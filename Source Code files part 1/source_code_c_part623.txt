rString,
	IN	UCHAR						AtmAddrTypeLen
);

EXTERN
NDIS_STATUS
AtmArpSendPacketOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec	OPTIONAL,
	IN	PATMARP_FLOW_INFO			pFlowInfo	OPTIONAL,
	IN	BOOLEAN						IsBroadcast
);

EXTERN
VOID
AtmArpQueuePacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpStartSendsOnVc(
	IN	PATMARP_VC					pVc
);

EXTERN
VOID
AtmArpSendPacketListOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pPacketList,
	IN	BOOLEAN						IsBroadcast
);

EXTERN
PATMARP_IP_ENTRY
AtmArpLearnIPToAtm(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS UNALIGNED *		pIPAddress,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	BOOLEAN						IsStaticEntry
);

EXTERN
NDIS_STATUS
AtmArpQueuePacketOnIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

BOOLEAN
AtmArpAtmEntryIsReallyClosing(
	IN PATMARP_ATM_ENTRY		pAtmEntry
);

EXTERN
PATMARP_ATM_ENTRY
AtmArpSearchForAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	AE_REFTYPE					RefType,
	IN	BOOLEAN						CreateNew
);

EXTERN
PATMARP_IP_ENTRY
AtmArpSearchForIPAddress(
	IN PATMARP_INTERFACE			pInterface,
	IN IP_ADDRESS UNALIGNED *		pIPAddress,
	IN IE_REFTYPE					RefType,
	IN BOOLEAN						IsBroadcast,
	IN BOOLEAN						CreateNew
);

EXTERN
VOID
AtmArpAbortIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpInvalidateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
);

EXTERN
VOID
AtmArpCloseVCsOnAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
);

EXTERN
VOID
AtmArpResolveIpEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpCleanupArpTable(
	IN PATMARP_INTERFACE			pInterface
);

//
//  --------------- from arpwmi.c -----------------------------
//
#ifdef ATMARP_WMI

EXTERN
PATMARP_WMI_GUID
AtmArpWmiFindGuid(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	OUT	PULONG						pGuidDataSize
);

EXTERN
NTSTATUS
AtmArpWmiRegister(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						RegistrationType,
	IN	PWMIREGINFO					pWmiRegInfo,
	IN	ULONG						WmiRegInfoSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiQueryAllData(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	PWNODE_ALL_DATA				pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiQuerySingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiChangeSingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiChangeSingleItem(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_ITEM			pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiSetEventStatus(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	BOOLEAN						bEnabled
);

EXTERN
NTSTATUS
AtmArpWmiDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

EXTERN
VOID
AtmArpWmiInitInterface(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_WMI_GUID			GuidList,
	IN	ULONG						NumberOfGuids
);

EXTERN
VOID
AtmArpWmiShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
NTSTATUS
AtmArpWmiSetTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

NTSTATUS
AtmArpWmiGetAddressList(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	LOCKOUT,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
VOID
AtmArpWmiEnableEventTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
);

EXTERN
NTSTATUS
AtmArpWmiSetTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
VOID
AtmArpWmiEnableEventTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
);

EXTERN
VOID
AtmArpWmiSendTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						IndicationCode,
	IN	ULONG						IndicationSubCode
);

EXTERN
NTSTATUS
AtmArpWmiSetStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
PATMARP_INTERFACE
AtmArpWmiGetIfByName(
	IN	PWSTR						pIfName,
	IN	USHORT						IfNameLength
);

#endif // ATMARP_WMI

//
//  --------------- from callmgr.c ----------------------------
//
EXTERN
VOID
AtmArpCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
);

EXTERN
NDIS_STATUS
AtmArpOpenCallMgr(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCloseCallMgr(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpRegisterSaps(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeregisterSaps(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
NDIS_STATUS
AtmArpMakeCall(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PNDIS_PACKET				pPacketToBeQueued	OPTIONAL
);

EXTERN
VOID
AtmArpFillCallParameters(
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						ParametersSize,
	IN	PATM_ADDRESS				pCalledAddress,
	IN	PATM_ADDRESS				pCallingAddress,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	BOOLEAN						IsPMP,
	IN	BOOLEAN						IsMakeCall
);

EXTERN
VOID
AtmArpCloseCall(
	IN	PATMARP_VC					pVc
);

EXTERN
NDIS_STATUS
AtmArpCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmArpDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmArpIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
);

EXTERN
VOID
AtmArpCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
VOID
AtmArpIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpAddParty(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

EXTERN
VOID
AtmArpMcTerminateMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

#endif // IPMCAST

EXTERN
VOID
AtmArpIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmArpQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmArpOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
);

EXTERN
VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN
VOID
AtmArpRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
);

EXTERN
VOID
AtmArpDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
);

EXTERN
VOID
AtmArpMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpMcMakeCallComplete(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	NDIS_STATUS					Status
);

#endif // IPMCAST

EXTERN
VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN
VOID
AtmArpCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
);

EXTERN
VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmArpDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
);

EXTERN
VOID
AtmArpModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
NDIS_STATUS
AtmArpCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
);

EXTERN
VOID
AtmArpCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
VOID
AtmArpGetAtmAddress(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpHandleGetAddressesComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
VOID
AtmArpUpdateAddresses(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						AddThem
);

EXTERN
VOID
AtmArpHandleModAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	ULONG						Oid
);

EXTERN
NDIS_STATUS
AtmArpSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);


//
//  --------------- from init.c ----------------------------
//
//

EXTERN
VOID
AtmArpInitGlobals(
);

EXTERN
NDIS_STATUS
AtmArpInitIpOverAtm(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpUnloadProtocol(
	VOID
);

//
//  --------------- from ioctl.c ------------------------------
//
//
#if !BINARY_COMPATIBLE
#ifdef CUBDD

EXTERN
NTSTATUS
AtmArpInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

EXTERN
NTSTATUS
AtmArpIoctlArpRequest(
	IN	PATMARP_INTERFACE			pInterface	OPTIONAL,
	IN	PIRP						pIrp
);

EXTERN
VOID
AtmArpCompleteArpIrpList(
	IN	SINGLE_LIST_ENTRY			ListHead,
	IN	PATM_ADDRESS				pAtmAddress	OPTIONAL
);
#endif // CUBDD
#endif // !BINARY_COMPATIBLE

//
//  --------------- from ipmcast.c ----------------------------
//
//

#ifdef DHCP_OVER_ATM

EXTERN
NDIS_STATUS
AtmArpSendBroadcast(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
NDIS_STATUS
AtmArpSendToDHCPServer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
NDIS_STATUS
AtmArpSendToDHCPClient(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

#endif // DHCP_OVER_ATM

#ifdef IPMCAST

EXTERN
UINT
AtmArpMcAddAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);

EXTERN
UINT
AtmArpMcDelAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);

EXTERN
VOID
AtmArpMcHandleJoinOrLeaveCompletion(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask,
	IN	BOOLEAN						IsJoin
);

EXTERN
VOID
AtmArpMcStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpMcSendPendingJoins(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpMcRevalidateAll(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpMcHandleMARSFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsRegnFailure
);

EXTERN
VOID
AtmArpMcSendToMARS(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpMcSendJoinOrLeave(
	IN	PATMARP_INTERFACE			pInterface,
	IN	USHORT						OpCode,
	IN	PIP_ADDRESS					pIPAddress 	OPTIONAL,
	IN	IP_ADDRESS					Mask
);

EXTERN
VOID
AtmArpMcSendRequest(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PIP_ADDRESS					pIPAddress
);

EXTERN
PATMARP_IPMC_ATM_ENTRY
AtmArpMcLookupAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmList,
	IN	PUCHAR						pAtmNumber,
	IN	ULONG						AtmNumberLength,
	IN	ATM_ADDRESSTYPE				AtmNumberType,
	IN	PUCHAR						pAtmSubaddress,
	IN	ULONG						AtmSubaddressLength,
	IN	BOOLEAN						CreateNew
);

EXTERN
VOID
AtmArpMcUnlinkAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,	LOCKIN LOCKOUT
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

EXTERN
VOID
AtmArpMcUpdateConnection(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

#endif // IPMCAST

//
//  --------------- from marspkt.c ----------------------------
//
//

#ifdef IPMCAST

EXTERN
PUCHAR
AtmArpMcMakePacketCopy(
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	ULONG						TotalLength
);

EXTERN
BOOLEAN
AtmArpMcProcessPacket(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						TotalLength,
	IN	ULONG						FirstBufferLength
);

EXTERN
BOOLEAN
AtmArpMcPreprocess(
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	OUT	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleMulti(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleMigrate(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleJoinOrLeave(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleNak(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleGroupListReply(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleRedirectMap(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);


#endif // IPMCAST

//
//  --------------- from ntentry.c ----------------------------
//
//

EXTERN
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
);

#if !BINARY_COMPATIBLE

EXTERN
NTSTATUS
Dispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

NTSTATUS
AtmArpHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
);

#endif // !BINARY_COMPATIBLE

EXTERN
VOID
Unload(
	IN	PDRIVER_OBJECT				pDriverObject
);


//
//  --------------- from qos.c ------------------------------
//
//
EXTERN
VOID
AtmArpQosGetPacketSpecs(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC			*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC			*ppFilterSpec
);

EXTERN
BOOLEAN
AtmArpQosDoFlowsMatch(
	IN	PVOID						Context,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FLOW_SPEC			pTargetFlowSpec
);

EXTERN
BOOLEAN
AtmArpQosDoFiltersMatch(
	IN	PVOID						Context,
	IN	PATMARP_FILTER_SPEC			pFilterSpec,
	IN	PATMARP_FILTER_SPEC			pTargetFilterSpec
);

#ifdef GPC

EXTERN
VOID
AtmArpGpcInitialize(
	VOID
);

EXTERN
VOID
AtmArpGpcShutdown(
	VOID
);


EXTERN
VOID
AtmArpGpcAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_HANDLE					GpcCfInfoHandle,
	IN	PTC_INTERFACE_ID			InterfaceInfo,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pCfInfo,
	OUT	PGPC_CLIENT_HANDLE			pClientCfInfoContext
);

EXTERN
VOID
AtmArpGpcModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pNewCfInfo
);

EXTERN
VOID
AtmArpGpcRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext
);

EXTERN
GPC_STATUS
AtmArpGpcValidateCfInfo(
	IN	PVOID						pCfInfo,
	IN	ULONG						CfInfoSize
);

EXTERN
GPC_STATUS
AtmArpGpcGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       	ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING        InstanceName
);

#endif // GPC

//
//  --------------- from space.c ----------------------------
//
//
EXTERN ATMARP_GLOBALS		AtmArpGlobalInfo;
EXTERN PATMARP_GLOBALS		pAtmArpGlobalInfo;
EXTERN NDIS_PROTOCOL_CHARACTERISTICS AtmArpProtocolCharacteristics;
EXTERN NDIS_CLIENT_CHARACTERISTICS AtmArpClientCharacteristics;
EXTERN ATM_BLLI_IE AtmArpDefaultBlli;
EXTERN ATM_BHLI_IE AtmArpDefaultBhli;
EXTERN AA_PKT_LLC_SNAP_HEADER AtmArpLlcSnapHeader;
#ifdef QOS_HEURISTICS
EXTERN ATMARP_FLOW_INFO	AtmArpDefaultFlowInfo;
#endif // QOS_HEURISTICS
#ifdef GPC
EXTERN GPC_CLASSIFY_PACKET_HANDLER AtmArpGpcClassifyPacketHandler;
EXTERN GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER AtmArpGpcGetCfInfoClientContextHandler;
#endif
#ifdef IPMCAST
EXTERN AA_MC_PKT_TYPE1_SHORT_HEADER AtmArpMcType1ShortHeader;
EXTERN AA_MARS_PKT_FIXED_HEADER	AtmArpMcMARSFixedHeader;
#endif // IPMCAST

EXTERN ULONG	AtmArpMaxTimerValue[];
EXTERN ULONG	AtmArpTimerListSize[];
EXTERN ULONG	AtmArpTimerPeriod[];

#ifdef ATMARP_WMI

EXTERN ATMARP_WMI_GUID		AtmArpGuidList[];
EXTERN ULONG				AtmArpGuidCount;

#endif // ATMARP_WMI

#ifdef BACK_FILL
EXTERN  ULONG	AtmArpDoBackFill;
EXTERN  ULONG	AtmArpBackFillCount;
#endif // BACK_FILL


//
//  --------------- from timeouts.c ----------------------------
//
//
EXTERN
VOID
AtmArpServerConnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpServerRefreshTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpAddressResolutionTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIPEntryInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpPVCInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIPEntryAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpVcAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpNakDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpMcMARSRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcMARSReconnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcMARSKeepAliveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcJoinOrLeaveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcRevalidationDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcPartyRetryDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);


#endif // IPMCAST

//
//  --------------- from utils.c ----------------------------
//
//

EXTERN
VOID
AtmArpSetMemory(
	IN	PUCHAR						pStart,
	IN	UCHAR						Value,
	IN	ULONG						NumberOfBytes
);

EXTERN
ULONG
AtmArpMemCmp(
	IN	PUCHAR						pString1,
	IN	PUCHAR						pString2,
	IN	ULONG						Length
);

EXTERN
LONG
AtmArpRandomNumber(
	VOID
);

EXTERN
VOID
AtmArpCheckIfTimerIsInActiveList(
	IN	PATMARP_TIMER				pTimerToCheck,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PVOID						pStruct,
	IN	PCHAR						pStructName
	);

EXTERN
PATMARP_VC
AtmArpAllocateVc(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateVc(
	IN	PATMARP_VC					pVc
);

EXTERN
VOID
AtmArpReferenceVc(
	IN	PATMARP_VC					pVc
);

EXTERN
ULONG
AtmArpDereferenceVc(
	IN	PATMARP_VC					pVc
);

EXTERN
PATMARP_ATM_ENTRY
AtmArpAllocateAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsMulticast
);

EXTERN
VOID
AtmArpDeallocateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmArpReferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
ULONG
AtmArpDereferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
PATMARP_IP_ENTRY
AtmArpAllocateIPEntry(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpReferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
ULONG
AtmArpDereferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);


EXTERN
PATMARP_INTERFACE
AtmArpAllocateInterface(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
VOID
AtmArpDeallocateInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpReferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
ULONG
AtmArpDereferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpReferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
);

EXTERN
ULONG
AtmArpDereferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
);

EXTERN
VOID
AtmArpStartTimer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_TIMER				pTimer,
	IN	ATMARP_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						Context
);

EXTERN
BOOLEAN
AtmArpStopTimer(
	IN	PATMARP_TIMER				pTimer,
	IN	PATMARP_INTERFACE			pInterface
);

#ifdef NO_TIMER_MACRO

EXTERN
VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER				pTimer
);

#endif // NO_TIMER_MACRO

EXTERN
VOID
AtmArpTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
PNDIS_PACKET
AtmArpAllocatePacket(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpFreePacket(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pPacket
);

EXTERN
PNDIS_BUFFER
AtmArpGrowHeaders(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType
);

EXTERN
PNDIS_BUFFER
AtmArpAllocateHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmArpFreeHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	AA_HEADER_TYPE				HdrType
);

EXTERN
VOID
AtmArpDeallocateHeaderBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
PNDIS_BUFFER
AtmArpAllocateProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmArpFreeProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer
);

EXTERN
NDIS_STATUS
AtmArpInitProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpLinkVcToAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmArpUnlinkVcFromAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	BOOLEAN						bDerefAtmEntry
);


EXTERN
VOID
AtmArpUnlinkIpEntryFromAtmEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
PNDIS_BUFFER
AtmArpCopyToNdisBuffer(
	IN	PNDIS_BUFFER				pDestBuffer,
	IN	PUCHAR						pDataSrc,
	IN	UINT						LenToCopy,
	IN OUT	PUINT					pOffsetInBuffer
);

PATMARP_INTERFACE
AtmArpAddInterfaceToAdapter (
	IN	PATMARP_ADAPTER				pAdapter,
	IN	NDIS_HANDLE					LISConfigHandle, // Handle to per-LIS config
	IN	NDIS_STRING					*pIPConfigString
	);

#if DBG

//
// Following are versions of addref/deref which tracks referenc types.
//

EXTERN
VOID
AtmArpReferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType
);

EXTERN
ULONG
AtmArpDereferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
);


EXTERN
VOID
AtmArpReferenceIPEntryEx(
	IN 	PATMARP_IP_ENTRY			pIpEntry,
	IN	IE_REFTYPE 					RefType
);

EXTERN
ULONG
AtmArpDereferenceIPEntryEx(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN 	IE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
);

EXTERN
VOID
AtmArpReferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
);

EXTERN
ULONG
AtmArpDereferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
);

#endif // DBG

#endif	// _ATMARP_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ATM/ARP module

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		06-13-96	created based on Call Manager debug.h

Notes:

--*/

#ifndef _AADEBUG__H
#define _AADEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define AAD_EXTRA_LOUD		20
#define AAD_VERY_LOUD		10
#define AAD_LOUD			 8
#define AAD_INFO			 6
#define AAD_WARNING		 	 4
#define AAD_ERROR			 2
#define AAD_FATAL			 0

//
//  Data traffic debug message flags
//
#define AAD_DATA_IN			0x01
#define AAD_DATA_OUT		0x02
#define AAD_TRACK_BIG_SENDS	0x04

#ifdef PERF

typedef struct _AAD_SEND_LOG_ENTRY
{
	ULONG				Flags;
	PNDIS_PACKET		pNdisPacket;
	ULONG				Destination;
	ULONG				Length;
	LARGE_INTEGER		SendTime;
	LARGE_INTEGER		SendCompleteTime;
} AAD_SEND_LOG_ENTRY, *PAAD_SEND_LOG_ENTRY;

#define AAD_SEND_FLAG_UNUSED					0x00000000
#define AAD_SEND_FLAG_WAITING_COMPLETION		0x00000001
#define AAD_SEND_FLAG_COMPLETED					0x00000002
#define AAD_SEND_FLAG_RCE_GIVEN					0x00000100


extern VOID
AadLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
);

extern VOID
AadLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
AadLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
AadLogSendAbort(
	IN	PNDIS_PACKET	pNdisPacket
);

extern LARGE_INTEGER	TimeFrequency;


#endif // PERF

#if DBG_SPIN_LOCK

typedef struct _ATMARP_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	ULONG					TouchedByFileNumber;
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} ATMARP_LOCK, *PATMARP_LOCK;

#define AAL_SIG	'KCOL'

extern
VOID
AtmArpAllocateSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
AtmArpAcquireSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
AtmArpReleaseSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)		\
			{								\
				if ((INT)(Count) < 0)		\
				{							\
					DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",	\
						Count, __FILE__, __LINE__);		\
					DbgBreakPoint();					\
				}							\
			}
#else
#define CHECK_LOCK_COUNT(Count)

#define ATMARP_LOCK		NDIS_SPIN_LOCK
#define PATMARP_LOCK	PNDIS_SPIN_LOCK

#endif	// DBG_SPIN_LOCK

#if DBG

extern INT	AaDebugLevel;	// the value here defines what the user wants to see
							// all messages with this urgency and higher are enabled
extern INT	AaMcDebugLevel;
extern INT	AaDataDebugLevel;
extern INT	AadBigDataLength;

#define AADEBUGP(lev, stmt)	\
		{ if ((lev) <= AaDebugLevel) { DbgPrint("AtmArpC: "); DbgPrint stmt; }}

#define AADEBUGPDUMP(lev, pBuf, Len)	\
		{ if ((lev) <= AaDebugLevel) { DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len)); }}

#define AADEBUGPATMADDR(lev, pString, pAddr)		\
		{ if ((lev) <= AaDebugLevel) { DbgPrintAtmAddr(pString, pAddr); } }

#define AADEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)		\
		{ if ((lev) <= AaDebugLevel) { DbgPrintMapping(pString, (PUCHAR)pIpAddr, pAtmAddr); } }

#define AAMCDEBUGP(lev, stmt)	\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrint("AtmArpC: "); DbgPrint stmt; }}

#define AAMCDEBUGPDUMP(lev, pBuf, Len)	\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len)); }}

#define AAMCDEBUGPATMADDR(lev, pString, pAddr)		\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintAtmAddr(pString, pAddr); } }

#define AAMCDEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)		\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintMapping(pString, (PUCHAR)pIpAddr, pAtmAddr); } }

#define AA_ASSERT(exp)	\
		{ if (!(exp)) { DbgPrint("ATMARPC: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__); DbgBreakPoint(); } }

#define AA_STRUCT_ASSERT(s, t)\
				if ((s)->t##_sig != t##_signature) {\
					DbgPrint("Structure assertion failure for type " #t " in file %s, line %d\n", __FILE__, __LINE__);	\
					DbgBreakPoint();	\
				}

#if DBG_CO_SEND

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			AaCoSendPackets(_VcHandle, _PktArray, _Count)

#else

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif // DBG_CO_SEND

extern INT	AaSkipAll;		// Used as an emergency exit mechanism!

//
// Memory Allocation/Freeing Audit:
//

//
// The AAD_ALLOCATION structure stores all info about one allocation
//
typedef struct _AAD_ALLOCATION {

		ULONG					Signature;
		struct _AAD_ALLOCATION	*Next;
		struct _AAD_ALLOCATION *Prev;
		ULONG					FileNumber;
		ULONG					LineNumber;
		ULONG					Size;
		PVOID					Location;	// where the returned pointer was put
		union
		{
			ULONGLONG			Alignment;
			UCHAR				UserData;
		};

} AAD_ALLOCATION, *PAAD_ALLOCATION;

#define AAD_MEMORY_SIGNATURE	(ULONG)'CSII'

extern
PVOID
AaAuditAllocMem (
	PVOID		pPointer,
	ULONG		Size,
	ULONG		FileNumber,
	ULONG		LineNumber
);

extern
VOID
AaAuditFreeMem(
	PVOID		Pointer
);

extern
VOID
AaAuditShutdown(
	VOID
);

extern
VOID
DbgPrintHexDump(
	PUCHAR		pBuffer,
	ULONG		Length
);

extern
VOID
DbgPrintAtmAddr(
	PCHAR			pString,
	ATM_ADDRESS UNALIGNED *	pAddr
);

extern
VOID
DbgPrintMapping(
	PCHAR			pString,
	UCHAR UNALIGNED *	pIpAddr,
	ATM_ADDRESS UNALIGNED *	pAddr
);


extern
VOID
AaCoSendPackets(
	IN	NDIS_HANDLE			NdisVcHandle,
	IN	PNDIS_PACKET *		PacketArray,
	IN	UINT				PacketCount
);

#else
//
// No debug
//
#define AADEBUGP(lev, stmt)
#define AADEBUGPDUMP(lev, pBuf, Len)
#define AADEBUGPATMADDR(lev, pString, pAddr)
#define AADEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)
#define AAMCDEBUGP(lev, stmt)
#define AAMCDEBUGPDUMP(lev, pBuf, Len)
#define AAMCDEBUGPATMADDR(lev, pString, pAddr)
#define AAMCDEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)
#define AA_ASSERT(exp)
#define AA_STRUCT_ASSERT(s, t)

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif	// DBG




#if DBG

	#define AA_REF_AE(_pAE, _RefType) \
		AtmArpReferenceAtmEntryEx(_pAE, _RefType)
	
	#define AA_DEREF_AE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntryEx(_pAE, _RefType, TRUE)
	
	#define AA_DEREF_AE_NO_DELETE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntryEx(_pAE, _RefType, FALSE)
	
	#define AA_REF_IE(_pIE, _RefType) \
		AtmArpReferenceIPEntryEx(_pIE, _RefType)
	
	#define AA_DEREF_IE(_pIE, _RefType) \
		AtmArpDereferenceIPEntryEx(_pIE, _RefType, TRUE)
	
	#define AA_DEREF_IE_NO_DELETE(_pIE, _RefType) \
		AtmArpDereferenceIPEntryEx(_pIE, _RefType, FALSE)

	#define AA_SWITCH_IE_REFTYPE(_pIE, _FromRefType, _ToRefType) \
		( AtmArpReferenceIPEntryEx(_pIE, _ToRefType) \
		 ,AtmArpDereferenceIPEntryEx(_pIE, _FromRefType, FALSE))

	#define AA_REF_JE(_pJE)	\
		AtmArpReferenceJoinEntryEx(_pJE, (_FILENUMBER << 16) | __LINE__)
	
	#define AA_DEREF_JE(_pJE)	\
		AtmArpDereferenceJoinEntryEx(_pJE, (_FILENUMBER << 16) | __LINE__)

#else  // !DBG

	#define AA_REF_AE(_pAE, _RefType) \
		AtmArpReferenceAtmEntry(_pAE)
	
	#define AA_DEREF_AE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntry(_pAE)
	
	#define AA_DEREF_AE_NO_DELETE(_pAE, _RefType) \
		((_pAE)->RefCount--)

	#define AA_REF_IE(_pIE, _RefType) \
		AtmArpReferenceIPEntry(_pIE)
	
	#define AA_DEREF_IE(_pIE, _RefType) \
		AtmArpDereferenceIPEntry(_pIE)
	
	#define AA_DEREF_IE_NO_DELETE(_pIE, _RefType) \
		((_pIE)->RefCount--)
	
	#define AA_SWITCH_IE_REFTYPE(_pIE, _FromRefType, _ToRefType) \
			((void)(0))

	#define AA_REF_JE(_pJE)	\
		AtmArpReferenceJoinEntry(_pJE)
	
	#define AA_DEREF_JE(_pJE)	\
		AtmArpDereferenceJoinEntry(_pJE)


#endif // !DBG


#if DBG

#define AA_CHECK_TIMER_IN_ACTIVE_LIST(_pTimer, _pIf, _pStruct, _pName)	\
	AtmArpCheckIfTimerIsInActiveList(									\
		_pTimer,														\
		_pIf,															\
		_pStruct,														\
		_pName															\
		)

#else

#define AA_CHECK_TIMER_IN_ACTIVE_LIST(_pTimer, _pIf, _pStruct, _pName)

#endif // DBG

#endif // _AADEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	Handler routines for Internal IOCTLs, including IOCTL_ATMARP_REQUEST
	to resolve an IP address to an ATM address.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-16-96    Created

Notes:

--*/

#include <precomp.h>
#include "ioctl.h"

#define _FILENUMBER 'TCOI'


#if !BINARY_COMPATIBLE

NTSTATUS
AtmArpHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;

	PUCHAR				pBuf;  
	UINT				BufLen;
	// PINTF				pIntF	= NULL;

	pIrp->IoStatus.Information = 0;
	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

	AADEBUGP(AAD_INFO,
		 ("AtmArpHandleIoctlRequest: Code = 0x%lx\n",
			pIrpSp->Parameters.DeviceIoControl.IoControlCode));
					
	
	return Status;
}

#endif // !BINARY_COMPATIBLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\ioctl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for the atmarp client.

Environment:

    Kernel mode

Revision History:

	8/14/1998 JosephJ Created

--*/

#ifndef	_IOCTL_
#define	_IOCTL_

#define	ARP_CLIENT_DOS_DEVICE_NAME		L"\\\\.\\ATMARPC"

#define	ARPC_IOCTL_QUERY_VERSION		CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_INTERFACES		CTL_CODE(FILE_DEVICE_NETWORK, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_INTERFACE		CTL_CODE(FILE_DEVICE_NETWORK, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_IPENTRY		CTL_CODE(FILE_DEVICE_NETWORK, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_ATMENTR		CTL_CODE(FILE_DEVICE_NETWORK, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_ADD_ARPENTRY			CTL_CODE(FILE_DEVICE_NETWORK, 105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ARPC_IOCTL_VERSION 0x0

//
// Sames as COUNTED_STRING defined in  sdk\inc\ntfsprop.h
//
typedef struct
{
	USHORT Length;
	WCHAR Text[1];
} ATMARPC_INTERFACE_NAME, *PATMARPC_INTERFACE_NAME;

//
// All Ptrs are represented by offsets from the beginning of the structures.
//
typedef	UNICODE_STRING	INTERFACE_NAME, *PINTERFACE_NAME;

typedef struct
{
	ATM_ADDRESS Addr;
	ATM_ADDRESS SubAddr;
} ATM_ADDRESS_PAIR;


typedef struct
{
	UINT			NumberOfInterfaces;
	ATMARPC_INTERFACE_NAME	Interfaces; // The interfaces are strung together.
} ATMARPC_INTERFACES, *PATMARPC_INTERFACES;


typedef struct
{
	enum
	{
		SIG_ATMARPC_INTERFACE_INFO,
		SIG_ATMARPC_IP_INFO,
		SIG_ATMARPC_ATM_INFO
	} Sig;
	UINT TotalSize;
	UINT NeededSize;
	UINT InterfaceNameOffset;
} ATMARPC_IOCTL_HEADER;

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	ULONG					State;
	UINT					NumLocalIPAddrs;
	UINT 					LocalIPAddrsOffset;
	UINT					NumDestIPAddrs;
	UINT					DestIPAddrsOffset;
	UINT					NumDestAtmAddrs;
	UINT					DestAtmAddrsOffset;
} ATMARPC_INTERFACE_INFO;

#define ATMARPC_GET_LOCAL_IP_LIST(_pInterfaceInfo) 					\
		((IPAddr*)  (  ((BYTE*)(_pInterfaceInfo))					\
						  + (_pInterfaceInfo)->LocalIPAddrsOffset))

#define ATMARPC_GET_DEST_IP_LIST(_pInterfaceInfo) 					\
		((IPAddr*)  (  ((BYTE*)(_pInterfaceInfo))					\
						  + (_pInterfaceInfo)->DestIPAddrsOffset))

#define ATMARPC_GET_DEST_ATM_LIST(_pInterfaceInfo)					\
		((ATM_ADDRESS_PAIR*)  (  ((BYTE*)(_pInterfaceInfo))			\
						  + (_pInterfaceInfo)->DestAtmAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	IPAddr 			   	IPAddress;
	ULONG					State;
	UINT 				   	NumAtmEntries;
	UINT					AtmAddrsOffset;
} ATMARPC_DEST_IP_INFO;

#define ATMARPC_GET_DEST_ATM_LIST_FOR_IP(_pIPInfo)					\
		((ATM_ADDRESS_PAIR*)  (  ((BYTE*)(_pIPInfo))				\
						  + (_pIPInfo)->AtmAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	ULONG					State;
	ATM_ADDRESS_PAIR		AtmAddress;
	UINT					NumIPEntries;
	UINT					IPAddrsOffset;
} ATMARPC_DEST_ATM_INFO;

#define ATMARPC_GET_DEST_IP_LIST_FOR_ATM(_pAtmInfo)					\
		((IPAddr*)  (  ((BYTE*)(_pAtmInfo))						\
						  + (_pAtmInfo)->IPAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	IPAddr					IPAddress;
	ATM_ADDRESS_PAIR 		AtmAddress;
} ATMARPC_ARP_COMMAND;

#endif	// _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	init.c 

Abstract:

	Initialization and Termination routines for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'TINI'

VOID
AtmArpInitGlobals(
)
/*++

Routine Description:

	Initialize all our global data structures.

Arguments:

	None

Return Value:

	None

--*/
{

	AA_SET_MEM(pAtmArpGlobalInfo, 0, sizeof(ATMARP_GLOBALS));

#if DBG
	pAtmArpGlobalInfo->aag_sig = aag_signature;
#ifdef GPC
	pAtmArpGlobalInfo->aaq_sig = aaq_signature;
#endif // GPC
#endif // DBG

	AA_INIT_GLOBAL_LOCK(pAtmArpGlobalInfo);
	AA_INIT_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

}



NDIS_STATUS
AtmArpInitIpOverAtm(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Initialize IP/ATM data structures for the given interface.
	It is assumed that the configuration information for the interface
	has been read in.

	We allocate ATM Entries for the ARP servers, and the DHCP server,
	if configured.

Arguments:

	pInterface			- Pointer to ATMARP interface

Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we
	aren't able to do the allocation necessary.

--*/
{
	PATMARP_SERVER_ENTRY	pServerEntry;
	NDIS_STATUS				Status;
	PATMARP_SERVER_LIST		pServerList;

	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;

	do
	{
#ifdef IPMCAST
		if (pInterface->ArpServerList.ListSize != 0)
		{
			//
			//  Set the current ARP server to the first one in the list.
			//
			pInterface->pCurrentServer = pInterface->ArpServerList.pList;
		}

		if (pInterface->MARSList.ListSize != 0)
		{
			//
			//  Set the current MARS server to the first one in the list.
			//
			pInterface->pCurrentMARS = pInterface->MARSList.pList;
		}
	
		for (pServerList = &(pInterface->ArpServerList);
			 pServerList != NULL_PATMARP_SERVER_LIST;
			 /* NONE -- see end of for loop */
			 )
		{
			for (pServerEntry = pServerList->pList;
 				pServerEntry != NULL_PATMARP_SERVER_ENTRY;
 				pServerEntry = pServerEntry->pNext)
			{
				UCHAR	AddrTypeLen;
				UCHAR	SubaddrTypeLen;

				AddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMAddress));
				if (pServerEntry->ATMSubaddress.NumberOfDigits > 0)
				{
					SubaddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMSubaddress));
				}
				else
				{
					SubaddrTypeLen = 0;
				}

				pServerEntry->pAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pServerEntry->ATMAddress.Address,
						SubaddrTypeLen,
						pServerEntry->ATMSubaddress.Address,
						AE_REFTYPE_IF,
						TRUE	// Create new one if not found
						);

				if (pServerEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Must be a resource failure.
					//
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
				else
				{
					//
					//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
					//  the pAtmEntry for us.
					//
				}
			}

			//
			//  Move to the next list of servers, if any.
			//
			if (pServerList == &(pInterface->MARSList))
			{
				//
				//  We are done.
				//
				pServerList = NULL_PATMARP_SERVER_LIST;
			}
			else
			{
				//
				//  We just finished with the ARP Server list. Now process
				//  the MARS list.
				//
				pServerList = &(pInterface->MARSList);
			}
		}
#else
		if (pInterface->ArpServerList.ListSize > 0)
		{
			//
			//  Set the current ARP server to the first one in the list.
			//
			pInterface->pCurrentServer = pInterface->ArpServerList.pList;
	
			for (pServerEntry = pInterface->ArpServerList.pList;
 				pServerEntry != NULL_PATMARP_SERVER_ENTRY;
 				pServerEntry = pServerEntry->pNext)
			{
				UCHAR	AddrTypeLen;
				UCHAR	SubaddrTypeLen;

				AddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMAddress));
				if (pServerEntry->ATMSubaddress.NumberOfDigits > 0)
				{
					SubaddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMSubaddress));
				}
				else
				{
					SubaddrTypeLen = 0;
				}

				pServerEntry->pAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pServerEntry->ATMAddress.Address,
						SubaddrTypeLen,
						pServerEntry->ATMSubaddress.Address,
						AE_REFTYPE_IF,			
						TRUE	// Create new one if not found
						);

				if (pServerEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Must be a resource failure.
					//
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
				else
				{
					//
					//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
					//  the pAtmEntry for us.
					//
				}
			}
		}
#endif // IPMCAST

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

#ifdef DHCP_OVER_ATM
		if (pInterface->DhcpEnabled)
		{
			UCHAR		AddrTypeLen;

			AddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->DhcpServerAddress));

			pInterface->pDhcpServerAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pInterface->DhcpServerAddress.Address,
						0,					// Subaddress type+len
						(PUCHAR)NULL,		// Subaddress
						AE_REFTYPE_IF,
						TRUE				// Create new one if not found
						);

			if (pInterface->pDhcpServerAtmEntry == NULL_PATMARP_ATM_ENTRY)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
			else
			{
				//
				//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
				//  the pAtmEntry for us.
				//
			}
		}
#endif // DHCP_OVER_ATM
		break;
	}
	while (FALSE);

	return (Status);
}


VOID
AtmArpUnloadProtocol(
	VOID
)
/*++

Routine Description:

	Unloads the ATMARP protocol module. We unbind from all adapters,
	and deregister from NDIS as a protocol.

Arguments:

	None.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMARP_ADAPTER		pAdapter;

#if DBG
	AADEBUGP(AAD_INFO, ("AtmArpUnloadProtocol entered\n"));
#endif // DBG

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pAtmArpGlobalInfo->bUnloading)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		return;
	}

	pAtmArpGlobalInfo->bUnloading = TRUE;

#if 0
	//
	//  Commented this out because we don't need to handle
	//  the case of unclosed bindings ourselves. If there
	//  are any at this time, then NDIS will call our Unbind
	//  handlers for such bindings in response to our call
	//  to NdisDeregisterProtocol below.
	//
	while (pAtmArpGlobalInfo->pAdapterList != NULL_PATMARP_ADAPTER)
	{
		pAdapter = pAtmArpGlobalInfo->pAdapterList;
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		AADEBUGP(AAD_INFO, ("UnloadProtocol: Will unbind adapter 0x%x\n", pAdapter));

		AtmArpUnbindAdapterHandler(
				&Status,
				(NDIS_HANDLE)pAdapter,
				(NDIS_HANDLE)NULL		// No UnbindContext ==> Don't complete NdisUnbind
			);

		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for the unbind to complete
			//
			(VOID)AA_WAIT_ON_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));
		}

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

#endif // 0

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	NdisDeregisterProtocol(
		&Status,
		pAtmArpGlobalInfo->ProtocolHandle
		);


	AA_FREE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	AA_FREE_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

#ifdef GPC
	AtmArpGpcShutdown();
#endif // GPC

#if DBG
	AaAuditShutdown();
#endif // DBG

	AADEBUGP(AAD_LOUD,
		 ("UnloadProtocol: will deregister protocol now, ProtHandle 0x%x\n",
			pAtmArpGlobalInfo->ProtocolHandle));

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);

	AADEBUGP(AAD_LOUD, ("UnloadProtocol done\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\ipmcast.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ipmcast.c

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-27-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'CMPI'



#ifdef IPMCAST

UINT
AtmArpMcAddAddress(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	NOLOCKOUT,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	The IP layer wants us to start receiving packets directed to this
	IP Multicast address. This translates to sending a MARS_JOIN message
	to MARS, if conditions are fine.

	NOTE: For now, we support a non-zero Mask value (see below) only
	      for the special case of multicast promiscuous mode.

	NOTE: The caller is assumed to have acquired the IF lock, and it
	willl be released here.

Arguments:
	pInterface				- Pointer to ATMARP Interface on which to receive
							  multicast packets.
	IPAddress				- Identifies the multicast group to "Join"
	Mask					- 0 if a single address is being specified, otherwise
							  a mask that denotes a block of addresses being joined.

Return Value:

	(UINT)TRUE if the address was added successfully, (UINT)FALSE otherwise.

--*/
{
	BOOLEAN						ReturnValue;
	BOOLEAN						LockReleased;
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;

	//
	//  Initialize.
	//
	ReturnValue = (UINT)TRUE;
	LockReleased = TRUE;
	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;

	do
	{
		//
		//  We don't support "block join" yet, i.e. we allow only single
		//  IP addresses to be joined. Special exception: promiscuous mode
		//  multicast, or "join everything", indicated by the special values
		//  of IPAddress and Mask checked for below.
		//
		if (Mask != 0)
		{
	        if (IPAddress != IP_CLASSD_MIN || Mask != IP_CLASSD_MASK)
	        {
                ReturnValue = (UINT)FALSE;
                LockReleased = FALSE;
                break;
            }
		}

		//
		//  Fail this if the interface is going down.
		//
		if (pInterface->ArpTableUp == FALSE)
		{
			ReturnValue = (UINT)FALSE;
			LockReleased = FALSE;
			break;
		}

		//
		//  Check if this IP address range has been added before. If so,
		//  all we need to do is to bump up its ref count.
		//
		for (pJoinEntry = pInterface->pJoinList;
			 pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
			 pJoinEntry = pJoinEntry->pNextJoinEntry)
		{
			if (   pJoinEntry->IPAddress == IPAddress
				&& pJoinEntry->Mask == Mask)
			{
				break;
			}
		}

		if (pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			//
			//  This address is already added. Just add a reference to it.
			//
			pJoinEntry->JoinRefCount++;
			ReturnValue = (UINT)TRUE;
			LockReleased = FALSE;
			break;
		}


		//
		//  Allocate an entry for this IP address.
		//
		AA_ALLOC_MEM(pJoinEntry, ATMARP_IPMC_JOIN_ENTRY, sizeof(ATMARP_IPMC_JOIN_ENTRY));
		if (pJoinEntry == NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			ReturnValue = (UINT)FALSE;
			LockReleased = FALSE;
			break;
		}

		//
		//  Fill in this new entry, and add it to the multicast address list.
		//
		AA_SET_MEM(pJoinEntry, 0, sizeof(ATMARP_IPMC_JOIN_ENTRY));
#if DBG
		pJoinEntry->aamj_sig = aamj_signature;
#endif // DBG
		pJoinEntry->IPAddress = IPAddress;
		pJoinEntry->Mask = Mask;
		pJoinEntry->pInterface = pInterface;
		pJoinEntry->JoinRefCount = 1;
		pJoinEntry->RefCount = 1;

		pJoinEntry->pNextJoinEntry = pInterface->pJoinList;
		pInterface->pJoinList = pJoinEntry;

		//
		//  We proceed to send a Join only if we have completed registering with
		//  the MARS. This is because we need to have a Cluster Member Id before
		//  we can Join multicast groups. When registration completes, the
		//  Join operation will be triggered off.
		//
		if (AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED)
		{
			AA_SET_FLAG(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_JOINING);


			//
			//  Start the "Wait For Join completion" timer.
			//
			AtmArpStartTimer(
				pInterface,
				&(pJoinEntry->Timer),
				AtmArpMcJoinOrLeaveTimeout,
				pInterface->JoinTimeout,
				(PVOID)pJoinEntry
				);
			
			AA_REF_JE(pJoinEntry);	// McAddAddr: Wait for Join timer
			
			pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

			//
			//  Send off a MARS_JOIN for this IP address.
			//
			AtmArpMcSendJoinOrLeave(
				pInterface,
				AA_MARS_OP_TYPE_JOIN,
				&IPAddress,
				Mask
				);

			//
			//  IF lock is released within the above.
			//
		}
		else
		{
			pJoinEntry->Flags = AA_IPMC_JE_STATE_PENDING;
			AtmArpMcStartRegistration(
				pInterface
				);
			//
			//  IF lock is released within the above.
			//
		}
		break;

	}
	while (FALSE);

	if (!LockReleased)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

	AAMCDEBUGP(AAD_LOUD,
		("AtmArpMcAddAddress: pIf 0x%x, Addr 0x%x, Mask 0x%x, JoinEnt 0x%x, Ret %d\n",
				pInterface, IPAddress, Mask, pJoinEntry, ReturnValue));
			
	return (ReturnValue);
}



UINT
AtmArpMcDelAddress(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	NOLOCKOUT,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	Delete membership of the given multicast IP address group, on the specified
	interface. If this is the last surviving reference to this multicast group,
	we send off a MARS_LEAVE message to MARS, indicating that we don't want to
	receive packets directed to this address anymore.

	NOTE: The "Mask" parameter could theoretically be used to identify a block
	of IP addresses. We support it for the specific case of stopping promiscuous
	multicast receive mode.

	NOTE: The caller is assumed to have acquired the IF Lock, which will
	be released here.

Arguments:

	pInterface				- Pointer to ATMARP Interface on which to remove
							  multicast group membership.
	IPAddress				- Identifies the multicast group to "Leave"
	Mask					- 0 if a single address is being specified, otherwise
							  a mask that denotes a block of addresses being "leave"d.

Return Value:

	(UINT)TRUE if the given address was deleted successfully, (UINT)FALSE
	otherwise.

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY		*ppNextJoinEntry;
	UINT						ReturnValue;
	BOOLEAN						LockAcquired;
	BOOLEAN						WasRunning;
	ULONG						rc;
	
	//
	//  Initialize.
	//
	ReturnValue = (UINT)TRUE;
	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;
	LockAcquired = TRUE;

	do
	{
		//
		//  Get the entry corresponding to this IP address and mask.
		//
		ppNextJoinEntry = &(pInterface->pJoinList);
		while (*ppNextJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			if (   (*ppNextJoinEntry)->IPAddress == IPAddress
				&& (*ppNextJoinEntry)->Mask == Mask)
			{
				pJoinEntry = *ppNextJoinEntry;
				break;
			}
			ppNextJoinEntry = &((*ppNextJoinEntry)->pNextJoinEntry);
		}

		if (pJoinEntry == NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			//
			//  No entry for the given IP address!
			//
			ReturnValue = (UINT)TRUE;
			break;
		}

		//
		//  If we reached here, this call is successful.
		//
		ReturnValue = (UINT)TRUE;

		pJoinEntry->JoinRefCount--;

		if ((pJoinEntry->JoinRefCount == 0)		&&
		    (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_JOINED)))
		{
			//
			//  We just removed the last "Join" reference to this multicast group.
			//  If we are currently registered with MARS, send a MARS_LEAVE.
			//

			//
			//  First, stop any timer running on this entry.
			//
			WasRunning = AtmArpStopTimer(
							&(pJoinEntry->Timer),
							pInterface
							);

			if (AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED)
			{
				//
				//  Start the "Wait for Leave completion" timer on this entry.
				//
				AtmArpStartTimer(
					pInterface,
					&(pJoinEntry->Timer),
					AtmArpMcJoinOrLeaveTimeout,
					pInterface->LeaveTimeout,
					(PVOID)pJoinEntry
					);
				
				if (!WasRunning)
				{
					AA_REF_JE(pJoinEntry);	// Started Wait for Leave timer
				}

				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING);

				pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

				//
				//  Send off a MARS_LEAVE for this IP address.
				//
				AtmArpMcSendJoinOrLeave(
					pInterface,
					AA_MARS_OP_TYPE_LEAVE,
					&IPAddress,
					Mask
					);
				//
				//  IF Lock is released within the above.
				//
				LockAcquired = FALSE;
			}
			else
			{
				//
				//  We are not registered with MARS, meaning that
				//  (re)-registration is in progress. Since all Joins
				//  are invalidated and re-created at the end of registration,
				//  we don't have to send a LEAVE explicitly for this address.
				//

				//
				//  Remove this entry from the Join list, and free it.
				//
				*ppNextJoinEntry = pJoinEntry->pNextJoinEntry;

				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));

				if (WasRunning)
				{
					rc = AA_DEREF_JE(pJoinEntry);	// McDelAddr: Timer stopped
				}
				else
				{
					rc = pJoinEntry->RefCount;
				}

				if (rc != 0)
				{
					rc = AA_DEREF_JE(pJoinEntry);	// McDelAddr: get rid of entry
				}
				else
				{
					AA_ASSERT(FALSE);
				}

			}

		}
		//
		//  else this IP address has some references outstanding.
		//  Leave it as is.
		//

		break;
	}
	while (FALSE);

	if (LockAcquired)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

	return (ReturnValue);

}


VOID
AtmArpMcHandleJoinOrLeaveCompletion(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask,
	IN	BOOLEAN						IsJoin
)
/*++

Routine Description:

	This is called when we receive a JOIN or LEAVE that acknowledges
	one that we sent earlier.

Arguments:

	pInterface			- Pointer to Interface
	IPAddress			- The group being joined/left
	IsJoin				- Is this a Join completion?

Return Value:

	None

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY		*ppNextJoinEntry;
	ULONG						NewFlags;			// For Join Entry
	BOOLEAN						SendJoinOrLeave;
	ULONG						rc;

	//
	//  Find the JOIN Entry for this address
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	SendJoinOrLeave = FALSE;

	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;
	ppNextJoinEntry = &(pInterface->pJoinList);
	while (*ppNextJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
	{
		if (  (*ppNextJoinEntry)->IPAddress == IPAddress
			&&(*ppNextJoinEntry)->Mask == Mask)
		{
			pJoinEntry = *ppNextJoinEntry;
			break;
		}
		ppNextJoinEntry = &((*ppNextJoinEntry)->pNextJoinEntry);
	}

	if (pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
	{
		BOOLEAN		WasRunning;

		WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);

		if (WasRunning)
		{
			rc = AA_DEREF_JE(pJoinEntry);	// Join Complete, stopped timer
			AA_ASSERT(rc != 0);
		}

		if (IsJoin)
		{
			AAMCDEBUGP(AAD_INFO,
				("JOINed %d.%d.%d.%d, pJoinEntry 0x%x, Flags 0x%x, JoinRefCount %d\n",
					((PUCHAR)&IPAddress)[0],
					((PUCHAR)&IPAddress)[1],
					((PUCHAR)&IPAddress)[2],
					((PUCHAR)&IPAddress)[3],
					pJoinEntry, pJoinEntry->Flags, pJoinEntry->JoinRefCount
				));

			AA_SET_FLAG(pJoinEntry->Flags,
						AA_IPMC_JE_STATE_MASK,
						AA_IPMC_JE_STATE_JOINED);

			//
			//  Check if IP had deleted this address while we
			//  were joining it.
			//
			if (pJoinEntry->JoinRefCount == 0)
			{
				//
				//  Send a Leave.
				//
				SendJoinOrLeave = TRUE;
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING);
			}

		}
		else
		{
			//
			//  This signifies completion of a LEAVE process.
			//
			AAMCDEBUGP(AAD_INFO,
				("LEFT %d.%d.%d.%d, pJoinEntry 0x%x, Flags 0x%x, RefCount %d\n",
					((PUCHAR)&IPAddress)[0],
					((PUCHAR)&IPAddress)[1],
					((PUCHAR)&IPAddress)[2],
					((PUCHAR)&IPAddress)[3],
					pJoinEntry, pJoinEntry->Flags, pJoinEntry->JoinRefCount
				));

			//
			//  IP might have re-joined this address while we were
			//  waiting for completion of leave.
			//
			if (pJoinEntry->JoinRefCount != 0)
			{
				//
				//  Send a Join.
				//
				SendJoinOrLeave = TRUE;
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
			}
			else
			{
				//
				//  Unlink Join Entry from list.
				//
				*ppNextJoinEntry = pJoinEntry->pNextJoinEntry;
			
				//
				//  And free it.
				//
				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));
				rc = AA_DEREF_JE(pJoinEntry);	// Leave Complete - get rid of entry
				AA_ASSERT(SendJoinOrLeave == FALSE);
			}
		}
	}

	if (SendJoinOrLeave)
	{
		USHORT		Opcode;

		//
		//  Start the "Wait for Leave completion" timer on this entry.
		//
		AtmArpStartTimer(
			pInterface,
			&(pJoinEntry->Timer),
			AtmArpMcJoinOrLeaveTimeout,
			pInterface->LeaveTimeout,
			(PVOID)pJoinEntry
			);
		
		AA_REF_JE(pJoinEntry);	// Wait for Join/Leave completion

		pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

		Opcode = (IsJoin? AA_MARS_OP_TYPE_LEAVE: AA_MARS_OP_TYPE_JOIN);
		AtmArpMcSendJoinOrLeave(
			pInterface,
			Opcode,
			&IPAddress,
			Mask
			);
		//
		//  IF Lock is released within the above.
		//
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
}



VOID
AtmArpMcStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Start registration with the MARS, if all pre-conditions are met:
	0. AdminState for this Interface is UP
	1. Registration isn't done or in progress
	2. The ATM Interface is up
	3. Atleast one MARS ATM address is known (configured).

	NOTE: The caller is assumed to have locked the Interface structure,
	and the lock will be released here.

Arguments:

	pInterface			- Interface on which MARS registration is to be done.

Return Value:

	None

--*/
{
	BOOLEAN		WasRunning;

	AAMCDEBUGP(AAD_LOUD,
		 ("McStartReg: IF 0x%x, AdminState %d, AtmIfUp %d, Marslist size %d\n",
			pInterface,
			pInterface->AdminState,
			pInterface->AtmInterfaceUp,
			pInterface->MARSList.ListSize));

	if ((!pInterface->PVCOnly) &&
		(pInterface->AdminState == IF_STATUS_UP) &&
		(AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_NOT_REGISTERED) &&
		(pInterface->AtmInterfaceUp) &&
		(pInterface->MARSList.ListSize > 0))
	{
		AAMCDEBUGP(AAD_INFO, ("Starting MARS registration on IF 0x%x\n", pInterface));

		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_REGISTERING);

		//
		//  Stop any running timer.
		//
		WasRunning = AtmArpStopTimer(
							&(pInterface->McTimer),
							pInterface
							);

		//
		//  Start a timer to police completion of MARS registration.
		//
		AtmArpStartTimer(
				pInterface,
				&(pInterface->McTimer),
				AtmArpMcMARSRegistrationTimeout,
				pInterface->MARSRegistrationTimeout,
				(PVOID)pInterface
			);

		if (!WasRunning)
		{
			AtmArpReferenceInterface(pInterface);	// MARS Reg timer ref
		}

		pInterface->McRetriesLeft = pInterface->MaxRegistrationAttempts - 1;

		//
		//  Send a MARS_JOIN
		//
		AtmArpMcSendJoinOrLeave(
			pInterface,
			AA_MARS_OP_TYPE_JOIN,
			NULL,		// Not Joining any specific Multicast group (=> registration)
			0			// Mask (don't care)
			);
		//
		//  IF Lock is released within the above
		//
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpMcSendPendingJoins(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Send MARS_JOIN on behalf of all Joins pending initial registration.

	NOTE: The caller is assumed to have a lock for the Interface,
	which will be released here.

Arguments:

	pInterface			- Interface on which pending Joins are to be sent.

Return Value:

	None

--*/
{
	typedef struct 
	{
		IP_ADDRESS			IPAddress;
		IP_MASK				Mask;
	} AA_IP_MASK_PAIR;

	PATMARP_IPMC_JOIN_ENTRY	pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY	pNextJoinEntry;
	UINT					NumEntries;
	AA_IP_MASK_PAIR 		*DestArray;

	//
	// Count the entries which need to be sent.
	//
	for (pJoinEntry = pInterface->pJoinList, NumEntries=0;
 		 pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 		 pJoinEntry = pJoinEntry->pNextJoinEntry)
	{
		if (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_PENDING))
		{
			NumEntries++;
		}
	}

	if (NumEntries)
	{
		//
		// Allocate temporary space to hold their ip addresses and masks.
		//
		AA_ALLOC_MEM(
			DestArray,
			AA_IP_MASK_PAIR,
			NumEntries*sizeof(AA_IP_MASK_PAIR)
			);
	}
	else
	{
		DestArray = NULL;
	}
	
	if (DestArray!=NULL)
	{
		AA_IP_MASK_PAIR *pPair 		= DestArray;
		AA_IP_MASK_PAIR *pPairEnd 	= DestArray + NumEntries;

		//
		// Now go through the list again, setting the state of the entries
		// appropriately, and picking up the ipaddresses&masks.
		// Note that we continue to hold the interface lock, to the
		// join entry list can't grow or shrink, nor any join entry
		// change state. Neverthless, we check for these cases.
		//

		for (pJoinEntry = pInterface->pJoinList;
 			pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 		 	pJoinEntry = pJoinEntry->pNextJoinEntry)
		{
			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_PENDING))
			{
				PIP_ADDRESS				pIpAddress;

				if (pPair >= pPairEnd)
				{
					//
					// This means there are now more join entries in
					// this state then when we counted just above!
					// We deal with it by breaking out early, but really
					// this is an assert and if we hit it neet to determine
					// why the state of join entries are changing elsewhere
					// when we have the interface lock.
					//
					AA_ASSERT(FALSE);
					break;
				}

				pPair->IPAddress = pJoinEntry->IPAddress;
				pPair->Mask = pJoinEntry->Mask;

				pIpAddress = &(pJoinEntry->IPAddress);
	
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
	
				//
				//  Send off a MARS_JOIN for this IP address.
				//
				AAMCDEBUGP(AAD_INFO,
					("Sending Pended Join: pIf 0x%x, pJoinEntry 0x%x, Addr: %d.%d.%d.%d\n",
							pInterface,
							pJoinEntry,
							((PUCHAR)pIpAddress)[0],
							((PUCHAR)pIpAddress)[1],
							((PUCHAR)pIpAddress)[2],
							((PUCHAR)pIpAddress)[3]));
	
				//
				//  Start the "Wait For Join completion" timer.
				//
				AtmArpStartTimer(
					pInterface,
					&(pJoinEntry->Timer),
					AtmArpMcJoinOrLeaveTimeout,
					pInterface->JoinTimeout,
					(PVOID)pJoinEntry
					);
				
				AA_REF_JE(pJoinEntry);	// Wait for Join completion - pended join
	
				pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;
			

				pPair++;
			}
		}

		AA_ASSERT(pPair == pPairEnd);

		//
		// But just in case  ....
		//
		if (pPair < pPairEnd)
		{
			//
			// Only send joins for as many as we've copied over.
			//
			pPairEnd = pPair;
		}

		//
		// Now actually send the JOIN entries. Note that the interface
		// lock is released/reacquired once per iteration.
		//
		for (pPair = DestArray;
 			 pPair < pPairEnd;
 			 pPair++)

		{
				AtmArpMcSendJoinOrLeave(
					pInterface,
					AA_MARS_OP_TYPE_JOIN,
					&(pPair->IPAddress),
					pPair->Mask
					);
				//
				//  IF Lock is released within the above.
				//
	
				AA_ACQUIRE_IF_LOCK(pInterface);
		}

		AA_FREE_MEM(DestArray);
		DestArray = NULL;
	}


	AA_RELEASE_IF_LOCK(pInterface);

}


VOID
AtmArpMcRevalidateAll(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	An event has happened that needs us to revalidate all group information.
	The RFC says that we should set the REVALIDATE flag on all groups at a
	random time between 1 and 10 seconds. We implement this by starting
	"random" timers on all groups.

Arguments:

	pInterface			- Interface on which revalidation is to be done

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;

	AAMCDEBUGP(AAD_INFO, ("McRevalidateAll on IF 0x%x\n", pInterface));

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	//
	//  Go through the list of IP Entries representing multicast addresses
	//  that we send to.
	//
	for (pIpEntry = pInterface->pMcSendList;
 		 pIpEntry != NULL_PATMARP_IP_ENTRY;
 		 pIpEntry = pIpEntry->pNextMcEntry)
	{
		AA_ASSERT(AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_NUCAST));
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		if (AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_RESOLVED))
		{
			ULONG	RandomDelay;
			BOOLEAN	WasRunning;

			WasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

			RandomDelay =  AA_GET_RANDOM(
								pInterface->MinRevalidationDelay,
								pInterface->MaxRevalidationDelay);
			AAMCDEBUGP(AAD_LOUD,
				("McRevalidateAll: pIpEntry 0x%x/0x%x, Addr: %d.%d.%d.%d, pAtmEntry 0x%x\n",
					pIpEntry, pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3],
					pIpEntry->pAtmEntry));

			AtmArpStartTimer(
				pInterface,
				&(pIpEntry->Timer),
				AtmArpMcRevalidationDelayTimeout,
				RandomDelay,
				(PVOID)pIpEntry
				);

			if (!WasRunning)
			{
				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
			}
		}

		AA_RELEASE_IE_LOCK(pIpEntry);
	}

	AA_RELEASE_IF_TABLE_LOCK(pInterface);


}


VOID
AtmArpMcHandleMARSFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsRegnFailure
)
/*++

Routine Description:

	Handle a MARS failure, as per Section 5.4.1 etc in RFC 2022.
	On seeing the first failure, we assume that there is a transient
	problem with the MARS, so we try to re-register. If we fail to do
	so, we pick up the next MARS in our configured list. If no such
	MARS exists, then we wait for a while before retrying registration.

Arguments:

	pInterface			- Interface on which MARS failure has been detected.
	IsRegnFailure		- Is this a failure in registering?

Return Value:

	None

--*/
{
	BOOLEAN						WasRunning;
	ULONG						rc;
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY *	ppJoinEntry;

	AAMCDEBUGP(AAD_INFO, ("HandleMARSFailure: pIf 0x%x, Flags 0x%x, RegnFailure=%d\n",
			pInterface, pInterface->Flags, IsRegnFailure));

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Stop the MC timer running on this Interface.
	//
	WasRunning = AtmArpStopTimer(&(pInterface->McTimer), pInterface);
	if (WasRunning)
	{
		rc = AtmArpDereferenceInterface(pInterface);	// MC Timer ref
		AA_ASSERT(rc != 0);
	}

	if (AA_IS_FLAG_SET(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE))
	{
		//
		//  First failure. Do some housekeeping, and re-register with
		//  the MARS.
		//
		AA_SET_FLAG(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_FIRST_RESP);

		//
		//  Clean up all our JOIN Entries.
		//
		ppJoinEntry = &(pInterface->pJoinList);
		while (*ppJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			pJoinEntry = *ppJoinEntry;
			WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);

			if (WasRunning)
			{
				rc = AA_DEREF_JE(pJoinEntry);	// MARS failure; stopped timer
				AA_ASSERT(rc != 0);
			}

			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING))
			{
				//
				//  Delete this because it is leaving.
				//
				*ppJoinEntry = pJoinEntry->pNextJoinEntry;
				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));
				AA_DEREF_JE(pJoinEntry);	// MARS Failure; get rid of leaving entry
			}
			else
			{
				//
				//  Mark this as "pending" so that we will re-join
				//  this group as soon as we complete re-registration.
				//
				AA_SET_FLAG(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_PENDING);

				ppJoinEntry = &(pJoinEntry->pNextJoinEntry);
			}
		}

		//
		//  Prime the IF state so that registration can happen.
		//
		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);

		AtmArpMcStartRegistration(pInterface);
		//
		//  IF Lock is released within the above.
		//
					
	}
	else if  (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Check if this is a failure to re-register.
		//
		if (AA_IS_FLAG_SET(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_FIRST_RESP) ||
			IsRegnFailure)
		{
			//
			//  Absolutely no hope for this MARS. If we have more entries in
			//  the MARS list, move to the next one. In any case, delay for
			//  atleast 1 minute before re-registering.
			//
			if (pInterface->pCurrentMARS->pNext != (PATMARP_SERVER_ENTRY)NULL)
			{
				pInterface->pCurrentMARS = pInterface->pCurrentMARS->pNext;
			}
			else
			{
				pInterface->pCurrentMARS = pInterface->MARSList.pList;
			}
		}

		AA_SET_FLAG(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_SECOND_RESP);

		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_DELAY_B4_REGISTERING);

		AtmArpStartTimer(
			pInterface,
			&(pInterface->McTimer),
			AtmArpMcMARSReconnectTimeout,
			pInterface->MARSConnectInterval,
			(PVOID)pInterface
			);

		AtmArpReferenceInterface(pInterface);	// MC Timer ref

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		//
		// AdminStatus is not UP -- don't try to re-register.
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpMcSendToMARS(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send the given packet to MARS on the specified interface.

	NOTE: The caller is assumed to have acquired the Interface lock, which
	will be released here.

Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	pNdisPacket			- Points to packet to be sent. This is assumed to be
						  allocated by ourselves.

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_VC				pVc;
	PATMARP_FLOW_SPEC		pFlowSpec;
	NDIS_STATUS				Status;
	ULONG					rc;

	AA_ASSERT(pInterface->pCurrentMARS != NULL_PATMARP_SERVER_ENTRY);
	pAtmEntry = pInterface->pCurrentMARS->pAtmEntry;

	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	AAMCDEBUGP(AAD_EXTRA_LOUD,
		("SendToMars: pIf 0x%x, NdisPkt 0x%x, MARS ATM Entry 0x%x\n",
				pInterface, pNdisPacket, pAtmEntry));

	AA_RELEASE_IF_LOCK(pInterface);
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	//
	//  Get at the best effort VC going to this address
	//

	pVc = pAtmEntry->pBestEffortVc;

	if (pVc != NULL_PATMARP_VC)
	{
		//
		//  Nail down the VC.
		//
		AA_ACQUIRE_VC_LOCK_DPC(pVc);
		AtmArpReferenceVc(pVc);	// temp ref
		AA_RELEASE_VC_LOCK_DPC(pVc);

		AA_RELEASE_AE_LOCK(pAtmEntry);	// Not needed anymore

		//
		//  We found a VC to MARS. Make sure it is still around, and send the
		//  packet on it.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		rc = AtmArpDereferenceVc(pVc);	// temp ref

		if (rc != 0)
		{
			AtmArpSendPacketOnVc(pVc, pNdisPacket);
			//
			//  The VC lock is released in SendPacketOnVc
			//
		}
		else
		{
			//
			//  The VC has been deref'ed away! Set up "pVc" for the check
			//  coming up.
			//
			pVc = NULL_PATMARP_VC;
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
		}
	}

	if (pVc == NULL_PATMARP_VC)
	{
		//
		//  We don't have an appropriate VC to the MARS, so create
		//  one, and queue this packet for transmission as soon as
		//  the call is made.
		//
		//  AtmArpMakeCall needs the caller to hold the ATM Entry lock.
		//
		AA_GET_CONTROL_PACKET_SPECS(pInterface, &pFlowSpec);
		Status = AtmArpMakeCall(
						pInterface,
						pAtmEntry,
						pFlowSpec,
						pNdisPacket
						);
		//
		//  The AE lock is released within the above.
		//
	}


}

VOID
AtmArpMcSendJoinOrLeave(
	IN	PATMARP_INTERFACE			pInterface,
	IN	USHORT						OpCode,
	IN	PIP_ADDRESS					pIpAddress 	OPTIONAL,
	IN	IP_ADDRESS					Mask
)
/*++

Routine Description:

	Send a MARS_JOIN or MARS_LEAVE to the MARS on the specified interface.
	If no IP address is given, then this message is being sent to (de)-register
	ourselves with the MARS. Otherwise, we are Joining/Leaving the multicast
	group(s) indicated by the IP address and mask.

	NOTE: The caller is assumed to have acquired the Interface lock, which
	will be released here.

Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	OpCode				- JOIN or LEAVE
	pIpAddress			- Optional pointer to first IP address in block
						  of Class D IP addresses being Joined/Left. NULL if
						  the JOIN/LEAVE message is being sent in order to
						 (de)register.
	Mask				- Defines the block [*pIpAddress to (*pIpAddress | Mask)]
						  of IP addresses being Joined/Left, if pIpAddress isn't
						  NULL.

Return Value:

	None

--*/
{
	PNDIS_PACKET				pNdisPacket;
	PNDIS_BUFFER				pNdisBuffer;
	ULONG						BufferLength;
	PAA_MARS_JOIN_LEAVE_HEADER	pPkt;
	PUCHAR						pNextToFill;	// Next field to fill in packet
	IP_ADDRESS					MaxIPAddress;	// being joined

	BufferLength = sizeof(AA_MARS_JOIN_LEAVE_HEADER) +
						 pInterface->LocalAtmAddress.NumberOfDigits;

	AA_RELEASE_IF_LOCK(pInterface);

#if DBG
	if (pIpAddress != (PIP_ADDRESS)NULL)
	{
		AAMCDEBUGP(AAD_VERY_LOUD,
			("SendJoinOrLeave: pIf 0x%x, Op %d, IP Address: %d.%d.%d.%d\n",
					pInterface, OpCode,
					((PUCHAR)pIpAddress)[0],
					((PUCHAR)pIpAddress)[1],
					((PUCHAR)pIpAddress)[2],
					((PUCHAR)pIpAddress)[3]));
	}
	else
	{
		AAMCDEBUGP(AAD_VERY_LOUD,
			("SendJoinOrLeave: pIf 0x%x, Op %d, No IP Address\n",
					pInterface, OpCode));
	}
#endif // DBG

	if (pIpAddress != (PIP_ADDRESS)NULL)
	{
		BufferLength += (2 * AA_IPV4_ADDRESS_LENGTH);
	}

	//
	//  Allocate packet
	//
	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Allocate buffer
		//
		pNdisBuffer = AtmArpAllocateProtoBuffer(
							pInterface,
							BufferLength,
							(PUCHAR *)&pPkt
							);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

			AA_SET_MEM((PUCHAR)pPkt, 0, BufferLength);

			//
			//  Fill in fixed fields first.
			//
			AA_COPY_MEM((PUCHAR)pPkt,
						(PUCHAR)&AtmArpMcMARSFixedHeader,
						sizeof(AtmArpMcMARSFixedHeader));

			pPkt->op = NET_SHORT(OpCode);
			pPkt->shtl = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));
			if (pIpAddress != (PIP_ADDRESS)NULL)
			{
				pPkt->tpln = AA_IPV4_ADDRESS_LENGTH;
			}

			//
			//  The only addresses we fill in are Source ATM Number and
			//  Target multicast group address.
			//
			pNextToFill = (PUCHAR)pPkt + sizeof(AA_MARS_JOIN_LEAVE_HEADER);

			//
			//  Source ATM Number:
			//
			AA_COPY_MEM(pNextToFill,
						(pInterface->LocalAtmAddress.Address),
						pInterface->LocalAtmAddress.NumberOfDigits);

			pNextToFill += pInterface->LocalAtmAddress.NumberOfDigits;

			//
			//  Target Multicast Group Address:
			//
			if (pIpAddress != (PIP_ADDRESS)NULL)
			{
				//
				//  Joining a layer 3 group
				//
				pPkt->pnum = HOST_TO_NET_SHORT(1);
				pPkt->flags |= AA_MARS_JL_FLAG_LAYER3_GROUP;

				//
				//  Fill in one <Min, Max> pair: "Min" value first:
				//
				AA_COPY_MEM(pNextToFill,
							pIpAddress,
							AA_IPV4_ADDRESS_LENGTH);
				pNextToFill += AA_IPV4_ADDRESS_LENGTH;

				//
				//  Compute the "Max" value, and fill it in.
				//
				MaxIPAddress = *pIpAddress | Mask;
				AA_COPY_MEM(pNextToFill,
							&(MaxIPAddress),
							AA_IPV4_ADDRESS_LENGTH);
			}
			else
			{
				//
				//  Registering as a Cluster Member
				//
				pPkt->flags |= AA_MARS_JL_FLAG_REGISTER;
			}

			AA_ACQUIRE_IF_LOCK(pInterface);

			AtmArpMcSendToMARS(
				pInterface,
				pNdisPacket
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
		}
	}

}



VOID
AtmArpMcSendRequest(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PIP_ADDRESS					pIpAddress
)
/*++

Routine Description:

	Send a MARS Request to resolve a multicast group address, on the specified
	interface.


Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	pIpAddress			- Pointer to Address to be resolved.

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					BufferLength;
	PAA_MARS_REQ_NAK_HEADER	pPkt;

	AAMCDEBUGP(AAD_LOUD,
		("McSendRequest: pIf 0x%x, IP Address: %d.%d.%d.%d\n",
				pInterface,
				((PUCHAR)pIpAddress)[0],
				((PUCHAR)pIpAddress)[1],
				((PUCHAR)pIpAddress)[2],
				((PUCHAR)pIpAddress)[3]));

	BufferLength = sizeof(AA_MARS_REQ_NAK_HEADER) +
						 pInterface->LocalAtmAddress.NumberOfDigits +
						 AA_IPV4_ADDRESS_LENGTH;

	//
	//  Allocate packet
	//
	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Allocate buffer
		//
		pNdisBuffer = AtmArpAllocateProtoBuffer(
							pInterface,
							BufferLength,
							(PUCHAR *)&pPkt
							);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

			AA_SET_MEM((PUCHAR)pPkt, 0, BufferLength);

			//
			//  Fill in fixed fields first.
			//
			AA_COPY_MEM((PUCHAR)pPkt,
						(PUCHAR)&AtmArpMcMARSFixedHeader,
						sizeof(AtmArpMcMARSFixedHeader));

			pPkt->op = NET_SHORT(AA_MARS_OP_TYPE_REQUEST);
			pPkt->shtl = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));
			pPkt->tpln = AA_IPV4_ADDRESS_LENGTH;

			//
			//  The only addresses we fill in are Source ATM Number and
			//  Target multicast group address.
			//

			//
			//  Source ATM Number:
			//
			AA_COPY_MEM((PUCHAR)pPkt + sizeof(AA_MARS_REQ_NAK_HEADER),
						(pInterface->LocalAtmAddress.Address),
						pInterface->LocalAtmAddress.NumberOfDigits);
			
			//
			//  Target Multicast Group Address:
			//
			AA_COPY_MEM((PUCHAR)pPkt + sizeof(AA_MARS_REQ_NAK_HEADER) +
							pInterface->LocalAtmAddress.NumberOfDigits,
						pIpAddress,
						AA_IPV4_ADDRESS_LENGTH);


			AA_ACQUIRE_IF_LOCK(pInterface);

			AtmArpMcSendToMARS(
				pInterface,
				pNdisPacket
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
		}
	}

}



PATMARP_IPMC_ATM_ENTRY
AtmArpMcLookupAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmList,
	IN	PUCHAR						pAtmNumber,
	IN	ULONG						AtmNumberLength,
	IN	ATM_ADDRESSTYPE				AtmNumberType,
	IN	PUCHAR						pAtmSubaddress,
	IN	ULONG						AtmSubaddressLength,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Check if the specified ATM endstation is a member of the list of
	ATM addresses associated with a Multicast entry. If so, return
	a pointer to the entry for this endstation. If not, create a new
	entry conditionally and return a pointer to this.

	NOTE: the ATM Entry is assumed to be locked by the caller.

Arguments:

	pAtmEntry			- ATM Entry to which the member will be added
	ppMcAtmList			- Points to start of list to search in.
	pAtmNumber			- Pointer to ATM address for this endstation
	AtmNumberLength		- Length of above
	AtmNumberType		- Type of above
	pAtmSubaddress		- Pointer to ATM Subaddress for this endstation
	AtmSubaddressLength	- Length of above
	CreateNew			- Should we create a new entry if not found?

Return Value:

	Pointer to the (possibly new) ATM MC Entry for the specified leaf.

--*/
{
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	BOOLEAN					Found;

	Found = FALSE;

	for (pMcAtmEntry = *ppMcAtmList;
		 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
	{
		//
		//  Compare ATM Numbers
		//
		if ((pMcAtmEntry->ATMAddress.NumberOfDigits == AtmNumberLength) &&
			(pMcAtmEntry->ATMAddress.AddressType == AtmNumberType) &&
			(AA_MEM_CMP(pMcAtmEntry->ATMAddress.Address, pAtmNumber, AtmNumberLength) == 0))
		{
			//
			//  Compare subaddresses
			//
			if ((pMcAtmEntry->ATMSubaddress.NumberOfDigits == AtmSubaddressLength) &&
				(AA_MEM_CMP(pMcAtmEntry->ATMSubaddress.Address,
							pAtmSubaddress,
							AtmSubaddressLength) == 0))
			{
				Found = TRUE;
				break;
			}
		}
	}

	if ((!Found) && CreateNew)
	{
		AA_ALLOC_MEM(pMcAtmEntry, ATMARP_IPMC_ATM_ENTRY, sizeof(ATMARP_IPMC_ATM_ENTRY));
		if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
		{
			AA_SET_MEM(pMcAtmEntry, 0, sizeof(ATMARP_IPMC_ATM_ENTRY));

			//
			//  Fill in all that we know.
			//
#if DBG
			pMcAtmEntry->ame_sig = ame_signature;
#endif
			pMcAtmEntry->pAtmEntry = pAtmEntry;

			//
			//  The ATM Address
			//
			pMcAtmEntry->ATMAddress.NumberOfDigits = AtmNumberLength;
			pMcAtmEntry->ATMAddress.AddressType = AtmNumberType;
			AA_COPY_MEM(pMcAtmEntry->ATMAddress.Address, pAtmNumber, AtmNumberLength);

			//
			//  ATM Subaddress
			//
			pMcAtmEntry->ATMSubaddress.NumberOfDigits = AtmSubaddressLength;
			pMcAtmEntry->ATMSubaddress.AddressType = ATM_NSAP;
			AA_COPY_MEM(pMcAtmEntry->ATMSubaddress.Address, pAtmSubaddress, AtmSubaddressLength);

			//
			//  Link it to the list
			//
			pMcAtmEntry->pNextMcAtmEntry = *ppMcAtmList;
			*ppMcAtmList = pMcAtmEntry;
			pAtmEntry->pMcAtmInfo->NumOfEntries++;

			//
			//  Bump up ref count on this ATM Entry
			//
			AA_REF_AE(pAtmEntry, AE_REFTYPE_MCAE);	// New McAtmEntry added
		}
	}

	AAMCDEBUGP(AAD_VERY_LOUD,
		("McLookupAtmMember: pAtmEntry 0x%x, %s pMcAtmEntry 0x%x\n",
			pAtmEntry, (!Found)? "New": "Old", pMcAtmEntry));

#if DBG
	if (pMcAtmEntry && (pAtmEntry->pIpEntryList))
	{
		AAMCDEBUGPMAP(AAD_INFO, ((!Found)? "Added " : "Found "),
					&pAtmEntry->pIpEntryList->IPAddress,
					&pMcAtmEntry->ATMAddress);
	}
#endif // DBG

	return (pMcAtmEntry);
}


VOID
AtmArpMcUnlinkAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Delete an ATM destination from the list of members of a multicast group.
	We stop the timer (if running) associated with this Multicast entry and delink the entry
	from the list of destinations, and free the structure.

	NOTE: the caller is assumed to hold a lock to the ATM Entry.

Arguments:

	pAtmEntry			- ATM Entry from which to delete the member
	pMcAtmEntry			- The entry to be deleted

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;
	ULONG						rc;

	AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

	AA_ASSERT(AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED));

	AAMCDEBUGP(AAD_LOUD, ("UnlinkAtmMember: pAtmEntry 0x%x, pMcAtmEntry 0x%x\n",
					pAtmEntry, pMcAtmEntry));

	//
	//  Stop any timer running here.
	//
	if (AA_IS_TIMER_ACTIVE(&(pMcAtmEntry->Timer)))
	{
		(VOID)AtmArpStopTimer(&(pMcAtmEntry->Timer), pAtmEntry->pInterface);
	}
		
	for (ppMcAtmEntry = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
		 *ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
	{
		if (*ppMcAtmEntry == pMcAtmEntry)
		{
			//
			//  Delink now.
			//
			*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;
			break;
		}

		AA_ASSERT(*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
	}

	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pMcAtmEntry->Timer));
	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pMcAtmEntry->Timer, pAtmEntry->pInterface, pMcAtmEntry, "MC ATM Entry");
	AA_FREE_MEM(pMcAtmEntry);

	pAtmEntry->pMcAtmInfo->NumOfEntries--;
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_MCAE);	// Unlink MC ATM Entry
	AA_ASSERT(rc!=0);// We always expect caller will retain a reference to pAtmEntry.
}


VOID
AtmArpMcUpdateConnection(
	IN	PATMARP_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Update our outgoing Point to Multipoint connection for the multicast
	group represented by the given IP Entry.

	If no call exists, and there is atleast one valid entry in the list
	of remote ATM addresses for this group, then we place an outgoing call.

	If an outgoing call exists, then we go through the list of remote
	ATM addresses. Each address that isn't participating in the call,
	and is Valid gets added as a leaf to the call. Each address that has
	been invalidated gets deleted.

	NOTE: The caller is assumed to have acquired the ATM_ENTRY lock;
	it will be released here.

Arguments:

	pAtmEntry			- ATM Entry representing multicast group on which
						  to update the PMP connection.

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_INFO		pMcAtmInfo;
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;
	ULONG						rc;

	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	PATMARP_FLOW_INFO			pFlowInfo;
	PATMARP_FLOW_SPEC			pFlowSpec;
	PATMARP_FILTER_SPEC			pFilterSpec;
	PNDIS_PACKET				pNdisPacket;
	BOOLEAN						Closing = FALSE;

	AAMCDEBUGP(AAD_LOUD,
		("McUpdateConn: pAtmEntry 0x%x/0x%x, pMcAtmInfo 0x%x/0x%x\n",
			pAtmEntry, pAtmEntry->Flags,
			pAtmEntry->pMcAtmInfo, pAtmEntry->pMcAtmInfo->Flags));
		
	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	AA_ASSERT(pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);
	AA_ASSERT(pMcAtmInfo->pMcAtmEntryList != NULL_PATMARP_IPMC_ATM_ENTRY);
	AA_ASSERT(AA_IS_FLAG_SET(pAtmEntry->Flags,
							 AA_ATM_ENTRY_TYPE_MASK,
							 AA_ATM_ENTRY_TYPE_NUCAST));

	//
	//  Add a temp reference to the ATM Entry so that it can't go
	//  away for the duration of this routine.
	//
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	do
	{
		if (pAtmEntry->pVcList && AA_IS_FLAG_SET(pAtmEntry->pVcList->Flags,
									AA_VC_CLOSE_STATE_MASK,
									AA_VC_CLOSE_STATE_CLOSING))
		{
			//
			// Bail out.
			//
			pMcAtmInfo->Flags &= ~AA_IPMC_AI_WANT_UPDATE;
			Closing = TRUE;
			break;
		}


		//
		//  Mark this entry as needing a connection update.
		//
		pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;

		//
		//  If a connection update is in progress, don't do
		//  anything more. The thread that's doing the update
		//  will see that another update is needed, and do it.
		//
		if (pMcAtmInfo->Flags & AA_IPMC_AI_BEING_UPDATED)
		{
			break;
		}

		//
		//  Mark this entry so that we don't have more than one
		//  thread proceeding beyond here.
		//
		pMcAtmInfo->Flags |= AA_IPMC_AI_BEING_UPDATED;

		while (pMcAtmInfo->Flags & AA_IPMC_AI_WANT_UPDATE)
		{
			pMcAtmInfo->Flags &= ~AA_IPMC_AI_WANT_UPDATE;

			if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_NONE))
			{
				PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;

				//
				//  No connection exists; create one.
				//

				//
				//  First, find an MC ATM Entry that is valid and disconnected.
				//  We are mainly concerned with avoiding entries that are running
				//  a party-retry delay timer.
				//
				for (ppMcAtmEntry = &pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
				{
					pMcAtmEntry = *ppMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID) &&
						AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
					{
						break;
					}
				}

				//
				//  Bail out if we don't find one.
				//
				if (*ppMcAtmEntry == NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					AAMCDEBUGP(AAD_INFO,
						("McUpdateConn: pAtmEntry %x, pMcAtmInfo %x, no valid MC ATM Entry to make call on!\n",
							pAtmEntry, pMcAtmInfo));
					break;
				}

				//
				//  We found one. Remove it from its current position and
				//  move it to the top of the list. This is for the benefit
				//  of AtmArpMakeCall, which picks up the first MC ATM Entry
				//  as the party context for the call.
				//

				//
				//  Unlink from current position.
				//
				*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

				//
				//  Insert at top of list.
				//
				pMcAtmEntry->pNextMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
				pAtmEntry->pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

				AAMCDEBUGP(AAD_VERY_LOUD,
				 ("McUpdateConn: No conn exists: pIpEnt 0x%x, pMcAtmInfo 0x%x\n",
							pAtmEntry->pIpEntryList, pMcAtmInfo));

				AA_ASSERT(pAtmEntry->pVcList == NULL_PATMARP_VC);

				AA_SET_FLAG(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_WACK_MAKE_CALL);

				AA_SET_FLAG(
						pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_WACK_ADD_PARTY);

				//
				//  Get the flow spec for this call from one of the packets
				//  queued on the IP entry.
				//
				pInterface = pAtmEntry->pInterface;
				pIpEntry = pAtmEntry->pIpEntryList;

				if (pIpEntry != NULL_PATMARP_IP_ENTRY)
				{
					pNdisPacket = pIpEntry->PacketList;
					if (pNdisPacket != NULL)
					{
						AA_GET_PACKET_SPECS(pInterface,
											pNdisPacket, 
											&pFlowInfo,
											&pFlowSpec,
											&pFilterSpec);
					}
					else
					{
						pFlowSpec = &(pInterface->DefaultFlowSpec);
					}
				}
				else
				{
					pFlowSpec = &(pInterface->DefaultFlowSpec);
				}

				AtmArpMakeCall(
						pInterface,
						pAtmEntry,
						pFlowSpec,
						(PNDIS_PACKET)NULL
						);
				//
				//  the ATM Entry lock is released within the above.
				//
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				break;
			}
			else if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_WACK_MAKE_CALL))
			{
				//
				//  Don't do anything till the first connection
				//  is established.
				//
				break;
			}
			else if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_ACTIVE))
			{
				//
				//  The PMP connection exists. Go through the list
				//  of ATM MC Entries, and:
				//  1 - Add valid ones which aren't leaves yet
				//  2 - Delete invalid ones
				//

				// #1: add validated leaves

				for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					pMcAtmEntry = pNextMcAtmEntry)
				{
					pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID) &&
						AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
					{
						AAMCDEBUGP(AAD_VERY_LOUD, ("McUpdateConn: pAtmEnt 0x%x, Adding Pty pMcAtmEnt 0x%x\n",
								pAtmEntry, pMcAtmEntry));

						AtmArpAddParty(
							pAtmEntry,
							pMcAtmEntry
							);
						//
						//  ATM Entry lock is released within the above.
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;
						break;
					}

				} // for

				// #2: delete invalid leaves

				for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					pMcAtmEntry = pNextMcAtmEntry)
				{
					pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags, 
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_INVALID))
					{
						AAMCDEBUGP(AAD_VERY_LOUD, ("McUpdateConn: pAtmEnt 0x%x, Terminating 0x%x\n",
							pAtmEntry, pMcAtmEntry));

						AAMCDEBUGPMAP(AAD_INFO,
							"Deleting ", &pAtmEntry->pIpEntryList->IPAddress,
							&pMcAtmEntry->ATMAddress);

						AtmArpMcTerminateMember(
							pAtmEntry,
							pMcAtmEntry
							);
						//
						//  ATM Entry lock is released within the above.
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;
						break;
					}

				} // for

			} // if Connection is active
			//
			//  else we may be waiting for a while after seeing
			//  a transient connection failure on the first MakeCall.
			//

		} // while more connection updates needed

		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_UPDATE_MASK,
					AA_IPMC_AI_NO_UPDATE);

		break;

	}
	while (FALSE);


	//
	//  Remove the temp reference on the ATM Entry:
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	if (rc != 0)
	{
		BOOLEAN				ClearToSend;
		PNDIS_PACKET		pPacketList;

		ClearToSend = ((pMcAtmInfo->TransientLeaves == 0) &&
					   !Closing							  &&
					   (AA_IS_FLAG_SET(pMcAtmInfo->Flags,
					   				   AA_IPMC_AI_CONN_STATE_MASK,
					   				   AA_IPMC_AI_CONN_ACTIVE)));

		pIpEntry = pAtmEntry->pIpEntryList;
		pInterface = pAtmEntry->pInterface;
		AA_RELEASE_AE_LOCK(pAtmEntry);

		if (ClearToSend && pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			pPacketList = pIpEntry->PacketList;
			pIpEntry->PacketList = (PNDIS_PACKET)NULL;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pPacketList != (PNDIS_PACKET)NULL)
			{
				AAMCDEBUGP(AAD_INFO, ("UpdateConn: pAtmEntry 0x%x, sending pktlist 0x%x\n",
						pAtmEntry, pPacketList));

				AtmArpSendPacketListOnAtmEntry(
						pInterface,
						pAtmEntry,
						pPacketList,
						TRUE	// IsBroadcast
						);
			}
		}

	}
	//
	//  else the ATM Entry is gone.
	//

}



#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\macros.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    macros.h

Abstract:

	Macros for the ATMARP module

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-20-96    created

Notes:


--*/
#ifndef __ATMARP_MACROS_H_INCLUDED
#define __ATMARP_MACROS_H_INCLUDED

#include "atmarp.h"

#define INCR_STAT(_x)	NdisInterlockedIncrement(&(_x))

#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN


/*++
ULONG
ATMARP_HASH(
	IN	IP_ADDRESS	IpAddress
)
--*/
#define ATMARP_HASH(IpAddress)	\
			(((ULONG)(IpAddress)) % ATMARP_TABLE_SIZE)


/*++
VOID
AA_SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define AA_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
AA_IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define AA_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

#ifdef IPMCAST

/*++
VOID
AAMC_SET_IF_STATE(
	IN	PATMARP_INTERFACE	_pIf,
	IN	ULONG				_NewState
)
Set the Multicast state for the specified Interface to the given value.
--*/
#define AAMC_SET_IF_STATE(_pIf, _NewState)	\
			AA_SET_FLAG((_pIf)->Flags, AAMC_IF_STATE_MASK, (_NewState))


/*++
ULONG
AAMC_IF_STATE(
	IN	PATMARP_INTERFACE	_pIf
)
Get the Multicast state for the specified Interface.
--*/
#define AAMC_IF_STATE(_pIf)	((_pIf)->Flags & AAMC_IF_STATE_MASK)



#endif // IPMCAST

/*++
VOID
AA_INIT_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_INIT_BLOCK_STRUCT(pBlock)		NdisInitializeEvent(&((pBlock)->Event))


/*++
NDIS_STATUS
AA_WAIT_ON_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_WAIT_ON_BLOCK_STRUCT(pBlock)		\
			(NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
AA_SIGNAL_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock,
	IN	UINT			Status
)
--*/
#define AA_SIGNAL_BLOCK_STRUCT(pBlock, _Status)	\
			{ (pBlock)->Status = _Status; NdisSetEvent(&((pBlock)->Event)); }


/*++
VOID
AA_FREE_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_FREE_BLOCK_STRUCT(pBlock)		// Nothing to be done here


/*++
VOID
AA_INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_INIT_LOCK(pLock)	\
				AtmArpAllocateSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_ACQUIRE_LOCK(pLock)	\
				AtmArpAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_ACQUIRE_LOCK_DPC(pLock)	\
				AtmArpAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_RELEASE_LOCK(pLock)		\
				AtmArpReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_RELEASE_LOCK_DPC(pLock)		\
				AtmArpReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#define AA_FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)


/*++
VOID
AA_INIT_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->InterfaceLock))

/*++
VOID
AA_ACQUIRE_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_ACQUIRE_IF_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->InterfaceLock))


/*++
VOID
AA_RELEASE_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_RELEASE_IF_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->InterfaceLock))


/*++
VOID
AA_FREE_IF_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_INIT_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_TABLE_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_ACQUIRE_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TABLE_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_ACQUIRE_IF_TABLE_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TABLE_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->ArpTableLock))


/*++
VOID
AA_RELEASE_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TABLE_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_RELEASE_IF_TABLE_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TABLE_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->ArpTableLock))


/*++
VOID
AA_FREE_IF_TABLE_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_TABLE_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->ArpTableLock))


/*++
VOID
AA_INIT_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_ATM_LIST_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_ACQUIRE_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_ATM_LIST_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_ACQUIRE_IF_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_ATM_LIST_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->AtmEntryListLock))


/*++
VOID
AA_RELEASE_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_ATM_LIST_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_RELEASE_IF_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_ATM_LIST_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->AtmEntryListLock))


/*++
VOID
AA_FREE_IF_ATM_LIST_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_ATM_LIST_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_INIT_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_TIMER_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_ACQUIRE_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TIMER_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_ACQUIRE_IF_TIMER_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TIMER_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->TimerLock))

/*++
VOID
AA_RELEASE_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TIMER_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_RELEASE_IF_TIMER_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TIMER_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->TimerLock))


/*++
VOID
AA_FREE_IF_TIMER_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_TIMER_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->TimerLock))


/*++
VOID
AA_INIT_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_INIT_VC_LOCK(pVc)		\
				AA_INIT_LOCK(&((pVc)->Lock))

/*++
VOID
AA_ACQUIRE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_ACQUIRE_VC_LOCK(pVc)		\
				AA_ACQUIRE_LOCK(&((pVc)->Lock))

/*++
VOID
AA_ACQUIRE_VC_LOCK_DPC(
	IN PATMARP_VC	pVc
)
--*/
#define AA_ACQUIRE_VC_LOCK_DPC(pVc)		\
				AA_ACQUIRE_LOCK_DPC(&((pVc)->Lock))

/*++
VOID
AA_RELEASE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_RELEASE_VC_LOCK(pVc)		\
				AA_RELEASE_LOCK(&((pVc)->Lock))


/*++
VOID
AA_RELEASE_VC_LOCK_DPC(
	IN PATMARP_VC	pVc
)
--*/
#define AA_RELEASE_VC_LOCK_DPC(pVc)		\
				AA_RELEASE_LOCK_DPC(&((pVc)->Lock))

/*++
VOID
AA_FREE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_FREE_VC_LOCK(pVc)		\
				AA_FREE_LOCK(&((pVc)->Lock))


/*++
VOID
AA_INIT_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_INIT_AE_LOCK(pAtmEntry)		\
				AA_INIT_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_ACQUIRE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_ACQUIRE_AE_LOCK(pAtmEntry)		\
				AA_ACQUIRE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_ACQUIRE_AE_LOCK_DPC(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry)		\
				AA_ACQUIRE_LOCK_DPC(&((pAtmEntry)->Lock))

/*++
VOID
AA_RELEASE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_RELEASE_AE_LOCK(pAtmEntry)		\
				AA_RELEASE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_RELEASE_AE_LOCK_DPC(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_RELEASE_AE_LOCK_DPC(pAtmEntry)		\
				AA_RELEASE_LOCK_DPC(&((pAtmEntry)->Lock))

/*++
VOID
AA_FREE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_FREE_AE_LOCK(pAtmEntry)		\
				AA_FREE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_INIT_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_INIT_IE_LOCK(pIpEntry)		\
				AA_INIT_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_ACQUIRE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_ACQUIRE_IE_LOCK(pIpEntry)		\
				AA_ACQUIRE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_ACQUIRE_IE_LOCK_DPC(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_ACQUIRE_IE_LOCK_DPC(pIpEntry)		\
				AA_ACQUIRE_LOCK_DPC(&((pIpEntry)->Lock))

/*++
VOID
AA_RELEASE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_RELEASE_IE_LOCK(pIpEntry)		\
				AA_RELEASE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_RELEASE_IE_LOCK_DPC(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_RELEASE_IE_LOCK_DPC(pIpEntry)		\
				AA_RELEASE_LOCK_DPC(&((pIpEntry)->Lock))

/*++
VOID
AA_FREE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_FREE_IE_LOCK(pIpEntry)		\
				AA_FREE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_INIT_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_INIT_GLOBAL_LOCK(pGlob)		\
				AA_INIT_LOCK(&((pGlob)->Lock))


/*++
VOID
AA_ACQUIRE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_ACQUIRE_GLOBAL_LOCK(pGlob)		\
				AA_ACQUIRE_LOCK(&((pGlob)->Lock))


/*++
VOID
AA_RELEASE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_RELEASE_GLOBAL_LOCK(pGlob)		\
				AA_RELEASE_LOCK(&((pGlob)->Lock))

/*++
VOID
AA_FREE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_FREE_GLOBAL_LOCK(pGlob)		\
				AA_FREE_LOCK(&((pGlob)->Lock))


#ifdef ATMARP_WMI

/*++
VOID
AA_INIT_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_WMI_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->WmiLock))

/*++
VOID
AA_ACQUIRE_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_WMI_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->WmiLock))


/*++
VOID
AA_ACQUIRE_IF_WMI_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_WMI_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->WmiLock))


/*++
VOID
AA_RELEASE_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_WMI_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->WmiLock))


/*++
VOID
AA_RELEASE_IF_WMI_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_WMI_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->WmiLock))


/*++
VOID
AA_FREE_IF_WMI_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_WMI_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->WmiLock))

#endif // ATMARP_WMI

/*++
BOOLEAN
AA_IS_VC_GOING_DOWN(
	IN	PATMARP_VC		pVc
)
Is the VC being closed, or marked for closing?
--*/
#define AA_IS_VC_GOING_DOWN(_pVc)		\
				(((_pVc)->Flags & (AA_VC_CLOSE_STATE_CLOSING|AA_VC_CALL_STATE_CLOSE_IN_PROGRESS)) != 0)


#if !BINARY_COMPATIBLE

#define AA_ALLOC_FROM_POOL(_pVar, _StructType, _Size)	\
			(_pVar) = (_StructType *)ExAllocatePoolWithTag(NonPagedPool,	\
														 (_Size),		\
														 'CPRA')

#define AA_FREE_TO_POOL(_pMem)		ExFreePool((PVOID)(_pMem))

#endif
	
/*++
VOID
AA_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
#define AA_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)AaAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define AA_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'CPRA');
#endif // DBG


/*++
VOID
AA_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
#define AA_FREE_MEM(pMem)	AaAuditFreeMem((PVOID)(pMem));
#else
#define AA_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


/*++
VOID
AA_SET_MEM(
	IN	POPAQUE		pMem,
	IN	UCHAR		bValue,
	IN	ULONG		NumberOfBytes
)
--*/
#define AA_SET_MEM(pMem, bValue, NumberOfBytes)	\
			AtmArpSetMemory((PUCHAR)(pMem), (bValue), (NumberOfBytes));



/*++
VOID
AA_COPY_MEM(
	IN	POPAQUE		pDst,
	IN	POPAQUE		pSrc,
	IN	ULONG		NumberOfBytes
)
--*/
#define AA_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


/*++
ULONG
AA_MEM_CMP(
	IN	PVOID		pString1,
	IN	PVOID		pString2,
	IN	ULONG		Length
)
--*/
#define AA_MEM_CMP(pString1, pString2, Length)	\
			AtmArpMemCmp((PUCHAR)(pString1), (PUCHAR)(pString2), (ULONG)(Length))



/*++
VOID
AA_INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define AA_INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)



/*++
VOID
AA_START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define AA_START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))


/*++
VOID
AA_STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define AA_STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
AA_IS_TIMER_ACTIVE(
	IN	PATMARP_TIMER		pArpTimer
)
--*/
#define AA_IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PATMARP_TIMER_LIST)NULL)


/*++
ULONG
AA_GET_TIMER_DURATION(
	IN	PATMARP_TIMER		pTimer
)
--*/
#define AA_GET_TIMER_DURATION(pTmr)	((pTmr)->Duration)


#ifndef NO_TIMER_MACRO

/*++
VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER		pTimer
)
--*/
#define AtmArpRefreshTimer(_pTmr)												\
{																				\
	PATMARP_TIMER_LIST	_pTimerList;											\
																				\
	if ((_pTimerList = (_pTmr)->pTimerList) != (PATMARP_TIMER_LIST)NULL)		\
	{																			\
		(_pTmr)->LastRefreshTime = _pTimerList->CurrentTick;					\
	}																			\
}

#endif // !NO_TIMER_MACRO

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/10)


/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)


/*++
ULONG
CELLS_TO_BYTES(
	IN	ULONG				NumberOfCells
)
Convert from cell count to byte count
--*/
#define CELLS_TO_BYTES(NumberOfCells)	((NumberOfCells) * 48)


/*++
ULONG
BYTES_TO_CELLS(
	IN	ULONG				ByteCount
)
Convert from byte count to cell count
--*/
#define BYTES_TO_CELLS(ByteCount)		((ByteCount) / 48)



/*++
VOID
AA_IF_STAT_INCR(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter
)
Increment the specified StatsCounter on an Interface by 1.
--*/
#define AA_IF_STAT_INCR(pInterface, StatsCounter)	\
			NdisInterlockedIncrement(&(pInterface->StatsCounter))


/*++
VOID
AA_IF_STAT_ADD_LOCK(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter,
	IN	ULONG				IncrValue
)
Increment the specified StatsCounter on an Interface by the specified IncrValue.
Take a lock on the interface to do so.
--*/
#if DBG_SPIN_LOCK
#define AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)	\
			NdisInterlockedAddUlong(&(pInterface->StatsCounter), IncrValue, &(pInterface->InterfaceLock.NdisLock))
#else
#define AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)	\
			NdisInterlockedAddUlong(&(pInterface->StatsCounter), IncrValue, &(pInterface->InterfaceLock))
#endif // DBG_SPIN_LOCK

/*++
VOID
AA_IF_STAT_ADD(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter,
	IN	ULONG				IncrValue
)
Add to the specified StatsCounter on an Interface by the specified IncrValue.
Use the more efficient InterlockedEcxhangeAdd instruction.
--*/
#if  BINARY_COMPATIBLE

	#define AA_IF_STAT_ADD(pInterface, StatsCounter, IncrValue)	\
				AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)

#else // !BINARY_COMPATIBLE

	#define AA_IF_STAT_ADD(pInterface, StatsCounter, IncrValue)	\
				InterlockedExchangeAdd(&(pInterface->StatsCounter), IncrValue)
	
			//((pInterface)->StatsCounter+=(IncrValue))
#endif // !BINARY_COMPATIBLE

/*++
BOOLEAN
AA_IS_BCAST_IP_ADDRESS(
	IN	IP_ADDRESS			Destination,
	IN	PATMARP_INTERFACE	pIf
)
Check if the given Destination is a broadcast IP address on the
given Interface. Currently, we only check if the destination is
the same as the (limited) broadcast address for the interface.

TBD: extend this when we support addition of broadcast addresses
to an interface.
--*/
#define AA_IS_BCAST_IP_ADDRESS(Destn, pIf)	\
		(IP_ADDR_EQUAL((pIf)->BroadcastAddress, Destn))



/*++
BOOLEAN
AA_FILTER_SPEC_MATCH(
	IN	PATMARP_INTERFACE	pInterface,
	IN	PATMARP_FILTER_SPEC	pSrc,
	IN	PATMARP_FILTER_SPEC	pDst
)
Check if the given filter spec matches a target filter spec, for the
specified interface.
--*/
#define AA_FILTER_SPEC_MATCH(pIf, pSrc, pDst)	\
			( ((pIf)->pFilterMatchFunc == NULL_PAA_FILTER_SPEC_MATCH_FUNC) ?	\
					TRUE:													\
					(*((pIf)->pFilterMatchFunc))((PVOID)pIf, pSrc, pDst))


/*++
BOOLEAN
AA_FLOW_SPEC_MATCH(
	IN	PATMARP_INTERFACE	pInterface,
	IN	PATMARP_FLOW_SPEC	pSrc,
	IN	PATMARP_FLOW_SPEC	pDst
)
Check if the given flow spec matches a target flow spec, for the
specified interface.
--*/
#define AA_FLOW_SPEC_MATCH(pIf, pSrc, pDst)	\
			( ((pIf)->pFlowMatchFunc == NULL_PAA_FLOW_SPEC_MATCH_FUNC) ?	\
					TRUE:													\
					(*((pIf)->pFlowMatchFunc))((PVOID)pIf, pSrc, pDst))


/*++
VOID
AA_GET_PACKET_SPECS(
	IN	PATMARP_INTERFACE		pInterface,
	IN	PNDIS_PACKET			pNdisPacket,
	OUT	PATMARP_FLOW_INFO		*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC		*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC		*ppFilterSpec
)
Get the flow and filter specs for the given packet
--*/
#define AA_GET_PACKET_SPECS(pIf, pPkt, ppFlowInfo, ppFlow, ppFilt)	\
			{																	\
				if ((pIf)->pGetPacketSpecFunc != NULL_PAA_GET_PACKET_SPEC_FUNC)	\
				{																\
					(*((pIf)->pGetPacketSpecFunc))								\
							((PVOID)(pIf), pPkt, ppFlowInfo, ppFlow, ppFilt);	\
				}																\
				else															\
				{																\
					*(ppFlowInfo) = NULL;										\
					*(ppFlow) = &((pIf)->DefaultFlowSpec);						\
					*(ppFilt) = &((pIf)->DefaultFilterSpec);					\
				}																\
			}																	\



/*++
VOID
AA_GET_CONTROL_PACKET_SPECS(
	IN	PATMARP_INTERFACE		pInterface,
	OUT	PATMARP_FLOW_SPEC		*ppFlowSpec
)
--*/
#define AA_GET_CONTROL_PACKET_SPECS(pIf, ppFlow)	\
			*(ppFlow) = &((pIf)->DefaultFlowSpec);


/*++
BOOLEAN
AA_IS_BEST_EFFORT_FLOW(
	IN	PATMARP_FLOW_SPEC		pFlowSpec
)
--*/
#define AA_IS_BEST_EFFORT_FLOW(pFlowSpec)	\
			(((pFlowSpec)->SendServiceType == SERVICETYPE_BESTEFFORT) &&			\
			 ((pFlowSpec)->SendPeakBandwidth > 0))




/*++
VOID
AA_SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define AA_SET_NEXT_PACKET(pPkt, pNext)		\
			*((PNDIS_PACKET *)((pPkt)->MiniportReserved)) = (pNext);



/*++
PNDIS_PACKET
AA_GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define AA_GET_NEXT_PACKET(pPkt)			\
			(*((PNDIS_PACKET *)((pPkt)->MiniportReserved)))



/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)


/*++
ULONG
ROUND_TO_8_BYTES(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 8.
--*/
#define ROUND_TO_8_BYTES(_Val)	(((_Val) + 7) & ~7)


#ifndef NET_SHORT

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define NET_SHORT(_x) _byteswap_ushort((USHORT)(_x))
#else
/*++
USHORT
NET_SHORT(
	IN	USHORT	Val
)
--*/
#define NET_SHORT(Val)	\
				((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
#endif

#define NET_TO_HOST_SHORT(Val)	NET_SHORT(Val)
#define HOST_TO_NET_SHORT(Val)	NET_SHORT(Val)

#endif // NET_SHORT


#ifndef NET_LONG

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define NET_LONG(_x) _byteswap_ulong((ULONG)(_x))
#else
/*++
ULONG
NET_LONG(
	IN	ULONG	Val
)
--*/
#define NET_LONG(Val)	\
				((((Val) & 0x000000ff) << 24)	|	\
				 (((Val) & 0x0000ff00) << 8)	|	\
				 (((Val) & 0x00ff0000) >> 8)	|	\
				 (((Val) & 0xff000000) >> 24) )
#endif

#define NET_TO_HOST_LONG(Val)	NET_LONG(Val)
#define HOST_TO_NET_LONG(Val)	NET_LONG(Val)

#endif // NET_LONG


/*++
BOOLEAN
AA_IS_TRANSIENT_FAILURE(
	IN NDIS_STATUS		Status
)
	Return TRUE if the given Status indicates a transient connection
	failure, otherwise return FALSE.
--*/
#define AA_IS_TRANSIENT_FAILURE(_Status)	\
			((_Status == NDIS_STATUS_RESOURCES) ||					\
			 (_Status == NDIS_STATUS_CELLRATE_NOT_AVAILABLE) ||		\
			 (_Status == NDIS_STATUS_INCOMPATABLE_QOS))


/*++
LONG
AA_GET_RANDOM(
	IN LONG			min,
	IN LONG			max
)
--*/
#define AA_GET_RANDOM(min, max)	\
			(((LONG)AtmArpRandomNumber() % (LONG)(((max+1) - (min))) + (min)))


#define AA_LOG_ERROR()		// Nothing

/*++
BOOLEAN
AA_AE_IS_ALIVE(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_AE_IS_ALIVE(pAtmEntry)				\
				(!AA_IS_FLAG_SET(				\
						(pAtmEntry)->Flags, 	\
						AA_ATM_ENTRY_STATE_MASK, \
						AA_ATM_ENTRY_IDLE))

/*++
BOOLEAN
AA_IE_ALIVE(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_IE_IS_ALIVE(pIpEntry)				\
				(!AA_IS_FLAG_SET(				\
						(pIpEntry)->Flags, 		\
						AA_IP_ENTRY_STATE_MASK, \
						AA_IP_ENTRY_IDLE))


#endif // __ATMARP_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\marspkt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	marspkt.h

Abstract:

	Definitions for MARS packets.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-12-96    Created

Notes:

--*/


#ifndef _MARS_PKT__H
#define _MARS_PKT__H

#include "arppkt.h"


#include <pshpack1.h>

//
//  LLC and OUI values for all (control and data) Multicast packets.
//
#define MC_LLC_SNAP_LLC0					((UCHAR)0xAA)
#define MC_LLC_SNAP_LLC1					((UCHAR)0xAA)
#define MC_LLC_SNAP_LLC2					((UCHAR)0x03)
#define MC_LLC_SNAP_OUI0					((UCHAR)0x00)
#define MC_LLC_SNAP_OUI1					((UCHAR)0x00)
#define MC_LLC_SNAP_OUI2					((UCHAR)0x5E)


//
//  "EtherType" (i.e. PID) values for MARS control and multicast data
//
#define AA_PKT_ETHERTYPE_MARS_CONTROL		((USHORT)0x003)
#define AA_PKT_ETHERTYPE_MARS_CONTROL_NS	((USHORT)0x0300)
#define AA_PKT_ETHERTYPE_MC_TYPE1			((USHORT)0x001)		// Type #1 data
#define AA_PKT_ETHERTYPE_MC_TYPE1_NS		((USHORT)0x0100)		// Type #1 data (Net format)
#define AA_PKT_ETHERTYPE_MC_TYPE2			((USHORT)0x004)		// Type #2 data

//
//  Address Family value for MARS control packets.
//
#define AA_MC_MARS_HEADER_AFN				((USHORT)0x000F)
#define AA_MC_MARS_HEADER_AFN_NS			((USHORT)0x0F00)

//
//  Common preamble for all packets: control, type #1 data and type #2 data.
//  This is the same as for ATMARP packets. The OUI bytes dictate whether
//  a packet is destined to a Unicast IP/ATM entity or to the Multicast IP/ATM
//  entity.
//
typedef AA_PKT_LLC_SNAP_HEADER AA_MC_MARS_PKT_HEADER;

typedef AA_MC_MARS_PKT_HEADER UNALIGNED *PAA_MC_MARS_PKT_HEADER;



//
//  Short form encapsulation for Type #1 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE1_SHORT_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x001
	USHORT						cmi;			// Cluster Member ID
	USHORT						pro;			// Protocol type
} AA_MC_PKT_TYPE1_SHORT_HEADER;

typedef AA_MC_PKT_TYPE1_SHORT_HEADER UNALIGNED *PAA_MC_PKT_TYPE1_SHORT_HEADER;


//
//  Long form encapsulation for Type #1 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE1_LONG_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x001
	USHORT						cmi;			// Cluster Member ID
	USHORT						pro;			// Protocol type
	UCHAR						snap[5];
	UCHAR						padding[3];

} AA_MC_PKT_TYPE1_LONG_HEADER;

typedef AA_MC_PKT_TYPE1_LONG_HEADER UNALIGNED *PAA_MC_PKT_TYPE1_LONG_HEADER;


//
//  Short form encapsulation for Type #2 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE2_SHORT_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x004
	UCHAR						sourceID[8];	// Ignored
	USHORT						pro;			// Protocol type
	UCHAR						padding[2];
} AA_MC_PKT_TYPE2_SHORT_HEADER;

typedef AA_MC_PKT_TYPE2_SHORT_HEADER UNALIGNED *PAA_MC_PKT_TYPE2_SHORT_HEADER;


//
//  Long form encapsulation for Type #2 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE2_LONG_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x004
	UCHAR						sourceID[8];	// Ignored
	USHORT						pro;			// Protocol type
	UCHAR						snap[5];
	UCHAR						padding[1];
} AA_MC_PKT_TYPE2_LONG_HEADER;

typedef AA_MC_PKT_TYPE2_LONG_HEADER UNALIGNED *PAA_MC_PKT_TYPE2_LONG_HEADER;



//
//  The Fixed header part of every MARS control packet.
//
typedef struct _AA_MARS_PKT_FIXED_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
} AA_MARS_PKT_FIXED_HEADER;

typedef AA_MARS_PKT_FIXED_HEADER UNALIGNED *PAA_MARS_PKT_FIXED_HEADER;



//
//  MARS control packet types
//
#define AA_MARS_OP_TYPE_REQUEST				((USHORT)1)
#define AA_MARS_OP_TYPE_MULTI				((USHORT)2)
#define AA_MARS_OP_TYPE_JOIN				((USHORT)4)
#define AA_MARS_OP_TYPE_LEAVE				((USHORT)5)
#define AA_MARS_OP_TYPE_NAK					((USHORT)6)
#define AA_MARS_OP_TYPE_GROUPLIST_REQUEST	((USHORT)10)
#define AA_MARS_OP_TYPE_GROUPLIST_REPLY		((USHORT)11)
#define AA_MARS_OP_TYPE_REDIRECT_MAP		((USHORT)12)
#define AA_MARS_OP_TYPE_MIGRATE				((USHORT)13)


//
//  Format of MARS JOIN and LEAVE message headers.
//
typedef struct _AA_MARS_JOIN_LEAVE_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (JOIN/LEAVE)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						tpln;			// Length of group address
	USHORT						pnum;			// Number of group address pairs
	USHORT						flags;			// LAYER3GRP, COPY and REGISTER bits
	USHORT						cmi;			// Cluster Member ID
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_JOIN_LEAVE_HEADER;

typedef AA_MARS_JOIN_LEAVE_HEADER UNALIGNED *PAA_MARS_JOIN_LEAVE_HEADER;


//
//  Bit definitions for flags in JOIN/LEAVE messages
//
#define AA_MARS_JL_FLAG_LAYER3_GROUP			NET_SHORT((USHORT)0x8000)
#define AA_MARS_JL_FLAG_COPY					NET_SHORT((USHORT)0x4000)
#define AA_MARS_JL_FLAG_REGISTER				NET_SHORT((USHORT)0x2000)
#define AA_MARS_JL_FLAG_PUNCHED					NET_SHORT((USHORT)0x1000)
#define AA_MARS_JL_FLAG_SEQUENCE_MASK			NET_SHORT((USHORT)0x00ff)

//
//  Format of MARS REQUEST and MARS NAK message header.
//
typedef struct _AA_MARS_REQ_NAK_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (REQUEST/NAK)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	UCHAR						pad[8];
} AA_MARS_REQ_NAK_HEADER;

typedef AA_MARS_REQ_NAK_HEADER UNALIGNED *PAA_MARS_REQ_NAK_HEADER;


//
//  Format of MARS MULTI message header.
//
typedef struct _AA_MARS_MULTI_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (MULTI)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	USHORT						tnum;			// Number of target ATM addresses returned
	USHORT						seqxy;			// Boolean X and sequence number Y
	ULONG						msn;			// MARS Sequence Number

} AA_MARS_MULTI_HEADER;

typedef AA_MARS_MULTI_HEADER UNALIGNED *PAA_MARS_MULTI_HEADER;


//
//  Format of MARS MIGRATE message header.
//
typedef struct _AA_MARS_MIGRATE_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (MIGRATE)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	USHORT						tnum;			// Number of Target ATM addresses returned
	USHORT						resv;			// Reserved
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_MIGRATE_HEADER;

typedef AA_MARS_MIGRATE_HEADER UNALIGNED *PAA_MARS_MIGRATE_HEADER;



//
//  Format of MARS REDIRECT MAP message header.
//
typedef struct _AA_MARS_REDIRECT_MAP_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (REDIRECT MAP)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						redirf;			// Flag controlling redirect behaviour
	USHORT						tnum;			// Number of MARS addresses returned
	USHORT						seqxy;			// Boolean flag x and seq number y
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_REDIRECT_MAP_HEADER;


typedef AA_MARS_REDIRECT_MAP_HEADER UNALIGNED *PAA_MARS_REDIRECT_MAP_HEADER;


//
//  Bit assignments for Boolean flag X and sequence number Y in
//  "seqxy" fields in MARS messages.
//
#define AA_MARS_X_MASK			((USHORT)0x8000)
#define AA_MARS_Y_MASK			((USHORT)0x7fff)


//
//  Initial value for sequence number Y
//
#define AA_MARS_INITIAL_Y		((USHORT)1)


//
//  Structure of a MARS packet extension element (TLV = Type, Length, Value)
//
typedef struct _AA_MARS_TLV_HDR
{
	USHORT						Type;
	USHORT						Length;		// Number of significant octets in Value

} AA_MARS_TLV_HDR;

typedef AA_MARS_TLV_HDR UNALIGNED *PAA_MARS_TLV_HDR;

//
//  Our experimental TLV that we use in MARS MULTI messages to
//  indicate that the returned target address is that of an MCS.
//
typedef struct _AA_MARS_TLV_MULTI_IS_MCS
{
	AA_MARS_TLV_HDR;

} AA_MARS_TLV_MULTI_IS_MCS;

typedef AA_MARS_TLV_MULTI_IS_MCS UNALIGNED *PAA_MARS_TLV_MULTI_IS_MCS;

#define AAMC_TLVT_MULTI_IS_MCS			((USHORT)0x3a00)

//
//  Type of a NULL TLV
//
#define AAMC_TLVT_NULL					((USHORT)0x0000)

//
//  Bit definitions for the Type field in a MARS TLV.
//
//
//  The Least significant 14 bits indicate the actual type.
//
#define AA_MARS_TLV_TYPE_MASK			((USHORT)0x3fff)

//
//  The most significant 2 bits define the action to be taken
//  when we receive a TLV type that we don't recognize.
//
#define AA_MARS_TLV_ACTION_MASK			((USHORT)0xc000)
#define AA_MARS_TLV_TA_SKIP				((USHORT)0x0000)
#define AA_MARS_TLV_TA_STOP_SILENT		((USHORT)0x1000)
#define AA_MARS_TLV_TA_STOP_LOG			((USHORT)0x2000)
#define AA_MARS_TLV_TA_RESERVED			((USHORT)0x3000)



#include <poppack.h>


//
//  TLV List, internal representation. This stores information about
//  all TLVs sent/received in a packet. For each TLV, there is a
//  BOOLEAN that says whether it is present or not.
//
typedef struct _AA_MARS_TLV_LIST
{
	//
	//  MULTI_IS_MCS TLV:
	//
	BOOLEAN						MultiIsMCSPresent;
	BOOLEAN						MultiIsMCSValue;

	//
	//  Add other TLVs...
	//

} AA_MARS_TLV_LIST, *PAA_MARS_TLV_LIST;



/*++
BOOLEAN
AAMC_PKT_IS_TYPE1_DATA(
	IN	PAA_MC_PKT_TYPE1_SHORT_HEADER		pH
)
--*/
#define AAMC_PKT_IS_TYPE1_DATA(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MC_TYPE1)) && \
			 ((pH)->pro == NET_SHORT(AA_PKT_ETHERTYPE_IP)))

/*++
BOOLEAN
AAMC_PKT_IS_TYPE2_DATA(
	IN	PAA_MC_PKT_TYPE2_SHORT_HEADER		pH
)
--*/
#define AAMC_PKT_IS_TYPE2_DATA(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MC_TYPE2)) && \
			 ((pH)->pro == NET_SHORT(AA_PKT_ETHERTYPE_IP)))


/*++
BOOLEAN
AAMC_PKT_IS_CONTROL(
	IN	PAA_MARS_PKT_FIXED_HEADER			pH
)
--*/
#define AAMC_PKT_IS_CONTROL(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MARS_CONTROL)))


/*++
USHORT
AAMC_GET_TLV_TYPE(
	IN	USHORT								_Type
)
--*/
#define AAMC_GET_TLV_TYPE(_Type)		NET_TO_HOST_SHORT((_Type) & AA_MARS_TLV_TYPE_MASK)


/*++
USHORT
AAMC_GET_TLV_ACTION(
	IN	USHORT								_Type
)
--*/
#define AAMC_GET_TLV_ACTION(_Type)		NET_TO_HOST_SHORT((_Type) & AA_MARS_TLV_ACTION_MASK)


/*++
SHORT
AAMC_GET_TLV_TOTAL_LENGTH(
	IN	SHORT								_TlvLength
)
Given the value stored in the Length field of a TLV, return
the total (rounded-off) length of the TLV. This is just the
length of the TLV header plus the given length rounded off
to the nearest multiple of 4.
--*/
#define AAMC_GET_TLV_TOTAL_LENGTH(_TlvLength)	\
			(sizeof(AA_MARS_TLV_HDR) +			\
			 (_TlvLength) +						\
			 ((4 - ((_TlvLength) & 3)) % 4))


/*++
BOOLEAN
AAMC_IS_NULL_TLV(
	IN	PAA_MARS_TLV_HDR					_pTlv
)
Return TRUE iff the given TLV is a NULL TLV, meaning end of list.
--*/
#define AAMC_IS_NULL_TLV(_pTlv)					\
			(((_pTlv)->Type == 0x0000) && ((_pTlv)->Length == 0x0000))

#endif _MARS_PKT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\marspkt.c ===
/*++

	Copyright (c) 1996  Microsoft Corporation

Module Name:

	mars.c

Abstract:

	Routines that build and parse MARS packets.


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-12-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'TKPM'



#ifdef IPMCAST

PUCHAR
AtmArpMcMakePacketCopy(
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	ULONG						TotalLength
)
/*++

Routine Description:

	Make a copy of the contents of the given NDIS packet. Allocate
	a contiguous piece of memory for this.

Arguments:

	pNdisPacket				- Pointer to the NDIS packet structure
	pNdisBuffer				- Pointer to the first NDIS Buffer in the packet
	TotalLength				- Total Length of the packet

Return Value:

	Pointer to the copy, if allocation was successful. Otherwise NULL.

--*/
{
	PUCHAR				pCopyBuffer;
	PUCHAR				pCopyDestination;
	PUCHAR				pNdisData;
	ULONG				BufferLength;

	AA_ALLOC_MEM(pCopyBuffer, UCHAR, TotalLength);
	if (pCopyBuffer != (PUCHAR)NULL)
	{
		pCopyDestination = pCopyBuffer;

		while (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisQueryBuffer(
				pNdisBuffer,
				&pNdisData,
				&BufferLength
				);

			AA_COPY_MEM(pCopyDestination, pNdisData, BufferLength);
			pCopyDestination += BufferLength;

			pNdisBuffer = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		}
	}

	return (pCopyBuffer);
}


BOOLEAN
AtmArpMcProcessPacket(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						TotalLength,
	IN	ULONG						FirstBufferLength
)
/*++

Routine Description:

	Process a received packet, which is potentially a MARS control or
	multicast data packet. If it is a data packet, pass it up to IP.
	Otherwise, process it here.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pNdisPacket				- Pointer to the NDIS packet structure
	pNdisBuffer				- Pointer to the first NDIS Buffer in the packet
	pPktHeader				- Pointer to the start of the packet contents
	TotalLength				- Total packet length
	FirstBufferLength		- Length of first NDIS buffer in packet.

Return Value:

	TRUE if we decide to discard this packet, FALSE if it is a valid packet.

--*/
{
	PATMARP_INTERFACE				pInterface;
	ULONG							HeaderLength;
	PAA_MC_PKT_TYPE1_SHORT_HEADER	pType1Header;
	PAA_MC_PKT_TYPE2_SHORT_HEADER	pType2Header;
	PAA_MARS_PKT_FIXED_HEADER		pControlHeader;
	BOOLEAN							IsIPPacket;		// Is this an IP packet?
	BOOLEAN							DiscardThis;	// Should we discard this?
	BOOLEAN							MadeACopy;		// Did we make a copy of this?
	AA_MARS_TLV_LIST				TlvList;
	
	//
	//  Initialize
	//
	IsIPPacket = TRUE;
	DiscardThis = FALSE;
	MadeACopy = FALSE;
	pInterface = pVc->pInterface;

	AA_SET_MEM(&TlvList, 0, sizeof(TlvList));

	do
	{
		//
		//  Check if we have a multicast data packet. Since we only
		//  support IPv4, we only expect to see short form headers.
		//
		pType1Header = (PAA_MC_PKT_TYPE1_SHORT_HEADER)pPktHeader;
		if (AAMC_PKT_IS_TYPE1_DATA(pType1Header))
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD,
				("McProcessPacket: pVc 0x%x, Pkt 0x%x, Type 1, %d bytes, CMI %d\n",
						pVc, pNdisPacket, TotalLength, pType1Header->cmi));
	
			AAMCDEBUGPDUMP(AAD_EXTRA_LOUD+500, pPktHeader, MIN(FirstBufferLength, 96));
#if DBG
			if (AaDataDebugLevel & AAD_DATA_IN)
			{
				IP_ADDRESS			IPAddress;

				if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
					(pVc->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY))
				{
					IPAddress = pVc->pAtmEntry->pIpEntryList->IPAddress;
				}
				else
				{
					IPAddress = 0;
				}

				AADEBUGP(AAD_WARNING,
					("%d <= %d.%d.%d.%d\n",
						TotalLength,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			}
#endif // DBG

#if 0
	//
	//  Bug #138261: Local clients can never receive multicast packets
	//  sent out by a local application because of this.
	//
			if (pType1Header->cmi == pInterface->ClusterMemberId)
			{
				//
				//  This is a copy of a packet we sent out.
				//
				DiscardThis = TRUE;
				break;
			}

#endif // 0
			HeaderLength = sizeof(AA_MC_PKT_TYPE1_SHORT_HEADER); 
		}
		else
		{
			pType2Header = (PAA_MC_PKT_TYPE2_SHORT_HEADER)pPktHeader;
	
			if (AAMC_PKT_IS_TYPE2_DATA(pType2Header))
			{
		
				AAMCDEBUGP(AAD_EXTRA_LOUD,
					("McProcessPacket: pVc 0x%x, pNdisPacket 0x%x, Type 2 data\n",
							pVc, pNdisPacket));
		
				HeaderLength = sizeof(AA_MC_PKT_TYPE2_SHORT_HEADER);
			}
			else
			{
				IsIPPacket = FALSE;
			}
		}


		if (IsIPPacket)
		{
			AA_IF_STAT_INCR(pInterface, InNonUnicastPkts);

			//
			//  Send this up to IP. HeaderLength now contains the number
			//  of header bytes we need to strip off.
			//
			(pInterface->IPRcvHandler)(
					pInterface->IPContext,
					(PVOID)((PUCHAR)pPktHeader+HeaderLength),
					FirstBufferLength - HeaderLength,
					TotalLength - HeaderLength,
					(NDIS_HANDLE)pNdisPacket,
					HeaderLength,
					(UINT)TRUE		// Is NON Unicast
				#if P2MP
					,NULL
				#endif //P2MP
					);

			break;
		}

		//
		//  Check if this is a valid MARS control packet.
		//
		pControlHeader = (PAA_MARS_PKT_FIXED_HEADER)pPktHeader;
		if (AAMC_PKT_IS_CONTROL(pControlHeader))
		{
			//
			//  We ignore the checksum (the RFC allows us to do so).
			//
			AAMCDEBUGP(AAD_EXTRA_LOUD+10,
				("McProcessPacket: pControlHeader 0x%x, Op 0x%x, TotalLen %d\n",
						pControlHeader, pControlHeader->op, TotalLength));

			//
			//  If the entire MARS packet isn't in the first NDIS buffer,
			//  we make a copy into a single contiguous chunk of memory,
			//  to ease parsing.
			//
			if (FirstBufferLength == TotalLength)
			{
				MadeACopy = FALSE;
			}
			else
			{
				pControlHeader = (PAA_MARS_PKT_FIXED_HEADER)
									AtmArpMcMakePacketCopy(
										pNdisPacket,
										pNdisBuffer,
										TotalLength
										);

				if (pControlHeader == (PAA_MARS_PKT_FIXED_HEADER)NULL)
				{
					//
					//  Allocation failed. Discard this packet.
					//
					DiscardThis = TRUE;
					break;
				}
				else
				{
					MadeACopy = TRUE;
				}
			}

			if (!AtmArpMcPreprocess(pControlHeader, TotalLength, &TlvList))
			{
				AAMCDEBUGP(AAD_INFO,
					("McProcessPacket: PreProcess failed: pHdr 0x%x, TotalLength %d\n",
						pControlHeader, TotalLength));

				DiscardThis = TRUE;
				break;
			}

			switch (NET_TO_HOST_SHORT(pControlHeader->op))
			{
				case AA_MARS_OP_TYPE_MULTI:
					AtmArpMcHandleMulti(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;

				case AA_MARS_OP_TYPE_JOIN:
				case AA_MARS_OP_TYPE_LEAVE:
					AtmArpMcHandleJoinOrLeave(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_NAK:
					AtmArpMcHandleNak(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_GROUPLIST_REPLY:
					AtmArpMcHandleGroupListReply(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_REDIRECT_MAP:
					AtmArpMcHandleRedirectMap(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_MIGRATE:
					AtmArpMcHandleMigrate(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				default:
					AAMCDEBUGP(AAD_WARNING,
					("pVc 0x%x, pNdisPacket 0x%x, pHdr 0x%x, bad/unknown op 0x%x\n",
							pVc, pNdisPacket, pControlHeader, pControlHeader->op));
					AA_ASSERT(FALSE);
					break;

			} // switch (op)

		} // if Control packet
		break;

	}
	while (FALSE);

	if (MadeACopy)
	{
		AA_FREE_MEM(pControlHeader);
	}

	return (DiscardThis);
}



BOOLEAN
AtmArpMcPreprocess(
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	OUT	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Do preliminary checks on a received MARS control packet.
	Go through any TLVs, and make sure we can either handle or
	safely ignore them. Be prepared to receive complete garbage in this packet.



	Update *pTlvList with information about all valid TLVs that we see.

Arguments:

	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.

Return Value:

	TRUE if the packet passed all checks, FALSE otherwise.

--*/
{
	ULONG				ExtensionOffset;
	PAA_MARS_TLV_HDR	pTlv;
	ULONG				TlvSpaceLeft;	// in packet
	ULONG				TlvLength;
	ULONG				TlvType;
	ULONG				TlvAction;
	BOOLEAN				Passed;
	BOOLEAN				TlvOk;

	Passed = TRUE;

	do
	{
		//
		//	The USHORT casts below and in obtaining TlvLengths are important
		//  in order to ensure that these values are less than 2^16.
		//	Since they are less than 2^16, any sums involving them will not overflow.
		//
		ExtensionOffset = (USHORT)NET_TO_HOST_SHORT(pControlHeader->extoff);


		if (ExtensionOffset != 0)
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD+20,
				("McPreprocess: pControlHdr 0x%x, ExtOff %d, TotalLength %d\n",
					pControlHeader, ExtensionOffset, TotalLength));

			//
			//  Is there space for atleast one TLV?
			//
			if ((ExtensionOffset
				  + sizeof(AA_PKT_LLC_SNAP_HEADER) + sizeof(AA_MARS_TLV_HDR))
				 > TotalLength)
			{
				Passed = FALSE;
				break;
			}

			pTlv = (PAA_MARS_TLV_HDR)((PUCHAR)pControlHeader +
									 ExtensionOffset + sizeof(AA_PKT_LLC_SNAP_HEADER));

			TlvSpaceLeft = (TotalLength - ExtensionOffset - sizeof(AA_PKT_LLC_SNAP_HEADER));

			do
			{
				TlvType = AAMC_GET_TLV_TYPE(pTlv->Type);
				TlvAction = AAMC_GET_TLV_ACTION(pTlv->Type);

				//
				//  Get the rounded-off TLV length
				//
				TlvLength = (USHORT) NET_TO_HOST_SHORT(pTlv->Length);
				TlvLength = AAMC_GET_TLV_TOTAL_LENGTH(TlvLength);

				if (TlvLength > TlvSpaceLeft)
				{
					AAMCDEBUGP(AAD_WARNING,
						("McPreprocess: Hdr 0x%x, pTlv 0x%x: TlvLength %d > TlvSpaceLeft %d\n",
							pControlHeader, pTlv, TlvLength, TlvSpaceLeft));
					Passed = FALSE;
					break;
				}

				TlvOk = FALSE;

				switch (TlvType)
				{
					case AAMC_TLVT_MULTI_IS_MCS:
						if (TlvLength == sizeof(AA_MARS_TLV_MULTI_IS_MCS))
						{
							TlvOk = TRUE;
							pTlvList->MultiIsMCSPresent =
							pTlvList->MultiIsMCSValue = TRUE;
						}
						break;
					case AAMC_TLVT_NULL:
						if (TlvLength == 0)
						{
							TlvOk = TRUE;
						}
						break;
					default:
						break;
				}

				if (!TlvOk)
				{
					if (TlvAction == AA_MARS_TLV_TA_STOP_SILENT)
					{
						Passed = FALSE;
						break;
					}

					if (TlvAction == AA_MARS_TLV_TA_STOP_LOG)
					{
						AA_LOG_ERROR();
						Passed = FALSE;
						break;
					}
				}

				pTlv = (PAA_MARS_TLV_HDR)((PUCHAR)pTlv + TlvLength);
				TlvSpaceLeft -= TlvLength;
			}
			while (TlvSpaceLeft >= sizeof(AA_MARS_TLV_HDR));

			if (TlvSpaceLeft != 0)
			{
				//
				//  Improperly formed TLV at the end of the packet.
				//
				AAMCDEBUGP(AAD_LOUD,
					("McPreprocess: residual space left at end of Pkt 0x%x: %d bytes\n",
						pControlHeader, TlvSpaceLeft));

				Passed = FALSE;
			}
		}

		break;

	}
	while (FALSE);

	return (Passed);
}



VOID
AtmArpMcHandleMulti(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_MULTI message. We first look up the IP Entry
	for the group address being resolved/revalidated. If we aren't
	in "Discard mode" on this entry and the MULTI sequence number is ok,
	then we add all ATM endstations returned in this MULTI (that aren't
	present already) to the ATM Entry for this multicast group.

	If this is the last MULTI for the multicast group, we initiate/update
	our point-to-multipoint connection for sending data to the group.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	pTlvList				- All TLVs seen in this packet

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_MULTI_HEADER	pMultiHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	ULONG					MarsSeqNumber;	// MSN received in this packet
	ULONG					HostSeqNumber;	// Our MSN
	ULONG					SeqDiff;		// Difference between MSN and the HSN
	USHORT					SequenceNoY;	// MULTI sequence number
	BOOLEAN					IsLastMulti;	// Is this the final MULTI response?
	BOOLEAN					bWasRunning;	// Was a timer running?
	IP_ADDRESS				IPAddress;		// the address being queried
	PNDIS_PACKET			pPacketList;
	BOOLEAN					IsUnicastResolution;	// Did we resolve to a single MCS?

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pMultiHeader = (PAA_MARS_MULTI_HEADER)pControlHeader;

	do
	{
		ULONG		rc;
		//
		//  Get the sequence number of this MARS MULTI.
		//
		SequenceNoY = NET_TO_HOST_SHORT(pMultiHeader->seqxy);
		IsLastMulti =  ((SequenceNoY & AA_MARS_X_MASK) != 0);
		SequenceNoY = (SequenceNoY & AA_MARS_Y_MASK);

		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pMultiHeader->msn);

		//
		//  If this is the last MULTI in reply to our REQUEST,
		//  calculate the Seq # difference.
		//
		if (IsLastMulti)
		{
			AA_ACQUIRE_IF_LOCK(pInterface);
			HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
			pInterface->HostSeqNumber = MarsSeqNumber;	// and update
			AA_RELEASE_IF_LOCK(pInterface);

			SeqDiff = MarsSeqNumber - HostSeqNumber;
		}

		//
		//  Get the group address being responded to.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pMultiHeader +
						sizeof(AA_MARS_MULTI_HEADER) +
						(pMultiHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMultiHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMultiHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleMulti: 0x%x, IP %d.%d.%d.%d, MSN %d, HSN %d, Last %d, Y %d, tnum %d\n",
						pMultiHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						MarsSeqNumber,
						HostSeqNumber,
						(ULONG)IsLastMulti,
						(ULONG)SequenceNoY,
						NET_TO_HOST_SHORT(pMultiHeader->tnum)
						));
					

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_AE,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		//
		// AtmArpSearchForIPAddress addreffs pIpEntry for us ...
		//

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleMulti: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}


		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		//
		//  A resolution timer may be running here - stop it.
		//

		bWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
		if (bWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // Timer ref
			AA_ASSERT(rc != 0);
		}

		IsUnicastResolution = (IsLastMulti &&
								(NET_TO_HOST_SHORT(pMultiHeader->tnum) == 1) &&
								(pTlvList->MultiIsMCSValue == TRUE));


		//
		// Check if the multi request is compatible with the existing atm
		// entry (if any) associated with the ip entry. If they are not,
		// then we must abort the IP entry and get out of here, because
		// there was possibly a switch in status of this IP group address from
		// being vc-mesh served to mcs served, or vice versa.
		//
		if (pIpEntry->pAtmEntry)
		{
			if (	(IsUnicastResolution && pIpEntry->pAtmEntry->pMcAtmInfo != NULL)
				||  (!IsUnicastResolution && pIpEntry->pAtmEntry->pMcAtmInfo ==NULL))
			{
				AAMCDEBUGP(AAD_WARNING,
					("HandleMulti: Type Mismatch! %s pIpEntry 0x%x/%x (%d.%d.%d.%d) linked to ATMEntry 0x%x\n",
							((IsUnicastResolution) ? "MCS" : "VC-Mesh"),
							pIpEntry, pIpEntry->Flags,
							((PUCHAR)&(pIpEntry->IPAddress))[0],
							((PUCHAR)&(pIpEntry->IPAddress))[1],
							((PUCHAR)&(pIpEntry->IPAddress))[2],
							((PUCHAR)&(pIpEntry->IPAddress))[3],
							pIpEntry->pAtmEntry));
				
				//
				// Remove the AE_REF implicitly added by AtmArpMcLookupAtmMember
				// above...
				//
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
				if (rc!=0)
				{
					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//
				}

				break;
			}
		}


		//
		//  Check if we are in discard mode, or this MULTI has a bad
		//  sequence number. In either case, discard this MULTI, otherwise
		//  process it.
		//
		if (!AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_DISCARDING_MULTI
					) &&
			(SequenceNoY == pIpEntry->NextMultiSeq))
		{
			PATMARP_ATM_ENTRY	pAtmEntry;
			//
			//  Total entries in this MULTI
			//
			ULONG				NumberOfEntries;
			//
			//  All info about one ATM (leaf) entry:
			//
			PUCHAR				pAtmNumber;
			ULONG				AtmNumberLength;
			ATM_ADDRESSTYPE		AtmNumberType;
			PUCHAR				pAtmSubaddress;
			ULONG				AtmSubaddressLength;
			ATM_ADDRESSTYPE		AtmSubaddressType;

			//
			//  Process this MARS MULTI.
			//
			pIpEntry->NextMultiSeq++;

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMultiHeader->thtl,
				&AtmNumberType,
				&AtmNumberLength);

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMultiHeader->tstl,
				&AtmSubaddressType,
				&AtmSubaddressLength);

			pAtmNumber = ((PUCHAR)pMultiHeader +
							sizeof(AA_MARS_MULTI_HEADER) +
							(pMultiHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMultiHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMultiHeader->spln) +
							(pMultiHeader->tpln));

			if (IsUnicastResolution)
			{

				//
				//  This IP address has resolved to a single ATM address. Search
				//  for (or allocate a new) ATM Entry for this address.
				//
				AAMCDEBUGP(AAD_LOUD, ("McHandleMulti: Unicast res for %d.%d.%d.%d\n",
							((PUCHAR)&IPAddress)[0],
							((PUCHAR)&IPAddress)[1],
							((PUCHAR)&IPAddress)[2],
							((PUCHAR)&IPAddress)[3]));

				AA_RELEASE_IE_LOCK(pIpEntry);
				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				pAtmEntry = AtmArpSearchForAtmAddress(
									pInterface,
									pMultiHeader->thtl,
									pAtmNumber,
									pMultiHeader->tstl,
									(PUCHAR)pAtmNumber + AtmNumberLength,
									AE_REFTYPE_IE,
									TRUE
									);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));


				if (	pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					AAMCDEBUGP(AAD_INFO,
						("McHandleMulti: pIpEntry 0x%x, failed to alloc AtmEntry\n",
							pIpEntry));

					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
					if (rc!=0)
					{
						AtmArpAbortIPEntry(pIpEntry);
						//
						//  IE lock is released within the above.
						//
					}
					break;	// go to end of processing
				}

				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

				//
				// AtmArpSearchForAtmAddress addrefs pAtmEntry for us..
				//

				if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Link the ATM Entry to this IP Entry.
					//

					pIpEntry->pAtmEntry = pAtmEntry;

					AA_SET_FLAG(pAtmEntry->Flags,
								AA_ATM_ENTRY_STATE_MASK,
								AA_ATM_ENTRY_ACTIVE);

					//
					//  Add the IP Entry to the ATM Entry's list of IP Entries
					//  (multiple IP entries could point to the same ATM Entry).
					//
					pIpEntry->pNextToAtm = pAtmEntry->pIpEntryList;
					pAtmEntry->pIpEntryList = pIpEntry;

					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				}
				else
				{
					//
					// There is already a linkage -- deref the
					// references implicitly added for us in the
					// SearchForXXX calls above...
					//

					rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE); // IP
					{
						if (rc != 0)
						{
							AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
						}
					}
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // AE
					if (rc==0)
					{
						//
						// IpEntry gone away...
						//
						break;
					}

				}

				//
				// At this point we have a lock on pIpEntry, but none
				// on pAtmEntry, and we don't have any "extra" refs on
				// either.
				//

				if (pIpEntry->pAtmEntry == pAtmEntry)
				{
					//
					//  Either a fresh IP->ATM resolution, or
					//  reconfirmation of an existing resolution.
					//
					AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "MULTI: Unicast Addr: ", &pAtmEntry->ATMAddress);

					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_MC_RESOLVE_MASK,
								AA_IP_ENTRY_MC_RESOLVED);
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_MC_VALIDATE_MASK,
								AA_IP_ENTRY_MC_NO_REVALIDATION);
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_STATE_MASK,
								AA_IP_ENTRY_RESOLVED);
					pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

#ifdef AGE_MCAST_IP_ENTRIES
	//
	//  Feb 26, 97: we don't need to age out IP multicast entries:
	//  VC aging timer is sufficient.
	// 
					//
					//  Start off IP Aging timeout
					//
					AtmArpStartTimer(
								pInterface,
								&(pIpEntry->Timer),
								AtmArpIPEntryAgingTimeout,
								pInterface->MulticastEntryAgingTimeout,
								(PVOID)pIpEntry
								);

					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref

#endif // AGE_MCAST_IP_ENTRIES

					//
					//  Remove the packet list queued on this IP Entry,
					//  if any.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;

					AA_RELEASE_IE_LOCK(pIpEntry);
					if (pPacketList != (PNDIS_PACKET)NULL)
					{
						//
						//  The following will trigger off MakeCall.
						//
						AtmArpSendPacketListOnAtmEntry(
									pInterface,
									pAtmEntry,
									pPacketList,
									TRUE
									);
					}
				}
				else
				{
					AAMCDEBUGP(AAD_WARNING,
						("HandleMulti: pIpEntry 0x%x/%x (%d.%d.%d.%d) linked to ATMEntry 0x%x, resolves to 0x%x\n",
								pIpEntry, pIpEntry->Flags,
								((PUCHAR)&(pIpEntry->IPAddress))[0],
								((PUCHAR)&(pIpEntry->IPAddress))[1],
								((PUCHAR)&(pIpEntry->IPAddress))[2],
								((PUCHAR)&(pIpEntry->IPAddress))[3],
								pIpEntry->pAtmEntry,
								pAtmEntry));

					AA_STRUCT_ASSERT(pIpEntry->pAtmEntry, aae);

					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//
				}

				break;	// go to end of processing

			} // Unicast resolution

			//
			//  IP Address resolved to multiple ATM addresses.
			//
			pAtmEntry = pIpEntry->pAtmEntry;
			if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
			{
				//
				//  Allocate an ATM Entry and link to this IP Entry.
				//
				pAtmEntry = AtmArpAllocateAtmEntry(pInterface, TRUE);

				if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{

					// Let's deref the implicit addref for pIpEntry...
					// Warning -- we should now not release our lock on
					// pIpEntry until we're completely done with it
					// (unless we first addref it).
					//
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
					if (rc!=0)
					{
						AtmArpAbortIPEntry(pIpEntry);
						//
						//  IE lock is released within the above.
						//
					}
					break;	// go to end of processing
				}

				//
				//  Link them together.
				//
				pIpEntry->pAtmEntry = pAtmEntry;
				pAtmEntry->pIpEntryList = pIpEntry;

				AAMCDEBUGP(AAD_EXTRA_LOUD,
					("McHandleMulti: Multicast: linked pIpEntry 0x%x, pAtmEntry 0x%x\n",
							pIpEntry, pAtmEntry));

				AA_REF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry linkage
				//
				//  Link the ATM entry to this Interface
				//
				AA_RELEASE_IE_LOCK(pIpEntry);
				AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
				if (pInterface->AtmEntryListUp)
				{
					pAtmEntry->pNext = pInterface->pAtmEntryList;
					pInterface->pAtmEntryList = pAtmEntry;
				}
				AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				
			}
			else
			{
				//
				// IP already has an atm entry...
				//
				// Let's deref the implicit addref for pIpEntry...
				// Warning -- we should now not release our lock on
				// pIpEntry until we're completely done with it
				// (unless we first addref it).
				//
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
				if (rc==0)
				{
					//
					// IpEntry gone away...
					//
					break;
				}
			}


			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

			for (NumberOfEntries = NET_TO_HOST_SHORT(pMultiHeader->tnum);
				 NumberOfEntries != 0;
				 NumberOfEntries--)
			{
				pAtmSubaddress = ((PUCHAR)pAtmNumber + AtmNumberLength);

				pMcAtmEntry = AtmArpMcLookupAtmMember(
								pAtmEntry,
								&(pAtmEntry->pMcAtmInfo->pMcAtmEntryList),
								pAtmNumber,
								AtmNumberLength,
								AtmNumberType,
								pAtmSubaddress,
								AtmSubaddressLength,
								TRUE	// Create new entry if not found
								);

				if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					//
					//  Mark this member "valid".
					//
					AA_SET_FLAG(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID);

					AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "MULTI Addr: ", &pMcAtmEntry->ATMAddress);
				}
				else
				{
					//
					//  Resource problems! No point in continuing.
					//
					break;
				}

				pAtmNumber = (PUCHAR)pAtmNumber + AtmNumberLength;

			} // for

			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

			if (IsLastMulti)
			{
				//
				//  We have successfully resolved this Multicast IP Address.
				//
				AAMCDEBUGP(AAD_INFO,
						("### HandleMulti: pIpEntry 0x%x, resolved %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)(&IPAddress))[0],
							((PUCHAR)(&IPAddress))[1],
							((PUCHAR)(&IPAddress))[2],
							((PUCHAR)(&IPAddress))[3]));

				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_RESOLVED);
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_VALIDATE_MASK,
							AA_IP_ENTRY_MC_NO_REVALIDATION);
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);

				pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

				//
				//  Remove the packet list queued on this IP Entry,
				//  if any.
				//
				pPacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;

#ifdef AGE_MCAST_IP_ENTRIES
				//
				//  Start off IP Aging timeout
				//
				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryAgingTimeout,
							pInterface->MulticastEntryAgingTimeout,
							(PVOID)pIpEntry
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref

#endif // AGE_MCAST_IP_ENTRIES

				AA_RELEASE_IE_LOCK(pIpEntry);

				AA_ACQUIRE_AE_LOCK(pAtmEntry);

				AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);

				AtmArpMcUpdateConnection(pAtmEntry);
				//
				//  AE Lock is released within the above.
				//
					
				if (pPacketList != (PNDIS_PACKET)NULL)
				{
					AtmArpSendPacketListOnAtmEntry(
								pInterface,
								pAtmEntry,
								pPacketList,
								TRUE
								);
				}

				AA_ACQUIRE_AE_LOCK(pAtmEntry);

				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);

				if (rc != 0)
				{
					AA_RELEASE_AE_LOCK(pAtmEntry);
				}

			}
			else
			{
				//
				//  Restart the address resolution timer on this entry,
				//  but for a duration equal to the max delay between
				//  MULTI messages.
				//
				AtmArpStartTimer(
						pInterface,
						&(pIpEntry->Timer),
						AtmArpAddressResolutionTimeout,
						pInterface->MaxDelayBetweenMULTIs,
						(PVOID)pIpEntry
						);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Delay b/w MULTI timer ref

				AA_RELEASE_IE_LOCK(pIpEntry);
			}

		}
		else
		{
			AAMCDEBUGP(AAD_WARNING,
				("HandleMULTI: fail condition: pIpEntry 0x%x/0x%x, Addr %d.%d.%d.%d, SeqY %d, NextMultiSeq %d, IsLastMulti %d\n",
					pIpEntry,
					pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3],
					SequenceNoY,
					pIpEntry->NextMultiSeq,
					IsLastMulti
				));

			//
			//  A "failure condition" with this MULTI.
			//
			if (IsLastMulti)
			{
				//
				//  This is the last MULTI of a failed address resolution
				//  sequence. Start off address resolution afresh.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_IDLE2);

				AtmArpResolveIpEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//
			}
			else
			{
				//
				//  Discard all future MULTIs
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_DISCARDING_MULTI);

				AA_RELEASE_IE_LOCK(pIpEntry);
			}
		}

		break;
	}
	while (FALSE);


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleMulti: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

}



VOID
AtmArpMcHandleMigrate(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_MIGRATE_HEADER	pMigrateHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	ULONG					MarsSeqNumber;	// MSN received in this packet
	ULONG					HostSeqNumber;	// Our MSN
	ULONG					SeqDiff;		// Difference between MSN and the HSN
	BOOLEAN					bWasRunning;	// Was a timer running?
	IP_ADDRESS				IPAddress;		// the address being queried

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pMigrateHeader = (PAA_MARS_MIGRATE_HEADER)pControlHeader;

	do
	{
		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pMigrateHeader->msn);

		//
		//  Calculate the Seq # difference.
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
		pInterface->HostSeqNumber = MarsSeqNumber;	// and update
		AA_RELEASE_IF_LOCK(pInterface);

		SeqDiff = MarsSeqNumber - HostSeqNumber;

		//
		//  Get the group address being migrated.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pMigrateHeader +
						sizeof(AA_MARS_MIGRATE_HEADER) +
						(pMigrateHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMigrateHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMigrateHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleMigrate: 0x%x, IP %d.%d.%d.%d, MSN %d, HSN %d\n",
						pMigrateHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						MarsSeqNumber,
						HostSeqNumber));
					

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_TMP,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			// AtmArpSearchForIPAddress addrefs pIpEntry for us ...
			//
			ULONG		rc;
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
			if (rc == 0)
			{
				// Oops, IP address has gone away...
				pIpEntry = NULL_PATMARP_IP_ENTRY;
			}
		}

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleMigrate: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}

		if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
		{
			//
			// This IP address is being resolved.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
			break;
		}

		pAtmEntry = pIpEntry->pAtmEntry;

		if (AA_IS_FLAG_SET(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_TYPE_MASK,
					AA_ATM_ENTRY_TYPE_UCAST))
		{
			AAMCDEBUGP(AAD_INFO,
			("McHandleMigrate: IP Addr %d.%d.%d.%d was unicast, aborting pIpEntry 0x%x\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						pIpEntry));

			AtmArpAbortIPEntry(pIpEntry);
			//
			//  IE Lock is released within the above.
			//
			break;
		}

		//
		//  Check if we are in discard mode.
		//
		if (!AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_DISCARDING_MULTI))
		{
			//
			//  Total entries in this MULTI
			//
			ULONG				NumberOfEntries;
			//
			//  All info about one ATM (leaf) entry:
			//
			PUCHAR				pAtmNumber;
			ULONG				AtmNumberLength;
			ATM_ADDRESSTYPE		AtmNumberType;
			PUCHAR				pAtmSubaddress;
			ULONG				AtmSubaddressLength;
			ATM_ADDRESSTYPE		AtmSubaddressType;

			//
			//  Process this MARS MIGRATE fully.
			//

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMigrateHeader->thtl,
				&AtmNumberType,
				&AtmNumberLength);

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMigrateHeader->tstl,
				&AtmSubaddressType,
				&AtmSubaddressLength);

			pAtmNumber = ((PUCHAR)pMigrateHeader +
							sizeof(AA_MARS_MIGRATE_HEADER) +
							(pMigrateHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMigrateHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMigrateHeader->spln) +
							(pMigrateHeader->tpln));

			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

			for (NumberOfEntries = pMigrateHeader->tnum;
				 NumberOfEntries != 0;
				 NumberOfEntries--)
			{
				pAtmSubaddress = ((PUCHAR)pAtmNumber + AtmNumberLength);

				pMcAtmEntry = AtmArpMcLookupAtmMember(
								pAtmEntry,
								&(pAtmEntry->pMcAtmInfo->pMcAtmMigrateList),
								pAtmNumber,
								AtmNumberLength,
								AtmNumberType,
								pAtmSubaddress,
								AtmSubaddressLength,
								TRUE	// Create new entry if not found
								);

				if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					//
					//  Mark this member "valid".
					//
					AA_SET_FLAG(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID);
				}
				else
				{
					//
					//  Resource problems! No point in continuing.
					//
					break;
				}

				pAtmNumber = (PUCHAR)pAtmNumber + AtmNumberLength;

			} // for

			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_RESOLVE_MASK,
						AA_IP_ENTRY_MC_RESOLVED);
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_VALIDATE_MASK,
						AA_IP_ENTRY_MC_NO_REVALIDATION);
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_RESOLVED);

			pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

			//
			//  Now close the PMP VC for this group, if one exists.
			//  If we don't have a VC, start a connection.
			//
			pVc = pIpEntry->pAtmEntry->pVcList;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pVc != (PATMARP_VC)NULL)
			{
				AA_ACQUIRE_VC_LOCK(pVc);
				//
				//  When the call is closed, we start a new
				//  PMP connection, using the migrate list.
				//
				AtmArpCloseCall(pVc);
			}
			else
			{
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				AtmArpMcUpdateConnection(pAtmEntry);
				//
				//  AE Lock is released within the above.
				//
			}

		}
		else
		{
			//
			//  Discard this MIGRATE
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}

		break;
	}
	while (FALSE);


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleMigrate: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

}



VOID
AtmArpMcHandleJoinOrLeave(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_JOIN/MARS_LEAVE message. If this is a copy of a
	message that we had sent, then there are two cases: (1) we are registering with
	MARS, in which case we send MARS_JOINs for all pending Joins (2) we were
	Joining a multicast group, in which case the Join operation is complete.

	If this is not a copy of a MARS_JOIN originated from us, then we check if
	the multicast group being joined is one to which we are sending. If so,
	and if the station joining is not already a member of that group, we add it.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	pTlvList				- All TLVs seen in this packet

Return Value:

	None

--*/
{
	PAA_MARS_JOIN_LEAVE_HEADER	pJoinHeader;
	PATMARP_INTERFACE			pInterface;		// IF on which this packet arrived
	ULONG						IfState;		// State of the interface
	IP_ADDRESS					IPAddress;
	PATMARP_IP_ENTRY			pIpEntry;		// Our entry for the group being joined
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	ULONG						MarsSeqNumber;	// MSN received in this packet
	ULONG						HostSeqNumber;	// Our MSN
	ULONG						SeqDiff;		// Difference between MSN and the HSN
	USHORT						Flags;			// From the JOIN packet
	BOOLEAN						bLayer3Group;	// Is a Layer 3 explicitly Joining?
	BOOLEAN						bCopyBitSet;	// Is the COPY bit set?
	BOOLEAN						bRegister;		// Is this a cluster member registering?
	BOOLEAN						bPunched;		// Is the Punched bit set?
	PUCHAR						pSrcAtmNumber;
	PUCHAR						pSrcAtmSubaddress;
	BOOLEAN						bIsAtmNumberOurs;	// Is the source ATM Number ours?
	ATM_ADDRESSTYPE				AtmNumberType;
	ULONG						AtmNumberLength;
	ATM_ADDRESSTYPE				AtmSubaddressType;
	ULONG						AtmSubaddressLength;
	IP_ADDRESS UNALIGNED *		pMinIPAddress;
	IP_ADDRESS UNALIGNED *		pMaxIPAddress;
	IP_ADDRESS					MinIPAddress;
	IP_ADDRESS					MaxIPAddress;
	BOOLEAN						IsJoin;			// Is this a JOIN?
	BOOLEAN						ProcessMcSendList = TRUE;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pJoinHeader = (PAA_MARS_JOIN_LEAVE_HEADER)pControlHeader;

	IsJoin = (pJoinHeader->op == NET_SHORT(AA_MARS_OP_TYPE_JOIN));

	//
	//  Get the MARS Sequence Number in this message.
	//
	MarsSeqNumber = NET_TO_HOST_LONG(pJoinHeader->msn);

	AA_ACQUIRE_IF_LOCK(pInterface);
	HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
	pInterface->HostSeqNumber = MarsSeqNumber;	// and update
	IfState = AAMC_IF_STATE(pInterface);
	AA_RELEASE_IF_LOCK(pInterface);

	SeqDiff = MarsSeqNumber - HostSeqNumber;

	//
	//  Get all "flag" values:
	//
	Flags = pJoinHeader->flags;
	bLayer3Group = ((Flags & AA_MARS_JL_FLAG_LAYER3_GROUP) != 0);
	bCopyBitSet = ((Flags & AA_MARS_JL_FLAG_COPY) != 0);
	bRegister = ((Flags & AA_MARS_JL_FLAG_REGISTER) != 0);
	bPunched = ((Flags & AA_MARS_JL_FLAG_PUNCHED) != 0);

	//
	//  Get at the source ATM number
	//
	pSrcAtmNumber = ((PUCHAR)pJoinHeader +
 					sizeof(AA_MARS_JOIN_LEAVE_HEADER));

	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
		pJoinHeader->shtl,
		&AtmNumberType,
		&AtmNumberLength);

	//
	//  Get at the source ATM subaddress
	//
	pSrcAtmSubaddress = ((PUCHAR)pSrcAtmNumber + AtmNumberLength);
						
	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
		pJoinHeader->sstl,
		&AtmSubaddressType,
		&AtmSubaddressLength);

	bIsAtmNumberOurs = ((AtmNumberType == pInterface->LocalAtmAddress.AddressType) &&
						(AtmNumberLength == pInterface->LocalAtmAddress.NumberOfDigits) &&
						(AA_MEM_CMP(pSrcAtmNumber,
									pInterface->LocalAtmAddress.Address,
									AtmNumberLength) == 0));


	pMinIPAddress = (PIP_ADDRESS)((PUCHAR)pJoinHeader +
 							sizeof(AA_MARS_JOIN_LEAVE_HEADER)+
 							AtmNumberLength +
 							AtmSubaddressLength +
 							(pJoinHeader->spln & ~AA_PKT_ATM_ADDRESS_BIT));

	pMaxIPAddress = (PIP_ADDRESS)((PUCHAR)pMinIPAddress +
							(pJoinHeader->tpln & ~AA_PKT_ATM_ADDRESS_BIT));

	AAMCDEBUGP(AAD_LOUD,
		("Handle %s: Flags 0x%x, OurAtmNum %d, Punch %d, Copy %d, pnum %d, IFState 0x%x\n",
			(IsJoin? "JOIN": "LEAVE"),
			Flags,
			(ULONG)bIsAtmNumberOurs,
			(ULONG)bPunched,
			(ULONG)bCopyBitSet,
			pJoinHeader->pnum,
			AAMC_IF_STATE(pInterface)
		));

	AAMCDEBUGP(AAD_LOUD,
		("Handle %s: Min %d.%d.%d.%d, Max %d.%d.%d.%d\n",
			(IsJoin? "JOIN": "LEAVE"),
			((PUCHAR)pMinIPAddress)[0], ((PUCHAR)pMinIPAddress)[1],
			((PUCHAR)pMinIPAddress)[2], ((PUCHAR)pMinIPAddress)[3],
			((PUCHAR)pMaxIPAddress)[0], ((PUCHAR)pMaxIPAddress)[1],
			((PUCHAR)pMaxIPAddress)[2], ((PUCHAR)pMaxIPAddress)[3]));

	if (bIsAtmNumberOurs && (!bPunched) && bCopyBitSet)
	{
		//
		//  Potentially sent by us
		//

		ProcessMcSendList = FALSE; // we may set it back  to true -- see below.

		if (IfState == AAMC_IF_STATE_REGISTERING)
		{
			if (IsJoin &&
				bRegister &&
				(pJoinHeader->pnum == 0))
			{
				BOOLEAN		WasRunning;

				//
				//  Registration complete. Get our Cluster Member ID.
				//  We store this in network order so that we can
				//  use it to fill packets directly.
				//
				AA_ACQUIRE_IF_LOCK(pInterface);

				pInterface->ClusterMemberId = pJoinHeader->cmi;

				AAMCDEBUGP(AAD_INFO,
					("==== HandleJoin: pIf 0x%x, registered with MARS, CMI %d!\n",
						 pInterface, pInterface->ClusterMemberId));

				AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_REGISTERED);

				//
				//  Stop the MARS Registration timer.
				//
				WasRunning = AtmArpStopTimer(&(pInterface->McTimer), pInterface);
				AA_ASSERT(WasRunning);

				//
				//  Start MARS wait-for-keepalive timer.
				//
				AtmArpStartTimer(
						pInterface,
						&(pInterface->McTimer),
						AtmArpMcMARSKeepAliveTimeout,
						pInterface->MARSKeepAliveTimeout,
						(PVOID)pInterface
					);

				//
				//  If we are recovering from a MARS failure,
				//  then we need to initiate revalidation of all
				//  groups we send to.
				//
				if (!AA_IS_FLAG_SET(pInterface->Flags,
									AAMC_IF_MARS_FAILURE_MASK,
									AAMC_IF_MARS_FAILURE_NONE))
				{
					AA_SET_FLAG(pInterface->Flags,
								AAMC_IF_MARS_FAILURE_MASK,
								AAMC_IF_MARS_FAILURE_NONE);

					SeqDiff = 2;	// a dirty way of triggering the above
				}

				//
				//  Send any JOINs we have pended waiting for registration
				//  to be over.
				//
				//  TBDMC: Section 5.4.1 recommends that if we are doing this
				//  after a failure recovery, then a random delay should be
				//  inserted between JOINs...
				//
				AtmArpMcSendPendingJoins(pInterface);
				//
				// IF Lock is released within the above.
				//
			}
			//
			//  else Discard: we aren't interested in this packet
			//
		}
		else
		{
			//
			//  Potentially a Join/Leave sent by us for a multicast group
			//
			if (pJoinHeader->pnum == HOST_TO_NET_SHORT(1))
			{

				//
				// Check if this came on the cluster control vc (or rather,  we cheat
				// and simply check if this is an incoming vc) -- if
				// so we want to also process the McSendList to see if
				// we need to add/remove ourselves to any mc ip send entries.
				//
				if (AA_IS_FLAG_SET(
						pVc->Flags,
						AA_VC_OWNER_MASK,
						AA_VC_OWNER_IS_CALLMGR))
				{
					ProcessMcSendList = TRUE;
				}

				//
				//  Get the IP address range of group being joined/left.
				//

				IPAddress =  *pMinIPAddress;

				AtmArpMcHandleJoinOrLeaveCompletion(
					pInterface,
					IPAddress,
					IPAddress ^ *pMaxIPAddress,
 					IsJoin);

			}
			//
			//  else Discard: bad pnum
			//
		}
	}

	if (ProcessMcSendList)
	{
		//
		//  Not sent by us, or punched, or it was sent by us but it came on the
		//  cluster control vc. For each <Min, Max> pair in this message,
		//  check if the pair overlaps any of the MC addresses to which
		//  we send packets. For each such IP entry, we find the MC ATM
		//  Entry corresponding to the host that is joining/leaving,
		//  and if necessary, mark it as needing a connection update.
		//
		//  Then, we go thru the list of MC IP Entries, and start a
		//  connection update on all marked entries.
		//

		BOOLEAN		bWorkDone;
		USHORT		MinMaxPairs;

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		MinMaxPairs = NET_TO_HOST_SHORT(pJoinHeader->pnum);
		pIpEntry = pInterface->pMcSendList;

		while (MinMaxPairs--)
		{
			MinIPAddress = NET_LONG(*pMinIPAddress);
			MaxIPAddress = NET_LONG(*pMaxIPAddress);

			while (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				IPAddress = NET_LONG(pIpEntry->IPAddress);

				if (IPAddress <= MaxIPAddress)
				{
					if (IPAddress >= MinIPAddress)
					{
						//
						//  This is an IP Entry that might be affected.
						//

						AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
						AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
						do
						{
							BOOLEAN				bNeedToUpdateConnection;
			
							if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
							{
								//
								//  Skip this because it hasn't been resolved.
								//
								break;
							}
		
							pAtmEntry = pIpEntry->pAtmEntry;

							if (AA_IS_FLAG_SET(pAtmEntry->Flags,
												AA_ATM_ENTRY_TYPE_MASK,
												AA_ATM_ENTRY_TYPE_UCAST))
							{
								if ((AtmNumberType != pAtmEntry->ATMAddress.AddressType) ||
									(AtmNumberLength != pAtmEntry->ATMAddress.NumberOfDigits) ||
									(AA_MEM_CMP(pSrcAtmNumber,
											    pAtmEntry->ATMAddress.Address,
											    AtmNumberLength) != 0))
								{
									//
									//  Addresses don't match; if this is a new JOIN,
									//  then this IP Entry needs updating.
									//
									bNeedToUpdateConnection = (IsJoin);
								}
								else
								{
									bNeedToUpdateConnection = !(IsJoin);
								}
								 
								if (bNeedToUpdateConnection)
								{
									//
									//  Mark this entry so that we abort it below.
									//
									AA_SET_FLAG(pIpEntry->Flags,
												AA_IP_ENTRY_STATE_MASK,
												AA_IP_ENTRY_ABORTING);
								}

								break;	// end of Unicast ATM Entry case
							}

							//
							//  Multicast IP Entry.
							//
							pMcAtmEntry = AtmArpMcLookupAtmMember(
												pIpEntry->pAtmEntry,
												&(pAtmEntry->pMcAtmInfo->pMcAtmEntryList),
												pSrcAtmNumber,
												AtmNumberLength,
												AtmNumberType,
												pSrcAtmSubaddress,
												AtmSubaddressLength,
												IsJoin
												);
			
							if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
							{
								AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD,
									(IsJoin? "Join Addr: ": "Leave Addr"),
									&pMcAtmEntry->ATMAddress);

								if (!IsJoin)
								{
									//
									//  Mark this entry so that it will be dropped from
									//  our connection to this multicast group.
									//
									if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
														AA_IPMC_AE_GEN_STATE_MASK,
														AA_IPMC_AE_VALID))
									{
										AA_SET_FLAG(pMcAtmEntry->Flags,
													AA_IPMC_AE_GEN_STATE_MASK,
													AA_IPMC_AE_INVALID);
			
										bNeedToUpdateConnection = TRUE;
									}
								}
								else
								{
									bNeedToUpdateConnection =
										(AA_IS_FLAG_SET(pMcAtmEntry->Flags,
														AA_IPMC_AE_CONN_STATE_MASK,
														AA_IPMC_AE_CONN_DISCONNECTED));
								}
			
								if (bNeedToUpdateConnection)
								{
									//
									//  Mark this ATM MC entry as wanting a connection
									//  update.
									//
									pIpEntry->pAtmEntry->pMcAtmInfo->Flags |=
												AA_IPMC_AI_WANT_UPDATE;
								}
							}
							break;
						}
						while (FALSE);
									
						AA_RELEASE_IE_LOCK_DPC(pIpEntry);
					}

					pIpEntry = pIpEntry->pNextMcEntry;
				}
				else
				{
					//
					//  This IP Address lies beyond this <Min, Max> pair.
					//  Go to the next pair.
					//
					break;
				}
			}

			if (pIpEntry == NULL_PATMARP_IP_ENTRY)
			{
				break;
			}

			pMinIPAddress = (PIP_ADDRESS)((PUCHAR)pMaxIPAddress +
								(pJoinHeader->tpln & ~AA_PKT_ATM_ADDRESS_BIT));

		} // while loop processing all <Min, Max> pairs

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		//
		//  Now, for each ATM MC entry that we marked in the previous
		//  step, start a connection update.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		//
		// We keep running through the McSendList, stopping when no work is done.
		// This is because in order to "do work" we must release the table lock,
		// in which case the McSendList may be modified by someone else.
		//
		do
		{
			bWorkDone = FALSE;

			for (pIpEntry = pInterface->pMcSendList;
 				 pIpEntry != NULL_PATMARP_IP_ENTRY;
 				 pIpEntry = pIpEntry->pNextMcEntry)
			{
				ULONG		McAiFlags;

				pAtmEntry = pIpEntry->pAtmEntry;

				if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Not yet resolved. Skip this one.
					//
					continue;
				}

				if (AA_IS_FLAG_SET(pIpEntry->Flags,
									AA_IP_ENTRY_STATE_MASK,
									AA_IP_ENTRY_ABORTING))
				{
					//
					//  Must be a unicast entry that we marked above.
					//
					AA_RELEASE_IF_TABLE_LOCK(pInterface);
					
					bWorkDone = TRUE;
					AA_ACQUIRE_IE_LOCK(pIpEntry);
					AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//

					AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
					break;
				}

				//
				//  If this is a unicast ATM Entry, there is nothing
				//  more to be done. If this needed revalidation, 
				//  we would have aborted it above.
				//
				if (AA_IS_FLAG_SET(pAtmEntry->Flags,
									AA_ATM_ENTRY_TYPE_MASK,
									AA_ATM_ENTRY_TYPE_UCAST))
				{
					continue;
				}

				AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

				McAiFlags = pAtmEntry->pMcAtmInfo->Flags;

				if (McAiFlags & AA_IPMC_AI_BEING_UPDATED)
				{
					//
					//  Nothing to be done on this one.
					//
					continue;
				}

				if (McAiFlags & AA_IPMC_AI_WANT_UPDATE) 
				{
					//
					//  Needs a connection update.
					//

					AA_RELEASE_IF_TABLE_LOCK(pInterface);

					bWorkDone = TRUE;
					AA_ACQUIRE_AE_LOCK(pAtmEntry);
					AtmArpMcUpdateConnection(pAtmEntry);
					//
					//  AE Lock is released within the above.
					//

					AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
					break;
				}
			}
		}
		while (bWorkDone);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

	} // else (Packet not a copy of ours)


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleJoin+Leave: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}
}





VOID
AtmArpMcHandleNak(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_NAK message. We mark the IP Entry corresponding
	to the IP Address being resolved as having seen a NAK. This is so that
	we don't send another MARS Request for this IP address too soon. We also
	start a timer at the end of which we unmark this IP Entry, so that
	we may try to resolve it again.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_REQ_NAK_HEADER	pNakHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_ATM_ENTRY		pAtmEntry;		// Corresponding ATM Entry
	IP_ADDRESS				IPAddress;		// the address being queried
	BOOLEAN					bWasRunning;	// Was a timer running?
	PNDIS_PACKET			PacketList;		// Packets queued for sending
	ULONG					rc;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;

	pNakHeader = (PAA_MARS_REQ_NAK_HEADER)pControlHeader;

	do
	{

		//
		//  Get the group address being responded to.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pNakHeader +
						sizeof(AA_MARS_REQ_NAK_HEADER) +
						(pNakHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pNakHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pNakHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleNak: 0x%x, IP %d.%d.%d.%d\n",
						pNakHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_TMP,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			// AtmArpSearchForIPAddress addreffs pIpEntry for us ...
			//
			ULONG		IeRefCount;
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			IeRefCount = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
			if (IeRefCount == 0)
			{
				// Oops, IP address has gone away...
				pIpEntry = NULL_PATMARP_IP_ENTRY;
			}
		}

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleNak: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}

		bWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
		if (bWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // Timer ref
			AA_ASSERT(rc != 0);
		}
		else
		{
			AAMCDEBUGP(AAD_WARNING,
 			("McHandleNak: 0x%x, IP %d.%d.%d.%d NO TIMER RUNNING\n",
							pNakHeader,
							((PUCHAR)&IPAddress)[0],
							((PUCHAR)&IPAddress)[1],
							((PUCHAR)&IPAddress)[2],
							((PUCHAR)&IPAddress)[3]));
		}

		//
		//  Take out all packets queued on this entry
		//
		PacketList = pIpEntry->PacketList;
		pIpEntry->PacketList = (PNDIS_PACKET)NULL;

		//
		//  Mark this IP Entry as being resolved, but seen NAK.
		//
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_RESOLVED);
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_MC_VALIDATE_MASK,
					AA_IP_ENTRY_MC_NO_REVALIDATION);
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_STATE_MASK,
					AA_IP_ENTRY_SEEN_NAK);
		
		
		AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpNakDelayTimeout,
					pInterface->MinWaitAfterNak,
					(PVOID)pIpEntry		// Context
					);

		AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

		AA_RELEASE_IE_LOCK(pIpEntry);

		//
		//  Free any packets that were queued up.
		//
		if (PacketList != (PNDIS_PACKET)NULL)
		{
			AtmArpFreeSendPackets(
						pInterface,
						PacketList,
						FALSE	// No headers on these
						);
		}

		break;
	}
	while (FALSE);

}


VOID
AtmArpMcHandleGroupListReply(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_GROUPLIST_REPLY message.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	AAMCDEBUGP(AAD_WARNING, ("GroupListReply unexpected\n"));
	AA_ASSERT(FALSE);
}


VOID
AtmArpMcHandleRedirectMap(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_REDIRECT_MAP message. For now, we simply
	refresh the MARS Keepalive timer.

	TBDMC: Parse fully, and update MARS list, and migrate if necessary.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	PATMARP_INTERFACE				pInterface;
	PAA_MARS_REDIRECT_MAP_HEADER	pRedirectHeader;
	ULONG							MarsSeqNumber;
	ULONG							HostSeqNumber;
	ULONG							SeqDiff;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	AAMCDEBUGP(AAD_VERY_LOUD, ("### REDIRECT MAP 0x%x on VC 0x%x, IF 0x%x/0x%x\n",
				pControlHeader, pVc, pInterface, pInterface->Flags));

	pRedirectHeader = (PAA_MARS_REDIRECT_MAP_HEADER)pControlHeader;

	AA_ACQUIRE_IF_LOCK(pInterface);

	if ((AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED) &&
		(AA_IS_FLAG_SET(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE)))
	{
		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pRedirectHeader->msn);

		HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
		pInterface->HostSeqNumber = MarsSeqNumber;	// and update

		SeqDiff = MarsSeqNumber - HostSeqNumber;

		//
		//  The MC Timer running on the IF must be MARS Keepalive
		//
		AA_ASSERT(pInterface->McTimer.TimeoutHandler == AtmArpMcMARSKeepAliveTimeout);

		AAMCDEBUGP(AAD_EXTRA_LOUD,
			 ("Redirect MAP: refreshing keepalive on IF 0x%x, new HSN %d\n",
				pInterface, pInterface->HostSeqNumber));

		AtmArpRefreshTimer(&(pInterface->McTimer));
	}

	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleRedirectMap: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

	return;
}

#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\precomp.h ===
#include <ndis.h>

#include <atm.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#ifndef ATMARP_WIN98
#include <tdistat.h>
#include <ipifcons.h>
#endif

#include <atmarpif.h>

#ifdef NEWARP

#ifdef _PNP_POWER_
#include <ntddip.h>
#include <llipif.h>
#else

#ifdef ATMARP_WIN98
#define _PNP_POWER_ 1
#endif

#include <ntddip.h>

#ifdef ATMARP_WIN98
#undef _PNP_POWER_
#undef NT
#include <tdistat.h>
#endif

#include <llipif.h>

#ifdef ATMARP_WIN98
#define NT 1
#endif

#endif // _PNP_POWER_

#else

#include <llipif0.h>

#endif // NEWARP

#include <ntddip.h>

#include "system.h"
#include "debug.h"

#ifdef GPC
#include "gpcifc.h"
#include "traffic.h"
#include "ntddtc.h"
#endif // GPC

#include "aaqos.h"
#include "arppkt.h"
#ifdef IPMCAST
#include "marspkt.h"
#endif // IPMCAST
#include "atmarp.h"
#include "cubdd.h"
#include "macros.h"

#ifdef ATMARP_WMI
#include <wmistr.h>
#include "aawmi.h"
#endif // ATMARP_WMI

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\qos.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	qos.c

Abstract:

	Quality Of Service support routines. These are a collection of
	heuristics that allow configuration of different types of VCs
	between two IP endstations.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-27-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER	' SOQ'


#ifdef QOS_HEURISTICS


VOID
AtmArpQosGetPacketSpecs(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC			*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC			*ppFilterSpec
)
/*++

Routine Description:

	Given a packet to be transmitted over an Interface, return the
	flow and filter specs for the packet.

	We go through the list of configured Flow Info structures on the
	specified interface, and find the Flow Info that comes closest
	to matching this packet.

	For now, the algorithm is: search thru the list of Flow Info structures
	configured on the interface -- a match is found when we find a Flow
	Info structure that has a PacketSizeLimit greater than or equal to the
	packet size (the flow info list is arranged in ascending order of
	PacketSizeLimit).

	GPC enhancement: if we couldn't find a matching flow on the Interface,
	ask the GPC to classify the packet for us.

	NOTE: This packet must not have any headers (LLC/SNAP) pre-pended to it.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pNdisPacket			- Pointer to the packet to be classified
	ppFlowInfo			- where we return a pointer to the packet's flow info
	ppFlowSpec			- where we return a pointer to the packet's flow spec
	ppFilterSpec		- where we return a pointer to the packet's filter spec

Return Value:

	None. See Arguments above.

--*/
{
	PATMARP_INTERFACE			pInterface;
	PATMARP_FLOW_INFO			pFlowInfo;
	UINT						TotalLength;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;

	//
	//  Get the packet's total length.
	//
	NdisQueryPacket(
			pNdisPacket,
			NULL,		// Phys buffer count
			NULL,		// Buffer count
			NULL,		// First Buffer
			&TotalLength
			);

	//
	// Note that we test for pInterface->pFlowInfoList BEFORE grabbing
	// the interface lock -- this so that for the most common case of not
	// having these preconfigured flows, we don't take the drastic action
	// of taking the interface lock for each send packet! There is
	// no harm in doing this check, as long as the pFlowInfo pointer we actually
	// use is got AFTER taking the lock.
	//
	// TODO: perhaps get rid of this code altogether -- along with other code
	// dealing with preconfigured flows.
	//

	pFlowInfo  = pInterface->pFlowInfoList;

	if (pFlowInfo)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);
	
		//
		// Remember to reload pFlowInfo once we have the the lock.
		//
		for (pFlowInfo = pInterface->pFlowInfoList;
 			pFlowInfo != (PATMARP_FLOW_INFO)NULL;
 			pFlowInfo = pFlowInfo->pNextFlow)
		{
			if (TotalLength <= pFlowInfo->PacketSizeLimit)
			{
				break;
			}
		}
	
		AA_RELEASE_IF_LOCK(pInterface);
	}

	if (pFlowInfo != (PATMARP_FLOW_INFO)NULL)
	{
		*ppFlowInfo = pFlowInfo;
		*ppFlowSpec = &(pFlowInfo->FlowSpec);
		*ppFilterSpec = &(pFlowInfo->FilterSpec);
	}
	else
	{
#ifdef GPC
		CLASSIFICATION_HANDLE		ClassificationHandle;

        ClassificationHandle = (CLASSIFICATION_HANDLE)
        	PtrToUlong(
            NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, 
                                             ClassificationHandlePacketInfo));
        *ppFlowInfo = NULL;

        if (ClassificationHandle){
            GPC_STATUS					GpcStatus;

            AA_ASSERT(GpcGetCfInfoClientContext);
            GpcStatus = GpcGetCfInfoClientContext(pAtmArpGlobalInfo->GpcClientHandle,
                                                  ClassificationHandle,
                                                  ppFlowInfo);
            
        }
        else{

#if 0
            //
            // THIS CODE HAS BEEN COMMENTED OUT SINCE
            // WE ASSUME THAT CLASSIFICATION IS DONE IN
            // TCP. IF WE DON'T GET A CH - THERE'S NOT MUCH POINT
            // IN CALLING THE GPC AGAIN...
            //

            GPC_STATUS					GpcStatus;
            TC_INTERFACE_ID				InterfaceId;
            
            InterfaceId.InterfaceId = 0;
            InterfaceId.LinkId = 0;

            AA_ASSERT(GpcClassifyPacket);
            GpcStatus = GpcClassifyPacket(
							pAtmArpGlobalInfo->GpcClientHandle,
                            GPC_PROTOCOL_TEMPLATE_IP,
                            pNdisPacket,
                            0,				// TransportHeaderOffset
                            &InterfaceId,
                            (PGPC_CLIENT_HANDLE)ppFlowInfo,
                            &ClassificationHandle
                            );
#endif
        }

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		if (*ppFlowInfo != NULL)
		{
			AA_ASSERT(*ppFlowInfo != NULL);
			*ppFlowSpec = &((*ppFlowInfo)->FlowSpec);
			*ppFilterSpec = &((*ppFlowInfo)->FilterSpec);

			AADEBUGP(AAD_LOUD,
					("ClassifyPacket: Pkt %x: pFlowInfo %x, pFlowSpec %x, SendBW %d, ServType %d\n",
						pNdisPacket,
						*ppFlowInfo,
						*ppFlowSpec,
						(*ppFlowSpec)->SendAvgBandwidth,
						(*ppFlowSpec)->SendServiceType));
		}
		else
		{
			//*ppFlowInfo = NULL;
			*ppFlowSpec = &(pInterface->DefaultFlowSpec);
			*ppFilterSpec = &(pInterface->DefaultFilterSpec);
		}
#else
		*ppFlowInfo = NULL;
		*ppFlowSpec = &(pInterface->DefaultFlowSpec);
		*ppFilterSpec = &(pInterface->DefaultFilterSpec);
#endif // GPC
	}

	return;
}


BOOLEAN
AtmArpQosDoFlowsMatch(
	IN	PVOID						Context,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FLOW_SPEC			pTargetFlowSpec
)
/*++

Routine Description:

	Check if a target flow spec supports the given flow spec. Currently,
	we check only the bandwidth: if the target flow spec has a send bandwidth
	greater than or equal to that of the given flow spec, we declare a match.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pFlowSpec			- The given flow spec which we are trying to satisfy
	pTargetFlowSpec		- The candidate flow spec

Return Value:

	TRUE iff the target flow spec matches the given flow spec.

--*/
{
	return (
			(pFlowSpec->SendServiceType == pTargetFlowSpec->SendServiceType)
				 &&
			(pFlowSpec->SendPeakBandwidth <= pTargetFlowSpec->SendPeakBandwidth)
		   );
}



BOOLEAN
AtmArpQosDoFiltersMatch(
	IN	PVOID						Context,
	IN	PATMARP_FILTER_SPEC			pFilterSpec,
	IN	PATMARP_FILTER_SPEC			pTargetFilterSpec
)
/*++

Routine Description:

	Check if a target filter spec matches the given filter spec. Currently,
	we always return TRUE.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pFilterSpec			- The given filter spec which we are trying to satisfy
	pTargetFilterSpec	- The candidate filter spec

Return Value:

	TRUE always.

--*/
{
	return (TRUE);
}


#endif // QOS_HEURISTICS


#ifdef GPC

#define AA_GPC_COPY_FLOW_PARAMS(_pFlowInfo, _pQosInfo)							\
		{																		\
			(_pFlowInfo)->FlowSpec.SendAvgBandwidth = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.TokenRate;					\
			(_pFlowInfo)->FlowSpec.SendPeakBandwidth = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.PeakBandwidth;				\
			(_pFlowInfo)->FlowSpec.SendMaxSize =								\
					MAX((_pQosInfo)->GenFlow.SendingFlowspec.TokenBucketSize,			\
						(_pQosInfo)->GenFlow.SendingFlowspec.MaxSduSize);				\
			(_pFlowInfo)->PacketSizeLimit = (_pFlowInfo)->FlowSpec.SendMaxSize;	\
			(_pFlowInfo)->FlowSpec.ReceiveAvgBandwidth = 						\
					(_pQosInfo)->GenFlow.ReceivingFlowspec.TokenRate;					\
			(_pFlowInfo)->FlowSpec.ReceivePeakBandwidth =						\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.PeakBandwidth;			\
			(_pFlowInfo)->FlowSpec.ReceiveMaxSize =								\
					MAX((_pQosInfo)->GenFlow.ReceivingFlowspec.TokenBucketSize,			\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.MaxSduSize);				\
			(_pFlowInfo)->FlowSpec.Encapsulation = ENCAPSULATION_TYPE_LLCSNAP;	\
			(_pFlowInfo)->FlowSpec.AgingTime = 0;								\
			(_pFlowInfo)->FlowSpec.SendServiceType = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.ServiceType;				\
			(_pFlowInfo)->FlowSpec.ReceiveServiceType = 						\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.ServiceType;				\
		}


VOID
AtmArpGpcInitialize(
	VOID
)
/*++

Routine Description:

	Initialize with the Generic Packet Classifier. The GPC informs us of
	newly created flows (e.g. via RSVP) and of flows being torn down.
	For each flow, we keep context (ATMARP_FLOW_INFO) that keeps track of
	the QoS needed for the flow. Each IP packet given to us for transmission
	is classified into a flow, and we use this flow info to make VCs with
	the appropriate characteristics.

Arguments:

	None

Return Value:

	None

--*/
{
	GPC_STATUS					GpcStatus;
	ULONG						ClassificationFamilyId;
	ULONG						Flags;
	ULONG						ProtocolTemplate;
	ULONG						MaxPriorities;
	GPC_CLIENT_FUNC_LIST		AtmArpFuncList;
	GPC_CLIENT_HANDLE			ClientContext;

	//
	//  Initialize the GPC.
	//
	GpcStatus = GpcInitialize(&pAtmArpGlobalInfo->GpcCalls);

	if (GpcStatus != GPC_STATUS_SUCCESS)
	{
		AADEBUGP(AAD_WARNING, ("GpcInitialize failed, status 0x%x\n", GpcStatus));
		pAtmArpGlobalInfo->bGpcInitialized = FALSE;
		return;
	}

	pAtmArpGlobalInfo->bGpcInitialized = TRUE;

	AtmArpGpcClassifyPacketHandler = pAtmArpGlobalInfo->GpcCalls.GpcClassifyPacketHandler;
    AtmArpGpcGetCfInfoClientContextHandler = pAtmArpGlobalInfo->GpcCalls.GpcGetCfInfoClientContextHandler;

	ClassificationFamilyId = GPC_CF_QOS;
	Flags = 0;
	ProtocolTemplate = GPC_PROTOCOL_TEMPLATE_IP;
	MaxPriorities = 1;

	AA_SET_MEM(&AtmArpFuncList, 0, sizeof(AtmArpFuncList));

	AtmArpFuncList.ClAddCfInfoCompleteHandler = AtmArpGpcAddCfInfoComplete;
	AtmArpFuncList.ClAddCfInfoNotifyHandler = AtmArpGpcAddCfInfoNotify;
	AtmArpFuncList.ClModifyCfInfoCompleteHandler = AtmArpGpcModifyCfInfoComplete;
	AtmArpFuncList.ClModifyCfInfoNotifyHandler = AtmArpGpcModifyCfInfoNotify;
	AtmArpFuncList.ClRemoveCfInfoCompleteHandler = AtmArpGpcRemoveCfInfoComplete;
	AtmArpFuncList.ClGetCfInfoName = AtmArpGpcGetCfInfoName;
	AtmArpFuncList.ClRemoveCfInfoNotifyHandler = AtmArpGpcRemoveCfInfoNotify;

	ClientContext = (GPC_CLIENT_HANDLE)pAtmArpGlobalInfo;

	GpcStatus = GpcRegisterClient(
						ClassificationFamilyId,
						Flags,
						MaxPriorities,
						&AtmArpFuncList,
						ClientContext,
						&(pAtmArpGlobalInfo->GpcClientHandle)
						);

	AADEBUGP(AAD_INFO,
			("GpcRegisterClient status 0x%x, GpcClientHandle 0x%x\n",
				GpcStatus, pAtmArpGlobalInfo->GpcClientHandle));

	if(GpcStatus != GPC_STATUS_SUCCESS)
    {
        AA_ASSERT(FALSE);
	    pAtmArpGlobalInfo->bGpcInitialized = FALSE;
    }
}




VOID
AtmArpGpcShutdown(
	VOID
)
/*++

Routine Description:

	Shuts down our GPC interface.

Arguments:

	None

Return Value:

	None

--*/
{
	GPC_STATUS		GpcStatus;

	if (pAtmArpGlobalInfo->bGpcInitialized)
	{
		GpcStatus = GpcDeregisterClient(pAtmArpGlobalInfo->GpcClientHandle);

		AA_ASSERT(GpcStatus == GPC_STATUS_SUCCESS);
	}
}




VOID
AtmArpGpcAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcAddCfInfo() has completed. Since we never call GpcAddCfInfo,
	we should never be called here.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	AA_ASSERT(FALSE);
}





GPC_STATUS
AtmArpGpcAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_HANDLE					GpcCfInfoHandle,
	IN	PTC_INTERFACE_ID			InterfaceInfo,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pCfInfo,
	OUT	PGPC_CLIENT_HANDLE			pClientCfInfoContext
)
/*++

Routine Description:

	This is the entry point called by GPC to notify us of creation of
	a new INFO block of type QOS. We allocate a FLOW_INFO structure,
	fill it with what we need, and return a pointer to it as our context.

Arguments:

	ClientContext		- Pointer to our global info struct
	GpcCfInfoHandle		- GPC Handle to use in all GPC APIs for this INFO block
	InterfaceInfo		- Some information about the interface (ignored)
	CfInfoSize			- Length of the following block
	pCfInfo				- Pointer to the newly created INFO block
	pClientCfInfoContext- Place where we return our context for this block

Return Value:

	GPC_STATUS_SUCCESS if we were able to allocate a new FLOW_INFO structure,
	GPC_STATUS_RESOURCES otherwise.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	GPC_STATUS				GpcStatus;
	PCF_INFO_QOS			pQosInfo;

	pQosInfo = (PCF_INFO_QOS)pCfInfo;

	//
	//  Initialize.
	//
	*pClientCfInfoContext = NULL;

	do
	{
		GpcStatus = AtmArpGpcValidateCfInfo(pCfInfo, CfInfoSize);

		if (GpcStatus != GPC_STATUS_SUCCESS)
		{
			break;
		}

		AA_ALLOC_MEM(pFlowInfo, ATMARP_FLOW_INFO, sizeof(ATMARP_FLOW_INFO));

		if (pFlowInfo == NULL)
		{
			GpcStatus = GPC_STATUS_RESOURCES;
			break;
		}

		AA_SET_MEM(pFlowInfo, 0, sizeof(ATMARP_FLOW_INFO));

		pFlowInfo->CfInfoHandle = GpcCfInfoHandle;

		//
		//  Copy in flow parameters
		//
		AA_GPC_COPY_FLOW_PARAMS(pFlowInfo, pQosInfo);

		//
		// Generate Unique Name for this flow.
		// This name is based on the template, AA_FLOW_INSTANCE_TEMPLATE.
		// The flow number part is based on a static variable which is
		// InterlockIncremented each time a flowinfo is created.
		//
		{
			static		ULONG FlowCount = 0;
			ULONG 		ThisFlow =  NdisInterlockedIncrement(&FlowCount);
			WCHAR		*pwc;

			AA_ASSERT(sizeof(pFlowInfo->FlowInstanceName)
					  == sizeof(AA_FLOW_INSTANCE_NAME_TEMPLATE)-sizeof(WCHAR));

			AA_COPY_MEM(
					pFlowInfo->FlowInstanceName,
					AA_FLOW_INSTANCE_NAME_TEMPLATE,
					sizeof(pFlowInfo->FlowInstanceName)
					);

			//
			// We fill in the "flow number" field of the template, which
			// is the 1st 8 characters, with the hex representation of
			// ThisFlow. The LS digit is at offset 7.
			//
			pwc = pFlowInfo->FlowInstanceName+7;
			AA_ASSERT(2*sizeof(ThisFlow) == 8);
			while (ThisFlow)
			{
				ULONG u = ThisFlow & 0xf;
				*pwc--  =  (WCHAR) ((u < 10) ? (u + '0') : u + 'A' - 10);
				ThisFlow >>= 4;
			}
		}

		//
		//  Link it to the global flow list.
		//
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		pFlowInfo->pPrevFlow = NULL;
		pFlowInfo->pNextFlow = pAtmArpGlobalInfo->pFlowInfoList;

		if (pAtmArpGlobalInfo->pFlowInfoList != NULL)
		{
			pAtmArpGlobalInfo->pFlowInfoList->pPrevFlow = pFlowInfo;
		}

		pAtmArpGlobalInfo->pFlowInfoList = pFlowInfo;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		//
		//  Return our context for this flow.
		//
		*pClientCfInfoContext = (GPC_CLIENT_HANDLE)pFlowInfo;
		GpcStatus = GPC_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO, ("AddCfInfoNotify: pCfInfo x%x, ClientCtx x%x, ret x%x\n",
						pCfInfo, *pClientCfInfoContext, GpcStatus));
#if DBG
	if (GpcStatus == GPC_STATUS_SUCCESS)
	{
		AADEBUGP(AAD_INFO, ("               : SendPeak %d, SendAvg %d, SendPktSize %d, ServType %d\n",
						pFlowInfo->FlowSpec.SendPeakBandwidth,
						pFlowInfo->FlowSpec.SendAvgBandwidth,
						pFlowInfo->FlowSpec.SendMaxSize,
						pFlowInfo->FlowSpec.SendServiceType));
		AADEBUGP(AAD_INFO, ("               : RecvPeak %d, RecvAvg %d, RecvPktSize %d, ServType %d\n",
						pFlowInfo->FlowSpec.ReceivePeakBandwidth,
						pFlowInfo->FlowSpec.ReceiveAvgBandwidth,
						pFlowInfo->FlowSpec.ReceiveMaxSize,
						pFlowInfo->FlowSpec.ReceiveServiceType));
	}
#endif
						

	return (GpcStatus);
}




VOID
AtmArpGpcModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcModifyCfInfo() has completed. Since we never call GpcModifyCfInfo,
	we should never be called here.

	Addendum: Apparently this is called even if another client calls
	GpcModifyCfInfo, just to notify this client that the modify operation
	finished.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	return;
}




GPC_STATUS
AtmArpGpcModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pNewCfInfo
)
/*++

Routine Description:

	This is the entry point called by GPC when an existing flow has
	been modified.

	If the flow info for this flow is linked with a VC, we unlink it,
	and start an aging timeout on the VC. We update the flow info structure
	with this new information. The next packet that falls into this
	classification will cause a new VC with updated QoS to be created.

Arguments:

	ClientContext		- Pointer to our global context
	ClientCfInfoContext	- Pointer to our FLOW INFO structure
	CfInfoSize			- Length of the following
	pNewCfInfo			- Updated flow info

Return Value:

	GPC_STATUS_SUCCESS always.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_VC				pVc;
	GPC_STATUS				GpcStatus;
	PCF_INFO_QOS			pQosInfo;
	ULONG					rc;

	pQosInfo = (PCF_INFO_QOS)pNewCfInfo;

	pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;

	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		GpcStatus = AtmArpGpcValidateCfInfo(pNewCfInfo, CfInfoSize);

		if (GpcStatus != GPC_STATUS_SUCCESS)
		{
			break;
		}

		pVc = (PATMARP_VC) InterlockedExchangePointer(
								&(pFlowInfo->VcContext),
								NULL
								);

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  This flow isn't associated with a VC.
			//
			break;
		}


		//
		//  Unlink the flow from the VC.
		//

		AA_ACQUIRE_VC_LOCK(pVc);

		AA_ASSERT(pVc->FlowHandle == (PVOID)pFlowInfo);

		pVc->FlowHandle = NULL;
		rc = AtmArpDereferenceVc(pVc);	// GPC Unlink flow info (modify)

		if (rc != 0)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_GPC_MASK,
						AA_VC_GPC_IS_UNLINKED_FROM_FLOW);

			//
			//  Age out this VC if it isn't aging out yet.
			//
			if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
			{
				AtmArpStartTimer(
						pVc->pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						1,			// Age out in 1 second
						(PVOID)pVc
						);

				AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
			}

			AA_RELEASE_VC_LOCK(pVc);
		}
		//
		//  else the VC is gone.
		//

		//
		//  Update the flow info.
		//
		AA_GPC_COPY_FLOW_PARAMS(pFlowInfo, pQosInfo);
		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO, ("ModCfInfo: pFlowInfo x%x, VC x%x, New SendBW %d, SendPktSz %d\n",
				pFlowInfo,
				pFlowInfo->VcContext,
				pFlowInfo->FlowSpec.SendAvgBandwidth,
				pFlowInfo->FlowSpec.SendMaxSize));

	return (GpcStatus);
}




VOID
AtmArpGpcRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcRemoveCfInfo() has completed. Since we never call GpcRemoveCfInfo,
	we should never be called here.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	AA_ASSERT(FALSE);
}




GPC_STATUS
AtmArpGpcRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext
)
/*++

Routine Description:

	This is the entry point called by GPC to notify us that a flow
	is being removed. We locate our context for the flow, unlink
	it from the ATM VC that carries the flow, and start aging
Arguments:

	ClientContext		- Pointer to our global context
	ClientCfInfoContext	- Pointer to our FLOW INFO structure

Return Value:

	GPC_STATUS_SUCCESS always.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_VC				pVc;
	GPC_STATUS				GpcStatus;
	ULONG					rc;

	pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;

	AADEBUGP(AAD_INFO, ("RemCfInfo: pFlowInfo x%x, VC x%x, SendBW %d, SendPktSz %d\n",
				pFlowInfo,
				pFlowInfo->VcContext,
				pFlowInfo->FlowSpec.SendAvgBandwidth,
				pFlowInfo->FlowSpec.SendMaxSize));

	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		pVc = (PATMARP_VC) InterlockedExchangePointer(
								&(pFlowInfo->VcContext),
								NULL
								);

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  This flow isn't associated with a VC.
			//
			break;
		}


		//
		//  Unlink the flow from the VC.
		//

		AA_ACQUIRE_VC_LOCK(pVc);

		AA_ASSERT(pVc->FlowHandle == (PVOID)pFlowInfo);

		pVc->FlowHandle = NULL;
		rc = AtmArpDereferenceVc(pVc);	// GPC Unlink flow info (modify)

		if (rc != 0)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_GPC_MASK,
						AA_VC_GPC_IS_UNLINKED_FROM_FLOW);

			//
			//  Age out this VC if it isn't aging out yet.
			//
			if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
			{
				AtmArpStartTimer(
						pVc->pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						1,			// Age out in 1 second
						(PVOID)pVc
						);

				AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
			}

			AA_RELEASE_VC_LOCK(pVc);
		}
		//
		//  else the VC is gone.
		//

		break;
	}
	while (FALSE);


	//
	//  Unlink this flow from the global list.
	//

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pFlowInfo->pNextFlow != NULL)
	{
		pFlowInfo->pNextFlow->pPrevFlow = pFlowInfo->pPrevFlow;
	}

	if (pFlowInfo->pPrevFlow != NULL)
	{
		pFlowInfo->pPrevFlow->pNextFlow = pFlowInfo->pNextFlow;
	}
	else
	{
		pAtmArpGlobalInfo->pFlowInfoList = pFlowInfo->pNextFlow;
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Delete this flow info structure.
	//
	AA_FREE_MEM(pFlowInfo);

	return (GpcStatus);
}

GPC_STATUS
AtmArpValidateFlowSpec(
	IN	PATMARP_INTERFACE	pInterface,	 LOCKIN LOCKOUT
	IN	FLOWSPEC *			pFS,
	IN 	BOOLEAN				fSending
)
/*++

Routine Description:

	Check the contents of a CF INFO structure that's been given to us.

Arguments:

	pFS				- The FLOWSPEC struct to check.
	pInterface		- Pointer to the interface (assumed to be locked).
	fSending		- if TRUE this is a sending flow otherwise it is a receiving
					  flow.

Return Value:

	GPC_STATUS_SUCCESS if the structure is OK, error code otherwise.

--*/
{

	/*
		Here is the validation plan for the
		fields of FLOWSPEC:
	
			Ignored fields:
				Latency
				DelayVariation
			
			If ServiceType == NO_TRAFFIC, we ignore all other fields.

			Default handling
				MinimumPolicedSize: ignored
				TokenRate: BE:line-rate; GS:invalid   CLS: invalid
				TokenBucketSize: MTU
				PeakBandwidth: line-rate
				ServiceType:BE
				MaxSduSize: MTU
			
			Valid ranges
				MinimumPolicedSize <= MTU
				0<TokenRate	<= LineRate
				0<TokenBucketSize
				0<TokenRate	<= PeakBandwidth
				ServiceType: valid type
				0<MaxSduSize <= MTU
				MaxSduSize <= TokenBucketSize
	*/


	GPC_STATUS Status = GPC_STATUS_SUCCESS;

	do
	{
		ULONG MTU      = pInterface->pAdapter->MaxPacketSize;
		UINT  LineRate = (fSending)
						? pInterface->pAdapter->LineRate.Outbound
						: pInterface->pAdapter->LineRate.Inbound;
					
		//
		// Check service types.
		//
		switch(pFS->ServiceType)
		{

		case SERVICETYPE_GUARANTEED: 		// fall through
		case SERVICETYPE_CONTROLLEDLOAD:
			if  (pFS->TokenRate == QOS_NOT_SPECIFIED)
			{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: Token rate U for ST G/CL. ST=0x%lx\n",
				pFS->ServiceType));
				Status = QOS_STATUS_INVALID_TOKEN_RATE;
				// Status = GPC_STATUS_INVALID_PARAMETER;
			}
			break;

		case SERVICETYPE_NOTRAFFIC:			// fall through
		case SERVICETYPE_BESTEFFORT:		// fall through
		case QOS_NOT_SPECIFIED:
			break;

		default:
			// Status = GPC_STATUS_INVALID_PARAMETER;
			Status = QOS_STATUS_INVALID_SERVICE_TYPE;
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: Unknown ST 0x%lx\n", pFS->ServiceType));
			break;
			
		}
		
		if (Status != GPC_STATUS_SUCCESS)
		{
			break;
		}

		//
		// If service type is notraffic, we ignore all other parameters...
		//
		if (pFS->ServiceType == SERVICETYPE_NOTRAFFIC)
		{
			break;
		}

		//
		// Check that non-default values fall into valid ranges...
		//
		#define EXCEEDSMAX(_value,_max) \
					((_value) != QOS_NOT_SPECIFIED && (_value) > (_max))

		if (EXCEEDSMAX(pFS->MinimumPolicedSize, MTU))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MinPolSz(%lu)>MTU(%lu)\n",
				pFS->MinimumPolicedSize,
				MTU));
			Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->TokenRate, LineRate))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: TokRt(%lu)>LineRt(%lu)\n",
				pFS->TokenRate,
				LineRate));
			Status = QOS_STATUS_INVALID_TOKEN_RATE;
			// Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->TokenRate, pFS->PeakBandwidth))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: TokRt(%lu)>PkBw(%lu)\n",
				pFS->TokenRate,
				pFS->PeakBandwidth));
			//
			// 3/15/1999 JosephJ: According	 to EricEil, in this condition
			//				we should return INVALID_PEAK_RATE, not 
			//				INVALID_TOKEN_RATE
			//
			Status = QOS_STATUS_INVALID_PEAK_RATE;
			break;
		}

		if (EXCEEDSMAX(pFS->MaxSduSize, MTU))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MaxSduSz(%lu)>MTU(%lu)\n",
				pFS->MaxSduSize,
				MTU));
			Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->MaxSduSize, pFS->TokenBucketSize))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MaxSduSz(%lu)>TokBktSz(%lu)\n",
				pFS->MaxSduSize,
				pFS->TokenBucketSize));
			Status = GPC_STATUS_INVALID_PARAMETER;
			break;
		}

		if (
				pFS->TokenRate==0
			||  pFS->TokenBucketSize==0
			||  pFS->MaxSduSize==0)
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: !TokRt || !TokBktSz || !MaxSduSz\n"));
			if (pFS->TokenRate == 0)
			{
				Status = QOS_STATUS_INVALID_TOKEN_RATE;
			}
			else
			{
				Status = GPC_STATUS_INVALID_PARAMETER;
			}
			break;
		}

	} while (FALSE);

	return Status;
}


GPC_STATUS
AtmArpGpcValidateCfInfo(
	IN	PVOID						pCfInfo,
	IN	ULONG						CfInfoSize
)
/*++

Routine Description:

	Check the contents of a CF INFO structure that's been given to us.

Arguments:

	pCfInfo				- Pointer to the newly created INFO block
	CfInfoSize			- Length of the above

Return Value:

	GPC_STATUS_SUCCESS if the structure is OK, error code otherwise.

--*/
{
	GPC_STATUS			GpcStatus;
	PCF_INFO_QOS		pQosInfo;
	PATMARP_INTERFACE	pInterface;

	pQosInfo = (PCF_INFO_QOS)pCfInfo;
	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		if(CfInfoSize < (FIELD_OFFSET(CF_INFO_QOS, GenFlow) +
		                 FIELD_OFFSET(TC_GEN_FLOW, TcObjects)))
		{
			GpcStatus = GPC_STATUS_INVALID_PARAMETER;
			break;
		}


#ifdef ATMARP_WMI

		//
		// Check that both recv and send servicetypes are not both notraffic
		//
		if (   pQosInfo->GenFlow.ReceivingFlowspec.ServiceType==SERVICETYPE_NOTRAFFIC
		    && pQosInfo->GenFlow.SendingFlowspec.ServiceType==SERVICETYPE_NOTRAFFIC)
		{
			GpcStatus = GPC_STATUS_INVALID_PARAMETER;
			break;
		}

		//
		//  Check if this notification is actually for us.
		//
		pInterface = AtmArpWmiGetIfByName(
						(PWSTR)&pQosInfo->InstanceName[0],
						pQosInfo->InstanceNameLength
						);

		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			AA_ACQUIRE_IF_LOCK(pInterface);

			if (pInterface->AdminState != IF_STATUS_UP)
			{
				//
				// Oh oh -- interface is not up and about....
				//
				AtmArpDereferenceInterface(pInterface); // WMI: Tmp ref.
				AA_RELEASE_IF_LOCK(pInterface);
				pInterface = NULL;
			}
		}

		if (pInterface == NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING,
				("GpcValidateCfInfo: pQosInfo 0x%x, unknown instance name %ws\n",
					pQosInfo, pQosInfo->InstanceName));

			GpcStatus = GPC_STATUS_IGNORED;
			break;
		}

		//
		// We have the interface lock -- don't break without releasing it first!
		//

		GpcStatus = AtmArpValidateFlowSpec(
						pInterface,
						&(pQosInfo->GenFlow.ReceivingFlowspec),
						FALSE
						);

		if (GpcStatus == GPC_STATUS_SUCCESS)
		{
			GpcStatus = AtmArpValidateFlowSpec(
						pInterface,
						&(pQosInfo->GenFlow.SendingFlowspec),
						TRUE
						);
		}

		AtmArpDereferenceInterface(pInterface); // WMI: Tmp ref.
		AA_RELEASE_IF_LOCK(pInterface);

#endif // ATMARP_WMI

		break;
	}
	while (FALSE);

	return (GpcStatus);
}


EXTERN
GPC_STATUS
AtmArpGpcGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       	ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING        InstanceName
)
/*++

Routine Description:

    
    The GPC can issue this call to get from us the WMI manageable
    InstanceName which Ndis created for the flow associated with
    the CfInfo struct.

    We guarantee to keep the string buffer around until the CfInfo
    structure is removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   Client's CfInfo context
    InstanceName -          We return a pointer to our string.

Return Value:

    Status

--*/

{
	PATMARP_FLOW_INFO		pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;
	InstanceName->Buffer = pFlowInfo->FlowInstanceName;
	InstanceName->Length = sizeof(pFlowInfo->FlowInstanceName);
	InstanceName->MaximumLength = sizeof(pFlowInfo->FlowInstanceName);

	return NDIS_STATUS_SUCCESS;

}

#endif // GPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\ntentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ntentry.c

Abstract:

	NT System entry points for ATMARP.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-08-96    Created

Notes:

--*/

#ifdef ATMARP_WIN98

#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0

#endif // ATMARP_WIN98

#include <precomp.h>

#define _FILENUMBER 'NETN'

//
//  The INIT code is discardable
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#endif // ALLOC_PRAGMA





NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
)
/*++

Routine Description:

	This is the "init" routine, called by the system when the ATMARP
	module is loaded. We initialize all our global objects, fill in our
	Dispatch and Unload routine addresses in the driver object, and create
	a device object for receiving I/O requests on (IOCTLs).

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.
	pRegistryPath	- Pointer to our global registry path. This is ignored.

Return Value:

	NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
	NTSTATUS				Status;
	PDEVICE_OBJECT			pDeviceObject;
	UNICODE_STRING			DeviceName;
	INT						i;

	AADEBUGP(AAD_INFO, ("DriverEntry: entered, pAtmArpGlobal 0x%x\n", pAtmArpGlobalInfo));
	AADEBUGP(AAD_FATAL, ("&AaDebugLevel: 0x%x, AaDebugLevel now is %d\n",
				&AaDebugLevel, AaDebugLevel));
	AADEBUGP(AAD_FATAL, ("&AaDataDebugLevel: 0x%x, AaDataDebugLevel now is %d\n",
				&AaDataDebugLevel, AaDataDebugLevel));
#ifdef IPMCAST
	AAMCDEBUGP(AAD_FATAL, ("&AaMcDebugLevel: 0x%x, AaMcDebugLevel now is %d\n",
				&AaMcDebugLevel, AaMcDebugLevel));
#endif
#if DBG
	AADEBUGP(AAD_FATAL, ("To skip everything set AaSkipAll at 0x%x to 1\n",
				&AaSkipAll));
	if (AaSkipAll)
	{
		AADEBUGP(AAD_ERROR, ("Aborting DriverEntry\n"));
		return (STATUS_UNSUCCESSFUL);
	}
#endif

	//
	//  Initialize our globals.
	//
	AtmArpInitGlobals();

#ifdef GPC
    //
    // Init GPC
    //
	AtmArpGpcInitialize();
#endif // GPC

#if !BINARY_COMPATIBLE
	//
	//  Initialize the Driver Object.
	//
	pDriverObject->DriverUnload = Unload;
	pDriverObject->FastIoDispatch = NULL;
	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		pDriverObject->MajorFunction[i] = Dispatch;
	}

#ifdef ATMARP_WMI

	pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AtmArpWmiDispatch;

#endif // ATMARP_WMI

	pAtmArpGlobalInfo->pDriverObject = (PVOID)pDriverObject;

	//
	//  Create a device object for the ATMARP module.
	//
	RtlInitUnicodeString(&DeviceName, ATMARP_DEVICE_NAME);

	Status = IoCreateDevice(
				pDriverObject,
				0,
				&DeviceName,
				FILE_DEVICE_NETWORK,
				0,
				FALSE,
				&pDeviceObject
				);

	if (NT_SUCCESS(Status))
	{

		//
		// Set up a symbolic name for interaction with the user-mode
		// admin application.
		//
		#define	ATMARP_SYMBOLIC_NAME		L"\\DosDevices\\ATMARPC"
		UNICODE_STRING	SymbolicName;
		RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
		IoCreateSymbolicLink(&SymbolicName, &DeviceName);

		//
		//  Initialize the Device Object.
		//
		pDeviceObject->Flags |= DO_DIRECT_IO;

		//
		//  Retain the device object pointer -- we'll need this
		//  if/when we are asked to unload ourselves.
		//
		pAtmArpGlobalInfo->pDeviceObject = (PVOID)pDeviceObject;

	}
	else
	{
		pDeviceObject = NULL;
	}

#endif // !BINARY_COMPATIBLE

	//
	//  Fill in our Protocol and Client characteristics structures.
	//
	AA_SET_MEM(&AtmArpProtocolCharacteristics, 0, sizeof(AtmArpProtocolCharacteristics));
	AtmArpProtocolCharacteristics.MajorNdisVersion = ATMARP_NDIS_MAJOR_VERSION;
	AtmArpProtocolCharacteristics.MinorNdisVersion = ATMARP_NDIS_MINOR_VERSION;
	AtmArpProtocolCharacteristics.OpenAdapterCompleteHandler = AtmArpOpenAdapterCompleteHandler;
	AtmArpProtocolCharacteristics.CloseAdapterCompleteHandler = AtmArpCloseAdapterCompleteHandler;
	AtmArpProtocolCharacteristics.SendCompleteHandler = AtmArpSendCompleteHandler;
	AtmArpProtocolCharacteristics.TransferDataCompleteHandler = AtmArpTransferDataCompleteHandler;
	AtmArpProtocolCharacteristics.ResetCompleteHandler = AtmArpResetCompleteHandler;
	AtmArpProtocolCharacteristics.RequestCompleteHandler = AtmArpRequestCompleteHandler;
	AtmArpProtocolCharacteristics.ReceiveHandler = AtmArpReceiveHandler;
	AtmArpProtocolCharacteristics.ReceiveCompleteHandler = AtmArpReceiveCompleteHandler;
	AtmArpProtocolCharacteristics.StatusHandler = AtmArpStatusHandler;
	AtmArpProtocolCharacteristics.StatusCompleteHandler = AtmArpStatusCompleteHandler;
	NdisInitUnicodeString(
		&AtmArpProtocolCharacteristics.Name,
		ATMARP_LL_NAME
	);
	AtmArpProtocolCharacteristics.ReceivePacketHandler = AtmArpReceivePacketHandler;
	AtmArpProtocolCharacteristics.BindAdapterHandler = AtmArpBindAdapterHandler;
	AtmArpProtocolCharacteristics.UnbindAdapterHandler = AtmArpUnbindAdapterHandler;
	AtmArpProtocolCharacteristics.UnloadHandler = (UNLOAD_PROTOCOL_HANDLER)AtmArpUnloadProtocol;
#ifdef _PNP_POWER_
	AtmArpProtocolCharacteristics.PnPEventHandler = AtmArpPnPEventHandler;
#endif // _PNP_POWER_
	AtmArpProtocolCharacteristics.CoSendCompleteHandler = AtmArpCoSendCompleteHandler;
	AtmArpProtocolCharacteristics.CoStatusHandler = AtmArpCoStatusHandler;
	AtmArpProtocolCharacteristics.CoReceivePacketHandler = AtmArpCoReceivePacketHandler;
	AtmArpProtocolCharacteristics.CoAfRegisterNotifyHandler = AtmArpCoAfRegisterNotifyHandler;

	AA_SET_MEM(&AtmArpClientCharacteristics, 0, sizeof(AtmArpClientCharacteristics));
	AtmArpClientCharacteristics.MajorVersion = ATMARP_NDIS_MAJOR_VERSION;
	AtmArpClientCharacteristics.MinorVersion = ATMARP_NDIS_MINOR_VERSION;
	AtmArpClientCharacteristics.ClCreateVcHandler = AtmArpCreateVcHandler;
	AtmArpClientCharacteristics.ClDeleteVcHandler = AtmArpDeleteVcHandler;
	AtmArpClientCharacteristics.ClRequestHandler = AtmArpCoRequestHandler;
	AtmArpClientCharacteristics.ClRequestCompleteHandler = AtmArpCoRequestCompleteHandler;
	AtmArpClientCharacteristics.ClOpenAfCompleteHandler = AtmArpOpenAfCompleteHandler;
	AtmArpClientCharacteristics.ClCloseAfCompleteHandler = AtmArpCloseAfCompleteHandler;
	AtmArpClientCharacteristics.ClRegisterSapCompleteHandler = AtmArpRegisterSapCompleteHandler;
	AtmArpClientCharacteristics.ClDeregisterSapCompleteHandler = AtmArpDeregisterSapCompleteHandler;
	AtmArpClientCharacteristics.ClMakeCallCompleteHandler = AtmArpMakeCallCompleteHandler;
	AtmArpClientCharacteristics.ClModifyCallQoSCompleteHandler = AtmArpModifyQosCompleteHandler;
	AtmArpClientCharacteristics.ClCloseCallCompleteHandler = AtmArpCloseCallCompleteHandler;
	AtmArpClientCharacteristics.ClAddPartyCompleteHandler = AtmArpAddPartyCompleteHandler;
	AtmArpClientCharacteristics.ClDropPartyCompleteHandler = AtmArpDropPartyCompleteHandler;
	AtmArpClientCharacteristics.ClIncomingCallHandler = AtmArpIncomingCallHandler;
	AtmArpClientCharacteristics.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
	AtmArpClientCharacteristics.ClIncomingCloseCallHandler = AtmArpIncomingCloseHandler;
	AtmArpClientCharacteristics.ClIncomingDropPartyHandler = AtmArpIncomingDropPartyHandler;
	AtmArpClientCharacteristics.ClCallConnectedHandler = AtmArpCallConnectedHandler;
	
	do
	{
		//
		//  Register ourselves as a protocol with NDIS.
		//
		NdisRegisterProtocol(
				&Status,
				&(pAtmArpGlobalInfo->ProtocolHandle),
				&AtmArpProtocolCharacteristics,
				sizeof(AtmArpProtocolCharacteristics)
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_FATAL,
				("NdisRegisterProtocol failed: %x\n", Status));
			pAtmArpGlobalInfo->ProtocolHandle = NULL;
			break;
		}

#ifdef NEWARP
		//
		//  Register ourselves as an ARP Module with IP.
		//
		{
			NDIS_STRING		AtmArpName;

			#if IFCHANGE1
			#ifndef ATMARP_WIN98
			IP_CHANGE_INDEX        IpChangeIndex;
			IP_RESERVE_INDEX       IpReserveIndex;
			IP_DERESERVE_INDEX     IpDereserveIndex;
			#endif
			#endif // IFCHANGE1

			NdisInitUnicodeString(&AtmArpName, ATMARP_UL_NAME);

			Status = IPRegisterARP(
						&AtmArpName,
						IP_ARP_BIND_VERSION,
						AtmArpBindAdapterHandler,
						&(pAtmArpGlobalInfo->pIPAddInterfaceRtn),
						&(pAtmArpGlobalInfo->pIPDelInterfaceRtn),
						&(pAtmArpGlobalInfo->pIPBindCompleteRtn),
					#if P2MP
						&(pAtmArpGlobalInfo->pIPAddLinkRtn),
						&(pAtmArpGlobalInfo->pIpDeleteLinkRtn),
					#endif // P2MP
					#if IFCHANGE1
					#ifndef ATMARP_WIN98
						//
						// Following 3 are placeholders -- we don't use this information.
						// See 10/14/1998 entry in notes.txt
						//
						&IpChangeIndex,
						&IpReserveIndex,
						&IpDereserveIndex,
					#endif // ATMARP_WIN98
					#endif // IFCHANGE1
						&(pAtmArpGlobalInfo->ARPRegisterHandle)
						);

			if (!NT_SUCCESS(Status))
			{

				AADEBUGP(AAD_FATAL, ("DriverEntry: IPRegisterARP FAILS. Status = 0x%08lx\n", Status));
				pAtmArpGlobalInfo->ARPRegisterHandle = NULL;
				break;
			}
		
		}
#endif // NEWARP

		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		NDIS_STATUS		CleanupStatus;

		//
		//  Clean up.
		//

#if !BINARY_COMPATIBLE
		if (pDeviceObject != NULL)
		{
			UNICODE_STRING	SymbolicName;
			RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
			IoDeleteSymbolicLink(&SymbolicName);
			IoDeleteDevice(pDeviceObject);
			pDeviceObject = NULL;
		}
#endif // !BINARY_COMPATIBLE

		if (pAtmArpGlobalInfo->ProtocolHandle)
		{
			NdisDeregisterProtocol(
				&CleanupStatus,
				pAtmArpGlobalInfo->ProtocolHandle
				);
			
			pAtmArpGlobalInfo->ProtocolHandle = NULL;
		}

		if (pAtmArpGlobalInfo->ARPRegisterHandle != NULL)
		{
			CleanupStatus = IPDeregisterARP(pAtmArpGlobalInfo->ARPRegisterHandle);
			AA_ASSERT(CleanupStatus == NDIS_STATUS_SUCCESS);

			pAtmArpGlobalInfo->ARPRegisterHandle = NULL;
		}

    #ifdef GPC
        //
        // DeInit GPC
        //
        AtmArpGpcShutdown();
    #endif // GPC

	}

	return (Status);
}


#if !BINARY_COMPATIBLE

NTSTATUS
Dispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	This routine is called by the system when there is an IRP
	to be processed.

Arguments:

	pDeviceObject		- Pointer to device object we created for ourselves.
	pIrp				- Pointer to IRP to be processed.

Return Value:

	NT Status code.

--*/
{
	NTSTATUS				Status;				// Return value
	PIO_STACK_LOCATION		pIrpStack;
	PVOID					pIoBuffer;			// Values in/out
	ULONG					InputBufferLength;	// Length of input parameters
	ULONG					OutputBufferLength;	// Space for output values

	//
	//  Initialize
	//
	Status = (NTSTATUS)NDIS_STATUS_SUCCESS;
	pIrp->IoStatus.Status = (NTSTATUS)NDIS_STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;

	//
	//  Get all information in the IRP
	//
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	switch (pIrpStack->MajorFunction)
	{
		case IRP_MJ_CREATE:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CREATE\n"));
			//
			//  Return a pointer to the first ATMARP interface available, as the
			//  FsContext.
			//
			pIrpStack->FileObject->FsContext = NULL;	// Initialize
			if (pAtmArpGlobalInfo->pAdapterList != (PATMARP_ADAPTER)NULL)
			{
				pIrpStack->FileObject->FsContext =
					(PVOID)(pAtmArpGlobalInfo->pAdapterList->pInterfaceList);
			}
			break;

		case IRP_MJ_CLOSE:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CLOSE\n"));
			break;

		case IRP_MJ_CLEANUP:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CLEANUP\n"));
			break;

		case IRP_MJ_DEVICE_CONTROL:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_DEVICE_CONTROL\n"));

#ifndef ATMARP_WIN98
			Status =  AtmArpHandleIoctlRequest(pIrp, pIrpStack);
#endif // ATMARP_WIN98
			break;

		default:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP: Unknown major function 0x%x\n",
						pIrpStack->MajorFunction));
			break;
	}

	if (Status != (NTSTATUS)NDIS_STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}

	return (Status);

}

#endif // !BINARY_COMPATIBLE


VOID
Unload(
	IN	PDRIVER_OBJECT				pDriverObject
)
/*++

Routine Description:

	This routine is called by the system prior to unloading us.
	Currently, we just undo everything we did in DriverEntry,
	that is, de-register ourselves as an NDIS protocol, and delete
	the device object we had created.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AADEBUGP(AAD_INFO, ("Unload Entered!\n"));

	if (pAtmArpGlobalInfo->ARPRegisterHandle != NULL)
	{
		Status = IPDeregisterARP(pAtmArpGlobalInfo->ARPRegisterHandle);
		AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
	}

	AtmArpUnloadProtocol();

	//
	//  Delay for a while.
	//
	AADEBUGP(AAD_INFO, ("Unload: will delay for a while...\n"));

	NdisInitializeEvent(&pAtmArpGlobalInfo->Block.Event);

	NdisWaitEvent(&pAtmArpGlobalInfo->Block.Event, 250);

#if !BINARY_COMPATIBLE
	{
		UNICODE_STRING	SymbolicName;
		RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
		IoDeleteSymbolicLink(&SymbolicName);

		//
		//  Delete our device object.
		//
		IoDeleteDevice((PDEVICE_OBJECT)pAtmArpGlobalInfo->pDeviceObject);
	}
#endif // !BINARY_COMPATIBLE

	AADEBUGP(AAD_INFO, ("Unload done!\n"));
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\space.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	space.c

Abstract:

	All globals and tunable variables are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-08-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'CAPS'

//
//  The Global Info structure is initialized in our DriverEntry.
// 
ATMARP_GLOBALS		AtmArpGlobalInfo;
PATMARP_GLOBALS		pAtmArpGlobalInfo = &AtmArpGlobalInfo;

//
//  Generic NDIS protocol characteristics structure: this defines
//  our handler routines for various common protocol functions.
//  We pass this to NDIS when we register ourselves as a protocol.
//
NDIS_PROTOCOL_CHARACTERISTICS AtmArpProtocolCharacteristics;


//
//  Connection Oriented Client specific NDIS characteristics structure.
//  This contains our handlers for Connection-Oriented functions. We pass
//  this structure to NDIS when we open the Q.2931 Address Family.
//
NDIS_CLIENT_CHARACTERISTICS AtmArpClientCharacteristics;


#ifdef OLDSAP

ATM_BLLI_IE AtmArpDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,         // Layer2Mode
							(UCHAR)0x00,         // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)BLLI_L3_ISO_TR9577,  // Layer3Protocol
							(UCHAR)0x01,         // Layer3Mode
							(UCHAR)0x00,         // Layer3DefaultPacketSize
							(UCHAR)0x00,         // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)BLLI_L3_IPI_IP,  // Layer3IPI,
							(UCHAR)0x00,         // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#else

ATM_BLLI_IE AtmArpDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,         // Layer2Mode
							(UCHAR)0x00,         // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)SAP_FIELD_ABSENT,  // Layer3Protocol
							(UCHAR)0x00,         // Layer3Mode
							(UCHAR)0x00,         // Layer3DefaultPacketSize
							(UCHAR)0x00,         // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)0x00000000,   // Layer3IPI,
							(UCHAR)0x00,         // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#endif


ATM_BHLI_IE AtmArpDefaultBhli =
						{
							(ULONG)SAP_FIELD_ABSENT,   // HighLayerInfoType
							(ULONG)0x00000000,   // HighLayerInfoLength
							(UCHAR)0x00,         // HighLayerInfo[8]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};


AA_PKT_LLC_SNAP_HEADER AtmArpLlcSnapHeader =
						{
							(UCHAR)0xAA,
							(UCHAR)0xAA,
							(UCHAR)0x03,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(USHORT)AA_PKT_ETHERTYPE_IP_NS
						};

#ifdef IPMCAST
AA_MC_PKT_TYPE1_SHORT_HEADER AtmArpMcType1ShortHeader =
						{
							(UCHAR)MC_LLC_SNAP_LLC0,
							(UCHAR)MC_LLC_SNAP_LLC1,
							(UCHAR)MC_LLC_SNAP_LLC2,
							(UCHAR)MC_LLC_SNAP_OUI0,
							(UCHAR)MC_LLC_SNAP_OUI1,
							(UCHAR)MC_LLC_SNAP_OUI2,
							(USHORT)AA_PKT_ETHERTYPE_MC_TYPE1_NS,
							(USHORT)0x0,				// CMI
							(USHORT)AA_PKT_ETHERTYPE_IP_NS
						};

AA_MARS_PKT_FIXED_HEADER	AtmArpMcMARSFixedHeader =
						{
							(UCHAR)MC_LLC_SNAP_LLC0,
							(UCHAR)MC_LLC_SNAP_LLC1,
							(UCHAR)MC_LLC_SNAP_LLC2,
							(UCHAR)MC_LLC_SNAP_OUI0,
							(UCHAR)MC_LLC_SNAP_OUI1,
							(UCHAR)MC_LLC_SNAP_OUI2,
							(USHORT)AA_PKT_ETHERTYPE_MARS_CONTROL_NS,
							(USHORT)AA_MC_MARS_HEADER_AFN_NS,
							(UCHAR)0x08,	// this and the next == 0x800 (IPv4)
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,	// hdrrsv[0]
							(UCHAR)0x00,	// hdrrsv[1]
							(UCHAR)0x00,	// hdrrsv[2]
							(USHORT)0x0000,	// check-sum
							(USHORT)0x0000,	// extensions offset
							(USHORT)0x0000,	// Op code
							(UCHAR)0x00,	// Source ATM Number type+len
							(UCHAR)0x00		// Source ATM Subaddress type+len
						};

#endif // IPMCAST
#ifdef QOS_HEURISTICS

ATMARP_FLOW_INFO	AtmArpDefaultFlowInfo =
						{
							(PATMARP_FLOW_INFO)NULL,				// pNextFlow
							(PATMARP_FLOW_INFO)NULL,				// pPrevFlow
#ifdef GPC
							(PVOID)0,								// VcContext
							(GPC_HANDLE)NULL,						// CfInfoHandle
							{0},									// FlowInstanceName
#endif // GPC
							(ULONG)AAF_DEF_LOWBW_SEND_THRESHOLD,	// Max Send Size
							{		// Filter Spec:
								(ULONG)-1,							// DestinationPort
							},
							{		// Flow Spec:
								(ULONG)AAF_DEF_LOWBW_SEND_BANDWIDTH,
								(ULONG)65535,
								(ULONG)AAF_DEF_LOWBW_RECV_BANDWIDTH,
								(ULONG)65535,
								ENCAPSULATION_TYPE_LLCSNAP,
								AAF_DEF_LOWBW_AGING_TIME
							}
						};


#endif // QOS_HEURISTICS

#ifdef GPC
GPC_CLASSIFY_PACKET_HANDLER                 AtmArpGpcClassifyPacketHandler;
GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER 		AtmArpGpcGetCfInfoClientContextHandler;
#endif // GPC

//
//  Timer configuration.
//

#define AAT_MAX_TIMER_SHORT_DURATION            60      // Seconds
#define AAT_MAX_TIMER_LONG_DURATION         (30*60)     // Seconds

#define AAT_SHORT_DURATION_TIMER_PERIOD			 1		// Second
#define AAT_LONG_DURATION_TIMER_PERIOD			10		// Seconds

//
//  Max timeout value (in seconds) for each class.
//
ULONG	AtmArpMaxTimerValue[AAT_CLASS_MAX] =
						{
							AAT_MAX_TIMER_SHORT_DURATION,
							AAT_MAX_TIMER_LONG_DURATION
						};

//
//  Size of each timer wheel.
//
ULONG	AtmArpTimerListSize[AAT_CLASS_MAX] =
						{
							SECONDS_TO_SHORT_TICKS(AAT_MAX_TIMER_SHORT_DURATION),
							SECONDS_TO_LONG_TICKS(AAT_MAX_TIMER_LONG_DURATION)
						};
//
//  Interval between ticks, in seconds, for each class.
//
ULONG	AtmArpTimerPeriod[AAT_CLASS_MAX] =
						{
							AAT_SHORT_DURATION_TIMER_PERIOD,
							AAT_LONG_DURATION_TIMER_PERIOD
						};


#ifdef ATMARP_WMI

ATMARP_WMI_GUID		AtmArpGuidList[] = {
		{
			0,						// MyId
			//
			//  GUID_QOS_TC_SUPPORTED:
			//
			{0xe40056dcL,0x40c8,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x59,0x15},
			0,						// Flags
			AtmArpWmiQueryTCSupported,
			AtmArpWmiSetTCSupported,
			AtmArpWmiEnableEventTCSupported
		},

		{
			1,
			//
			//  GUID_QOS_TC_INTERFACE_UP_INDICATION:
			//
			{0x0ca13af0L,0x46c4,0x11d1,0x78,0xac,0x00,0x80,0x5f,0x68,0x35,0x1e},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		},

		{
			2,
			//
			//  GUID_QOS_TC_INTERFACE_DOWN_INDICATION:
			//
			{0xaf5315e4L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		},

		{
			3,
			//
			//  GUID_QOS_TC_INTERFACE_CHANGE_INDICATION:
			//
			{0xda76a254L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		}

#if 0
		,
		{
			4,
			//
			//   GUID_QOS_STATISTICS_BUFFER:
			//
			{0xbb2c0980L,0xe900,0x11d1,0xb0,0x7e,0x00,0x80,0xc7,0x13,0x82,0xbf},
			0,						// Flags
			AtmArpWmiQueryStatisticsBuffer,
			AtmArpWmiSetStatisticsBuffer,
			NULL
		}
#endif // 0

	};

ULONG				AtmArpGuidCount = sizeof(AtmArpGuidList) / sizeof(ATMARP_WMI_GUID);

#ifdef BACK_FILL
#ifdef ATMARP_WIN98
ULONG	AtmArpDoBackFill = 0;
#else
ULONG	AtmArpDoBackFill = 0;
#endif
ULONG	AtmArpBackFillCount = 0;
#endif // BACK_FILL

#endif // ATMARP_WMI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\arp.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    arp.h

Abstract:

    This file contains the definitions and data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

//
// Definition for an IP address
//
typedef ULONG		IPADDR;     // An IP address

//
// OpCodes - Define these in network byte order
//
#define	ATMARP_Request			0x0100
#define	ATMARP_Reply			0x0200
#define	InATMARP_Request		0x0800
#define	InATMARP_Reply			0x0900
#define	ATMARP_Nak				0x0A00

#define	ATM_HWTYPE				0x1300			// ATM Forum assigned - in network byte order
#define	IP_PROTOCOL_TYPE		0x0008			// In network byte order
#define	IP_ADDR_LEN				sizeof(IPADDR)

//
// the offset into the 20 byte ATM address where the ESI starts
//
#define	ESI_START_OFFSET		13

//
// Structure of a Q2931 ARP header.
//
//
// Encoding of the TL, ATM Number and ATM Sub-address encoding
//
typedef UCHAR					ATM_ADDR_TL;

#define	TL_LEN(_x_)				((_x_) & 0x3F)			// Low 6 bits
														// range is from 0-ATM_ADDRESS_LENGTH
#define	TL_TYPE(_x_)			(((_x_) & 0x40) >> 6)	// Bit # 7, 0 - ATM Forum NSAP, 1 - E164
#define	TL_RESERVED(_x_)		(((_x_) & 0x80) >> 7)	// Bit # 8 - Must be 0
#define	TL(_type_, _len_)		(((UCHAR)(_type_) << 6) + (UCHAR)(_len_))

#define	ADDR_TYPE_NSAP			0
#define	ADDR_TYPE_E164			1

#if	(ADDR_TYPE_NSAP != ATM_NSAP)
#error "Atm address type mismatch"
#endif
#if (ADDR_TYPE_E164 != ATM_E164)
#error "Atm address type mismatch"
#endif

//
// the structure for the LLC/SNAP encapsulation header on the IP packets for Q2931
//
typedef struct
{
	UCHAR			LLC[3];
	UCHAR			OUI[3];
	USHORT			EtherType;
} LLC_SNAP_HDR, *PLLC_SNAP_HDR;

//
// On the wire format for Atm ARP request
//
typedef struct _ARPS_HEADER
{
	LLC_SNAP_HDR				LlcSnapHdr;			// LLC SNAP Header
	USHORT						HwType;				// Hardware address space.
	USHORT						Protocol;			// Protocol address space.
	ATM_ADDR_TL					SrcAddressTL;		// Src ATM number type & length
	ATM_ADDR_TL					SrcSubAddrTL;		// Src ATM subaddr type & length
	USHORT						Opcode;				// Opcode.
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					DstAddressTL;		// Dest ATM number type & length
	ATM_ADDR_TL					DstSubAddrTL;		// Dest ATM subaddr type & length
	UCHAR						DstProtoAddrLen;	// Dest protocol addr length

	//
	// This is followed by variable length fields and is dictated by the value of fields above.
	//
} ARPS_HEADER, *PARPS_HEADER;

//
// The following structure is used ONLY to allocate space for the packet.
// It represents the maximum space needed for an arp request/reply.
//
typedef struct
{
	UCHAR						SrcHwAddr[ATM_ADDRESS_LENGTH];	 // Source HW address.
	UCHAR						SrcHwSubAddr[ATM_ADDRESS_LENGTH];// Source HW sub-address.
	IPADDR						SrcProtoAddr;					 // Source protocol address.
	UCHAR						DstHwAddr[ATM_ADDRESS_LENGTH];	 // Destination HW address.
	UCHAR						DstHwSubAddr[ATM_ADDRESS_LENGTH];// Destination HW sub-address.
	IPADDR						DstProtoAddr;					 // Destination protocol address.
} ARPS_VAR_HDR, *PARPS_VAR_HDR;

//
// Get a short (16-bits) from on-the-wire format (big-endian)
// to a short in the host format (either big or little endian)
//
#define GETSHORT2SHORT(_D_, _S_)											\
		*(PUSHORT)(_D_) = ((*((PUCHAR)(_S_)+0) << 8) + (*((PUCHAR)(_S_)+1)))

//
// Copy a short (16-bits) from the host format (either big or little endian)
// to a short in the on-the-wire format (big-endian)
//
#define PUTSHORT2SHORT(_D_, _S_)											\
		*((PUCHAR)(_D_)+0) = (UCHAR)((USHORT)(_S_) >> 8),					\
		*((PUCHAR)(_D_)+1) = (UCHAR)(_S_)

//
// Get a ULONG from on-the-wire format to a ULONG in the host format
//
#define GETULONG2ULONG(DstPtr, SrcPtr)   \
		*(PULONG)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 24) +				\
							  (*((PUCHAR)(SrcPtr)+1) << 16) +				\
							  (*((PUCHAR)(SrcPtr)+2) << 8)  +				\
							  (*((PUCHAR)(SrcPtr)+3)	))

//
// Put a ULONG from the host format to a ULONG to on-the-wire format
//
#define PUTULONG2ULONG(DstPtr, Src)											\
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((ULONG)(Src) >> 24),				\
		*((PUCHAR)(DstPtr)+1) = (UCHAR) ((ULONG)(Src) >> 16),				\
		*((PUCHAR)(DstPtr)+2) = (UCHAR) ((ULONG)(Src) >>  8),				\
		*((PUCHAR)(DstPtr)+3) = (UCHAR) (Src)


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\data.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains the data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_DATA

PDRIVER_OBJECT	ArpSDriverObject = NULL;
PDEVICE_OBJECT	ArpSDeviceObject = NULL;
NDIS_HANDLE		ArpSProtocolHandle = NULL;
NDIS_HANDLE		ArpSPktPoolHandle = NULL;
NDIS_HANDLE		ArpSBufPoolHandle = NULL;
NDIS_HANDLE		MarsPktPoolHandle = NULL;
NDIS_HANDLE		MarsBufPoolHandle = NULL;
PINTF			ArpSIfList = NULL;
ULONG			ArpSIfListSize = 0;
KSPIN_LOCK		ArpSIfListLock = { 0 };
KQUEUE			ArpSReqQueue = {0};
KQUEUE			MarsReqQueue = {0};
LIST_ENTRY		ArpSEntryOfDeath = {0};
KEVENT			ArpSReqThreadEvent = {0};
SLIST_HEADER	ArpSPktList = {0};
KSPIN_LOCK		ArpSPktListLock = { 0 };
UINT			ArpSBuffers = NUM_ARPS_DESC;
UINT			MarsPackets = NUM_MARS_DESC;
PVOID			ArpSBufferSpace = NULL;
USHORT			ArpSFlushTime = FLUSH_TIME;
USHORT			ArpSNumEntriesInBlock[ARP_BLOCK_TYPES] =
		{
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(ARP_ENTRY) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(ARP_ENTRY) + sizeof(ATM_ADDRESS)),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(GROUP_MEMBER) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(CLUSTER_MEMBER) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(CLUSTER_MEMBER) + sizeof(ATM_ADDRESS)),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(MARS_ENTRY) + 0)
		};

USHORT			ArpSEntrySize[ARP_BLOCK_TYPES] =
		{
			sizeof(ARP_ENTRY),
			sizeof(ARP_ENTRY) + sizeof(ATM_ADDRESS),
			sizeof(GROUP_MEMBER),
			sizeof(CLUSTER_MEMBER),
			sizeof(CLUSTER_MEMBER) + sizeof(ATM_ADDRESS),
			sizeof(MARS_ENTRY) + 0
		};

BOOLEAN			ArpSBlockIsPaged[ARP_BLOCK_TYPES] =
		{
			TRUE,
			TRUE,
			FALSE,
			FALSE,
			FALSE,
			FALSE
		};

#ifdef OLDSAP

ATM_BLLI_IE 	ArpSDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,		 // Layer2Mode
							(UCHAR)0x00,		 // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)BLLI_L3_ISO_TR9577,  // Layer3Protocol
							(UCHAR)0x01,		 // Layer3Mode
							(UCHAR)0x00,		 // Layer3DefaultPacketSize
							(UCHAR)0x00,		 // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)BLLI_L3_IPI_IP,  // Layer3IPI,
							(UCHAR)0x00,		 // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#else

ATM_BLLI_IE 	ArpSDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,		 // Layer2Mode
							(UCHAR)0x00,		 // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)SAP_FIELD_ABSENT,  // Layer3Protocol
							(UCHAR)0x00,		 // Layer3Mode
							(UCHAR)0x00,		 // Layer3DefaultPacketSize
							(UCHAR)0x00,		 // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)0x00000000,   // Layer3IPI,
							(UCHAR)0x00,		 // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#endif // OLDSAP

ATM_BHLI_IE		ArpSDefaultBhli =
						{
							(ULONG)SAP_FIELD_ABSENT,   // HighLayerInfoType
							(ULONG)0x00000000,   // HighLayerInfoLength
							(UCHAR)0x00,         // HighLayerInfo[8]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};
LLC_SNAP_HDR	ArpSLlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x00 }, { 0x0608 } };
LLC_SNAP_HDR	MarsCntrlLlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0300 } };
LLC_SNAP_HDR	MarsData1LlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0100 } };
LLC_SNAP_HDR	MarsData2LlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0400 } };

MARS_HEADER		MarsCntrlHdr =
						{ { { 0xAA, 0xAA, 0x03 } ,  { 0x00, 0x00, 0x5E } , 0x0300 },
						  // { 0x00, 0x0f },	// HwType or AFN
						  0x0f00,
						  // { 0x08, 0x00 },	// Pro.Type
						  0x0008,
						  { 0x00, 0x00, 0x00, 0x00, 0x00 },	// ProtocolSnap[]
						  { 0x00, 0x00, 0x00 },	// Reserved[]
						  // { 0x00, 0x00 },	// Checksum
						  0x0000,
						  // { 0x00, 0x00 },	// Extension offset
						  0x0000,
						  // { 0x00, 0x00 },	// OpCode
						  0x0000,
						  0x00,				// SrcAddressTL
						  0x00				// SrcSubAddrTL
						};

MARS_FLOW_SPEC		DefaultCCFlowSpec =
						{
							DEFAULT_SEND_BANDWIDTH,
							DEFAULT_MAX_PACKET_SIZE,
							0,		// ReceiveBandwidth for PMP is zero
							0,		// ReceiveMaxSize for PMP is zero
							SERVICETYPE_BESTEFFORT
						};

MARS_TLV_MULTI_IS_MCS	MultiIsMcsTLV =
						{
							MARS_TLVT_MULTI_IS_MCS,
							0x0000		// TLV variable part Length
						};

MARS_TLV_NULL		NullTLV =
						{
							0x0000,
							0x0000
						};
#if	DBG
ULONG		ArpSDebugLevel = DBG_LEVEL_ERROR;
ULONG		MarsDebugLevel = DBG_LEVEL_ERROR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\timeouts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	timeouts.c		- Timeout handlers.

Abstract:

	All timeout handlers for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-01-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'EMIT'



VOID
AtmArpServerConnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout indicates that enough time has passed since a previous
	failed attempt at connecting to the ARP server. Try again now.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AADEBUGP(AAD_INFO, ("Server Connect timeout on IF 0x%x\n", pInterface));

			//
			//  Restart registration
			//
			AtmArpStartRegistration(pInterface);
			//
			//  IF lock is released by the above routine.
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	// else the Interface is gone!

	return;
}




VOID
AtmArpRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called if we timed out waiting for registration to a server
	to complete. If we have retries left for this server, we send another
	ARP Request to register ourselves. Otherwise, we close all VCs to this
	server, move to the next server in the server list, and wait for a while
	before initiating registration to this new server.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Registration timeout: pIf 0x%x, IF Flags 0x%x\n",
				pInterface, pInterface->Flags));

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		AtmArpRetryServerRegistration(pInterface);
		//
		//  The IF lock is released within the above.
		//
	}
	//
	//  else the Interface is gone.
	//

	return;

}



VOID
AtmArpServerRefreshTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is periodically invoked so that we can refresh our
	IP address+ATM address info with the ARP server. We do so by registering
	the first of our local IP addresses. We mark all the other IP addresses
	configured on this interface as "not registered", so that, when the first
	one completes, we register all the rest.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIPAddressEntry;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Server Refresh timeout: IF 0x%x\n", pInterface));

	//
	// We also use this opportunity to clean out orphan entries in the
	// Arp Table.
	//
	AtmArpCleanupArpTable(pInterface);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			//
			//  Mark all local addresses as not registered.
			//
			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (pIPAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				pIPAddressEntry->IsRegistered = FALSE;
				pIPAddressEntry = pIPAddressEntry->pNext;
			}

			//
			//  Start registering the first one.
			//
			pInterface->RetriesLeft = pInterface->MaxRegistrationAttempts - 1;

			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_NO_CONTACT);

			AtmArpStartRegistration(pInterface);
			//
			//  The IF lock is released in the above routine.
			//
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	//
	// else the Interface is gone!
	//

	return;
}



VOID
AtmArpAddressResolutionTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to an ARP Request
	we had sent ages ago in order to resolve/refresh an IP entry.

	First, check if the IP address got resolved anyway (e.g. an InARP Reply
	on a PVC). If so, we don't have to do anything. Otherwise, check if we
	have tried enough times. If we have retries left, send another ARP
	Request.

	If we have run out of retries, delete the IP entry, and any VCs going to it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;		// IP Entry being ARP'ed for.
	ULONG					Flags;			// On IP Entry
	PATMARP_VC				pVc;			// VC to this IP destination
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;				// Ref Count on IP Entry
	IP_ADDRESS				DstIPAddress;	// Address being resolved
	IP_ADDRESS UNALIGNED *	pSrcIPAddress;	// Our IP address
#ifdef IPMCAST
	BOOLEAN					IsMARSProblem;
#endif

#ifdef IPMCAST
	IsMARSProblem = FALSE;
#endif

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
	Flags = pIpEntry->Flags;

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference

	//
	//  Continue only if the IP Entry still exists
	//
	if (rc > 0)
	{
		AADEBUGP(AAD_INFO,
			("Addr Resolution timeout: pIpEntry 0x%x, Flags 0x%x, IP Addr: %d.%d.%d.%d\n",
					pIpEntry,
					pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3]
			));

		//
		//  Check if the entry got resolved somehow.
		//
		if (!AA_IS_FLAG_SET(
						Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_RESOLVED))
		{
			//
			// We are still trying to resolve this. See if we have
			// retries left.
			//
			pInterface = pIpEntry->pInterface;

			if (pIpEntry->RetriesLeft != 0)
			{
				pIpEntry->RetriesLeft--;

				//
				// Try again: start addr resolution timer, send ARP Request.
				//
				pSrcIPAddress = &(pInterface->LocalIPAddress.IPAddress);
				DstIPAddress = pIpEntry->IPAddress;

				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpAddressResolutionTimeout,
							pInterface->AddressResolutionTimeout,
							(PVOID)pIpEntry
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer reference

				AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef IPMCAST
				if (AA_IS_FLAG_SET(Flags,
									AA_IP_ENTRY_ADDR_TYPE_MASK,
									AA_IP_ENTRY_ADDR_TYPE_UCAST))
				{
					AtmArpSendARPRequest(
								pInterface,
								pSrcIPAddress,
								&DstIPAddress
								);
				}
				else
				{
					AtmArpMcSendRequest(
								pInterface,
								&DstIPAddress
								);
				}
#else
				AtmArpSendARPRequest(
							pInterface,
							pSrcIPAddress,
							&DstIPAddress
							);
#endif // IPMCAST
			}
			else
			{
				//
				//  We are out of retries. Check if we were REvalidating
				//  an entry that was aged out. If so, try revalidating
				//  using InARP on a VC attached to it -- if no such VC
				//  exists, delete the IP Entry.
				//
				if ((pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
#ifdef IPMCAST
					(AA_IS_FLAG_SET(Flags,
									AA_IP_ENTRY_ADDR_TYPE_MASK,
									AA_IP_ENTRY_ADDR_TYPE_UCAST)) &&
#endif // IPMCAST
					(pIpEntry->pAtmEntry->pVcList != NULL_PATMARP_VC))
				{
					pVc = pIpEntry->pAtmEntry->pVcList;

					//
					//  Try revalidating now via InARP.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_INARPING
							);

					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryInARPWaitTimeout,
							pInterface->InARPWaitTimeout,
							(PVOID)pIpEntry
							);

					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer reference

					AA_RELEASE_IE_LOCK(pIpEntry);
#ifdef VC_REFS_ON_SENDS
					AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
					AtmArpSendInARPRequest(pVc);
				}
				else
				{
					AtmArpAbortIPEntry(pIpEntry);
					//
					//  The IP Entry lock is released in the above routine.
					//
#ifdef IPMCAST
					IsMARSProblem = AA_IS_FLAG_SET(Flags,
												AA_IP_ENTRY_ADDR_TYPE_MASK,
												AA_IP_ENTRY_ADDR_TYPE_NUCAST);
#endif // IPMCAST
				}
			}
		}
		else
		{
			//
			//  The IP Entry must have got resolved.
			//  Nothing more to be done.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
	}
	// else the IP Entry is gone

#ifdef IPMCAST
	if (IsMARSProblem)
	{
		AtmArpMcHandleMARSFailure(pInterface, FALSE);
	}
#endif // IPMCAST
	return;
}



VOID
AtmArpIPEntryInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout happens if we don't receive an InARP Reply in response
	to an InARP Request sent in order to revalidate an IP Entry. Delete
	the entry.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	ULONG					rc;			// Ref Count on IP Entry

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);

	if (rc > 0)
	{
		AtmArpAbortIPEntry(pIpEntry);
		//
		//  The IP Entry lock is released in the above routine.
		//
	}
	//
	//  else the entry is gone.
	//
}





VOID
AtmArpPVCInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout happens if we don't receive a reply to an InARP Request
	we had sent in order to resolve a PVC. We send another InARP Request,
	and restart this timer, but to fire after a longer delay.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP VC structure

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;		// Ref Count on VC

	pVc = (PATMARP_VC)Context;
	AA_STRUCT_ASSERT(pVc, avc);

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);	// Timer ref

	if (rc > 0)
	{
		AA_ASSERT(AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_INARP_IN_PROGRESS));

		pInterface = pVc->pInterface;


		AtmArpStartTimer(
					pInterface,
					&(pVc->Timer),
					AtmArpPVCInARPWaitTimeout,
					(2 * pInterface->InARPWaitTimeout),
					(PVOID)pVc
					);


		AtmArpReferenceVc(pVc);	// Timer ref

#ifndef VC_REFS_ON_SENDS
		AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS

		//
		//  Send another InARP Request on the PVC
		//
		AtmArpSendInARPRequest(pVc);
	}
	//
	//  else the VC is gone
	//
}




VOID
AtmArpIPEntryAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if some time has passed (~15 minutes) since an
	IP entry was last resolved/refreshed.

	If there is no VC attached to this IP entry, we delete it. Otherwise,
	revalidate the entry:
	- Mark this entry so that packets are temporarily queued rather
	  than sent.
	- If "the VC attached to this entry" is a PVC, send an InARP Request
	  to validate the entry, otherwise, send an ARP Request to the server
	  to validate.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;	// IP Entry that has aged out
	ULONG					rc;			// Ref count on IP Entry
	PATMARP_VC				pVc;		// VC going to this IP Entry
	ULONG					VcFlags;	// Flags on above VC
	PATMARP_INTERFACE		pInterface;
	IP_ADDRESS				DstIPAddress;	// IP Address on this Entry


	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	VcFlags = 0;

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref

	//
	//  Continue only if the entry hasn't gone away.
	//
	if (rc != 0)
	{
		//
		//  Continue only if the Interface is not going down
		//
		pInterface = pIpEntry->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			PATMARP_ATM_ENTRY		pAtmEntry;

			pAtmEntry = pIpEntry->pAtmEntry;
			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
				pVc = pAtmEntry->pVcList;
				if (pVc != NULL_PATMARP_VC)
				{
					VcFlags = pVc->Flags;
				}
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
			}
			else
			{
				pVc = NULL_PATMARP_VC;
			}

			AADEBUGP(AAD_INFO,
 				("Aged out IP Entry 0x%x, Flags 0x%x, IP Addr: %d.%d.%d.%d, VC: 0x%x\n",
						pIpEntry,
						pIpEntry->Flags,
						((PUCHAR)(&(pIpEntry->IPAddress)))[0],
						((PUCHAR)(&(pIpEntry->IPAddress)))[1],
						((PUCHAR)(&(pIpEntry->IPAddress)))[2],
						((PUCHAR)(&(pIpEntry->IPAddress)))[3],
						pVc
 				)	);

#ifdef IPMCAST
			if ((pVc != NULL_PATMARP_VC) &&
				(AA_IS_FLAG_SET(pIpEntry->Flags,
								AA_IP_ENTRY_ADDR_TYPE_MASK,
								AA_IP_ENTRY_ADDR_TYPE_UCAST)))
#else
			if (pVc != NULL_PATMARP_VC)
#endif // IPMCAST
			{
				//
				//  There is atleast one VC going to this IP Address.
				//  So we try to revalidate this IP entry: use InARP
				//  if the VC is a PVC, otherwise use ARP.
				//

				//
				//  First mark this entry so that we don't send packets
				//  to this destination till it is revalidated.
				//
				pIpEntry->Flags |= AA_IP_ENTRY_AGED_OUT;

				if (AA_IS_FLAG_SET(VcFlags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC))
				{
					//
					//  PVC; send InARP Request: actually, we fire off a timer
					//  at whose expiry we send the InARP Request.
					//
					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryInARPWaitTimeout,
							pInterface->InARPWaitTimeout,
							(PVOID)pIpEntry
							);

					AA_SET_FLAG(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_INARPING);
					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref
					AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef VC_REFS_ON_SENDS
					AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
					AtmArpSendInARPRequest(pVc);
				}
				else
				{
					//
					//  SVC; send ARP Request
					//

					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpAddressResolutionTimeout,
							pInterface->AddressResolutionTimeout,
							(PVOID)pIpEntry
							);

					pIpEntry->RetriesLeft = 0;
					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref
					AA_SET_FLAG(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_ARPING);
					DstIPAddress = pIpEntry->IPAddress;

					AA_RELEASE_IE_LOCK(pIpEntry);

					AtmArpSendARPRequest(
							pInterface,
							&(pInterface->LocalIPAddress.IPAddress),
							&DstIPAddress
							);
				}
			}
			else
			{
				//
				//  No VCs attached to this IP Entry; Delete it.
				//

				AtmArpAbortIPEntry(pIpEntry);
				//
				//  The IP Entry lock is released in the above routine.
				//
			}
		}
		else
		{
			//
			//  The Interface is going down.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
	}
	//
	//  else the IP Entry is gone
	//
	return;		

}





VOID
AtmArpVcAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if there hasn't been traffic on a VC for
	some time. We should be running this timer on a VC only if it is
	an SVC.

	Close the VC.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP VC

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;			// VC that has aged out
	ULONG					rc;				// Ref Count on the VC
	PATMARP_INTERFACE		pInterface;


	pVc = (PATMARP_VC)Context;
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_SVC));

	AADEBUGP(AAD_INFO, ("Aged out VC %x, Flags %x, ATMEntry %x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));
#if DBG
	if (pVc->pAtmEntry)
	{
		AADEBUGPATMADDR(AAD_INFO, "To ATM Addr:", &pVc->pAtmEntry->ATMAddress);
	}
#endif

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);	// Timer ref

	//
	//  Continue only if the VC hasn't gone away in the meantime.
	//
	if (rc > 0)
	{
		//
		//  Continue only if the Interface isn't going down.
		//
		pInterface = pVc->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AADEBUGP(AAD_INFO,
				("Aged out VC 0x%x, RefCount %d, Flags 0x%x, pAtmEntry 0x%x\n",
					pVc, pVc->RefCount, pVc->Flags, pVc->pAtmEntry));

			AtmArpCloseCall(pVc);
		}
		else
		{
			//
			//  The interface is going down.
			//
			AA_RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone
	//

	return;

}




VOID
AtmArpNakDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if sufficient time has elapsed since we last
	received a NAK for an IP address. This means that we can try again
	(if necessary) to resolve this IP address.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	AA_ASSERT(AA_IS_FLAG_SET(pIpEntry->Flags,
							 AA_IP_ENTRY_STATE_MASK, 
							 AA_IP_ENTRY_SEEN_NAK));

	AADEBUGP(AAD_INFO, ("NakDelay timeout: pIpEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
					pIpEntry,
					((PUCHAR)(&(pIpEntry->IPAddress)))[0],
					((PUCHAR)(&(pIpEntry->IPAddress)))[1],
					((PUCHAR)(&(pIpEntry->IPAddress)))[2],
					((PUCHAR)(&(pIpEntry->IPAddress)))[3]
					));

	pInterface = pIpEntry->pInterface;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);
	if (rc > 0)
	{
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_STATE_MASK,
					AA_IP_ENTRY_IDLE2);

		AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpIPEntryAgingTimeout,
					pInterface->ARPEntryAgingTimeout,
					(PVOID)pIpEntry
					);

		AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
		AA_RELEASE_IE_LOCK(pIpEntry);
	}
	//
	//  else the IP Entry is gone.
	//


	return;
}


#ifdef IPMCAST

VOID
AtmArpMcMARSRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	We haven't received acknowledgement of registering with the MARS.
	If we have retries left for this, try registering again. Otherwise,
	process this as a MARS failure.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("MARS Registration timeout: pIf 0x%x, IF Flags 0x%x\n",
				pInterface, pInterface->Flags));

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			if (pInterface->McRetriesLeft != 0)
			{
				pInterface->McRetriesLeft--;

				AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);
	
				AtmArpMcStartRegistration(pInterface);
				//
				//  IF Lock is released within the above.
				//
			}
			else
			{
				//
				//  Out of retries: problems with this MARS
				//
				AA_RELEASE_IF_LOCK(pInterface);
				AtmArpMcHandleMARSFailure(pInterface, TRUE);
			}
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
}



VOID
AtmArpMcMARSReconnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is the end of a delay before we retry registering with MARS.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// MARS Reconnect timer deref
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_INFO, ("MARS Reconnect timeout: pIf 0x%x, Flags 0x%x\n",
					pInterface, pInterface->Flags));

			AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);

			AA_SET_FLAG(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE);

			AtmArpMcStartRegistration(pInterface);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	//
	//  else the IF is gone.
	//
}



VOID
AtmArpMcMARSKeepAliveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called if "MARSKeepAliveTimeout" seconds have passed since
	we last received a MARS_REDIRECT message.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// MARS Keepalive timer deref
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_INFO, ("MARS Keepalive timeout: pIf 0x%x, Flags 0x%x\n",
					pInterface, pInterface->Flags));

			AA_RELEASE_IF_LOCK(pInterface);

			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}

}



VOID
AtmArpMcJoinOrLeaveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	We timed out waiting for an acknowledgement for a MARS_JOIN/MARS_LEAVE.

	If we have retries left for this JOIN/LEAVE, resend the JOIN. Otherwise,
	declare a MARS failure.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our JOIN Entry structure

Return Value:

	None

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_INTERFACE			pInterface;
	PIP_ADDRESS					pIpAddress;
	IP_MASK						IpMask;
	USHORT						OpType;

	pJoinEntry = (PATMARP_IPMC_JOIN_ENTRY)Context;
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pInterface = pJoinEntry->pInterface;

	AAMCDEBUGP(AAD_VERY_LOUD,
		("McJoinTimeout: pJoinEntry 0x%x, RetriesLeft %d, IP Addr: %d.%d.%d.%d\n",
				pJoinEntry,
				pJoinEntry->RetriesLeft,
				((PUCHAR)&(pJoinEntry->IPAddress))[0],
				((PUCHAR)&(pJoinEntry->IPAddress))[1],
				((PUCHAR)&(pJoinEntry->IPAddress))[2],
				((PUCHAR)&(pJoinEntry->IPAddress))[3]));

	AA_ACQUIRE_IF_LOCK(pInterface);
	if (pInterface->AdminState == IF_STATUS_UP)
	{
		pJoinEntry->RetriesLeft--;
		if (pJoinEntry->RetriesLeft != 0)
		{
			pIpAddress = &(pJoinEntry->IPAddress);
			IpMask = pJoinEntry->Mask;

			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_LEAVING))
			{
				OpType = AA_MARS_OP_TYPE_LEAVE;
			}
			else
			{
				OpType = AA_MARS_OP_TYPE_JOIN;

				//
				// State could've been "pending"
				//
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
			}

			//
			//  Restart the "Wait For Join completion" timer.
			//
			AtmArpStartTimer(
				pInterface,
				&(pJoinEntry->Timer),
				AtmArpMcJoinOrLeaveTimeout,
				pInterface->JoinTimeout,
				(PVOID)pJoinEntry
				);
			
			//
			//  Resend the Join or Leave
			//
			AAMCDEBUGP(AAD_INFO,
				("Resending Join/Leave: pIf 0x%x, pJoinEntry 0x%x, Addr: %d.%d.%d.%d\n",
						pInterface,
						pJoinEntry,
						((PUCHAR)pIpAddress)[0],
						((PUCHAR)pIpAddress)[1],
						((PUCHAR)pIpAddress)[2],
						((PUCHAR)pIpAddress)[3]));

			AtmArpMcSendJoinOrLeave(
				pInterface,
				OpType,
				pIpAddress,
				IpMask
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			//
			//  Out of retries: problems with this MARS.
			//
			AA_RELEASE_IF_LOCK(pInterface);
			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
}




VOID
AtmArpMcRevalidationDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	It's time to mark an IP Entry representing a Multicast group as
	needing revalidation.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;
	PNDIS_PACKET				PacketList;

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	PacketList = NULL;

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref

	//
	//  Continue only if the entry hasn't gone away.
	//
	if (rc != 0)
	{
		//
		//  Remove any packets queued on this IP Entry.
		//
		PacketList = pIpEntry->PacketList;
		pIpEntry->PacketList = (PNDIS_PACKET)NULL;

		//
		//  Continue only if the state is OK.
		//
		pInterface = pIpEntry->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_LOUD,
					("Marking Revalidate: pIpEntry 0x%x/0x%x, pAtmEntry 0x%x, Addr: %d.%d.%d.%d\n",
							pIpEntry,
							pIpEntry->Flags,
							pIpEntry->pAtmEntry,
							((PUCHAR)&(pIpEntry->IPAddress))[0],
							((PUCHAR)&(pIpEntry->IPAddress))[1],
							((PUCHAR)&(pIpEntry->IPAddress))[2],
							((PUCHAR)&(pIpEntry->IPAddress))[3]));

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_VALIDATE_MASK,
						AA_IP_ENTRY_MC_REVALIDATE);
		}

		AA_RELEASE_IE_LOCK(pIpEntry);
	}
	//
	//  else the IP Entry is gone.
	//

	if (PacketList != NULL)
	{
		//
		//  Free all packets that were queued on the IP Entry.
		//
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					FALSE       // No LLC/SNAP header on these
					);
	}
}


VOID
AtmArpMcPartyRetryDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	End of a delay after failing to connect or add-party a member of
	a multicast group. Unmark this member, and attempt to add it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our MC ATM Entry structure

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)Context;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AAMCDEBUGP(AAD_LOUD,
		("PartyRetryDelay timeout: pMcAtmEntry 0x%x, pAtmEntry 0x%x\n",
				pMcAtmEntry, pAtmEntry));

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_ASSERT(pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	if (pAtmEntry->pInterface->AdminState == IF_STATUS_UP)
	{
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_DISCONNECTED);
		
		//
		//  Move this MC ATM Entry to the top of the list it belongs to.
		//
		//  Find the predecessor for this MC ATM Entry:
		//
		for (ppMcAtmEntry = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
			 *ppMcAtmEntry != pMcAtmEntry;
			 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
		{
			AA_ASSERT(*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
		}

		//
		//  Unlink the MC ATM Entry from its current position
		//
		*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

		//
		//  And insert at the top of the list.
		//
		pMcAtmEntry->pNextMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
		pAtmEntry->pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
	
}


#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\data.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    data.h

Abstract:

    This file contains the data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_DATA_
#define	_DATA_

extern	PDRIVER_OBJECT	ArpSDriverObject;
extern	PDEVICE_OBJECT	ArpSDeviceObject;
extern	NDIS_HANDLE		ArpSProtocolHandle;
extern	NDIS_HANDLE		ArpSPktPoolHandle;
extern	NDIS_HANDLE		ArpSBufPoolHandle;
extern	NDIS_HANDLE		MarsPktPoolHandle;
extern	NDIS_HANDLE		MarsBufPoolHandle;
extern  PINTF			ArpSIfList;
extern  ULONG			ArpSIfListSize;
extern  KSPIN_LOCK		ArpSIfListLock;
extern	KQUEUE			ArpSReqQueue;
extern	KQUEUE			MarsReqQueue;
extern	LIST_ENTRY		ArpSEntryOfDeath;
extern	KEVENT			ArpSReqThreadEvent;
extern	SLIST_HEADER	ArpSPktList;
extern	KSPIN_LOCK		ArpSPktListLock;
extern	UINT			ArpSBuffers;
extern	UINT			MarsPackets;
extern	PVOID			ArpSBufferSpace;
extern	USHORT			ArpSFlushTime;
extern	USHORT			ArpSNumEntriesInBlock[ARP_BLOCK_TYPES];
extern	USHORT			ArpSEntrySize[ARP_BLOCK_TYPES];
extern	BOOLEAN			ArpSBlockIsPaged[ARP_BLOCK_TYPES];

extern	ATM_BLLI_IE 	ArpSDefaultBlli;
extern	ATM_BHLI_IE 	ArpSDefaultBhli;
extern	LLC_SNAP_HDR	ArpSLlcSnapHdr;
extern	LLC_SNAP_HDR	MarsCntrlLlcSnapHdr;
extern  LLC_SNAP_HDR	MarsData1LlcSnapHdr;
extern  LLC_SNAP_HDR	MarsData2LlcSnapHdr;
extern	MARS_HEADER		MarsCntrlHdr;
extern	MARS_FLOW_SPEC	DefaultCCFlowSpec;
extern	MARS_TLV_MULTI_IS_MCS	MultiIsMcsTLV;
extern	MARS_TLV_NULL	NullTLV;

extern	ULONG			ArpSDebugLevel;
extern	ULONG			MarsDebugLevel;

#endif	// _DATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\system.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	system.h

Abstract:

	ATMARP Client versions of system objects/definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-28-96    Created

Notes:

--*/

#ifndef __ATMARPC_SYSTEM__H
#define __ATMARPC_SYSTEM__H


#define ATMARP_NDIS_MAJOR_VERSION		5
#define ATMARP_NDIS_MINOR_VERSION		0


#define ATMARP_UL_NAME			L"ATMARPC"
#define ATMARP_LL_NAME			L"TCPIP_ATMARPC"
//
//  4/3/1998 JosephJ The UL version above is presented to TCPIP and the
//                   LL version is presented to NDIS, so that NDIS will
//                   find us when a "TCPIP" reconfiguration is sent to it
//                   (NDIS will first look for an exact match and then for
//                    a proper prefix match.)
//


#define ATMARP_NAME_STRING	NDIS_STRING_CONST("ATMARPC")
#define ATMARP_DEVICE_NAME	L"\\Device\\ATMARPC"
#define ATMARP_REGISTRY_PATH	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\AtmArpC"

#define MAX_IP_CONFIG_STRING_LEN		200

#define LOCKIN
#define LOCKOUT
#define NOLOCKOUT

#ifndef APIENTRY
#define APIENTRY
#endif

typedef struct _ATMARP_BLOCK
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMARP_BLOCK, *PATMARP_BLOCK;


//
//  List manipulation stuff
//

typedef SLIST_ENTRY AA_SINGLE_LIST_ENTRY, *PAA_SINGLE_LIST_ENTRY;

#define NULL_PAA_SINGLE_LIST_ENTRY	((PAA_SINGLE_LIST_ENTRY)NULL)

#define AA_POP_FROM_SLIST	ExInterlockedPopEntrySList
#define AA_PUSH_TO_SLIST	ExInterlockedPushEntrySList
#define AA_INIT_SLIST		ExInitializeSListHead

#if !BINARY_COMPATIBLE

/*++
VOID
AA_COMPLETE_IRP(
	IN	PIRP			pIrp,
	IN	NTSTATUS		Status,
	IN	ULONG			Length
)
Complete a pending IRP.
--*/
#define AA_COMPLETE_IRP(_pIrp, _Status, _Length)				\
			{													\
				(_pIrp)->IoStatus.Status = (_Status);			\
				(_pIrp)->IoStatus.Information = (_Length);		\
				IoCompleteRequest((_pIrp), IO_NO_INCREMENT);	\
			}

#define AA_IRQL			KIRQL


#if DBG
#define AA_GET_ENTRY_IRQL(Irql)	\
			Irql = KeGetCurrentIrql()
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)	\
		{										\
			ExitIrql = KeGetCurrentIrql();		\
			if (ExitIrql != EntryIrql)			\
			{									\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, ExitIrql, EntryIrql);			\
				DbgBreakPoint();				\
			}									\
		}
#else
#define AA_GET_ENTRY_IRQL(Irql)
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)
#endif // DBG

#endif // !BINARY_COMPATIBLE


#if BINARY_COMPATIBLE
#define AA_GET_ENTRY_IRQL(Irql)
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#define AA_IRQL			ULONG

#endif // BINARY_COMPATIBLE


#ifdef BACK_FILL

/*++
BOOLEAN
AA_BACK_FILL_POSSIBLE(
	IN	PNDIS_BUFFER		pNdisBuffer
)
Check if we can back-fill the specified NDIS buffer with Low-layer headers.
--*/
#define AA_BACK_FILL_POSSIBLE(_pBuf)	\
				(((_pBuf)->MdlFlags & MDL_NETWORK_HEADER) != 0)

#endif // BACK_FILL

#endif // __ATMARPC_SYSTEM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\utils.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	utils.c		- Utility functions.

Abstract:

   Internal utility functions for ATMARP:

	- Allocation and deallocation of various structures
	- Timer management
	- Buffer/Packet management
	- Linking/unlinking ATMARP structures
	- Copy support functions


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-15-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'LITU'

//
// AtmArpValidateTimerList and AtmArpValidateTimer are used in the checked
// build to validate the state of a timerlist and timer, respectively.
// They are not defined and used in the free build.
//

#if  DBG
void
AtmArpValidateTimerList(
	PATMARP_TIMER_LIST		pTimerList
	);

void
AtmArpValidateTimer(
	PATMARP_TIMER_LIST		pTimerList,
	PATMARP_TIMER			pTimer
	);

//
// AtmArpValidateTimerList is overkill for general use (even default
// free build) -- because it goes through the entire timer list --
// so disable it by default
//
#if 0
#define AA_VALIDATE_TIMER_LIST(_ptl) 	AtmArpValidateTimerList(_ptl)
#else
#define AA_VALIDATE_TIMER_LIST(_ptl) 	((void) 0)
#endif

#define AA_VALIDATE_TIMER(_ptl,_pt) 	AtmArpValidateTimer(_ptl,_pt)

#else // !DBG

#define AA_VALIDATE_TIMER_LIST(_ptl) 	((void) 0)
#define AA_VALIDATE_TIMER(_ptl,_pt) 	((void) 0)

#endif // !DBG




VOID
AtmArpSetMemory(
	IN	PUCHAR						pStart,
	IN	UCHAR						Value,
	IN	ULONG						NumberOfBytes
)
/*++

Routine Description:

	Set "NumberOfBytes" bytes starting from "pStart" to "Value".

Arguments:

	pStart			- where to start filling.
	Value			- the value to put everywhere
	NumberOfBytes	- how many bytes to fill in

Return Value:

	None

--*/
{
	while (NumberOfBytes--)
	{
		*pStart++ = Value;
	}
}



ULONG
AtmArpMemCmp(
	IN	PUCHAR						pString1,
	IN	PUCHAR						pString2,
	IN	ULONG						Length
)
/*++

Routine Description:

	Compare two byte strings.

Arguments:

	pString1		- Start of first string
	pString2		- Start of second string
	Length			- Length to compare

Return Value:

	0 if both are equal, -1 if string 1 is "smaller", +1 if string 1 is "larger".

--*/
{
	while (Length--)
	{
		if (*pString1 != *pString2)
		{
			return ((*pString1 > *pString2)? (ULONG)1 : (ULONG)-1);
		}
		pString1++;
		pString2++;
	}

	return (0);
}



LONG
AtmArpRandomNumber(
	VOID
)
/*++

Routine Description:

	Generate a positive pseudo-random number; simple linear congruential
	algorithm. ANSI C "rand()" function. Courtesy JameelH.

Arguments:

	None

Return Value:

	a random number.

--*/
{
	LARGE_INTEGER		Li;
	static LONG			seed = 0;

	if (seed == 0)
	{
		NdisGetCurrentSystemTime(&Li);
        seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);
	return (seed & 0x7FFFFFFF);
}




VOID
AtmArpCheckIfTimerIsInActiveList(
	IN	PATMARP_TIMER				pTimerToCheck,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PVOID						pStruct,
	IN	PCHAR						pStructName
	)
/*
	Instrumentation to catch a bug that causes the timer list to
	contain a pointer to an element that's been freed.
*/
{
	PATMARP_TIMER_LIST	pTimerList;
	PATMARP_TIMER		pTimer;
	ULONG				i, j;

	do
	{
		if (pInterface == NULL)
		{
			break;
		}

		if (pTimerToCheck->State == ATMARP_TIMER_STATE_RUNNING ||
			pTimerToCheck->State == ATMARP_TIMER_STATE_EXPIRING)
		{
			DbgPrint("ATMARPC: %s at %x contains timer %x still active on IF %x\n",
				pStructName,
				pStruct,
				pTimerToCheck,
				pInterface);

			DbgBreakPoint();
		}

		AA_STRUCT_ASSERT(pInterface, aai);

		AA_ACQUIRE_IF_TIMER_LOCK(pInterface);

		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &pInterface->TimerList[i];

			for (j = 0; j < pTimerList->TimerListSize; j++)
			{
				for (pTimer = pTimerList->pTimers[j].pNextTimer;
					 pTimer != NULL_PATMARP_TIMER;
					 pTimer = pTimer->pNextTimer)
				{
					if (pTimer == pTimerToCheck)
					{
						DbgPrint("ATMARPC: %s at %x contains timer %x still active on IF %x, Head of list %x\n",
							pStructName,
							pStruct,
							pTimerToCheck,
							pInterface,
							&pTimerList->pTimers[j]);
						DbgBreakPoint();
					}
				}
			}
		}

		AA_RELEASE_IF_TIMER_LOCK(pInterface);
		break;
	}
	while (FALSE);

}



PATMARP_VC
AtmArpAllocateVc(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an ATMARP VC structure, initialize it, and return it.

Arguments:

	pInterface		- Interface for which this VC is created.

Return Value:

	Pointer to VC if allocated, NULL otherwise.

--*/
{
	PATMARP_VC			pVc;

	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ALLOC_MEM(pVc, ATMARP_VC, sizeof(ATMARP_VC));

	if (pVc != NULL_PATMARP_VC)
	{
		AA_SET_MEM(pVc, 0, sizeof(ATMARP_VC));
#if DBG
		pVc->avc_sig = avc_signature;
#endif // DBG
		pVc->pInterface = pInterface;
		AA_INIT_VC_LOCK(pVc);
	}

	AADEBUGP(AAD_LOUD, ("Allocated Vc 0x%x\n", pVc));

	return (pVc);
}



VOID
AtmArpDeallocateVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Deallocate an ATMARP VC structure. It is assumed that all references
	to this VC have gone, so there is no need to acquire a lock to the VC.

Arguments:

	pVc			- Pointer to the VC to be deallocated

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(pVc->RefCount == 0);
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pVc->Timer));

	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pVc->Timer, pVc->pInterface, pVc, "VC");

#if DBG
	pVc->avc_sig++;
#endif
	AA_FREE_VC_LOCK(pVc);
	AA_FREE_MEM(pVc);

	AADEBUGP(AAD_LOUD, ("Deallocated Vc 0x%x\n", pVc));

}




VOID
AtmArpReferenceVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Add a reference to the specified ATMARP VC.
	NOTE: The caller is assumed to possess a lock for the VC.

Arguments:

	pVc			- Pointer to the VC to be referenced

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pVc, avc);

	pVc->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referencing Vc 0x%x, new count %d\n",
			 pVc, pVc->RefCount));
}




ULONG
AtmArpDereferenceVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Subtract a reference from the specified ATMARP VC. If the VC's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the VC.
	SIDE EFFECT: See Return Value below

Arguments:

	pVc			- Pointer to the VC to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the VC's reference count became zero, the VC will be
	deallocated -- the VC lock is, obviously, released in this case.

--*/
{
	ULONG		rv;
	NDIS_HANDLE	NdisVcHandle;
	BOOLEAN		bVcOwnerIsAtmArp;
	NDIS_STATUS	Status;

	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(pVc->RefCount > 0);

	rv = --(pVc->RefCount);
	if (rv == 0)
	{
#ifdef VC_REFS_ON_SENDS
		NdisVcHandle = pVc->NdisVcHandle;
		bVcOwnerIsAtmArp = AA_IS_FLAG_SET(pVc->Flags,
										  AA_VC_OWNER_MASK,
										  AA_VC_OWNER_IS_ATMARP);
#endif // VC_REFS_ON_SENDS

		AA_RELEASE_VC_LOCK(pVc);
		AtmArpDeallocateVc(pVc);

#ifdef VC_REFS_ON_SENDS
		if ((NdisVcHandle != NULL) &&
			(bVcOwnerIsAtmArp))
		{
			Status = NdisCoDeleteVc(NdisVcHandle);
			AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
			AADEBUGP(AAD_LOUD, ("DereferenceVc 0x%x, deleted NdisVcHandle 0x%x\n",
							pVc, NdisVcHandle));
		}
#endif // VC_REFS_ON_SENDS
	}

	AADEBUGP(AAD_VERY_LOUD, ("Dereference Vc 0x%x, New RefCount %d\n", pVc, rv));

	return (rv);
}




PATMARP_ATM_ENTRY
AtmArpAllocateAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsMulticast
)
/*++

Routine Description:

	Allocate an ATM Entry structure, initialize it, and return it.

Arguments:

	pInterface		- Pointer to ATMARP interface on which the entry is allocated
	IsMulticast		- Is this a Multicast entry?

Return Value:

	Pointer to allocated ATM Entry structure if successful, NULL otherwise.

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	ULONG						Size;

	AA_STRUCT_ASSERT(pInterface, aai);

	Size = sizeof(ATMARP_ATM_ENTRY)
#ifdef IPMCAST
			 	+ (IsMulticast? sizeof(ATMARP_IPMC_ATM_INFO): 0);
#else
				;
#endif

	AA_ALLOC_MEM(pAtmEntry, ATMARP_ATM_ENTRY, Size);
	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AA_SET_MEM(pAtmEntry, 0, Size);
#if DBG
		pAtmEntry->aae_sig = aae_signature;
#endif
		pAtmEntry->Flags = AA_ATM_ENTRY_IDLE;
#ifdef IPMCAST
		if (IsMulticast)
		{
			pAtmEntry->Flags |= AA_ATM_ENTRY_TYPE_NUCAST;
			pAtmEntry->pMcAtmInfo = (PATMARP_IPMC_ATM_INFO)
										((PUCHAR)pAtmEntry + sizeof(ATMARP_ATM_ENTRY));
		}
#endif // IPMCAST
		AA_INIT_AE_LOCK(pAtmEntry);
		pAtmEntry->pInterface = pInterface;

	}

	AADEBUGP(AAD_INFO, ("Allocated ATM Entry: IF 0x%x, Entry 0x%x\n",
				pInterface, pAtmEntry));

	return (pAtmEntry);
}



VOID
AtmArpDeallocateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Free an ATMARP ATM Entry structure. It is assumed that all references
	to the structure have gone. We don't need any locks here.

Arguments:

	pAtmEntry		- Pointer to ATMARP ATM Entry to be freed.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pAtmEntry, aae);
	AA_ASSERT(pAtmEntry->RefCount == 0);
	AA_ASSERT(pAtmEntry->pVcList == NULL_PATMARP_VC);
	AA_ASSERT(!AA_AE_IS_ALIVE(pAtmEntry));


#if DBG
	pAtmEntry->aae_sig++;
#endif

	AA_FREE_AE_LOCK(pAtmEntry);
	AA_FREE_MEM(pAtmEntry);

	AADEBUGP(AAD_INFO, ("Deallocated ATM Entry: 0x%x\n", pAtmEntry));
}




VOID
AtmArpReferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Add a reference to the specified ATMARP Entry.
	NOTE: The caller is assumed to possess a lock for the Entry.

Arguments:

	pAtmEntry			- Pointer to the Entry to be referenced

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	pAtmEntry->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referencing AtmEntry 0x%x, new count %d\n",
			 pAtmEntry, pAtmEntry->RefCount));
}




ULONG
AtmArpDereferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Subtract a reference from the specified ATM Entry. If the Entry's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the Entry.
	SIDE EFFECT: See Return Value below

Arguments:

	pAtmEntry			- Pointer to the Entry to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the Entry's reference count became zero, the Entry will be
	deallocated -- the Entry lock is, obviously, released in this case.

--*/
{
	ULONG					rc;
	PATMARP_INTERFACE		pInterface;

	AA_STRUCT_ASSERT(pAtmEntry, aae);
	AA_ASSERT(pAtmEntry->RefCount > 0);

	rc = --(pAtmEntry->RefCount);
	if (rc == 0)
	{
		PATMARP_ATM_ENTRY *	ppAtmEntry;

		//
		// We are most likely going to delete this entry...
		//
		// We must observe the protocol of 1st locking the list lock then
		// the pAtmEntry's lock, so this requires us to do the
		// release/lock/lock sequence below.
		//
		// Temporarly addref it again, to make sure that when we
		// release the lock below someone else doesn't get confused.
		//
		pAtmEntry->RefCount++;

		pInterface = pAtmEntry->pInterface;
		AA_STRUCT_ASSERT(pInterface, aai);
		AA_RELEASE_AE_LOCK(pAtmEntry);

		//
		// No locks held at this time!
		//

		//
		// Acquire locks in the correct order...
		//
		AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		AA_ASSERT(pAtmEntry->RefCount > 0);
		rc = --(pAtmEntry->RefCount);

		//
		// We can't assume that the ref count is still zero -- in principle
		// someone may have addrefd this pAtmEntry while both locks
		// were released above...
		//
		if (rc == 0)
		{
			//
			//  Unlink this entry from the Interface's list of ATM Entries.
			//

			ppAtmEntry = &(pInterface->pAtmEntryList);
			while (*ppAtmEntry != pAtmEntry)
			{
				AA_ASSERT(*ppAtmEntry != NULL_PATMARP_ATM_ENTRY);
				ppAtmEntry = &((*ppAtmEntry)->pNext);
			}
	
			*ppAtmEntry = pAtmEntry->pNext;

			//
			// Set state back to idle -- AtmArpDeallocate checks this...
			//
			AA_SET_FLAG(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_IDLE
				);
		}
		AA_RELEASE_AE_LOCK(pAtmEntry);
		AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

		if (rc == 0)
		{
			AtmArpDeallocateAtmEntry(pAtmEntry);
		}
		else
		{
			//
			// Caller expects to still hold the lock on pAtmEntry!
			// if we return nonzero rc ...
			// We can't simply re-acquire the lock because the caller expects
			// the that lock was never released.
			// So, since the ref count had gone to zero, as far as the caller
			// is concerned this structure has gone away and so we lie
			// and return 0 here...
			//
			rc = 0;
		}
	}

	AADEBUGP(AAD_VERY_LOUD,
		 ("Dereference AtmEntry 0x%x, New RefCount %d\n", pAtmEntry, rc));

	return (rc);
}



PATMARP_IP_ENTRY
AtmArpAllocateIPEntry(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an ATMARP IP Entry structure, initialize it, and
	return it.

Arguments:

	pInterface		- Pointer to ATMARP Interface on which this IP
					  Entry is allocated.

Return Value:

	Pointer to allocated IP Entry structure if successful,
	NULL otherwise.

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;

	AA_ALLOC_MEM(pIpEntry, ATMARP_IP_ENTRY, sizeof(ATMARP_IP_ENTRY));

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_SET_MEM(pIpEntry, 0, sizeof(ATMARP_IP_ENTRY));
#if DBG
		pIpEntry->aip_sig = aip_signature;
#endif // DBG
		pIpEntry->pInterface = pInterface;
		pIpEntry->Flags = AA_IP_ENTRY_IDLE;
#ifdef IPMCAST
		pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;	// Init on allocation
#endif
		AA_INIT_IE_LOCK(pIpEntry);
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated IP Entry 0x%x\n", pIpEntry));
	return (pIpEntry);
}




VOID
AtmArpDeallocateIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Deallocate an ATMARP IP Entry. It is assumed that all references
	to this IP Entry have gone, so there is no need to acquire its
	lock.

Arguments:

	pIpEntry			- Pointer to the IP Entry to be deallocated.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pIpEntry, aip);
	AA_ASSERT(pIpEntry->RefCount == 0);
	AA_ASSERT(!AA_IE_IS_ALIVE(pIpEntry));
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pIpEntry->Timer));

	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pIpEntry->Timer, pIpEntry->pInterface, pIpEntry, "IP Entry");

#if DBG
	pIpEntry->aip_sig = ~(pIpEntry->aip_sig);
#endif // DBG

	AA_FREE_IE_LOCK(pIpEntry);
	AA_FREE_MEM(pIpEntry);

	AADEBUGP(AAD_LOUD, ("Deallocated IP Entry 0x%x\n", pIpEntry));

}




VOID
AtmArpReferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Add a reference to an ATMARP IP Entry.
	NOTE: The caller is assumed to possess a lock for the IP Entry.

Arguments:

	pIpEntry			- Pointer to an ATMARP IP Entry.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pIpEntry, aip);

	pIpEntry->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referenced IP Entry 0x%x, new count %d\n",
			pIpEntry, pIpEntry->RefCount));
}



ULONG
AtmArpDereferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Subtract a reference from an ATMARP IP Entry. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the IP Entry.
	See SIDE EFFECT below.

Arguments:

	pIpEntry			- Pointer to ATMARP IP Entry

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the IP Entry lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;

	AA_STRUCT_ASSERT(pIpEntry, aip);

	rc = --(pIpEntry->RefCount);

	if (rc == 0)
	{
		AA_RELEASE_IE_LOCK(pIpEntry);
		AtmArpDeallocateIPEntry(pIpEntry);
	}

	AADEBUGP(AAD_VERY_LOUD, ("Dereference IP Entry 0x%x: new count %d\n",
			pIpEntry, rc));

	return (rc);
}




PATMARP_INTERFACE
AtmArpAllocateInterface(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Allocate an ATMARP interface structure, initialize it, link it to
	the given adapter structure, and return it.

Arguments:

	None.

Return Value:

	Pointer to ATMARP interface structure, if successful, else NULL.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_IP_ENTRY *		pArpTable;
	PATMARP_TIMER_LIST		pTimerList;
	NDIS_STATUS				Status;
	PCO_SAP					pIfSap;
	ULONG					SapSize;
	PWSTR					pIPConfigBuffer;
	USHORT					ConfigBufferSize;
	INT						i;

	//
	//  Initialize
	//
	Status = NDIS_STATUS_SUCCESS;
	pInterface = NULL_PATMARP_INTERFACE;
	pArpTable = (PATMARP_IP_ENTRY *)NULL;
	pIfSap = (PCO_SAP)NULL;
	pIPConfigBuffer = (PWSTR)NULL;

	SapSize = sizeof(CO_SAP)+sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	ConfigBufferSize = MAX_IP_CONFIG_STRING_LEN * sizeof(WCHAR);

	do
	{
		//
		//  Allocate everything.
		//
		AA_ALLOC_MEM(pInterface, ATMARP_INTERFACE, sizeof(ATMARP_INTERFACE));
		AA_ALLOC_MEM(pArpTable, PATMARP_IP_ENTRY, ATMARP_TABLE_SIZE*sizeof(PATMARP_IP_ENTRY));
		AA_ALLOC_MEM(pIfSap, CO_SAP, SapSize);

		if ((pInterface == NULL_PATMARP_INTERFACE) ||
			(pArpTable == (PATMARP_IP_ENTRY *)NULL) ||
			(pIfSap == (PCO_SAP)NULL))
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Got (almost) everything allocated. Initialize the main IF structure
		//  first. IMPORTANT: Keep this SET_MEM right here! Otherwise, we will
		//  trash the timer list allocation coming right up.
		//
		AA_SET_MEM(pInterface, 0, sizeof(ATMARP_INTERFACE));

		//
		// Set up the Buffer pool quadword-aligned slist pointers.
		//
		{
			for (i=0;i<AA_HEADER_TYPE_MAX;i++)
			{
				//
				// Verify that HeaderBufList is 8-byte aligned...
				// (we fully expect it to be because HeaderBufList is of type
				// SLIST_HEADER which has longlong alignment) -- so that
				// if the INTERFACE structure in which it is embedded in is
				// 8-byte aligned, so will  HeaderBufList...).
				//
				ASSERT((((ULONG_PTR)&(pInterface->HeaderPool[i].HeaderBufList))
						& 0x7) == 0);

				//
				// Spec says you gotta init it...
				//
				AA_INIT_SLIST(&(pInterface->HeaderPool[i].HeaderBufList));
			}
		}

		//
		//  Allocate timer structures
		//
		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &(pInterface->TimerList[i]);
#if DBG
			pTimerList->atl_sig = atl_signature;
#endif // DBG
			AA_ALLOC_MEM(
					pTimerList->pTimers,
					ATMARP_TIMER, 
					sizeof(ATMARP_TIMER) * AtmArpTimerListSize[i]
					);
			if (pTimerList->pTimers == NULL_PATMARP_TIMER)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
		
		//
		//  Continue initializing the IF structure.
		//
#if DBG
		//
		//  Signatures, for debugging.
		//
		pInterface->aai_sig =  aai_signature;
		pInterface->aaim_sig = aaim_signature;
		pInterface->aaia_sig = aaia_signature;
		pInterface->aait_sig =  aait_signature;
		pInterface->aaio_sig = aaio_signature;
		pInterface->aaic_sig = aaic_signature;

		pInterface->SapList.aas_sig = aas_signature;
#if ATMARP_WMI
		pInterface->aaiw_sig = aaiw_signature;
#endif
#endif // DBG


		//
		//  Initialize state fields.
		//
		pInterface->AdminState = IF_STATUS_DOWN;
		pInterface->State = IF_STATUS_DOWN;
		pInterface->LastChangeTime = GetTimeTicks();
		pInterface->ReconfigState = RECONFIG_NOT_IN_PROGRESS;

		//
		//  Initialize IP interface fields.
		//
		pInterface->BroadcastMask = 0;
		pInterface->BroadcastAddress = IP_LOCAL_BCST;
#ifndef OLD_ENTITY_LIST
		pInterface->ATInstance = INVALID_ENTITY_INSTANCE;
		pInterface->IFInstance = INVALID_ENTITY_INSTANCE;
#endif // OLD_ENTITY_LIST

		//
		//  Initialize spinlocks.
		//
		AA_INIT_IF_LOCK(pInterface);
		AA_INIT_IF_TABLE_LOCK(pInterface);
		AA_INIT_IF_ATM_LIST_LOCK(pInterface);
		AA_INIT_IF_TIMER_LOCK(pInterface);
		AA_INIT_BLOCK_STRUCT(&(pInterface->Block));
		NdisAllocateSpinLock(&(pInterface->BufferLock));

		//
		// Initialize list and table status
		//
		pInterface->AtmEntryListUp 	= TRUE;
		pInterface->ArpTableUp 		= TRUE;

		//
		//  Initialize timer wheels.
		//
		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &(pInterface->TimerList[i]);
			AA_SET_MEM(
				pTimerList->pTimers,
				0,
				sizeof(ATMARP_TIMER) * AtmArpTimerListSize[i]
				);
			pTimerList->MaxTimer = AtmArpMaxTimerValue[i];
			pTimerList->TimerPeriod = AtmArpTimerPeriod[i];
			pTimerList->ListContext = (PVOID)pInterface;
			pTimerList->TimerListSize = AtmArpTimerListSize[i];

			AA_INIT_SYSTEM_TIMER(
						&(pTimerList->NdisTimer),
						AtmArpTickHandler,
						(PVOID)pTimerList
						);
		}


		//
		//  Initialize all sub-components.
		//
		AA_SET_MEM(pArpTable, 0, ATMARP_TABLE_SIZE*sizeof(PATMARP_IP_ENTRY));
		AA_SET_MEM(pIfSap, 0, SapSize);

		//
		//  Link all sub-components to the Interface structure.
		//
		pInterface->pArpTable = pArpTable;
		pInterface->SapList.pInfo = pIfSap;

		//
		//  Link the Interface to the Adapter.
		//
		pInterface->pAdapter = pAdapter;
		pInterface->pNextInterface = pAdapter->pInterfaceList;
		pAdapter->pInterfaceList = pInterface;

		//
		//  Cache the adapter handle.
		//
		pInterface->NdisAdapterHandle = pAdapter->NdisAdapterHandle;


		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);


	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Failed to allocate atleast one component. Free the other(s).
		//
		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			for (i = 0; i < AAT_CLASS_MAX; i++)
			{
				pTimerList = &(pInterface->TimerList[i]);
	
				if (pTimerList->pTimers != NULL_PATMARP_TIMER)
				{
					AA_FREE_MEM(pTimerList->pTimers);
					pTimerList->pTimers = NULL_PATMARP_TIMER;
				}
			}
	
			AA_FREE_MEM(pInterface);
			pInterface = NULL_PATMARP_INTERFACE;	// return value
		}

		if (pArpTable != (PATMARP_IP_ENTRY *)NULL)
		{
			AA_FREE_MEM(pArpTable);
		}

		if (pIfSap != (PCO_SAP)NULL)
		{
			AA_FREE_MEM(pIfSap);
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated ATMARP Interface 0x%x\n", pInterface));

	return (pInterface);

}




VOID
AtmArpDeallocateInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deallocate an ATMARP Interface structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also delink this from the adapter structure it's linked to.

Arguments:

	pInterface		- Pointer to Interface structure to be deallocated.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE	*	ppInterface;
	PATMARP_ADAPTER			pAdapter;
	PATMARP_SAP				pAtmArpSap;
	PIP_ADDRESS_ENTRY		pIpEntry;
	PATMARP_SERVER_ENTRY	pServerEntry;
	PPROXY_ARP_ENTRY		pProxyEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_VC				pVc;
	INT						i;

	PVOID					pNext;		// Catch-all for all list traversals

	AA_STRUCT_ASSERT(pInterface, aai);
	AA_ASSERT(pInterface->RefCount == 0);

	AADEBUGP(AAD_INFO, ("Deallocate Interface 0x%x\n", pInterface));

#if DBG
	pInterface->aai_sig =  ~(pInterface->aai_sig);
#endif // DBG

	//
	//  Unlink from Adapter structure
	//
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	pAdapter = pInterface->pAdapter;
	if (pAdapter != NULL_PATMARP_ADAPTER)
	{
		ppInterface = &(pAdapter->pInterfaceList);
		while (*ppInterface != NULL_PATMARP_INTERFACE)
		{
			if (*ppInterface == pInterface)
			{
				*ppInterface = pInterface->pNextInterface;
				break;
			}
			else
			{
				ppInterface = &((*ppInterface)->pNextInterface);
			}
		}
	}
	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Free all subcomponents
	//

	//
	//  ARP Table
	//
	if (pInterface->pArpTable != (PATMARP_IP_ENTRY *)NULL)
	{
		AA_FREE_MEM(pInterface->pArpTable);
		pInterface->pArpTable = (PATMARP_IP_ENTRY *)NULL;
	}

	//
	//  Local SAP list
	//
	for (pAtmArpSap = pInterface->SapList.pNextSap;
		 pAtmArpSap != NULL_PATMARP_SAP;
		 pAtmArpSap = (PATMARP_SAP)pNext)
	{
		pNext = (PVOID)(pAtmArpSap->pNextSap);
		if (pAtmArpSap->pInfo != (PCO_SAP)NULL)
		{
			AA_FREE_MEM(pAtmArpSap->pInfo);
		}
		AA_FREE_MEM(pAtmArpSap);
	}
	if (pInterface->SapList.pInfo != (PCO_SAP)NULL)
	{
		AA_FREE_MEM(pInterface->SapList.pInfo);
	}
	pInterface->SapList.pNextSap = NULL_PATMARP_SAP;


	//
	//  List of local IP addresses
	//
	for (pIpEntry = pInterface->LocalIPAddress.pNext;
		 pIpEntry != (PIP_ADDRESS_ENTRY)NULL;
		 pIpEntry = (PIP_ADDRESS_ENTRY)pNext)
	{
		pNext = (PVOID)pIpEntry->pNext;
		AA_FREE_MEM(pIpEntry);
	}


	//
	//  List of proxy ARP addresses
	//
	for (pProxyEntry = pInterface->pProxyList;
		 pProxyEntry != (PPROXY_ARP_ENTRY)NULL;
		 pProxyEntry = (PPROXY_ARP_ENTRY)pNext)
	{
		pNext = (PVOID)pProxyEntry->pNext;
		AA_FREE_MEM(pProxyEntry);
	}
	pInterface->pProxyList = (PPROXY_ARP_ENTRY)NULL;

	//
	//  List of ARP Server addresses
	//
	for (pServerEntry = pInterface->ArpServerList.pList;
		 pServerEntry != NULL_PATMARP_SERVER_ENTRY;
		 pServerEntry = (PATMARP_SERVER_ENTRY)pNext)
	{
		pNext = (PVOID)pServerEntry->pNext;
		AA_FREE_MEM(pServerEntry);
	}
	pInterface->ArpServerList.pList = NULL_PATMARP_SERVER_ENTRY;

#ifdef IPMCAST
	//
	//  List of MARS Server addresses
	//
	for (pServerEntry = pInterface->MARSList.pList;
		 pServerEntry != NULL_PATMARP_SERVER_ENTRY;
		 pServerEntry = (PATMARP_SERVER_ENTRY)pNext)
	{
		pNext = (PVOID)pServerEntry->pNext;
		AA_FREE_MEM(pServerEntry);
	}
	pInterface->MARSList.pList = NULL_PATMARP_SERVER_ENTRY;
#endif // IPMCAST

	//
	//  ARP Table
	//
	if (pInterface->pArpTable != (PATMARP_IP_ENTRY *)NULL)
	{
		AA_FREE_MEM(pInterface->pArpTable);
		pInterface->pArpTable = (PATMARP_IP_ENTRY *)NULL;
	}

	//
	//  ATM Entry List
	//
	for (pAtmEntry = pInterface->pAtmEntryList;
		 pAtmEntry != NULL_PATMARP_ATM_ENTRY;
		 pAtmEntry = (PATMARP_ATM_ENTRY)pNext)
	{
		pNext = (PVOID)pAtmEntry->pNext;
		AA_FREE_MEM(pAtmEntry);
	}
	pInterface->pAtmEntryList = NULL_PATMARP_ATM_ENTRY;

	//
	//  Unresolved VC list
	//
	for (pVc = pInterface->pUnresolvedVcs;
		 pVc != NULL_PATMARP_VC;
		 pVc = (PATMARP_VC)pNext)
	{
		pNext = (PVOID)pVc->pNextVc;
		AA_FREE_MEM(pVc);
	}
	pInterface->pUnresolvedVcs = (PATMARP_VC)NULL;

	//
	//  Timers
	//
	for (i = 0; i < AAT_CLASS_MAX; i++)
	{
		PATMARP_TIMER_LIST	pTimerList = &(pInterface->TimerList[i]);

		if (pTimerList->pTimers != NULL_PATMARP_TIMER)
		{
			AA_FREE_MEM(pTimerList->pTimers);
			pTimerList->pTimers = NULL_PATMARP_TIMER;
		}
	}

	//
	//  ProtocolPacketPool
	//  ProtocolBufferPool
	//  ProtocolBufList
	//
	AtmArpDeallocateProtoBuffers(pInterface);

	//
	//  HeaderBufList
	//  pHeaderTrkList
	//
	AtmArpDeallocateHeaderBuffers(pInterface);

	//
	//  Free all Interface locks.
	//
	AA_FREE_IF_LOCK(pInterface);
	AA_FREE_IF_TABLE_LOCK(pInterface);
	AA_FREE_IF_ATM_LIST_LOCK(pInterface);
	AA_FREE_IF_TIMER_LOCK(pInterface);
	AA_FREE_BLOCK_STRUCT(&(pInterface->Block));
	NdisFreeSpinLock(&(pInterface->BufferLock));

	//
	//  Free the Interface structure now
	//
	AA_FREE_MEM(pInterface);

	//
	//  If we just freed the last Interface structure on this
	//  adapter, and an Unbind operation was in progress, complete
	//  it now.
	//
	if ((pAdapter->pInterfaceList == NULL_PATMARP_INTERFACE) &&
		(pAdapter->Flags & AA_ADAPTER_FLAGS_UNBINDING))
	{
		AtmArpCompleteUnbindAdapter(pAdapter);
	}
}




VOID
AtmArpReferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Add a reference to an Interface structure.
	NOTE: The caller is assumed to possess a lock for the interface
	structure.

Arguments:

	pInterface		- Pointer to the ATMARP interface

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pInterface, aai);

	pInterface->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Reference Interface 0x%x, new count %d\n",
			pInterface, pInterface->RefCount));
}




ULONG
AtmArpDereferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Subtract a reference from an ATMARP Interface. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the Interface
	structure. See SIDE EFFECT below.

Arguments:

	pInterface		- Pointer to the ATMARP interface

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the Interface lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;

	AA_STRUCT_ASSERT(pInterface, aai);
	AA_ASSERT(pInterface->RefCount > 0);

	rc = --(pInterface->RefCount);

	AADEBUGP(AAD_VERY_LOUD, ("Dereference Interface 0x%x, new count %d\n",
			pInterface, rc));

	if (rc == 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
		AtmArpDeallocateInterface(pInterface);
	}


	return (rc);
}



VOID
AtmArpReferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
)
/*++

Routine Description:

	Add a reference to a Join Entry.

Arguments:

	pJoinEntry		- Pointer to Join Entry

Return Value:

	None

--*/
{
	NdisInterlockedIncrement(&pJoinEntry->RefCount);
}


ULONG
AtmArpDereferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
)
/*++

Routine Description:

	Decrements the ref count on a Join Entry. If it goes down to zero,
	deallocates it.

Arguments:

	pJoinEntry		- Pointer to the Join Entry

Return Value:

	The final ref count

--*/
{
	ULONG		rc;

	rc = NdisInterlockedDecrement(&pJoinEntry->RefCount);

	if (rc == 0)
	{
		AA_CHECK_TIMER_IN_ACTIVE_LIST(&pJoinEntry->Timer, pJoinEntry->pInterface, pJoinEntry, "Join Entry");
		AA_FREE_MEM(pJoinEntry);
	}

	return (rc);
}


VOID
AtmArpStartTimer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_TIMER				pTimer,
	IN	ATMARP_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						Context
)
/*++

Routine Description:

	Start an ATMARP timer. Based on the length (SecondsToGo) of the
	timer, we decide on whether to insert it in the short duration
	timer list or in the long duration timer list in the Interface
	structure.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

Arguments:

	pInterface		- Pointer to the ATMARP Interface
	pTimer			- Pointer to ATMARP Timer structure
	TimeoutHandler	- Handler function to be called if this timer expires
	SecondsToGo		- When does this timer go off?
	Context			- To be passed to timeout handler if this timer expires

Return Value:

	None

--*/
{
	PATMARP_TIMER_LIST	pTimerList;		// List to which this timer goes
	PATMARP_TIMER		pTimerListHead; // Head of above list
	ULONG				Index;			// Into timer wheel
	ULONG				TicksToGo;
	INT					i;

	AA_STRUCT_ASSERT(pInterface, aai);


 	AADEBUGP(AAD_EXTRA_LOUD,
 	 ("StartTimer: pIf 0x%x, Secs %d, Handler 0x%x, Ctxt 0x%x, pTimer 0x%x\n",
 	 			pInterface, SecondsToGo, TimeoutHandler, Context, pTimer));


	if (AA_IS_TIMER_ACTIVE(pTimer))
	{
		AADEBUGP(AAD_ERROR,
			("Start timer: pTimer 0x%x: is active (list 0x%x, hnd 0x%x), stopping it\n",
				pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));

		AtmArpStopTimer(pTimer, pInterface);
	}

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(pTimer));

	//
	//  Find the list to which this timer should go, and the
	//  offset (TicksToGo)
	//
	for (i = 0; i < AAT_CLASS_MAX; i++)
	{
		pTimerList = &(pInterface->TimerList[i]);
		if (SecondsToGo < pTimerList->MaxTimer)
		{
			//
			//  Found it.
			//
			TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
			break;
		}
	}
	
	AA_ASSERT(i < AAT_CLASS_MAX);

	AA_VALIDATE_TIMER_LIST(pTimerList);
	//
	//  Find the position in the list for this timer
	//
	Index = pTimerList->CurrentTick + TicksToGo;
	if (Index >= pTimerList->TimerListSize)
	{
		Index -= pTimerList->TimerListSize;
	}
	AA_ASSERT(Index < pTimerList->TimerListSize);

	pTimerListHead = &(pTimerList->pTimers[Index]);

	//
	//  Fill in the timer
	//
	pTimer->pTimerList = pTimerList;
	pTimer->LastRefreshTime = pTimerList->CurrentTick;
	pTimer->Duration = TicksToGo;
	pTimer->TimeoutHandler = TimeoutHandler;
	pTimer->Context = Context;
	pTimer->State = ATMARP_TIMER_STATE_RUNNING;
 
 	//
 	//  Insert this timer in the "ticking" list
 	//
 	pTimer->pPrevTimer = pTimerListHead;
 	pTimer->pNextTimer = pTimerListHead->pNextTimer;
 	if (pTimer->pNextTimer != NULL_PATMARP_TIMER)
 	{
 		pTimer->pNextTimer->pPrevTimer = pTimer;
 	}
 	pTimerListHead->pNextTimer = pTimer;

	//
	//  Start off the system tick timer if necessary.
	//
	pTimerList->TimerCount++;
	if (pTimerList->TimerCount == 1)
	{
		AADEBUGP(AAD_LOUD,
			 ("StartTimer: Starting system timer 0x%x, class %d on IF 0x%x\n",
					&(pTimerList->NdisTimer), i, pInterface));

		AA_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
	}
	AA_VALIDATE_TIMER_LIST(pTimerList);
	AA_VALIDATE_TIMER(pTimerList, pTimer);

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	//
	//  We're done
	//
	AADEBUGP(AAD_LOUD,
		 ("Started timer 0x%x, IF 0x%x, Secs %d, Index %d, Head 0x%x\n",
				pTimer,
				pInterface,
				SecondsToGo,
				Index,
				pTimerListHead));

	return;
}




BOOLEAN
AtmArpStopTimer(
	IN	PATMARP_TIMER				pTimer,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Stop an ATMARP timer, if it is running. We remove this timer from
	the active timer list and mark it so that we know it's not running.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

	SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
	the Interface, we also stop the appropriate Tick function.

Arguments:

	pTimer			- Pointer to ATMARP Timer structure
	pInterface		- Pointer to interface to which the timer belongs

Return Value:

	TRUE if the timer was running, FALSE otherwise.

--*/
{
	PATMARP_TIMER_LIST	pTimerList;			// Timer List to which this timer belongs
	BOOLEAN				WasRunning;

	AADEBUGP(AAD_LOUD,
		 ("Stopping Timer 0x%x, IF 0x%x, List 0x%x, Prev 0x%x, Next 0x%x\n",
					pTimer,
					pInterface,
					pTimer->pTimerList,
					pTimer->pPrevTimer,
					pTimer->pNextTimer));

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);


	if (AA_IS_TIMER_ACTIVE(pTimer))
	{
		WasRunning = TRUE;

		AA_VALIDATE_TIMER_LIST(pTimer->pTimerList);
		AA_VALIDATE_TIMER(NULL, pTimer);

		//
		//  Unlink timer from the list
		//
		AA_ASSERT(pTimer->pPrevTimer);	// the list head always exists

		pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
		if (pTimer->pNextTimer)
		{
			pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
		}

		pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PATMARP_TIMER;

		//
		//  Update timer count on Interface, for this class of timers
		//
		pTimerList = pTimer->pTimerList;
		pTimerList->TimerCount--;

		//
		//  If all timers of this class are gone, stop the system tick timer
		//  for this class
		//
		if (pTimerList->TimerCount == 0)
		{
			AADEBUGP(AAD_LOUD, ("Stopping system timer 0x%x, List 0x%x, IF 0x%x\n",
						&(pTimerList->NdisTimer),
						pTimerList,
						pInterface));

			pTimerList->CurrentTick = 0;
			AA_STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
		}

		//
		//  Mark stopped timer as not active
		//
		pTimer->pTimerList = (PATMARP_TIMER_LIST)NULL;

		pTimer->State = ATMARP_TIMER_STATE_IDLE;

		AA_VALIDATE_TIMER_LIST(pTimerList);

	}
	else
	{
		WasRunning = FALSE;
	}

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	return (WasRunning);
}




#ifdef NO_TIMER_MACRO

VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER				pTimer
)
/*++

Routine Description:

	Refresh a timer that is already running.

	NOTE: The caller is assumed to possess a lock protecting the
	timer structure (i.e. to the structure containing the timer).

	NOTE: We don't acquire the IF Timer Lock here, to optimize
	the refresh operation. So, _within_ the confines of this routine,
	the tick handler may fire, and expire this timer. The only care
	that we take here is to make sure that we don't crash if the
	timer expires while we access the Timer list.

Arguments:

	pTimer		- Pointer to ATMARP_TIMER structure

Return Value:

	None

--*/
{
	PATMARP_TIMER_LIST	pTimerList;

	if ((pTimerList = pTimer->pTimerList) != (PATMARP_TIMER_LIST)NULL)
	{
		pTimer->LastRefreshTime = pTimerList->CurrentTick;
	}
	else
	{
		AADEBUGP(AAD_VERY_LOUD,
			 ("RefreshTimer: pTimer 0x%x not active: Hnd 0x%x, Cntxt 0x%x\n",
			 	pTimer,
			 	pTimer->TimeoutHandler,
			 	pTimer->Context
			 ));
	}

	AADEBUGP(AAD_LOUD,
		 ("Refreshed timer 0x%x, List 0x%x, hnd 0x%x, Cntxt 0x%x, LastRefresh %d\n",
				pTimer,
				pTimer->pTimerList,
				pTimer->TimeoutHandler,
				pTimer->Context,
				pTimer->LastRefreshTime));
}


#endif // NO_TIMER_MACRO


VOID
AtmArpTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
/*++

Routine Description:

	This is the handler we register with the system for processing each
	Timer List. This is called every "tick" seconds, where "tick" is
	determined by the granularity of the timer type.

Arguments:

	Context				- Actually a pointer to a Timer List structure
	SystemSpecific[1-3]	- Not used

Return Value:

	None

--*/
{

	PATMARP_INTERFACE		pInterface;
	PATMARP_TIMER_LIST		pTimerList;

	PATMARP_TIMER			pExpiredTimer;		// Start of list of expired timers
	PATMARP_TIMER			pNextTimer;			// for walking above list
	PATMARP_TIMER			pTimer;				// temp, for walking timer list
	PATMARP_TIMER			pPrevExpiredTimer;	// for creating expired timer list

	ULONG					Index;			// into the timer wheel
	ULONG					NewIndex;		// for refreshed timers


	pTimerList = (PATMARP_TIMER_LIST)Context;
	AA_STRUCT_ASSERT(pTimerList, atl);

	pInterface = (PATMARP_INTERFACE)pTimerList->ListContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_VERY_LOUD, ("Tick: pIf 0x%x, List 0x%x, Count %d\n",
				pInterface, pTimerList, pTimerList->TimerCount));

	pExpiredTimer = NULL_PATMARP_TIMER;

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);

	AA_VALIDATE_TIMER_LIST(pTimerList);

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Pick up the list of timers scheduled to have expired at the
		//  current tick. Some of these might have been refreshed.
		//
		Index = pTimerList->CurrentTick;
		pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
		(pTimerList->pTimers[Index]).pNextTimer = NULL_PATMARP_TIMER;

		//
		//  Go through the list of timers scheduled to expire at this tick.
		//  Prepare a list of expired timers, using the pNextExpiredTimer
		//  link to chain them together.
		//
		//  Some timers may have been refreshed, in which case we reinsert
		//  them in the active timer list.
		//
		pPrevExpiredTimer = NULL_PATMARP_TIMER;

		for (pTimer = pExpiredTimer;
			 pTimer != NULL_PATMARP_TIMER;
			 pTimer = pNextTimer)
		{
			//
			// Save a pointer to the next timer, for the next iteration.
			//
			pNextTimer = pTimer->pNextTimer;

			AADEBUGP(AAD_EXTRA_LOUD, 
				("Tick Handler: pIf 0x%x, looking at timer 0x%x, next 0x%x\n",
					pInterface, pTimer, pNextTimer));

			//
			//  Find out when this timer should actually expire.
			//
			NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
			if (NewIndex >= pTimerList->TimerListSize)
			{
				NewIndex -= pTimerList->TimerListSize;
			}

			//
			//  Check if we are currently at the point of expiry.
			//
			if (NewIndex != Index)
			{
				//
				//  This timer still has some way to go, so put it back.
				//
				AADEBUGP(AAD_LOUD,
				("Tick: Reinserting Timer 0x%x: Hnd 0x%x, Durn %d, Ind %d, NewInd %d\n",
					pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

				//
				//  Remove it from the expired timer list. Note that we only
				//  need to update the forward (pNextExpiredTimer) links.
				//
				if (pPrevExpiredTimer == NULL_PATMARP_TIMER)
				{
					pExpiredTimer = pNextTimer;
				}
				else
				{
					pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
				}

				//
				//  And insert it back into the running timer list.
				//
				pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
				if (pTimer->pNextTimer != NULL_PATMARP_TIMER)
				{
					pTimer->pNextTimer->pPrevTimer = pTimer;
				}
				pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
				(pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
			}
			else
			{
				//
				//  This one has expired. Keep it in the expired timer list.
				//
				pTimer->pNextExpiredTimer = pNextTimer;
				if (pPrevExpiredTimer == NULL_PATMARP_TIMER)
				{
					pExpiredTimer = pTimer;
				}
				pPrevExpiredTimer = pTimer;

				//
				//  Mark it as inactive.
				//
				AA_ASSERT(pTimer->pTimerList == pTimerList);
				pTimer->pTimerList = (PATMARP_TIMER_LIST)NULL;

				pTimer->State = ATMARP_TIMER_STATE_EXPIRING;

				//
				//  Update the active timer count.
				//
				pTimerList->TimerCount--;
			}
		}

		//
		//  Update current tick index in readiness for the next tick.
		//
		if (++Index == pTimerList->TimerListSize)
		{
			pTimerList->CurrentTick = 0;
		}
		else
		{
			pTimerList->CurrentTick = Index;
		}

		if (pTimerList->TimerCount > 0)
		{
			//
			//  Re-arm the tick handler
			//
			AADEBUGP(AAD_LOUD, ("Tick[%d]: Starting system timer 0x%x, on IF 0x%x\n",
						pTimerList->CurrentTick, &(pTimerList->NdisTimer), pInterface));
			
			AA_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
		}
		else
		{
			pTimerList->CurrentTick = 0;
		}

	}

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	//
	//  Now pExpiredTimer is a list of expired timers.
	//  Walk through the list and call the timeout handlers
	//  for each timer.
	//
	while (pExpiredTimer != NULL_PATMARP_TIMER)
	{
		pNextTimer = pExpiredTimer->pNextExpiredTimer;

		AADEBUGP(AAD_LOUD, ("Expired timer 0x%x: handler 0x%x, next 0x%x\n",
					pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

		pExpiredTimer->State = ATMARP_TIMER_STATE_EXPIRED;
		(*(pExpiredTimer->TimeoutHandler))(
				pExpiredTimer,
				pExpiredTimer->Context
			);

		pExpiredTimer = pNextTimer;
	}

}




PNDIS_PACKET
AtmArpAllocatePacket(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an NDIS packet for the specified Interface.
	Currently just a wrapper for the corresponding NDIS function.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure

Return Value:

	Pointer to NDIS packet if allocated, NULL otherwise.

--*/
{
	NDIS_STATUS				Status;
	PNDIS_PACKET			pNdisPacket;
	struct PacketContext	*PC;

	NdisAllocatePacket(
			&Status,
			&pNdisPacket,
			pInterface->ProtocolPacketPool
		);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
		PC->pc_common.pc_owner = PACKET_OWNER_LINK;
	}

	AADEBUGP(AAD_EXTRA_LOUD, ("Allocate Packet: IF 0x%x, Status 0x%x, Packet 0x%x\n",
				pInterface,
				Status,
				pNdisPacket));

	return (pNdisPacket);
}



VOID
AtmArpFreePacket(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pPacket
)
/*++

Routine Description:

	Deallocate an NDIS packet on the specified Interface.
	Currently just a wrapper around the corresponding NDIS function.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure
	pPacket			- Pointer to packet being freed.

Return Value:

	None

--*/
{
	NdisFreePacket(pPacket);

	AADEBUGP(AAD_EXTRA_LOUD, ("Free Packet: IF 0x%x, Packet 0x%x\n",
				pInterface,
				pPacket));
}




PNDIS_BUFFER
AtmArpGrowHeaders(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType
)
/*++

Routine Description:

	Allocate a bunch of header buffers on the specified ATMARP interface.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory that we break down into header buffers.
	These header buffers are then attached to NDIS Buffers before they are
	inserted into the list of free header buffers for this Interface.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure
	HdrType			- Unicast or Nonunicast

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMARP_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	AA_ASSERT(HdrType < AA_HEADER_TYPE_MAX);

	//
	//  Initialize
	//
	pTracker = NULL_PATMARP_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;


	NdisAcquireSpinLock(&pInterface->BufferLock);

	do
	{
		if (pInterface->HeaderPool[HdrType].CurHeaderBufs >= 
					pInterface->HeaderPool[HdrType].MaxHeaderBufs)
		{
			AADEBUGP(AAD_WARNING,
				("Grow Hdrs: IF 0x%x, Type %d, CurHdrBufs %d > MaxHdrBufs %d\n",
						pInterface,
						HdrType,
						pInterface->HeaderPool[HdrType].CurHeaderBufs,
						pInterface->HeaderPool[HdrType].MaxHeaderBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		AA_ALLOC_MEM(pTracker, ATMARP_BUFFER_TRACKER, sizeof(ATMARP_BUFFER_TRACKER));
		if (pTracker == NULL_PATMARP_BUFFER_TRACKER)
		{
			AADEBUGP(AAD_WARNING, ("Grow Hdrs: IF 0x%x, alloc failed for tracker\n",
					pInterface));
			break;
		}

		AA_SET_MEM(pTracker, 0, sizeof(ATMARP_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				AA_DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING,
				 ("Grow Hdrs: IF 0x%x, NdisAllocateBufferPool err status 0x%x\n",
					pInterface, Status));
			break;
		}

		//
		//  Allocate system space for a bunch of header buffers
		//
		AA_ALLOC_MEM(pTracker->pPoolStart, 
					 UCHAR,
					 pInterface->HeaderPool[HdrType].HeaderBufSize *
						 AA_DEF_HDRBUF_GROW_SIZE);

		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			AADEBUGP(AAD_WARNING,
				 ("Grow Hdrs: IF 0x%x, could not alloc buf space %d bytes\n",
					pInterface,
			 		pInterface->HeaderPool[HdrType].HeaderBufSize *
						 AA_DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free header buffer list. Retain one for returning
		//  to caller.
		//
		//  We also fill in the contents of the buffers right away, so
		//  that we don't have to prepare them afresh for each transmit.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < AA_DEF_HDRBUF_GROW_SIZE; i++)
		{
			if (HdrType == AA_HEADER_TYPE_UNICAST)
			{
				//
				//  Fill in the (Unicast) LLC/SNAP header
				//
				AA_COPY_MEM(pSpace,
							&AtmArpLlcSnapHeader,
							pInterface->HeaderPool[HdrType].HeaderBufSize);
			}
			else
			{
				AA_ASSERT(HdrType == AA_HEADER_TYPE_NUNICAST);
				//
				//  Fill in the (Multicast) Type 1 short form header
				//
#ifdef IPMCAST
				AA_COPY_MEM(pSpace,
							&AtmArpMcType1ShortHeader,
							pInterface->HeaderPool[HdrType].HeaderBufSize);
#else
				AA_ASSERT(FALSE);
#endif // IPMCAST
			}


			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pInterface->HeaderPool[HdrType].HeaderBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
					 ("Grow Hdrs: NdisAllocateBuffer failed: IF 0x%x, status 0x%x\n",
							pInterface, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
			pSpace += pInterface->HeaderPool[HdrType].HeaderBufSize;
		}

		if (i > 0)
		{
			//
			//  Successfully allocated atleast one more header buffer
			//
			pTracker->pNext = pInterface->HeaderPool[HdrType].pHeaderTrkList;
			pInterface->HeaderPool[HdrType].pHeaderTrkList = pTracker;
			pInterface->HeaderPool[HdrType].CurHeaderBufs += i;

			NdisReleaseSpinLock(&pInterface->BufferLock);

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		NdisReleaseSpinLock(&pInterface->BufferLock);

		if (pTracker != NULL_PATMARP_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				AA_FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			AA_FREE_MEM(pTracker);
		}
	}

	AADEBUGP(AAD_INFO, ("Grow ARP Headers: IF 0x%x, RetBuf 0x%x, New Tracker 0x%x\n",
				pInterface, pReturnBuffer, pTracker));

	return (pReturnBuffer);

}




PNDIS_BUFFER
AtmArpAllocateHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used as an LLC/SNAP header prepended
	to an IP packet. We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pInterface		- Pointer to ATMARP Interface
	HdrType			- Unicast or Nonunicast
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;
	PAA_SINGLE_LIST_ENTRY	pListEntry;

	pListEntry = AA_POP_FROM_SLIST(
						&(pInterface->HeaderPool[HdrType].HeaderBufList),
						&(pInterface->BufferLock.SpinLock)
					);
	if (pListEntry != NULL_PAA_SINGLE_LIST_ENTRY)
	{
		pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		*pBufferAddress = NdisBufferVirtualAddress(pNdisBuffer);
	}
	else
	{
		pNdisBuffer = AtmArpGrowHeaders(pInterface, HdrType);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
			AADEBUGP(AAD_INFO,
				("After growing hdrs: Type %d, returning pNdisBuf 0x%x, Start 0x%x, Len %d\n",
					HdrType, pNdisBuffer, *pBufferAddress, Length));
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated Header Buffer: 0x%x, IF: 0x%x\n",
					pNdisBuffer, pInterface));
	return (pNdisBuffer);
}




VOID
AtmArpFreeHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	AA_HEADER_TYPE				HdrType
)
/*++

Routine Description:

	Deallocate a header buffer.

Arguments:

	pInterface		- Pointer to ATMARP interface from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	HdrType			- Unicast or Nonunicast

Return Value:

	None

--*/
{
	AA_PUSH_TO_SLIST(
			&(pInterface->HeaderPool[HdrType].HeaderBufList),
			STRUCT_OF(AA_SINGLE_LIST_ENTRY, &(pNdisBuffer->Next), Next),
			&(pInterface->BufferLock.SpinLock)
		);

	AADEBUGP(AAD_VERY_LOUD, ("Freed Header Buffer: 0x%x, IF: 0x%x, HdrType %d\n",
					pNdisBuffer, pInterface, HdrType));
}



VOID
AtmArpDeallocateHeaderBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deallocate everything pertaining to header buffers on an Interface.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PAA_SINGLE_LIST_ENTRY		pListEntry;
	PATMARP_BUFFER_TRACKER		pTracker;
	PATMARP_BUFFER_TRACKER		pNextTracker;
	AA_HEADER_TYPE				HdrType;

	for (HdrType = 0; HdrType < AA_HEADER_TYPE_MAX; HdrType++)
	{
		//
		//  Free all NDIS buffers in the header buffer list.
		//
		do
		{
			pListEntry = AA_POP_FROM_SLIST(
								&(pInterface->HeaderPool[HdrType].HeaderBufList),
								&(pInterface->BufferLock.SpinLock)
							);
			if (pListEntry != NULL_PAA_SINGLE_LIST_ENTRY)
			{
				pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				NdisFreeBuffer(pNdisBuffer);
			}
			else
			{
				//
				//  No more NDIS buffers.
				//
				break;
			}
		}
		while (TRUE);

		//
		//  Now free all the buffer trackers.
		//
		pTracker = pInterface->HeaderPool[HdrType].pHeaderTrkList;

		while (pTracker != NULL_PATMARP_BUFFER_TRACKER)
		{
			pNextTracker = pTracker->pNext;
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				AA_FREE_MEM(pTracker->pPoolStart);
				pTracker->pPoolStart = (PUCHAR)NULL;
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
				pTracker->NdisHandle = (NDIS_HANDLE)NULL;
			}
			AA_FREE_MEM(pTracker);
			pTracker = pNextTracker;
		}

	} // for
}




PNDIS_BUFFER
AtmArpAllocateProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate a buffer to be used for an ATM ARP protocol message. Attach
	it to an NDIS_BUFFER structure and return a pointer to this.

Arguments:

	pInterface		- Pointer to ATMARP Interface
	Length			- Length, in bytes, of the buffer.
	pBufferAddress	- Place to return virtual address of allocated buffer.

Return Value:

	Pointer to NDIS Buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER		pNdisBuffer;
	NDIS_STATUS			Status;

	//
	//  Initialize
	//
	pNdisBuffer = NULL;

	AA_ASSERT(Length <= pInterface->ProtocolBufSize);

	NdisAcquireSpinLock(&pInterface->BufferLock);

	*pBufferAddress = pInterface->ProtocolBufList;
	if (*pBufferAddress != (PUCHAR)NULL)
	{
		NdisAllocateBuffer(
				&Status,
				&pNdisBuffer,
				pInterface->ProtocolBufferPool,
				*pBufferAddress,
				Length
			);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pInterface->ProtocolBufList = *((PUCHAR *)*pBufferAddress);
		}
	}

	NdisReleaseSpinLock(&pInterface->BufferLock);

	AADEBUGP(AAD_LOUD,
		("Allocated protocol buffer: IF 0x%x, pNdisBuffer 0x%x, Length %d, Loc 0x%x\n",
				pInterface, pNdisBuffer, Length, *pBufferAddress));

	return (pNdisBuffer);
}



VOID
AtmArpFreeProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer
)
/*++

Routine Description:

	Free an NDIS buffer (and associated memory) used for a protocol
	packet. We return the associated memory to the ProtocolBufList
	in the interface structure, and the NDIS buffer to NDIS.

Arguments:

	pInterface		- Pointer to ATMARP interface structure
	pNdisBuffer		- Pointer to NDIS buffer to be freed

Return Value:

	None

--*/
{
	PUCHAR *		pBufferLinkage;
	ULONG			Length;

	NdisQueryBuffer(pNdisBuffer, (PVOID)&pBufferLinkage, &Length);

	NdisAcquireSpinLock(&pInterface->BufferLock);

	*pBufferLinkage = pInterface->ProtocolBufList;
	pInterface->ProtocolBufList = (PUCHAR)pBufferLinkage;

	NdisReleaseSpinLock(&pInterface->BufferLock);

	NdisFreeBuffer(pNdisBuffer);

	AADEBUGP(AAD_LOUD, ("Freed Protocol Buf: IF 0x%x, pNdisBuffer 0x%x, Loc 0x%x\n",
			pInterface, pNdisBuffer, pBufferLinkage));

}



NDIS_STATUS
AtmArpInitProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Initialize the protocol buffer pool for an interface.

	Allocate a chunk of memory to be used for ATMARP protocol messages.
	We prepare a linked list of protocol buffers, and attach it to the
	Interface structure.

Arguments:

	pInterface		- Pointer to Interface on which we need to allocate
					  protocol buffers.
Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we run
	into a resource failure.

--*/
{
	NDIS_STATUS			Status;
	PUCHAR				pSpace;
	ULONG				i;

	do
	{
		NdisAllocatePacketPool(
				&Status,
				&(pInterface->ProtocolPacketPool),
				pInterface->MaxProtocolBufs,
				sizeof(struct PCCommon)
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(
				&Status,
				&(pInterface->ProtocolBufferPool),
				pInterface->MaxProtocolBufs
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a big chunk of system memory that we can divide up into
		//  protocol buffers.
		//
		AA_ALLOC_MEM(
				pInterface->ProtocolBufTracker,
				UCHAR,
				(pInterface->ProtocolBufSize * pInterface->MaxProtocolBufs)
				);

		if (pInterface->ProtocolBufTracker == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = NDIS_STATUS_SUCCESS;

		//
		//  Make all protocol buffers free.
		//
		pSpace = pInterface->ProtocolBufTracker;
		{
			PUCHAR	LinkPtr;

			LinkPtr = (PUCHAR)NULL;
			for (i = 0; i < pInterface->MaxProtocolBufs; i++)
			{
				*((PUCHAR *)pSpace) = LinkPtr;
				LinkPtr = pSpace;
				pSpace += pInterface->ProtocolBufSize;
			}
			pSpace -= pInterface->ProtocolBufSize;
			pInterface->ProtocolBufList = pSpace;
		}
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Undo everything.
		//
		AtmArpDeallocateProtoBuffers(pInterface);
	}


	return (Status);
}



VOID
AtmArpDeallocateProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Free the protocol buffer pool for an interface.

Arguments:

	pInterface		- Pointer to ATMARP interface structure

Return Value:

	None

--*/
{
	if (pInterface->ProtocolPacketPool != (NDIS_HANDLE)NULL)
	{
		NdisFreePacketPool(pInterface->ProtocolPacketPool);
		pInterface->ProtocolPacketPool = NULL;
	}

	if (pInterface->ProtocolBufferPool != (NDIS_HANDLE)NULL)
	{
		NdisFreeBufferPool(pInterface->ProtocolBufferPool);
		pInterface->ProtocolBufferPool = NULL;
	}

	if (pInterface->ProtocolBufTracker != (PUCHAR)NULL)
	{
		AA_FREE_MEM(pInterface->ProtocolBufTracker);
		pInterface->ProtocolBufTracker = (PUCHAR)NULL;
	}
}


VOID
AtmArpLinkVcToAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Link an ATMARP VC to an ATM Entry. The caller is assumed to
	hold locks to both structures.

	If this VC is a "best effort" VC, and there is no "best effort"
	VC linked to the ATM Entry, we make this as the "best effort VC"
	on this ATM Entry.

Arguments:

	pVc					- Pointer to ATMARP VC structure
	pAtmEntry			- Pointer to ATMARP ATM Entry structure

Return Value:

	None

--*/
{
	PATMARP_VC		*ppNext;
	ULONG			SendBandwidth;

	AADEBUGP(AAD_EXTRA_LOUD, ("Link VC: 0x%x to AtmEntry 0x%x\n",
			pVc, pAtmEntry));

	//
	//  Back pointer from VC to ATM Entry.
	//
	pVc->pAtmEntry = pAtmEntry;

	//
	//  Find the position in which this VC should appear in the ATM Entry's
	//  VC list. We maintain this list in descending order of send bandwidth,
	//  so that the largest bandwidth VC to a destination appears first.
	//
	SendBandwidth = pVc->FlowSpec.SendPeakBandwidth;
	ppNext = &(pAtmEntry->pVcList);
	while (*ppNext != NULL_PATMARP_VC)
	{
		if (SendBandwidth >= (*ppNext)->FlowSpec.SendPeakBandwidth)
		{
			break;
		}
		else
		{
			ppNext = &((*ppNext)->pNextVc);
		}
	}

	//
	//  Found the place we were looking for. Insert the VC here.
	//
	pVc->pNextVc = *ppNext;
	*ppNext = pVc;

	if ((pAtmEntry->pBestEffortVc == NULL_PATMARP_VC) &&
			AA_IS_BEST_EFFORT_FLOW(&(pVc->FlowSpec)))
	{
		pAtmEntry->pBestEffortVc = pVc;
	}

	AA_REF_AE(pAtmEntry, AE_REFTYPE_VC);	// VC reference
}




VOID
AtmArpUnlinkVcFromAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	BOOLEAN						bDerefAtmEntry
)
/*++

Routine Description:

	Unlink an ATMARP VC from the ATM Entry it is linked to.
	The caller is assumed to hold a lock for the VC structure.

Arguments:

	pVc				- Pointer to ATMARP VC structure
	bDerefAtmEntry	- Should we deref the ATM entry or not.

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_VC *				ppVc;

	AADEBUGP(AAD_EXTRA_LOUD, ("Unlink VC: 0x%x from AtmEntry 0x%x\n",
			pVc, pVc->pAtmEntry));

	pAtmEntry = pVc->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	pVc->pAtmEntry = NULL_PATMARP_ATM_ENTRY;

	//
	//  Reacquire locks in the right order.
	//
	AA_RELEASE_VC_LOCK(pVc);

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_ACQUIRE_VC_LOCK_DPC(pVc);

	//
	//  Search for the position of this VC in the ATM Entry's VC list
	//
	ppVc = &(pAtmEntry->pVcList);
	while (*ppVc != pVc)
	{
		AA_ASSERT(*ppVc != NULL_PATMARP_VC);
		ppVc = &((*ppVc)->pNextVc);
	}

	//
	//  Make the predecessor point to the next VC in the list.
	//
	*ppVc = pVc->pNextVc;

	AA_RELEASE_VC_LOCK_DPC(pVc);

	//
	//  If this was the Best Effort VC for this ATM Entry, try
	//  to find a replacement
	//
	if (pAtmEntry->pBestEffortVc == pVc)
	{
		//
		//  Yes, it was. Walk through the list of remaining VCs,
		//  if we find another Best Effort VC, make that the
		//  BestEffortVc for this ATM Entry
		//
		pAtmEntry->pBestEffortVc = NULL_PATMARP_VC;

		ppVc = &(pAtmEntry->pVcList);
		while (*ppVc != NULL_PATMARP_VC)
		{
			if (AA_IS_BEST_EFFORT_FLOW(&((*ppVc)->FlowSpec)))
			{
				pAtmEntry->pBestEffortVc = *ppVc;
				break;
			}
			else
			{
				ppVc = &((*ppVc)->pNextVc);
			}
		}
		AADEBUGP(AAD_LOUD, ("Atm Entry 0x%x, new Best Effort VC: 0x%x\n",
				pAtmEntry, pAtmEntry->pBestEffortVc));
	}

	if (bDerefAtmEntry)
	{
		if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_VC) != 0)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	else
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

	//
	//  Acquire the VC lock again for the caller's sake
	//
	AA_ACQUIRE_VC_LOCK(pVc);
}



PNDIS_BUFFER
AtmArpCopyToNdisBuffer(
	IN	PNDIS_BUFFER				pDestBuffer,
	IN	PUCHAR						pDataSrc,
	IN	UINT						LenToCopy,
	IN OUT	PUINT					pOffsetInBuffer
)
/*++

Routine Description:

	Copy data into an NDIS buffer chain. Use up as much of the given
	NDIS chain as needed for "LenToCopy" bytes. After copying is over,
	return a pointer to the first NDIS buffer that has space for writing
	into (for the next Copy operation), and the offset within this from
	which to start writing.

Arguments:

	pDestBuffer		- First NDIS buffer in a chain of buffers
	pDataSrc		- Where to copy data from
	LenToCopy		- How much data to copy
	pOffsetInBuffer	- Offset in pDestBuffer where we can start copying into.

Return Value:

	The NDIS buffer in the chain where the next Copy can be done. We also
	set *pOffsetInBuffer to the write offset in the returned NDIS buffer.

	Note: if we are low on memory and run into a failure, we return NULL.

--*/
{
	//
	//  Size and destination for individual (contiguous) copy operations
	//
	UINT			CopySize;
	PUCHAR			pDataDst;

	//
	//  Start Virtual address for each NDIS buffer in chain.
	//
	PUCHAR			VirtualAddress;

	//
	//  Offset within pDestBuffer
	//
	UINT			OffsetInBuffer = *pOffsetInBuffer;

	//
	//  Bytes remaining in current buffer
	//
	UINT			DestSize;

	//
	//  Total Buffer Length
	//
	UINT			BufferLength;


	AA_ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
	AA_ASSERT(pDataSrc != NULL);

#ifdef ATMARP_WIN98
	NdisQueryBuffer(
			pDestBuffer,
			&VirtualAddress,
			&BufferLength
			);
#else
	NdisQueryBufferSafe(
			pDestBuffer,
			&VirtualAddress,
			&BufferLength,
			NormalPagePriority
			);

	if (VirtualAddress == NULL)
	{
		return (NULL);
	}
#endif // ATMARP_WIN98
	
	AA_ASSERT(BufferLength >= OffsetInBuffer);

	pDataDst = VirtualAddress + OffsetInBuffer;
	DestSize = BufferLength - OffsetInBuffer;

	for (;;)
	{
		CopySize = MIN(LenToCopy, DestSize);
		AA_COPY_MEM(pDataDst, pDataSrc, CopySize);

		pDataDst += CopySize;
		pDataSrc += CopySize;

		LenToCopy -= CopySize;
		if (LenToCopy == 0)
		{
			break;
		}

		DestSize -= CopySize;

		if (DestSize == 0)
		{
			//
			//  Out of space in the current buffer. Move to the next.
			//
			pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);
			AA_ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
#ifdef ATMARP_WIN98
			NdisQueryBuffer(
					pDestBuffer,
					&VirtualAddress,
					&BufferLength
					);
#else
			NdisQueryBufferSafe(
					pDestBuffer,
					&VirtualAddress,
					&BufferLength,
					NormalPagePriority
					);

			if (VirtualAddress == NULL)
			{
				return (NULL);
			}
#endif // ATMARP_WIN98

			pDataDst = VirtualAddress;
			DestSize = BufferLength;
		}
	}

	*pOffsetInBuffer = (UINT) (pDataDst - VirtualAddress);

	return (pDestBuffer);
}


PATMARP_INTERFACE
AtmArpAddInterfaceToAdapter (
	IN	PATMARP_ADAPTER				pAdapter,
	IN	NDIS_HANDLE					LISConfigHandle, // Handle to per-LIS config
	IN	NDIS_STRING					*pIPConfigString
	)
{
	NDIS_STATUS					Status;
	struct LLIPBindInfo			BindInfo;
	PATMARP_INTERFACE			pInterface;
#ifdef ATMARP_WIN98
	ANSI_STRING					AnsiConfigString;
#endif

	do
	{
		//
		//  Create an ATMARP Interface structure to represent this LIS.
		//
		pInterface = AtmArpAllocateInterface(pAdapter);
		if (pInterface == NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING, ("NotifyRegAfHandler: could not allocate Interface\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Adapter Binding Reference:
		//
		AtmArpReferenceInterface(pInterface);

		//
		//  Get all configuration information for this LIS.
		//
		Status = AtmArpCfgReadLISConfiguration(
									LISConfigHandle,
									pInterface
									);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) reading LIS cfg\n",
						Status));
			break;
		}

#ifndef ATMARP_WIN98
		pInterface->IPConfigString = *pIPConfigString; // struct copy.
#else
		//
		//  Win98: Convert IPConfig string from Unicode to ANSI.
		//
		AnsiConfigString.MaximumLength = pIPConfigString->MaximumLength / sizeof(WCHAR) + sizeof(CHAR);
		AA_ALLOC_MEM(AnsiConfigString.Buffer, CHAR, AnsiConfigString.MaximumLength);
		if (AnsiConfigString.Buffer == NULL)
		{
			AADEBUGP(AAD_WARNING, ("NotifyRegAfHandler: couldn't alloc Ansi string (%d)\n",
				AnsiConfigString.MaximumLength));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		AnsiConfigString.Length = 0;
		NdisUnicodeStringToAnsiString(&AnsiConfigString, pIPConfigString);
		AnsiConfigString.Buffer[AnsiConfigString.Length] = '\0';
#endif // !ATMARP_WIN98

		//
		//  Allocate protocol buffers for this LIS.
		//
		Status = AtmArpInitProtoBuffers(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from InitBufs\n",
						Status));
			break;
		}

		//
		//  Initialize IP/ATM data structures for this LIS.
		//
		Status = AtmArpInitIpOverAtm(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from InitIP/ATM\n",
						Status));
			break;
		}

		//
		//  Initialize the Call Manager interface for this LIS.
		//
		Status = AtmArpOpenCallMgr(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from OpenCallMgr\n",
						Status));
			break;
		}

		//
		//  Announce this new interface to IP, along with our BindInfo
		//  structure.
		//
		AA_SET_MEM(&BindInfo, 0, sizeof(BindInfo));

#if ATMOFFLOAD
		//
		// Query and set NIC offload capabilities.
		//
		BindInfo.lip_OffloadFlags 	= pAdapter->Offload.Flags;
		BindInfo.lip_MaxOffLoadSize = pAdapter->Offload.MaxOffLoadSize;
		BindInfo.lip_MaxSegments 	= pAdapter->Offload.MinSegmentCount;
#endif // ATMOFFLOAD

		BindInfo.lip_context = (PVOID)pInterface;
#ifdef ATMARP_WIN98
		BindInfo.lip_transmit = AtmArpIfTransmit;
#else
		BindInfo.lip_transmit = AtmArpIfMultiTransmit;
#endif
		BindInfo.lip_transfer = AtmArpIfTransfer;
		BindInfo.lip_close = AtmArpIfClose;
		BindInfo.lip_addaddr = AtmArpIfAddAddress;
		BindInfo.lip_deladdr = AtmArpIfDelAddress;
		BindInfo.lip_invalidate = AtmArpIfInvalidate;
		BindInfo.lip_open = AtmArpIfOpen;
		BindInfo.lip_qinfo = AtmArpIfQueryInfo;
		BindInfo.lip_setinfo = AtmArpIfSetInfo;
		BindInfo.lip_getelist = AtmArpIfGetEList;
		BindInfo.lip_mss = pInterface->MTU;
		BindInfo.lip_speed = pInterface->Speed;
		//
		//  Set LIP_COPY_FLAG to avoid having TransferData
		//  called all the time.
		//
		BindInfo.lip_flags = LIP_COPY_FLAG;
		BindInfo.lip_addrlen = AA_ATM_PHYSADDR_LEN;
		BindInfo.lip_addr = &(pInterface->LocalAtmAddress.Address[AA_ATM_ESI_OFFSET]);
#ifdef _PNP_POWER_
		BindInfo.lip_pnpcomplete = AtmArpIfPnPComplete;
#endif // _PNP_POWER_

#ifdef PROMIS
		BindInfo.lip_setndisrequest = AtmArpIfSetNdisRequest;
#endif // PROMIS

#ifdef ATMARP_WIN98
#if DBG
		AADEBUGP(AAD_FATAL, ("Will call AddIF: DeviceName [%ws]\n",
							&(pInterface->pAdapter->DeviceName.Buffer)));
		AADEBUGP(AAD_FATAL, ("And ConfigString: [%s]\n", AnsiConfigString.Buffer));
#endif
#endif // ATMARP_WIN98

		Status = (*(pAtmArpGlobalInfo->pIPAddInterfaceRtn))(
							&(pInterface->pAdapter->DeviceName),

#ifndef ATMARP_WIN98
#if IFCHANGE1
							NULL, // IfName (unused) --  See 10/14/1998 entry
								  // in notes.txt
#endif // IFCHANGE1
							pIPConfigString,
						
#else
							(PNDIS_STRING)&AnsiConfigString,
#endif
							pAdapter->SystemSpecific2,
							(PVOID)pInterface,
							AtmArpIfDynRegister,
							&BindInfo
#if IFCHANGE1
#ifndef ATMARP_WIN98
							,0,	// RequestedIndex (unused) --  See 10/14/1998 entry
								// in notes.txt

                            IF_TYPE_IPOVER_ATM,
                            IF_ACCESS_BROADCAST,
                            IF_CONNECTION_DEDICATED
#endif
#endif // IFCHANGE1
							);

		if (Status == IP_SUCCESS)
		{
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			AADEBUGP(AAD_ERROR, ("AddInterface: IPAddInterface ret 0x%x\n",
						Status));

			Status = NDIS_STATUS_FAILURE;
		}
		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  There was a failure in processing this LIS.
		//
		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			if (pInterface->NdisAfHandle != NULL)
			{
				(VOID)AtmArpCloseCallMgr(pInterface);
			}

			pInterface->RefCount = 0;
			AtmArpDeallocateInterface(pInterface);

			pInterface = NULL_PATMARP_INTERFACE;
		}
	}

	return pInterface;

}

#if DBG

void
AtmArpValidateTimerList(
	PATMARP_TIMER_LIST		pTimerList
	)
/*++

Routine Description:


Arguments:

	pTimerList		- Timer list 

Return Value:

	None -- will assert if timer is not valid.

--*/

{
	PATMARP_TIMER			pTimer;
	UINT u;
	UINT cTimers=0;

	AA_ASSERT(pTimerList->atl_sig == atl_signature);
	AA_ASSERT(pTimerList->CurrentTick < pTimerList->TimerListSize);

	for (u=0;u<pTimerList->TimerListSize;u++)
	{
		for ( 	pTimer = pTimerList->pTimers[u].pNextTimer;
  				pTimer;
  				pTimer = pTimer->pNextTimer)
		{
			AtmArpValidateTimer(pTimerList, pTimer);
			cTimers++;
		}
	}

	AA_ASSERT(pTimerList->TimerCount == cTimers);

}

void
AtmArpValidateTimer(
	PATMARP_TIMER_LIST		pTimerList, // OPTIONAL
	PATMARP_TIMER			pTimer
	)
/*++

Routine Description:


Arguments:

	pTimer			- Timer

Return Value:

	None -- will assert if timer is not valid.

--*/

{
	if (pTimerList)
	{
		AA_ASSERT(pTimerList == pTimer->pTimerList);
	}

	if (pTimer->pPrevTimer)
	{
		AA_ASSERT(pTimer->pPrevTimer->pNextTimer == pTimer);
	}

	if (pTimer->pNextTimer)
	{
		AA_ASSERT(pTimer->pNextTimer->pPrevTimer == pTimer);
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\arps.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	arps.c

Abstract:

	This file contains the code to implement the initialization
	functions for the atmarp server.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_ARPS

ULONG	MCastDiscards = 0;

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT			DriverObject,
	IN	PUNICODE_STRING			RegistryPath
	)
/*++

Routine Description:

	IP/ATM Arp Server driver entry point.

Arguments:

	DriverObject - Pointer to the driver object created by the system.
	RegistryPath - Pointer to the registry section where the parameters reside.

Return Value:

	Return value from IoCreateDevice

--*/
{
	NTSTATUS		Status;
	UNICODE_STRING	DeviceName, GlobalPath, SymbolicName;
	HANDLE			ThreadHandle = NULL;
	INT				i;

#if DBG
	DbgPrint("AtmArpS: ArpSDebugLevel @ %p, MarsDebugLevel @ %p\n",
				&ArpSDebugLevel, &MarsDebugLevel);
#endif // DBG
	InitializeListHead(&ArpSEntryOfDeath);
	KeInitializeEvent(&ArpSReqThreadEvent, NotificationEvent, FALSE);
	KeInitializeQueue(&ArpSReqQueue, 0);
	KeInitializeQueue(&MarsReqQueue, 0);
	INITIALIZE_SPIN_LOCK(&ArpSIfListLock);

	ASSERT (ADDR_TYPE_NSAP == ATM_NSAP);
	ASSERT (ADDR_TYPE_E164 == ATM_E164);
	//
	// Create an NON-EXCLUSIVE device object
	//
	RtlInitUnicodeString(&DeviceName,
						 ARP_SERVER_DEVICE_NAME);
	RtlInitUnicodeString(&SymbolicName, ARP_SERVER_SYMBOLIC_NAME);

	Status = IoCreateDevice(DriverObject,
							0,
							&DeviceName,
							FILE_DEVICE_NETWORK,
							FILE_DEVICE_SECURE_OPEN,
							FALSE,
							&ArpSDeviceObject);

	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_LEVEL_INFO, ("DriverEntry: IoCreateDevice failed %lx\n", Status));
	}

	else do
	{
		IoCreateSymbolicLink(&SymbolicName, &DeviceName);
		IoRegisterShutdownNotification(ArpSDeviceObject);

		ArpSDriverObject = DriverObject;

		//
		// Initialize the driver object
		//
		DriverObject->DriverUnload = ArpSUnload;
		DriverObject->FastIoDispatch = NULL;

		for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
			DriverObject->MajorFunction[i] = ArpSDispatch;

		RtlInitUnicodeString(&GlobalPath, L"AtmArpS\\Parameters");
		Status = ArpSReadGlobalConfiguration(&GlobalPath);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		// Now create a thread to handle the Arp requests.
		// We do this so that the arp cache can be allocated
		// out of paged memory. Do this prior to initializing
		// the NDIS interface.
		//
		Status = PsCreateSystemThread(&ThreadHandle,
									  THREAD_ALL_ACCESS,
									  NULL,
									  NtCurrentProcess(),
									  NULL,
									  ArpSReqThread,
									  (PVOID)NULL);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("DriverEntry: Cannot create request thread %lx\n", Status));
			LOG_ERROR(Status);
			break;
		}
		else
		{
			//
			// Close the handle to the thread so that it goes away when the
			// thread terminates
			//
			NtClose(ThreadHandle);

			Status = PsCreateSystemThread(&ThreadHandle,
										  THREAD_ALL_ACCESS,
										  NULL,
										  NtCurrentProcess(),
										  NULL,
										  MarsReqThread,
										  (PVOID)NULL);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("DriverEntry: Cannot create MARS thread %lx\n", Status));
				LOG_ERROR(Status);
			}
			else
			{
				//
				// Close the handle to the thread so that it goes away when the
				// thread terminates
				//
				NtClose(ThreadHandle);
			}
		}

		//
		// Finally initialize the NDIS interface
		//

		if(NT_SUCCESS(Status))
		{
			Status = ArpSInitializeNdis();
		}

		if(!NT_SUCCESS(Status))
		{
			NTSTATUS	Sts;

			DBGPRINT(DBG_LEVEL_INFO, ("DriverEntry: Error initializing NDIS\n"));

			//
			// Ask the request thread to die
			//
			KeInsertQueue(&ArpSReqQueue, &ArpSEntryOfDeath);

			//
			// Wait for it to die
			//
			WAIT_FOR_OBJECT(Sts, &ArpSReqThreadEvent, NULL);

			ArpSSleep(500);
			KeRundownQueue(&ArpSReqQueue);

			break;
		}
	} while (FALSE);

	if (!NT_SUCCESS(Status))
	{
		if (ArpSDeviceObject != NULL)
		{

			IoUnregisterShutdownNotification(ArpSDeviceObject);
		    IoDeleteSymbolicLink(&SymbolicName);
			IoDeleteDevice(ArpSDeviceObject);
		}

		//
		// De-initialize the NDIS interface
		//
		ArpSDeinitializeNdis();

		ArpSFreeGlobalData();
	}

	return Status;
}


VOID
ArpSUnload(
	IN	PDRIVER_OBJECT			DriverObject
	)
/*++

Routine Description:

	Called by the IO system to unload. This is a synchronous call and we block here till
	we finish all the cleanup before we unload.

Arguments:

	DriverObject - The arp-server's driver object.

Return Value:

	None

--*/
{
	ArpSShutDown();

	//
	// Finally delete the device
	//
	{
		UNICODE_STRING	SymbolicName;

		RtlInitUnicodeString(&SymbolicName, ARP_SERVER_SYMBOLIC_NAME);
		IoUnregisterShutdownNotification(ArpSDeviceObject);
		IoDeleteSymbolicLink(&SymbolicName);
		IoDeleteDevice(ArpSDeviceObject);
	}
}


VOID
ArpSShutDown(
	VOID
	)
/*++

Routine Description:

	Called by the IO system when the system is being shutdown.

Arguments:

	None

Return Value:

	None

--*/
{
	NTSTATUS		Status;

	//
	// Take care of the NDIS layer. NDIS will tear down any existing
	// bindings when we deregister as a protocol.
	//
	ArpSDeinitializeNdis();

	//
	// Ask the request thread to quit and wait for its demise.
	//
	KeInsertQueue(&ArpSReqQueue, &ArpSEntryOfDeath);

	WAIT_FOR_OBJECT(Status, &ArpSReqThreadEvent, NULL);
	ArpSSleep(500);
	KeRundownQueue(&ArpSReqQueue);

	//
	// Ask the MARS thread to quit and wait for its demise.
	//
	KeInsertQueue(&MarsReqQueue, &ArpSEntryOfDeath);

	KeInitializeEvent(&ArpSReqThreadEvent, NotificationEvent, FALSE);
	WAIT_FOR_OBJECT(Status, &ArpSReqThreadEvent, NULL);
	ArpSSleep(500);
	KeRundownQueue(&MarsReqQueue);

	//
	// Now cleanup global data structures
	//
	ArpSFreeGlobalData();
}

PINTF
ArpSCreateIntF(
	IN	PNDIS_STRING			DeviceName,
	IN	PNDIS_STRING			ConfigString,
	IN  NDIS_HANDLE				BindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	NTSTATUS		Status;
	HANDLE			ThreadHandle;
	PINTF			pIntF;
	UINT			Size;
	UNICODE_STRING	DevPrefix;
	UNICODE_STRING	FilePrefix;
	UNICODE_STRING	FileSuffix;
	UNICODE_STRING	BaseName;
	NDIS_STRING	    AdapterFriendlyName;

	ARPS_PAGED_CODE( );

	//
	// Get the friendly name of the adapter we are bound to.
	//
	if (NdisQueryBindInstanceName(&AdapterFriendlyName, BindingContext) != NDIS_STATUS_SUCCESS)
	{
		return (NULL);
	}

	//
	// Extract the base-name of the device we are bound to
	//
	RtlInitUnicodeString(&DevPrefix, L"\\Device\\");
	RtlInitUnicodeString(&FilePrefix, L"\\SYSTEMROOT\\SYSTEM32\\");
	RtlInitUnicodeString(&FileSuffix, L".ARP");

	BaseName.Buffer = (PWSTR)((PUCHAR)DeviceName->Buffer + DevPrefix.Length);
    BaseName.Length = DeviceName->Length - DevPrefix.Length;
    BaseName.MaximumLength = DeviceName->MaximumLength - DevPrefix.Length;

	//
	// Start off by allocating an IntF block
	//
	Size =  sizeof(INTF) + FilePrefix.Length + BaseName.Length + FileSuffix.Length + sizeof(WCHAR) +
			BaseName.Length + sizeof(WCHAR) +
			AdapterFriendlyName.MaximumLength + sizeof(WCHAR);
	Size += ConfigString->MaximumLength + sizeof(WCHAR);
	pIntF = (PINTF)ALLOC_NP_MEM(Size, POOL_TAG_INTF);
	if (pIntF != NULL)
	{
		ZERO_MEM(pIntF, Size);

		//
		// Fill in some defaults.
		//
		pIntF->MaxPacketSize = DEFAULT_MAX_PACKET_SIZE;
		pIntF->LinkSpeed.Inbound = pIntF->LinkSpeed.Outbound = DEFAULT_SEND_BANDWIDTH;
		pIntF->CCFlowSpec = DefaultCCFlowSpec;

	
		//
		// Start off with a refcount of 1 for the interface and one for the timer thread.
		// The timer thread derefs when asked to quit and the last reference
		// is removed when the interface is closed (ArpSCloseAdapterComplete).
		//
		pIntF->RefCount = 2;
		pIntF->LastVcId = 1;		// Start off with 1 and wrap-around to 1. 0 and -1 are invalid
		pIntF->SupportedMedium = NdisMediumAtm;
		pIntF->CSN = 1;

		INITIALIZE_MUTEX(&pIntF->ArpCacheMutex);
		KeInitializeEvent(&pIntF->TimerThreadEvent, NotificationEvent, FALSE);
		InitializeListHead(&pIntF->InactiveVcHead);
		InitializeListHead(&pIntF->ActiveVcHead);
		InitializeListHead(&pIntF->CCPacketQueue);
		ArpSTimerInitialize(&pIntF->FlushTimer, ArpSWriteArpCache, ArpSFlushTime);

		ArpSTimerInitialize(&pIntF->MarsRedirectTimer, MarsSendRedirect, REDIRECT_INTERVAL);

		pIntF->InterfaceName.Buffer = (PWSTR)((PUCHAR)pIntF + sizeof(INTF));
		pIntF->InterfaceName.Length = 0;
		pIntF->InterfaceName.MaximumLength = BaseName.Length;

		pIntF->FileName.Buffer = (PWSTR)((PUCHAR)pIntF->InterfaceName.Buffer + BaseName.Length + sizeof(WCHAR));
		pIntF->FileName.Length = 0;
		pIntF->FileName.MaximumLength = FilePrefix.Length + BaseName.Length + FileSuffix.Length + sizeof(WCHAR);

		RtlUpcaseUnicodeString(&pIntF->InterfaceName,
							   &BaseName,
							   FALSE);

		RtlCopyUnicodeString(&pIntF->FileName, &FilePrefix);
		RtlAppendUnicodeStringToString(&pIntF->FileName, &pIntF->InterfaceName);
		RtlAppendUnicodeStringToString(&pIntF->FileName, &FileSuffix);

		//
		// Copy in the config string used to access registry for this interface.
		//
		pIntF->ConfigString.Buffer = (PWSTR)((ULONG_PTR)pIntF->FileName.Buffer + pIntF->FileName.MaximumLength);
		pIntF->ConfigString.Length = 0;
		pIntF->ConfigString.MaximumLength = ConfigString->MaximumLength;
		RtlCopyUnicodeString(&pIntF->ConfigString, ConfigString);

		//
		// Copy in the friendly name.
		//
		pIntF->FriendlyName.Buffer = (PWSTR)((ULONG_PTR)pIntF->ConfigString.Buffer + pIntF->ConfigString.MaximumLength);
		pIntF->FriendlyName.Length = 0;
		pIntF->FriendlyName.MaximumLength = AdapterFriendlyName.MaximumLength + sizeof(WCHAR);
		RtlCopyUnicodeString(&pIntF->FriendlyName, &AdapterFriendlyName);
		*(PWCHAR)((ULONG_PTR)pIntF->FriendlyName.Buffer + AdapterFriendlyName.MaximumLength) = L'\0';
		pIntF->FriendlyName.Length += sizeof(WCHAR);
		NdisFreeString(AdapterFriendlyName);

		//
		// Initialize the start timestamp value -- used for statistics reporting.
		//
 		NdisGetCurrentSystemTime(&(pIntF->StatisticsStartTimeStamp));

		//
		// Create a timer-thread now.
		//
		Status = PsCreateSystemThread(&ThreadHandle,
									  THREAD_ALL_ACCESS,
									  NULL,
									  NtCurrentProcess(),
									  NULL,
									  ArpSTimerThread,
									  (PVOID)pIntF);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSCreateIntF: Cannot create timer thread %lx for device %Z\n",
					Status, DeviceName));
			LOG_ERROR(Status);
			FREE_MEM(pIntF);
			pIntF = NULL;
		}
		else
		{
			//
			// Close the handle to the thread so that it goes away when the
			// thread terminates
			//
			NtClose(ThreadHandle);

			DBGPRINT(DBG_LEVEL_INFO,
					("ArpSCreateIntF: Device name %Z, InterfaceName %Z, FileName %Z, ConfigString %Z\n",
					DeviceName, &pIntF->InterfaceName, &pIntF->FileName, &pIntF->ConfigString));
			if (ArpSFlushTime != 0)
				ArpSTimerEnqueue(pIntF, &pIntF->FlushTimer);
			ArpSTimerEnqueue(pIntF, &pIntF->MarsRedirectTimer);
		}
	}

	return pIntF;
}


VOID
ArpSReqThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle all arp requests here.

Arguments:

	None

Return Value:

	None
--*/
{
	PARPS_HEADER		Header;
	PARP_ENTRY			ArpEntry;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	PARP_VC				Vc;
	PINTF				pIntF;
	UINT				PktLen;
	PLIST_ENTRY			List;
	IPADDR				SrcIpAddr, DstIpAddr;
	NTSTATUS			Status;
	HW_ADDR				SrcHwAddr, DstHwAddr;
	ATM_ADDRESS			SrcSubAddr, DstSubAddr;
	PUCHAR				p;
	BOOLEAN				SendReply;
	BOOLEAN				SendNAK = FALSE;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSReqThread: Came to life\n"));

	do
	{
		List = KeRemoveQueue(&ArpSReqQueue, KernelMode, NULL);
		if (List == &ArpSEntryOfDeath)
		{
			//
			// Asked to terminate, do so.
			//
			break;
		}

		SendReply = FALSE;
		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, ReqList);
		Vc = Resd->Vc;

		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		pIntF = Vc->IntF;
	
		NdisQueryBuffer(Pkt->Private.Head, &Header, &PktLen);

		ASSERT (PktLen <= PKT_SPACE);
		p = (PUCHAR)Header + sizeof(ARPS_HEADER);
	
		//
		// Process arp request now. Since the Pkt is owned by us, we know that
		// the buffer that the packet points is contiguous and the integrity of
		// the packet has already been verified. There is also sufficient space
		// in the packet for the max. size reply that we can send.
		//
		//	!!!!!!!!!! ALGORITHM FROM RFC 1577 !!!!!!!!!!
		//
		// Here is the algorithm for handling ARP requests from the RFC
		//
		//  if (SrcIpAddr == DstIpAddr)
		//  {
		//  	if ((ArpEntry(SrcIpAddr) != NULL) &&
		//  		(SrcAtmAddress != ArpEntry->AtmAddress) &&
		//  		(ArpEnrty->Vc != NULL) && (ArpEntry->Vc != Vc))
		//  	{
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  	else if ((ArpEntry(SrcIpAddr) == NULL) ||
		//  			 (ArpEntry->Vc == NULL) ||
		//  			 (ArpEntry->Vc == Vc))
		//  	{
		//  		if (ArpEntry(SrcIpAddr) == NULL))
		//  		{
		//  			Create an arp entry for this IpAddr;
		//  		}
		//  		Update the arp entry with info from the request;
		//
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  }
		//  else // if (SrcIpAddr != DstIpAddr)
		//  {
		//  	if (ArpEntry(DstIpAddr) != NULL)
		//  	{
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  	else
		//  	{
		//  		Respond with a NAK
		//  	}
		//
		//  	if (ArpEntry(SrcIpAddr) == NULL)
		//  	{
		//  		Create a new ArpEntry for the (SrcIpAddr, ArcAtmAddress) pair
		//  	}
		//  	else if ((ArpEntry->AtmAddress == SrcAtmAddress) &&
		//  			 (ArpEntry->AtmAddress == Vc->AtmAddress))
		//  	{
		//  		Reset timer on this ArpEntry;
		//  	}
		//  }
		//
		//	!!!!!!!!!! ALGORITHM FROM RFC 1577 !!!!!!!!!!
		//

		//
		// Start off by extracting fields from the header
		// First the source hw address (incl. the sub-addr if any)
		//
		SrcHwAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcHwAddr.Address.NumberOfDigits > 0)
		{
			SrcHwAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcHwAddr.Address.Address, p, SrcHwAddr.Address.NumberOfDigits);
			p += SrcHwAddr.Address.NumberOfDigits;
		}
		SrcHwAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcHwAddr.SubAddress = &SrcSubAddr;
            SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
            SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// Next get the source IP address
		//
		SrcIpAddr = 0;
		if (Header->SrcProtoAddrLen == IP_ADDR_LEN)
		{
			SrcIpAddr = *(UNALIGNED IPADDR *)p;
			p += IP_ADDR_LEN;
		}
		ArpSDumpAddress(SrcIpAddr, &SrcHwAddr, "Source");

		//
		// Now the destination hw address (incl. the sub-addr if any)
		//
		DstHwAddr.Address.NumberOfDigits = TL_LEN(Header->DstAddressTL);
		if (DstHwAddr.Address.NumberOfDigits > 0)
		{
			DstHwAddr.Address.AddressType = TL_TYPE(Header->DstAddressTL);
			COPY_MEM(DstHwAddr.Address.Address, p, DstHwAddr.Address.NumberOfDigits);
			p += DstHwAddr.Address.NumberOfDigits;
		}
		DstHwAddr.SubAddress = NULL;
		if (TL_LEN(Header->DstSubAddrTL) > 0)
		{
			DstHwAddr.SubAddress = &DstSubAddr;
            DstSubAddr.NumberOfDigits = TL_LEN(Header->DstSubAddrTL);
            DstSubAddr.AddressType = TL_TYPE(Header->DstSubAddrTL);
			COPY_MEM(&DstSubAddr.Address, p, DstSubAddr.NumberOfDigits);
			p += DstSubAddr.NumberOfDigits;
		}

		//	
		// Finally the destination IP address
		//
		DstIpAddr = 0;
		if (Header->DstProtoAddrLen == IP_ADDR_LEN)
		{
			DstIpAddr = *(UNALIGNED IPADDR *)p;
			// p += IP_ADDR_LEN;
		}
		ArpSDumpAddress(DstIpAddr, &DstHwAddr, "Destination");

		do
		{
			//
			// Validate that the source and destination Ip addresses are not 0.0.0.0
			// NOTE: We can also check if they are within the same LIS (should we ?).
			//
			if ((SrcIpAddr == 0) || (DstIpAddr == 0))
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("ArpSReqThread: Null IpAddress Src(%lx), Dst(%lx)\n",
						SrcIpAddr, DstIpAddr));
	
				SendReply = FALSE;
				break;
			}
	
			//
			// Take the lock on the Arp Cache now.
			//
			WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
			ASSERT (Status == STATUS_SUCCESS);
	
			if (SrcIpAddr == DstIpAddr)
			{
				//
				// Try to map the address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, SrcIpAddr);
				if ((ArpEntry != NULL) &&
					!COMP_HW_ADDR(&SrcHwAddr, &ArpEntry->HwAddr) &&
					(ArpEntry->Vc != NULL) && (ArpEntry->Vc != Vc))
				{
					//
					// Respond with the information from the ArpEntry
					// We have encountered a duplicate address.
					//
					ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
					SendReply = TRUE;
					LOG_ERROR(NDIS_STATUS_ALREADY_MAPPED);
				}
				else if ((ArpEntry == NULL)	|| (ArpEntry->Vc == NULL) || (ArpEntry->Vc == Vc))
				{
					if (ArpEntry == NULL)
					{
						//
						// Create an arp entry for this IpAddr
						//
						ArpEntry = ArpSAddArpEntry(pIntF, SrcIpAddr, &SrcHwAddr.Address, SrcHwAddr.SubAddress, Vc);
					}
					else
					{
						//
						// Update the arp entry with info from the request;
						//
						ArpSUpdateArpEntry(pIntF, ArpEntry, SrcIpAddr, &SrcHwAddr, Vc);
					}
			
					if (ArpEntry != NULL)
					{
						//
						// Respond with the information from the ArpEntry
						//
						ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
						SendReply = TRUE;
					}
					else
					{
						//
						// Failed to allocate an ARP entry
						//
						SendNAK = TRUE;
						SendReply = TRUE;
					}
				}
				else
				{
					DbgPrint("ATMARPS: pkt on wrong VC: ArpEntry %p, ArpEntry->Vc %p, Vc %p\n",
								ArpEntry,
								((ArpEntry)? ArpEntry->Vc: NULL),
								Vc);
				}
			}
			else // i.e. (SrcIpAddr != DstIpAddr)
			{
				//
				// Try to map the dst address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, DstIpAddr);
	
				if (ArpEntry != NULL)
				{
					//
					// Respond with the information from the ArpEntry
					// for the destination IP Address
					//
					ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
					SendReply = TRUE;
				}
				else
				{
					//
					// Respond with a NAK
					//
					// ArpSBuildNakReply(pIntF, ArpEntry, Header, Pkt);
					DBGPRINT(DBG_LEVEL_INFO,
							("ArpSThread: Naking for "));
					ArpSDumpIpAddr(DstIpAddr, "\n");
					Header->Opcode = ATMARP_Nak;
					SendReply = TRUE;
					SendNAK = TRUE; // for stats
				}
			
				//
				// Try to map the src address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, SrcIpAddr);
				if (ArpEntry == NULL)
				{
					//
					// Create a new ArpEntry for the (SrcIpAddr, ArcAtmAddress) pair
					//
					ArpEntry = ArpSAddArpEntry(pIntF, SrcIpAddr, &SrcHwAddr.Address, SrcHwAddr.SubAddress, Vc);
				}
				else if (COMP_HW_ADDR(&ArpEntry->HwAddr, &SrcHwAddr) &&
						 COMP_HW_ADDR(&ArpEntry->HwAddr, &Vc->HwAddr))
				{
					//
					// Reset timer on this ArpEntry
					//
					ArpSTimerCancel(&ArpEntry->Timer);
					ArpEntry->Age = ARP_AGE;
					ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
				}
			}
	
			RELEASE_MUTEX(&pIntF->ArpCacheMutex);
		} while (FALSE);

		if (SendReply && (Vc->NdisVcHandle != NULL))
		{
			if (SendNAK)
			{
				pIntF->ArpStats.Naks++;
			}
			else
			{
				pIntF->ArpStats.Acks++;
			}
			
			NDIS_SET_PACKET_STATUS(Pkt, NDIS_STATUS_SUCCESS);
			NdisCoSendPackets(Vc->NdisVcHandle, &Pkt, 1);
		}
		else
		{
			pIntF->ArpStats.DiscardedRecvPkts++;
		
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
			ArpSDereferenceVc(Vc, FALSE, TRUE);
		}
	} while (TRUE);

	KeSetEvent(&ArpSReqThreadEvent, 0, FALSE);

	DBGPRINT(DBG_LEVEL_WARN,
			("ArpSReqThread: Terminating\n"));
}


UINT
ArpSHandleArpRequest(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle an incoming arp request from the network. Do minimal checks,
	make a copy of the packet and queue it up.

Arguments:

	ProtocolBindingContext	Pointer to the INTF
	ProtocolVcContext		Pointer to the Vc
	Packet					Pointer to the packet

Return Value:

	Ref count on this received packet. This is 0 if we are done with
	the packet here, and 1 if we hang on to it (as for Multicast data
	that is forwarded).

--*/
{
	PARP_VC				Vc = (PARP_VC)ProtocolVcContext;
	PINTF				pIntF = (PINTF)ProtocolBindingContext;
	PARPS_HEADER		Header;
	PMARS_HEADER		MHdr;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	UINT				PktLen, Tmp;
	BOOLEAN				ValidPkt, Mars;
	PSLIST_ENTRY	    List;
	UINT				ReturnValue;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSHandleArpRequest: Request on Vc %lx, Id %lx\n", Vc, Vc->VcId));


	ReturnValue = 0;

	do
	{
		//
		// Verify minimum packet length
		//
		NdisQueryPacket(Packet, NULL, NULL, NULL, &PktLen);
		if (PktLen < sizeof(ARPS_HEADER))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Invalid PktLen %d for received packet %lx\n",
					PktLen, Packet));

			//
			// For statistics purposes, we consider these to be discarded multicast data
			// packets.
			//
			pIntF->MarsStats.TotalMCDataPkts++;
			pIntF->MarsStats.DiscardedMCDataPkts++;
			break;
		}

		//
		// Check if this is Multicast data. If so, forward it
		// and quit.
		//
		NdisQueryBuffer(Packet->Private.Head, &Header, &Tmp);
			
		if (COMP_MEM(&Header->LlcSnapHdr, &MarsData1LlcSnapHdr, sizeof(LLC_SNAP_HDR)))
		{
			PNDIS_PACKET		pNewPacket;
			pIntF->MarsStats.TotalMCDataPkts++;
			//
			// Check if the miniport wants this packet back immediately.
			// If so, don't reuse it.
			//
			if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES)
			{
				ReturnValue = 0;

				pIntF->MarsStats.DiscardedMCDataPkts++;
				
				break;
			}

			pNewPacket = MarsAllocPacketHdrCopy(Packet);
			if (pNewPacket != (PNDIS_PACKET)NULL)
			{
				pIntF->MarsStats.ReflectedMCDataPkts++;
				MarsSendOnClusterControlVc(pIntF, pNewPacket);
				ReturnValue = 1;
			}
			break;
		}

		//
		// This must be an ARP or MARS control packet. We make a copy and queue
		// this to the appropriate thread (ARPS or MARS).
		// 

		pIntF->ArpStats.TotalRecvPkts++;
		//
		// Make sure that a larger packet wil not trash local packet after copy
		//
		if (PktLen > PKT_SPACE)
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Incoming packet too large, truncating - %d, Vc %lx\n",
					PktLen, Vc));
			PktLen = PKT_SPACE;
		}

		//
		// Allocate a packet from our free pool. The contents from the packet from the adapter is copied into
		// this after verification and queued to the thread. If we fail to allocate, we simply drop the request.
		//
		List = ExInterlockedPopEntrySList(&ArpSPktList, &ArpSPktListLock);
		if (List == NULL)
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Out of packets - interface %lx, Vc %lx\n",
					pIntF, Vc));
			pIntF->ArpStats.DiscardedRecvPkts++;
			break;
		}
	
		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, FreeList);
		Resd->Flags = 0;
		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

		//
		// Adjust Length of packet to reflect the size of the received packet.
		// We adjust it again to size when we reply.
		//
		if (Pkt->Private.Head == NULL)
		{
		    DbgPrint("ATMARPS: HandleArpReq: Pkt %p has NULL head!\n", Pkt);
		    DbgBreakPoint();
		}

		if ((Pkt->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) == 0)
		{
			DbgPrint("ATMARPS: HandleArpReq: Pkt %p is freed?\n", Pkt);
			DbgBreakPoint();
		}

		NdisAdjustBufferLength(Pkt->Private.Head, PktLen);
		Pkt->Private.ValidCounts = FALSE;
		NdisCopyFromPacketToPacket(Pkt,
								   0,
								   PktLen,
								   Packet,
								   0,
								   &Tmp);
		ASSERT(Tmp == PktLen);
		ASSERT( PktLen < 65536);
		Resd->PktLen = (USHORT) PktLen;

		//
		// The incoming packet is now copied to our packet.
		// Examine and sanity check before queuing it.
		//
		NdisQueryBuffer(Pkt->Private.Head, &Header, &Tmp);
		Resd->PacketStart = (PUCHAR)Header;
		MHdr = (PMARS_HEADER)Header;

		do
		{
			ValidPkt = FALSE;		// Assume the worst

			//
			// Check for the LLC SNAP Header
			//
			if (COMP_MEM(&Header->LlcSnapHdr, &ArpSLlcSnapHdr, sizeof(LLC_SNAP_HDR)))
			{
				Mars = FALSE;
			}
			else if	(COMP_MEM(&Header->LlcSnapHdr, &MarsCntrlLlcSnapHdr, sizeof(LLC_SNAP_HDR)))
			{
				if ((MHdr->HwType == MARS_HWTYPE)			&&
					(MHdr->Protocol == IP_PROTOCOL_TYPE)	&&
					ArpSReferenceVc(Vc, TRUE))
				{
					Mars = TRUE;
					ValidPkt = TRUE;
				}
				break;
			}
			else
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("ArpSHandleArpRequest: Invalid Llc Snap Hdr\n"));
				break;
			}

			Tmp = sizeof(ARPS_HEADER) +
					Header->SrcProtoAddrLen + TL_LEN(Header->SrcAddressTL) + TL_LEN(Header->SrcSubAddrTL) +
					Header->DstProtoAddrLen + TL_LEN(Header->DstAddressTL) + TL_LEN(Header->DstSubAddrTL);

			//
			// Make sure the address and sub-address formats are consistent.
			// The valid ones from the RFC:
			//
			//					Adress				Sub-Address
			//					------				-----------
			// 
			// Structure 1		ATM Forum NSAP		Null
			// Structure 2		E.164				Null
			// Structure 3		E.164				ATM Forum NSAP
			//
			if (TL_LEN(Header->SrcSubAddrTL) > 0)
			{
				//
				// Sub-address is present. Make sure that the Address is E.164 and Sub-Address is NSAP
				//
				if ((TL_TYPE(Header->SrcAddressTL) == ADDR_TYPE_NSAP) ||
                    (TL_TYPE(Header->SrcSubAddrTL) == ADDR_TYPE_E164))
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Src Address is NSAP and Src Sub Addr is E164\n"));
					break;
				}
			}

			if (TL_LEN(Header->DstSubAddrTL) > 0)
			{
				//
				// Sub-address is present. Make sure that the Address is E.164 and Sub-Address is NSAP
				//
				if ((TL_TYPE(Header->DstAddressTL) == ADDR_TYPE_NSAP) ||
                    (TL_TYPE(Header->DstSubAddrTL) == ADDR_TYPE_E164))
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Dst Address is NSAP and Dst Sub Addr is E164\n"));
					break;
				}
			}

			if ((Header->Opcode == ATMARP_Request)		&&
				(Header->HwType == ATM_HWTYPE)			&&
				(Header->Protocol == IP_PROTOCOL_TYPE)	&&
				(PktLen >= Tmp)							&&
				ArpSReferenceVc(Vc, TRUE))
			{
				ValidPkt = TRUE;
				break;
			}
#if DBG
			else
			{
				if (Header->Opcode != ATMARP_Request)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid OpCode %x\n", Header->Opcode));
				}
				else if (Header->HwType != ATM_HWTYPE)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid HwType %x\n", Header->HwType));
				}
				else if (Header->Protocol == IP_PROTOCOL_TYPE)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid Protocol %x\n", Header->Protocol));
				}
				else if (PktLen < Tmp)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid Length %x - %x\n", PktLen, Tmp));
				}
				else
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Cannot reference Vc\n"));
				}
			}
#endif
		} while (FALSE);

		if (ValidPkt)
		{
			Resd->Vc = Vc;
			if (Mars)
			{
				Resd->Flags |= RESD_FLAG_MARS;
				KeInsertQueue(&MarsReqQueue, &Resd->ReqList);
			}
			else
			{
				Resd->Flags &= ~RESD_FLAG_MARS;
				KeInsertQueue(&ArpSReqQueue, &Resd->ReqList);
			}
		}
		else
		{
			//
			// Either a mal-formed packet or the Vc is closing
			//
			pIntF->ArpStats.DiscardedRecvPkts++;
			ArpSDumpPacket((PUCHAR)Header, PktLen);

			//
			// Move the packet back into the free list
			//
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		
		}
	} while (FALSE);

	return ReturnValue;
}


PARP_ENTRY
ArpSLookupEntryByIpAddr(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr
	)
/*++

Routine Description:

	Lookup the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF	Pointer to the IntF structure
	IpAddr	IP address to look for

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry;
	UINT		Hash = ARP_HASH(IpAddr);

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSLookupArpEntry: Lookup entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	for (ArpEntry = pIntF->ArpCache[Hash];
		 ArpEntry != NULL;
		 ArpEntry = ArpEntry->Next)
	{
		if (ArpEntry->IpAddr == IpAddr)
			break;
		if (ArpEntry->IpAddr > IpAddr)
		{
			ArpEntry = NULL;
			break;
		}
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("%sFound\n", (ArpEntry != NULL) ? "" : "Not"));

	if (ArpEntry != NULL)
	{
		//
		// Cleanup this entry if the Vc is no-longer active
		//
		CLEANUP_DEAD_VC(ArpEntry);
	}

	return ArpEntry;
}


PARP_ENTRY
ArpSLookupEntryByAtmAddr(
	IN	PINTF					pIntF,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL
	)
/*++

Routine Description:

	Lookup the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF	Pointer to the IntF structure
	IpAddr	IP address to look for

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry;
	UINT		i;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSLookupArpEntry: Lookup entry for "));
	ArpSDumpAtmAddr(Address, " ..... ");
	if (SubAddress != NULL)
	{
		ArpSDumpAtmAddr(SubAddress, "\t Sub ");
	}
	for (i =0; i < ARP_TABLE_SIZE; i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
			 ArpEntry != NULL;
			 ArpEntry = ArpEntry->Next)
		{
			if (COMP_ATM_ADDR(Address, &ArpEntry->HwAddr.Address))
			{
				if (((SubAddress == NULL) && (ArpEntry->HwAddr.SubAddress == NULL)) ||
					(((SubAddress != NULL) && (ArpEntry->HwAddr.SubAddress != NULL)) &&
					 COMP_ATM_ADDR(SubAddress, ArpEntry->HwAddr.SubAddress)))
				{
					break;
				}
			}
		}
		if (ArpEntry != NULL)
		{
			//
			// Cleanup this entry if the Vc is no-longer active
			//
			CLEANUP_DEAD_VC(ArpEntry);
			break;
		}
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("ArpSLookupArpEntry: %sFound\n", (ArpEntry != NULL) ? "" : "Not"));

	return ArpEntry;
}


PARP_ENTRY
ArpSAddArpEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL,
	IN	PARP_VC					Vc			OPTIONAL
	)
/*++

Routine Description:

	Add the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF		Pointer to the IntF structure
	IpAddr		IP address to add
	Address &
	SubAddress	Supplies the atm address and the sub-address
	Vc			The Vc associated with this ArpEntry, if any

Return Value:

	ArpEntry if added successfully or NULL.
--*/
{
	PARP_ENTRY	ArpEntry, *ppEntry;
	UINT		Hash = ARP_HASH(IpAddr);
	ENTRY_TYPE	EntryType;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAddArpEntry: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	//
	// Start off by allocating an arp-entry structure
	//
    EntryType = (SubAddress != NULL) ? ARP_BLOCK_SUBADDR : ARP_BLOCK_VANILA;
	ArpEntry = (PARP_ENTRY)ArpSAllocBlock(pIntF, EntryType);
	if (ArpEntry == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{
		if (++(pIntF->ArpStats.CurrentArpEntries) > pIntF->ArpStats.MaxArpEntries)
		{
			pIntF->ArpStats.MaxArpEntries = pIntF->ArpStats.CurrentArpEntries; 
		}
		
		ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);
		ArpEntry->IpAddr = IpAddr;
		COPY_ATM_ADDR(&ArpEntry->HwAddr.Address, Address);
		if (SubAddress != NULL)
			COPY_ATM_ADDR(ArpEntry->HwAddr.SubAddress, SubAddress);
		if (ARGUMENT_PRESENT(Vc) && ArpSReferenceVc(Vc, FALSE))
		{
			ArpEntry->Vc = Vc;
			Vc->ArpEntry = ArpEntry;
		}
		ArpEntry->Age = ARP_AGE;

		//
		// Keep the overflow list sorted in ascending order of Ip addresses
		//
		for (ppEntry = &pIntF->ArpCache[Hash];
			 *ppEntry != NULL;
			 ppEntry = (PARP_ENTRY *)(&(*ppEntry)->Next))
		{
			ASSERT ((*ppEntry)->IpAddr != IpAddr);
			if ((*ppEntry)->IpAddr > IpAddr)
				break;
		}

		ArpEntry->Next = *ppEntry;
		ArpEntry->Prev = ppEntry;
		if (*ppEntry != NULL)
		{
			(*ppEntry)->Prev = &ArpEntry->Next;
		}
		*ppEntry = ArpEntry;
		pIntF->NumCacheEntries ++;

		ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%lx\n", ArpEntry));

	return ArpEntry;
}


PARP_ENTRY
ArpSAddArpEntryFromDisk(
	IN	PINTF					pIntF,
	IN	PDISK_ENTRY				pDskEntry
	)
/*++

Routine Description:

	Add the Arp table for the specified IP address. Called during intialization.

Arguments:

	pIntF		Pointer to the IntF structure
	DiskEntry	
	

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry, *ppEntry;
	UINT		Hash = ARP_HASH(pDskEntry->IpAddr);
	ENTRY_TYPE	EntryType;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAddArpEntryFromDisk: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(pDskEntry->IpAddr, " ..... ");

	//
	// Start off by allocating an arp-entry structure
	//
    EntryType = (pDskEntry->AtmAddr.SubAddrLen != 0) ? ARP_BLOCK_SUBADDR : ARP_BLOCK_VANILA;
	ArpEntry = (PARP_ENTRY)ArpSAllocBlock(pIntF, EntryType);
	if (ArpEntry == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{
		ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);
		ArpEntry->Age = ARP_AGE;
		ArpEntry->IpAddr = pDskEntry->IpAddr;
		ArpEntry->Vc = NULL;

		//
		// COPY_ATM_ADDR();
		//
		ArpEntry->HwAddr.Address.AddressType = pDskEntry->AtmAddr.AddrType;
		ArpEntry->HwAddr.Address.NumberOfDigits = pDskEntry->AtmAddr.AddrLen;
		COPY_MEM(ArpEntry->HwAddr.Address.Address, pDskEntry->AtmAddr.Address, pDskEntry->AtmAddr.AddrLen);

		if (pDskEntry->AtmAddr.SubAddrLen != 0)
		{
			//
			// COPY_ATM_ADDR();
			//
			ArpEntry->HwAddr.SubAddress->AddressType = pDskEntry->AtmAddr.SubAddrType;
			ArpEntry->HwAddr.SubAddress->NumberOfDigits = pDskEntry->AtmAddr.SubAddrLen;
			COPY_MEM(ArpEntry->HwAddr.SubAddress->Address,
					 (PUCHAR)pDskEntry + sizeof(DISK_ENTRY),
					 pDskEntry->AtmAddr.SubAddrLen);
		}

		//
		// Keep the overflow list sorted in ascending order of Ip addresses
		//
		for (ppEntry = &pIntF->ArpCache[Hash];
			 *ppEntry != NULL;
			 ppEntry = (PARP_ENTRY *)(&(*ppEntry)->Next))
		{
			ASSERT ((*ppEntry)->IpAddr != pDskEntry->IpAddr);
			if ((*ppEntry)->IpAddr > pDskEntry->IpAddr)
				break;
		}

		ArpEntry->Next = *ppEntry;
		ArpEntry->Prev = ppEntry;
		if (*ppEntry != NULL)
		{
			(*ppEntry)->Prev = &ArpEntry->Next;
		}
		*ppEntry = ArpEntry;
		pIntF->NumCacheEntries ++;

		ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%lx\n", ArpEntry));

	return ArpEntry;
}


VOID
ArpSUpdateArpEntry(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PARP_VC					Vc
	)
/*++

Routine Description:

	Update the ArpEntry with possibly new values.

Arguments:

	ArpEntry		ArpEntry to be updated
	IpAddr			IP Address
	HwAddr			Hw address (Atm Address and optionally Atm SubAddress)
	Vc				Vc associated with this entry

Return Value:

	None

--*/
{
	KIRQL	OldIrql;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSUpdateArpEntry: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	ASSERT ((ArpEntry->Vc == NULL) || (ArpEntry->Vc == Vc));
	ASSERT (ArpEntry->IpAddr == IpAddr);

	//
	// If the Hw address changed, make sure that there is enough space there to copy the new address
	//
	if ((HwAddr->SubAddress != NULL) ^ (ArpEntry->HwAddr.SubAddress != NULL))
	{
		PARP_ENTRY	*ppEntry, ArpEntryNew;

		//
		// Need to allocate a new ArpEntry. First de-queue the current
		// entry from the list and cancel the timer.
		//
		ArpSTimerCancel(&ArpEntry->Timer);
		*(ArpEntry->Prev) = ArpEntry->Next;
		if (ArpEntry->Next != NULL)
			((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
		pIntF->NumCacheEntries --;

		//
		// We create the new ArpEntry with a NULL Vc and then update it. This is to avoid
		// de-ref and ref of the Vc again.
		//
		ArpEntryNew = ArpSAddArpEntry(pIntF, IpAddr, &HwAddr->Address, HwAddr->SubAddress, NULL);

		if (ArpEntryNew == NULL)
		{
			//
			// Allocation failure, link back the old entry and bail out.
			//
			if (ArpEntry->Next != NULL)
			{
				((PENTRY_HDR)(ArpEntry->Next))->Prev = &ArpEntry;
			}

			*(ArpEntry->Prev) = ArpEntry;

			ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);

			pIntF->NumCacheEntries ++;

			return;
		}

        //
        // Update with the existing Vc for now.
        //
        ArpEntryNew->Vc = ArpEntry->Vc;

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		ASSERT((Vc->ArpEntry == ArpEntry) || (Vc->ArpEntry == NULL));
		if (Vc->Flags & ARPVC_ACTIVE)
		{
			Vc->ArpEntry = ArpEntryNew;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		ArpSFreeBlock(ArpEntry);

		ArpEntry = ArpEntryNew;
	}
	else
	{
		ArpEntry->Age = ARP_AGE;
	}

	if (ArpEntry->Vc != Vc)
	{
		ASSERT(ArpEntry->Vc == NULL);
		if (ArpSReferenceVc(Vc, FALSE))
		{
			ArpEntry->Vc = Vc;
		}
	}

	COPY_HW_ADDR(&ArpEntry->HwAddr, HwAddr);
}


VOID
ArpSBuildArpReply(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	PARPS_HEADER			Header,
	IN	PNDIS_PACKET			Pkt
	)
/*++

Routine Description:


Arguments:


Return Value:

	None

--*/
{
	PUCHAR	pSrc, pDst, pDstOld;
	UINT	Tmp, SrcLenOld, SrcLenNew, DstLenNew;

	//
	// Most of the fields are already valid (or else we will not be here)
	//
	Header->Opcode = ATMARP_Reply;

	pSrc = (PUCHAR)Header + sizeof(ARPS_HEADER);
	SrcLenOld = DstLenNew = IP_ADDR_LEN + TL_LEN(Header->SrcAddressTL) + TL_LEN(Header->SrcSubAddrTL);

	SrcLenNew = IP_ADDR_LEN + ArpEntry->HwAddr.Address.NumberOfDigits;
	if (ArpEntry->HwAddr.SubAddress != NULL)
		SrcLenNew += ArpEntry->HwAddr.SubAddress->NumberOfDigits;
	pDst = pSrc + SrcLenNew;

	//
	// Fill in the new destination fields from the source fields of the request
	//
	Header->DstAddressTL = Header->SrcAddressTL;
	Header->DstSubAddrTL = Header->SrcSubAddrTL;
	Header->DstProtoAddrLen = Header->SrcProtoAddrLen;
	MOVE_MEM(pDst, pSrc, DstLenNew);

	//
	// Fill in the destination fields
	//
	Header->DstAddressTL = TL(ArpEntry->HwAddr.Address.AddressType, ArpEntry->HwAddr.Address.NumberOfDigits);
	Header->DstSubAddrTL = 0;
	if (ArpEntry->HwAddr.SubAddress != NULL)
	{
		Header->DstSubAddrTL =
					TL(ArpEntry->HwAddr.SubAddress->AddressType, ArpEntry->HwAddr.SubAddress->NumberOfDigits);
	}
	Header->DstProtoAddrLen = IP_ADDR_LEN;

	Tmp = ArpEntry->HwAddr.Address.NumberOfDigits;
	COPY_MEM(pSrc, ArpEntry->HwAddr.Address.Address, Tmp);
	if (ArpEntry->HwAddr.SubAddress != NULL)
	{
		COPY_MEM(pSrc + Tmp,
				 ArpEntry->HwAddr.SubAddress->Address,
				 ArpEntry->HwAddr.SubAddress->NumberOfDigits);
		Tmp += ArpEntry->HwAddr.SubAddress->NumberOfDigits;
	}

	*(UNALIGNED IPADDR *)(pSrc + Tmp) = ArpEntry->IpAddr;

	DBGPRINT(DBG_LEVEL_INFO,
	 ("BuildReply: Pkt=0x%lx MDL=0x%lx: sz=%lu bc=%lu bo=%lu new bc=%lu\n",
	 Pkt,
	 Pkt->Private.Head,
	 Pkt->Private.Head->Size,
	 Pkt->Private.Head->ByteCount,
	 Pkt->Private.Head->ByteOffset,
	 SrcLenNew + DstLenNew + sizeof(ARPS_HEADER)));

	//
	// Finally set the Pkt length correctly
	//
	NdisAdjustBufferLength(Pkt->Private.Head, SrcLenNew + DstLenNew + sizeof(ARPS_HEADER));
	Pkt->Private.ValidCounts = FALSE;
}


BOOLEAN
ArpSAgeEntry(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Check this ARP entry and if it ages out, free it.

Arguments:

Return Value:


--*/
{
	PARP_ENTRY	ArpEntry;
	BOOLEAN		rc;

	ArpEntry = CONTAINING_RECORD(Timer, ARP_ENTRY, Timer);

	ArpEntry->Age --;
	if (TimerShuttingDown || (ArpEntry->Age == 0))
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAgeEntry: Aging out entry for IpAddr %lx\n", ArpEntry->IpAddr));

		pIntF->ArpStats.CurrentArpEntries--;
		
		if (ArpEntry->Next != NULL)
		{
			((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
		}
		*(ArpEntry->Prev) = ArpEntry->Next;
		pIntF->NumCacheEntries --;
	
		//
		// if there is an open Vc, make sure it is not pointing to this arpentry
		//
		CLEANUP_DEAD_VC(ArpEntry);
		ArpSFreeBlock(ArpEntry);
		rc = FALSE;
	}
	else
	{
		//
		// Cleanup dead vcs
		//
		CLEANUP_DEAD_VC(ArpEntry);
		rc = TRUE;
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAgeEntry: IpAddr %lx age %02d:%02d\n",
				ArpEntry->IpAddr, ArpEntry->Age/4, (ArpEntry->Age % 4) * 15));
	}

	return rc;
}

BOOLEAN
ArpSDeleteIntFAddresses(
	IN	PINTF					pIntF,
	IN	INT						NumAddresses,
	IN	PATM_ADDRESS			AddrList
	)
//
// Return TRUE IFF the  NdisCoRequest has been called EXACTLY NumAddresses times.
//
{
	PNDIS_REQUEST		NdisRequest;
	NDIS_STATUS			Status;
	PCO_ADDRESS			pCoAddr;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSDeleteIntFAddresses: pIntF %p: %Z, NumAddr %d\n", pIntF, &pIntF->InterfaceName, NumAddresses));

	while (NumAddresses--)
	{
		NdisRequest = ALLOC_NP_MEM(sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS), POOL_TAG_REQ);
		if (NdisRequest == NULL)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
			return FALSE;
		}

		ZERO_MEM(NdisRequest, sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS));
		NdisRequest->RequestType = NdisRequestSetInformation;
		NdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_DELETE_ADDRESS;
		NdisRequest->DATA.SET_INFORMATION.InformationBuffer = (PUCHAR)NdisRequest + sizeof(NDIS_REQUEST);
		NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

		//
		// Copy the address into the request
		//
        pCoAddr = NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
		pCoAddr->AddressSize = sizeof(ATM_ADDRESS);
		*(PATM_ADDRESS)(pCoAddr->Address) = *AddrList++;

		if (pIntF->NdisAfHandle == NULL)
		{
			//
			// Can happen if ATMUNI was unbound and we closed the AF handle
			// on receiving an OID_CO_AF_CLOSE.
			//
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			Status = NdisCoRequest(pIntF->NdisBindingHandle,
							   	   pIntF->NdisAfHandle,
							   	   NULL,
							   	   NULL,
							   	   NdisRequest);
		}

		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCoRequestComplete(Status, pIntF, NULL, NULL, NdisRequest);
		}
	}

	return TRUE;
		
}


VOID
ArpSQueryAndSetAddresses(
	IN	PINTF					pIntF
	)
{
	PNDIS_REQUEST		NdisRequest;
	PCO_ADDRESS			pCoAddr;
	NDIS_STATUS			Status;
	UINT				Size;

	DBGPRINT(DBG_LEVEL_INFO, ("Querying current address\n"));

	//
	// Allocate a request to query the configured address
	//
	Size = sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS_LIST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
	NdisRequest = ALLOC_NP_MEM(Size, POOL_TAG_REQ);
	if (NdisRequest == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return;
	}

	ZERO_MEM(NdisRequest, Size);
	NdisRequest->RequestType = NdisRequestQueryInformation;
	NdisRequest->DATA.QUERY_INFORMATION.Oid = OID_CO_GET_ADDRESSES;
	NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = ((PUCHAR)NdisRequest + sizeof(NDIS_REQUEST));
	NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = Size - sizeof(NDIS_REQUEST);

	if (pIntF->NdisAfHandle == NULL)
	{
		Status = NDIS_STATUS_FAILURE;
	}
	else
	{
		Status = NdisCoRequest(pIntF->NdisBindingHandle,
						   	   pIntF->NdisAfHandle,
						   	   NULL,
						   	   NULL,
						   	   NdisRequest);
	}

	if (Status != NDIS_STATUS_PENDING)
	{
		ArpSCoRequestComplete(Status, pIntF, NULL, NULL, NdisRequest);
	}
}


VOID
ArpSValidateAndSetRegdAddresses(
	IN	PINTF			pIntF,	// LOCKIN NOLOCKOUT
	IN	KIRQL			OldIrql
	)
/*++
	Initiate the 1st step of the following operations, which complete asynchronously
	and in order:
	   - Validate 1st address to be registered (by making a call to the dest - if
	   	 it fails we consider the address validated).
	   - (on successful validation) Register the address with the call manager.
	   - Validate the 2nd address
	   - (on successful validation) Register the 2nd address
	   - etc..
--*/
{
	PNDIS_REQUEST		NdisRequest;
	PCO_ADDRESS			pCoAddr;
	UINT				Size;
	INT					fLockReleased;
	PREG_ADDR_CTXT		pRegAddrCtxt;

	DBGPRINT(DBG_LEVEL_INFO, ("Validating and setting regd. addresses\n"));

	pRegAddrCtxt 	= NULL;
	fLockReleased 	= FALSE;

	do
	{
		//
		// The state on the ongoing validation and registration process is
		// maintained in pIntF->pRegAddrCtxt, which we allocate and initialize
		// here.
		//

		if (pIntF->pRegAddrCtxt != NULL)
		{
			//
			//  There is ongoing work relating to registering already!
            //  This could happen if we get an  OID_CO_ADDRESS_CHANGE when we are
            //  either processing an earlier one, or are in the process of
            //  initializing. We get these cases during pnp stress
            // ( 1c_reset script against an Olicom 616X) -- Whistler bug#102805
			//
			break;
		}

		if (pIntF->NumAddressesRegd >= pIntF->NumAllocedRegdAddresses)
		{
			ASSERT(pIntF->NumAddressesRegd == pIntF->NumAllocedRegdAddresses);

			//
			// No addresses to register.
			//
			DBGPRINT(DBG_LEVEL_INFO, ("ValAndSet: No addresses to register.\n"));
			break;
		}
		
		pRegAddrCtxt = ALLOC_NP_MEM(sizeof(*pRegAddrCtxt), POOL_TAG_REQ);

		if (pRegAddrCtxt == NULL)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
			break;
		}

		ZERO_MEM(pRegAddrCtxt, sizeof(*pRegAddrCtxt));

		//
		// Attach the context to the IF and add a reference.
		// (Can't have the lock when adding the reference)
		//

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		if (!ArpSReferenceIntF(pIntF))
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValAndSet: ERROR: Couldn't ref IntF. .\n"));
			//  Couldn't reference the IF. Fail.
			//
			fLockReleased = TRUE;
			break;
		}
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		if (pIntF->pRegAddrCtxt != NULL)
		{
			//
			//  Someone snuck in while we unlocked the IF above!
			//  We bail out.
			//
			ASSERT(FALSE);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			ArpSDereferenceIntF(pIntF);
			fLockReleased = TRUE;
			break;
		}

		pIntF->pRegAddrCtxt = pRegAddrCtxt;
		pRegAddrCtxt->pIntF = pIntF;
		pRegAddrCtxt = NULL; // so that it is not deallocated in this function.

		// Initiate the validation and registration of the first address.
		//
		ArpSValidateOneRegdAddress(pIntF, OldIrql);
		//
		// (Lock released by above call.)
		fLockReleased = TRUE;

		//
		// The remainder of the validation and registration process happens 
		// asynchronously.
		//

	} while (FALSE);

	if (pRegAddrCtxt != NULL)
	{
		FREE_MEM(pRegAddrCtxt);
	}

	if (!fLockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
}


VOID
ArpSValidateOneRegdAddress(
	IN	PINTF			pIntF,	// LOCKIN NOLOCKOUT
	IN	KIRQL			OldIrql
	)
/*++

Routine Description:

	Initiates the validation and registration of a single address.
	"Initiate" consists of creating a vc and making a call to the address. The
	next step in the process happens after the make call completes
	(see  05/14/1999 notes.txt entry ("Rogue ARP server detection contd."))
	for more details.

	One more thing: If there are no addresses to be validated, then
	this function will DEREF pIntF and FREE pIntF->pRegAddrCtxt (which
	MUST be NON-NULL).

Arguments:

	pIntF		Pointer to the interface block.
	OldIrql		Irql before pIntF was locked.

--*/
{
	NDIS_STATUS Status;
	INT			fLockReleased = FALSE;
	INT			fFreeContext  = TRUE;

	DBGPRINT(
		DBG_LEVEL_INFO,
		 ("==>ValidateOneRegAddress(pIntF=0x%p; pCtxt=0x%p).\n",
		 	pIntF,
			pIntF->pRegAddrCtxt));

	do
	{
		PREG_ADDR_CTXT		pRegAddrCtxt;
		PATM_ADDRESS		pDestAtmAddress;
		pRegAddrCtxt = pIntF->pRegAddrCtxt;

		// We expect to be called only if there is a valid pRegAddrCtxt.
		//
		if (pRegAddrCtxt == NULL)
		{
			ASSERT(FALSE);
			fFreeContext = FALSE;
			break;
		}

		if (pIntF->Flags & INTF_STOPPING)
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: IF stopping, quitting.\n"));
			// Nothing left to do.
			//
			break;
		}

		if (pIntF->NumAddressesRegd >= pIntF->NumAllocedRegdAddresses)
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: nothing left to do.\n"));
			// Nothing left to do.
			//
			break;
		}

		if (pIntF->NumAddressesRegd > pRegAddrCtxt->RegAddrIndex)
		{
			// This should never happen.
			//
			ASSERT(FALSE);
			break;
		}

		if (pIntF->NumAllocedRegdAddresses <= pRegAddrCtxt->RegAddrIndex)
		{
			ASSERT(pIntF->NumAllocedRegdAddresses == pRegAddrCtxt->RegAddrIndex);

			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: nothing left to do.\n"));

			// Nothing left to do.
			//
			break;
		}

		if (pRegAddrCtxt->NdisVcHandle != NULL)
		{
			// We shouldn't be called with a non-null VcHandle.
			//
			fFreeContext = FALSE;
			ASSERT(FALSE);
			break;
		}

		// TODO: use the Flags field.
		
		//
		// There is at least one address to try to validate & register. It
		// is pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex].
		//
		
		// Create VC
		//
		Status = NdisCoCreateVc(
					pIntF->NdisBindingHandle,
					pIntF->NdisAfHandle,
					(NDIS_HANDLE)pRegAddrCtxt,
					&pRegAddrCtxt->NdisVcHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			pRegAddrCtxt->NdisVcHandle = NULL;
			break;
		}

		// Set the VC type.
		//
		pRegAddrCtxt->VcType =  VC_TYPE_CHECK_REGADDR;

		// Setup call params
		//
		pDestAtmAddress = &(pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]);
		ArpSSetupValidationCallParams(pRegAddrCtxt, pDestAtmAddress);
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
		fLockReleased = TRUE;
		fFreeContext = FALSE;

		DBGPRINT(
			DBG_LEVEL_INFO,
 			("ValOneRA: Going to make call. pCallParams=0x%p\n",
				&pRegAddrCtxt->CallParams));
		//
		// Make Call (in call complete handler we move on to the next step --
		// see  05/14/1999 notes.txt entry for details.)
		//
		Status = NdisClMakeCall(
						pRegAddrCtxt->NdisVcHandle,
						&pRegAddrCtxt->CallParams,
						NULL,
						NULL
						);
		
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSMakeRegAddrCallComplete(
						Status,
						pRegAddrCtxt
						);
			Status = NDIS_STATUS_PENDING;
		}
		
	} while (FALSE);
	
	if (fFreeContext)
	{
		ASSERT(!fLockReleased);

		//
		// If there is nothing more to be done, unlink the context.
		//
		ArpSUnlinkRegAddrCtxt(pIntF, OldIrql);
		//
		// IntF lock released in above call.
		fLockReleased = TRUE;
	}

	if (!fLockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	DBGPRINT(DBG_LEVEL_INFO, ("<==ValidateOneRegAddress.\n"));
}


BOOLEAN
ArpSReferenceIntF(
	IN	PINTF		pIntF
	)
/*++

Routine Description:

	Reference the Interface object.

Arguments:

	pIntF	Pointer to the interface block.

Return Value:

	TRUE	Referenced
	FALSE	Interface is closing, cannot reference.

--*/
{
	KIRQL	OldIrql;
	BOOLEAN	rc = TRUE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if (pIntF->Flags & INTF_CLOSING)
	{
		rc = FALSE;
	}
	else
	{
		pIntF->RefCount ++;
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	return rc;
}


PINTF
ArpSReferenceIntFByName(
	IN	PINTERFACE_NAME			pInterface
	)
/*++

Routine Description:

	Reference the Interface object by base-name.

Arguments:

	pIntF	Pointer to the interface block.

Return Value:

	TRUE	Referenced
	FALSE	Interface is closing, cannot reference.

--*/
{
	PINTF	pIntF;
	KIRQL	OldIrql;
	BOOLEAN	Found = FALSE, ref = FALSE;
	ULONG	IfIndex;

	ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);

	for (pIntF = ArpSIfList, IfIndex = 1;
		 pIntF != NULL;
		 pIntF = pIntF->Next, IfIndex++)
	{
		if (IfIndex > ArpSIfListSize)
		{
			DbgPrint("ATMARPS: RefIntByName: IF list at %p not consistent with list size %d\n",
				ArpSIfList, ArpSIfListSize);
			DbgBreakPoint();
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);	

		if ((pIntF->FriendlyName.Length == pInterface->Length) &&
			COMP_MEM(pIntF->FriendlyName.Buffer, pInterface->Buffer, pInterface->Length))
		{
			Found = TRUE;
			if ((pIntF->Flags & INTF_CLOSING) == 0)
			{
				pIntF->RefCount ++;
				ref = TRUE;
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);	

		if (Found)
			break;
	}

	if (!ref)
	{
		pIntF = NULL;
	}

	RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

	DBGPRINT(DBG_LEVEL_INFO, ("ATMARPS: RefIntfByName:[%ws]: pIntF %p\n",
		pInterface->Buffer, pIntF));

	return pIntF;
}


VOID
ArpSDereferenceIntF(
	IN	PINTF					pIntF
	)
{
	KIRQL	OldIrql;
	PINTF *	ppIntF;
	KIRQL	EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	ASSERT (pIntF->RefCount > 0);
	pIntF->RefCount --;

	if (pIntF->RefCount == 0)
	{
		BOOLEAN  bFreeIntF = FALSE;
		ASSERT (pIntF->Flags & INTF_CLOSING);


		//
		// We need to release and reacquire the lock to get the locks
		// in the right order. In the meantime, we need to keep the
		// refcount nonzero.
		//
		pIntF->RefCount = 1;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

		ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);

		pIntF->RefCount--; // Remove tmp ref added just before.

		if (pIntF->RefCount == 0)
		{
			//
			// As expected, refcount is now back to zero. Also we have
			// both list and IF lock held, so we can complete the deinit safely.
			//

			bFreeIntF = TRUE;

			//
			// Remove this Interface from the global list IF it is in the list.
			//
			for (ppIntF = &ArpSIfList; *ppIntF != NULL; ppIntF = &((*ppIntF)->Next))
			{
				if (*ppIntF == pIntF)
				{
					*ppIntF = pIntF->Next;
					ArpSIfListSize--;
					break;
				}
			}
	
			//
			// Signal anyone waiting for this to happen
			//
			if (pIntF->CleanupEvent != NULL)
			{
				KeSetEvent(pIntF->CleanupEvent, IO_NETWORK_INCREMENT, FALSE);
			}
		}
		else
		{
			//
			// Some other thread has snuck in and referenced the IF. We
			// don't do anything here.
			//
		}

		RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);
		RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

		if (bFreeIntF)
		{
			FREE_MEM(pIntF);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
	}

	ARPS_CHECK_IRQL(EntryIrql);
}


BOOLEAN
ArpSReferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					bSendRef
	)
/*++

Routine Description:

	Reference the VC.

Arguments:

	Vc			Pointer to the VC.
	bSendRef	Is this a "pending send" reference?

Return Value:

	TRUE	Referenced
	FALSE	Interface or VC is closing, cannot reference.

--*/
{
	PINTF	pIntF = Vc->IntF;
	KIRQL	OldIrql;
	BOOLEAN	rc = TRUE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if ((Vc->Flags & (ARPVC_CLOSING | ARPVC_CLOSE_PENDING)) != 0)
	{
		rc = FALSE;
	}
	else
	{
		Vc->RefCount ++;
		if (bSendRef)
		{
			Vc->PendingSends ++;
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	return rc;
}


VOID
ArpSDereferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					KillArpEntry,
	IN	BOOLEAN					bSendComplete
	)
{
	PINTF	pIntF = Vc->IntF;
	KIRQL	OldIrql;
	BOOLEAN	bInitiateClose = FALSE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if (bSendComplete)
	{
		Vc->PendingSends--;
	}

	ASSERT (Vc->RefCount > 0);
	Vc->RefCount --;

	if (Vc->RefCount == 0)
	{
		ASSERT ((Vc->Flags & ARPVC_ACTIVE) == 0);
		ASSERT (Vc->ArpEntry == NULL);

		//
		// Do other cleanup here
		//
		RemoveEntryList(&Vc->List);

		FREE_MEM(Vc);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
		ArpSDereferenceIntF(pIntF);
	}
	else
	{
		if (KillArpEntry)
		{
			DBGPRINT(DBG_LEVEL_WARN,
					("Cleaning dead vc from vc %lx, arpentry %lx\n", Vc, Vc->ArpEntry));
			Vc->ArpEntry = NULL;
		}

		if ((Vc->PendingSends == 0) &&
			(Vc->Flags & ARPVC_CLOSE_PENDING))
		{
			bInitiateClose = TRUE;
			Vc->Flags |= ARPVC_CLOSING;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

		if (bInitiateClose)
		{
			ArpSInitiateCloseCall(Vc);
		}
	}
}


VOID
ArpSSleep(
	IN	UINT				TimeInMs
	)
{
#define	NUM_100ns_PER_ms	-10000L
	KTIMER			SleepTimer;
	LARGE_INTEGER	TimerValue;
	NTSTATUS		Status;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_WARN,
			("=>ArpSSleep(%d)\n", TimeInMs));

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	KeInitializeTimer(&SleepTimer);

	TimerValue.QuadPart = Int32x32To64(TimeInMs, NUM_100ns_PER_ms);
	KeSetTimer(&SleepTimer,
			   TimerValue,
			   NULL);

	WAIT_FOR_OBJECT(Status, &SleepTimer, NULL);

	DBGPRINT(DBG_LEVEL_WARN,
			("ArpSSleep: woken up, Status 0x%x\n", Status));

//	ASSERT (Status == STATUS_TIMEOUT);
}


VOID
ArpSFreeGlobalData(
	VOID
	)
{
}


#if	DBG

VOID
ArpSDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO, (" PacketDump: "));
	for (i = 0; i < PktLen; i++)
	{
		DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", Packet[i]));
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}

VOID
ArpSDumpAddress(
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PCHAR					String
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO,
			(" %s IpAddr: ", String));
	ArpSDumpIpAddr(IpAddr, "");
	ArpSDumpAtmAddr(&HwAddr->Address, ", ");

	if (HwAddr->SubAddress != NULL)
	{
		ArpSDumpAtmAddr(HwAddr->SubAddress, "\tSub ");
	}
}

VOID
ArpSDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	)
{
	PUCHAR	p = (PUCHAR)&IpAddr;

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("%d.%d.%d.%d%s", p[0], p[1], p[2], p[3], String));
}

VOID
ArpSDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%sAtmAddr (%s, %d): ",
			String,
			(AtmAddr->AddressType == ATM_E164) ? "E164" : "NSAP",
			AtmAddr->NumberOfDigits));
	for (i = 0; i < AtmAddr->NumberOfDigits; i++)
	{
		DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", AtmAddr->Address[i]));
	}
	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}


#endif


VOID
ArpSSetupValidationCallParams(
		PREG_ADDR_CTXT  pRegAddrCtxt, // LOCKIN LOCKOUT (pIntF lock)
		PATM_ADDRESS 	pAtmAddr
		)
/*++

Routine Description:

	Sets up the call parameters for a validation call (call to verify that
	another server with the same address doesn't exist.).

Arguments:

	pRegAddrCtxt	Pointer to the context used to validate and register the address.
					pRegAddrCtxt->CallParams is filled with the call params.
	pAtmAddr		Destination address.

--*/
{
	NDIS_STATUS								Status;
	PINTF									pIntF;

	//
	//  Set of parameters for a MakeCall
	//
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;
	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Total space requirements for the MakeCall
	//
	ULONG									RequestSize;

	pIntF = pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	//
	//  Zero out call params. Don't remove this!
	//
	ZERO_MEM(&pRegAddrCtxt->CallParams, sizeof(pRegAddrCtxt->CallParams));
	ZERO_MEM(&pRegAddrCtxt->Buffer, sizeof(pRegAddrCtxt->Buffer));

	//
	//  Distribute space amongst the various structures
	//
	pCallParameters	   = &pRegAddrCtxt->CallParams;
	pCallMgrParameters = &pRegAddrCtxt->CmParams;

	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						REGADDR_MAKE_CALL_IE_SPACE;

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Transmit.TokenBucketSize = 9188;
	pCallMgrParameters->Transmit.MaxSduSize = 9188;
	pCallMgrParameters->Transmit.PeakBandwidth = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Transmit.ServiceType =  SERVICETYPE_BESTEFFORT;

	pCallMgrParameters->Receive.TokenRate = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Receive.TokenBucketSize = 9188;
	pCallMgrParameters->Receive.MaxSduSize = 9188;
	pCallMgrParameters->Receive.PeakBandwidth = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Receive.ServiceType =  SERVICETYPE_BESTEFFORT;

	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
  				(PUCHAR)pAtmAddr,
  				sizeof(ATM_ADDRESS));

	//
	//  Calling address:
	//
	COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
  				(PUCHAR)&pIntF->ConfiguredAddress,
  				sizeof(ATM_ADDRESS));


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (only for MakeCall)
	//      Broadband Bearer Capability (only for MakeCall)
	//      Broadband Low Layer Info
	//      QoS (only for MakeCall)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = 9188;
		pAal5->BackwardMaxCPCSSDUSize = 9188;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&ArpSDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

}


VOID
ArpSMakeRegAddrCallComplete(
	NDIS_STATUS Status,
	PREG_ADDR_CTXT  pRegAddrCtxt
	)
/*++

Routine Description:

	Completion handler for the validation call. On success we drop the call and
	and move on to the next address. On failure we go on to register this address
	with the switch. See  05/14/1999 notes.txt entry for the larger context.

Arguments:

	Status			MakeCall Completion status.
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	PINTF				pIntF;
	KIRQL 				OldIrql;

	pIntF = pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	DBGPRINT(DBG_LEVEL_INFO,
		 ("==>ArpSMakeRegAddrCallComplete. Status=0x%lx, pIntF=0x%p, pCtxt=0x%p\n",
		 	Status,
			pRegAddrCtxt->pIntF,
			pRegAddrCtxt
		));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
		 ("MakeRegAddrCallComplete: Successful call == failed validation; dropping call.\n"));

		if (pIntF->Flags & INTF_STOPPING)
		{
			//
			// When the IF is stopping, we can't rely on 
			// pIntF->RegAddresses to be still around...
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		}
		else
		{
			ATM_ADDRESS AtmAddress;
			//
			// A successful make call is failed validation!
			// We log the event, drop the call. The drop call complete handler will
			// do the next thing, which is to move on to validating the next address.
			//
			AtmAddress =  pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]; // struct copy
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			ArpSLogFailedRegistration(&AtmAddress);
		}


		Status = NdisClCloseCall(pRegAddrCtxt->NdisVcHandle, NULL, NULL, 0);
	
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseRegAddrCallComplete(Status, pRegAddrCtxt);
		}
	}
	else
	{
		//
		// A failed make call is considered a successful validation!
		// Delete VC and initiate registration of the address.
		//
		PNDIS_REQUEST		pNdisRequest;
		NDIS_HANDLE			NdisVcHandle;
		PATM_ADDRESS		pValidatedAddress;
		PCO_ADDRESS			pCoAddr;
	
		DBGPRINT(DBG_LEVEL_ERROR,
		 ("MakeRegAddrCallComplete: Failed call == successful validation; Adding address.\n"));

		ASSERT(pRegAddrCtxt->NdisVcHandle != NULL);
		NdisVcHandle =  pRegAddrCtxt->NdisVcHandle;
		pRegAddrCtxt->NdisVcHandle = NULL;
	
		if (pIntF->Flags & INTF_STOPPING)
		{
			// Oh oh, the IF is stopping -- we clean up the VC and call
			// ArpSValidateOneRegdAddress -- it will free  pRegAddrCtxt.
			// 
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			if (NdisVcHandle != NULL)
			{
				(VOID)NdisCoDeleteVc(NdisVcHandle);
			}

			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		
			ArpSValidateOneRegdAddress(
					pIntF,
					OldIrql
					);
		}
		else
		{
			ASSERT(pRegAddrCtxt->RegAddrIndex < pIntF->NumAllocedRegdAddresses);
			pValidatedAddress = &(pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]);
			pRegAddrCtxt->RegAddrIndex++;
	
			pNdisRequest = &pRegAddrCtxt->Request.NdisRequest;
			pNdisRequest->RequestType = NdisRequestSetInformation;
			pNdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_ADD_ADDRESS;
			pNdisRequest->DATA.SET_INFORMATION.InformationBuffer
 										= (PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST);
			pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
 										= sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
		
			//
			// Copy the address into the request
			//
			pCoAddr = pNdisRequest->DATA.SET_INFORMATION.InformationBuffer;
			pCoAddr->AddressSize = sizeof(ATM_ADDRESS);
			*(PATM_ADDRESS)(pCoAddr->Address) = *pValidatedAddress;
		
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			if (NdisVcHandle != NULL)
			{
				(VOID)NdisCoDeleteVc(NdisVcHandle);
			}
		
			if (pIntF->NdisAfHandle == NULL)
			{
				Status = NDIS_STATUS_FAILURE;
			}
			else
			{
				Status = NdisCoRequest(pIntF->NdisBindingHandle,
									   pIntF->NdisAfHandle,
									   NULL,
									   NULL,
									   pNdisRequest);
			}

			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCoRequestComplete(Status, pIntF, NULL, NULL, pNdisRequest);
			}
		}
		
	}

	DBGPRINT(DBG_LEVEL_INFO,
		 ("<==ArpSMakeRegAddrCallComplete.\n"));
}


VOID
ArpSCloseRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	)
/*++

Routine Description:


	Completion handler for the NdisClCloseCall of validation call. Since this
	is a failed validation, we move on to validating/registration of the next
	address. See  05/14/1999 notes.txt entry for the larger context.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	KIRQL OldIrql;
	PINTF pIntF;
	NDIS_HANDLE		NdisVcHandle;

	DBGPRINT(DBG_LEVEL_INFO,
		 ("==>ArpSCloseRegAddrCallComplete. pIntF=0x%p, pCtxt=0x%p\n",
			pRegAddrCtxt->pIntF,
			pRegAddrCtxt
		));

	pIntF =  pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

    if (!(pIntF->Flags & INTF_STOPPING))
    {
        ASSERT(pRegAddrCtxt->RegAddrIndex < pIntF->NumAllocedRegdAddresses);
        pRegAddrCtxt->RegAddrIndex++;
    }

	ASSERT(pRegAddrCtxt->NdisVcHandle != NULL);
	NdisVcHandle =  pRegAddrCtxt->NdisVcHandle;
	pRegAddrCtxt->NdisVcHandle = NULL;
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	if (NdisVcHandle != NULL)
	{
		(VOID)NdisCoDeleteVc(NdisVcHandle);
	}
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ArpSValidateOneRegdAddress(
			pIntF,
			OldIrql
			);
	//
	// Lock released above.

	DBGPRINT(DBG_LEVEL_INFO, ("<==ArpSCloseRegAddrCallComplete\n"));
}


VOID
ArpSUnlinkRegAddrCtxt(
	PINTF			pIntF, 		// LOCKIN NOLOCKOUT
	KIRQL			OldIrql
	)
/*++

Routine Description:

	Deref pIntF, remove reference to pRegAddrCtxt = pIntF->pRegAddrCtxt, and
	free pIntF->pRegAddrCtxt. See  05/14/1999 notes.txt entry for the larger context.
	
	Must only be called AFTER all async activity relating to pRegAddrCtxt is
	over and  pRegAddrCtxt->NdisVcHandle is NULL.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	PREG_ADDR_CTXT		pRegAddrCtxt;
	DBGPRINT(DBG_LEVEL_INFO, ("==>ArpSUnlinkRegAddrCtxt\n"));

	pRegAddrCtxt = pIntF->pRegAddrCtxt;
	ASSERT(pRegAddrCtxt != NULL);
	ASSERT(pRegAddrCtxt->pIntF == pIntF);
	ASSERT(pRegAddrCtxt->NdisVcHandle == NULL);
	// TODO: -- flags.
	FREE_MEM(pRegAddrCtxt);
	pIntF->pRegAddrCtxt = NULL;

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	ArpSDereferenceIntF(pIntF); // pRegAddrCtxt;

	DBGPRINT(DBG_LEVEL_INFO, ("<==ArpSUnlinkRegAddrCtxt\n"));
}


VOID
ArpSIncomingRegAddrCloseCall(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	)
/*++

Routine Description:

	Incoming close call handler for the validation call. Currently we do nothing
	with this. I don't see the need to do anything, because we don't keep
	the call up for an arbitrary length of time.

	However, if/when we decide to keep the call up so that we can try to
	re-validate after the call goes away, we'll need to do something here.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	DBGPRINT(DBG_LEVEL_INFO, ("<==>ArpSIncomingRegAddrCloseCall\n"));
}


VOID
ArpSLogFailedRegistration(
		PATM_ADDRESS pAtmAddress
	)
{
	WCHAR TxtAddress[2*ATM_ADDRESS_LENGTH+1];	// 2 chars per address byte plus null
	WCHAR *StringList[1];
	static ULONG SequenceId;

	//
	// Convert atm address to unicode...
	//
	{
		static PWSTR 	WHexChars = L"0123456789ABCDEF";
		PWSTR 			StrBuf;
		ULONG			Index;
		PWSTR			pWStr;
		PUCHAR			pAddr;
		UINT			Max;

		Max = pAtmAddress->NumberOfDigits;

		if (Max > ATM_ADDRESS_LENGTH)
		{
			Max = ATM_ADDRESS_LENGTH;
		}
	
		for (Index = 0, pWStr = TxtAddress, pAddr = pAtmAddress->Address;
			Index < Max;
			Index++, pAddr++)
		{
			*pWStr++ = WHexChars[(*pAddr)>>4];
			*pWStr++ = WHexChars[(*pAddr)&0xf];
		}

		*pWStr = L'\0';
	}

	StringList[0] = TxtAddress;

	(VOID) NdisWriteEventLogEntry(
				ArpSDriverObject,
				EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS,
				SequenceId,				// Sequence
				1, 						// NumStrings
				&StringList[0],			// String list
				0,						// DataSize
				NULL					// Data
				);

	NdisInterlockedIncrement(&SequenceId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\debug.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains the macros for debugging.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_DEBUG_
#define	_DEBUG_

#define	FILENUM_ARPS			0x010000
#define	FILENUM_MARS			0x020000
#define	FILENUM_NDIS			0x040000
#define	FILENUM_TIMER			0x080000
#define	FILENUM_DATA			0x100000
#define	FILENUM_REGISTRY		0x200000
#define	FILENUM_IOCTL			0x400000
#define	FILENUM_UTIL			0x800000

#define	DBG_LEVEL_LOUD			0x0000
#define	DBG_LEVEL_INFO			0x1000
#define DBG_LEVEL_NOTICE		0x2000
#define	DBG_LEVEL_WARN			0x3000
#define	DBG_LEVEL_ERROR			0x4000
#define	DBG_LEVEL_FATAL			0x4000
#define	DBG_NO_HDR				0x0001

#if	DBG
extern	ULONG		ArpSDebugLevel;
extern	ULONG		MarsDebugLevel;

#define ARPS_PAGED_CODE()											\
		if (KeGetCurrentIrql() > APC_LEVEL)							\
		{															\
			DbgPrint("Pageable code called at IRQL %d, file %s, line %d\n",	\
				KeGetCurrentIrql(), __FILE__, __LINE__);			\
		}

#define ARPS_GET_IRQL(_pIrql)	*(_pIrql) = KeGetCurrentIrql();

#define ARPS_CHECK_IRQL(_Irql)										\
		{															\
			KIRQL	NowIrql = KeGetCurrentIrql();					\
			if (_Irql != NowIrql)									\
			{														\
				DbgPrint("***ATMARPS***: old irq %d != new irq %d!\n",	\
					_Irql, NowIrql);								\
				DbgPrint("File: %s, line %d\n", __FILE__, __LINE__);\
				DbgBreakPoint();									\
			}														\
		}

#define DBGPRINT(Level, Fmt)										\
		{															\
			if ((Level) >= ArpSDebugLevel)							\
			{														\
				if (((Level) & DBG_NO_HDR) == 0)						\
					DbgPrint("***ATMARPS*** ");						\
				DbgPrint Fmt;										\
			}														\
		}

#define MARSDBGPRINT(Level, Fmt)									\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				if (((Level) & DBG_NO_HDR) == 0)						\
					DbgPrint("MARS:  ");							\
				DbgPrint Fmt;										\
			}														\
		}

#define MARSDUMPIPADDR(Level, Addr, Str)							\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				MarsDumpIpAddr(Addr, Str);							\
			}														\
		}

#define MARSDUMPATMADDR(Level, Addr, Str)							\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				MarsDumpAtmAddr(Addr, Str);							\
			}														\
		}

#define MARSDUMPMAP(Level, Str, IpAddr, pAtmAddr)					\
				{													\
						if ((Level) >= MarsDebugLevel)				\
						{											\
							MarsDumpMap(Str, IpAddr, pAtmAddr);		\
						}											\
				}

#define DBGBRK(Level)												\
		{															\
			if ((Level) >= ArpSDebugLevel)							\
				DbgBreakPoint();									\
		}

#define	LOG_ERROR(_s)	DBGPRINT(DBG_LEVEL_ERROR,					\
						("***ATMARPS*** ErrLog (%lx)@ %s (%ld)\n",	\
							_s, __FILE__, __LINE__));

#define ARPS_ASSERT(exp)											\
		{															\
			if (!(exp))												\
			{														\
				DbgPrint("***ATMARPS*** Assert " #exp " failed: file %s, line %d\n",	\
						__FILE__, __LINE__);						\
				DbgBreakPoint();									\
			}														\
		}

#else

#define ARPS_PAGED_CODE()
#define ARPS_GET_IRQL(_pIrql)
#define ARPS_CHECK_IRQL(Irql)
#define DBGPRINT(Level, Fmt)
#define MARSDBGPRINT(Level, Fmt)
#define MARSDUMPIPADDR(Level, Addr, Str)
#define MARSDUMPATMADDR(Level, Addr, Str)
#define MARSDUMPMAP(Level, Str, IpAddr, pAtmAddr)
#define DBGBRK(Level)
#define	LOG_ERROR(s)

#define ARPS_ASSERT(exp)

#endif	// DBG

#endif	// _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\file.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    file.h

Abstract:

    This file contains the data declarations for the disk format of arp cache.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_FILE_
#define	_FILE_

#define	DISK_HDR_SIGNATURE	'SprA'
#define	DISK_HDR_VERSION	0x00010000		// 1.0
#define	DISK_BUFFER_SIZE	4096			// Amount read or written at a time

//
// The file consists of a header, followed by individual entries.
//
typedef struct
{
	ULONG		Signature;
	ULONG		Version;
	ULONG		TimeStamp;				// Time written
	ULONG		NumberOfArpEntries;
} DISK_HEADER, *PDISK_HEADER;

typedef	struct
{
	UCHAR		AddrType;
	UCHAR		AddrLen;
	UCHAR		SubAddrType;
	UCHAR		SubAddrLen;
	UCHAR		Address[ATM_ADDRESS_LENGTH];
	//
	// This is followed by SubAddress if one is present
	//
	// UCHAR	SubAddress[ATM_ADDRESS_LENGTH];
} DISK_ATMADDR;

typedef	struct
{
	IPADDR			IpAddr;
	DISK_ATMADDR	AtmAddr;
} DISK_ENTRY, *PDISK_ENTRY;

#define	SIZE_4N(_x_)	(((_x_) + 3) & ~3)

#define	LinkDoubleAtHead(_pHead, _p)			\
	{											\
		(_p)->Next = (_pHead);					\
		(_p)->Prev = &(_pHead);					\
		if ((_pHead) != NULL)					\
			(_pHead)->Prev = &(_p)->Next;		\
		(_pHead) = (_p);						\
	}

#define	LinkDoubleAtEnd(_pThis, _pLast)			\
	{											\
		(_pLast)->Next = (_pThis);				\
		(_pThis)->Prev = &(_pLast)->Next;		\
		(_pThis)->Next = NULL;					\
	}

#define	UnlinkDouble(_p)						\
	{											\
		*((_p)->Prev) = (_p)->Next;				\
		if ((_p)->Next != NULL)					\
			(_p)->Next->Prev = (_p)->Prev;		\
	}

#endif	//	_FILE_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\mars.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mars.h

Abstract:

    This file contains the definitions for Multicast Address Resolution Server (MARS).

Author:

	Jameel Hyder (jameelh@microsoft.com)	January 1997

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_MARS_
#define	_MARS_

//
// IP Address values that can be used in comparisons:
//
#define MIN_CLASSD_IPADDR_VALUE		((IPADDR)0xE0000000)	// 224.0.0.0
#define MAX_CLASSD_IPADDR_VALUE		((IPADDR)0xEFFFFFFF)	// 239.255.255.255
#define IP_BROADCAST_ADDR_VALUE		((IPADDR)0xFFFFFFFF)	// 255.255.255.255

//
// IP Address value we use to represent the "full multicast+broadcast range"
//
#define IPADDR_FULL_RANGE			((IPADDR)0x00000000)


//
// MARS_OP - Define these in network byte order
//
#define	OP_MARS_REQUEST				0x0100
#define	OP_MARS_MULTI				0x0200 
#define	OP_MARS_MSERV				0x0300 
#define	OP_MARS_JOIN				0x0400 
#define	OP_MARS_LEAVE				0x0500 
#define	OP_MARS_NAK					0x0600 
#define	OP_MARS_UNSERV				0x0700 
#define	OP_MARS_SJOIN				0x0800 
#define	OP_MARS_SLEAVE				0x0900 
#define	OP_MARS_MIGRATE				0x0D00 
#define	OP_MARS_GROUPLIST_REQUEST	0x0000
#define	OP_MARS_GROUPLIST_REPLY		0x0000
#define	OP_MARS_REDIRECT_MAP		0x0C00

#define	MARS_HWTYPE					0x0F00

#define LAST_MULTI_FLAG				0x8000

//
// The layout of a MARS_JOIN and MARS_LEAVE request packets
//
typedef struct _MARS_HDR
{
	LLC_SNAP_HDR				LlcSnapHdr;			// LLC SNAP Header
	USHORT						HwType;				// Must be 0x0F00 (0x000F on the wire)
	USHORT						Protocol;			// 16 bits
	UCHAR						ProtocolSnap[5];	// 40 bits
	UCHAR						Reserved[3];		// 24-bits
	USHORT						CheckSum;
	USHORT						ExtensionOffset;
	USHORT						Opcode;				// MARS_XXX above
	ATM_ADDR_TL					SrcAddressTL;
	ATM_ADDR_TL					SrcSubAddrTL;
	//
	// This is followed by variable length fields and is dictated by the value of Opcode.
	// The structures below define fixed part of individual MARS_XXX messages. The variable
	// part of each of these depends on the TL fields.
	//
} MARS_HEADER, *PMARS_HEADER;


//
// Defines the structure of the MARS_REQUEST, MARS_MULTI, MARS_MIGRATE and MARS_NAK messages
//
typedef struct _MARS_REQUEST
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					TgtAddressTL;
	ATM_ADDR_TL					TgtSubAddrTL;
	UCHAR						TgtGroupAddrLen;	// Target protocol addr length
	union
	{
		UCHAR					Padding[8];			// For MARS_REQUEST and MARS_NAK
		struct
		{											// For MARS_MULTI and MARS_MIGRATE
			USHORT				NumTgtGroupAddr;	// Should be converted to wire-format
			union
			{
				USHORT			FlagSeq;			// Should be converted to wire-format
				USHORT			Reservedx;			// For MARS_MIGRATE
			
			};
			ULONG				SequenceNumber;		// Should be converted to wire-format
		};
	};
} MARS_REQUEST, MARS_MULTI, MARS_NAK, *PMARS_REQUEST, *PMARS_MULTI, *PMARS_NAK;

typedef struct _MCAST_ADDR_PAIR
{
	IPADDR						MinAddr;
	IPADDR						MaxAddr;
} MCAST_ADDR_PAIR, *PMCAST_ADDR_PAIR;

//
// Defines the structure of the MARS_JOIN and MARS_LEAVE messages
//
typedef struct _MARS_JOIN_LEAVE
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	UCHAR						GrpProtoAddrLen;	// Grp protocol addr length
	USHORT						NumGrpAddrPairs;	// # of group address pairs
													// Should be converted to wire-format
	USHORT						Flags;				// layer 3 frp copy & register flags
													// Should be converted to wire-format
	USHORT						ClusterMemberId;	// Should be converted to wire-format
	ULONG						MarsSequenceNumber;	// Should be converted to wire-format
	//
	// This is followed by Src ATM address/sub-address, src protocol address and N pairs of multicast addresses
	//
} MARS_JOIN_LEAVE, *PMARS_JOIN_LEAVE;

//
// Definitions of flags masks
//
#define	JL_FLAGS_L3GRP			0x8000
#define	JL_FLAGS_COPY			0x4000
#define	JL_FLAGS_REGISTER		0x2000
#define	JL_FLAGS_PUNCHED		0x1000
#define	JL_FLAGS_RESERVED		0x0F00
#define	JL_FLAGS_SEQUENCE		0x00FF

//
// Defines the structure of the MARS_GROUPLIST_REQUEST and MARS_GROUPLIST_REPLY messages
//
typedef struct _MARS_GROUPLIST_REPLY
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	UCHAR						Reserved1;
	UCHAR						Reserved2;
	UCHAR						TgtGroupAddrLen;	// Target protocol addr length
	USHORT						NumTgtGroupAddr;	// Should be converted to wire-format
	USHORT						FlagSeq;			// Should be converted to wire-format
	ULONG						SequenceNumber;		// Should be converted to wire-format
} MARS_GROUPLIST_REPLY, *PMARS_GROUPLIST_REPLY;

//
// Defines the structure of the MARS_REDIRECT_MAP messages
//
typedef struct _MARS_REDIRECT_MAP
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					TgtAddressTL;
	ATM_ADDR_TL					TgtSubAddrTL;
	UCHAR						Flags;
	USHORT						NumTgtAddr;			// Should be converted to wire-format
	USHORT						FlagSeq;			// Should be converted to wire-format
	ULONG						SequenceNumber;		// Should be converted to wire-format
} MARS_REDIRECT_MAP, *PMARS_REDIRECT_MAP;


//
// Defines the structure of a MARS TLV header
//
typedef struct _MARS_TLV_HEADER
{
	USHORT						Type;
	USHORT						Length;
} MARS_TLV_HEADER;

typedef MARS_TLV_HEADER UNALIGNED * PMARS_TLV_HEADER;


//
// Defines the structure of a MARS MULTI is MCS header. This TLV is appended
// to any MULTI message we send out with our address as the MCS address.
//
typedef struct _MARS_TLV_MULTI_IS_MCS
{
	MARS_TLV_HEADER;
} MARS_TLV_MULTI_IS_MCS;

typedef MARS_TLV_MULTI_IS_MCS UNALIGNED * PMARS_TLV_MULTI_IS_MCS;

//
// TLV Type value for MULTI is MCS TLV.
//
#define MARS_TLVT_MULTI_IS_MCS		0x003a	// on-the-wire form


//
// Defines the structure of a NULL TLV, which is used to terminate
// a list of TLVs.
//
typedef struct _MARS_TLV_NULL
{
	MARS_TLV_HEADER;
} MARS_TLV_NULL;

typedef MARS_TLV_NULL UNALIGNED * PMARS_TLV_NULL;


//
// Forward references
//
struct _CLUSTER_MEMBER ;
struct _GROUP_MEMBER ;
struct _MARS_ENTRY ;
struct _MCS_ENTRY ;
struct _MARS_VC ;


//
// This represents a cluster-member, or an endstation that has registered
// with MARS. A single cluster-member can be associated with many groups.
//
typedef struct _CLUSTER_MEMBER
{
	ENTRY_HDR;										// Must be the first entry
	HW_ADDR						HwAddr;				// HWADDR MUST FOLLOW ENTRY_HDR
	PINTF						pIntF;				// Back pointer to the interface
	USHORT						Flags;
	USHORT						CMI;				// Cluster-Member-Id
	NDIS_HANDLE					NdisPartyHandle;	// Leaf-node for ClusterControlVc
	struct _GROUP_MEMBER *		pGroupList;			// List of groups this CM has JOINed
													// This is sorted in ascending order
													// of Group Address
	INT							NumGroups;			// Size of above list
} CLUSTER_MEMBER, *PCLUSTER_MEMBER;

#define NULL_PCLUSTER_MEMBER	((PCLUSTER_MEMBER)NULL)

#define CM_CONN_FLAGS				0x000f
#define CM_CONN_IDLE				0x0000	// No connection
#define CM_CONN_SETUP_IN_PROGRESS	0x0001	// Sent MakeCall/AddParty
#define CM_CONN_ACTIVE				0x0002	// Participating in ClusterControlVc
#define CM_CONN_CLOSING				0x0004	// Sent CloseCall/DropParty
#define CM_INVALID					0x8000	// Invalidated entry

#define CM_GROUP_FLAGS				0x0010
#define CM_GROUP_ACTIVE				0x0000	// Ok to add groups
#define CM_GROUP_DISABLED			0x0010	// Don't add any more groups.



//
// This represents a member of a multicast address. There is one
// of this for every node that joins a class-D address. That is,
// this structure represents a <MulticastGroup, ClusterMember> relation.
//
typedef struct _GROUP_MEMBER
{
	ENTRY_HDR;										// Must be the first entry
	struct _MARS_ENTRY *		pMarsEntry;			// Pointer to group info
	PCLUSTER_MEMBER				pClusterMember;		// Cluster Member Joining this group
	struct _GROUP_MEMBER *		pNextGroup;			// Next group this CM has JOINed
	ULONG						Flags;
} GROUP_MEMBER, *PGROUP_MEMBER;

#define NULL_PGROUP_MEMBER		((PGROUP_MEMBER)NULL)


//
// This represents a multi-cast IP address. These are linked to the IntF.
// It contains a list of all cluster members who have Joined the group
// identified by the address.
//
// A special entry is one with IPAddress set to 0. This entry is used to
// represent the "All multicast and broadcast" range. Cluster Members who
// Join this range are linked here.
//
typedef struct _MARS_ENTRY
{
	ENTRY_HDR;										// Must be the first entry
    IPADDR						IPAddress;			// Class D IP Addr (0 means entire
    												// multicast+broadcast range)
	PGROUP_MEMBER				pMembers;			// List of group-members (Join list)
	UINT						NumMembers;			// Size of above list
	PINTF						pIntF;				// Back pointer to the interface
} MARS_ENTRY, *PMARS_ENTRY;

#define NULL_PMARS_ENTRY		((PMARS_ENTRY)NULL)


//
// This is used to represent an address range served by MCS. These
// structures are linked to the IntF.
//
typedef struct _MCS_ENTRY
{
	ENTRY_HDR;										// Must be the first entry
	MCAST_ADDR_PAIR				GrpAddrPair;		// The range served by MCS
	PINTF						pIntF;				// Back pointer to the interface
} MCS_ENTRY, *PMCS_ENTRY;

#define NULL_PMCS_ENTRY			((PMCS_ENTRY)NULL)



//
// This represents a PMP uni-directional VC. MARS creates one for
// ClusterControl and one for ServerControl (if and when external MCS'
// are supported).
//
typedef struct _MARS_VC
{
	ULONG						VcType;
	ULONG						Flags;
	LONG						RefCount;
	NDIS_HANDLE					NdisVcHandle;
	UINT						NumParties;
	PINTF						pIntF;

} MARS_VC, *PMARS_VC;

#define NULL_PMARS_VC			((PMARS_VC)NULL)

#define MVC_CONN_FLAGS				0x0000000f
#define MVC_CONN_IDLE				0x00000000
#define MVC_CONN_SETUP_IN_PROGRESS	0x00000001	// Sent MakeCall
#define MVC_CONN_ACTIVE				0x00000002	// MakeCall success
#define MVC_CONN_NEED_CLOSE			0x00000004	// Need to CloseCall when the penultimate
												// party is gone
#define MVC_CONN_CLOSING			0x00000008	// Sent CloseCall
#define MVC_CONN_CLOSE_RECEIVED		0x00000010	// Seen IncomingCloseCall





#ifndef MAX
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a, b)	(((a) > (b)) ? (b) : (a))
#endif


//
// Be a little generous and use 256 as space for incoming requests
//
#if 0
#define	PKT_SPACE	MAX(sizeof(ARPS_HEADER) + sizeof(ARPS_VAR_HDR), \
						sizeof(MARS_REQUEST) + sizeof(ARPS_VAR_HDR))
#else
#define	PKT_SPACE	256

#endif


#define BYTES_TO_CELLS(_b)	((_b)/48)

//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x4)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define MARS_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )


//
//  Total space required for Information Elements in an outgoing AddParty.
//
#define MARS_ADD_PARTY_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE )


//
// Some macros to set/get state
//
#define MARS_GET_CM_CONN_STATE(_pCm)		((_pCm)->Flags & CM_CONN_FLAGS)

#define MARS_SET_CM_CONN_STATE(_pCm, _St)	\
			{ (_pCm)->Flags = ((_pCm)->Flags & ~CM_CONN_FLAGS) | (_St); }

#define MARS_GET_CM_GROUP_STATE(_pCm)		((_pCm)->Flags & CM_GROUP_FLAGS)

#define MARS_SET_CM_GROUP_STATE(_pCm, _St)	\
			{ (_pCm)->Flags = ((_pCm)->Flags & ~CM_GROUP_FLAGS) | (_St); }

#define MARS_GET_VC_CONN_STATE(_pVc)		((_pVc)->Flags & MVC_CONN_FLAGS)

#define MARS_SET_VC_CONN_STATE(_pVc, _St)	\
			{ (_pVc)->Flags = ((_pVc)->Flags & ~MVC_CONN_FLAGS) | (_St); }



#endif	// _MARS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\ioctl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_IOCTL_
#define	_IOCTL_

#define	ARP_SERVER_DEVICE_NAME			L"\\Device\\AtmArpServer"
#define	ARP_SERVER_DOS_DEVICE_NAME		L"\\\\.\\AtmArpServer"
#define	ARP_SERVER_SYMBOLIC_NAME		L"\\DosDevices\\AtmArpServer"

#define	ARPS_IOCTL_QUERY_INTERFACES		CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_FLUSH_ARPCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_ARPCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_ADD_ARPENTRY			CTL_CODE(FILE_DEVICE_NETWORK, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_IP_FROM_ATM	CTL_CODE(FILE_DEVICE_NETWORK, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_ATM_FROM_IP	CTL_CODE(FILE_DEVICE_NETWORK, 105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	ARPS_IOCTL_QUERY_ARP_STATISTICS	CTL_CODE(FILE_DEVICE_NETWORK, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_MARSCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_MARS_STATISTICS CTL_CODE(FILE_DEVICE_NETWORK, 111, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_RESET_STATISTICS 	CTL_CODE(FILE_DEVICE_NETWORK, 112, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef enum
{
	QUERY_IP_FROM_ATM,
    QUERY_ATM_FROM_IP,
    ADD_ARP_ENTRY
} OPERATION;

//
// All Ptrs are represented by offsets from the beginning of the structures.
//
typedef	UNICODE_STRING	INTERFACE_NAME, *PINTERFACE_NAME;

typedef struct
{
	IPADDR		IpAddr;
	ATM_ADDRESS	AtmAddress;
	ATM_ADDRESS	SubAddress;
} ARPENTRY, *PARPENTRY;


typedef struct
{
	UINT			NumberOfInterfaces;
	INTERFACE_NAME	Interfaces[1];
} INTERFACES, *PINTERFACES;

typedef union
{
	INTERFACE_NAME			Name;
	ARPENTRY				ArpEntry;
} IOCTL_QA_ENTRY, *PIOCTL_QA_ENTRY;

typedef	union
{
	struct QUERY_ARP_CACHE_INPUT_PARAMS
	{
		UINT				StartEntryIndex;
		INTERFACE_NAME		Name;
	};
	struct QUERY_ARP_CACHE_OUTPUT_PARAMS
	{
		UINT				TotalNumberOfEntries;
		UINT				NumberOfEntriesInBuffer;
		ARPENTRY			Entries[1];
	} Entries;
} IOCTL_QUERY_CACHE, *PIOCTL_QUERY_CACHE;


typedef struct
{
	UINT	ElapsedSeconds;
	UINT	TotalRecvPkts;
	UINT	DiscardedRecvPkts;

	UINT	CurrentArpEntries;
	UINT	MaxArpEntries;
	UINT	Acks;
	UINT	Naks;
	UINT	CurrentClientVCs;
	UINT	MaxClientVCs;
	UINT	TotalActiveVCs;
	UINT	TotalIncomingCalls;		// for both arps and mars
	UINT	FailedIncomingCalls;	// for both arps and mars

} ARP_SERVER_STATISTICS, *PARP_SERVER_STATISTICS;

	
typedef struct
{
	UINT	ElapsedSeconds;
	UINT	TotalRecvPkts;
	UINT	DiscardedRecvPkts;

	UINT	TotalMCDataPkts;
	UINT	DiscardedMCDataPkts;
	UINT	ReflectedMCDataPkts;

	UINT	CurrentClusterMembers;
	UINT	MaxClusterMembers;
	UINT	TotalCCVCAddParties;
	UINT	FailedCCVCAddParties;

	UINT	RegistrationRequests;
	UINT	FailedRegistrations;

	UINT	TotalJoins;
	UINT	FailedJoins;
	UINT	DuplicateJoins;
	UINT 	SuccessfulVCMeshJoins;
	UINT	TotalLeaves;
	UINT	FailedLeaves;

	UINT	TotalRequests;
	UINT	Naks;
	UINT	VCMeshAcks;
	UINT	MCSAcks;

	UINT	CurrentGroups; 	// vc-mesh
	UINT	MaxGroups; 		// vc-mesh
	UINT	CurrentPromiscuous;
	UINT	MaxPromiscuous;
	UINT	MaxAddressesPerGroup;

} MARS_SERVER_STATISTICS, *PMARS_SERVER_STATISTICS;

//
//		MARS-specific entries.
//

typedef struct
{
	IPADDR	  IpAddr;
	ULONG	  Flags;     				// One or more MARSENTRY_* flags below
	ULONG	  NumAtmAddresses;
	ULONG	  OffsetAtmAddresses;		// From the start of THIS structure.
										// NOTE: we do not report subaddresses
										// Will be 0 if there are no addresses
										// present in the buffer (typically
										// because there is not enough space
										// to store them all).

} MARSENTRY, *PMARSENTRY;

#define MARSENTRY_MCS_SERVED	0x1			// Group is MCS served

#define	SIG_MARSENTRY 0xf69052f5

typedef	union
{
	struct QUERY_MARS_CACHE_INPUT_PARAMS
	{
		UINT				StartEntryIndex;
		INTERFACE_NAME		Name;
	};

	struct QUERY_MARS_CACHE_OUTPUT_PARAMS
	{
		ULONG				Sig;		// Set to SIG_MARSENTRY
		UINT				TotalNumberOfEntries;
		UINT				NumberOfEntriesInBuffer;
		MARSENTRY			Entries[1];

	} MarsCache;

} IOCTL_QUERY_MARS_CACHE, *PIOCTL_QUERY_MARS_CACHE;

#endif	// _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\ioctl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	This file contains the code to implement the IOCTL interface to the atmarp server.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/


#include <precomp.h>
#define	_FILENUM_		FILENUM_IOCTL

NTSTATUS
ArpSDispatch(
	IN	PDEVICE_OBJECT			pDeviceObject,
	IN	PIRP					pIrp
	)
/*++

Routine Description:

	Handler for the ioctl interface - not implemented yet.

Arguments:

	pDeviceObject	ARP Server device object
	pIrp			IRP

Return Value:

	STATUS_NOT_IMPLEMENTED currently
--*/
{
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	static ULONG		OpenCount = 0;

	ARPS_PAGED_CODE( );

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	switch (pIrpSp->MajorFunction)
	{
	  case IRP_MJ_CREATE:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Open Handle\n"));

		InterlockedIncrement(&OpenCount);
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_CLOSE:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Close Handle\n"));
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_DEVICE_CONTROL:
		Status =  ArpSHandleIoctlRequest(pIrp, pIrpSp);
		break;

	  case IRP_MJ_FILE_SYSTEM_CONTROL:
		Status = STATUS_NOT_IMPLEMENTED;
		break;

	  case IRP_MJ_CLEANUP:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Cleanup Handle\n"));
		Status = STATUS_SUCCESS;
		InterlockedDecrement(&OpenCount);
		break;

	  case IRP_MJ_SHUTDOWN:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Shutdown\n"));
		ArpSShutDown();
		Status = STATUS_SUCCESS;
		break;

	  default:
		Status = STATUS_NOT_IMPLEMENTED;
		break;
	}

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	if (Status != STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
	}
	else
	{
		IoMarkIrpPending(pIrp);
	}

	return Status;
}


NTSTATUS
ArpSHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;
	PUCHAR				pBuf;  
	UINT				BufLen;
	PINTF				pIntF	= NULL;

	pIrp->IoStatus.Information = 0;
	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
	  case ARPS_IOCTL_FLUSH_ARPCACHE:
	  case ARPS_IOCTL_QUERY_ARPCACHE:
	  case ARPS_IOCTL_ADD_ARPENTRY:
	  case ARPS_IOCTL_QUERY_IP_FROM_ATM:
	  case ARPS_IOCTL_QUERY_ATM_FROM_IP:
	  case ARPS_IOCTL_QUERY_ARP_STATISTICS:
	  case ARPS_IOCTL_QUERY_MARSCACHE:
	  case ARPS_IOCTL_QUERY_MARS_STATISTICS:
	  case ARPS_IOCTL_RESET_STATISTICS:
		{
			INTERFACE_NAME		RawName;
			UINT				Offset;

			if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == ARPS_IOCTL_QUERY_ARPCACHE)
			{
				Offset = FIELD_OFFSET(IOCTL_QUERY_CACHE, Name);
			}
			else if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == ARPS_IOCTL_QUERY_MARSCACHE)
			{
				Offset = FIELD_OFFSET(IOCTL_QUERY_MARS_CACHE, Name);
			}
			else
			{
				Offset = 0;
			}

			if (BufLen < sizeof(INTERFACE_NAME) + Offset)
			{
				return STATUS_INVALID_PARAMETER;
			}

			RawName = *(PINTERFACE_NAME)((PUCHAR)pBuf + Offset);
			RawName.Buffer = (PWSTR)(pBuf + Offset + (ULONG_PTR)RawName.Buffer); // fixup ptr

			//
			// Probe away...
			//
			if ( 	(PUCHAR)RawName.Buffer < (pBuf+sizeof(INTERFACE_NAME))
				||	(PUCHAR)RawName.Buffer >= (pBuf+BufLen)
				||	((PUCHAR)RawName.Buffer + RawName.Length) > (pBuf+BufLen))
			{
				return STATUS_INVALID_PARAMETER;
			}
	
			pIntF = ArpSReferenceIntFByName(&RawName);

			if (pIntF == NULL)
			{
				return STATUS_NOT_FOUND;
			}

		}
		break;

	  default:
        break;  // FALL THROUGH
	}
	
	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
	  case ARPS_IOCTL_QUERY_INTERFACES:
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_INTERFACES\n"));
		BufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		Status = ArpSEnumerateInterfaces(pBuf, &BufLen);
		if (NT_SUCCESS(Status))
		{
			pIrp->IoStatus.Information = BufLen;
		}
		else
		{
			pIrp->IoStatus.Information = 0;
		}
		break;
	
	  case ARPS_IOCTL_FLUSH_ARPCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
					("ArpSHandleIoctlRequest: FLUSH_ARPCACHE on %Z\n",
 					 &pIntF->FriendlyName));
		Status = ArpSFlushArpCache(pIntF);
		pIrp->IoStatus.Information = 0;
		break;
	
	  case ARPS_IOCTL_QUERY_ARPCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ARPCACHE on %Z\n",
				 &pIntF->FriendlyName));
		pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		Status = ArpSQueryArpCache(pIntF, pBuf, &pIrp->IoStatus.Information);
		break;

#if 0
	//
	//  These need more work - commented out as they aren't critical.
	//
	  case ARPS_IOCTL_ADD_ARPENTRY:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ADD_ARPENTRY on %Z\n",
				 &pIntF->FriendlyName));

		Status = ArpSQueryOrAddArpEntry(pIntF, (PIOCTL_QA_ENTRY)pBuf, ADD_ARP_ENTRY);
		break;
	
	  case ARPS_IOCTL_QUERY_IP_FROM_ATM:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_IP_ADDR on %Z\n",
				  &pIntF->FriendlyName));

		Status = ArpSQueryOrAddArpEntry(pIntF, (PIOCTL_QA_ENTRY)pBuf, QUERY_IP_FROM_ATM);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(IOCTL_QA_ENTRY);
		}
		break;
	
	  case ARPS_IOCTL_QUERY_ATM_FROM_IP:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ATM_ADDR on %Z\n",
				 pIntF->FriendlyName));
		Status = ArpSQueryOrAddArpEntry( pIntF, (PIOCTL_QA_ENTRY)pBuf, QUERY_ATM_FROM_IP );
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(IOCTL_QA_ENTRY);
		}
		break;
#endif // 0

	  case ARPS_IOCTL_QUERY_ARP_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ARP_STATS on %Z\n",
				 pIntF->FriendlyName));

		if (BufLen<sizeof(ARP_SERVER_STATISTICS))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = ArpSQueryArpStats( pIntF, (PARP_SERVER_STATISTICS)pBuf);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(ARP_SERVER_STATISTICS);
		}
	  	break;

	  case ARPS_IOCTL_QUERY_MARSCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_MARSCACHE on %Z\n",
				 &pIntF->FriendlyName));
		pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		Status = ArpSQueryMarsCache(pIntF, pBuf, &pIrp->IoStatus.Information);
		break;

	  case ARPS_IOCTL_QUERY_MARS_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_MARS_STATS on %Z\n",
				 pIntF->FriendlyName));

		if (BufLen<sizeof(MARS_SERVER_STATISTICS))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = ArpSQueryMarsStats( pIntF, (PMARS_SERVER_STATISTICS)pBuf);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(MARS_SERVER_STATISTICS);
		}
	  	break;
	
	  case ARPS_IOCTL_RESET_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: RESET_STATISTICS on %Z\n",
				 pIntF->FriendlyName));

		ArpSResetStats(pIntF);
		pIrp->IoStatus.Information = 0;
	  	break;

	  default:
		Status = STATUS_NOT_SUPPORTED;
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: Unknown request %lx\n",
				  pIrpSp->Parameters.DeviceIoControl.IoControlCode));
		break;
	}

	if (pIntF != NULL)
	{
		ArpSDereferenceIntF(pIntF);
	}
	
	return Status;
}

NTSTATUS
ArpSEnumerateInterfaces(
	IN		PUCHAR				pBuffer,
	IN OUT	PULONG			    pSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTERFACES		pInterfaces = (PINTERFACES)pBuffer;
	PINTERFACE_NAME	pInterface;
	NTSTATUS		Status = STATUS_SUCCESS;
	PINTF			pIntF;
	KIRQL			OldIrql;
	UINT			Size, Total, Remaining;
	PUCHAR			pBuf;
	UINT			InputSize = (UINT) *pSize;
	ULONG			IfIndex;

	if (InputSize < sizeof(INTERFACES))
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	pInterfaces->NumberOfInterfaces = 0;
	pBuf = (PUCHAR)pInterfaces + InputSize;

	ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);

	pInterface = &pInterfaces->Interfaces[0];
	for (pIntF = ArpSIfList, Total = 0, Remaining = InputSize, IfIndex = 1;
		 pIntF != NULL;
		 pIntF = pIntF->Next, pInterface++, IfIndex++)
	{
		if (IfIndex > ArpSIfListSize)
		{
			DbgPrint("ATMARPS: EnumInt: IF list at %p not consistent with list size %d\n",
				ArpSIfList, ArpSIfListSize);
			DbgBreakPoint();
			break;
		}

		Size = sizeof(INTERFACE_NAME) + pIntF->FriendlyName.Length;
		if (Size > Remaining)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}
		pInterfaces->NumberOfInterfaces ++;
		pInterface->MaximumLength = pInterface->Length = pIntF->FriendlyName.Length;
		pInterface->Buffer = (PWSTR)(pBuf - pIntF->FriendlyName.Length);
		COPY_MEM(pInterface->Buffer, pIntF->FriendlyName.Buffer, pIntF->FriendlyName.Length);
		pBuf -= pIntF->FriendlyName.Length;
		Total += Size;
		Remaining -= Size;

		//
		// Convert the ptr now to an offset
		//
		pInterface->Buffer = (PWSTR)((ULONG_PTR)pInterface->Buffer - (ULONG_PTR)pInterface);
	}

	RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

	//
	// Note: leave *pSize as is, because we write at the end of the
	// passed-in buffer.
	//

	return Status;
}


NTSTATUS
ArpSFlushArpCache(
	IN	 PINTF					pIntF
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PARP_ENTRY		ArpEntry, NextArpEntry;
	KIRQL			OldIrql;
	UINT			i;

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	for (i = 0; i < ARP_TABLE_SIZE; i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
 			ArpEntry != NULL;
 			ArpEntry = NextArpEntry)
		{
			NextArpEntry = ArpEntry->Next;

			if (ArpEntry->Vc != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

				ArpEntry->Vc->ArpEntry = NULL;

				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			}

			if (ArpEntry->Next != NULL)
			{
				((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
			}
			*(ArpEntry->Prev) = ArpEntry->Next;
			ArpSFreeBlock(ArpEntry);
			pIntF->NumCacheEntries --;
		}
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryOrAddArpEntry(
	IN	 PINTF						pIntF,
	IN	OUT	PIOCTL_QA_ENTRY			pQaBuf,
	IN	OPERATION					Operation
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PARP_ENTRY		ArpEntry;

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	switch (Operation)
	{
  	case QUERY_IP_FROM_ATM:

		if (   !ArpSValidAtmAddress(&pQaBuf->ArpEntry.AtmAddress, 0) // TODO
			|| !ArpSValidAtmAddress(&pQaBuf->ArpEntry.SubAddress, 0)) // TODO
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("QueryIpAddress: Invalid address or subaddress\n"));
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryIpAddress for "));

		ArpSDumpAtmAddr(&pQaBuf->ArpEntry.AtmAddress, "");
		if (pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0)
			ArpSDumpAtmAddr(&pQaBuf->ArpEntry.SubAddress, "\tSub");
		ArpEntry = ArpSLookupEntryByAtmAddr(pIntF,
											&pQaBuf->ArpEntry.AtmAddress,
											(pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0) ?
												&pQaBuf->ArpEntry.SubAddress : NULL);
		Status = STATUS_NOT_FOUND;
		if (ArpEntry != NULL)
		{
			pQaBuf->ArpEntry.IpAddr = ArpEntry->IpAddr;
			Status = STATUS_SUCCESS;
		}
		break;

  	case QUERY_ATM_FROM_IP:
		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryAtmAddress for "));
		ArpSDumpIpAddr(pQaBuf->ArpEntry.IpAddr, "");
		ArpEntry = ArpSLookupEntryByIpAddr(pIntF, pQaBuf->ArpEntry.IpAddr);
		Status = STATUS_NOT_FOUND;
		if (ArpEntry != NULL)
		{
			COPY_ATM_ADDR(&pQaBuf->ArpEntry.AtmAddress, &ArpEntry->HwAddr.Address);
			Status = STATUS_SUCCESS;
		}
		break;

#if 0
  	case ADD_ARP_ENTRY:

		if (   !ArpSValidAtmAddress(&pQaBuf->ArpEntry.AtmAddress, 0) // TODO
			|| !ArpSValidAtmAddress(&pQaBuf->ArpEntry.SubAddress, 0)) // TODO
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("AddArpEntry: Invalid address or subaddress\n"));
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		DBGPRINT(DBG_LEVEL_NOTICE, ("AddArpEntry:  IpAddr "));
		ArpSDumpIpAddr(pQaBuf->ArpEntry.IpAddr, "");
		ArpSDumpAtmAddr(&pQaBuf->ArpEntry.AtmAddress, "");
		if (pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0)
			ArpSDumpAtmAddr(&pQaBuf->ArpEntry.SubAddress, "\tSub");
		ArpEntry = ArpSAddArpEntry(pIntF,
   								pQaBuf->ArpEntry.IpAddr,
   								&pQaBuf->ArpEntry.AtmAddress,
   								(pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0) ?
										&pQaBuf->ArpEntry.SubAddress : NULL,
   								NULL);
#endif // 0
		break;

  	default:
		Status = STATUS_NOT_SUPPORTED;
		break;
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryArpCache(
	IN	PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	)
{
	NTSTATUS			Status = STATUS_SUCCESS;
    PIOCTL_QUERY_CACHE	pQCache = (PIOCTL_QUERY_CACHE)pBuf;
	PARP_ENTRY			ArpEntry;
	PARPENTRY			Entry;
	UINT				i, Total, Remaining;
	UINT				InputSize = (UINT) *pSize;
	UINT				StartIndex;

	#define HEADERSIZE  (UINT)FIELD_OFFSET(IOCTL_QUERY_CACHE, Entries.Entries)

	if (InputSize < HEADERSIZE)
	{
		//
		// We don't even have enough space to store the
		// IOCTL_QUERY_CACHE.Entries structure!
		//
		return STATUS_BUFFER_TOO_SMALL;
	}

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	StartIndex = pQCache->StartEntryIndex;
	pQCache->Entries.TotalNumberOfEntries = pIntF->NumCacheEntries;
	pQCache->Entries.NumberOfEntriesInBuffer = 0;
	Entry = &pQCache->Entries.Entries[0];

	for (i = 0, Total = 0, Remaining = InputSize - HEADERSIZE;
		 i < ARP_TABLE_SIZE;
		 i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
 			ArpEntry != NULL;
 			ArpEntry = ArpEntry->Next)
		{
			//
			// Skip entries until we reach entry # StartIndex
			//
			if (StartIndex != 0)
			{
				StartIndex--;
				continue;
			}

			if (sizeof(*Entry) > Remaining)
			{
				break;
			}
			Remaining -= sizeof(ARPENTRY);
			Entry->IpAddr = ArpEntry->IpAddr;
			Entry->AtmAddress = ArpEntry->HwAddr.Address;
			Entry->SubAddress.NumberOfDigits = 0;
			if (ArpEntry->HwAddr.SubAddress != NULL)
				Entry->SubAddress = *ArpEntry->HwAddr.SubAddress;
			pQCache->Entries.NumberOfEntriesInBuffer ++;
			Entry ++;
		}
		if (Status == STATUS_BUFFER_OVERFLOW)
			break;
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryMarsCache(
	IN	PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	)
/*++

Routine Description:

	Dump the mars cache into pBuf. The structure is QUERY_MARS_CACHE.MarsCache.
	The atm addresses are all placed together at the end of the supplied buffer,
	so the full size, *pSize, is used.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;
	PMARS_ENTRY		pMarsEntry;
	PMARSENTRY		pEntry;
	UINT			i, Total, Remaining;
	KIRQL			OldIrql;
	ATM_ADDRESS 	*pAtmAddr;
	UINT		    InputSize;
	UINT			StartIndex;

    PIOCTL_QUERY_MARS_CACHE	pQCache = (PIOCTL_QUERY_MARS_CACHE)pBuf;

	#define MCHEADERSIZE \
			 ((UINT)FIELD_OFFSET(IOCTL_QUERY_MARS_CACHE, MarsCache.Entries))

	//
	// Since we put stuff at the end of the buffer, let's force the
	// size to be a multiple of ULONG_PTR size.
	//
	InputSize = (UINT)(*pSize) & ~ ((UINT) (sizeof(ULONG_PTR)-1));

	DBGPRINT(DBG_LEVEL_NOTICE,
			("QueryMarsCache: pBuf=0x%lx Size=%lu. pBuf+Size=0x%lx\n",
			pBuf,
			InputSize,
			pBuf+InputSize
			));


	if (InputSize < MCHEADERSIZE)
	{
		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryMarsCache: Size %lu too small. Want %lu\n",
				InputSize,
				MCHEADERSIZE
				));
		//
		// We don't even have enough space to store the
		// IOCTL_QUERY_CACHE.Entries structure!
		//
		return STATUS_BUFFER_TOO_SMALL;
	}

	StartIndex = pQCache->StartEntryIndex;

	// Acquire the lock on the interface now
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);


	pQCache->MarsCache.TotalNumberOfEntries = 0;
	pQCache->MarsCache.Sig = SIG_MARSENTRY;
	pQCache->MarsCache.NumberOfEntriesInBuffer = 0;
	pEntry = &pQCache->MarsCache.Entries[0];

	//
	// We'll go through the entire cache, but only pick up as many
	// as we have space for. pAtmAddr contains the next location to
	// put an atm address -- it starts out at the end of the buffer and
	// works it's way backwards. Meanwhile, the mars entries are growing
	// forward, starting with pQCache->MarseCache.Entries[1].
	// Needless to say, we must keep track of how much space is left.
	//
	pAtmAddr = ((PATM_ADDRESS) (pBuf + InputSize));


	for (i = 0, Total = 0, Remaining = InputSize-MCHEADERSIZE;
		 i < MARS_TABLE_SIZE &&  Status == STATUS_SUCCESS;
		 i++)
	{
		for (pMarsEntry = pIntF->MarsCache[i];
			pMarsEntry != NULL &&  Status == STATUS_SUCCESS;
			pMarsEntry = pMarsEntry->Next)
		{
			PGROUP_MEMBER pGroup;
			UINT		  NumMembersPickedUp=0;

			//
			// Skip entries until we reach entry # StartIndex
			//
			if (StartIndex != 0)
			{
				StartIndex--;
				continue;
			}

			if (sizeof(*pEntry) > Remaining)
			{
				DBGPRINT(
					DBG_LEVEL_NOTICE,
				("QueryMarsCache: \tOut of space. Remaining=%lu\n", Remaining));
				break;
			}


			DBGPRINT(
				DBG_LEVEL_NOTICE,
			("QueryMarsCache: \tPicking up Group 0x%x. IP=0x%08lx NumAddr=%lu pE=0x%x Remaining=%lu\n",
					pMarsEntry,
					pMarsEntry->IPAddress,
					pMarsEntry->NumMembers,
					pEntry,
					Remaining));


			Remaining -= sizeof(*pEntry);

			pQCache->MarsCache.NumberOfEntriesInBuffer ++;
			GETULONG2ULONG(&(pEntry->IpAddr), &(pMarsEntry->IPAddress));
			pEntry->Flags				= 0;
			pEntry->NumAtmAddresses		=  pMarsEntry->NumMembers;
			pEntry->OffsetAtmAddresses	= 0;

			if (MarsIsAddressMcsServed(pIntF, pMarsEntry->IPAddress))
			{
				pEntry->Flags |=  MARSENTRY_MCS_SERVED;
			}

			//
			// Pick up the HW addresses of all the members of this group.
			// (TODO: We don't pick up the subaddress).
			//
			for (
				pGroup = pMarsEntry->pMembers, NumMembersPickedUp=0;
				pGroup != NULL;
				pGroup = pGroup->Next, NumMembersPickedUp++)
			{
				ARPS_ASSERT(pGroup != NULL_PGROUP_MEMBER);

				//
				// Check that we have enough space.
				//
				if (Remaining < sizeof(*pAtmAddr))
				{
					//
					// If there is not enough space to store all atm addresses
					// of a particular group, we return none, this is indicated
					// by setting pEntry->OffsetAtmAdresses to 0.
					//
				DBGPRINT(
					DBG_LEVEL_NOTICE,
					("QueryMarsCache: \t\tOut of space adding addreses. Remaining=%lu\n", Remaining));
					Status = STATUS_BUFFER_OVERFLOW;
					break;
				}
				ARPS_ASSERT( (PUCHAR)(pAtmAddr-1) >= (PUCHAR)(pEntry+1));

				//
				// Copy over the atm address
				//
				DBGPRINT(
					DBG_LEVEL_NOTICE,
			("QueryMarsCache: \t\tPicking up Addr. pDestAddr=%x. Remaining=%lu\n",
					pAtmAddr-1,
					Remaining));
				*--pAtmAddr = pGroup->pClusterMember->HwAddr.Address;
				Remaining -= sizeof(*pAtmAddr);

			}

			if (Status == STATUS_SUCCESS && NumMembersPickedUp)
			{
				//
				// There are non-zero members of this entry and they were
				// all copied successfully. Let's set the offset to these
				// addresses.
				//
				pEntry->OffsetAtmAddresses = 
									(UINT) ((PUCHAR)pAtmAddr - (PUCHAR) pEntry);

				//
				// We expect NumMembersPickedUp to be equal to
				// pMarsEntry->NumMembers.
				//
				ARPS_ASSERT(pMarsEntry->NumMembers == NumMembersPickedUp);

				if (pMarsEntry->NumMembers != NumMembersPickedUp)
				{
					pEntry->NumAtmAddresses	=  NumMembersPickedUp;
				}

				DBGPRINT(
					DBG_LEVEL_NOTICE,
			("QueryMarsCache: \t Picked up all addresses. OffsetAtmAddresses = %lu\n",
					 pEntry->OffsetAtmAddresses));

				pEntry++;

			}

		}

	}
	pQCache->MarsCache.TotalNumberOfEntries = 
		pQCache->MarsCache.NumberOfEntriesInBuffer; // TODO

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return Status;
}

UINT
ArpSElapsedSeconds(
	IN	PLARGE_INTEGER 			pStatisticsStartTimeStamp
	)
/*++

Routine Description:

	Return the elapsed time, in seconds, relative to *pStatisticsStartTimeStamp

Arguments:

	pStatisticsStartTimeStamp	ptr to the start time.

Return Value:

	None

--*/
{
	UINT Ret;
	LARGE_INTEGER	Current;
 	NdisGetCurrentSystemTime(&Current);

	//
	// Current is in units of 100-nanoseconds so we must convert the difference
	// to seconds. Note we use implicit large-arithmetic operators here.
	//
	Ret = (UINT) ((Current.QuadPart - pStatisticsStartTimeStamp->QuadPart)/10000000);

	return Ret;
}

extern
NTSTATUS
ArpSQueryArpStats(
	IN	PINTF					pIntF,
	OUT	PARP_SERVER_STATISTICS 	pArpStats
	)
/*++

Routine Description:

	Fill in the current arp statistics. Also set the ElapsedSeconds field
	to the time in seconds since statistics computation started.

Arguments:

	pIntF		- The interface applicable to the request
	pArpStats	- Arp statistics to fill out

Return Value:

	STATUS_SUCCESS	

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	*pArpStats = pIntF->ArpStats; // big structure copy.

	pArpStats->ElapsedSeconds = ArpSElapsedSeconds(
										&(pIntF->StatisticsStartTimeStamp)
										);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return STATUS_SUCCESS;
}

extern
NTSTATUS
ArpSQueryMarsStats(
	IN	PINTF					pIntF,
	OUT	PMARS_SERVER_STATISTICS pMarsStats
	)
/*++

Routine Description:

	Fill in the current mars statistics. Also set the ElapsedSeconds field
	to the time in seconds since statistics computation started.

Arguments:

	pIntF		- The interface applicable to the request
	pMarsStats	- Mars statistics to fill out.

Return Value:

	STATUS_SUCCESS	

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	*pMarsStats = pIntF->MarsStats; // big structure copy.

	pMarsStats->ElapsedSeconds = ArpSElapsedSeconds(
										&(pIntF->StatisticsStartTimeStamp)
										);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return STATUS_SUCCESS;
}

extern
VOID
ArpSResetStats(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Reset all arp and mars statistics. Update the statistics start timestamp.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived

Return Value:

	None

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ZERO_MEM(&(pIntF->ArpStats), sizeof(pIntF->ArpStats));
	ZERO_MEM(&(pIntF->MarsStats), sizeof(pIntF->MarsStats));

	NdisGetCurrentSystemTime(&(pIntF->StatisticsStartTimeStamp));

	//
	// Now recompute the "current" and "max" values...
	//

	//
	// Arp cache entries
	//
	pIntF->ArpStats.CurrentArpEntries
	= pIntF->ArpStats.MaxArpEntries
	= pIntF->NumCacheEntries;

	//
	// Cluster member count
	//
	{
		pIntF->MarsStats.CurrentClusterMembers
		= pIntF->MarsStats.MaxClusterMembers
		= pIntF->NumClusterMembers;
	}

	//
	// MCast group count and max group-size - we have to go through the entire
	// mars cache to get this information.
	//
	{
		UINT u;
		UINT MaxGroupSize;
		UINT NumGroups;
	
		for (u = 0, MaxGroupSize = 0, NumGroups = 0;
			u < MARS_TABLE_SIZE;
			u++)
		{
			PMARS_ENTRY		pMarsEntry;

			for (pMarsEntry = pIntF->MarsCache[u];
				pMarsEntry != NULL;
				pMarsEntry = pMarsEntry->Next)
			{
				if (MaxGroupSize < pMarsEntry->NumMembers)
				{
					MaxGroupSize = pMarsEntry->NumMembers;
				}
				NumGroups++;
			}
		}

		pIntF->MarsStats.CurrentGroups
		= pIntF->MarsStats.MaxGroups
		= NumGroups;

		pIntF->MarsStats.MaxAddressesPerGroup = MaxGroupSize;

	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\mars.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	mars.c

Abstract:

	This file contains the code to implement the functionality of
	Multicast Address Resolution Server (MARS), and a minimal
	MultiCast Server (MCS).

	Reference: RFC 2022

Author:

	Jameel Hyder (jameelh@microsoft.com)	January 1997

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_MARS

ULONG	ArpSMarsControlFreeCount = 0;

#define MARS_CO_SEND_PACKETS(_Vc, _PktArray, _PktCount)							\
{																				\
	ULONG			_Count;														\
	NDIS_HANDLE		_NdisVcHandle = (_Vc)->NdisVcHandle;						\
																				\
	if (_NdisVcHandle != NULL)													\
	{																			\
		NdisCoSendPackets(_NdisVcHandle, _PktArray, _PktCount);					\
	}																			\
	else																		\
	{																			\
		for (_Count = 0; _Count < _PktCount; _Count++)							\
		{																		\
			ArpSCoSendComplete(NDIS_STATUS_FAILURE, _Vc, _PktArray[_Count]);	\
		}																		\
	}																			\
}

VOID
MarsReqThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle all MARS requests here.

Arguments:

	None

Return Value:

	None
--*/
{
	PMARS_HEADER		Header;
	PLIST_ENTRY			List;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	PARP_VC				Vc;
	UINT				PktLen;
	PINTF				pIntF;

	ARPS_PAGED_CODE( );

	MARSDBGPRINT(DBG_LEVEL_INFO,
			("MarsReqThread: Came to life\n"));

	do
	{
		List = KeRemoveQueue(&MarsReqQueue, KernelMode, NULL);
		if (List == &ArpSEntryOfDeath)
		{
			//
			// Asked to terminate, do so.
			//
			break;
		}

		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, ReqList);
		if (Resd->Flags & RESD_FLAG_KILL_CCVC)
		{
			pIntF = (PINTF)Resd->Vc;
			MARSDBGPRINT(DBG_LEVEL_NOTICE,
				("MARS Thread: will kill CCVC on pIntF %x\n", pIntF));
			FREE_MEM(Resd);
			MarsAbortAllMembers(pIntF);
			continue;
		}


		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		Vc = Resd->Vc;
		pIntF = Vc->IntF;

		pIntF->MarsStats.TotalRecvPkts++;

		if (pIntF->Flags & INTF_STOPPING)
		{
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("MARS Thread: pIntF %x is stopping, dropping pkt %x\n", pIntF, Pkt));

			pIntF->MarsStats.DiscardedRecvPkts++;
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
			continue;
		}
	
		NdisQueryBuffer(Pkt->Private.Head, &Header, &PktLen);

		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MARS Thread: Resd %x, Pkt %x, PktLen %x, Header %x, Op %x, Vc %x, IntF %x\n",
					Resd, Pkt, PktLen, Header, Header->Opcode, Vc, pIntF));

		ARPS_ASSERT (PktLen <= PKT_SPACE);

		switch(Header->Opcode)
		{
		  case OP_MARS_REQUEST:
			MarsHandleRequest(pIntF, Vc, Header, Pkt);
			break;

		  case OP_MARS_JOIN:
			MarsHandleJoin(pIntF, Vc, Header, Pkt);
			break;

		  case OP_MARS_LEAVE:
			MarsHandleLeave(pIntF, Vc, Header, Pkt);
			break;
		  default:
		  	MARSDBGPRINT(DBG_LEVEL_FATAL,
		  			("MarsReqThread: Opcode %x unknown\n", Header->Opcode));
			pIntF->MarsStats.DiscardedRecvPkts++;

		  	ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);

		  	break;
		}

	} while (TRUE);

	KeSetEvent(&ArpSReqThreadEvent, 0, FALSE);

	MARSDBGPRINT(DBG_LEVEL_WARN,
			("MarsReqThread: Terminating\n"));
}


VOID
MarsHandleRequest(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_REQUEST. If the sender is a valid registered Cluster member,
	lookup the desired target group address in the MARS cache. If found, send
	a sequence of one or more MARS MULTIs. Include the addresses  of members
	who are monitoring the entire class-D address space.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None

--*/
{
	HW_ADDR					SrcAddr;
	HW_ADDR **				pPromisHWAddrArray;
	HW_ADDR **				ppPromisHWAddr;
	ATM_ADDRESS				SrcSubAddr;
	IPADDR					GrpAddr;
	PCLUSTER_MEMBER			pMember;
	PGROUP_MEMBER			pGroup;
	PMARS_ENTRY				pMarsEntry;
	NDIS_STATUS				Status;
	PMARS_REQUEST			RHdr;
	PUCHAR					p;
	PPROTOCOL_RESD			Resd, MultiResd;
	ULONG					SeqY;
	ULONG					Length;
	ULONG					CopyLength;
	ULONG					PacketLength;

	PNDIS_PACKET			MultiPacket;
	PNDIS_PACKET			HeadMultiList;
	PNDIS_PACKET *			pTailMultiList;
	ULONG					AddrCountThisPacket;
	ULONG					AddrPerPacket;
	INT						AddrRem;
	INT			 			NumUniquePromisEntries;
	PMARS_MULTI				MHdr;

	KIRQL					OldIrql;
	BOOLEAN					LockAcquired;
	BOOLEAN					SendNak;
	BOOLEAN					Discarded=TRUE;

	RHdr = (PMARS_REQUEST)Header;
	Resd = RESD_FROM_PKT(Packet);
	LockAcquired = FALSE;
	SendNak = FALSE;

	do
	{
		pIntF->MarsStats.TotalRequests++;
	
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_REQUEST))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		Length = sizeof(MARS_REQUEST) + RHdr->SrcProtoAddrLen +
				 TL_LEN(RHdr->SrcAddressTL) +
				 TL_LEN(RHdr->SrcSubAddrTL) +
				 RHdr->TgtGroupAddrLen;
	
		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		//
		// Expect NULL target ATM address/subaddress
		//
		if ((RHdr->TgtAddressTL != 0) ||
			(RHdr->TgtSubAddrTL != 0))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Non-null target HW address %x or %x\n",
						RHdr->TgtAddressTL,
						RHdr->TgtSubAddrTL));
			break;
		}

		//
		// Go to the variable length part, consisting of:
		// Source ATM Number (mandatory)
		// Source ATM Subaddress (optional)
		// Source protocol address (optional)
		// Target group address (mandatory)
		//
		p = (PUCHAR)(RHdr + 1);

		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}

		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// NOTE:
		//
		// We only support full length Source ATM Number,
		// and zero-length Source ATM Subaddress.
		//
		if ((SrcAddr.Address.NumberOfDigits != ATM_ADDRESS_LENGTH) ||
			(SrcAddr.SubAddress != NULL))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: unsupported ATM Number len %x or non-zero subaddr\n",
							SrcAddr.Address.NumberOfDigits));
			break;
		}

		if ((RHdr->SrcProtoAddrLen != 0) && 
			(RHdr->SrcProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: bad src proto addr len %x\n", RHdr->SrcProtoAddrLen));
			break;
		}

		p += RHdr->SrcProtoAddrLen;


		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;
		
		//
		// We honor this REQUEST only if it has come from a legitimate
		// Cluster Member.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);
		if ((pMember == NULL_PCLUSTER_MEMBER) ||
			(MARS_GET_CM_CONN_STATE(pMember) != CM_CONN_ACTIVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: from unconnected cluster member: "));
			MARSDUMPATMADDR(DBG_LEVEL_ERROR, &SrcAddr.Address, "");
			break;
		}
		Discarded = FALSE;	// For stats.


		//
		// Target Group address being resolved.
		//
		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleReq: Request from pMember %x for Addr ", pMember));
		MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");

		GETULONG2ULONG(&GrpAddr, p);

		//
		// Fill in our Seq number just in case we decide to send a NAK
		// using this packet
		//
		PUTULONG2ULONG(&(RHdr->SequenceNumber), pIntF->CSN);

		//
		// Check if we are the MCS serving the desired group address.
		//
		if (MarsIsAddressMcsServed(pIntF, GrpAddr))
		{
			PATM_ADDRESS	pAtmAddr = &(pIntF->ConfiguredAddress);

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsHandleReq: sending MULTI with MCS for "));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, *(UNALIGNED IPADDR *)p, "\n");

			//
			// Prepare a MARS MULTI with our address and return it.
			//
			PacketLength = Length + pAtmAddr->NumberOfDigits +
							sizeof(MARS_TLV_MULTI_IS_MCS) +
							sizeof(MARS_TLV_NULL);

			MultiPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&MHdr);
			if (MultiPacket != (PNDIS_PACKET)NULL)
			{
				ULONG		ExtOff;

				COPY_MEM(MHdr, RHdr, Length);

				MHdr->Opcode = OP_MARS_MULTI;
				MHdr->TgtAddressTL = TL(pAtmAddr->AddressType, pAtmAddr->NumberOfDigits);

				PUTULONG2ULONG(&(MHdr->SequenceNumber), pIntF->CSN);
				PUTSHORT2SHORT(&(MHdr->NumTgtGroupAddr), 1);
				SeqY = LAST_MULTI_FLAG | 1;
				PUTSHORT2SHORT(&(MHdr->FlagSeq), SeqY);

				p = (PUCHAR)MHdr + Length;
				COPY_MEM(p, pAtmAddr->Address, pAtmAddr->NumberOfDigits);
				p += pAtmAddr->NumberOfDigits;

				//
				// Calculate and fill in the extensions offset. This is the
				// offset, calculated from the HwType (afn) field, where
				// we put in the "MULTI is MCS" TLV.
				//
				ExtOff = (ULONG) (p - (PUCHAR)MHdr - sizeof(LLC_SNAP_HDR));
				PUTSHORT2SHORT(&MHdr->ExtensionOffset, ExtOff);

				//
				// Fill in the MULTI is MCS TLV
				//
				COPY_MEM(p, &MultiIsMcsTLV, sizeof(MultiIsMcsTLV));
				p += sizeof(MultiIsMcsTLV);

				//
				// Fill in a NULL (terminating) TLV
				//
				COPY_MEM(p, &NullTLV, sizeof(NullTLV));

				pIntF->MarsStats.MCSAcks++;


				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockAcquired = FALSE;

				MARS_CO_SEND_PACKETS(Vc, &MultiPacket, 1);

			}

			break;
		}

		pMarsEntry = MarsLookupMarsEntry(pIntF, GrpAddr, FALSE);
		if (pMarsEntry!=NULL && pMarsEntry->NumMembers==0)
		{
			pMarsEntry=NULL; // just to simplify tests later on.
		}

		//
		// Pick up the h/w address of all members that are members
		// of the entire class-D address space  (promiscuous members),
		// but which are not monitoring
		// the specific group address requested here. Pointers to these h/w addresses
		// are saved in ALLOC_NP_MEM allocated array pPromisHWAddrArray.
		// NumUniquePromisEntries is the count of these addresses.
		//
		{
			PMARS_ENTRY				pPromisMarsEntry;
			INT						TotPromisEntries;
			PGROUP_MEMBER			pPromisGroup;

			NumUniquePromisEntries = 0;

			//
			// Get total count of promiscuous members.
			//
			TotPromisEntries	   = 0;
			pPromisMarsEntry = MarsLookupMarsEntry(pIntF,  IPADDR_FULL_RANGE, FALSE);
			if (pPromisMarsEntry != NULL_PMARS_ENTRY)
			{
				TotPromisEntries = pPromisMarsEntry->NumMembers;
			}
	
			//
			// Allocate space to hold the hw addresses of all of them.
			//
			pPromisHWAddrArray = NULL;
			if (TotPromisEntries != 0)
			{
				pPromisHWAddrArray = (HW_ADDR **) ALLOC_NP_MEM(
												TotPromisEntries*sizeof(HW_ADDR *),
												POOL_TAG_MARS
												);
				if (pPromisHWAddrArray == NULL)
				{
					//
					// On alloc failure, simply ignore promiscuous members.
					//
					TotPromisEntries = 0;
				}
			}

			//
			// Now only pick up the hw addresses of those members who
			// are not also members of the specific group requested.
			//
			if (TotPromisEntries!=0)
			{
				PGROUP_MEMBER			pGroupStart = NULL;
				if (pMarsEntry!=NULL)
				{
					pGroupStart = pMarsEntry->pMembers;
				}

				for(
					pPromisGroup = pPromisMarsEntry->pMembers;
					TotPromisEntries!=0 && pPromisGroup!=NULL;
					TotPromisEntries--, pPromisGroup = pPromisGroup->Next)
				{
					for (pGroup = pGroupStart;
 						pGroup!=NULL;
 						pGroup = pGroup->Next)
					{
						if (pPromisGroup->pClusterMember ==  pGroup->pClusterMember)
						{
							break;
						}
					}
	
					if (pGroup == NULL)
					{
						//
						// pPromisGroup->pClusterMember is a promiscuous member
						// who is not also a member of the specific group
						// GrpAddr, so we save a pointer to its hw address
						// in our array.
						//
						pPromisHWAddrArray[NumUniquePromisEntries++] =
								&(pPromisGroup->pClusterMember->HwAddr);
					}
				}
			}

			if (NumUniquePromisEntries == 0 && TotPromisEntries != 0)
			{
				FREE_MEM(pPromisHWAddrArray);
				pPromisHWAddrArray = NULL;
				TotPromisEntries = 0;
			}
		}


		//
		// Total addresses equals number of members of the specific group (if any)
		// plus NumUniquePromisEntries
		//
		AddrRem = NumUniquePromisEntries;
		if (pMarsEntry != NULL_PMARS_ENTRY)
		{
			AddrRem += pMarsEntry->NumMembers;
		}

		if (AddrRem == 0)
		{
			RHdr->Opcode = OP_MARS_NAK;
			SendNak = TRUE;
			pIntF->MarsStats.Naks++;

			break;
		}


		// We've computed the total number of hw address we're going to
		// send: AddrRem. This consistes of the addresses of all the
		// members of the specific group GrpAddr, as well as any
		// members of the entire class D space which are not members of
		// the specific group.
		//
		// We'll now create MARS_MULTI send pkts for
		// all these hw addresses, starting with the
		// the addresses of the specific group, and then tacking on
		// the class-D members.
		//

		//
		// Each MARS_MULTI will begin with a copy of the MARS_REQUEST.
		//
		CopyLength = Length;

		AddrPerPacket = (Vc->MaxSendSize - CopyLength)/ATM_ADDRESS_LENGTH;

		HeadMultiList = NULL;
		pTailMultiList = &HeadMultiList;
		SeqY = 1;

		if (pMarsEntry != NULL)
		{
			pGroup = pMarsEntry->pMembers;
		}
		else
		{
			pGroup = NULL;
		}
		ppPromisHWAddr = pPromisHWAddrArray;


		for (; AddrRem != 0; SeqY++)
		{
			AddrCountThisPacket = MIN(AddrRem, (INT)AddrPerPacket);
			AddrRem -= AddrCountThisPacket;

			PacketLength = CopyLength + (AddrCountThisPacket * ATM_ADDRESS_LENGTH);
			MultiPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&MHdr);
			if (MultiPacket != (PNDIS_PACKET)NULL)
			{
				COPY_MEM(MHdr, RHdr, Length);

				MHdr->Opcode = OP_MARS_MULTI;
				MHdr->TgtAddressTL = ATM_ADDRESS_LENGTH;
				MHdr->TgtSubAddrTL = 0;

				PUTULONG2ULONG(&(MHdr->SequenceNumber), pIntF->CSN);
				PUTSHORT2SHORT(&(MHdr->NumTgtGroupAddr), AddrCountThisPacket);

#if 0
				p = (PUCHAR)(MHdr + 1);
#else
				p = (PUCHAR)MHdr + CopyLength;
#endif
				while (AddrCountThisPacket-- != 0)
				{
					HW_ADDR *pHWAddr;

					if (pGroup != NULL)
					{
						pHWAddr =  &(pGroup->pClusterMember->HwAddr);
						pGroup = pGroup->Next;
					}
					else
					{
						ARPS_ASSERT(  ppPromisHWAddr
								    < (pPromisHWAddrArray + NumUniquePromisEntries));
						pHWAddr = *(ppPromisHWAddr++);
					}

					COPY_MEM( p,
						pHWAddr->Address.Address,
						pHWAddr->Address.NumberOfDigits);

					p += pHWAddr->Address.NumberOfDigits;

				}

				if (AddrRem == 0)
				{
					SeqY |= LAST_MULTI_FLAG;
				}

				PUTSHORT2SHORT(&(MHdr->FlagSeq), SeqY);

				//
				// Link to tail of list of MULTIs.
				//
				*pTailMultiList = MultiPacket;
				MultiResd = RESD_FROM_PKT(MultiPacket);
				pTailMultiList = (PNDIS_PACKET *)&(MultiResd->ReqList.Flink);
				MultiResd->ReqList.Flink = NULL;
			}
			else
			{
				//
				// Failed to allocate MULTI: free all packets allocated so far
				//
				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockAcquired = FALSE;

				while (HeadMultiList != NULL)
				{
					MultiPacket = HeadMultiList;
					MultiResd = RESD_FROM_PKT(MultiPacket);
					HeadMultiList = (PNDIS_PACKET)MultiResd->ReqList.Flink;

					MarsFreePacket(MultiPacket);
				}

				break;
			}
		}

		//
		// Unless there was an allocation failure (HeadMultiList == NULL),
		// we had better have gone through all the hw addresses...
		//
		ARPS_ASSERT(
			HeadMultiList == NULL
			|| (pGroup == NULL
		   	    && (ppPromisHWAddr == (pPromisHWAddrArray+NumUniquePromisEntries))));

		//
		// We're done with the temporary array of pointers to unique
		// promiscuous hw members.
		//
		if (pPromisHWAddrArray != NULL)
		{
			FREE_MEM(pPromisHWAddrArray);
		}

		if (HeadMultiList != NULL)
		{
			pIntF->MarsStats.VCMeshAcks++;
		}
		
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		LockAcquired = FALSE;

		if (HeadMultiList != NULL)
		{
			//
			// Send all MULTIs.
			//
			do
			{
				MultiPacket = HeadMultiList;
				MultiResd = RESD_FROM_PKT(MultiPacket);
				HeadMultiList = (PNDIS_PACKET)MultiResd->ReqList.Flink;
	
				MARS_CO_SEND_PACKETS(Vc, &MultiPacket, 1);
			}
			while (HeadMultiList != NULL);
		}

		break;
	}
	while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}

	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Free the MARS_REQUEST copy if we didn't reuse it.
	//
	if (SendNak)
	{
		//
		// Send MARS_NAK back
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		ArpSDereferenceVc(Vc, FALSE, TRUE);
		Resd->Vc = NULL;
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);
	}

}


VOID
MarsHandleJoin(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_JOIN.

	This is issued as part of register (Flags register bit is set and no group addresses
	are specified) or to join a group address range.

Arguments:

	pIntF	- The interface on which the MARS_JOIN arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None
--*/
{
	NDIS_STATUS			Status;
	PMARS_JOIN_LEAVE	JHdr;
	PPROTOCOL_RESD		Resd;
	HW_ADDR				SrcAddr;
	ATM_ADDRESS			SrcSubAddr;
	MCAST_ADDR_PAIR		GrpAddrRange;
	UINT				Length;
	USHORT				Flags, AddrPairs, CMI;
	PUCHAR				p;
	BOOLEAN				bSendReply = FALSE, NewMember = FALSE;
	PCLUSTER_MEMBER		pMember;
	PNDIS_PACKET		ClusterPacket;	// Reply packet to be sent on ClusterControlVc
	KIRQL				OldIrql;
	BOOLEAN				LockAcquired;
	BOOLEAN				Discarded=TRUE, JoinFailed=FALSE, RegistrationFailed=FALSE;


	JHdr = (PMARS_JOIN_LEAVE)Header;
	Resd = RESD_FROM_PKT(Packet);
	ClusterPacket = (PNDIS_PACKET)NULL;
	LockAcquired = FALSE;

	do
	{
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_JOIN_LEAVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		GETSHORT2SHORT(&Flags, &JHdr->Flags);
		GETSHORT2SHORT(&AddrPairs, &JHdr->NumGrpAddrPairs);
		GETSHORT2SHORT(&CMI, &JHdr->ClusterMemberId);

		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleJoin: Pkt %x, Flags %x, AddrPairs %x, CMI %x\n",
					Packet, Flags, AddrPairs, CMI));

		if (Flags & JL_FLAGS_REGISTER)
		{
			RegistrationFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.RegistrationRequests++;
		}
		else
		{
			JoinFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.TotalJoins++;
		}
		
		Length = sizeof(MARS_JOIN_LEAVE) + JHdr->SrcProtoAddrLen +
				 TL_LEN(Header->SrcAddressTL) +
				 2*AddrPairs*(JHdr->GrpProtoAddrLen);

		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		if (Flags & JL_FLAGS_COPY)
		{
			MARSDBGPRINT(DBG_LEVEL_WARN,
					("MarsHandleJoin: dropping pkt %x with COPY set\n", Packet));
			break;
		}

		if (((Flags & JL_FLAGS_REGISTER) == 0) && (JHdr->GrpProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid Grp address length %x\n",
					JHdr->GrpProtoAddrLen));
			break;
		}
	
		if (((AddrPairs == 0) && ((Flags & JL_FLAGS_REGISTER) == 0)) ||
			((Flags & JL_FLAGS_REGISTER) && (AddrPairs != 0)))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid flags/addr pair combination - %x.%x\n",
					Flags, AddrPairs));
			break;
		}

		p = (PUCHAR)(JHdr + 1);
		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}
		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// We only support full length Source ATM Number,
		// and zero-length Source ATM Subaddress.
		//
		// This is because it is not easy to prepare MARS_MULTI
		// messages when you have an arbitrary mix of ATM Number and
		// ATM Subaddress lengths in the member list for a group.
		//
		if ((SrcAddr.Address.NumberOfDigits != ATM_ADDRESS_LENGTH) ||
			(SrcAddr.SubAddress != NULL))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: unsupported ATM Number len %x or non-zero subaddr\n",
							SrcAddr.Address.NumberOfDigits));
			break;
		}

		//
		// We do not care about the Src Ip Addr
		//
		p += JHdr->SrcProtoAddrLen;

		//
		// Atmost one Address Pair can be present in a JOIN
		//
		if (AddrPairs > 1)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Too many address pairs: %x\n", AddrPairs));
			break;
		}

		//
		// Get the group addr pair, if present
		//
		if (AddrPairs != 0)
		{
			MARSDBGPRINT(DBG_LEVEL_LOUD,
					("MarsHandleJoin: Group Min: "));
			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, ", Group Max ");
			GETULONG2ULONG(&GrpAddrRange.MinAddr, p);
			p += IP_ADDR_LEN;

			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");
			GETULONG2ULONG(&GrpAddrRange.MaxAddr, p);
			p += IP_ADDR_LEN;

			//
			// We only support two kinds of JOIN: single group JOIN, or
			// JOIN for the entire Class D space. If this is any other
			// kind, dump it.
			//
			if ((GrpAddrRange.MinAddr != GrpAddrRange.MaxAddr) 			&&
				((GrpAddrRange.MinAddr != MIN_CLASSD_IPADDR_VALUE) ||
				 (GrpAddrRange.MaxAddr != MAX_CLASSD_IPADDR_VALUE)))
			{
				MARSDBGPRINT(DBG_LEVEL_ERROR,
						("MarsHandleJoin: invalid pair %x - %x\n",
							GrpAddrRange.MinAddr, GrpAddrRange.MaxAddr));
				break;
			}
		}

		//
		// Set the COPY bit right here in case we send this packet
		// back. Also fill in the MARS Seq Number.
		//
		Flags |= JL_FLAGS_COPY;
		PUTSHORT2SHORT(&JHdr->Flags, Flags);
		PUTULONG2ULONG(&(JHdr->MarsSequenceNumber), pIntF->CSN);
		Discarded = FALSE; // for stats.
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;

		//
		// Search for this (potential) cluster member in our database.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);

		if (Flags & JL_FLAGS_REGISTER)
		{
			//
			// A cluster member attempting to register.
			//

			//
			// No groups expected in Registration Join.
			//
			if (AddrPairs != 0)
			{

				break;	// discard
			}

			//
			// Create a new entry if we need to.
			//
			if (pMember == NULL_PCLUSTER_MEMBER)
			{
				//
				// If the ClusterControlVc is closing, discard this: we
				// are in no shape to handle this now.
				//
				if ((pIntF->ClusterControlVc != NULL_PMARS_VC)		&&
					MARS_GET_VC_CONN_STATE(pIntF->ClusterControlVc) == MVC_CONN_CLOSING)
				{
					break;
				}

				pMember = MarsCreateClusterMember(pIntF, &SrcAddr);
				if (pMember != NULL_PCLUSTER_MEMBER)
				{
					NewMember = TRUE;
				}
			}

			if (pMember != NULL_PCLUSTER_MEMBER)
			{
				//
				// Successfully registered this Cluster member. Reflect the
				// JOIN message back to it with COPY bit set and PUNCHED bit
				// reset.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&JHdr->Flags, Flags);
				PUTSHORT2SHORT(&JHdr->ClusterMemberId, pMember->CMI);
				PUTULONG2ULONG(&JHdr->MarsSequenceNumber, pIntF->CSN);
				bSendReply = TRUE;
				RegistrationFailed = FALSE;
			}
		}
		else
		{
			//
			// A cluster member Joining one or more multicast groups.
			// Allow this only if the cluster member has been
			// successfully added to ClusterControlVc AND it is in a position to add groups to it.
			//
			if ((pMember != NULL_PCLUSTER_MEMBER) &&
				(MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_ACTIVE) &&
				(MARS_GET_CM_GROUP_STATE(pMember) == CM_GROUP_ACTIVE))
			{
				if (AddrPairs != 0)
				{
					if (MarsAddClusterMemberToGroups(
										pIntF,
										pMember,
										&GrpAddrRange,
										Packet,
										JHdr,
										Length,
										&ClusterPacket
										))
					{
						JoinFailed = FALSE;	// For stats.
						bSendReply = TRUE;
					}
					else if (ClusterPacket!=NULL)
					{
						JoinFailed = FALSE; // For stats.
					}
				}
				//
				// else discard: no groups specified.
				//
			}
			//
			// else discard: unknown member or member not added to ClusterControlVc
			//
		}

	
	} while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (RegistrationFailed)
	{
		pIntF->MarsStats.FailedRegistrations++; // this includes failures due to bad pkts.
	}
	if (JoinFailed)
	{
		pIntF->MarsStats.FailedJoins++;	// this include failures due to bad pkts.
	}
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}
					
	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Follow up actions:
	//
	// - We may send a reply on the VC this packet came on
	// - We may initiate AddParty to add a new member to ClusterControlVc
	// - We may send a reply packet on ClusterControlVc
	//

	if (bSendReply)
	{
		//
		// Send this back on the VC we received the JOIN from
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		if (ClusterPacket != Packet)
		{
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		}
		//
		// else we're sending Packet on CC VC
		//
	}

	if (NewMember)
	{
		MarsAddMemberToClusterControlVc(pIntF, pMember);
	}

	if (ClusterPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Send this packet on ClusterControlVc.
		//
		MarsSendOnClusterControlVc(pIntF, ClusterPacket);
	}
}


VOID
MarsHandleLeave(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_LEAVE.

Arguments:

	pIntF	- The interface on which the MARS_LEAVE arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None
--*/
{
	NDIS_STATUS			Status;
	PMARS_JOIN_LEAVE	LHdr;
	PPROTOCOL_RESD		Resd;
	HW_ADDR				SrcAddr;
	ATM_ADDRESS			SrcSubAddr;
	MCAST_ADDR_PAIR		GrpAddrRange;
	UINT				Length;
	USHORT				Flags, AddrPairs, CMI;
	PUCHAR				p;
	BOOLEAN				bSendReply = FALSE, Deregistered = FALSE;
	PCLUSTER_MEMBER		pMember;
	PNDIS_PACKET		ClusterPacket;	// Reply packet to be sent on ClusterControlVc
	KIRQL				OldIrql;
	BOOLEAN				LockAcquired;
	BOOLEAN				Discarded=TRUE, LeaveFailed=FALSE;


	LHdr = (PMARS_JOIN_LEAVE)Header;
	Resd = RESD_FROM_PKT(Packet);
	ClusterPacket = (PNDIS_PACKET)NULL;
	LockAcquired = FALSE;

	do
	{
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_JOIN_LEAVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		GETSHORT2SHORT(&Flags, &LHdr->Flags);
		GETSHORT2SHORT(&AddrPairs, &LHdr->NumGrpAddrPairs);
		GETSHORT2SHORT(&CMI, &LHdr->ClusterMemberId);
	
		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleLeave: Pkt %x, Flags %x, AddrPairs %x, CMI %x\n",
					Packet, Flags, AddrPairs, CMI));

		Length = sizeof(MARS_JOIN_LEAVE) + LHdr->SrcProtoAddrLen +
				 TL_LEN(Header->SrcAddressTL) +
				 2*AddrPairs*(LHdr->GrpProtoAddrLen);

		if (Flags & JL_FLAGS_REGISTER)
		{
			// We don't track de-registrations.
		}
		else
		{
			LeaveFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.TotalLeaves++;
		}
		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		if (Flags & JL_FLAGS_COPY)
		{
			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsHandleLeave: dropping pkt %x with COPY set\n", Packet));
			break;
		}

		if (((Flags & JL_FLAGS_REGISTER) == 0) && (LHdr->GrpProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid Grp address length %x\n",
					LHdr->GrpProtoAddrLen));
			break;
		}
	
		if (((AddrPairs == 0) && ((Flags & JL_FLAGS_REGISTER) == 0)) ||
			((Flags & JL_FLAGS_REGISTER) && (AddrPairs != 0)))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid flags/addr pair combination - %x.%x\n",
					Flags, AddrPairs));
			break;
		}

		p = (PUCHAR)(LHdr + 1);
		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}
		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// We do not care about the Src Ip Addr
		//
		p += LHdr->SrcProtoAddrLen;

		//
		// Atmost one Address Pair can be present in a LEAVE
		//
		if (AddrPairs > 1)
		{
			break;
		}

		//
		// Get the group addr pair, if present
		//
		if (AddrPairs != 0)
		{
			MARSDBGPRINT(DBG_LEVEL_LOUD,
					("HandleLeave: Group Min: "));
			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, ", Group Max ");
			GETULONG2ULONG(&GrpAddrRange.MinAddr, p);
			p += IP_ADDR_LEN;

			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");
			GETULONG2ULONG(&GrpAddrRange.MaxAddr, p);
			p += IP_ADDR_LEN;

			//
			// We only support two kinds of non-deregistration LEAVE:
			// single group LEAVE, or LEAVE for the entire Class D space.
			// If this is any other kind, dump it.
			//
			if ((GrpAddrRange.MinAddr != GrpAddrRange.MaxAddr) 			&&
				((GrpAddrRange.MinAddr != MIN_CLASSD_IPADDR_VALUE) ||
				 (GrpAddrRange.MaxAddr != MAX_CLASSD_IPADDR_VALUE)))
			{
				break;
			}
		}

		//
		// Set the COPY bit right here in case we send this packet
		// back. Also fill in the MARS Seq Number.
		//
		Flags |= JL_FLAGS_COPY;
		PUTSHORT2SHORT(&LHdr->Flags, Flags);
		PUTULONG2ULONG(&(LHdr->MarsSequenceNumber), pIntF->CSN);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;
		Discarded = FALSE; // For stats.
		//
		// Search for this (potential) cluster member in our database.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);

		if (Flags & JL_FLAGS_REGISTER)
		{
			//
			// A cluster member attempting to de-register.
			//

			if (AddrPairs == 0)
			{
				if (pMember != NULL_PCLUSTER_MEMBER)
				{
					//
					// Unlink all Group structures from the Cluster member,
					// AND disable further groups from being added.
					//
					MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);
					Deregistered = TRUE;
					//
					// Successfully de-registered this Cluster member. Reflect the
					// LEAVE message back to it with COPY bit set and PUNCHED bit
					// reset.
					//
					Flags &= ~JL_FLAGS_PUNCHED;
					PUTSHORT2SHORT(&LHdr->Flags, Flags);
					PUTULONG2ULONG(&LHdr->MarsSequenceNumber, pIntF->CSN);
					bSendReply = TRUE;
				}
			}
			//
			// else discard: no groups expected in DeRegistration Leave
			//
		}
		else
		{
			//
			//  A cluster member Leaving one or more multicast groups.
			//
			if (AddrPairs != 0)
			{
				if (MarsDelClusterMemberFromGroups(
									pIntF,
									pMember,
									&GrpAddrRange,
									Packet,
									LHdr,
									Length,
									&ClusterPacket
									))
				{
					bSendReply = TRUE;
					LeaveFailed = FALSE;
				}
			}
			//
			// else discard: no groups specified.
			//
		}

	
	} while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (LeaveFailed)
	{
		pIntF->MarsStats.FailedLeaves++;	// this includes failures due to bad pkts.
	}
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}
					
	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Follow up actions:
	//
	// - We may send a reply on the VC this packet came on
	// - We may initiate DropParty to delete a member from ClusterControlVc
	// - We may send a reply packet on ClusterControlVc
	//

	if (bSendReply)
	{
		//
		//  Send this back on the VC we received the JOIN from
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		if (ClusterPacket != Packet)
		{
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		}
		//
		// else we're sending this packet on CC VC
		//
	}

	if (Deregistered)
	{
		BOOLEAN fLocked =
			  MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
		ASSERT(!fLocked);
	}

	if (ClusterPacket != NULL)
	{
		//
		//  Send this packet on ClusterControlVc.
		//
		MarsSendOnClusterControlVc(pIntF, ClusterPacket);
	}
}




PCLUSTER_MEMBER
MarsLookupClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	)
/*++

Routine Description:

	Given the Hardware address of a cluster member, search our list
	of cluster members for an entry that matches this.

	It is assumed that the caller has acquired the IntF lock.

Arguments:

	pIntF			- Ptr to Interface to search in
	pHwAddr			- Ptr to ATM address and subaddress

Return Value:

	Pointer to Cluster member structure if found, else NULL.

--*/
{
	PCLUSTER_MEMBER	pMember;

	for (pMember = pIntF->ClusterMembers;
		 pMember != NULL;
		 pMember = pMember->Next)
	{
		if (COMP_HW_ADDR(pHwAddr, &pMember->HwAddr))
		{
			break;
		}
	}

	return (pMember);
}


PCLUSTER_MEMBER
MarsCreateClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	)
/*++

Routine Description:

	Allocate and initialize a Cluster Member structure, and link it
	to the list of members on the specified Interface.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface on which this member has joined
	pHwAddr			- ATM address and subaddress for this new member

Return Value:

	Pointer to Cluster member structure if successful, else NULL.

--*/
{
	PCLUSTER_MEMBER pMember;
	ENTRY_TYPE		EntryType;
	ULONG			Length;

	Length =  sizeof(CLUSTER_MEMBER) +
							((pHwAddr->SubAddress != NULL) ? sizeof(ATM_ADDRESS) : 0);
	pMember = ALLOC_NP_MEM(Length, POOL_TAG_MARS);

	if (pMember == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{

		if (++(pIntF->MarsStats.CurrentClusterMembers) > pIntF->MarsStats.MaxClusterMembers)
		{
			pIntF->MarsStats.MaxClusterMembers = pIntF->MarsStats.CurrentClusterMembers;
		}
		
		ZERO_MEM(pMember, Length);

		COPY_ATM_ADDR(&pMember->HwAddr.Address, &pHwAddr->Address);
		if (pHwAddr->SubAddress != NULL)
		{
			pMember->HwAddr.SubAddress = (PATM_ADDRESS)(pMember + 1);
			COPY_ATM_ADDR(pMember->HwAddr.SubAddress, pHwAddr->SubAddress);
		}

		pMember->pIntF = pIntF;

		//
		// Link it to the list of Cluster Members on this Interface.
		//
#if 0
		{
			PCLUSTER_MEMBER *	pPrev;

			for (pPrev= &(pIntF->ClusterMembers);
				 *pPrev != NULL;
				 pPrev = &(PCLUSTER_MEMBER)((*pPrev)->Next) )
			{
				// Nothing
			}
			pMember->Next = NULL;
			pMember->Prev = pPrev;
			*pPrev = (PCLUSTER_MEMBER)pMember;
		}
#else
		pMember->Next = pIntF->ClusterMembers;
		pMember->Prev = &(pIntF->ClusterMembers);
		if (pIntF->ClusterMembers != NULL_PCLUSTER_MEMBER)
		{
			pIntF->ClusterMembers->Prev = &(pMember->Next);
		}
		pIntF->ClusterMembers = pMember;
#endif

		pIntF->NumClusterMembers++;

		//
		//  Assign it a CMI
		//
		pMember->CMI = pIntF->CMI++;

	}

	MARSDBGPRINT(DBG_LEVEL_INFO,
			("New Cluster Member 0x%x, pIntF %x, CMI %x, Prev %x, Next %x, ATM Addr:",
				 pMember, pIntF, pMember->CMI, pMember->Prev, pMember->Next));
	MARSDUMPATMADDR(DBG_LEVEL_INFO, &pHwAddr->Address, "");

	return (pMember);
}




VOID
MarsDeleteClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Remove Cluster member from the list of Cluster members, and free it.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Cluster member to be freed

Return Value:

	None

--*/
{
	ARPS_ASSERT(pMember->pGroupList == NULL_PGROUP_MEMBER);
	MARSDBGPRINT(DBG_LEVEL_INFO,
			("MarsDeleteClusterMember: pIntF %x, pMember %x, Next %x, Prev %x\n",
				pIntF, pMember, pMember->Next, pMember->Prev));
				
	pIntF->MarsStats.CurrentClusterMembers--;
	//
	// De-link this Cluster Member from the list on IntF.
	//
	*(pMember->Prev) = pMember->Next;
	if (pMember->Next != NULL)
	{
		((PENTRY_HDR)pMember->Next)->Prev = pMember->Prev;
	}
	pIntF->NumClusterMembers--;

	FREE_MEM(pMember);

}



PMARS_ENTRY
MarsLookupMarsEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					GrpAddr,
	IN	BOOLEAN					bCreateNew
	)
/*++

Routine Description:

	Look up the MARS_ENTRY for the given Group Address on the specified
	Interface. Optionally create a new one if not found.

	The caller is assumed to hold the IntF lock.

Arguments:

	pIntF			- Ptr to Interface
	GrpAddr			- The address to look for
	bCreateNew		- Should we create a new entry if one isn't present?

Return Value:

	Pointer to MARS entry if found/created, else NULL.

--*/
{
	PMARS_ENTRY *	ppMarsEntry;
	PMARS_ENTRY		pMarsEntry = NULL_PMARS_ENTRY;
	UINT			Hash = MARS_HASH(GrpAddr);

	MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsLookupMarsEntry: for IP Addr: "));

	MARSDUMPIPADDR(DBG_LEVEL_LOUD, GrpAddr, "...");

	for (ppMarsEntry = &pIntF->MarsCache[Hash];
		 *ppMarsEntry != NULL;
		 ppMarsEntry = (PMARS_ENTRY *)(&(*ppMarsEntry)->Next))
	{
		if ((*ppMarsEntry)->IPAddress == GrpAddr)
		{
			pMarsEntry = *ppMarsEntry;
			break;
		}

		if ((*ppMarsEntry)->IPAddress > GrpAddr)
		{
			//
			// No chance of finding this.
			//
			break;
		}
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD+DBG_NO_HDR,
			("%sFound\n", ((pMarsEntry != NULL_PMARS_ENTRY)? "" : "Not ")));

	if ((pMarsEntry == NULL_PMARS_ENTRY) && bCreateNew)
	{
		pMarsEntry = (PMARS_ENTRY)ArpSAllocBlock(pIntF, MARS_BLOCK_ENTRY);
		if (pMarsEntry == NULL_PMARS_ENTRY)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
		}
		else
		{
			//
			// Fill in the new entry.
			//
			pMarsEntry->IPAddress = GrpAddr;
			pMarsEntry->pIntF = pIntF;

			//
			// ppMarsEntry points to the Next field of the predecessor of this new entry
			//
			pMarsEntry->Next = *ppMarsEntry;
			pMarsEntry->Prev = ppMarsEntry;
			if (*ppMarsEntry != NULL_PMARS_ENTRY)
			{
				(*ppMarsEntry)->Prev = &(pMarsEntry->Next);
			}
			*ppMarsEntry = pMarsEntry;

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsLookupMarsEntry: new entry %x for IP Addr:", pMarsEntry));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, GrpAddr, "\n");
			if (++(pIntF->MarsStats.CurrentGroups) > pIntF->MarsStats.MaxGroups)
			{
				pIntF->MarsStats.MaxGroups = pIntF->MarsStats.CurrentGroups;
			}
		}
	}

	return (pMarsEntry);
}



BOOLEAN
MarsIsAddressMcsServed(
	IN	PINTF					pIntF,
	IN	IPADDR					IPAddress
	)
/*++

Routine Description:

	Check if the given IP Address is one that is served by MCS.

Arguments:

	pIntF			- Ptr to Interface
	IPAddress		- Address to check

Return Value:

	TRUE if we are the MCS serving IPAddress, else FALSE.

--*/
{
	PMCS_ENTRY		pMcsEntry;

	for (pMcsEntry = pIntF->pMcsList;
		 pMcsEntry != NULL_PMCS_ENTRY;
		 pMcsEntry = (PMCS_ENTRY)pMcsEntry->Next)
	{
		if ((IPAddress >= pMcsEntry->GrpAddrPair.MinAddr) &&
			(IPAddress <= pMcsEntry->GrpAddrPair.MaxAddr))
		{
			return TRUE;
		}
	}

	return FALSE;
}


VOID
MarsPunchHoles(
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PGROUP_MEMBER			pGroupList,
	IN	PINTF					pIntF,
	IN	IPADDR UNALIGNED *		pOutBuf					OPTIONAL,
	OUT	PUSHORT					pMinMaxCount,
	OUT	BOOLEAN *				pAnyHolesPunched
	)
/*++

Routine Description:

	Punch holes in the given IP Address range, according to RFC 2022.
	These holes correspond to:
	1. IP Addresses that are MCS-supported
	2. IP Addresses that are present in the given Group Member list

	Optionally, fill in an output buffer (reflected JOIN/LEAVE) with the
	resulting <min, max> list.

	This routine gets called twice when processing any JOIN or LEAVE message,
	once to get the MinMaxCount and AnyHolesPunched info, and then again,
	after space has been allocated for MinMaxCount pairs, to fill in
	a retransmitted JOIN or LEAVE.

Arguments:

	pGrpAddrRange	- The range to punch holes in
	pGroupList		- #2 in Routine Description above
	pIntF			- Ptr to Interface
	pOutBuf			- If not NULL, place to write <min, max> pairs to.
	pMinMaxCount	- The number of discrete, non-contiguous IP address ranges
					  remaining after hole-punching.
	pAnyHolesPunched- Where we return TRUE iff we punched atleast one hole.

Return Value:

	None. See OUT parameters above.

--*/
{
	PGROUP_MEMBER			pGroup;
	PMCS_ENTRY				pMcsEntry;
	IPADDR					StartOfThisRange;
	IPADDR					IPAddress;
	UNALIGNED IPADDR *		pIPAddress;
	BOOLEAN					InHole;				// are we in a hole now?
	BOOLEAN					HolePunched;		// any holes punched so far?
	BOOLEAN					InGroupList;
	BOOLEAN					InMcsList;

	*pMinMaxCount = 0;

	StartOfThisRange = pGrpAddrRange->MinAddr;
	pGroup = pGroupList;
	pMcsEntry = pIntF->pMcsList;

	InHole = FALSE;
	HolePunched = FALSE;
	pIPAddress = (UNALIGNED IPADDR *)pOutBuf;

	for (IPAddress = pGrpAddrRange->MinAddr;
 		 IPAddress <= pGrpAddrRange->MaxAddr;
 		 IPAddress++)
	{
		//
		// Check if IPAddress is covered by the Group Member list.
		//
		while ((pGroup != NULL) && 
   			(pGroup->pMarsEntry->IPAddress < IPAddress))
		{
			pGroup = (PGROUP_MEMBER)pGroup->pNextGroup;
		}

		if ((pGroup != NULL) &&
   			(pGroup->pMarsEntry->IPAddress == IPAddress))
		{
			InGroupList = TRUE;
		}
		else
		{
			InGroupList = FALSE;
		}

		//
		// Check if IPAddress is served by MCS.
		//
		while ((pMcsEntry != NULL) &&
   			(pMcsEntry->GrpAddrPair.MaxAddr < IPAddress))
		{
			pMcsEntry = (PMCS_ENTRY)pMcsEntry->Next;
		}

		if ((pMcsEntry != NULL) &&
   			((pMcsEntry->GrpAddrPair.MinAddr <= IPAddress) &&
				(pMcsEntry->GrpAddrPair.MaxAddr >= IPAddress)))
		{
			InMcsList = TRUE;
		}
		else
		{
			InMcsList = FALSE;
		}

		if (InHole)
		{
			if (!InGroupList && !InMcsList)
			{
				//
				//  Out of the hole with this IPAddress
				//
				InHole = FALSE;
				StartOfThisRange = IPAddress;
			}
			else
			{
				//
				// A hole right next to the one we were previously in..
				// Jump to the end of this hole...
				// (If we're not in an mcs-served range then we're already
				//  at the end of the single-address hole and so don't do anything).
				//
				if (InMcsList)
				{
					IPAddress = pMcsEntry->GrpAddrPair.MaxAddr;
 		 			if (IPAddress > pGrpAddrRange->MaxAddr)
 		 			{
 		 				IPAddress = pGrpAddrRange->MaxAddr;
 		 			}
				}
			}
		}
		else
		{
			if (InGroupList || InMcsList)
			{
				//
				//  Entering a hole that includes IPAddress
				//
				InHole = TRUE;
				HolePunched = TRUE;
				if (IPAddress > StartOfThisRange)
				{
					(*pMinMaxCount)++;

					if (pIPAddress)
					{
						//
						//  Write out a pair: <StartOfThisRange to IPAddress-1>
						//
						PUTULONG2ULONG(pIPAddress, StartOfThisRange);
						pIPAddress++;
						IPAddress--;
						PUTULONG2ULONG(pIPAddress, IPAddress);
						pIPAddress++;
						IPAddress++;
					}
				}

				//
				// Jump to the end of this hole...
				// (If we're not in an mcs-served range then we're already
				//  at the end of the single-address hole and so don't do anything).
				//
				if (InMcsList)
				{
					IPAddress = pMcsEntry->GrpAddrPair.MaxAddr;
 		 			if (IPAddress > pGrpAddrRange->MaxAddr)
 		 			{
 		 				IPAddress = pGrpAddrRange->MaxAddr;
 		 			}
				}
			}
			else
			{
				//
				// We're not in a hole -- skip to just before the next hole...
				//

				//
				// Since we're not in a hole, the following 2 assertions hold.
				//
				ARPS_ASSERT(pGroup==NULL || pGroup->pMarsEntry->IPAddress > IPAddress);
				ARPS_ASSERT(pMcsEntry==NULL || pMcsEntry->GrpAddrPair.MinAddr > IPAddress);

				//
				// We now pick the skip to just before the next hole which is either
				// a group address or a mcs-served range, whichever comes first.
				// Note that either entry could be NULL.
				//

				if (pGroup != NULL)
				{
					IPAddress = pGroup->pMarsEntry->IPAddress-1;
				}

				if (    (pMcsEntry != NULL)
					 && (   (pGroup == NULL)
					     || (pMcsEntry->GrpAddrPair.MinAddr <= IPAddress)))
				{
					IPAddress =  pMcsEntry->GrpAddrPair.MinAddr-1;
				}

				//
				// Truncate back to the end of the GrpAddrRange
				//
				if (IPAddress > pGrpAddrRange->MaxAddr)
				{
					IPAddress = pGrpAddrRange->MaxAddr;
				}
			}
		}

		//
		// Corner case: Handle IPAddress 255.255.255.255
		// 				(because adding 1 to it causes rollover)
		//
		if (IPAddress == IP_BROADCAST_ADDR_VALUE)
		{
			break;
		}
	}

	if (!InHole)
	{
		(*pMinMaxCount)++;

		if (pIPAddress)
		{
			//
			//  Write out a pair: <StartOfThisRange to IPAddress-1>
			//
			PUTULONG2ULONG(pIPAddress, StartOfThisRange);
			pIPAddress++;
			IPAddress--;
			PUTULONG2ULONG(pIPAddress, IPAddress);
			pIPAddress++;
		}
	}

	*pAnyHolesPunched = HolePunched;

	return;

}


BOOLEAN
MarsAddClusterMemberToGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		JHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	)
/*++

Routine Description:

	This is called when processing a non-registration JOIN.
	Add a Cluster member to the multicast groups in the given range
	(could be just one). Create all necessary data structures and
	linkages for this.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface on which this member has joined
	pMember			- Ptr to Cluster member
	pGrpAddrRange	- Min, Max IP addresses being Joined
	Packet			- Ptr to NDIS packet containing the JOIN
	JHdr			- Ptr to incoming JOIN
	Length			- of incoming JOIN
	ppClusterPacket	- Optionally, a packet to be sent out on ClusterControlVc.

Return Value:

	TRUE if the member was added successfully to the indicated groups,
	FALSE otherwise. If we returned TRUE, we also set *pClusterPacket optionally
	to a packet to be sent out on ClusterControlVc.

--*/
{
	PGROUP_MEMBER		pGroup;
	PGROUP_MEMBER *		ppGroup;
	PMARS_ENTRY			pMarsEntry;
	PMARS_JOIN_LEAVE	pCopyHdr;
	IPADDR				IPAddress;
	USHORT				MinMaxCount;
	BOOLEAN				ReflectJoin;
	BOOLEAN				HolePunched;
	BOOLEAN				RetransmitOnCCVC;
	USHORT				Flags;
	UNALIGNED IPADDR *	pIPAddress;
	ULONG				JoinCopyLength;

	*ppClusterPacket = (PNDIS_PACKET)NULL;
	ReflectJoin = FALSE;
	RetransmitOnCCVC = FALSE;

	GETSHORT2SHORT(&Flags, &JHdr->Flags);

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsAddClusterMemberToGroups: pMember %x, Min ", pMember));
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MinAddr, ", Max ");
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MaxAddr, "\n");

	MARSDUMPMAP(DBG_LEVEL_NOTICE,
			"MARS: Join ", pGrpAddrRange->MinAddr, &pMember->HwAddr.Address);
	do
	{
		//
		// Possible cases:
		//
		// 1. Joining a single group
		// 2. Joining the entire Class D space.
		//
		if ((pGrpAddrRange->MinAddr == MIN_CLASSD_IPADDR_VALUE) &&
			(pGrpAddrRange->MaxAddr == MAX_CLASSD_IPADDR_VALUE))
		{
			IPAddress = IPADDR_FULL_RANGE; // key for entry representing entire range
		}
		else
		{
			IPAddress = pGrpAddrRange->MinAddr;
		}

		//
		// Check if this is a duplicate join of the entire class-D range.
		// The special value, IPADDR_FULL_RANGE is smaller than any valid
		// IP address, so if present it's always the first in
		// pMember->pGroupList
		//
		if (	IPAddress == IPADDR_FULL_RANGE
			&&	pMember->pGroupList != NULL
			&&	pMember->pGroupList->pMarsEntry->IPAddress == IPAddress)
		{
			//
			// Yes it is a duplicate join of the entire class-D address space.
			//
			MinMaxCount = 0;
		}
		else
		{
			MarsPunchHoles(
				pGrpAddrRange,
				pMember->pGroupList,
				pIntF,
				NULL,
				&MinMaxCount,
				&HolePunched
				);
		}


		//
		// Check whether the JOIN is a complete duplicate.
		//
		if (MinMaxCount == 0)
		{
			//
			// Duplicate JOIN. Retransmit JOIN back on the VC
			// on which it was received.
			//
			ReflectJoin = TRUE;
			pIntF->MarsStats.DuplicateJoins++;

			//
			// Set PUNCHED to 0 in the received JOIN.
			//
			Flags &= ~JL_FLAGS_PUNCHED;
			PUTSHORT2SHORT(&JHdr->Flags, Flags);

			break;
		}

		


		// First access the MARS entry representing the
		// Multicast group being joined.
		//
		pMarsEntry = MarsLookupMarsEntry(pIntF, IPAddress, TRUE);
		if (pMarsEntry == NULL_PMARS_ENTRY)
		{
			break;
		}

		pGroup = ALLOC_NP_MEM(sizeof(GROUP_MEMBER), POOL_TAG_MARS);
		if (pGroup == NULL_PGROUP_MEMBER)
		{
			break;
		}

		//
		// stats...
		//
		pIntF->MarsStats.SuccessfulVCMeshJoins++;
		if (IPAddress == IPADDR_FULL_RANGE)
		{
			if (++(pIntF->MarsStats.CurrentPromiscuous) > pIntF->MarsStats.MaxPromiscuous)
			{
				pIntF->MarsStats.MaxPromiscuous = pIntF->MarsStats.CurrentPromiscuous;
			}
		}
		
		//
		// Fill in the basics for this GROUP_MEMBER.
		//
		pGroup->pMarsEntry = pMarsEntry;
		pGroup->pClusterMember = pMember;

		//
		// Link this GROUP_MEMBER to the MARS Entry.
		//
		pGroup->Prev = &(pMarsEntry->pMembers);
		pGroup->Next = pMarsEntry->pMembers;
		if (pMarsEntry->pMembers != NULL_PGROUP_MEMBER)
		{
			((PENTRY_HDR)(pGroup->Next))->Prev = &(pGroup->Next);
		}
		pMarsEntry->pMembers = pGroup;
		pMarsEntry->NumMembers++;

		//
		// Stats...
		//
		if ((UINT)pMarsEntry->NumMembers > pIntF->MarsStats.MaxAddressesPerGroup)
		{
			pIntF->MarsStats.MaxAddressesPerGroup = pMarsEntry->NumMembers;
		}

		//
		// Link this GROUP_MEMBER to the CLUSTER_MEMBER. The list
		// is sorted in ascending order of IPAddress.
		// NOTE: This function must not be called if pMember's GROUP_STATE is not ACTIVE.
		//
		ASSERT((MARS_GET_CM_GROUP_STATE(pMember) == CM_GROUP_ACTIVE));
		for (ppGroup = &(pMember->pGroupList);
			 *ppGroup != NULL_PGROUP_MEMBER;
			 ppGroup = &(*ppGroup)->pNextGroup)
		{
			if ((*ppGroup)->pMarsEntry->IPAddress > IPAddress)
			{
				break;
			}
		}

		pGroup->pNextGroup = *ppGroup;
		*ppGroup = pGroup;
		pMember->NumGroups++;

		//
		// If a single group was being joined, retransmit the JOIN
		// on ClusterControlVc.
		//
		if (pGrpAddrRange->MinAddr == pGrpAddrRange->MaxAddr)
		{
			//
			// Set PUNCHED to 0 in the received JOIN.
			//
			Flags &= ~JL_FLAGS_PUNCHED;
			PUTSHORT2SHORT(&JHdr->Flags, Flags);

			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// A range of groups were joined. Check whether any holes
		// were punched, i.e., are there any addresses in this
		// range that the member had already joined, or any addresses
		// that are MCS-served.
		//
		if (!HolePunched)
		{
			//
			// All new Join, and no addresses were MCS-served.
			// Retransmit the original JOIN on ClusterControlVc.
			//
			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// A copy of the JOIN, with the hole-punched list, is to be
		// sent on ClusterControlVc.
		//
		// The copy will contain (MinMaxCount - 1) _additional_ address
		// pairs.
		//
		JoinCopyLength = Length + ((2 * sizeof(IPADDR))*(MinMaxCount - 1));
		*ppClusterPacket = MarsAllocControlPacket(
								pIntF,
								JoinCopyLength,
								(PUCHAR *)&pCopyHdr
								);

		if (*ppClusterPacket == (PNDIS_PACKET)NULL)
		{
			break;
		}

		COPY_MEM((PUCHAR)pCopyHdr, (PUCHAR)JHdr, Length);

		pIPAddress = (UNALIGNED IPADDR *)((PUCHAR)pCopyHdr + Length - (2 * sizeof(IPADDR)));
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			pIPAddress,
			&MinMaxCount,
			&HolePunched
			);


		//
		// Update the JOIN _copy_ that will go on ClusterControlVc.
		//
		PUTSHORT2SHORT(&pCopyHdr->NumGrpAddrPairs, MinMaxCount);
		Flags |= JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&pCopyHdr->Flags, Flags);

		//
		// Retransmit the received JOIN on the VC it arrived on, with
		// Hole-punched reset.
		//
		Flags &= ~JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&JHdr->Flags, Flags);
		ReflectJoin = TRUE;

		break;
	}
	while (FALSE);

	if (RetransmitOnCCVC)
	{
		ARPS_ASSERT(!ReflectJoin);
#if 0
		*ppClusterPacket = MarsAllocPacketHdrCopy(Packet);
#else
		*ppClusterPacket = Packet;
#endif
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD,
		("MarsAddClusterMemberToGroups: ClusterPkt %x, RetransmitOnCCVC %d, Reflect %d\n",
		 *ppClusterPacket, RetransmitOnCCVC, ReflectJoin));

	return (ReflectJoin);
}



VOID
MarsUnlinkAllGroupsOnClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Unlink and free all Group structures attached to a Cluster Member.
	ALSO: disable any more groups from being added.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface from which this member is to be deleted
	pMember			- Ptr to Cluster member

Return Value:

	None

--*/
{
	PGROUP_MEMBER			pGroup;
	PGROUP_MEMBER			pNextGroup;


	MARSDBGPRINT(DBG_LEVEL_NOTICE,
		("MarsUnlinkAllGroupsOnClusterMember: pMember %x, GroupList %x\n",
			pMember, pMember->pGroupList));

	//
	// Save for later.
	//
	pGroup = pMember->pGroupList;
	pMember->pGroupList = NULL_PGROUP_MEMBER;

	//
	// Make sure more groups can't be added later.
	//
	MARS_SET_CM_GROUP_STATE(pMember,  CM_GROUP_DISABLED);

	//
	// De-link and free all Group structures associated with
	// this cluster member.
	//
	for (NOTHING;
		 pGroup != NULL_PGROUP_MEMBER;
		 pGroup = pNextGroup)
	{
		pNextGroup = pGroup->pNextGroup;

		//
		// Unlink from MARS cache.
		//
		*(pGroup->Prev) = pGroup->Next;
		if (pGroup->Next != NULL)
		{
			((PENTRY_HDR)(pGroup->Next))->Prev = pGroup->Prev;
		}

		pGroup->pMarsEntry->NumMembers--;

		pMember->NumGroups--;

		FREE_MEM(pGroup);
	}

}



BOOLEAN
MarsDelClusterMemberFromGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		LHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	)
/*++

Routine Description:

	Delete a Cluster Member from membership of the indicated group (or
	group range). This is called on processing a non-deregistration
	LEAVE message.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster member
	pGrpAddrRange	- Min, Max IP addresses being Left
	Packet			- NDIS packet containing the LEAVE
	LHdr			- Ptr to incoming LEAVE
	Length			- of incoming LEAVE
	ppClusterPacket	- Optionally, a packet to be sent out on ClusterControlVc.

Return Value:

	TRUE if the member was deleted successfully from the indicated groups,
	FALSE otherwise. If we returned TRUE, we also set *pClusterPacket optionally
	to a packet to be sent out on ClusterControlVc.

--*/
{
	PGROUP_MEMBER		pGroup;
	PGROUP_MEMBER *		ppGroup, * ppDelGroup;
	PMCS_ENTRY			pMcsEntry;
	PMARS_JOIN_LEAVE	pCopyHdr;
	IPADDR				IPAddress;
	USHORT				MinMaxCount;
	BOOLEAN				ReflectLeave;
	BOOLEAN				HolePunched;
	BOOLEAN				RetransmitOnCCVC;
	BOOLEAN				WasBlockJoined;
	BOOLEAN				IsMcsServed;
	USHORT				Flags;
	UNALIGNED IPADDR *	pIPAddress;
	ULONG				LeaveCopyLength;

	*ppClusterPacket = NULL;
	RetransmitOnCCVC = FALSE;
	ReflectLeave = FALSE;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsDelClusterMemberFromGroups: pMember %x, Min ", pMember));
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MinAddr, ", Max ");
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MaxAddr, "\n");

	do
	{
		if (pMember == NULL)
		{
			ReflectLeave = TRUE;
			break;
		}

		GETSHORT2SHORT(&Flags, &LHdr->Flags);

		pMcsEntry = pIntF->pMcsList;

		if ((pGrpAddrRange->MinAddr == MIN_CLASSD_IPADDR_VALUE) &&
			(pGrpAddrRange->MaxAddr == MAX_CLASSD_IPADDR_VALUE))
		{
			IPAddress = IPADDR_FULL_RANGE; // key for entry representing entire range
		}
		else
		{
			IPAddress = pGrpAddrRange->MinAddr;
		}

		//
		// Gather some information:
		// 1. Locate the Group member structure for this IP Address.
		// 2. Check if this Cluster member has Block-Joined the entire multicast range
		//
		ppDelGroup = NULL;
		WasBlockJoined = FALSE;

		for (ppGroup = &(pMember->pGroupList);
			 *ppGroup != NULL_PGROUP_MEMBER;
			 ppGroup = &((*ppGroup)->pNextGroup))
		{
			//
			// Is this the GROUP_MEMBER to be deleted?
			//
			if ((*ppGroup)->pMarsEntry->IPAddress == IPAddress)
			{
				ppDelGroup = ppGroup;
			}

			//
			// Does this GROUP_MEMBER indicate that the Cluster member
			// has block-joined the entire multicast range?
			//
			if ((*ppGroup)->pMarsEntry->IPAddress == IPADDR_FULL_RANGE)
			{
				WasBlockJoined = TRUE;
			}

			//
			// Do we have all that we are looking for?
			//
			if (ppDelGroup && WasBlockJoined)
			{
				break;
			}
		}

		if (ppDelGroup != NULL)
		{
			PMARS_ENTRY pMarsEntry;
			pGroup = *ppDelGroup;

			//
			// Unlink this GROUP_MEMBER from the CLUSTER_MEMBER.
			//
			*ppDelGroup = (*ppDelGroup)->pNextGroup;
			pMember->NumGroups--;

			//
			// Unlink this GROUP_MEMBER from the MARS_ENTRY.
			//
			*(pGroup->Prev) = pGroup->Next;
			if (pGroup->Next != NULL)
			{
				((PENTRY_HDR)pGroup->Next)->Prev = pGroup->Prev;
			}
			pMarsEntry = pGroup->pMarsEntry;
			pGroup->pMarsEntry = NULL;
			pMarsEntry->NumMembers--;

			if (pMarsEntry->pMembers == NULL)
			{
				PMARS_ENTRY pNextEntry = (PMARS_ENTRY) pMarsEntry->Next;
				//
				// This mars entry has no more members -- remove it from the
				//	hash table and delete it.
				//
				ARPS_ASSERT(pMarsEntry->NumMembers==0);
				pIntF->MarsStats.CurrentGroups--;

#if 1
				MARSDBGPRINT(DBG_LEVEL_INFO,
				("MarsLookupMarsEntry: deleting entry %x for IP Addr:", pMarsEntry));
					MARSDUMPIPADDR(DBG_LEVEL_INFO, pMarsEntry->IPAddress, "\n");


				ARPS_ASSERT(*(pMarsEntry->Prev) == pMarsEntry);
				*(pMarsEntry->Prev) = pNextEntry;
				if (pNextEntry != NULL_PMARS_ENTRY)
				{
					ARPS_ASSERT(pNextEntry->Prev == &(pMarsEntry->Next));
					pNextEntry->Prev = pMarsEntry->Prev;
				}
				ArpSFreeBlock(pMarsEntry);
#endif // 0

			}

			//
			// TODO: Delete group
			//
			#if 1
			FREE_MEM(pGroup);
			#endif 

			
			
			MARSDUMPMAP(DBG_LEVEL_NOTICE,
				"MARS: Leave ", pGrpAddrRange->MinAddr, &pMember->HwAddr.Address);

		}

		//
		// Check if the range/group being Left is MCS-served.
		//
		IsMcsServed = FALSE;
		for (pMcsEntry = pIntF->pMcsList;
			 pMcsEntry != NULL_PMCS_ENTRY;
			 pMcsEntry = pMcsEntry->Next)
		{
			if ((pMcsEntry->GrpAddrPair.MinAddr <= pGrpAddrRange->MinAddr) &&
				(pMcsEntry->GrpAddrPair.MaxAddr >= pGrpAddrRange->MaxAddr))
			{
				IsMcsServed = TRUE;
				break;
			}
		}

		

		if (IPAddress == IPADDR_FULL_RANGE)
		{
			if (!WasBlockJoined)
			{
				//
				// This is an attempt to leave the entire class-D
				// space when in fact it has not joined it (perhaps this is
				// a retransmit of an earlier LEAVE). Reflect it privately.
				//

				ARPS_ASSERT(!ppDelGroup);

				//
				// Reset PUNCHED to 0.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&LHdr->Flags, Flags);
	
				//
				// Retransmit privately on VC.
				//
				ReflectLeave = TRUE;

				break;
			}
			else
			{
				//
				//	This member is truly leaving the entire class-D space.
				//
				pIntF->MarsStats.CurrentPromiscuous--;
			}
		}
		else
		{
			//
			// Single group Leave. Check if this Cluster Member is still
			// block-joined (to the entire Class D range), or if the group
			// being left is served by MCS. In either case, we retransmit
			// the LEAVE privately.
			//
			if (WasBlockJoined || IsMcsServed)
			{
				//
				// Reset PUNCHED to 0.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&LHdr->Flags, Flags);
	
				//
				// Retransmit privately on VC.
				//
				ReflectLeave = TRUE;
			}
			else
			{
				//
				// Retransmit LEAVE on ClusterControlVc.
				//
				ReflectLeave = FALSE;
				RetransmitOnCCVC = TRUE;

			}
			break;
		}


		//
		// Block Leave: can be only for the "entire Class D space" range.
		// Punch holes: for each group that this Cluster member still has
		// "single joins" to, and for each group that is MCS-served.
		//
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			NULL,
			&MinMaxCount,
			&HolePunched
			);

		if (!HolePunched)
		{
			//
			// No holes were punched, meaning that the Cluster member
			// isn't member anymore of any groups in the LEAVE range,
			// and none of the groups in the range is MCS-served.
			// To propagate this information to all hosts in the Cluster,
			// retransmit the LEAVE on ClusterControlVc.
			//

			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// One or more holes were punched. The original LEAVE
		// should be transmitted back on the VC it came on, with
		// PUNCHED reset to 0.
		//
		Flags &= ~JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&LHdr->Flags, Flags);
		ReflectLeave = TRUE;

		if (MinMaxCount == 0)
		{
			//
			// The holes didn't leave anything left, so there is nothing
			// more to do.
			//
			break;
		}

		//
		// A copy of the LEAVE, with the hole-punched list, is to be
		// sent on ClusterControlVc.
		//
		// The copy will contain (MinMaxCount - 1) _additional_ address
		// pairs.
		//
		LeaveCopyLength = Length + ((2 * sizeof(IPADDR))*(MinMaxCount - 1));
		*ppClusterPacket = MarsAllocControlPacket(
								pIntF,
								LeaveCopyLength,
								(PUCHAR *)&pCopyHdr
								);

		if (*ppClusterPacket == (PNDIS_PACKET)NULL)
		{
			break;
		}

		COPY_MEM((PUCHAR)pCopyHdr, (PUCHAR)LHdr, Length);

		pIPAddress = (UNALIGNED IPADDR *)((PUCHAR)pCopyHdr + Length - (2 * sizeof(IPADDR)));
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			pIPAddress,
			&MinMaxCount,
			&HolePunched
			);

		//
		// Update the LEAVE copy.
		//
		PUTSHORT2SHORT(&pCopyHdr->NumGrpAddrPairs, MinMaxCount);
		Flags |= JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&pCopyHdr->Flags, Flags);

		break;
	}
	while (FALSE);

	if (RetransmitOnCCVC)
	{
		ARPS_ASSERT(!ReflectLeave);
		*ppClusterPacket = Packet;
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD,
		("MarsDelClusterMemberFromGroups: ClusterPkt %x, RetransmitOnCCVC %d, Reflect %d\n",
		 *ppClusterPacket, RetransmitOnCCVC, ReflectLeave));

	return (ReflectLeave);
}



PNDIS_PACKET
MarsAllocControlPacket(
	IN	PINTF					pIntF,
	IN	ULONG					PacketLength,
	OUT	PUCHAR *				pPacketStart
	)
/*++

Routine Description:

	Allocate and return a packet that can be used to send a MARS control packet.

Arguments:

	pIntF			- Ptr to Interface on which to allocate the packet
	PacketLength	- Total length in bytes
	pPacketStart	- Place to return pointer to start of allocated packet.

Return Value:

	Pointer to NDIS packet if successful, NULL otherwise. If successful, we
	also set *pPacketStart to the start of the allocated (contiguous) memory.

--*/
{
	PNDIS_PACKET		Packet;
	PUCHAR				pBuffer;
	PNDIS_BUFFER		NdisBuffer;
	NDIS_STATUS			Status;
	PPROTOCOL_RESD		Resd;		// ProtocolReserved part of NDIS packet

	*pPacketStart = NULL;
	Packet = NULL;
	NdisBuffer = NULL;

	do
	{
		//
		// Allocate space for the packet.
		//
		pBuffer = (PUCHAR)ALLOC_NP_MEM(PacketLength, POOL_TAG_MARS);
		if (pBuffer == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		// Make this an NDIS buffer.
		//
		NdisAllocateBuffer(&Status,
						   &NdisBuffer,
						   MarsBufPoolHandle,
						   pBuffer,
						   PacketLength);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		// Allocate an NDIS PACKET.
		//
		NdisAllocatePacket(&Status, &Packet, MarsPktPoolHandle);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisChainBufferAtFront(Packet, NdisBuffer);
 
 		//
 		// Fill in the Protocol reserved fields properly:
 		//
 		Resd = RESD_FROM_PKT(Packet);
 		ZERO_MEM(Resd, sizeof(PROTOCOL_RESD));
 		Resd->Flags = (RESD_FLAG_MARS_PKT | RESD_FLAG_FREEBUF);
 		Resd->PacketStart = pBuffer;

 		break;
 	}
 	while (FALSE);

 	if (Status == NDIS_STATUS_SUCCESS)
 	{
 		*pPacketStart = pBuffer;
 	}
 	else
 	{
 		//
 		// Undo all that we have done so far.
 		//
 		if (NdisBuffer != NULL)
 		{
 			NdisFreeBuffer(NdisBuffer);
 		}

 		if (pBuffer != (PUCHAR)NULL)
 		{
 			FREE_MEM(pBuffer);
 		}
 	}

	if (Packet == NULL)
	{
		MARSDBGPRINT(DBG_LEVEL_ERROR,
				("MarsAllocControlPacket: FAILED"));
	}

 	return(Packet);
}



VOID
MarsFreePacket(
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Free a packet and any associated buffers. Three kinds of packets
	are handled here:

	1. Copy of a received control packet that has been forwarded. We might
	   have queued this for sending on CC VC, but later decided to abort.
	2. Packet generated by MARS (e.g. MARS_MULTI, hole-punched MARS_JOIN).
	3. Received multicast data packet that has been forwarded.

Arguments:

	Packet			- Packet to be freed

Return Value:

	None

--*/
{
	PPROTOCOL_RESD		Resd;	// ProtocolReserved part of NDIS packet
	PNDIS_BUFFER		NdisBuffer;
	PUCHAR				pBuffer;
	ULONG				BufferLength, TotalLength;

	Resd = RESD_FROM_PKT(Packet);

	//
	// 1. Is this a copy of a received MARS control packet?
	//
	if ((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)
	{
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);

		ArpSDereferenceVc(Resd->Vc, FALSE, TRUE);
		ArpSMarsControlFreeCount++;
		return;
	}
	else
	//
	// 2. Is this a packet generated by MARS?
	//
	if (Resd->Flags & RESD_FLAG_FREEBUF)
	{
		//
		// Type 1 in Routine Description: everything belongs to MARS
		//
		NdisGetFirstBufferFromPacket(
				Packet,
				&NdisBuffer,
				(PVOID *)&pBuffer,
				&BufferLength,
				&TotalLength
				);

		ARPS_ASSERT(BufferLength == TotalLength);

		FREE_MEM(pBuffer);

		NdisFreeBuffer(NdisBuffer);
	}
	else
	//
	// 3. This must be Multicast data that we forwarded
	//
	{
		//
		// Type 2 in Routine Description: only the first packet header
		// belongs to MARS. The protocol reserved part contains a pointer
		// to the original packet.
		//
		PNDIS_PACKET		OriginalPacket;

		OriginalPacket = Resd->OriginalPkt;
		ARPS_ASSERT(OriginalPacket != NULL);

		NdisReturnPackets(&OriginalPacket, 1);
	}

	if (NdisGetPoolFromPacket(Packet) == ArpSPktPoolHandle)
	{
		DbgPrint("ATMARPS: Freeing Packet %p belonging to ArpSPktPoolHandle %p\n!!!!",
			Packet, ArpSPktPoolHandle);
		DbgBreakPoint();
	}

	NdisFreePacket(Packet);
}



PNDIS_PACKET
MarsAllocPacketHdrCopy(
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Given an NDIS packet, allocate a new NDIS_PACKET structure, and make
	this new packet point to the buffer chain in the old one.

Arguments:

	Packet			- Packet to make a linked copy of.

Return Value:

	Pointer to the newly allocated and initialized packet if successful,
	else NULL.

--*/
{
	PNDIS_PACKET		PacketCopy;
	NDIS_STATUS			Status;
	PPROTOCOL_RESD		Resd;

	//
	// Allocate an NDIS PACKET.
	//
	NdisAllocatePacket(&Status, &PacketCopy, MarsPktPoolHandle);
	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		// Make this new packet point to the buffer chain in the old one.
		//
		PacketCopy->Private.Head = Packet->Private.Head;
		PacketCopy->Private.Tail = Packet->Private.Tail;
		PacketCopy->Private.ValidCounts = FALSE;

		//
		// Fill in the ProtocolReserved part with all information
		// we need when we free this packet later.
		//
		Resd = RESD_FROM_PKT(PacketCopy);
		ZERO_MEM(Resd, sizeof(PROTOCOL_RESD));

		Resd->Flags = RESD_FLAG_MARS_PKT;
		Resd->OriginalPkt = Packet;
	}
	else
	{
		PacketCopy = (PNDIS_PACKET)NULL;
	}

	return (PacketCopy);
}


VOID
MarsSendOnClusterControlVc(
	IN	PINTF					pIntF,
	IN	PNDIS_PACKET			Packet	OPTIONAL
	)
/*++

Routine Description:

	Start sends on ClusterControlVc, if we have the connection active,
	and we have tried to AddParty all cluster members. Otherwise, enqueue
	the (optional) Packet on the Cluster Control Packet queue.

	TBD: Protect this from reentrancy!

Arguments:

	pIntF			- Interface on which this packet is to be sent
	Packet			- Packet to be sent

Return Value:

	None

--*/
{
	KIRQL				OldIrql;
	NDIS_HANDLE			NdisVcHandle;
	PPROTOCOL_RESD		Resd;

	PLIST_ENTRY			pEntry;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsSendOnCC: pIntF %x/%x, Pkt %x\n", pIntF, pIntF->Flags, Packet));


	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (Packet != (PNDIS_PACKET)NULL)
	{
		if (pIntF->NumClusterMembers == 0)
		{
			//
			//  No point in queueing this packet.
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			MarsFreePacket(Packet);
			return;
		}

		//
		// Queue this packet.
		//
		Resd = RESD_FROM_PKT(Packet);
		InsertTailList(&pIntF->CCPacketQueue, &Resd->ReqList);
	}

	//
	// Make sure not more than one thread enters here.
	//
	if (pIntF->Flags & INTF_SENDING_ON_CC_VC)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		return;
	}

	pIntF->Flags |= INTF_SENDING_ON_CC_VC;

	//
	// Send now if the PMP connection is made, and we have tried to AddParty
	// all Cluster Members.
	//
	if ((pIntF->ClusterControlVc != NULL_PMARS_VC) &&
		(MARS_GET_VC_CONN_STATE(pIntF->ClusterControlVc) == MVC_CONN_ACTIVE) &&
		(pIntF->CCAddingParties == 0))
	{
		NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;

		ARPS_ASSERT(NdisVcHandle != NULL);

		//
		// Send all packets.
		//
		while (!IsListEmpty(&pIntF->CCPacketQueue))
		{
			pEntry = RemoveHeadList(&pIntF->CCPacketQueue);
			ARPS_ASSERT (pEntry != (PLIST_ENTRY)NULL);
			{
				Resd = CONTAINING_RECORD(pEntry, PROTOCOL_RESD, ReqList);
				Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

				//
				// If this is a MARS Control packet, fill in CSN, and
				// update our Cluster Sequence Number.
				//
				if ((Resd->Flags & RESD_FLAG_FREEBUF) ||	// Locally generated MARS CTL
					((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)) // Forwarded MARS CTL
				{
					PULONG	pCSN;

					pCSN = (PULONG)(Resd->PacketStart + FIELD_OFFSET(MARS_JOIN_LEAVE, MarsSequenceNumber));
					PUTULONG2ULONG(pCSN, pIntF->CSN);
					pIntF->CSN++;
				}

				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

				NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

				NdisCoSendPackets(NdisVcHandle, &Packet, 1);

				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			}
		}
	}

	pIntF->Flags &= ~INTF_SENDING_ON_CC_VC;

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

}



VOID
MarsFreePacketsQueuedForClusterControlVc(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Free any packets queued for sending on ClusterControlVc.

Arguments:

	pIntF			- Ptr to Interface

Return Value:

	None

--*/
{
	KIRQL				OldIrql;
	PPROTOCOL_RESD		Resd;
	PLIST_ENTRY			pEntry;
	PNDIS_PACKET		Packet;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	while (!IsListEmpty(&pIntF->CCPacketQueue))
	{
		pEntry = RemoveHeadList(&pIntF->CCPacketQueue);
		ARPS_ASSERT (pEntry != (PLIST_ENTRY)NULL);

		Resd = CONTAINING_RECORD(pEntry, PROTOCOL_RESD, ReqList);
		Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		MarsFreePacket(Packet);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}



BOOLEAN
MarsDelMemberFromClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	BOOLEAN					fIfLockedOnEntry,
	IN	KIRQL					OldIrql			OPTIONAL
	)
/*++

Routine Description:

	Drop a Cluster Member from ClusterControlVc. Handle all three
	possibilities:
	(a) Not connected to ClusterControlVc
	(b) Connection setup (MakeCall or AddParty) in progress
	(c) Connected to ClusterControlVc

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster Member to be deleted
	fIfLockedOnEntry- If TRUE, IF is locked on entry, else IF is unlocked on entry.

	OldIrql			-- Required IFF fIfLockedOnEntry is TRUE. This is the
					 Irql to return to.

Return Value:

	TRUE IFF IF lock was NEVER released and continues to be held.
	FALSE IFF IF lock WAS release AND and is released on exit  AND
	there was some change of state that is NOT idempotent.

	Thus, if IF lock is ever released in this function, it MUST be released on on
	exit and the return value MUST be false, AND this must only be done in a 
	situation which changes the state of pMember in a non-idempotent way (so calling
	it over and over again will not result in endlessly returning FALSE).

	Why these complexities? To make it safe to call this function while enumerating
	over all members -- check out  MarsAbortAllMembers.

--*/
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisVcHandle;
	NDIS_HANDLE		NdisPartyHandle;
	BOOLEAN			LockReleased;

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("MarsDelMemberFromCCVC: pIntF %x, pMember %x, ConnSt %x, PartyHandle %x\n",
			pIntF, pMember, MARS_GET_CM_CONN_STATE(pMember), pMember->NdisPartyHandle));

	LockReleased = FALSE;

	if (!fIfLockedOnEntry)
	{
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	if (!MarsIsValidClusterMember(pIntF, pMember))
	{
		//
		// Oops, the member has gone away in the
		// mean time. We silently return.
		//
		MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("MarsDelMemberFromCCVC: pIntF %x, pMember %x: pMember INVALID!\n",
			pIntF, pMember));
		if (!fIfLockedOnEntry)
		{
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			return FALSE; 							// ***** EARLY RETURN *******
		}
		else
		{
			//
			// We shouldn't have an invalid member if the lock is held on entry!
			//
			ARPS_ASSERT(!"INVALID MEMBER WHEN LOCK IS HELD!");
			return TRUE;						    // ***** EARLY RETURN *******
		}
	}

	switch (MARS_GET_CM_CONN_STATE(pMember))
	{
		case CM_CONN_ACTIVE:
			NdisPartyHandle = pMember->NdisPartyHandle;
			ARPS_ASSERT(NdisPartyHandle != NULL);

			if (pIntF->CCActiveParties + pIntF->CCAddingParties > 1)
			{
				MARS_SET_CM_CONN_STATE(pMember, CM_CONN_CLOSING);

				pIntF->CCActiveParties--;
				pIntF->CCDroppingParties++;
				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockReleased = TRUE;

				Status = NdisClDropParty(NdisPartyHandle, NULL, 0);
				if (Status != NDIS_STATUS_PENDING)
				{
					ArpSDropPartyComplete(Status, (NDIS_HANDLE)pMember);
				}
			}
			else
			{
				//
				// This is the last active party. Check if any DropParty()'s are
				// yet to finish.
				//
				if (pIntF->CCDroppingParties != 0)
				{
					//
					// This member will have to wait till all DropParty()s are
					// complete. Mark the ClusterControlVc so that we send
					// a CloseCall() when all DropParty()s are done.
					//
#if DBG
					MARSDBGPRINT(DBG_LEVEL_WARN,
						("ATMARPS: Intf %p, Member %p/%x, PtyHandle %p last active party\n",
					    pIntF, pMember, pMember->Flags, pMember->NdisPartyHandle));
					{
						PCLUSTER_MEMBER	pTmpMember;
						for (pTmpMember = pIntF->ClusterMembers;
							 pTmpMember != NULL;
							 pTmpMember = pTmpMember->Next)
						{
							MARSDBGPRINT(DBG_LEVEL_WARN,
								("ATMARPS: saw last active on Intf %p, other Pty %p/%x, PtyHandle %p\n",
								pIntF, pTmpMember, pTmpMember->Flags, pTmpMember->NdisPartyHandle));
						}
					}
#endif

					MARS_SET_VC_CONN_STATE(pIntF->ClusterControlVc, MVC_CONN_NEED_CLOSE);
				}
				else
				{
					//
					// Last active party, and no DropParty pending.
					//
					NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
					MARS_SET_VC_CONN_STATE(pIntF->ClusterControlVc, MVC_CONN_CLOSING);

					MARS_SET_CM_CONN_STATE(pMember, CM_CONN_CLOSING);
					pIntF->CCActiveParties--;
					pIntF->CCDroppingParties++;

					RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
					LockReleased = TRUE;

					Status = NdisClCloseCall(
									NdisVcHandle,
									NdisPartyHandle,
									NULL,
									0
									);

					if (Status != NDIS_STATUS_PENDING)
					{
						ArpSCloseCallComplete(
									Status,
									(NDIS_HANDLE)(pIntF->ClusterControlVc),
									(NDIS_HANDLE)pMember
									);
					}
				}
			}
			break;

		case CM_CONN_SETUP_IN_PROGRESS:
			//
			// Mark it so that we'll delete it when the AddParty/MakeCall
			// completes.
			//
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("ATMARPS: DeleteClustMemb %p/%x, conn setup in progress\n",
			    pMember, pMember->Flags));
			pMember->Flags |= CM_INVALID;
			break;
		
		case CM_CONN_CLOSING:
			NOTHING;
			break;

		case CM_CONN_IDLE:
			//
			// No connection. Just unlink this from the IntF and free it.
			//
			MarsDeleteClusterMember(pIntF, pMember);
			break;

		default:
			ARPS_ASSERT(FALSE);
			break;
	}

	if (LockReleased)
	{
		return FALSE;
	}
	else
	{
		if (fIfLockedOnEntry)
		{
			return TRUE;
		}
		else
		{
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			return FALSE;
		}
	}
}



VOID
MarsAddMemberToClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Add a Cluster Member as a party to ClusterControlVc. If this is the
	only (or first) Cluster Member known to us, then place a call to
	this cluster member.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster Member to be deleted

Return Value:

	None

--*/
{
	KIRQL					OldIrql;
	PMARS_VC				pVc=NULL;
	PCO_CALL_PARAMETERS		pCallParameters;
	BOOLEAN					LockReleased;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				NdisPartyHandle;
	NDIS_HANDLE				ProtocolVcContext;
	NDIS_HANDLE				ProtocolPartyContext;
	NDIS_STATUS				Status;

	LockReleased = FALSE;
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);


	do
	{
		if (MARS_GET_CM_CONN_STATE(pMember) != CM_CONN_IDLE)
		{
			// Get out of here.
			//
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("AddMemberToCC: pVc %x, pMember %x, Member ConnState %x NOT IDLE\n",
						pVc, pMember,  MARS_GET_CM_CONN_STATE(pMember)));
			break;
		}

		pVc = pIntF->ClusterControlVc;
	
		if (pVc == NULL_PMARS_VC)
		{
			pVc = pIntF->ClusterControlVc = ALLOC_NP_MEM(sizeof(MARS_VC), POOL_TAG_MARS);
			if (pVc == NULL_PMARS_VC)
			{
				MARSDBGPRINT(DBG_LEVEL_FATAL,
						("AddMemberToCC: Cannot allocate CC Vc!\n"));
				break;
			}
			ZERO_MEM(pVc, sizeof(MARS_VC));
			pVc->pIntF = pIntF;
			pVc->VcType = VC_TYPE_MARS_CC;
		}
	
		MARSDBGPRINT(DBG_LEVEL_INFO,
				("AddMemberToCC: pVc %x, pMember %x, ConnState %x\n",
						pVc, pMember, MARS_GET_VC_CONN_STATE(pVc)));
	
		ProtocolVcContext = (NDIS_HANDLE)pVc;
		ProtocolPartyContext = (NDIS_HANDLE)pMember;


		NdisVcHandle = pVc->NdisVcHandle;

		if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_IDLE)
		{
			if (pVc->NdisVcHandle == NULL)
			{
				Status = NdisCoCreateVc(
							pIntF->NdisBindingHandle,
							pIntF->NdisAfHandle,
							(NDIS_HANDLE)pVc,
							&pVc->NdisVcHandle
							);

				if (Status != NDIS_STATUS_SUCCESS)
				{
					break;
				}

				NdisVcHandle = pVc->NdisVcHandle;
				MARSDBGPRINT(DBG_LEVEL_LOUD,
						("AddMemberToCC: Created VC, CCVC %x, NdisVcHandle %x\n",
								pVc, pVc->NdisVcHandle));
			}

			pCallParameters = MarsPrepareCallParameters(pIntF, &pMember->HwAddr, TRUE);
			if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
			{
				break;
			}
			
			if (pVc->Flags & MVC_CONN_CLOSE_RECEIVED)
			{
				MARSDBGPRINT(DBG_LEVEL_WARN,
					("ATMARPS: MakingCall on IntF %p, CCVC %p has CLOSE_RCVD!\n",
					pIntF, pVc));
				DbgBreakPoint();
			}

			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_SETUP_IN_PROGRESS);

			MARS_SET_CM_CONN_STATE(pMember, CM_CONN_SETUP_IN_PROGRESS);

			pIntF->CCAddingParties++;
			pIntF->MarsStats.TotalCCVCAddParties++;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockReleased = TRUE;

			Status = NdisClMakeCall(
							NdisVcHandle,
							pCallParameters,
							ProtocolPartyContext,
							&pMember->NdisPartyHandle
							);

			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSMakeCallComplete(
							Status,
							ProtocolVcContext,
							pMember->NdisPartyHandle,
							pCallParameters
							);
			}

		}
		else if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_ACTIVE)
		{
			pCallParameters = MarsPrepareCallParameters(pIntF, &pMember->HwAddr, FALSE);
			if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
			{
				break;
			}

			MARS_SET_CM_CONN_STATE(pMember, CM_CONN_SETUP_IN_PROGRESS);

			pIntF->CCAddingParties++;
			pIntF->MarsStats.TotalCCVCAddParties++;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockReleased = TRUE;

			Status = NdisClAddParty(
							NdisVcHandle,
							ProtocolPartyContext,
							pCallParameters,
							&pMember->NdisPartyHandle
							);

			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSAddPartyComplete(
							Status,
							ProtocolPartyContext,
							pMember->NdisPartyHandle,
							pCallParameters
							);
			}
		}
		else
		{
			//
			// First call in progress.
			//
			NOTHING;
		}
		break;
	}
	while (FALSE);

	if (!LockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
}



PCO_CALL_PARAMETERS
MarsPrepareCallParameters(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr,
	IN	BOOLEAN					IsMakeCall
	)
/*++

Routine Description:

	Allocate and fill in call parameters for use in a MakeCall(PMP)
	or AddParty.

Arguments:

	pIntF			- Ptr to Interface
	pHwAddr			- Points to the Called ATM address and subaddress

Return Value:

	None

--*/
{
	PMARS_FLOW_SPEC							pFlowSpec;
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	ULONG									RequestSize;

	RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
					sizeof(CO_CALL_MANAGER_PARAMETERS) +
					sizeof(Q2931_CALLMGR_PARAMETERS) +
					(IsMakeCall? MARS_MAKE_CALL_IE_SPACE : MARS_ADD_PARTY_IE_SPACE) +
					0;

	pCallParameters = (PCO_CALL_PARAMETERS)ALLOC_NP_MEM(RequestSize, POOL_TAG_MARS);

	if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
	{
		return (pCallParameters);
	}

	pFlowSpec = &(pIntF->CCFlowSpec);

	//
	//  Zero out everything
	//
	ZERO_MEM((PUCHAR)pCallParameters, RequestSize);

	//
	//  Distribute space amongst the various structures
	//
	pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
							((PUCHAR)pCallParameters +
 								sizeof(CO_CALL_PARAMETERS));


	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						(IsMakeCall? MARS_MAKE_CALL_IE_SPACE : MARS_ADD_PARTY_IE_SPACE);

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	pCallParameters->Flags |= MULTIPOINT_VC;

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendBandwidth);
	pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
	pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
	pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendBandwidth);
	pCallMgrParameters->Transmit.ServiceType = pFlowSpec->ServiceType;

	//
	// For PMP calls, receive side values are 0's.
	//
	pCallMgrParameters->Receive.ServiceType = pFlowSpec->ServiceType;
	
	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	//  TBD: Add Called Subaddress IE in outgoing call.
	//
	pAtmCallMgrParameters->CalledParty = pHwAddr->Address;

	//
	//  Calling address:
	//
	pAtmCallMgrParameters->CallingParty = pIntF->ConfiguredAddress;


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (MakeCall only)
	//      Broadband Bearer Capability (MakeCall only)
	//      Broadband Low Layer Info
	//      QoS (MakeCall only)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
		pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  Traffic Descriptor:
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Bearer Capability
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = UP_P2P;
		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&ArpSDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  QoS
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

	return (pCallParameters);

}


BOOLEAN
MarsSendRedirect(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Send a MARS_REDIRECT on ClusterControlVc, as part of a periodic keepalive
	for Cluster members, unless we are shutting down.

Arguments:

	pIntF				- Ptr to Interface
	Timer				- Ptr to timer that went off
	TimerShuttingDown	- Indicates whether we are shutting down

Return Value:

	TRUE iff TimerShuttingDown is FALSE.

--*/
{
	ULONG				PacketLength;
	PNDIS_PACKET		RedirPacket;
	PMARS_REDIRECT_MAP	RHdr;
	PATM_ADDRESS		pAtmAddress;
	KIRQL				OldIrql;
	PUCHAR				p;
	INT					i;
	BOOLEAN					LockAcquired;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsSendRedirect: pIntF %x, Timer %x, ShuttingDown %x\n",
			 pIntF, Timer, TimerShuttingDown));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	LockAcquired = TRUE;

	if (pIntF->NumAddressesRegd > pIntF->NumAllocedRegdAddresses)
	{
		//
		// 12/22/1998 JosephJ: We shouldn't get here, but we have in the past, hence this assert.
		// I made a change to ArpSCoRequestComplete -- see 12/22/1998 note there -- which should
		// make us never get here.
		ASSERT(!"Redirect: NumRegd>NumAlloced");

		// If somehow we do, we fix up NumAddresesRegd
		//
		pIntF->NumAddressesRegd = pIntF->NumAllocedRegdAddresses;
	}
	
	if (!TimerShuttingDown)
	{
		PacketLength = sizeof(MARS_REDIRECT_MAP) +
						//
						// Source ATM Address
						//
						pIntF->ConfiguredAddress.NumberOfDigits +
						//
						// List of MARS ATM Addresses =
						// Our configured address + registered addresses
						//
						pIntF->ConfiguredAddress.NumberOfDigits +
						(ATM_ADDRESS_LENGTH * pIntF->NumAddressesRegd);

		ARPS_ASSERT(PacketLength <= pIntF->MaxPacketSize);

		RedirPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&RHdr);

		if (RedirPacket != (PNDIS_PACKET)NULL)
		{
			ZERO_MEM(RHdr, PacketLength);

			//
			// Fill in the packet.
			//
			COPY_MEM(RHdr, &MarsCntrlHdr, sizeof(MarsCntrlHdr));
			RHdr->Opcode = OP_MARS_REDIRECT_MAP;
			RHdr->TgtAddressTL = ATM_ADDRESS_LENGTH;
			PUTSHORT2SHORT(&(RHdr->NumTgtAddr), 1 + pIntF->NumAddressesRegd);

			p = (PUCHAR)(RHdr + 1);

			//
			// Source ATM Number
			//
			COPY_MEM(p, pIntF->ConfiguredAddress.Address, pIntF->ConfiguredAddress.NumberOfDigits);

			p += pIntF->ConfiguredAddress.NumberOfDigits;

			pAtmAddress = pIntF->RegAddresses;
			for (i = pIntF->NumAddressesRegd;
				 i != 0;
				 i--)
			{
				ARPS_ASSERT(pAtmAddress->NumberOfDigits <= 20);
				COPY_MEM(p, pAtmAddress->Address, pAtmAddress->NumberOfDigits);
				p += pAtmAddress->NumberOfDigits;
				pAtmAddress++;
			}

			PacketLength = (ULONG)(p - (PUCHAR)RHdr);

			NdisAdjustBufferLength(RedirPacket->Private.Head, PacketLength);
			RedirPacket->Private.ValidCounts = FALSE;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockAcquired = FALSE;
			MarsSendOnClusterControlVc(pIntF, RedirPacket);
		}
	}

	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	return (!TimerShuttingDown);
}


VOID
MarsAbortAllMembers(
	IN	PINTF					pIntF
	)

/*++

Routine Description:

	Abort all Cluster Members on the specified Interface, by removing
	all their group memberships, and dropping them off ClusterControlVc.

Arguments:

	pIntF				- Ptr to Interface

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER			pMember = NULL;
	PCLUSTER_MEMBER			pNextMember;
	KIRQL					OldIrql;
	BOOLEAN					fLockPreserved;
	UINT					uInitialMembersEnumerated;
	UINT					uTotalMembersEnumerated;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	// 
	// TODO: disable more members from being added.
	//

	//
	// First with the IntF lock held, we go through unlinking groups from
	// all cluster members.
	//
	uInitialMembersEnumerated = 0;
	for (pMember = pIntF->ClusterMembers;
		pMember != NULL_PCLUSTER_MEMBER;
		pMember =  (PCLUSTER_MEMBER)pMember->Next)
	{
		uInitialMembersEnumerated++;

		MARSDBGPRINT(DBG_LEVEL_NOTICE,
		   ("MarsAbortAllMembers: pIntF %x, Unlinking groups on Cluster Member %x\n",
			pIntF, pMember));

		//
		// Delete all groups from this member
		// AND disable further groups from being added.
		//
		MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);
	}

	//
	// Then we initiate the deletion of each cluster member.
	//
	uTotalMembersEnumerated = 0;
	do
	{
		fLockPreserved = TRUE;

		if (uTotalMembersEnumerated >
			 (uInitialMembersEnumerated*uInitialMembersEnumerated))
		{
			//
			// This really shouldn't happen. In the worst case, we expect
			// total enumerations to be around N*(N-1)/2, where N is
			// uInitialMembersEnumerated.
			// NOTE: the squaring above could theoretically result in an overflow.
			// But we're really not shooting to support 65536 cluster members!
			// If we were, our O(N^2) algorithms will breakdown anyway!
			//
			ASSERT(!"Not making progress deleting members.");
			break;
		}

		for (pMember = pIntF->ClusterMembers;
 			pMember != NULL_PCLUSTER_MEMBER;
			pMember =  pNextMember)
		{
		    pNextMember = (PCLUSTER_MEMBER)pMember->Next;
			uTotalMembersEnumerated++;
	
			MARSDBGPRINT(DBG_LEVEL_NOTICE,
					("MarsAbortAllMembers: pIntF %x, Deleting Cluster Member %x\n",
						pIntF, pMember));
	
			fLockPreserved = MarsDelMemberFromClusterControlVc(
								pIntF,
								pMember,
								TRUE,
								OldIrql
								);
	
			if (!fLockPreserved)
			{
				//
				// This means that MarsDelMemberFromClusterControlVc has
				// made some non-idempotent change to pMember which has
				// required it to release the pIntF lock.
				//
				// We will re-acquire the lock and start enumeration from scratch.
				//
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
				break;
			}
		}

	} while (!fLockPreserved);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}



VOID
MarsStopInterface(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Shut down all MARS activity on the specified Interface.

	1. Free any packets queued for transmission on ClusterControlVc.
	2. Delete all Cluster Members, and drop them from ClusterControlVc.
	3. Clean up the MARS cache.

Arguments:

	pIntF				- Ptr to Interface

Return Value:

	None

--*/
{
	PMARS_ENTRY				pMarsEntry;
	PMARS_ENTRY				pNextMarsEntry;
	ULONG					i;
	KIRQL					OldIrql;

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("=>MarsStopInterface: pIntF %x, Flags %x, Ref %x\n",
				pIntF, pIntF->Flags, pIntF->RefCount));

	MarsFreePacketsQueuedForClusterControlVc(pIntF);

	//
	// Delete all cluster members.
	//
	MarsAbortAllMembers(pIntF);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (pIntF->pMcsList != NULL)
	{
		FREE_MEM(pIntF->pMcsList);
		pIntF->pMcsList = NULL;
	}

	//
	// Clean up the MARS cache.
	//
	for (i = 0; i < MARS_TABLE_SIZE; i++)
	{
		// Remove the list at pIntF->MarsCache[i] and nuke all items in it.
		// Be sure to set pIntF->MarsCache[i] to NULL so no one else tries to
		// get to these entries in the mean time.
		//
		pMarsEntry = pIntF->MarsCache[i];
		pIntF->MarsCache[i] = NULL;

		for (;
			 pMarsEntry != NULL_PMARS_ENTRY;
			 pMarsEntry = pNextMarsEntry)
		{
			pNextMarsEntry = (PMARS_ENTRY)pMarsEntry->Next;

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsStopIntf: pIntF %x, Freeing MARS Entry %x, IP Addr: ",
						pIntF, pMarsEntry));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, pMarsEntry->IPAddress, "\n");

			ARPS_ASSERT(pMarsEntry->pMembers == NULL_PGROUP_MEMBER);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			ArpSFreeBlock(pMarsEntry);

			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
	}

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("<=MarsStopInterface: pIntF %x, Flags %x, Ref %x\n",
				pIntF, pIntF->Flags, pIntF->RefCount));

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return;
}


#if DBG

VOID
MarsDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	)
{
	UINT	i;

	MARSDBGPRINT(DBG_LEVEL_INFO, (" PacketDump: "));
	for (i = 0; i < PktLen; i++)
	{
		MARSDBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", Packet[i]));
	}

	MARSDBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}

VOID
MarsDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	)
{
	PUCHAR	p = (PUCHAR)&IpAddr;

	DbgPrint("%d.%d.%d.%d%s", p[0], p[1], p[2], p[3], String);
}

VOID
MarsDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = AtmAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = AtmAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s(%s, %d): %s\n",
					String,
					(AtmAddr->AddressType == ATM_E164) ? "E164" : "NSAP",
					AtmAddr->NumberOfDigits,
					AddrString);
}

VOID
MarsDumpMap(
	IN	PCHAR					String,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			AtmAddr
	)
{
	PUCHAR		pIpAddrVal = (PUCHAR)&IpAddr;

	DbgPrint("MARS: %s %d.%d.%d.%d : ",
				String,
				((PUCHAR)pIpAddrVal)[3],
				((PUCHAR)pIpAddrVal)[2],
				((PUCHAR)pIpAddrVal)[1],
				((PUCHAR)pIpAddrVal)[0]
			);

	MarsDumpAtmAddr(AtmAddr, "");
}

#endif // DBG


BOOLEAN
MarsIsValidClusterMember(
	PINTF				pIntF,
	PCLUSTER_MEMBER		pPossibleMember
	)
/*++

Routine Description:

	Verify that pPossibleMember is a valid member,
	by checking if it is in the list of members.
	pMember COULD be an invalid pointer.

	The interface lock is expected to be held and is not released.

Arguments:

	pIntF			- Ptr to Interface
	pPossibleMember	- Ptr to Cluster Member to be validated.

Return Value:

	TRUE IFF pMember is in the cluster member list.

--*/
{
	PCLUSTER_MEMBER		pMember;

	for (pMember = pIntF->ClusterMembers;
		pMember != NULL_PCLUSTER_MEMBER;
		pMember =  (PCLUSTER_MEMBER)pMember->Next)
	{
		if (pMember == pPossibleMember)
		{
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\intf.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    intf.h

Abstract:

    This file contains the per-adapter (LIS) interface definition.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_INTF_
#define	_INTF_

#define	SERVICE_NAME				L"AtmArpS"

#define	NUM_ARPS_DESC		128
#define	NUM_MARS_DESC		128
#define	MAX_DESC_MULTIPLE	10
#define	ARP_TABLE_SIZE		64		// Keep this as a power of 2. The ARP_HASH macro relies on it.
#define	MARS_TABLE_SIZE		32		// Keep this as a power of 2. The MARS_HASH macro relies on it.

#define	ARP_HASH(_ipaddr)			((((PUCHAR)&(_ipaddr))[3]) & (ARP_TABLE_SIZE - 1))
#define	MARS_HASH(_ipaddr)			((((PUCHAR)&(_ipaddr))[3]) & (MARS_TABLE_SIZE - 1))

typedef	struct _ArpVc		ARP_VC, *PARP_VC;
typedef	struct _REG_ADDR_CTXT	REG_ADDR_CTXT, *PREG_ADDR_CTXT;

//
// The protocol reserved area in the ndis packets.
//
typedef struct
{
	LIST_ENTRY			ReqList;	// For queuing the packet into the KQUEUE
	SLIST_ENTRY	        FreeList;	// For queuing the packet into the SLIST
	PARP_VC				Vc;			// Owning Vc in case of queued packet
	USHORT				Flags;		// Misc. other information
	USHORT				PktLen;		// Length of incoming packet
	union {
		PNDIS_PACKET	OriginalPkt;// When a packet is forwarded by the MARS
		PUCHAR			PacketStart;// For MARS Control packets
	};
} PROTOCOL_RESD, *PPROTOCOL_RESD;

#define	RESD_FLAG_MARS		0x0001	// Indicates that the packet is to be processed by MARS
#define	RESD_FLAG_MARS_PKT	0x0002	// Indicates that the packet is from the MARS pool
#define	RESD_FLAG_FREEBUF	0x0004	// Indicates that the buffer and associated memory must be
									// freed upon completion of the send.
#define RESD_FLAG_KILL_CCVC	0x0010	// This isn't part of a packet. This is used
									// to queue a request to abort ClusterControlVc.
#define	RESD_FROM_PKT(_Pkt)		(PPROTOCOL_RESD)((_Pkt)->ProtocolReserved)

typedef	UCHAR	ATM_ADDR_TYPE;

typedef struct _HwAddr
{
	ATM_ADDRESS			Address;
	PATM_ADDRESS		SubAddress;
} HW_ADDR, *PHW_ADDR;

#define	COMP_ATM_ADDR(_a1_, _a2_)	(((_a1_)->AddressType == (_a2_)->AddressType) &&						\
									 ((_a1_)->NumberOfDigits == (_a2_)->NumberOfDigits) &&					\
									 COMP_MEM((_a1_)->Address,												\
											  (_a2_)->Address,												\
											  (_a1_)->NumberOfDigits))

#define	COPY_ATM_ADDR(_d_, _s_)																				\
	{																										\
		(_d_)->AddressType = (_s_)->AddressType;															\
		(_d_)->NumberOfDigits = (_s_)->NumberOfDigits;														\
		COPY_MEM((_d_)->Address, (_s_)->Address, (_s_)->NumberOfDigits);									\
	}

#define	COMP_HW_ADDR(_a1_, _a2_)	(((_a1_)->Address.AddressType == (_a2_)->Address.AddressType) &&		\
									 ((_a1_)->Address.NumberOfDigits == (_a2_)->Address.NumberOfDigits) &&	\
									 COMP_MEM((_a1_)->Address.Address,										\
											  (_a2_)->Address.Address,										\
											  (_a1_)->Address.NumberOfDigits) && 							\
									 ((((_a1_)->SubAddress == NULL) && ((_a2_)->SubAddress == NULL)) ||		\
									  ((((_a1_)->SubAddress != NULL) && ((_a2_)->SubAddress != NULL)) &&	\
									   ((_a1_)->SubAddress->AddressType == (_a2_)->SubAddress->AddressType) &&\
									   ((_a1_)->SubAddress->NumberOfDigits == (_a2_)->SubAddress->NumberOfDigits) &&\
									   COMP_MEM((_a1_)->SubAddress->Address,								\
											    (_a2_)->SubAddress->Address,								\
											    (_a1_)->SubAddress->NumberOfDigits))))						\

#define	COPY_HW_ADDR(_d_, _s_)																				\
	{																										\
		(_d_)->Address.AddressType = (_s_)->Address.AddressType;											\
		(_d_)->Address.NumberOfDigits = (_s_)->Address.NumberOfDigits;										\
		COPY_MEM((_d_)->Address.Address, (_s_)->Address.Address, (_s_)->Address.NumberOfDigits);			\
		if ((_s_)->SubAddress != NULL)																		\
		{																									\
			(_d_)->SubAddress->AddressType = (_s_)->SubAddress->AddressType;								\
			(_d_)->SubAddress->NumberOfDigits = (_s_)->SubAddress->NumberOfDigits;							\
			COPY_MEM((_d_)->SubAddress->Address, (_s_)->SubAddress->Address, (_s_)->SubAddress->NumberOfDigits);\
		}																									\
	}

typedef struct _ENTRY_HDR
{
	VOID				*		Next;
	VOID				**		Prev;
} ENTRY_HDR, *PENTRY_HDR;

typedef	struct _ArpEntry
{
	ENTRY_HDR;
	HW_ADDR						HwAddr;				// HWADDR MUST FOLLOW ENTRY_HDR
	TIMER						Timer;
	IPADDR						IpAddr;
	PARP_VC						Vc;					// Pointer to the Vc (if active)
	UINT						Age;
} ARP_ENTRY, *PARP_ENTRY;

#define	FLUSH_TIME				60*MULTIPLIER		// 60 minutes in 15s units
#define	ARP_AGE					20*MULTIPLIER		// 20 minutes in 15s units
#define REDIRECT_INTERVAL		1*MULTIPLIER		// 1 minute

#define	ARP_BLOCK_VANILA		(ENTRY_TYPE)0
#define	ARP_BLOCK_SUBADDR		(ENTRY_TYPE)1
#define	MARS_CLUSTER_VANILA		(ENTRY_TYPE)2
#define	MARS_CLUSTER_SUBADDR	(ENTRY_TYPE)3
#define	MARS_GROUP				(ENTRY_TYPE)4
#define	MARS_BLOCK_ENTRY		(ENTRY_TYPE)5

#define	ARP_BLOCK_TYPES			(ENTRY_TYPE)6
#define	BLOCK_ALLOC_SIZE		PAGE_SIZE

typedef	UINT	ENTRY_TYPE;

typedef	struct _ArpBlock
{
	struct _ArpBlock *			Next;				// Link to next
	struct _ArpBlock **			Prev;				// Link to previous
	struct _IntF *				IntF;				// Back pointer to the interface
	ENTRY_TYPE					EntryType;			// ARP_BLOCK_XXX
	UINT						NumFree;			// # of free ArpEntries in this block
	PENTRY_HDR					FreeHead;			// Head of the list of free Arp Entries
} ARP_BLOCK, *PARP_BLOCK;


//
// Forward declaration
//
typedef struct _MARS_ENTRY	MARS_ENTRY, *PMARS_ENTRY;
typedef struct _MARS_VC MARS_VC, *PMARS_VC;
typedef struct _MARS_FLOW_SPEC MARS_FLOW_SPEC, *PMARS_FLOW_SPEC;
typedef struct _CLUSTER_MEMBER CLUSTER_MEMBER, *PCLUSTER_MEMBER;
typedef struct _MCS_ENTRY MCS_ENTRY, *PMCS_ENTRY;

//
// Flow Specifications for an ATM Connection. The structure
// represents a bidirectional flow.
//
typedef struct _MARS_FLOW_SPEC
{
	ULONG						SendBandwidth;		// Bytes/Sec
	ULONG						SendMaxSize;		// Bytes
	ULONG						ReceiveBandwidth;	// Bytes/Sec
	ULONG						ReceiveMaxSize;		// Bytes
	SERVICETYPE					ServiceType;

} MARS_FLOW_SPEC, *PMARS_FLOW_SPEC;
 


typedef struct _IntF
{
	struct _IntF *				Next;

	LONG						RefCount;
	ULONG						Flags;

	UNICODE_STRING				InterfaceName;		// Name of device bound to
	UNICODE_STRING				FriendlyName;		// Descriptive name of above
	UNICODE_STRING				FileName;			// Name of file where arp entries are stored
	UNICODE_STRING				ConfigString;		// Used to access registry

	//
	// Fields relating to NDIS.
	//
	NDIS_MEDIUM					SupportedMedium;	// For use in NdisOpenAdapter
	NDIS_HANDLE					NdisBindingHandle;	// Handle to the binding
	NDIS_HANDLE					NdisAfHandle;		// Handle to the registered Address Family
	union
	{
		NDIS_HANDLE				NdisSapHandle;		// Handle to the registered Sap
		NDIS_HANDLE				NdisBindContext;	// Valid only during BindAdapter call
	};

	CO_ADDRESS_FAMILY			AddrFamily;			// For use by NdisClOpenAddressFamily
	PCO_SAP						Sap;				// For use by NdisClRegisterSap

	LIST_ENTRY					InactiveVcHead;		// Created Vcs go here.
	LIST_ENTRY					ActiveVcHead;		// Vcs with active calls go here.
#if	DBG
	LIST_ENTRY					FreeVcHead;			// Freed Vcs go here - fo Debugging.
#endif
	UCHAR						SelByte;			// Read as part of the configuration
	USHORT						NumAllocedRegdAddresses;	// # of registered atm addresses on this i/f
	USHORT						NumAddressesRegd;	// # of atm addresses successfully registered on this i/f
	ATM_ADDRESS					ConfiguredAddress;	// Configured address for this port
	UINT						NumPendingDelAddresses; // Number of address pending deletion.
	PATM_ADDRESS				RegAddresses;		// Array of h/w addresses
	PREG_ADDR_CTXT				pRegAddrCtxt;		// Context used when registering
													// addresses.

	UINT						NumCacheEntries;
	PARP_ENTRY					ArpCache[ARP_TABLE_SIZE];
											// The list of arp entries that we know about
	ULONG						LastVcId;			// A server created id assigned to each incoming vc
	PTIMER						ArpTimer;			// Head of the timer-list for this interface
	KMUTEX						ArpCacheMutex;		// Protects the ArpCache and the ArpTimer
	KEVENT						TimerThreadEvent;	// Signal this to kill the timer thread

	TIMER						FlushTimer;			// Used to flush arp-cache to disk
	TIMER						BlockTimer;			// Used to age-out arp blocks
	PKEVENT						CleanupEvent;		// signalling when IntF is freed
	PKEVENT						DelAddressesEvent;	// signalling when addresses are deleted

	PARP_BLOCK					PartialArpBlocks[ARP_BLOCK_TYPES];
	PARP_BLOCK					UsedArpBlocks[ARP_BLOCK_TYPES];
	ARP_SERVER_STATISTICS		ArpStats;

	LARGE_INTEGER 				StatisticsStartTimeStamp;

	//
	// Fields used by MARS
	//
	PMARS_ENTRY					MarsCache[MARS_TABLE_SIZE];
	MARS_SERVER_STATISTICS		MarsStats;
	PCLUSTER_MEMBER				ClusterMembers;		// List of Cluster members
	ULONG						NumClusterMembers;	// Size of above list
	PMCS_ENTRY					pMcsList;			// MCS configuration
	PMARS_VC					ClusterControlVc;	// Outgoing PMP for MARS control
													// and MCS data
	INT							CCActiveParties;	// Number of connected members
	INT							CCAddingParties;	// Number of AddParty()'s pending
	INT							CCDroppingParties;	// Number of DropParty()'s pending
	LIST_ENTRY					CCPacketQueue;		// Packets queued for sending on
													// the above VC.
	ULONG						CSN;				// ClusterSequenceNumber
	USHORT						CMI;				// ClusterMemberId
	ULONG						MaxPacketSize;		// Supported by miniport
	NDIS_CO_LINK_SPEED			LinkSpeed;			// Supported by miniport
	struct _MARS_FLOW_SPEC		CCFlowSpec;			// Flow params for ClusterControlVc
	TIMER						MarsRedirectTimer;	// For periodic MARS_REDIRECT

	KSPIN_LOCK					Lock;
} INTF, *PINTF;

#define	INTF_ADAPTER_OPENED		0x00000001	// Set after OpenAdapterComplete runs
#define	INTF_AF_OPENED			0x00000002	// Set after OpenAfComplete runs
#define	INTF_SAP_REGISTERED		0x00000008	// Set after RegisterSapComplete runs
#define	INTF_ADDRESS_VALID		0x00000010	// Set after OID_CO_ADDRESS_CHANGE is notified

#define INTF_SENDING_ON_CC_VC	0x00001000	// Send in progress on ClusterControlVc
#define INTF_STOPPING			0x40000000	// StopInterface in progress
#define	INTF_CLOSING			0x80000000	// Set after CloseAdapterComplete runs

typedef	struct _ArpVc
{
	ULONG						VcType;		// Must be the first field in struct
	LIST_ENTRY					List;
	USHORT						RefCount;
	USHORT						Flags;
	ULONG						PendingSends;
	ULONG						VcId;
	NDIS_HANDLE					NdisVcHandle;
	PINTF						IntF;
	ULONG						MaxSendSize;// From AAL parameters
	PARP_ENTRY					ArpEntry;
	HW_ADDR						HwAddr;		// From CallingPartyAddress
} ARP_VC, *PARP_VC;

#define	ARPVC_ACTIVE				0x0001
#define	ARPVC_CALLPROCESSING		0x0002
#define ARPVC_CLOSE_PENDING			0x4000
#define	ARPVC_CLOSING				0x8000

//
// VC types:
// 
#define VC_TYPE_INCOMING			((ULONG)0)
#define VC_TYPE_MARS_CC				((ULONG)1)	// ClusterControlVc
#define VC_TYPE_CHECK_REGADDR		((ULONG)2)	// Transient vc to validate
												// a registered address.


#define	CLEANUP_DEAD_VC(_ArpEntry)														\
	{																					\
		if (((_ArpEntry)->Vc != NULL) && (((_ArpEntry)->Vc->Flags & ARPVC_ACTIVE) == 0))\
		{																				\
			PARP_VC	Vc = (_ArpEntry)->Vc;												\
																						\
			ArpSDereferenceVc(Vc, TRUE, FALSE);											\
			(_ArpEntry)->Vc = NULL;														\
		}																				\
	}


//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x4)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define REGADDR_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )


// REG_ADDR_CTXT stores context relating to validating and registering the
// list of addresses that need to be explicitly registered. "Validating" consists
// of making a call to the address *before* registering, to make sure that
// no one *else* has registered the same address.
// See 05/14/1999 notes.txt entry for details.
//
typedef struct _REG_ADDR_CTXT
{
	ULONG				VcType;		// Must be the first field in struct
	NDIS_HANDLE			NdisVcHandle;	// NDIS VC handle used for makeing a call
										// to verify that the address is unused.

	ULONG				Flags;		// One or more of the following flags.
	#define	REGADDRCTXT_RESTART					0x0001
	#define	REGADDRCTXT_ABORT					0x0002
	#define	REGADDRCTXT_MAKECALL_PENDING		0x0004
	#define	REGADDRCTXT_CLOSECALL_PENDING		0x0008
	// TODO/WARNING -- the above flags are currently UNUSED.

	UINT				RegAddrIndex;	// Index of the address being registered.
	PINTF				pIntF;

	// Request is for setting up an ndis request to add (register) a local address.
	//
	struct
	{
		NDIS_REQUEST		NdisRequest;
		CO_ADDRESS			CoAddress;
		ATM_ADDRESS			AtmAddress;
	} Request;

	// CallParams and the following union are for setting up the validation call.
	//
	CO_CALL_PARAMETERS		CallParams;

	// Call manager parameters, plus extra space for the ATM-specific stuff...
	//
	union
	{
		CO_CALL_MANAGER_PARAMETERS 					CmParams;
		UCHAR	Buffer[	sizeof(CO_CALL_MANAGER_PARAMETERS)
			  + sizeof(Q2931_CALLMGR_PARAMETERS) +
			    REGADDR_MAKE_CALL_IE_SPACE];
	};

} REG_ADDR_CTXT, *PREG_ADDR_CTXT;


//
//  Temp structure used to store information read from the registry.
//
typedef struct _ATMARPS_CONFIG
{
	UCHAR						SelByte;			// Selector Byte
	USHORT						NumAllocedRegdAddresses;
	PATM_ADDRESS				RegAddresses;
	PMCS_ENTRY					pMcsList;			// MCS configuration

} ATMARPS_CONFIG, *PATMARPS_CONFIG;

//
// Some defaults
//
#define DEFAULT_SEND_BANDWIDTH		(ATM_USER_DATA_RATE_SONET_155*100/8)	// Bytes/sec
#define DEFAULT_MAX_PACKET_SIZE		9180	// Bytes

// Minimum tolerated MAX_PACKET_SIZE
//
#define ARPS_MIN_MAX_PKT_SIZE 9180	// Bytes


#endif	// _INTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\ndis.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ndis.c

Abstract:

    This file contains the code to implement the initialization
	functions for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_NDIS

NTSTATUS
ArpSInitializeNdis(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_STATUS						Status;
	NDIS_PROTOCOL_CHARACTERISTICS	Chars;
	UINT							i, j;
	PUCHAR							pTmp;

	do
	{
		INITIALIZE_SPIN_LOCK(&ArpSPktListLock);
		ExInitializeSListHead(&ArpSPktList);

		//
		// Start off by allocating packets, mdls and buffer space
		// 
		NdisAllocatePacketPoolEx(&Status,
								 &ArpSPktPoolHandle,
								 ArpSBuffers,
								 ArpSBuffers * (MAX_DESC_MULTIPLE-1),
								 sizeof(PROTOCOL_RESD));
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
	#if 0
		{
			INT SkipAll = 0;
			
			DBGPRINT(DBG_LEVEL_ERROR, ("SkipAll = 0x%p.\n", &SkipAll));
			DbgBreakPoint();

			if (SkipAll)
			{
				DBGPRINT(DBG_LEVEL_ERROR, ("ABORTING ATMARPS\n"));
				Status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
	#endif // 0

		NdisAllocateBufferPool(&Status,
							   &ArpSBufPoolHandle,
							   ArpSBuffers);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
		NdisAllocatePacketPoolEx(&Status,
								 &MarsPktPoolHandle,
								 MarsPackets,
								 MarsPackets * (MAX_DESC_MULTIPLE-1),
								 sizeof(PROTOCOL_RESD));
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(&Status,
							   &MarsBufPoolHandle,
							   ArpSBuffers);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
		ArpSBufferSpace = ALLOC_NP_MEM(ArpSBuffers*PKT_SPACE, POOL_TAG_BUF);
		if (ArpSBufferSpace == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		// Now that we have the packets and the buffer descriptors, allocate memory for the each of the packets
		// and queue them up in the global list. Fail only if no packets initialized.
		//
		for (i = 0, pTmp = ArpSBufferSpace;
			 i < ArpSBuffers;
			 i++, pTmp += PKT_SPACE)
		{
			PNDIS_PACKET	Pkt;
			PNDIS_BUFFER	Buf;
			PPROTOCOL_RESD	Resd;
	
			//
			// The packet pool is already allocated. NdisAllocatePacket cannot fail.
			//
			NdisAllocatePacket(&Status, &Pkt, ArpSPktPoolHandle);
			ASSERT (Status == NDIS_STATUS_SUCCESS);
			if (Status != NDIS_STATUS_SUCCESS)
			{
			    DbgPrint("ATMARPS: failed to alloc pkt from %p\n", ArpSPktPoolHandle);
			    DbgBreakPoint();
			    DbgBreakPoint();
			}

			Resd = RESD_FROM_PKT(Pkt);
			InitializeListHead(&Resd->ReqList);
			NdisAllocateBuffer(&Status,
							   &Buf,
							   ArpSBufPoolHandle,
							   pTmp,
							   PKT_SPACE);
			if (Status == NDIS_STATUS_SUCCESS)
			{
				NdisChainBufferAtFront(Pkt, Buf);
				ExInterlockedPushEntrySList(&ArpSPktList,
											&Resd->FreeList,
											&ArpSPktListLock);
			}
			else
			{
				NdisFreePacket(Pkt);
				break;
			}
		}
	
		if (i == 0)
		{
			//
			// We could not initialize even one packet, quit.
			//
			break;
		}

		//
		// Now register with NDIS as a protocol. We do this last since we
		// must be ready to accept incoming bind notifications
		// 
		RtlZeroMemory(&Chars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
		Chars.MajorNdisVersion = 5;
		Chars.MinorNdisVersion = 0;
		Chars.OpenAdapterCompleteHandler = ArpSOpenAdapterComplete;
		Chars.CloseAdapterCompleteHandler = ArpSCloseAdapterComplete;
		Chars.StatusHandler = ArpSStatus;
		Chars.RequestCompleteHandler = ArpSRequestComplete;
		Chars.ReceiveCompleteHandler = ArpSReceiveComplete;
		Chars.StatusCompleteHandler = ArpSStatusComplete;
		Chars.BindAdapterHandler = ArpSBindAdapter;
		Chars.UnbindAdapterHandler = ArpSUnbindAdapter;
		Chars.PnPEventHandler = ArpSPnPEventHandler;
	
		Chars.CoSendCompleteHandler = ArpSCoSendComplete;
		Chars.CoStatusHandler = ArpSCoStatus;
		Chars.CoReceivePacketHandler = ArpSHandleArpRequest;
		Chars.CoAfRegisterNotifyHandler = ArpSCoAfRegisterNotify;
	
		RtlInitUnicodeString(&Chars.Name, SERVICE_NAME);
	
		NdisRegisterProtocol(&Status, &ArpSProtocolHandle, &Chars, sizeof(Chars));
	} while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		ArpSDeinitializeNdis();
	}

	return Status;
}


VOID
ArpSDeinitializeNdis(
	VOID
	)
{
	NDIS_STATUS				Status;
	PNDIS_PACKET			Packet;
	PSLIST_ENTRY		    Entry;
	PPROTOCOL_RESD			Resd;

	if (ArpSProtocolHandle != NULL)
	{
		NdisDeregisterProtocol(&Status, ArpSProtocolHandle);
		ArpSProtocolHandle = NULL;
	}

	while ((Entry = ExInterlockedPopEntrySList(&ArpSPktList, &ArpSPktListLock)) != NULL)
	{
		Resd = CONTAINING_RECORD(Entry, PROTOCOL_RESD, FreeList);
		Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		NdisFreeBuffer(Packet->Private.Head);
		NdisFreePacket(Packet);
	}

	if (ArpSBufPoolHandle != NULL)
	{
		NdisFreeBufferPool(ArpSBufPoolHandle);
		ArpSBufPoolHandle = NULL;
	}

	if (ArpSPktPoolHandle != NULL)
	{
		NdisFreePacketPool(ArpSPktPoolHandle);
		ArpSPktPoolHandle = NULL;
	}

	if (MarsBufPoolHandle != NULL)
	{
		NdisFreeBufferPool(MarsBufPoolHandle);
		MarsBufPoolHandle = NULL;
	}

	if (MarsPktPoolHandle != NULL)
	{
		NdisFreePacketPool(MarsPktPoolHandle);
		MarsPktPoolHandle = NULL;
	}

	if (ArpSBufferSpace != NULL)
	{
		FREE_MEM(ArpSBufferSpace);
        ArpSBufferSpace = NULL;
	}
}


VOID
ArpSBindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	)
/*++

Routine Description:

	Handle incoming bind requests here. Open the adapter, read the per-adapter registry and
	initialize the binding.

Arguments:

	Status			Placeholder for returning status
	BindContext		Opaque blob to call NdisBindAdapterComplete if we pend this
	DeviceName		The adapter name which we should bind to
	SystemSpecific1	To be used with NdisOpenProtocolConfiguration, if the per-adapter
					configuration information is stored with the adapter
	SystemSpecific2	Not currently used.

Return Value:

	Status of the per-adapter initialization

--*/
{
	PINTF		pIntF;
	NDIS_STATUS	OpenErrorStatus;
	UINT		SelectedMedium;
	NDIS_MEDIUM	SupportedMedium = NdisMediumAtm;
	KIRQL		EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	//
	// Allocate an Interface block and initialize it
	//
	pIntF = ArpSCreateIntF(DeviceName, (PNDIS_STRING)SystemSpecific1, BindContext);
	if (pIntF != NULL)
	{
		//
		// Save the binding context
		//
		pIntF->NdisBindContext = BindContext;

		*Status = ArpSReadAdapterConfiguration(pIntF);

		if (*Status == NDIS_STATUS_SUCCESS)
		{
			//
			// Read the Arp cache in now. We prime the arp table to start off.
			//
			if (ArpSFlushTime != 0)
			{
				ArpSReadArpCache(pIntF);
			}

			//
			// Open the adapter and see if it is interesting to us (mediatype should be atm)
			//
			NdisOpenAdapter(Status,
							&OpenErrorStatus,
							&pIntF->NdisBindingHandle,
							&SelectedMedium,
							&pIntF->SupportedMedium,
							sizeof(NDIS_MEDIUM),
							ArpSProtocolHandle,
							pIntF,
							DeviceName,
							0,
							NULL);

			ARPS_CHECK_IRQL(EntryIrql);
			if (*Status != NDIS_STATUS_PENDING)
			{
				ArpSOpenAdapterComplete(pIntF, *Status, OpenErrorStatus);
			}
			ARPS_CHECK_IRQL(EntryIrql);

			*Status = NDIS_STATUS_PENDING;
		}
		else
		{
			//
			// Could not read per-adapter registry. Use defaults.
			//
			LOG_ERROR(*Status);
		}
	}
	else
	{
		*Status = NDIS_STATUS_RESOURCES;
		LOG_ERROR(Status);
	}
}


VOID
ArpSOpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	)
/*++

Routine Description:

	Upcall from NDIS to signal completion of a NdisOpenAdapter() call.

Arguments:

	ProtocolBindingContext		Pointer to the pIntF
	Status						Status of NdisOpenAdapter
	OpenErrorStatus				Adapter's code

Return Value:


--*/
{
	PINTF						pIntF = (PINTF)ProtocolBindingContext;
	KIRQL						OldIrql;

	//
	// First complete the pending bind call.
	//
	NdisCompleteBindAdapter(pIntF->NdisBindContext, Status, OpenErrorStatus);
	pIntF->NdisBindContext = NULL;	// We do not need this anymore

    if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		// NdisOpenAdapter() failed - log an error and exit
		//
		LOG_ERROR(Status);
		ArpSCloseAdapterComplete(pIntF, Status);
	}
	else
	{
		//
		// Insert this into the global adapter list
		//
		ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);
		{
			PINTF	pTmpIntF;

			for (pTmpIntF = ArpSIfList;
 				pTmpIntF != NULL;
 				pTmpIntF = pTmpIntF->Next)
			{
				if (pTmpIntF == pIntF)
				{
					DbgPrint("ATMARPS: OpenAdComp: IntF %p already in list!\n",
						pTmpIntF);
					DbgBreakPoint();
				}
			}
		}

		ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);

		pIntF->Flags |= INTF_ADAPTER_OPENED;
		pIntF->Next = ArpSIfList;
		ArpSIfList = pIntF;
		ArpSIfListSize++;

		RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);
		RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

		ArpSQueryAdapter(pIntF);
	}
}


VOID
ArpSCoAfRegisterNotify(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily
	)
/*++

Routine Description:


Arguments:


Return Value:

	None.

--*/
{
	PINTF						pIntF = (PINTF)ProtocolBindingContext;
	NDIS_STATUS					Status;
	NDIS_CLIENT_CHARACTERISTICS	Chars;
	KIRQL						EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	if ((AddressFamily->AddressFamily == CO_ADDRESS_FAMILY_Q2931)	&&
		(AddressFamily->MajorVersion == 3)							&&
        (AddressFamily->MinorVersion == 1)							&&
		(pIntF->NdisAfHandle == NULL) )
	{
		DBGPRINT(DBG_LEVEL_NOTICE,
			("AfNotify: IntF %x, Name %Z\n", pIntF, &pIntF->InterfaceName));

		if (ArpSReferenceIntF(pIntF))
		{
			//
			// We successfully opened the adapter. Now open the address-family
			//
			pIntF->AddrFamily.AddressFamily = CO_ADDRESS_FAMILY_Q2931;
			pIntF->AddrFamily.MajorVersion = 3;
			pIntF->AddrFamily.MinorVersion = 1;
			
			ZERO_MEM(&Chars, sizeof(NDIS_CLIENT_CHARACTERISTICS));
			Chars.MajorVersion = 5;
			Chars.MinorVersion = 0;
			Chars.ClCreateVcHandler = ArpSCreateVc;
			Chars.ClDeleteVcHandler = ArpSDeleteVc;
			Chars.ClRequestHandler = ArpSCoRequest;
			Chars.ClRequestCompleteHandler = ArpSCoRequestComplete;
			Chars.ClOpenAfCompleteHandler = ArpSOpenAfComplete;
			Chars.ClCloseAfCompleteHandler = ArpSCloseAfComplete;
			Chars.ClRegisterSapCompleteHandler = ArpSRegisterSapComplete;
			Chars.ClDeregisterSapCompleteHandler = ArpSDeregisterSapComplete;
			Chars.ClMakeCallCompleteHandler = ArpSMakeCallComplete;
			Chars.ClModifyCallQoSCompleteHandler = NULL;
			Chars.ClCloseCallCompleteHandler = ArpSCloseCallComplete;
			Chars.ClAddPartyCompleteHandler = ArpSAddPartyComplete;
			Chars.ClDropPartyCompleteHandler = ArpSDropPartyComplete;
			Chars.ClIncomingCallHandler = ArpSIncomingCall;
			Chars.ClIncomingCallQoSChangeHandler = ArpSIncomingCallQoSChange;
			Chars.ClIncomingCloseCallHandler = ArpSIncomingCloseCall;
			Chars.ClIncomingDropPartyHandler = ArpSIncomingDropParty;
			Chars.ClCallConnectedHandler = ArpSCallConnected;
			
			Status = NdisClOpenAddressFamily(pIntF->NdisBindingHandle,
											 &pIntF->AddrFamily,
											 pIntF,			// Use this as the Af context too
											 &Chars,
											 sizeof(NDIS_CLIENT_CHARACTERISTICS),
											 &pIntF->NdisAfHandle);
			ARPS_CHECK_IRQL(EntryIrql);
			if (Status != NDIS_STATUS_PENDING)
			{
				ARPS_CHECK_IRQL(EntryIrql);
				ArpSOpenAfComplete(Status, pIntF, pIntF->NdisAfHandle);
				ARPS_CHECK_IRQL(EntryIrql);
			}
		}
		else
		{
			ARPS_CHECK_IRQL(EntryIrql);
			ArpSTryCloseAdapter(pIntF);
			ARPS_CHECK_IRQL(EntryIrql);
		}
	}
	ARPS_CHECK_IRQL(EntryIrql);
}

VOID
ArpSOpenAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisAfHandle
	)
/*++

Routine Description:

	Completion processing for the OpenAf call.

Arguments:

	Status				Status of OpenAf
	ProtocolAfContext	Pointer to the pIntF
	NdisAfHandle		Ndis Handle to refer to this Af

Return Value:


--*/
{
	PINTF			pIntF = (PINTF)ProtocolAfContext;
	PCO_SAP			Sap;
	NDIS_HANDLE		OldAfHandle;
	KIRQL			OldIrql;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		if (pIntF->NdisAfHandle != NULL)
		{
			DbgPrint("ATMARPS: OpenAfComp: IntF %p, NdisAfHandle %p is NOT NULL!\n",
				pIntF, pIntF->NdisAfHandle);
			DbgBreakPoint();
			DbgBreakPoint();
			DbgBreakPoint();
		}

		OldAfHandle = pIntF->NdisAfHandle;
		pIntF->NdisAfHandle = NdisAfHandle;
	
		if (ArpSReferenceIntF(pIntF))
		{
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			pIntF->Flags |= INTF_AF_OPENED;
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			//
			// Now register a SAP on this interface
			//
			ArpSRegisterSap(pIntF);
		}
		else
		{
			NDIS_STATUS	Sts;

			Sts = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCloseAfComplete(Status, pIntF);
			}
		}
	}
	else
	{
		//
		// Failed to open the Address family. Cleanup and exit
		//
		LOG_ERROR(Status);

		ArpSTryCloseAdapter(pIntF);

	}
}


VOID
ArpSRegisterSap(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Register the Sap for receiving incoming calls. De-register any existing saps (this can
	happen if an address change happens).

Arguments:


Return Value:


--*/
{
	NDIS_STATUS		Status;
	PATM_SAP		pAtmSap;
	PATM_ADDRESS	pAtmAddress;

	//
	// Kill previous sap if any and register a new one. Save this while we
	// register the new one. We kill this regardless of whether the new one
	// successfully registers or not - since the address has potentially changed
	//
	if (pIntF->NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(pIntF->NdisSapHandle);
		pIntF->NdisSapHandle = NULL;
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSDeregisterSapComplete(Status, pIntF);
		}
	}

	do
	{
		//
		// Allocate memory for registering the SAP, if doing it for the first time.
		//
		if (pIntF->Sap == NULL)
		{
			pIntF->Sap = (PCO_SAP)ALLOC_NP_MEM(sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS), POOL_TAG_SAP);
		}
	
		if (pIntF->Sap == NULL)
		{
			LOG_ERROR(Status);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		else
		{
			ZERO_MEM(pIntF->Sap, sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS));
			pAtmSap = (PATM_SAP)pIntF->Sap->Sap;
			pAtmAddress = (PATM_ADDRESS)(pAtmSap->Addresses);
					
			pIntF->Sap->SapType = SAP_TYPE_NSAP;
			pIntF->Sap->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
	
			//
			//  Fill in the ATM SAP with default values
			//
			COPY_MEM(&pAtmSap->Blli, &ArpSDefaultBlli, sizeof(ATM_BLLI_IE));
			COPY_MEM(&pAtmSap->Bhli, &ArpSDefaultBhli, sizeof(ATM_BHLI_IE));

			//
			//  ATM Address to "listen" on: Wild card everything except the SEL.
			//
			pAtmSap->NumberOfAddresses = 1;
			pAtmAddress->AddressType = SAP_FIELD_ANY_AESA_REST;
			pAtmAddress->NumberOfDigits = 20;
			pAtmAddress->Address[20-1] = pIntF->SelByte;
	
			Status = NdisClRegisterSap(pIntF->NdisAfHandle,
									   pIntF,
									   pIntF->Sap,
									   &pIntF->NdisSapHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSRegisterSapComplete(Status,
										pIntF,
										pIntF->Sap,
										pIntF->NdisSapHandle);
			}
		}
	} while (FALSE);

	if ((Status != NDIS_STATUS_SUCCESS) && (Status != NDIS_STATUS_PENDING))
	{
		Status = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAfComplete(Status, pIntF);
		}
	}
}


VOID
ArpSRegisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	PCO_SAP					Sap,
	IN	NDIS_HANDLE				NdisSapHandle
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolSapContext;

	ASSERT (Sap == pIntF->Sap);
	if (Status != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_WARN,
			("RegisterSapComplete failed (%x): Intf %x, Name %Z\n",
				Status, pIntF, &pIntF->InterfaceName));

		LOG_ERROR(Status);
		FREE_MEM(pIntF->Sap);
		pIntF->Sap = NULL;

		ArpSDereferenceIntF(pIntF);
	}
	else
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		pIntF->Flags |= INTF_SAP_REGISTERED;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		pIntF->NdisSapHandle = NdisSapHandle;
	}
}


VOID
ArpSDeregisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolSapContext;

	DBGPRINT(DBG_LEVEL_INFO,
			("DeregisterSapComplete: Intf %Z\n", &pIntF->InterfaceName));

	pIntF->NdisSapHandle = NULL;
	
	if (pIntF->Sap)
	{
		FREE_MEM(pIntF->Sap);
		pIntF->Sap = NULL;
	}

	//
	// Nothing to do here except deref the IntF block here.
	//
	ArpSDereferenceIntF(pIntF);
}


VOID
ArpSCloseAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolAfContext;
	KIRQL	OldIrql;

	DBGPRINT(DBG_LEVEL_NOTICE,
			("CloseAfComplete: pIntF %x, Flags %x, Ref %x, Intf %Z\n",
				 pIntF, pIntF->Flags, pIntF->RefCount, &pIntF->InterfaceName));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	pIntF->NdisAfHandle = NULL;
	pIntF->Flags &= ~INTF_STOPPING;
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	//
	// Nothing much to do except dereference the pIntF
	//
	ArpSDereferenceIntF(pIntF);
}


VOID
ArpSCloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolBindingContext;
	KIRQL	OldIrql;
	
	DBGPRINT(DBG_LEVEL_INFO,
			("CloseAdapterComplete: Intf %Z\n", &pIntF->InterfaceName));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Set the interface to closing
	//
	ASSERT ((pIntF->Flags & INTF_CLOSING) == 0);
	pIntF->Flags |= INTF_CLOSING;
	pIntF->NdisBindingHandle = NULL;

	//
	// Stop the timer thread
	//
	KeSetEvent(&pIntF->TimerThreadEvent, IO_NETWORK_INCREMENT, FALSE);
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	//
	// Finally dereference it
	//
	ArpSDereferenceIntF(pIntF);
}


NDIS_STATUS
ArpSCreateVc(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisVcHandle,
	OUT	PNDIS_HANDLE			ProtocolVcContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF		pIntF = (PINTF)ProtocolAfContext;
	PARP_VC		Vc;
	KIRQL		OldIrql;
	NDIS_STATUS	Status;

	DBGPRINT(DBG_LEVEL_INFO,
			("CreateVc: NdisVcHandle %lx, Intf %Z\n", NdisVcHandle, &pIntF->InterfaceName));
	//
	// Allocate a Vc, initialize it and link it into the IntF
	//
	*ProtocolVcContext = NULL;		// Assume failure
    Status = NDIS_STATUS_RESOURCES;

	Vc = (PARP_VC)ALLOC_NP_MEM(sizeof(ARP_VC), POOL_TAG_VC);
	if (Vc != NULL)
	{
		ZERO_MEM(Vc, sizeof(ARP_VC));
		Vc->NdisVcHandle = NdisVcHandle;
		Vc->IntF = pIntF;
		Vc->RefCount = 1;	// Dereferenced when DeleteVc is called.
		Vc->VcType = VC_TYPE_INCOMING;
		if (ArpSReferenceIntF(pIntF))
		{
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

			if (++(pIntF->ArpStats.CurrentClientVCs) > pIntF->ArpStats.MaxClientVCs)
			{
					pIntF->ArpStats.MaxClientVCs = pIntF->ArpStats.CurrentClientVCs;
			}
			
			InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);
			Vc->VcId = pIntF->LastVcId;
			pIntF->LastVcId ++;
			if (pIntF->LastVcId == -1)
			{
				pIntF->LastVcId = 1;
			}

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			*ProtocolVcContext = Vc;
			DBGPRINT(DBG_LEVEL_INFO,
					("CreateVc: Created Vc %lx, Id %lx\n", Vc, Vc->VcId));
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			FREE_MEM(Vc);	
			Status = NDIS_STATUS_CLOSING;
		}
	}

	return Status;
}


NDIS_STATUS
ArpSDeleteVc(
	IN	NDIS_HANDLE				ProtocolVcContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PARP_VC		Vc = (PARP_VC)ProtocolVcContext;

	DBGPRINT(DBG_LEVEL_INFO,
			("DeleteVc: For Vc %lx, Id %lx\n", Vc, Vc->VcId));

	Vc->IntF->ArpStats.CurrentClientVCs--;
	Vc->NdisVcHandle = NULL;
	ArpSDereferenceVc(Vc, FALSE, FALSE);

	return NDIS_STATUS_SUCCESS;
}


VOID
ArpSCoSendComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Completion routine for the previously pended send. Just return the packet to the pool of free packets.


Arguments:

	Status				Status of Completion
	ProtocolVcContext	Pointer to the Vc
	Packet				The packet in question

Return Value:


--*/
{
	PARP_VC			Vc = (PARP_VC)ProtocolVcContext;
	PPROTOCOL_RESD	Resd;

	Resd = RESD_FROM_PKT(Packet);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSCoSendComplete: Packet %lx, Vc %lx, ResdVc %lx, Id %lx\n",
				Packet, Vc, Resd->Vc, Vc->VcId));

	if (Status != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
				("ArpSCoSendComplete: Failed for Vc = %lx, status = %lx\n", Vc, Status));
	}

	if ((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)
	{
		if (Packet->Private.Head == NULL)
		{
		    DbgPrint("ATMARPS: sendcomplete: pkt %p head is NULL!\n",
		        Packet->Private.Head);
		    DbgBreakPoint();
		    DbgBreakPoint();
		}
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);

		ArpSDereferenceVc(Resd->Vc, FALSE, TRUE);
	}
	else
	{
		MarsFreePacket(Packet);
	}

}


NDIS_STATUS
ArpSIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS	CallParameters
	)
/*++

Routine Description:

	Handler for incoming call. We accept the call unless we are shutting down and then
	do the actual processing when the call processing completes.

Arguments:

	ProtocolSapContext		Pointer to the IntF
	ProtocolVcContext		Pointer to the Vc
    CallParameters			Call Parameters

Return Value:


--*/
{
	PINTF						pIntF = (PINTF)ProtocolSapContext;
	PARP_VC						Vc = (PARP_VC)ProtocolVcContext;
    Q2931_CALLMGR_PARAMETERS UNALIGNED *	CallMgrSpecific;
	KIRQL						OldIrql;
	NDIS_STATUS					Status = NDIS_STATUS_SUCCESS;

	ASSERT (Vc->IntF == pIntF);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSIncomingCall: On Vc %lx, Id %lx\n", Vc, Vc->VcId));
	//
	// Mark the Vc to indicate the call processing is underway
	//
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	pIntF->ArpStats.TotalIncomingCalls++;

	ASSERT ((Vc->Flags & (ARPVC_CALLPROCESSING | ARPVC_ACTIVE | ARPVC_CALLPROCESSING)) == 0);
	Vc->Flags |= ARPVC_CALLPROCESSING;

	//
	// Get the remote atm address from the call-parameters
	//
	CallMgrSpecific = (PQ2931_CALLMGR_PARAMETERS)&CallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0];
    Vc->HwAddr.Address = CallMgrSpecific->CallingParty;

	//
	// Get the max size of packets we can send on this VC, from the
	// AAL5 parameters. Limit it to the size our miniport can support.
	//
	Vc->MaxSendSize = pIntF->MaxPacketSize;	// default

	if (CallMgrSpecific->InfoElementCount > 0)
	{
		Q2931_IE UNALIGNED *			pIe;
		AAL5_PARAMETERS UNALIGNED *		pAal5;
		ULONG							IeCount;

		pIe = (PQ2931_IE)CallMgrSpecific->InfoElements;
		for (IeCount = CallMgrSpecific->InfoElementCount;
			 IeCount != 0;
			 IeCount--)
		{
			if (pIe->IEType == IE_AALParameters)
			{
				pAal5 = &(((PAAL_PARAMETERS_IE)pIe->IE)->AALSpecificParameters.AAL5Parameters);
				//
				// Make sure we don't send more than what the caller can handle.
				//
				if (pAal5->ForwardMaxCPCSSDUSize < Vc->MaxSendSize)
				{
					Vc->MaxSendSize = pAal5->ForwardMaxCPCSSDUSize;
				}

				//
				// Make sure this greater than the min allowed.
				//
				if (pAal5->ForwardMaxCPCSSDUSize < ARPS_MIN_MAX_PKT_SIZE)
				{
					DBGPRINT(DBG_LEVEL_WARN,
					("ArpSIncomingCall: Vc %lx max pkt size too small(%lu)\n",
 						Vc, Vc->MaxSendSize));
					Status = NDIS_STATUS_RESOURCES;
				}

				//
				// Make sure the caller doesn't send more than what our
				// miniport can handle.
				//
				if (pAal5->BackwardMaxCPCSSDUSize > pIntF->MaxPacketSize)
				{
					pAal5->BackwardMaxCPCSSDUSize = pIntF->MaxPacketSize;
				}
				break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return Status;
}

VOID
ArpSCallConnected(
	IN	NDIS_HANDLE				ProtocolVcContext
	)
/*++

Routine Description:

	Last hand-shake in the incoming call path. Move the Vc to the list of active calls.

Arguments:

	ProtocolVcContext	Pointer to VC

Return Value:

	None.

--*/
{
	PARP_VC		Vc = (PARP_VC)ProtocolVcContext;
	PINTF		pIntF;
	KIRQL		OldIrql;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSCallConnected: On Vc %lx, Id %lx\n", Vc, Vc->VcId));


	pIntF = Vc->IntF;
	pIntF->ArpStats.TotalActiveVCs++;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ASSERT((Vc->Flags & ARPVC_ACTIVE) == 0);
	ASSERT(Vc->Flags & ARPVC_CALLPROCESSING);

	Vc->Flags |= ARPVC_ACTIVE;
	Vc->Flags &= ~ARPVC_CALLPROCESSING;

	RemoveEntryList(&Vc->List);
	InsertHeadList(&pIntF->ActiveVcHead, &Vc->List);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}


VOID
ArpSMakeCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:

	Handle completion of an earlier call to NdisClMakeCall. The only
	outgoing call is for ClusterControlVc. If the status indicates
	success, AddParty's are initiated for all pending Cluster members.
	Otherwise, this cluster member is deleted, and if there are any
	other cluster members in the list, we initiate a MakeCall with
	one of them.

Arguments:

	Status				Result of NdisClMakeCall
	ProtocolVcContext	Pointer to ClusterControlVc
	NdisPartyHandle		If successful, the handle for this party
	CallParameters		Pointer to Call parameters

Return Value:

	None.

--*/
{
	KIRQL				OldIrql;
	PINTF				pIntF;
	PMARS_VC			pVc;
	PCLUSTER_MEMBER		pMember;
	PCLUSTER_MEMBER		pNextMember;
	NDIS_HANDLE         NdisVcHandle;

	pVc = (PMARS_VC)ProtocolVcContext;

	if (pVc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSMakeRegAddrCallComplete(
				Status,
				(PREG_ADDR_CTXT) ProtocolVcContext
				);
		return;						// ******  EARLY RETURN ****************
	}
	
	pIntF = pVc->pIntF;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MakeCallComplete: Status %x, pVc %x, VC ConnState %x\n",
				Status, pVc, MARS_GET_VC_CONN_STATE(pVc)));

	FREE_MEM(CallParameters);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Get the Cluster member we were trying to connect to.
	// 
	for (pMember = pIntF->ClusterMembers;
		 pMember != NULL_PCLUSTER_MEMBER;
		 pMember = (PCLUSTER_MEMBER)pMember->Next)
	{
		if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_SETUP_IN_PROGRESS)
		{
			break;
		}
	}
	ASSERT(pMember != NULL_PCLUSTER_MEMBER);

	pIntF->CCAddingParties--;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		ASSERT(NdisPartyHandle != NULL);
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_ACTIVE);
		pMember->NdisPartyHandle = NdisPartyHandle;

		pIntF->CCActiveParties++;

		if (pMember->Flags & CM_INVALID)
		{
			//
			// Deleting was deferred because the connection was being
			// setup. Now that it's up, strictly speaking we should
			// try to delete it again, BUT we don't because we
			// may also need to add other members now, and we can't really
			// drop the call itself while we're adding other parties!
			//
			MARSDBGPRINT(DBG_LEVEL_WARN,
					("pMember 0x%p is INVALID, but NOT dropping CCVC call.\n",
					 pMember));

			// do nothing...
		}

		if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_SETUP_IN_PROGRESS)
		{
			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_ACTIVE);

			//
			// Add all pending cluster members as parties
			//
			for (pMember = pIntF->ClusterMembers;
				 pMember != NULL_PCLUSTER_MEMBER;
				 pMember = pNextMember)
			{
				pNextMember = (PCLUSTER_MEMBER)pMember->Next;

				if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_IDLE)
				{
					RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

					MarsAddMemberToClusterControlVc(pIntF, pMember);

					ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

					if (!MarsIsValidClusterMember(pIntF, pNextMember))
					{
						//
						// Oops, the next member has gone away in the
						// mean time. In this unlikely case, we simply
						// quit processing the list early.
						//
						break;
					}
				}
			}

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			//
			// Send off any queued packets, if we can.
			//
			MarsSendOnClusterControlVc(pIntF, NULL);
		}
		else
		{
			BOOLEAN fLocked;
			//
			// We are closing down.
			//
			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_ACTIVE);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			fLocked = MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
			ASSERT(!fLocked);
		}
	}
	else
	{
		MARSDBGPRINT(DBG_LEVEL_WARN,
					("MakeCall error %x, pMember %x to addr:", Status, pMember));
		MARSDUMPATMADDR(DBG_LEVEL_WARN, &pMember->HwAddr.Address, "");
#if DBG
		if (Status == NDIS_STATUS_CALL_ACTIVE)
		{
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("ATMARPS: MakeCallComp: Intf %p, VC %p, pMember %p, call active!\n",
				pIntF, pVc, pMember));
			DbgBreakPoint();
			DbgBreakPoint();
		}
#endif // DBG

		//
		// Connection failed. Delete this member from our Cluster member list.
		//
		pIntF->MarsStats.FailedCCVCAddParties++;
		MarsDeleteClusterMember(pIntF, pMember);

		MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_IDLE);

		//
		// See if we have other Cluster members. If so, pick up one
		// of them and re-initiate the ClusterControlVc.
		//
		for (pMember = pIntF->ClusterMembers;
 			 pMember != NULL_PCLUSTER_MEMBER;
 			 pMember = (PCLUSTER_MEMBER)pMember->Next)
		{
			if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_IDLE)
			{
				break;
			}
		}

		if (pMember == NULL_PCLUSTER_MEMBER)
		{
		    //
		    //  No other cluster members, so we'll tear down the CC VC.
		    //
			NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
    		DBGPRINT(DBG_LEVEL_ERROR,
			    ("ATMARPS: pIntF %x, deleting CC VC, VcHandle %x\n", pIntF, NdisVcHandle));
			FREE_MEM(pIntF->ClusterControlVc);
			pIntF->ClusterControlVc = NULL;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		if (pMember != NULL_PCLUSTER_MEMBER)
		{
			MarsAddMemberToClusterControlVc(pIntF, pMember);
		}
		else
		{
			Status = NdisCoDeleteVc(NdisVcHandle);
			ASSERT(Status == NDIS_STATUS_SUCCESS);
			MarsFreePacketsQueuedForClusterControlVc(pIntF);
		}
	}

}


VOID
ArpSIncomingCloseCall(
	IN	NDIS_STATUS				CloseStatus,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	)
/*++

Routine Description:

	Indication of an incoming close call from the network. If this
	is not on ClusterControlVc, then we mark the VC as inactive, and
	move it to the Inactive VC list. If this is on ClusterControlVc,
	there must be only one party on the PMP connection. We update
	that member's state.

	In any case, we call NdisClCloseCall to complete the handshake.

Arguments:

	CloseStatus			Status of Close
	ProtocolVcContext	Pointer to VC (ARP_VC or MARS_VC)
	CloseData			Optional Close data (IGNORED)
	Size				Size of Optional Close Data (OPTIONAL)

Return Value:

	None

--*/
{
	PARP_VC			Vc = (PARP_VC)ProtocolVcContext;
	PMARS_VC		pMarsVc;
	PINTF			pIntF;
	NDIS_STATUS		Status;

	if (Vc->VcType == VC_TYPE_INCOMING)
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSIncomingCloseCall: On Vc %lx, Id %lx\n",
				 ProtocolVcContext, Vc->VcId));

		ArpSInitiateCloseCall(Vc);
	}
	else if (Vc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSIncomingRegAddrCloseCall(
			CloseStatus, 
			(PREG_ADDR_CTXT) ProtocolVcContext
			);
	}
	else
	{
		ASSERT(Vc->VcType == VC_TYPE_MARS_CC);
		pMarsVc = (PMARS_VC)ProtocolVcContext;
		pIntF = pMarsVc->pIntF;
#if DBG
		if (pIntF->CCAddingParties != 0)
		{
			PCLUSTER_MEMBER	pMember;

			MARSDBGPRINT(DBG_LEVEL_WARN,
			("ATMARPS: pIntF %p, InClose on CCVC %p/%x/%p with %d adding parties\n",
				pIntF, pMarsVc, pMarsVc->Flags, pMarsVc->NdisVcHandle,
				pIntF->CCAddingParties));
			for (pMember = pIntF->ClusterMembers; pMember != NULL; pMember = pMember->Next)
			{
				MARSDBGPRINT(DBG_LEVEL_WARN,
				("ATMARPS: pIntF %p, InClose, pMember %p/%x\n",
					pIntF, pMember, pMember->Flags));
			}
		}
#endif // DBG

		MARS_SET_VC_CONN_STATE(pMarsVc, MVC_CONN_CLOSE_RECEIVED);
		{
			PPROTOCOL_RESD		Resd;

			Resd = ALLOC_NP_MEM(sizeof(PROTOCOL_RESD), POOL_TAG_MARS);
			if (Resd != NULL)
			{
				Resd->Flags = RESD_FLAG_KILL_CCVC;
				Resd->Vc = (PARP_VC)pIntF;
				KeInsertQueue(&MarsReqQueue, &Resd->ReqList);
			}
			else
			{
				MarsAbortAllMembers(pIntF);
			}
		}
	}

}


VOID
ArpSCloseCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				ProtocolPartyContext OPTIONAL
	)
/*++

Routine Description:

	This is called to complete our call to NdisClCloseCall. If the VC
	is other than ClusterControlVc, we simply update its state.

	If this is on ClusterControlVc, we delete the last member.

Arguments:

	CloseStatus				Status of Close
	Status					Status of NdisClCloseCall
	ProtocolVcContext		Pointer to our VC structure
	ProtocolPartyContext	If the VC is ClusterControlVc, this is a pointer
							to the Cluster Member that was disconnected.

Return Value:

	None

--*/
{
	PARP_VC				Vc = (PARP_VC)ProtocolVcContext;
	PMARS_VC			pMarsVc;
	PCLUSTER_MEMBER		pMember;
	PINTF				pIntF;
	KIRQL				OldIrql;
	BOOLEAN				bStopping;
	NDIS_HANDLE			NdisVcHandle;

	ASSERT(Status == NDIS_STATUS_SUCCESS);
	if (Status != NDIS_STATUS_SUCCESS)
	{
	    DbgPrint("ATMARPS: CloseCall failed %x on VC %p\n", Status, Vc);
	    DbgBreakPoint();
	    DbgBreakPoint();
	}

	if (Vc->VcType == VC_TYPE_INCOMING)
	{
		pIntF = Vc->IntF;

		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSCloseCallComplete: On Vc %lx\n", Vc));

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		ASSERT ((Vc->Flags & ARPVC_CLOSING) != 0);
		Vc->Flags &= ~ARPVC_CLOSING;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
	else if (Vc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSCloseRegAddrCallComplete(
				Status,
				(PREG_ADDR_CTXT) ProtocolVcContext
				);
	}
	else
	{
		//
		//  Must be ClusterControlVc
		//
		pMarsVc = (PMARS_VC)ProtocolVcContext;
		pIntF = pMarsVc->pIntF;

		ASSERT(pMarsVc == pIntF->ClusterControlVc);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		MARS_SET_VC_CONN_STATE(pMarsVc, MVC_CONN_IDLE);

		pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);

		ASSERT(pIntF->CCAddingParties == 0);

		pIntF->CCActiveParties = pIntF->CCDroppingParties = pIntF->CCAddingParties = 0;

		bStopping = ((pIntF->Flags & INTF_STOPPING) != 0);

		MarsDeleteClusterMember(pIntF, pMember);

		ARPS_ASSERT(pIntF->ClusterControlVc);

		NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
		FREE_MEM(pIntF->ClusterControlVc);
		pIntF->ClusterControlVc = NULL;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		if (NdisVcHandle != NULL)
		{
			NDIS_STATUS		DeleteStatus;

			DeleteStatus = NdisCoDeleteVc(NdisVcHandle);
			if (DeleteStatus != NDIS_STATUS_SUCCESS)
			{
				DbgPrint("ATMARPS: CloseCallComp: DeleteVc %p failed %x\n",
					NdisVcHandle, DeleteStatus);
				DbgBreakPoint();
			}
		}
	}

}


VOID
ArpSAddPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	NDIS_HANDLE				NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:

	Completion of NdisClAddParty to add a new party to ClusterControlVc.
	If successful, update the member's state. Otherwise, delete it.

Arguments:

	Status					Status of AddParty
	ProtocolPartyContext	Pointer to Cluster Member being added
	NdisPartyHandle			Valid if AddParty successful
	CallParameters			Pointer to AddParty call parameters

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER		pMember;
	PINTF				pIntF;
	KIRQL				OldIrql;

	FREE_MEM(CallParameters);

	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("AddPartyComplete: Status %x, pMember %x, NdisPartyHandle %x\n",
					Status, pMember, NdisPartyHandle));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	ASSERT(pMember->pGroupList == NULL_PGROUP_MEMBER);

	pIntF->CCAddingParties--;	// AddPartyComplete

	if (Status == NDIS_STATUS_SUCCESS)
	{
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_ACTIVE);
		pMember->NdisPartyHandle = NdisPartyHandle;
		pIntF->CCActiveParties++;	// AddPartyComplete

		if (pMember->Flags & CM_INVALID)
		{
			//
			// Deleting was deferred because the connection was being
			// setup. Now that it's up, we will try to delete it again
			// (should have better luck this time!).
			//
			BOOLEAN fLocked;

			fLocked = MarsDelMemberFromClusterControlVc(
							pIntF,
							pIntF->ClusterMembers,
							TRUE,
							OldIrql
							);
			if(!fLocked)
			{
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			}
			
		}
	}
	else
	{
		MARSDBGPRINT(DBG_LEVEL_WARN,
				("AddParty Failed: pMember %x, Status %x, Addr: ",
					pMember, Status));
		MARSDUMPATMADDR(DBG_LEVEL_WARN, &pMember->HwAddr.Address, "");
		pIntF->MarsStats.FailedCCVCAddParties++;

		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);
		MarsDeleteClusterMember(pIntF, pMember);
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	//
	// Send any queued packets, if appropriate.
	//
	MarsSendOnClusterControlVc(pIntF, NULL);
}


VOID
ArpSDropPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext
	)
/*++

Routine Description:

	This is called to signify completion of a previous NdisClDropParty,
	to drop a cluster member off the ClusterControlVc. Delete the member.

Arguments:

	Status					Status of DropParty
	ProtocolPartyContext	Pointer to Cluster Member being dropped

Return Value:

	None.

--*/
{
	KIRQL					OldIrql;
	PCLUSTER_MEMBER			pMember;
	PINTF					pIntF;
	PMARS_VC				pVc;
	BOOLEAN					IsVcClosing;

	ASSERT(Status == NDIS_STATUS_SUCCESS);
	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;
	ASSERT(pIntF->ClusterControlVc != NULL_PMARS_VC);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);
	pIntF->CCDroppingParties--;

	//
	// Check if we are closing ClusterControlVc, and just one party is left.
	//
	pVc = pIntF->ClusterControlVc;
	IsVcClosing = ((MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_NEED_CLOSE) &&
				   (pIntF->CCActiveParties == 1) &&
				   (pIntF->CCAddingParties + pIntF->CCDroppingParties == 0));

	MarsDeleteClusterMember(pIntF, pMember);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (IsVcClosing)
	{
		BOOLEAN fLocked;
		fLocked = MarsDelMemberFromClusterControlVc(
						pIntF,
						pIntF->ClusterMembers,
						FALSE,
						0
						);
		ASSERT(!fLocked);
	}
}


VOID
ArpSIncomingDropParty(
	IN	NDIS_STATUS				DropStatus,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	)
/*++

Routine Description:

	Indication that a Cluster Member has dropped off the ClusterControlVc.
	We complete this handshake by calling NdisClDropParty.

Arguments:

	DropStatus				Status
	ProtocolPartyContext	Pointer to Cluster Member
	CloseData				Optional Close data (IGNORED)
	Size					Size of Optional Close Data (OPTIONAL)

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER			pMember;
	PINTF					pIntF;
	KIRQL					OldIrql;

	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;
	ASSERT(MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_ACTIVE);

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("IncomingDropParty: pIntF %x, pMember %x, Addr: ", pIntF, pMember));
	MARSDUMPATMADDR(DBG_LEVEL_NOTICE, &pMember->HwAddr.Address, "");

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Remove its membership from all groups.
	// AND disable further groups from being added.
	//
	MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	{
		BOOLEAN fLocked;
		fLocked = MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
		ASSERT(!fLocked);
	}
}


NDIS_STATUS
ArpSCoRequest(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST		NdisRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF		pIntF = (PINTF)ProtocolAfContext;
	KIRQL		OldIrql;
	BOOLEAN		ValidAf;

	DBGPRINT(DBG_LEVEL_INFO,
			("CallMgrRequest: Request %lx, Type %d, OID %lx\n",
			 NdisRequest, NdisRequest->RequestType, NdisRequest->DATA.SET_INFORMATION.Oid));

	switch(NdisRequest->DATA.SET_INFORMATION.Oid)
	{
	  case OID_CO_ADDRESS_CHANGE:
		ValidAf = FALSE;
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		pIntF->Flags |= INTF_ADDRESS_VALID;
		ValidAf = ((pIntF->Flags & INTF_AF_OPENED) != 0);
		pIntF->NumAddressesRegd = 0;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	
		if (ValidAf)
		{
			ArpSQueryAndSetAddresses(pIntF);
		}
		break;

	 case OID_CO_AF_CLOSE:
#if DBG
		DbgPrint("atmarps: OID_CO_AF_CLOSE\n");
#endif
		if (ArpSReferenceIntF(pIntF))
		{
			//
			// ArpSStopInterface dereferences the pIntF
			//
			(VOID)ArpSStopInterface(pIntF, FALSE);
		}
	 	break;

	 default:
	 	break;
	}

	return NDIS_STATUS_SUCCESS;
}


VOID
ArpSCoRequestComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST			NdisRequest
	)
/*++

Routine Description:

	Completion routine for the NdisCoRequest api.

Arguments:

	Status					Status of completion
	ProtocolAfContext		Pointer to the IntF structure
	ProtocolVcContext		Pointer to the VC structure
	ProtocolPartyContext	Not used by us since we do not make calls
	NdisRequest				Pointer to the request structure

Return Value:

	None

--*/
{
	PINTF			pIntF = (PINTF)ProtocolAfContext;
	BOOLEAN			FreeReq = TRUE;
	KIRQL			OldIrql;
	PKEVENT 		pEvent = NULL;

	DBGPRINT(DBG_LEVEL_INFO,
			 ("CoRequestComplete: Request %lx, Type %d, OID %lx\n",
			 NdisRequest, NdisRequest->RequestType, NdisRequest->DATA.QUERY_INFORMATION.Oid));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	switch(NdisRequest->DATA.SET_INFORMATION.Oid)
	{
	  case OID_CO_ADD_ADDRESS:
		if (Status == NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Registered address # %d\n", pIntF->NumAddressesRegd+1));
		
			if (pIntF->NumAddressesRegd < pIntF->NumAllocedRegdAddresses)
			{
				PCO_ADDRESS	pCoAddr;
				PATM_ADDRESS pAddress;

				// Copy the registered address from the ndis request into the
				// array of registered addresses.
				//
				pCoAddr = NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
				pAddress =  (PATM_ADDRESS)(pCoAddr->Address);
				pIntF->RegAddresses[pIntF->NumAddressesRegd] = *pAddress;
				pIntF->NumAddressesRegd ++;
			}
			else
			{
				//
				// 12/22/1998 JosephJ
				// We could potentially get here if the total number of outstanding add address requests
				// is greater then NumAllocedRegAddresses. One way this could happen is if ArpSQueryAndSetAddresses
				// is called multiple times in quick succession. Note that ArpSQueryAndSetAddresses is called from
				// two places: ArpSCoRequest and ArpSReqdAdaprConfiguration.
				//
				// Previously, we would increment NumAddressRegd in this condition. Now we simply ignore this.
				//
			}
		}
		else
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: CO_ADD_ADDRESS Failed %lx\n", Status));
		}

		//
		// Try registering the next address. ArpSValidateOneRegAddress will
		// unlink and free pIntF->pRegAddrCtxt if there are no more addresses
		// to be registered.
		//
		if (pIntF->pRegAddrCtxt != NULL)
		{
			ArpSValidateOneRegdAddress(
					pIntF,
					OldIrql
					);
			//
			// Lock released by above call.
			//
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
		else
		{
			ASSERT(FALSE); // can't get here.
		}
		// We don't want to free this ndis request here, because it's actually
		// part of pIntF->pRegAddrCtxt.
		//
		FreeReq = FALSE;
		break;

	  case OID_CO_GET_ADDRESSES:
	  	//
	  	// (On success) We just got our configured address value.
	  	// We save this value AND THEN move on the next stage of initialization --
	  	// validating and setting the "registered" addresses -- these are the
	  	// addresses we read from the registry. See 05/14/1999 notes.txt entry
		// for details.
	  	//
		if (Status == NDIS_STATUS_SUCCESS)
		{
			PCO_ADDRESS_LIST	pCoAddrList;
			UINT				i;

			pCoAddrList = (PCO_ADDRESS_LIST)(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
			ASSERT(pCoAddrList->NumberOfAddresses == 1);

			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Configured address, %d/%d Size %d\n",
					 pCoAddrList->NumberOfAddresses,
					 pCoAddrList->NumberOfAddressesAvailable,
					 pCoAddrList->AddressList.AddressSize));

			ASSERT(pCoAddrList->AddressList.AddressSize == (sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS)));
			COPY_MEM(&pIntF->ConfiguredAddress,
					 pCoAddrList->AddressList.Address,
					 sizeof(ATM_ADDRESS));

			DBGPRINT(DBG_LEVEL_INFO,
					("CoRequestComplete: Configured Address (%s): ",
					(pIntF->ConfiguredAddress.AddressType == ATM_E164) ? "E164" : "NSAP"));
			for (i = 0; i < pIntF->ConfiguredAddress.NumberOfDigits; i++)
			{
				DBGPRINT(DBG_LEVEL_INFO + DBG_NO_HDR,
						("%02x ", pIntF->ConfiguredAddress.Address[i]));
			}
			DBGPRINT(DBG_LEVEL_INFO | DBG_NO_HDR, ("\n"));

		}
		else
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: CO_GET_ADDRESS Failed %lx\n", Status));
		}

		//
		// Validate  and set the registered addresses.
		//
		ArpSValidateAndSetRegdAddresses(pIntF, OldIrql);

		// IntF lock released by the above.
		//
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		break;

	  case OID_CO_DELETE_ADDRESS:
	  		DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Deleted address. Status=%x\n", Status));
		if (pIntF->DelAddressesEvent != NULL)
		{
			// Someone's waiting for all the addresses to be deleted...
			//

			ASSERT(pIntF->NumPendingDelAddresses >  0);
			if (--(pIntF->NumPendingDelAddresses) == 0)
			{
				// Deletion of all addresses is over, signal the event.
				//
				pEvent = pIntF->DelAddressesEvent;
				pIntF->DelAddressesEvent = NULL;
			}
		}
	  	break;
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (pEvent != NULL)
	{
		KeSetEvent(pEvent, IO_NETWORK_INCREMENT, FALSE);
	}

	if (FreeReq)
	{
		FREE_MEM(NdisRequest);
	}
}


VOID
ArpSIncomingCallQoSChange(
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("QoSChange: Ignored\n"));
}



VOID
ArpSQueryAdapter(
	IN	PINTF					pIntF
)
/*++

Routine Description:

	Query the miniport we are bound to for the following info:
	1. Line rate
	2. Max packet size

	These will overwrite the defaults we set up in ArpSCreateIntF.

Arguments:

	pIntF		Pointer to Interface

Return Value:

	None

--*/
{

	ArpSSendNdisRequest(pIntF,
						OID_GEN_CO_LINK_SPEED,
						(PVOID)&(pIntF->LinkSpeed),
						sizeof(NDIS_CO_LINK_SPEED));

	ArpSSendNdisRequest(pIntF,
						OID_ATM_MAX_AAL5_PACKET_SIZE,
						(PVOID)&(pIntF->MaxPacketSize),
						sizeof(ULONG));
}




VOID
ArpSSendNdisRequest(
	IN	PINTF					pIntF,
	IN	NDIS_OID				Oid,
	IN	PVOID					pBuffer,
	IN	ULONG					BufferLength
)
/*++

Routine Description:

	NDIS Request generator, for sending NDIS requests to the miniport.

Arguments:

	pIntF			Ptr to Interface
	Oid				The parameter being queried
	pBuffer			Points to parameter
	BufferLength	Length of above

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	PNDIS_REQUEST			pRequest;

	pRequest = (PNDIS_REQUEST)ALLOC_NP_MEM(sizeof(NDIS_REQUEST), POOL_TAG_INTF);
	if (pRequest == (PNDIS_REQUEST)NULL)
	{
		return;
	}

	ZERO_MEM(pRequest, sizeof(NDIS_REQUEST));

	//
	// Query for the line rate.
	//
	pRequest->DATA.QUERY_INFORMATION.Oid = Oid;
	pRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
	pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
	pRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
	pRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;

	NdisRequest(&Status,
				pIntF->NdisBindingHandle,
				pRequest);

	if (Status != NDIS_STATUS_PENDING)
	{
		ArpSRequestComplete(
				(NDIS_HANDLE)pIntF,
				pRequest,
				Status);
	}
}




VOID
ArpSRequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			pRequest,
	IN	NDIS_STATUS				Status
)
/*++

Routine Description:

	Completion of our call to NdisRequest(). Do some follow-up.

Arguments:

	ProtocolBindingContext		Pointer to IntF
	pRequest					The request that just completed
	Status						Status of NdisRequest()

Return Value:

	None

--*/
{
	PINTF			pIntF;

	pIntF = (PINTF)ProtocolBindingContext;

	switch (pRequest->DATA.QUERY_INFORMATION.Oid)
	{
		case OID_ATM_MAX_AAL5_PACKET_SIZE:
			if (pIntF->MaxPacketSize < pIntF->CCFlowSpec.SendMaxSize)
			{
				pIntF->CCFlowSpec.SendMaxSize =
				pIntF->CCFlowSpec.ReceiveMaxSize = pIntF->MaxPacketSize;
			}
			DBGPRINT(DBG_LEVEL_INFO,
					("Miniport Max AAL5 Packet Size: %d (decimal)\n",
						pIntF->MaxPacketSize));
			break;
		case OID_GEN_CO_LINK_SPEED:
			//
			// Convert to bytes/sec
			//
			pIntF->LinkSpeed.Outbound = (pIntF->LinkSpeed.Outbound * 100 / 8);
			pIntF->LinkSpeed.Inbound = (pIntF->LinkSpeed.Inbound * 100 / 8);
			if (pIntF->LinkSpeed.Outbound < pIntF->CCFlowSpec.SendBandwidth)
			{
				pIntF->CCFlowSpec.SendBandwidth = pIntF->LinkSpeed.Outbound;
			}
			if (pIntF->LinkSpeed.Inbound < pIntF->CCFlowSpec.ReceiveBandwidth)
			{
				pIntF->CCFlowSpec.ReceiveBandwidth = pIntF->LinkSpeed.Inbound;
			}
			DBGPRINT(DBG_LEVEL_INFO,
					("Miniport Link Speed (decimal, bytes/sec): In %d, Out %d\n",
					pIntF->LinkSpeed.Inbound, pIntF->LinkSpeed.Outbound));
			break;
		default:
			ASSERT(FALSE);
			break;
	}

	FREE_MEM(pRequest);
}




VOID
ArpSUnbindAdapter(
	OUT	PNDIS_STATUS			UnbindStatus,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF			pIntF = (PINTF)ProtocolBindingContext;

	DBGPRINT(DBG_LEVEL_WARN,
			("UnbindAdapter: Intf %x, Name %Z\n", pIntF, &pIntF->InterfaceName));

	if (ArpSReferenceIntF(pIntF))
	{
		//
		// ArpSStopInterface dereferences the pIntF
		//
		*UnbindStatus = ArpSStopInterface(pIntF, TRUE);
	}
}


NDIS_STATUS
ArpSStopInterface(
	IN	PINTF					pIntF,
	IN	BOOLEAN					bCloseAdapter
	)
//
// NOTE: ArpSStopInterface MAY be called concurrently multiple times.
//
{
	KEVENT			CleanupEvent;
	NDIS_STATUS		Status;
	KIRQL			OldIrql;
	BOOLEAN			bWaitForClose;

	DBGPRINT(DBG_LEVEL_NOTICE,
			("StopInterface: Intf %x, Flags %x, Name %Z, bClose %d\n",
				pIntF, pIntF->Flags, &pIntF->InterfaceName, bCloseAdapter));

	bWaitForClose = FALSE;
	if (bCloseAdapter)
	{

		//
		// Event to be set when the IntF cleanup is complete
		//
		if (pIntF->CleanupEvent == NULL)
		{
			KeInitializeEvent(&CleanupEvent, NotificationEvent, FALSE);
			pIntF->CleanupEvent = &CleanupEvent;
			bWaitForClose = TRUE;
		}
		else
		{
			ASSERT(FALSE);
		}
	}


	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// NOTE: we can't simply skip the shutdown steps if
	// INTF_STOPPING is already set, because we need to make sure all the steps
	// are complete before we call  NdisCloseAdapter.
	//

	pIntF->Flags |= INTF_STOPPING;

	//
	// Start off by de-registering the Sap
	//
	if (pIntF->Flags & INTF_SAP_REGISTERED)
	{
		pIntF->Flags &= ~INTF_SAP_REGISTERED;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		Status = NdisClDeregisterSap(pIntF->NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSDeregisterSapComplete(Status, pIntF);
		}
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	//
	// Walk the list of Active Vcs and close them down
	//

	while (!IsListEmpty(&pIntF->ActiveVcHead))
	{
		PARP_VC	Vc;

		Vc = CONTAINING_RECORD(pIntF->ActiveVcHead.Flink, ARP_VC, List);

		if ((Vc->Flags & ARPVC_CLOSING) == 0)
		{
			Vc->Flags |= ARPVC_CLOSING;
			Vc->Flags &= ~ARPVC_ACTIVE;
		
			//
			// The ArpEntry part of the Vc gets cleaned up seperately.
			//
			Vc->ArpEntry = NULL;
		
			ASSERT(Vc->HwAddr.SubAddress == NULL);
		
			RemoveEntryList(&Vc->List);
			InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);
		
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			Status = NdisClCloseCall(Vc->NdisVcHandle, NULL, NULL, 0);
		
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCloseCallComplete(Status, Vc, NULL);
			}
	
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	MarsStopInterface(pIntF);

	//
	// Deregister all registered addresses...
	//
	DeregisterAllAddresses(pIntF);

	//
	// Now close Address family
	//
	if (pIntF->Flags & INTF_AF_OPENED)
	{
		pIntF->Flags &= ~INTF_AF_OPENED;

		Status = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAfComplete(Status, pIntF);
		}
	}

	if (bCloseAdapter)
	{
		//
		// Now close the adapter.
		//
		ArpSTryCloseAdapter(pIntF);
	}

	//
	// Take away reference added by caller.
	//
	ArpSDereferenceIntF(pIntF);

	if (bWaitForClose)
	{
		//
		// Wait for the cleanup to complete, i.e. last reference on the Interface
		// to go away.
		//
		WAIT_FOR_OBJECT(Status, &CleanupEvent, NULL);
	}

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
ArpSPnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	)
{
	PINTF						pIntF;
	NDIS_STATUS					Status;
	PNET_DEVICE_POWER_STATE		pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

	pIntF = (PINTF)ProtocolBindingContext;

	do
	{
		switch (pNetPnPEvent->NetEvent)
		{
			case NetEventSetPower:
				switch (*pPowerState)
				{
					case NetDeviceStateD0:
						Status = NDIS_STATUS_SUCCESS;
						break;

					default:
						//
						// We can't suspend, so we ask NDIS to Unbind us by
						// returning this status:
						//
						Status = NDIS_STATUS_NOT_SUPPORTED;
						break;
				}
				break;

			case NetEventQueryPower:	// FALLTHRU
			case NetEventQueryRemoveDevice:	// FALLTHRU
			case NetEventCancelRemoveDevice:
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case NetEventReconfigure:
				if (pIntF)
				{
					Status = ArpSReadAdapterConfiguration(pIntF);
				}
				else
				{
					//
					// Global changes
					//
					Status = NDIS_STATUS_SUCCESS;
				}
				break;

			case NetEventBindList:
			default:
				Status = NDIS_STATUS_NOT_SUPPORTED;
				break;
		}

		break;
	}
	while (FALSE);

	return (Status);
}



VOID
ArpSStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("StatusIndication: Ignored\n"));
}


VOID
ArpSReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return;
}


VOID
ArpSStatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("StatusComplete: Ignored\n"));
}


VOID
ArpSCoStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("CoStatus: Ignored\n"));
}




VOID
ArpSInitiateCloseCall(
	IN	PARP_VC					Vc
	)
/*++

Routine Description:

	Start off an NDIS Call Closing sequence on the ARP VC, if all
	conditions are right.

Arguments:

	Vc		- Pointer to ARP Vc

Return Value:

	None

--*/
{
	PINTF			pIntF;
	NDIS_HANDLE		NdisVcHandle;
	NDIS_HANDLE		NdisPartyHandle;
	NDIS_STATUS		Status;
	KIRQL			OldIrql;

	pIntF = Vc->IntF;
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	DBGPRINT(DBG_LEVEL_NOTICE, 
	("InitiateClose: VC %x, ref %d, flags %x, Pending %d, ArpEntry %x\n",
			Vc, Vc->RefCount, Vc->Flags, Vc->PendingSends, Vc->ArpEntry));

	if (Vc->PendingSends == 0)
	{
		//
		//  No outstanding packets, we can start closing this call.
		//

		NdisVcHandle = Vc->NdisVcHandle;
		NdisPartyHandle = NULL;

		Vc->Flags |= ARPVC_CLOSING;
		Vc->Flags &= ~ARPVC_CLOSE_PENDING;
		Vc->Flags &= ~ARPVC_ACTIVE;

		//
		// The ArpEntry part of the Vc gets cleaned up seperately.
		//
		Vc->ArpEntry = NULL;

		ASSERT(Vc->HwAddr.SubAddress == NULL);

		RemoveEntryList(&Vc->List);
		InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		Status = NdisClCloseCall(NdisVcHandle, NdisPartyHandle, NULL, 0);

		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseCallComplete(Status, Vc, (NDIS_HANDLE)NULL);
		}
	}
	else
	{
		//
		//  Mark this Vc as needing CloseCall.
		//
		Vc->Flags &= ~ARPVC_ACTIVE;
		Vc->Flags |= ARPVC_CLOSE_PENDING;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

}


VOID
DeregisterAllAddresses(
	IN	PINTF					pIntF
	)
{
	//
	// Deregister any registered addresses from the switch.
	//
	ULONG				NumAllocedRegdAddresses;
	PATM_ADDRESS		RegAddresses;
	KIRQL				OldIrql;
	NDIS_STATUS			Status;
	ULONG				NumAddressesRegd;

	// Clear the registered address field.
	//
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	NumAllocedRegdAddresses = pIntF->NumAllocedRegdAddresses;
	RegAddresses = pIntF->RegAddresses;
	pIntF->NumAllocedRegdAddresses = 0;
	pIntF->RegAddresses = NULL;
	NumAddressesRegd = pIntF->NumAddressesRegd;
	pIntF->NumAddressesRegd = 0;

	// Deregister all registered addresses with the switch.
	//
	if (NumAddressesRegd)
	{
		KEVENT			DelAddressesEvent;
		BOOLEAN			fRet;
		KeInitializeEvent(&DelAddressesEvent, NotificationEvent, FALSE);
		ASSERT(pIntF->DelAddressesEvent == NULL);
		ASSERT(pIntF->NumPendingDelAddresses ==  0);
		pIntF->DelAddressesEvent = &DelAddressesEvent;
		pIntF->NumPendingDelAddresses =  NumAllocedRegdAddresses;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		DBGPRINT(DBG_LEVEL_WARN, ("DeregisterAllAddresses: Going to derigester addresses\n"));

		fRet = ArpSDeleteIntFAddresses(
					pIntF,
					NumAllocedRegdAddresses,
					RegAddresses
					);
		
		if (fRet == FALSE)
		{
			// This means that deregistration was not started for ALL addresses
			// This is a bad situation, and in this case, we don't wait.
			//
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			pIntF->DelAddressesEvent  =  NULL;
			pIntF->NumPendingDelAddresses =  0;
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		}
		else
		{

			DBGPRINT(DBG_LEVEL_WARN, ("DeregisterAllAddresses: Waiting for addresses to be deleted\n"));
			WAIT_FOR_OBJECT(Status, &DelAddressesEvent, NULL);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	}


	// Free RegAddresses.
	//
	if (RegAddresses)
	{
		FREE_MEM(RegAddresses);
	}
}

VOID
ArpSTryCloseAdapter(
	IN	PINTF					pIntF // NOLOCKIN LOLOCKOUT
)
//
// Close adapter if it's still in the "open" state. Need to
// guard against closing the adapter more than once.
//
{
	KIRQL			OldIrql;
	BOOLEAN 		bCloseAdapter;
	NDIS_STATUS		Status;

	bCloseAdapter = FALSE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	if (pIntF->Flags & INTF_ADAPTER_OPENED)
	{
		pIntF->Flags &= ~INTF_ADAPTER_OPENED;
		bCloseAdapter = TRUE;
	}
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (bCloseAdapter)
	{
		NdisCloseAdapter(&Status, pIntF->NdisBindingHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAdapterComplete(pIntF, Status);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\timer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	timer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	Jul 1996		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_TIMER_
#define	_TIMER_

struct _Timer;

typedef
BOOLEAN
(*TIMER_ROUTINE)(
	IN struct _IntF *		pIntF,
	IN struct _Timer *		pTimer,
	IN BOOLEAN				TimerShuttingDown
	);

typedef	struct _Timer
{
	struct _Timer *			Next;
	struct _Timer **		Prev;
	TIMER_ROUTINE			Routine;		// Timer routine
	SHORT					AbsTime;		// Absolute time, for re-enqueue
	SHORT					RelDelta;		// Relative to the previous entry
} TIMER, *PTIMER;


#define	ArpSTimerInitialize(pTimer, TimerRoutine, DeltaTime)	\
	{															\
		(pTimer)->Routine = TimerRoutine;						\
		(pTimer)->AbsTime = DeltaTime;							\
	}

#define	ArpSGetCurrentTick()	ArpSTimerCurrentTick

// Keep this at 15 sec units
#define	MULTIPLIER				4				// To convert minutes to ticks
#define	TIMER_TICK				-15*10000000L	// 15s in 100ns units

#endif	// _TIMER_




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\timer.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This file contains the code to manipulate timers.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_TIMER

VOID
ArpSTimerEnqueue(
	IN	PINTF					pIntF,
	IN	PTIMER					pTimer
	)
/*++

Routine Description:

	The timer events are maintained as a list which the timer thread wakes up,
	it looks at every timer tick. The list is maintained in such a way that
	only the head of the list needs to be updated every tick i.e. the entire
	list is never scanned. The way this is achieved is by keeping delta times
	relative to the previous entry.

	Every timer tick, the relative time at the head of the list is decremented.
	When that goes to ZERO, the head of the list is unlinked and dispatched.

	To give an example, we have the following events queued at time slots
	X			Schedule A after 10 ticks.
	X+3			Schedule B after 5  ticks.
	X+5			Schedule C after 4  ticks.
	X+8			Schedule D after 6  ticks.

	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
	D at X+14 (X+8+6).

	The above example covers all the situations.

	- NULL List.
	- Inserting at head of list.
	- Inserting in the middle of the list.
	- Appending to the list tail.

	The list will look as follows.

		    BEFORE                          AFTER
		    ------                          -----

    X   Head -->|                  Head -> A(10) ->|
    A(10)

    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
    B(5)

    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
    C(4)

    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
    D(6)

	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.

Arguments:


Return Value:

--*/
{
	PTIMER		pList, *ppList;
	USHORT		DeltaTime = pTimer->AbsTime;

#if DBG
	if (pTimer->Routine == (TIMER_ROUTINE)NULL)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
				("TimerEnqueue: pIntF %x, pTimer %x, NULL Routine!\n",
					pIntF, pTimer));
		DbgBreakPoint();
	}
#endif // DBG

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerEnqueue: Entered for pTimer %lx\n", pTimer));

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &pIntF->ArpTimer;
		 (pList = *ppList) != NULL;
		 ppList = &pList->Next)
	{
		if (DeltaTime <= pList->RelDelta)
		{
			pList->RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->RelDelta;
	}
	

	// Link this in the chain
	pTimer->RelDelta = DeltaTime;
	pTimer->Next = pList;
	pTimer->Prev = ppList;
	*ppList = pTimer;
	if (pList != NULL)
	{
		pList->Prev = &pTimer->Next;
	}
}


VOID
ArpSTimerCancel(
	IN	PTIMER					pTimer
	)
/*++

Routine Description:

	Cancel a previously queued timer. Called with the ArpCache mutex held.

Arguments:


Return Value:

--*/
{
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerCancel: Entered for pTimer %lx\n", pTimer));

	//
	// Unlink it from the list adjusting relative deltas carefully
	//
	if (pTimer->Next != NULL)
	{
		pTimer->Next->RelDelta += pTimer->RelDelta;
		pTimer->Next->Prev = pTimer->Prev;
	}

	*(pTimer->Prev) = pTimer->Next;
}


VOID
ArpSTimerThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle timer events here.

Arguments:

	None

Return Value:

	None
--*/
{
	PINTF			pIntF = (PINTF)Context;
	NTSTATUS		Status;
	LARGE_INTEGER	TimeOut;
	PTIMER			pTimer;
	BOOLEAN			ReQueue;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: Came to life\n"));

	TimeOut.QuadPart = TIMER_TICK;

	do
	{
		WAIT_FOR_OBJECT(Status, &pIntF->TimerThreadEvent, &TimeOut);
		if (Status == STATUS_SUCCESS)
		{
			//
			// Signalled to quit, do so.
			//
			break;
		}

		WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);	

		if ((pTimer = pIntF->ArpTimer) != NULL)
		{
			//
			// Careful here. If two timers fire together - let them !!
			//
			if (pTimer->RelDelta != 0)
				pTimer->RelDelta --;

			if (pTimer->RelDelta == 0)
			{
				pIntF->ArpTimer = pTimer->Next;
				if (pIntF->ArpTimer != NULL)
				{
					pIntF->ArpTimer->Prev = &pIntF->ArpTimer;
				}

				ReQueue = (*pTimer->Routine)(pIntF, pTimer, FALSE);
				if (ReQueue)
				{
					ArpSTimerEnqueue(pIntF, pTimer);
				}
			}
		}

		RELEASE_MUTEX(&pIntF->ArpCacheMutex);	
	} while (TRUE);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: terminating\n"));

	//
	// Now fire all queued timers
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);	

	for (pTimer = pIntF->ArpTimer;
		 pTimer != NULL;
		 pTimer = pIntF->ArpTimer)
	{
		pIntF->ArpTimer = pTimer->Next;
		ReQueue = (*pTimer->Routine)(pIntF, pTimer, TRUE);
		ASSERT(ReQueue == FALSE);
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);	

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: terminated\n"));
	//
	// Finally dereference the IntF
	//
	ArpSDereferenceIntF(pIntF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\registry.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file contains the code to read the registry.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_REGISTRY

NTSTATUS
ArpSReadGlobalConfiguration(
	IN	PUNICODE_STRING		RegistryPath
	)
/*++

Routine Description:

	Read the global registry.

Arguments:

	RegistryPath - Pointer to the service section in the registry.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS	Status;
	NDIS_HANDLE	ConfigHandle;

	//
	// Open the per-adapter registry config
	//
	NdisOpenProtocolConfiguration(&Status,
								  &ConfigHandle,
								  RegistryPath);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NDIS_STRING						ArpsBufString = NDIS_STRING_CONST("ArpBuffers");
		NDIS_STRING						FlushString = NDIS_STRING_CONST("FlushTime");
		PNDIS_CONFIGURATION_PARAMETER	Param;

		//
		// Read number of configured buffers
		//
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &ArpsBufString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger))
		{
			ArpSBuffers = Param->ParameterData.IntegerData;
		}

		//
		// Should we save cache in a file ?
		//
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &FlushString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger))
		{
			ArpSFlushTime = (USHORT)(Param->ParameterData.IntegerData * MULTIPLIER);
		}

		NdisCloseConfiguration(ConfigHandle);
	}

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
ArpSReadAdapterConfigFromRegistry(
	IN	PINTF				pIntF,
	OUT	PATMARPS_CONFIG		pConfig
	)
/*++

Routine Description:

	Read configuration for the specified interface.

Arguments:

	pIntF		- Interface
	pConfig		- Place to return information read in.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS	Status;
	NDIS_HANDLE	ConfigHandle;

	//
	// Open the per-adapter registry config
	//
	NdisOpenProtocolConfiguration(&Status,
								  &ConfigHandle,
								  &pIntF->ConfigString);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NDIS_STRING						RegdAddrsString = NDIS_STRING_CONST("RegisteredAddresses");
		NDIS_STRING						SelString = NDIS_STRING_CONST("Selector");
		NDIS_STRING						McsString = NDIS_STRING_CONST("MulticastAddresses");
		PNDIS_CONFIGURATION_PARAMETER	Param;
		PWSTR							p;
		UINT							i, Length;

		//
		// Read the value, if present for the selector byte to be used for the registered sap
		// for the std. address (as opposed to added addresses).
		//
		pConfig->SelByte = 0;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &SelString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger) &&
			(Param->ParameterData.IntegerData <= 0xFF))
		{
			pConfig->SelByte = (UCHAR)(Param->ParameterData.IntegerData);
			DBGPRINT(DBG_LEVEL_INFO,
					("Selector byte for interface %Z is %d\n",
					&pIntF->InterfaceName, pConfig->SelByte));
		}

		//
		// Read registered addresses here. On an interface there can be a set of
		// atm addresses registered. These need to be added and SAPs registered on
		// them.
		//
		pConfig->NumAllocedRegdAddresses = 0;
		pConfig->RegAddresses = NULL;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &RegdAddrsString,
							  NdisParameterMultiString);
		if ((Status == NDIS_STATUS_SUCCESS) && (Param->ParameterType == NdisParameterMultiString))
		{
			NDIS_STRING	String;

			//
			// Param now contains a list of atm addresses. Convert them into the right format and store
			// it in the intf structure. First determine the number of addresses.
			//
			for (p = Param->ParameterData.StringData.Buffer, i = 0;
				 *p != L'\0';
				 i++)
			{
				RtlInitUnicodeString(&String, p);
				DBGPRINT(DBG_LEVEL_INFO,
						("Configured address for interface %Z - %Z\n",
						&pIntF->InterfaceName, &String));

				p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
			}

			if (i)
			{
				//
				// Allocate space for the addresses
				//
				pConfig->RegAddresses = (PATM_ADDRESS)ALLOC_NP_MEM(sizeof(ATM_ADDRESS) * i, POOL_TAG_ADDR);
				if (pConfig->RegAddresses == NULL)
				{
					LOG_ERROR(NDIS_STATUS_RESOURCES);
				}
				else
				{
					DBGPRINT(DBG_LEVEL_INFO,
					("%d addresses registered for %Z\n", i, &pIntF->InterfaceName));
	
					ZERO_MEM(pConfig->RegAddresses, sizeof(ATM_ADDRESS) * i);
					for (i = 0, p = Param->ParameterData.StringData.Buffer;
 						*p != L'\0';
 						NOTHING)
					{
						RtlInitUnicodeString(&String, p);
						NdisConvertStringToAtmAddress(&Status, &String, &pConfig->RegAddresses[i]);
						if (Status == NDIS_STATUS_SUCCESS)
						{
							i++;
							pConfig->NumAllocedRegdAddresses ++;
						}
						else
						{
							DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSReadAdapterConfiguration: Failed to convert address %Z\n",
									&String));
						}
						p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
					}
				}
			}
		}

		pConfig->pMcsList = NULL;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &McsString,
							  NdisParameterMultiString);
		if ((Status == NDIS_STATUS_SUCCESS) && (Param->ParameterType == NdisParameterMultiString))
		{
			NDIS_STRING	String;

			//
			// Param now contains a list of Multicast IP Address ranges.
			// Each string is of the form "M.M.M.M-N.N.N.N"
			// Read them in.
			//
			for (p = Param->ParameterData.StringData.Buffer, i = 0;
				 *p != L'\0';
				 i++)
			{
				RtlInitUnicodeString(&String, p);
				DBGPRINT(DBG_LEVEL_INFO,
						("Configured Multicast range for interface %Z - %Z\n",
						&pIntF->InterfaceName, &String));

				p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
			}

			//
			// Allocate space for the addresses
			//
			pConfig->pMcsList = (PMCS_ENTRY)ALLOC_NP_MEM(sizeof(MCS_ENTRY) * i, POOL_TAG_MARS);
			if (pConfig->pMcsList == (PMCS_ENTRY)NULL)
			{
				LOG_ERROR(NDIS_STATUS_RESOURCES);
			}
			else
			{
				DBGPRINT(DBG_LEVEL_INFO,
						("%d Multicast ranges configured on %Z\n", i, &pIntF->InterfaceName));

				ZERO_MEM(pConfig->pMcsList, sizeof(MCS_ENTRY) * i);
				for (i = 0, p = Param->ParameterData.StringData.Buffer;
					 *p != L'\0';
					 NOTHING)
				{
					RtlInitUnicodeString(&String, p);
					ArpSConvertStringToIpPair(&Status, &String, &pConfig->pMcsList[i]);
					if (Status == NDIS_STATUS_SUCCESS)
					{
						if (i > 0)
						{
							pConfig->pMcsList[i-1].Next = &(pConfig->pMcsList[i]);
						}
						i++;
					}
					else
					{
						DBGPRINT(DBG_LEVEL_ERROR,
								("ArpSReadAdapterConfiguration: Failed to convert IP Range %Z\n",
								&String));
					}
					p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
				}
			}
		}


		//
		// Close the configuration handle
		//
		NdisCloseConfiguration(ConfigHandle);

		Status = NDIS_STATUS_SUCCESS;
	}

	return Status;
}



NDIS_STATUS
ArpSReadAdapterConfiguration(
	IN	PINTF				pIntF
	)
/*++

Routine Description:

	Read the registry for parameters for the specified Interface.
	This could be in response to a reconfiguration event, in which
	case handle existing values/structures.

Arguments:

	pIntF - Interface to be read in.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS			Status;
	ATMARPS_CONFIG		AtmArpSConfig;
	KIRQL				OldIrql;
	
	ULONG				PrevNumAllocedRegdAddresses;
	PATM_ADDRESS		PrevRegAddresses;
	PMCS_ENTRY			PrevMcsList;

	Status = ArpSReadAdapterConfigFromRegistry(pIntF, &AtmArpSConfig);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		// Copy them into the interface structure. We could be handling a
		// parameter reconfig, so any space used to store old information.
		//

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		//
		// Selector Byte:
		//
		pIntF->SelByte = AtmArpSConfig.SelByte;

		//
		// List of addresses to be registered with the switch.
		// Take out the old list first. We'll have to delete those
		// addresses (deregister them from the switch).
		//
		PrevNumAllocedRegdAddresses = pIntF->NumAllocedRegdAddresses;
		PrevRegAddresses = pIntF->RegAddresses;

		//
		// Get the new list in:
		//
		pIntF->NumAllocedRegdAddresses = AtmArpSConfig.NumAllocedRegdAddresses;
		pIntF->RegAddresses = AtmArpSConfig.RegAddresses;
		pIntF->NumAddressesRegd = 0;	// reset count of addresses regd with switch

		//
		// Take out the old MCS list and insert the new one.
		//
		PrevMcsList = pIntF->pMcsList;
		pIntF->pMcsList = AtmArpSConfig.pMcsList;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		//
		// Deregister all previously registered addresses with the switch.
		//
		if (PrevNumAllocedRegdAddresses)
		{
			ArpSDeleteIntFAddresses(pIntF, PrevNumAllocedRegdAddresses, PrevRegAddresses);

			//
			// Register the new list of addresses with the switch.
			//
			ArpSQueryAndSetAddresses(pIntF);
		}

		//
		// Free unused memory.
		//
		if (PrevMcsList)
		{
			FREE_MEM(PrevMcsList);
		}

		if (PrevRegAddresses)
		{
			FREE_MEM(PrevRegAddresses);
		}

	}

	return Status;
}


VOID
ArpSConvertStringToIpPair(
	OUT	PNDIS_STATUS			pStatus,
	IN	PNDIS_STRING			pString,
	IN	PMCS_ENTRY				pMcsEntry
	)
/*++

Routine Description:

	Extract a pair of IP addresses that identify a range of multicast addresses
	that this MCS serves, from the given string.

Arguments:

	pStatus		- Place to return status
	pString		- Points to string containing "<IP1>-<IP2>"
	pMcsEntry	- Entry to read into.

Return Value:

	None. *pStatus is set to indicate the status of this call.

--*/
{
	PWSTR			pMin, pMax;
	IPADDR			Min, Max;
	ULONG			Length;
	ULONG			i;

    ARPS_PAGED_CODE();

	Length = pString->Length;

	*pStatus = NDIS_STATUS_FAILURE;

	do
	{
		//
		//  Locate the '-' and replace it with a NULL char.
		//
		pMin = pString->Buffer;
		pMax = pString->Buffer;

		for (i = 0; i < Length; i++, pMax++)
		{
			if (*pMax == L'-')
			{
				*pMax++ = L'\0';
				break;
			}
		}

		if (i == Length)
		{
			break;	// Didn't find '-'
		}

		if (IPConvertStringToAddress(pMin, &Min) &&
			IPConvertStringToAddress(pMax, &Max))
		{
			DBGPRINT(DBG_LEVEL_INFO, ("MCS pair: "));
			ArpSDumpIpAddr(Min, " to ");
			ArpSDumpIpAddr(Max, "\n");

			pMcsEntry->GrpAddrPair.MinAddr = Min;
			pMcsEntry->GrpAddrPair.MaxAddr = Max;
			*pStatus = NDIS_STATUS_SUCCESS;
		}

		break;
	}
	while (FALSE);

}


#define IP_ADDRESS_STRING_LENGTH (16+2)     // +2 for double NULL on MULTI_SZ


BOOLEAN
IPConvertStringToAddress(
    IN PWCHAR AddressString,
	OUT PULONG IpAddress
	)

/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
	IP address string into a numeric IP address. Unlike inet_addr(), this
	routine does not support address strings of less than 4 octets nor does
	it support octal and hexadecimal octets.

	Copied from tcpip\ip\ntip.c

Arguments

    AddressString    - IP address in dotted decimal notation
	IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

	TRUE if the address string was converted. FALSE otherwise.

--*/

{
    UNICODE_STRING  unicodeString;
	STRING          aString;
	UCHAR           dataBuffer[IP_ADDRESS_STRING_LENGTH];
	NTSTATUS        status;
	PUCHAR          addressPtr, cp, startPointer, endPointer;
	ULONG           digit, multiplier;
	int             i;


    ARPS_PAGED_CODE();

    aString.Length = 0;
	aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
	aString.Buffer = dataBuffer;

	RtlInitUnicodeString(&unicodeString, AddressString);

	status = RtlUnicodeStringToAnsiString(
	             &aString,
				 &unicodeString,
				 FALSE
				 );

    if (!NT_SUCCESS(status)) {
	    return(FALSE);
	}

    *IpAddress = 0;
	addressPtr = (PUCHAR) IpAddress;
	startPointer = dataBuffer;
	endPointer = dataBuffer;
	i = 3;

    while (i >= 0) {
        //
		// Collect the characters up to a '.' or the end of the string.
		//
		while ((*endPointer != '.') && (*endPointer != '\0')) {
			endPointer++;
		}

		if (startPointer == endPointer) {
			return(FALSE);
		}

		//
		// Convert the number.
		//

        for ( cp = (endPointer - 1), multiplier = 1, digit = 0;
			  cp >= startPointer;
			  cp--, multiplier *= 10
			) {

			if ((*cp < '0') || (*cp > '9') || (multiplier > 100)) {
				return(FALSE);
			}

			digit += (multiplier * ((ULONG) (*cp - '0')));
		}

		if (digit > 255) {
			return(FALSE);
		}

        addressPtr[i] = (UCHAR) digit;

		//
		// We are finished if we have found and converted 4 octets and have
		// no other characters left in the string.
		//
	    if ( (i-- == 0) &&
			 ((*endPointer == '\0') || (*endPointer == ' '))
		   ) {
			return(TRUE);
		}

        if (*endPointer == '\0') {
			return(FALSE);
		}

		startPointer = ++endPointer;
	}

	return(FALSE);
}

	


VOID
ArpSReadArpCache(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Read the per-adapter Arp Cache. TBD.

Arguments:

	pIntF - Per adapter arp cache.

Return Value:

	None

--*/
{
	HANDLE				FileHandle;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			Status;
	LARGE_INTEGER		Offset;
	ULONG				Space, NumEntries;
	PDISK_HEADER		DskHdr;
	PUCHAR				Buffer;
    PDISK_ENTRY			pDskEntry;
	PARP_ENTRY			ArpEntry;

	Buffer = ALLOC_PG_MEM(DISK_BUFFER_SIZE);
	if (Buffer == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return;
	}

	InitializeObjectAttributes(&ObjectAttributes,
							   &pIntF->FileName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = ZwCreateFile(&FileHandle,
						  SYNCHRONIZE | FILE_READ_DATA,
						  &ObjectAttributes,
						  &IoStatus,
						  NULL,
						  0,
						  0,
						  FILE_OPEN,
						  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
						  NULL,
						  0);

	if (Status == STATUS_SUCCESS)
	{
		do
		{
			//
			// First read the disk header and validate it
			//
			Offset.QuadPart = 0;
			Status = ZwReadFile(FileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatus,
								Buffer,
								DISK_BUFFER_SIZE,
								&Offset,
								NULL);
			if (Status != STATUS_SUCCESS)
			{
				LOG_ERROR(Status);
				break;
			}

			DskHdr = (PDISK_HEADER)Buffer;
			if ((IoStatus.Information < sizeof(DISK_HEADER)) ||
				(DskHdr->Signature != DISK_HDR_SIGNATURE) ||
				(DskHdr->Version != DISK_HDR_VERSION))
			{
				LOG_ERROR(STATUS_INVALID_LEVEL);
				break;
			}
	
			NumEntries = DskHdr->NumberOfArpEntries;
			Space = (ULONG) IoStatus.Information - sizeof(DISK_HEADER);
            pDskEntry = (PDISK_ENTRY)(Buffer + sizeof(DISK_HEADER));
			Offset.QuadPart = sizeof(DISK_HEADER);
			while (NumEntries > 0)
			{
				UINT	Consumed;

				if ((Space < sizeof(DISK_ENTRY)) ||
					(Space < (sizeof(DISK_ENTRY) + pDskEntry->AtmAddr.SubAddrLen)))
				{
					Status = ZwReadFile(FileHandle,
										NULL,
										NULL,
										NULL,
										&IoStatus,
										Buffer,
										DISK_BUFFER_SIZE,
										&Offset,
										NULL);
					if (Status != STATUS_SUCCESS)
					{
						LOG_ERROR(Status);
						break;
					}

					pDskEntry = (PDISK_ENTRY)Buffer;
					if ((IoStatus.Information < sizeof(DISK_ENTRY)) ||
						(IoStatus.Information < (sizeof(DISK_ENTRY) + pDskEntry->AtmAddr.SubAddrLen)))
					{
						LOG_ERROR(STATUS_INVALID_LEVEL);
						break;
					}
					Space = (ULONG) IoStatus.Information - sizeof(DISK_HEADER);
				}

				ArpEntry = ArpSAddArpEntryFromDisk(pIntF, pDskEntry);
				ASSERT (ArpEntry != NULL);

				Consumed = (sizeof(DISK_ENTRY) + SIZE_4N(pDskEntry->AtmAddr.SubAddrLen));
				(PUCHAR)pDskEntry += Consumed;
				Offset.QuadPart += Consumed;
				Space -= Consumed;
				NumEntries --;
			}
		} while (FALSE);

		ZwClose(FileHandle);
	}

	FREE_MEM(Buffer);
}


BOOLEAN
ArpSWriteArpCache(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Write the per-adapter Arp Cache. TBD.

Arguments:

	pIntF - Per adapter arp cache.
	Timer -	FlushTimer
	TimerShuttingDown - Do not requeue when set.

Return Value:

	TRUE to requeue unless TimerShuttingDown is set

--*/
{
	HANDLE				FileHandle;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			Status;
	LARGE_INTEGER		Offset;
	ULONG				Space, i;
	PDISK_HEADER		DskHdr;
	PUCHAR				Buffer;
    PDISK_ENTRY			pDskEntry;
	PARP_ENTRY			ArpEntry;
	TIME				SystemTime, LocalTime;
	ULONG				CurrentTime;

	Buffer = ALLOC_PG_MEM(DISK_BUFFER_SIZE);
	if (Buffer == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return (!TimerShuttingDown);
	}

	KeQuerySystemTime(&SystemTime);

	ExSystemTimeToLocalTime(&SystemTime, &LocalTime);

	// Convert this to number of seconds since 1980
	if (!RtlTimeToSecondsSince1980(&LocalTime, &CurrentTime))
	{
		// Could not convert! Bail out.
		LOG_ERROR(NDIS_STATUS_BUFFER_OVERFLOW);
		FREE_MEM(Buffer);
		return (!TimerShuttingDown);
	}

	InitializeObjectAttributes(&ObjectAttributes,
							   &pIntF->FileName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = ZwCreateFile(&FileHandle,
						  SYNCHRONIZE | FILE_WRITE_DATA,
						  &ObjectAttributes,
						  &IoStatus,
						  NULL,
						  0,
						  0,
						  FILE_OVERWRITE_IF,
						  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
						  NULL,
						  0);
	if (Status == STATUS_SUCCESS)
	{
		do
		{
			Offset.QuadPart = 0;
			Space = DISK_BUFFER_SIZE - sizeof(DISK_HEADER);
			DskHdr = (PDISK_HEADER)Buffer;
			pDskEntry = (PDISK_ENTRY)(Buffer + sizeof(DISK_HEADER));
			DskHdr->Signature = DISK_HDR_SIGNATURE;
			DskHdr->Version = DISK_HDR_VERSION;
			DskHdr->NumberOfArpEntries = pIntF->NumCacheEntries;
			DskHdr->TimeStamp = CurrentTime;

			for (i =0; i < ARP_TABLE_SIZE; i++)
			{
				for (ArpEntry = pIntF->ArpCache[i];
					 ArpEntry != NULL;
					 ArpEntry = ArpEntry->Next)
				{
					UINT	Size;

					Size = sizeof(DISK_ENTRY) + ((ArpEntry->HwAddr.SubAddress != NULL) ?
														SIZE_4N(ArpEntry->HwAddr.SubAddress->NumberOfDigits) : 0);
					if (Space < Size)
					{
						Status = ZwWriteFile(FileHandle,
											 NULL,
											 NULL,
											 NULL,
											 &IoStatus,
											 Buffer,
											 DISK_BUFFER_SIZE - Space,
											 &Offset,
											 NULL);
						if (Status != STATUS_SUCCESS)
						{
							LOG_ERROR(Status);
							break;
						}

						Space = DISK_BUFFER_SIZE;
						pDskEntry = (PDISK_ENTRY)Buffer;
						Offset.QuadPart += (DISK_BUFFER_SIZE - Space);
					}

					pDskEntry->IpAddr = ArpEntry->IpAddr;
					pDskEntry->AtmAddr.AddrType = (UCHAR)ArpEntry->HwAddr.Address.AddressType;
					pDskEntry->AtmAddr.AddrLen = (UCHAR)ArpEntry->HwAddr.Address.NumberOfDigits;
					COPY_MEM(pDskEntry->AtmAddr.Address,
							 ArpEntry->HwAddr.Address.Address,
							 pDskEntry->AtmAddr.AddrLen);

					pDskEntry->AtmAddr.SubAddrLen = 0;
					if (ArpEntry->HwAddr.SubAddress != NULL)
					{
						pDskEntry->AtmAddr.SubAddrLen = (UCHAR)ArpEntry->HwAddr.SubAddress->NumberOfDigits;
						pDskEntry->AtmAddr.SubAddrType = (UCHAR)ArpEntry->HwAddr.SubAddress->AddressType;
						COPY_MEM((PUCHAR)pDskEntry + sizeof(DISK_ENTRY),
								 ArpEntry->HwAddr.SubAddress->Address,
								 pDskEntry->AtmAddr.SubAddrLen);
					}

					Space -= Size;
					(PUCHAR)pDskEntry += Size;
				}

				if (Status != STATUS_SUCCESS)
				{
					break;
				}
			}
		} while (FALSE);

		if ((Status == STATUS_SUCCESS) && (Space < DISK_BUFFER_SIZE))
		{
			Status = ZwWriteFile(FileHandle,
								 NULL,
								 NULL,
								 NULL,
								 &IoStatus,
								 Buffer,
								 DISK_BUFFER_SIZE - Space,
								 &Offset,
								 NULL);
		}

		ZwClose(FileHandle);
	}

	FREE_MEM(Buffer);

   	return (!TimerShuttingDown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\protos.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	protos.h

Abstract:

	This file contains the function proto-types and macros.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	_PROTOS_
#define	_PROTOS_

#define	POOL_TAG_PG				'AprA'
#define	POOL_TAG_VC				'VprA'
#define	POOL_TAG_INTF			'IprA'
#define	POOL_TAG_ADDR			'AprA'
#define	POOL_TAG_BUF			'BprA'
#define	POOL_TAG_REQ			'RprA'
#define	POOL_TAG_SAP			'SprA'
#define POOL_TAG_BLK			'KprA'
#define POOL_TAG_MARS			'MprA'

#if DBG

extern
PVOID
ArpSAllocMem(
	IN	UINT					Size,
	IN	ULONG					FileLine,
	IN	ULONG					Tag,
	IN	BOOLEAN					Paged
	);

extern
VOID
ArpSFreeMem(
	IN	PVOID					pMem,
	IN	ULONG					FileLine
	);

#define	ALLOC_NP_MEM(_size, _tag)		ArpSAllocMem(_size, __LINE__ | _FILENUM_, _tag, FALSE)
#define	ALLOC_PG_MEM(_size)				ArpSAllocMem(_size, __LINE__ | _FILENUM_, POOL_TAG_PG, TRUE)
#define	FREE_MEM(_p)					ArpSFreeMem(_p, __LINE__ | _FILENUM_)

#else

#define	ALLOC_NP_MEM(_size, _tag)		ExAllocatePoolWithTag(NonPagedPool, _size, _tag)
#define	ALLOC_PG_MEM(_size)				ExAllocatePoolWithTag(PagedPool, _size, POOL_TAG_PG)
#define	FREE_MEM(_p)					ExFreePool(_p)

#endif

#define	ZERO_MEM(_p, _size)				RtlZeroMemory(_p, _size)
#define	COPY_MEM(_d, _s, _size)			RtlCopyMemory(_d, _s, _size)
#define	MOVE_MEM(_d, _s, _size)			RtlMoveMemory(_d, _s, _size)
#define	COMP_MEM(_p1, _p2, _size_)		RtlEqualMemory(_p1, _p2, _size_)

#define	INITIALIZE_SPIN_LOCK(_l)		KeInitializeSpinLock(_l)
#define	ACQUIRE_SPIN_LOCK(_l, _i)		KeAcquireSpinLock(_l, _i)
#define	ACQUIRE_SPIN_LOCK_DPC(_l)		KeAcquireSpinLockAtDpcLevel(_l)
#define	RELEASE_SPIN_LOCK(_l, _i)		KeReleaseSpinLock(_l, _i)
#define	RELEASE_SPIN_LOCK_DPC(_l)		KeReleaseSpinLockFromDpcLevel(_l)
#define	INITIALIZE_MUTEX(_m_)			KeInitializeMutex(_m_, 0xFFFF)
#define	RELEASE_MUTEX(_m_)				KeReleaseMutex(_m_, FALSE);
#define	WAIT_FOR_OBJECT(_S_, _O_, _TO_)	(_S_) = KeWaitForSingleObject(_O_,			\
																	  Executive,	\
																	  KernelMode,	\
																	  TRUE,			\
																	  _TO_)			\

#define INIT_EVENT(_pEv)				NdisInitializeEvent(_pEv)
#define SET_EVENT(_pEv)					NdisSetEvent(_pEv)
#define WAIT_FOR_EVENT(_pEv)			NdisWaitEvent(_pEv, 0)


extern
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT			DriverObject,
	IN	PUNICODE_STRING			RegistryPath
	);

extern
NTSTATUS
ArpSDispatch(
	IN	PDEVICE_OBJECT			pDeviceObject,
	IN	PIRP					pIrp
	);

extern
NTSTATUS
ArpSHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	);

extern
NTSTATUS
ArpSEnumerateInterfaces(
	IN	PUCHAR					pBuffer,
	IN OUT	PULONG			    pSize
	);

extern
NTSTATUS
ArpSFlushArpCache(
	IN	 PINTF					pIntF
	);

extern
NTSTATUS
ArpSQueryOrAddArpEntry(
	IN	 PINTF					pIntF,
	IN	OUT	PIOCTL_QA_ENTRY		pQaBuf,
	IN	OPERATION				Operation
	);

extern
NTSTATUS
ArpSQueryArpCache(
	IN	 PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	);

extern
NTSTATUS
ArpSQueryArpStats(
	IN	PINTF					pIntF,
	OUT	PARP_SERVER_STATISTICS 	pArpStats
	);

extern
NTSTATUS
ArpSQueryMarsCache(
	IN	 PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	);

extern
NTSTATUS
ArpSQueryMarsStats(
	IN	PINTF					pIntF,
	OUT	PMARS_SERVER_STATISTICS pMarsStats
	);

extern
VOID
ArpSResetStats(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSUnload(
	IN	PDRIVER_OBJECT			DriverObject
	);

extern
VOID
ArpSShutDown(
	VOID
	);

extern
NDIS_STATUS
ArpSStopInterface(
	IN	PINTF					pIntF,
	IN	BOOLEAN					bCloseAdapter
	);

extern
NDIS_STATUS
ArpSPnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	);

extern
PINTF	
ArpSCreateIntF(
	IN	PNDIS_STRING			DeviceName,
	IN	PNDIS_STRING			ConfigString,
	IN  NDIS_HANDLE				BindingContext
	);

extern
VOID
ArpSReqThread(
	IN	PVOID					Context
	);

extern
VOID
ArpSTimerThread(
	IN	PVOID					Context
	);

extern
NTSTATUS
ArpSReadGlobalConfiguration(
	IN	PUNICODE_STRING			RegistryPath
	);

extern
NDIS_STATUS
ArpSReadAdapterConfigFromRegistry(
	IN	PINTF					pIntF,
	OUT	PATMARPS_CONFIG			pConfig
	);

extern
NDIS_STATUS
ArpSReadAdapterConfiguration(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSConvertStringToIpPair(
	OUT	PNDIS_STATUS			pStatus,
	IN	PNDIS_STRING			pString,
	IN	PMCS_ENTRY				pMcsEntry
	);

extern
BOOLEAN
IPConvertStringToAddress(
    IN PWCHAR AddressString,
	OUT PULONG IpAddress
	);

extern
VOID
ArpSReadArpCache(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
ArpSWriteArpCache(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
VOID
MarsReqThread(
	IN	PVOID					Context
	);

extern
VOID
MarsHandleRequest(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsHandleJoin(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsHandleLeave(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
PCLUSTER_MEMBER
MarsLookupClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	);

extern
PCLUSTER_MEMBER
MarsCreateClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	);

extern
VOID
MarsDeleteClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
PMARS_ENTRY
MarsLookupMarsEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					GrpAddr,
	IN	BOOLEAN					bCreateNew
	);

extern
BOOLEAN
MarsIsAddressMcsServed(
	IN	PINTF					pIntF,
	IN	IPADDR					IPAddress
	);

extern
VOID
MarsPunchHoles(
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PGROUP_MEMBER			pGroupList,
	IN	PINTF					pIntF,
	IN	IPADDR UNALIGNED *		pOutBuf					OPTIONAL,
	OUT	PUSHORT					pMinMaxCount,
	OUT	BOOLEAN *				pAnyHolesPunched
	);

extern
BOOLEAN
MarsAddClusterMemberToGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		JHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	);

extern
VOID
MarsUnlinkAllGroupsOnClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
BOOLEAN
MarsDelClusterMemberFromGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		LHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	);

extern
PNDIS_PACKET
MarsAllocControlPacket(
	IN	PINTF					pIntF,
	IN	ULONG					PacketLength,
	OUT	PUCHAR *				pPacketStart
	);

extern
VOID
MarsFreePacket(
	IN	PNDIS_PACKET			Packet
	);

extern
PNDIS_PACKET
MarsAllocPacketHdrCopy(
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsSendOnClusterControlVc(
	IN	PINTF					pIntF,
	IN	PNDIS_PACKET			Packet	OPTIONAL
	);

extern
VOID
MarsFreePacketsQueuedForClusterControlVc(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
MarsDelMemberFromClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	BOOLEAN					fIfLocked,
	IN	KIRQL					OldIrql			OPTIONAL
	);

extern
VOID
MarsAddMemberToClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
PCO_CALL_PARAMETERS
MarsPrepareCallParameters(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr,
	IN	BOOLEAN					IsMakeCall
	);

extern
BOOLEAN
MarsSendRedirect(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
VOID
MarsAbortAllMembers(
	IN	PINTF					pIntF
	);

extern
VOID
MarsStopInterface(
	IN	PINTF					pIntF
	);

extern
VOID
MarsDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	);

extern
VOID
MarsDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	);

extern
VOID
MarsDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	);

extern
VOID
MarsDumpMap(
	IN	PCHAR					String,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			AtmAddr
	);

extern
NTSTATUS
ArpSInitializeNdis(
	VOID
	);

extern
VOID
ArpSDeinitializeNdis(
	VOID
	);

extern
VOID
ArpSOpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	);

extern
VOID
ArpSCloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	);

extern
VOID
ArpSStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	);

extern
VOID
ArpSReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

extern
VOID
ArpSStatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

VOID
ArpSQueryAdapter(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSSendNdisRequest(
	IN	PINTF					pIntF,
	IN	NDIS_OID				Oid,
	IN	PVOID					pBuffer,
	IN	ULONG					BufferLength
	);

extern
VOID
ArpSRequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			pRequest,
	IN	NDIS_STATUS				Status
	);

extern
VOID
ArpSBindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	);

extern
VOID
ArpSUnbindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	);


extern
VOID
ArpSCoSendComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
ArpSCoStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	);

extern
NDIS_STATUS
ArpSCoRequest(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST		NdisRequest
	);

extern
VOID
ArpSCoRequestComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST			NdisRequest
	);


extern
VOID
ArpSCoAfRegisterNotify(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily
	);


extern
NDIS_STATUS
ArpSCreateVc(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisVcHandle,
	OUT	PNDIS_HANDLE			ProtocolVcContext
	);

extern
NDIS_STATUS
ArpSDeleteVc(
	IN	NDIS_HANDLE				ProtocolVcContext
	);

extern
VOID
ArpSOpenAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisAfHandle
	);

extern
VOID
ArpSCloseAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext
	);

extern
VOID
ArpSRegisterSap(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSRegisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	PCO_SAP					Sap,
	IN	NDIS_HANDLE				NdisSapHandle
	);

extern
VOID
ArpSDeregisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext
	);

extern
VOID
ArpSMakeCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSCloseCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				ProtocolPartyContext OPTIONAL
	);

extern
VOID
ArpSAddPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	NDIS_HANDLE				NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSDropPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext
	);

extern
NDIS_STATUS
ArpSIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN OUT PCO_CALL_PARAMETERS	CallParameters
	);

extern
VOID
ArpSIncomingDropParty(
	IN	NDIS_STATUS				DropStatus,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	);

extern
VOID
ArpSCallConnected(
	IN	NDIS_HANDLE				ProtocolVcContext
	);

extern
VOID
ArpSIncomingCloseCall(
	IN	NDIS_STATUS				CloseStatus,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	);

extern
VOID
ArpSIncomingCallQoSChange(
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSInitiateCloseCall(
	IN	PARP_VC					Vc
	);

extern
UINT
ArpSHandleArpRequest(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	);

extern
PARP_ENTRY
ArpSLookupEntryByIpAddr(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr
	);

extern
PARP_ENTRY
ArpSLookupEntryByAtmAddr(
	IN	PINTF					pIntF,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL
	);

extern
PARP_ENTRY
ArpSAddArpEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL,
	IN	PARP_VC					Vc			OPTIONAL
	);

extern
PARP_ENTRY
ArpSAddArpEntryFromDisk(
	IN	PINTF					pIntF,
	IN	PDISK_ENTRY				pDiskEntry
	);

extern
VOID
ArpSUpdateArpEntry(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PARP_VC					Vc
	);

extern
VOID
ArpSBuildArpReply(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	PARPS_HEADER			Header,
	IN	PNDIS_PACKET			Pkt
	);

extern
BOOLEAN
ArpSAgeEntry(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
BOOLEAN
ArpSDeleteIntFAddresses(
	IN	PINTF					pIntF,
	IN	INT						NumAddresses,
	IN	PATM_ADDRESS			AddrList
	);

extern
VOID
ArpSQueryAndSetAddresses(
	IN	PINTF					pIntF
	);

VOID
ArpSValidateAndSetRegdAddresses(
	IN	PINTF			pIntF,
	IN	KIRQL			OldIrql
	);

VOID
ArpSMakeRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSCloseRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSIncomingRegAddrCloseCall(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSValidateOneRegdAddress(
	IN	PINTF			pIntF,
	IN	KIRQL			OldIrql
	);

VOID
ArpSSetupValidationCallParams(
	IN PREG_ADDR_CTXT	pRegAddrCtxt, // LOCKIN LOCKOUT (pIntF lock)
	IN PATM_ADDRESS 	pAtmAddr
	);

VOID
ArpSUnlinkRegAddrCtxt(
	PINTF			pIntF, 		// LOCKIN NOLOCKOUT
	KIRQL			OldIrql
	);

VOID
ArpSLogFailedRegistration(
		PATM_ADDRESS pAtmAddress
	);

extern
BOOLEAN
ArpSReferenceIntF(
	IN	PINTF					pIntF
	);

extern
PINTF
ArpSReferenceIntFByName(
	IN	PINTERFACE_NAME			pInterface
	);

extern
VOID
ArpSDereferenceIntF(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
ArpSReferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					bSendRef
	);

extern
VOID
ArpSDereferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					KillArpEntry,
	IN	BOOLEAN					bSendComplete
	);

extern
VOID
ArpSSleep(
	IN	UINT					TimeInMs
	);

extern
VOID
ArpSFreeGlobalData(
	VOID
	);

extern
VOID
ArpSTimerCancel(
	IN	PTIMER					pTimerList
	);

extern
VOID
ArpSTimerEnqueue(
	IN	PINTF					pIntF,
	IN	PTIMER					pTimer
	);

extern
PVOID
ArpSAllocBlock(
	IN	PINTF					pIntF,
	IN	ENTRY_TYPE				EntryType
	);

extern
VOID
ArpSFreeBlock(
	IN	PVOID					pBlock
	);

BOOLEAN
ArpSValidAtmAddress(
	IN	PATM_ADDRESS			AtmAddr,
	IN	UINT					MaxSize
	);


VOID
DeregisterAllAddresses(
	IN	PINTF					pIntF
	);

BOOLEAN
MarsIsValidClusterMember(
	PINTF				pIntF,
	PCLUSTER_MEMBER		pPossibleMember
	);

VOID
ArpSTryCloseAdapter(
	IN	PINTF					pIntF // NOLOCKIN LOLOCKOUT
	);

#if	DBG

extern
VOID
ArpSDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	);

extern
VOID
ArpSDumpAddress(
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PCHAR					String
	);

extern
VOID
ArpSDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	);

extern
VOID
ArpSDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	);

#else

#define	ArpSDumpPacket(_Packet, _PktLen)
#define	ArpSDumpAddress(_IpAddr, _HwAddr, _String)
#define	ArpSDumpIpAddr(_IpAddr, _String)
#define	ArpSDumpAtmAddr(_AtmAddr, _String)

#endif

/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

#pragma	alloc_text(INIT, DriverEntry)
#pragma	alloc_text(INIT, ArpSReadGlobalConfiguration)
#pragma	alloc_text(INIT, ArpSInitializeNdis)
#pragma	alloc_text(PAGE, ArpSReadArpCache)
#pragma	alloc_text(PAGE, ArpSWriteArpCache)
#pragma	alloc_text(PAGE, ArpSSleep)
#pragma	alloc_text(PAGE, ArpSReqThread)
#pragma	alloc_text(PAGE, ArpSTimerThread)
#pragma	alloc_text(PAGE, ArpSDispatch)
#pragma	alloc_text(PAGE, ArpSLookupEntryByIpAddr)
#pragma	alloc_text(PAGE, ArpSLookupEntryByAtmAddr)
#pragma	alloc_text(PAGE, ArpSAddArpEntry)
#pragma	alloc_text(PAGE, ArpSAddArpEntryFromDisk)
#pragma	alloc_text(PAGE, ArpSCreateIntF)

#pragma	alloc_text(PAGE, MarsReqThread)
#endif	// _PROTOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\precomp.h ===
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <atm.h>

#include "arp.h"
#include "timer.h"
#include "ioctl.h"
#include "intf.h"
#include "mars.h"
#include "file.h"
#include "protos.h"
#include "data.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarps\util.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains the code for misc. functions.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_UTIL

#if	DBG

PVOID
ArpSAllocMem(
	IN	UINT					Size,
	IN	ULONG					FileLine,
	IN	ULONG					Tag,
	IN	BOOLEAN					Paged
	)
{
	PVOID	pMem;

	pMem = ExAllocatePoolWithTag(Paged ? PagedPool : NonPagedPool, Size, Tag);
#if _DBG
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAllocMem: %d bytes (%sPaged) from %lx -> %lx\n",
			Size, Paged ? "" : "Non", FileLine, pMem));
#endif
	return pMem;
}


VOID
ArpSFreeMem(
	IN	PVOID					pMem,
	IN	ULONG					FileLine
	)
{
#if _DBG
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSFreeMem: %lx from %lx\n", FileLine, pMem));
#endif
	ExFreePool(pMem);
}

#endif

PVOID
ArpSAllocBlock(
	IN	PINTF					pIntF,
	IN	ENTRY_TYPE				EntryType
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	PARP_BLOCK	ArpBlock;
	PENTRY_HDR	pBlock;
	PHW_ADDR	HwAddr;
	USHORT		Size;
	BOOLEAN		Paged;

#if 0
	// arvindm - used by MARS
	ARPS_PAGED_CODE( );
#endif

	ASSERT (EntryType < ARP_BLOCK_TYPES);
	pBlock = NULL;

	//
	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	//
	Size = ArpSEntrySize[EntryType];
	Paged = ArpSBlockIsPaged[EntryType];
	ArpBlock = pIntF->PartialArpBlocks[EntryType];

	if (ArpBlock == NULL)
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAllocBlock: ... and allocating a new block for EntryType %ld\n", EntryType));

		ArpBlock = Paged ?  (PARP_BLOCK)ALLOC_PG_MEM(BLOCK_ALLOC_SIZE) :
							(PARP_BLOCK)ALLOC_NP_MEM(BLOCK_ALLOC_SIZE, POOL_TAG_BLK);
		if (ArpBlock != NULL)
		{
			USHORT	i;
			USHORT	Cnt;

			DBGPRINT(DBG_LEVEL_WARN,
					("ArpSAllocBlock: Allocated a new block for EntryType %d\n", EntryType));

			//
			// Link it in the list
			//
			ArpBlock->IntF = pIntF;
			ArpBlock->EntryType = EntryType;
            ArpBlock->NumFree = Cnt = ArpSNumEntriesInBlock[EntryType];

			LinkDoubleAtHead(pIntF->PartialArpBlocks[EntryType], ArpBlock);

			//
			// Initialize the list of free entries
			//
			for (i = 0, pBlock = ArpBlock->FreeHead = (PENTRY_HDR)((PUCHAR)ArpBlock + sizeof(ARP_BLOCK));
				 i < Cnt;
				 i++, pBlock = pBlock->Next)
			{
				HwAddr = (PHW_ADDR)(pBlock + 1);
				pBlock->Next = (i == (Cnt - 1)) ? NULL : ((PUCHAR)pBlock + Size);
				HwAddr->SubAddress = NULL;
				if ((EntryType == ARP_BLOCK_SUBADDR) || (EntryType == MARS_CLUSTER_SUBADDR))
					HwAddr->SubAddress = (PATM_ADDRESS)((PUCHAR)pBlock+Size);
			}
		}
	}
	else
	{
		ASSERT(ArpBlock->NumFree <= ArpSNumEntriesInBlock[EntryType]);
		ASSERT(ArpBlock->NumFree > 0);

		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAllocBlock: Found space in Block %lx\n", ArpBlock));
	}


	if (ArpBlock != NULL)
	{
		PARP_BLOCK	pTmp;

		pBlock = ArpBlock->FreeHead;

		ArpBlock->FreeHead = pBlock->Next;
		ArpBlock->NumFree --;
		ZERO_MEM(pBlock, Size);
		if ((EntryType == ARP_BLOCK_SUBADDR) || (EntryType == MARS_CLUSTER_SUBADDR))
		{
			HwAddr = (PHW_ADDR)(pBlock + 1);
			HwAddr->SubAddress = (PATM_ADDRESS)((PUCHAR)pBlock + Size);
		}

		//
		// If the block is now empty (completely used), unlink it from here and move it
		// to the Used list.
		//
		if (ArpBlock->NumFree == 0)
		{
	        UnlinkDouble(ArpBlock);
			LinkDoubleAtHead(pIntF->UsedArpBlocks[EntryType], ArpBlock)
		}
	}

	return pBlock;
}


VOID
ArpSFreeBlock(
	IN	PVOID					pBlock
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	PARP_BLOCK	ArpBlock;

#if 0
	// arvindm - MARS
	ARPS_PAGED_CODE( );
#endif

	//
	// NOTE: The following code *depends* on the fact that we allocate ARP_BLOCKs as
	//		 single page blocks and also that these are allocated *at* page boundaries
	//		 This lets us *cheaply* get to the owning ARP_BLOCK from ARP_ENTRY.
	//
	ArpBlock = (PARP_BLOCK)((ULONG_PTR)pBlock & ~(PAGE_SIZE-1));

	ASSERT (ArpBlock->EntryType < ARP_BLOCK_TYPES);
	ASSERT(ArpBlock->NumFree < ArpSNumEntriesInBlock[ArpBlock->EntryType]);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSFreepBlock: Returning pBlock %lx to Block %lx\n", pBlock, ArpBlock));

	ArpBlock->NumFree ++;
	((PENTRY_HDR)pBlock)->Next = ArpBlock->FreeHead;
	ArpBlock->FreeHead = pBlock;

	if (ArpBlock->NumFree == 1)
	{
		//
		// The block is now partially free (was completely used). Move it to the partial list
		//

		UnlinkDouble(ArpBlock);
		LinkDoubleAtHead(ArpBlock->IntF->PartialArpBlocks[ArpBlock->EntryType], ArpBlock)
	}
	else if (ArpBlock->NumFree == ArpSNumEntriesInBlock[ArpBlock->EntryType])
	{
		//
		// The block is now completely free (was partially used). Free it.
		//
		UnlinkDouble(ArpBlock);
		FREE_MEM(ArpBlock);
	}
}


BOOLEAN
ArpSValidAtmAddress(
	IN	PATM_ADDRESS			AtmAddr,
	IN	UINT					MaxSize
	)
{
	//
	// TODO -- validate
	//
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\parse.h ===
typedef enum // tokens: * . ? [ ] / help dt dg L number <identifier>
{
    tokSTAR,            // *
    tokDOT,             // .
    tokQUESTION,        // ?
    tokLBRAC,           // [
    tokRBRAC,           // ]
    tokSLASH,           // /
    tokKEYWORD,         // alnum strings which match one of the known keys.
    tokNUMBER,           // 0xcbde 129
    tokIDENTIFIER       // non-keyword and non-number alnum

} eTOKTYPE;


typedef struct
{
    eTOKTYPE eTok;
    UINT     uID;     // Tok-specific ID:
                      //    IDENTIFIER: a unique number across all identifiers.
                      //    NUMBER: the number
                      //    KEYWORD: eKEYWORD
                      //    Other tokens: uID is unused.
    char    *szStr;   // String containg original chars that made up this token.

                      // Note: a string of pure hex digits which is followed 
                      // by a non-alnum char is assumed to be a number --
                      // later if it turns out to be more likely that it is
                      // an identifier, it is converted to an identifier.
                      // Same deal with a keyword -- if it turns out based
                      // on context to be most likely an identifier or part
                      // of an identifier, it will be converted to an
                      // identifier.
    
} TOKEN;

typedef enum
{
    keywordNULL,            // Invalid keyword, use for sentinels.
    keywordHELP,            // help
    keywordDUMP_TYPE,       // dt
    keywordDUMP_GLOBALS,    // dg
    keywordL                // L

} eKEYWORD;

//
// Following is not used currently...
//
typedef enum
{
    phraseCMD,
    phraseIDENTIFIER,   // with optional wildcards
    phraseINDEX,        // [2], [*],  [1-3], etc.
    phraseDOT,          // .
    phraseNUMBER,       // 0x8908 abcd
    phraseOBJ_COUNT,    // L 2
    phraseFLAG          // /xyz

} ePHRASE;

typedef enum
{
    cmdDUMP_TYPE,
    cmdDUMP_GLOBALS,
    cmdHELP

}ePRIMARY_COMMAND;


struct _DBGCOMMAND;

typedef void (*PFN_SPECIAL_COMMAND_HANDLER)(struct _DBGCOMMAND *pCmd);

typedef struct _DBGCOMMAND
{
	NAMESPACE 		*pNameSpace;	// Name space applicable for this command.
    ePRIMARY_COMMAND ePrimaryCmd; // DumpGlobals, DumpType, help
    UINT 			uFlags;            // One or more fCMDFLAG_*
    TOKEN 			*ptokObject;     // eg <type>
    TOKEN 			*ptokSubObject;  // eg <field>
    UINT 			uVectorIndexStart; // if[0]
    UINT 			uVectorIndexEnd; // if[0]
    UINT 			uObjectAddress; // <address>
    UINT 			uObjectCount; // L 10

    void 			*pvContext;    // private context.
    //PFN_SPECIAL_COMMAND_HANDLER pfnSpecialHandler;

} DBGCOMMAND;


#define fCMDFLAG_HAS_VECTOR_INDEX       (0x1<<0)
#define fCMDFLAG_HAS_SUBOBJECT          (0x1<<1)
#define fCMDFLAG_HAS_OBJECT_ADDRESS     (0x1<<2)
#define fCMDFLAG_HAS_OBJECT_COUNT       (0x1<<3)
#define fCMDFLAG_OBJECT_STAR_PREFIX     (0x1<<4)
#define fCMDFLAG_OBJECT_STAR_SUFFIX     (0x1<<5)
#define fCMDFLAG_SUBOBJECT_STAR_PREFIX  (0x1<<6)
#define fCMDFLAG_SUBOBJECT_STAR_SUFFIX  (0x1<<7)

#define CMD_SET_FLAG(_pCmd, _f)  ((_pCmd)->uFlags |= (_f))
#define CMD_CLEAR_FLAG(_pCmd, _f)  ((_pCmd)->uFlags &= ~(_f))
#define CMD_IS_FLAG_SET(_pCmd, _f)  ((_pCmd)->uFlags & (_f))

DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *
);

void
FreeCommand(
    DBGCOMMAND *pCommand
);

void
DumpCommand(
    DBGCOMMAND *pCommand
);


#if 0
//!aac dt <type> . <field> <address> L <count> <flags>
//!aac dt <type> [index] . <field>   L <count> <flags>
//!aac dg <name> . <field>
//
//!aac dt if[*].*handle* 0x324890 L 5

0. Break up sentance into tokens:
        keywords: * . L dg dt ? help [ ] /
        identifier: contiguous non-keyword alnum
        number: interpreted as hex with optional 0x.
1st pass: combine "[*]", "*word*", "/xyz" into single entities 

1. Parse primary command: literal text
2. Parse primary object: [*]literal_text[*]
3. Parse index "[...]"
4. Parse field "."
5. Parse address (hex number)
6. Parse object count L <count>
#endif //  0

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler);

void
DoDumpType(DBGCOMMAND *pCmd);

void
DoDumpGlobals(DBGCOMMAND *pCmd);

void
DoHelp(DBGCOMMAND *pCmd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\aac.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	aac.c	- DbgExtension Structure information specific to ATMARPC.SYS

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created

Notes:

--*/


#include "precomp.h"


enum
{
    typeid_NULL,
    typeid_ATMARP_GLOBALS,
    typeid_ATMARP_ADAPTER,
    typeid_ATMARP_INTERFACE,
    typeid_ATMARP_ATM_ENTRY,
    typeid_ATMARP_IP_ENTRY,
    typeid_ATMARP_VC
};

extern TYPE_INFO *g_rgTypes[];
//
// STRUCTURES CONCERNING TYPE "ATMARP_ADAPTER"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_ADAPTER[] =
{

#if DBG
  {
    "aaa_sig",
     FIELD_OFFSET(ATMARP_ADAPTER, aaa_sig),
     FIELD_SIZE(ATMARP_ADAPTER, aaa_sig)
  },
#endif

  {
    "pNextAdapter",
     FIELD_OFFSET(ATMARP_ADAPTER, pNextAdapter),
     FIELD_SIZE(ATMARP_ADAPTER, pNextAdapter)
  },


  {
    "pInterfaceList",
     FIELD_OFFSET(ATMARP_ADAPTER, pInterfaceList),
     FIELD_SIZE(ATMARP_ADAPTER, pInterfaceList)
  },

  {
    "InterfaceCount",
     FIELD_OFFSET(ATMARP_ADAPTER, InterfaceCount),
     FIELD_SIZE(ATMARP_ADAPTER, InterfaceCount)
  },

  {
    "NdisAdapterHandle",
     FIELD_OFFSET(ATMARP_ADAPTER, NdisAdapterHandle),
     FIELD_SIZE(ATMARP_ADAPTER, NdisAdapterHandle)
  },

  {
    "BindContext",
     FIELD_OFFSET(ATMARP_ADAPTER, BindContext),
     FIELD_SIZE(ATMARP_ADAPTER, BindContext)
  },

  {
    "SystemSpecific1",
     FIELD_OFFSET(ATMARP_ADAPTER, SystemSpecific1),
     FIELD_SIZE(ATMARP_ADAPTER, SystemSpecific1)
  },

  {
    "SystemSpecific2",
     FIELD_OFFSET(ATMARP_ADAPTER, SystemSpecific2),
     FIELD_SIZE(ATMARP_ADAPTER, SystemSpecific2)
  },

#if OBSOLETE
  {
    "AdapterConfigHandle",
     FIELD_OFFSET(ATMARP_ADAPTER, AdapterConfigHandle),
     FIELD_SIZE(ATMARP_ADAPTER, AdapterConfigHandle)
  },
#endif // OBSOLETE

  {
    "IPConfigString",
     FIELD_OFFSET(ATMARP_ADAPTER, IPConfigString),
     FIELD_SIZE(ATMARP_ADAPTER, IPConfigString)
  },

  {
    "UnbindContext",
     FIELD_OFFSET(ATMARP_ADAPTER, UnbindContext),
     FIELD_SIZE(ATMARP_ADAPTER, UnbindContext)
  },

  {
    "Medium",
     FIELD_OFFSET(ATMARP_ADAPTER, Medium),
     FIELD_SIZE(ATMARP_ADAPTER, Medium)
  },

  {
    "Flags",
     FIELD_OFFSET(ATMARP_ADAPTER, Flags),
     FIELD_SIZE(ATMARP_ADAPTER, Flags)
  },

  {
    "LineRate",
     FIELD_OFFSET(ATMARP_ADAPTER, LineRate),
     FIELD_SIZE(ATMARP_ADAPTER, LineRate)
  },

  {
    "MaxPacketSize",
     FIELD_OFFSET(ATMARP_ADAPTER, MaxPacketSize),
     FIELD_SIZE(ATMARP_ADAPTER, MaxPacketSize)
  },

  {
    "MacAddress",
     FIELD_OFFSET(ATMARP_ADAPTER, MacAddress),
     FIELD_SIZE(ATMARP_ADAPTER, MacAddress)
  },

  {
    "DescrLength",
     FIELD_OFFSET(ATMARP_ADAPTER, DescrLength),
     FIELD_SIZE(ATMARP_ADAPTER, DescrLength)
  },

  {
    "pDescrString",
     FIELD_OFFSET(ATMARP_ADAPTER, pDescrString),
     FIELD_SIZE(ATMARP_ADAPTER, pDescrString)
  },

  {
    "DeviceName",
     FIELD_OFFSET(ATMARP_ADAPTER, DeviceName),
     FIELD_SIZE(ATMARP_ADAPTER, DeviceName)
  },

  {
    "ConfigString",
     FIELD_OFFSET(ATMARP_ADAPTER, ConfigString),
     FIELD_SIZE(ATMARP_ADAPTER, ConfigString)
  },


  {
    "Block",
     FIELD_OFFSET(ATMARP_ADAPTER, Block),
     FIELD_SIZE(ATMARP_ADAPTER, Block)
  },

  {
  	NULL
  }


};

TYPE_INFO type_ATMARP_ADAPTER = {
    "ATMARP_ADAPTER",
    "a",
     typeid_ATMARP_ADAPTER,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(ATMARP_ADAPTER),
     rgfi_ATMARP_ADAPTER,
     FIELD_OFFSET(ATMARP_ADAPTER, pNextAdapter) // offset to next pointer.
};



//
// STRUCTURES CONCERNING TYPE "ATMARP_GLOBALS"
//


STRUCT_FIELD_INFO  rgfi_ATMARP_GLOBALS[] =
{
#if DBG
  {
    "aag_sig",
     FIELD_OFFSET(ATMARP_GLOBALS, aag_sig),
     FIELD_SIZE(ATMARP_GLOBALS, aag_sig)
  },
#endif // DBG

  {
    "Lock",
     FIELD_OFFSET(ATMARP_GLOBALS, Lock),
     FIELD_SIZE(ATMARP_GLOBALS, Lock)
  },

  {
    "ProtocolHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, ProtocolHandle),
     FIELD_SIZE(ATMARP_GLOBALS, ProtocolHandle)
  },

  {
    "pDriverObject",
     FIELD_OFFSET(ATMARP_GLOBALS, pDriverObject),
     FIELD_SIZE(ATMARP_GLOBALS, pDriverObject)
  },

  {
    "pDeviceObject",
     FIELD_OFFSET(ATMARP_GLOBALS, pDeviceObject),
     FIELD_SIZE(ATMARP_GLOBALS, pDeviceObject)
  },


  {
    "pAdapterList",
     FIELD_OFFSET(ATMARP_GLOBALS, pAdapterList),
     FIELD_SIZE(ATMARP_GLOBALS, pAdapterList)
  },

  {
    "AdapterCount",
     FIELD_OFFSET(ATMARP_GLOBALS, AdapterCount),
     FIELD_SIZE(ATMARP_GLOBALS, AdapterCount)
  },

  {
    "bUnloading",
     FIELD_OFFSET(ATMARP_GLOBALS, bUnloading),
     FIELD_SIZE(ATMARP_GLOBALS, bUnloading)
  },

#ifdef NEWARP

  {
    "ARPRegisterHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, ARPRegisterHandle),
     FIELD_SIZE(ATMARP_GLOBALS, ARPRegisterHandle)
  },

  {
    "pIPAddInterfaceRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPAddInterfaceRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPAddInterfaceRtn)
  },

  {
    "pIPDelInterfaceRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPDelInterfaceRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPDelInterfaceRtn)
  },

  {
    "pIPBindCompleteRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPBindCompleteRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPBindCompleteRtn)
  },

#else
    #error "unimplemented"
#endif // NEWARP

  {
    "Block",
     FIELD_OFFSET(ATMARP_GLOBALS, Block),
     FIELD_SIZE(ATMARP_GLOBALS, Block)
  },


#ifdef GPC

#if DBG
  {
    "aaq_sig",
     FIELD_OFFSET(ATMARP_GLOBALS, aaq_sig),
     FIELD_SIZE(ATMARP_GLOBALS, aaq_sig)
  },
#endif

  {
    "pFlowInfoList",
     FIELD_OFFSET(ATMARP_GLOBALS, pFlowInfoList),
     FIELD_SIZE(ATMARP_GLOBALS, pFlowInfoList)
  },

  {
    "GpcClientHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, GpcClientHandle),
     FIELD_SIZE(ATMARP_GLOBALS, GpcClientHandle)
  },

  {
    "bGpcInitialized",
     FIELD_OFFSET(ATMARP_GLOBALS, bGpcInitialized),
     FIELD_SIZE(ATMARP_GLOBALS, bGpcInitialized)
  },

  {
    "GpcCalls",
     FIELD_OFFSET(ATMARP_GLOBALS, GpcCalls),
     FIELD_SIZE(ATMARP_GLOBALS, GpcCalls)
  },
#endif // GPC

  {
  	NULL
  }

};


TYPE_INFO type_ATMARP_GLOBALS = {
    "ATMARP_GLOBALS",
    "aag",
     typeid_ATMARP_GLOBALS,
     0,
     sizeof(ATMARP_GLOBALS),
     rgfi_ATMARP_GLOBALS
};


//
// STRUCTURES CONCERNING TYPE "ATMARP_INTERFACE"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_INTERFACE[] =
{

#if DBG
  {
    "aai_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aai_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aai_sig)
  },
#endif


//	struct _ATMARP_INTERFACE *	pNextInterface;		// in list of ATMARP interfaces
  {
    "pNextInterface",
     FIELD_OFFSET(ATMARP_INTERFACE, pNextInterface),
     FIELD_SIZE(ATMARP_INTERFACE, pNextInterface)
  },
//	ULONG						RefCount;			// References to this interface
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_INTERFACE, RefCount),
     FIELD_SIZE(ATMARP_INTERFACE, RefCount)
  },
//	ULONG						AdminState;			// Desired state of this interface
  {
    "AdminState",
     FIELD_OFFSET(ATMARP_INTERFACE, AdminState),
     FIELD_SIZE(ATMARP_INTERFACE, AdminState)
  },
//	ULONG						State;				// (Actual) State of this interface
  {
    "State",
     FIELD_OFFSET(ATMARP_INTERFACE, State),
     FIELD_SIZE(ATMARP_INTERFACE, State)
  },

#if (RECONFIG)
    //enum...                               ReconfigState;
  {
    "ReconfigState",
     FIELD_OFFSET(ATMARP_INTERFACE, ReconfigState),
     FIELD_SIZE(ATMARP_INTERFACE, ReconfigState)
  },
#endif // RECONFIG

//	ULONG						Flags;				// Misc state information
  {
    "Flags",
     FIELD_OFFSET(ATMARP_INTERFACE, Flags),
     FIELD_SIZE(ATMARP_INTERFACE, Flags)
  },

#if DBG
//	ULONG						aaim_sig;			// Signature to help debugging
  {
    "aaim_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaim_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaim_sig)
  },
#endif

//	struct _ATMARP_INTERFACE *	pAdapter;			// Pointer to Adapter info
  {
    "pAdapter",
     FIELD_OFFSET(ATMARP_INTERFACE, pAdapter),
     FIELD_SIZE(ATMARP_INTERFACE, pAdapter)
  },
#if 0
//	PCO_SAP						pSap;				// SAP info for this interface
  {
    "pSap",
     FIELD_OFFSET(ATMARP_INTERFACE, pSap),
     FIELD_SIZE(ATMARP_INTERFACE, pSap)
  },
#endif // 0

// ATMARP_SAP					SapList;			// Each SAP registered with CallMgr
  {
    "SapList",
     FIELD_OFFSET(ATMARP_INTERFACE, SapList),
     FIELD_SIZE(ATMARP_INTERFACE, SapList)
  },

//	ATMARP_HEADER_POOL			HeaderPool[AA_HEADER_TYPE_MAX];
  {
    "HeaderPool",
     FIELD_OFFSET(ATMARP_INTERFACE, HeaderPool),
     FIELD_SIZE(ATMARP_INTERFACE, HeaderPool)
  },


	//
	//  ----- IP/ARP interface related ----
	//
#if DBG
	//ULONG						aaia_sig;			// Signature to help debugging
  {
    "aaia_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaia_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaia_sig)
  },
#endif
//	PVOID						IPContext;			// Use in calls to IP
  {
    "IPContext",
     FIELD_OFFSET(ATMARP_INTERFACE, IPContext),
     FIELD_SIZE(ATMARP_INTERFACE, IPContext)
  },
//	IP_ADDRESS_ENTRY			LocalIPAddress;		// List of local IP addresses. There
  {
    "LocalIPAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, LocalIPAddress),
     FIELD_SIZE(ATMARP_INTERFACE, LocalIPAddress)
  },
													// should be atleast one.
//NDIS_STRING					IPConfigString;		// Config info for IP for this LIS
  {
    "IPConfigString",
     FIELD_OFFSET(ATMARP_INTERFACE, IPConfigString),
     FIELD_SIZE(ATMARP_INTERFACE, IPConfigString)
  },

	//
	//  ----- IP/ATM operation related ----
	//
#if DBG
//	ULONG						aait_sig;			// Signature to help debugging
  {
    "aait_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aait_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aait_sig)
  },
#endif
//	PATMARP_IP_ENTRY *			pArpTable;			// The ARP table
  {
    "pArpTable",
     FIELD_OFFSET(ATMARP_INTERFACE, pArpTable),
     FIELD_SIZE(ATMARP_INTERFACE, pArpTable)
  },
//	ULONG						NumOfArpEntries;	// Entries in the above
  {
    "NumOfArpEntries",
     FIELD_OFFSET(ATMARP_INTERFACE, NumOfArpEntries),
     FIELD_SIZE(ATMARP_INTERFACE, NumOfArpEntries)
  },
//	ATMARP_SERVER_LIST			ArpServerList;		// List of ARP servers
  {
    "ArpServerList",
     FIELD_OFFSET(ATMARP_INTERFACE, ArpServerList),
     FIELD_SIZE(ATMARP_INTERFACE, ArpServerList)
  },
//	PATMARP_SERVER_ENTRY		pCurrentServer;		// ARP server in use
  {
    "pCurrentServer",
     FIELD_OFFSET(ATMARP_INTERFACE, pCurrentServer),
     FIELD_SIZE(ATMARP_INTERFACE, pCurrentServer)
  },
//	PATMARP_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
  {
    "pAtmEntryList",
     FIELD_OFFSET(ATMARP_INTERFACE, pAtmEntryList),
     FIELD_SIZE(ATMARP_INTERFACE, pAtmEntryList)
  },
//	ULONG						AtmInterfaceUp;		// The ATM interface is considered
  {
    "AtmInterfaceUp",
     FIELD_OFFSET(ATMARP_INTERFACE, AtmInterfaceUp),
     FIELD_SIZE(ATMARP_INTERFACE, AtmInterfaceUp)
  },
													// "up" after ILMI addr regn is over
//	ATM_ADDRESS					LocalAtmAddress;	// Our ATM (HW) Address
  {
    "LocalAtmAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, LocalAtmAddress),
     FIELD_SIZE(ATMARP_INTERFACE, LocalAtmAddress)
  },

//	ATMARP_TIMER_LIST			TimerList[AAT_CLASS_MAX];
  {
    "TimerList",
     FIELD_OFFSET(ATMARP_INTERFACE, TimerList),
     FIELD_SIZE(ATMARP_INTERFACE, TimerList)
  },

#ifdef IPMCAST
	//
	//  ---- IP Multicast over ATM stuff ----
	//
#if DBG
	//ULONG						aaic_sig;			// Signature for debugging
  {
    "aaic_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaic_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaic_sig)
  },
#endif // DBG
//	ULONG						IpMcState;			// State of IP Multicast/ATM
  {
    "IpMcState",
     FIELD_OFFSET(ATMARP_INTERFACE, IpMcState),
     FIELD_SIZE(ATMARP_INTERFACE, IpMcState)
  },
//	PATMARP_IPMC_JOIN_ENTRY		pJoinList;			// List of MC groups we have Joined
  {
    "pJoinList",
     FIELD_OFFSET(ATMARP_INTERFACE, pJoinList),
     FIELD_SIZE(ATMARP_INTERFACE, pJoinList)
  },
//	PATMARP_IP_ENTRY			pMcSendList;		// Sorted list of MC groups we send to
  {
    "pMcSendList",
     FIELD_OFFSET(ATMARP_INTERFACE, pMcSendList),
     FIELD_SIZE(ATMARP_INTERFACE, pMcSendList)
  },
//	ATMARP_SERVER_LIST			MARSList;			// List of MARS (servers)
  {
    "MARSList",
     FIELD_OFFSET(ATMARP_INTERFACE, MARSList),
     FIELD_SIZE(ATMARP_INTERFACE, MARSList)
  },
//	PATMARP_SERVER_ENTRY		pCurrentMARS;		// MARS in use
  {
    "pCurrentMARS",
     FIELD_OFFSET(ATMARP_INTERFACE, pCurrentMARS),
     FIELD_SIZE(ATMARP_INTERFACE, pCurrentMARS)
  },
#endif // IPMCAST

//	PAA_GET_PACKET_SPEC_FUNC	pGetPacketSpecFunc;	// Routine to extract packet specs
  {
    "pGetPacketSpecFunc",
     FIELD_OFFSET(ATMARP_INTERFACE, pGetPacketSpecFunc),
     FIELD_SIZE(ATMARP_INTERFACE, pGetPacketSpecFunc)
  },

//	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows
  {
    "pFlowInfoList",
     FIELD_OFFSET(ATMARP_INTERFACE, pFlowInfoList),
     FIELD_SIZE(ATMARP_INTERFACE, pFlowInfoList)
  },

#ifdef DHCP_OVER_ATM
//	BOOLEAN						DhcpEnabled;
  {
    "DhcpEnabled",
     FIELD_OFFSET(ATMARP_INTERFACE, DhcpEnabled),
     FIELD_SIZE(ATMARP_INTERFACE, DhcpEnabled)
  },
//	ATM_ADDRESS					DhcpServerAddress;
  {
    "DhcpServerAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, DhcpServerAddress),
     FIELD_SIZE(ATMARP_INTERFACE, DhcpServerAddress)
  },
//	PATMARP_ATM_ENTRY			pDhcpServerAtmEntry;
  {
    "pDhcpServerAtmEntry",
     FIELD_OFFSET(ATMARP_INTERFACE, pDhcpServerAtmEntry),
     FIELD_SIZE(ATMARP_INTERFACE, pDhcpServerAtmEntry)
  },
#endif // DHCP_OVER_ATM

	//
	//  ---- WMI Information ---
	//
#if ATMARP_WMI
#if DBG
//	ULONG						aaiw_sig;			// Signature to help debugging
  {
    "aaiw_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaiw_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaiw_sig)
  },
#endif

//	struct _ATMARP_IF_WMI_INFO *pIfWmiInfo;
  {
    "pIfWmiInfo",
     FIELD_OFFSET(ATMARP_INTERFACE, pIfWmiInfo),
     FIELD_SIZE(ATMARP_INTERFACE, pIfWmiInfo)
  },
#endif // ATMARP_WMI

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_INTERFACE = {
    "ATMARP_INTERFACE",
    "i",
     typeid_ATMARP_INTERFACE,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_INTERFACE),
     rgfi_ATMARP_INTERFACE,
     FIELD_OFFSET(ATMARP_INTERFACE, pNextInterface) // offset to next pointer.
};

//
// STRUCTURES CONCERNING TYPE "ATMARP_ATM_ENTRY"
//


BITFIELD_INFO rgAtmEntryFlagsInfo[] =
{
	{
	"IDLE",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_IDLE
	},

	{
	"ACTIVE",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_ACTIVE
	},

	{
	"CLOSING",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_CLOSING
	},

	{
	"UCAST",
	AA_ATM_ENTRY_TYPE_MASK,
	AA_ATM_ENTRY_TYPE_UCAST
	},

	{
	"NUCAST",
	AA_ATM_ENTRY_TYPE_MASK,
	AA_ATM_ENTRY_TYPE_NUCAST
	},


	{
	NULL
	}
};

TYPE_INFO type_ATMARP_ATM_ENTRY_FLAGS = {
    "",
    "",
    typeid_NULL,
    fTYPEINFO_ISBITFIELD,
    sizeof(ULONG),
    NULL,
    0,
    rgAtmEntryFlagsInfo
};

STRUCT_FIELD_INFO  rgfi_ATMARP_ATM_ENTRY[] =
{

#if DBG
  {
    "aae_sig",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, aae_sig),
     FIELD_SIZE(ATMARP_ATM_ENTRY, aae_sig)
  },
#endif


//	struct _ATMARP_ATM_ENTRY *	pNext;
  {
    "pNext",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pNext),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pNext)
  },
//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, RefCount),
     FIELD_SIZE(ATMARP_ATM_ENTRY, RefCount)
  },
//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Flags),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Flags),
     0, // flags
	 &type_ATMARP_ATM_ENTRY_FLAGS
  },


#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Lock),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Lock)
  },
#endif

     // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pInterface),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pInterface)
  },


// struct _ATMARP_VC *             pVcList;        // List of VCs to this ATM
  {
    "pVcList",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pVcList),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pVcList)
  },


// struct _ATMARP_VC *				pBestEffortVc;	// One of the Best Effort VCs here
  {
    "pBestEffortVc",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pBestEffortVc),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pBestEffortVc)
  },
// struct _ATMARP_IP_ENTRY *		pIpEntryList;	// List of IP entries that
  {
    "pIpEntryList",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pIpEntryList),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pIpEntryList)
  },

// ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
  {
    "ATMAddress",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, ATMAddress),
     FIELD_SIZE(ATMARP_ATM_ENTRY, ATMAddress)
  },

#if 0
// ATM_ADDRESS						ATMSubAddress;
  {
    "ATMSubAddress",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, ATMSubAddress),
     FIELD_SIZE(ATMARP_ATM_ENTRY, ATMSubAddress)
  },
#endif // 0

#ifdef IPMCAST
// struct _ATMARP_IPMC_ATM_INFO *	pMcAtmInfo;		// Additional info for multicast
  {
    "pMcAtmInfo",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pMcAtmInfo),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pMcAtmInfo)
  },
#endif // IPMCAST


#if DBG
//UCHAR Refs[AE_REFTYPE_COUNT];
  {
    "Refs",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Refs),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Refs)
  },
#endif //DBG

	{
		NULL
	}


};

TYPE_INFO type_ATMARP_ATM_ENTRY = {
    "ATMARP_ATM_ENTRY",
    "ae",
     typeid_ATMARP_ATM_ENTRY,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_ATM_ENTRY),
     rgfi_ATMARP_ATM_ENTRY,
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pNext) // offset to next pointer.
};

//
// STRUCTURES CONCERNING TYPE "ATMARP_IP_ENTRY"
//

BITFIELD_INFO rgIpEntryFlagsInfo[] =
{

	{
	"IDLE",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_IDLE
	},

	{
	"ARPING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_ARPING
	},

	{
	"INARPING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_INARPING
	},
	{
	"RESOLVED",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_RESOLVED
	},

	{
	"COMM_ERROR",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_COMM_ERROR
	},

	{
	"ABORTING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_ABORTING
	},

	{
	"AGED_OUT",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_AGED_OUT
	},

	{
	"SEEN_NAK",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_SEEN_NAK
	},


#ifdef IPMCAST

#define MC	AA_IP_ENTRY_ADDR_TYPE_NUCAST
//			
//				We use this to only dump other multicast-related fields
//				if this field is set.

	{
	"MC_NO_REVALIDATION",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_NO_REVALIDATION
	},

	{
	"MC_REVALIDATE",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_REVALIDATE
	},

	{
	"MC_REVALIDATING",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_REVALIDATING
	},


	{
	"MC_IDLE",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_IDLE
	},

	{
	"MC_AWAIT_MULTI",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_AWAIT_MULTI
	},

	{
	"MC_DISCARDING_MULTI",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_DISCARDING_MULTI
	},

	{
	"MC_RESOLVED",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_RESOLVED
	},

	{
	"UCAST",
	AA_IP_ENTRY_ADDR_TYPE_MASK,
	AA_IP_ENTRY_ADDR_TYPE_UCAST
	},

	{
	"NUCAST",
	AA_IP_ENTRY_ADDR_TYPE_MASK,
	AA_IP_ENTRY_ADDR_TYPE_NUCAST
	},

#endif // IPMCAST


	{
	"STATIC",
	AA_IP_ENTRY_TYPE_MASK,
	AA_IP_ENTRY_IS_STATIC
	},

	{
		NULL
	}
};


TYPE_INFO type_ATMARP_IP_ENTRY_FLAGS = {
    "",
    "",
    typeid_NULL,
    fTYPEINFO_ISBITFIELD,
    sizeof(ULONG),
    NULL,
    0,
    rgIpEntryFlagsInfo
};


STRUCT_FIELD_INFO  rgfi_ATMARP_IP_ENTRY[] =
{

#if DBG
  {
    "aip_sig",
     FIELD_OFFSET(ATMARP_IP_ENTRY, aip_sig),
     FIELD_SIZE(ATMARP_IP_ENTRY, aip_sig)
  },
#endif

//	IP_ADDRESS						IPAddress;		// IP Address
  {
    "IPAddress",
     FIELD_OFFSET(ATMARP_IP_ENTRY, IPAddress),
     FIELD_SIZE(ATMARP_IP_ENTRY, IPAddress)
  },

//	struct _ATMARP_IP_ENTRY *	pNextEntry;
  {
    "pNextEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextEntry)
  },

//	struct _ATMARP_IP_ENTRY *		pNextToAtm;		// List of entries pointing to
  {
    "pNextToAtm",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextToAtm),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextToAtm)
  },

//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Flags),
     FIELD_SIZE(ATMARP_IP_ENTRY, Flags),
     0, // flags
	 &type_ATMARP_IP_ENTRY_FLAGS
  },

//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_IP_ENTRY, RefCount),
     FIELD_SIZE(ATMARP_IP_ENTRY, RefCount)
  },

#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Lock),
     FIELD_SIZE(ATMARP_IP_ENTRY, Lock)
  },
#endif

     // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pInterface),
     FIELD_SIZE(ATMARP_IP_ENTRY, pInterface)
  },


//	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
  {
    "pAtmEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pAtmEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pAtmEntry)
  },


#ifdef IPMCAST

//	struct _ATMARP_IP_ENTRY *		pNextMcEntry;	// Next "higher" Multicast IP Entry
  {
    "pNextMcEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextMcEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextMcEntry)
  },

//	USHORT							NextMultiSeq;	// Sequence Number expected
  {
    "NextMultiSeq",
     FIELD_OFFSET(ATMARP_IP_ENTRY, NextMultiSeq),
     FIELD_SIZE(ATMARP_IP_ENTRY, NextMultiSeq)
  },

													// in the next MULTI
#if 0
	USHORT							Filler;
#endif // 0

#endif // IPMCAST


//	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
  {
    "Timer",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Timer),
     FIELD_SIZE(ATMARP_IP_ENTRY, Timer)
  },


//	ULONG							RetriesLeft;
  {
    "RetriesLeft",
     FIELD_OFFSET(ATMARP_IP_ENTRY, RetriesLeft),
     FIELD_SIZE(ATMARP_IP_ENTRY, RetriesLeft)
  },

//	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
  {
    "PacketList",
     FIELD_OFFSET(ATMARP_IP_ENTRY, PacketList),
     FIELD_SIZE(ATMARP_IP_ENTRY, PacketList)
  },

// RouteCacheEntry *				pRCEList;		// List of Route Cache Entries
  {
    "pRCEList",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pRCEList),
     FIELD_SIZE(ATMARP_IP_ENTRY, pRCEList)
  },

#if 0
#ifdef CUBDD
	SINGLE_LIST_ENTRY				PendingIrpList;	// List of IRP's waiting for
													// this IP address to be resolved.
#endif // CUBDD
#endif// 0

#if DBG
//UCHAR Refs[IE_REFTYPE_COUNT];
  {
    "Refs",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Refs),
     FIELD_SIZE(ATMARP_IP_ENTRY, Refs)
  },
#endif //DBG

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_IP_ENTRY = {
    "ATMARP_IP_ENTRY",
    "ip",
     typeid_ATMARP_IP_ENTRY,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_IP_ENTRY),
     rgfi_ATMARP_IP_ENTRY,
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextToAtm) // offset to next pointer.
};


//
// STRUCTURES CONCERNING TYPE "ATMARP_VC"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_VC[] =
{

#if DBG
  {
    "avc_sig",
     FIELD_OFFSET(ATMARP_VC, avc_sig),
     FIELD_SIZE(ATMARP_VC, avc_sig)
  },
#endif


//	struct _ATMARP_VC *	pNextVc;
  {
    "pNextVc",
     FIELD_OFFSET(ATMARP_VC, pNextVc),
     FIELD_SIZE(ATMARP_VC, pNextVc)
  },



//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_VC, RefCount),
     FIELD_SIZE(ATMARP_VC, RefCount)
  },

#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_VC, Lock),
     FIELD_SIZE(ATMARP_VC, Lock)
  },
#endif

//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_VC, Flags),
     FIELD_SIZE(ATMARP_VC, Flags)
  },


	//	NDIS_HANDLE						NdisVcHandle;	// For NDIS calls
  {
    "NdisVcHandle",
     FIELD_OFFSET(ATMARP_VC, NdisVcHandle),
     FIELD_SIZE(ATMARP_VC, NdisVcHandle)
  },

  // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_VC, pInterface),
     FIELD_SIZE(ATMARP_VC, pInterface)
  },


//	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
  {
    "pAtmEntry",
     FIELD_OFFSET(ATMARP_VC, pAtmEntry),
     FIELD_SIZE(ATMARP_VC, pAtmEntry)
  },


//	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
  {
    "PacketList",
     FIELD_OFFSET(ATMARP_VC, PacketList),
     FIELD_SIZE(ATMARP_VC, PacketList)
  },




//	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
  {
    "Timer",
     FIELD_OFFSET(ATMARP_VC, Timer),
     FIELD_SIZE(ATMARP_VC, Timer)
  },

//	ULONG							RetriesLeft;
  {
    "RetriesLeft",
     FIELD_OFFSET(ATMARP_VC, RetriesLeft),
     FIELD_SIZE(ATMARP_VC, RetriesLeft)
  },

#ifdef GPC
//	PVOID							FlowHandle;		// Points to Flow Info struct
  {
    "FlowHandle",
     FIELD_OFFSET(ATMARP_VC, FlowHandle),
     FIELD_SIZE(ATMARP_VC, FlowHandle)
  },
#endif // GPC



//	ATMARP_FILTER_SPEC				FilterSpec;		// Filter Spec (Protocol, port)
  {
    "FilterSpec",
     FIELD_OFFSET(ATMARP_VC, FilterSpec),
     FIELD_SIZE(ATMARP_VC, FilterSpec)
  },

//	ATMARP_FLOW_SPEC				FlowSpec;		// Flow Spec (QoS etc) for this conn
  {
    "FlowSpec",
     FIELD_OFFSET(ATMARP_VC, FlowSpec),
     FIELD_SIZE(ATMARP_VC, FlowSpec)
  },

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_VC = {
    "ATMARP_VC",
    "vc",
     typeid_ATMARP_VC,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_VC),
     rgfi_ATMARP_VC,
     FIELD_OFFSET(ATMARP_VC, pNextVc) // offset to next pointer.
};


TYPE_INFO *g_rgAAC_Types[] =
{
    &type_ATMARP_GLOBALS,
    &type_ATMARP_ADAPTER,
    &type_ATMARP_INTERFACE,
    &type_ATMARP_ATM_ENTRY,
    &type_ATMARP_IP_ENTRY,
    &type_ATMARP_VC,

    NULL
};

#if 0
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.

} GLOBALVAR_INFO;
#endif

GLOBALVAR_INFO g_rgAAC_Globals[] =
{
    {
        "AtmArpGlobalInfo",
        "aag",
         &type_ATMARP_GLOBALS,
         0,
         sizeof(AtmArpGlobalInfo),
         0
    },


    {
        "AtmArpProtocolCharacteristics",
        "pc",
         NULL,
         0,
         sizeof(AtmArpProtocolCharacteristics),
         0
    },

    {
        "AtmArpClientCharacteristics",
        "cc",
         NULL,
         0,
         sizeof(AtmArpClientCharacteristics),
         0
    },

    {
    NULL
    }
};

UINT_PTR
AAC_ResolveAddress(
		TYPE_INFO *pType
		);

NAMESPACE AAC_NameSpace = {
			g_rgAAC_Types,
			g_rgAAC_Globals,
			AAC_ResolveAddress
			};

void
AAC_CmdHandler(
	DBGCOMMAND *pCmd
	);

void
do_aac(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &AAC_NameSpace);
	if (pCmd)
	{
		//DumpCommand(pCmd);
		DoCommand(pCmd, AAC_CmdHandler);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;

}

void
do_help(PCSTR args)
{
    return;
}


void
AAC_CmdHandler(
	DBGCOMMAND *pCmd
	)
{
	MyDbgPrintf("Handler called \n");
}


UINT_PTR
AAC_ResolveAddress(
		TYPE_INFO *pType
		)
{
	UINT_PTR uAddr = 0;
	UINT uOffset = 0;
	BOOL fRet = FALSE;
	UINT_PTR uParentAddress = 0;

	static UINT_PTR uAddr_AtmArpGlobalInfo;

	//
	// If this type has a parent (container) type, we will use the containing
	// type's cached address if its available, else we'll resolve the
	// containers type. The root types are globals -- we do an
	// expression evaluation for them.
	//

    switch(pType->uTypeID)
    {

    case typeid_ATMARP_GLOBALS:
		if (!uAddr_AtmArpGlobalInfo)
		{
  			uAddr_AtmArpGlobalInfo =
					 dbgextGetExpression("atmarpc!AtmArpGlobalInfo");
			pType->uCachedAddress =  uAddr_AtmArpGlobalInfo;
		}
    	uAddr  = uAddr_AtmArpGlobalInfo;
    	if (uAddr)
    	{
    		fRet = TRUE;
    	}
    	break;

    case typeid_ATMARP_ADAPTER:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_GLOBALS.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_GLOBALS);
		}
		if (uParentAddress)
		{
    		uOffset =  FIELD_OFFSET(ATMARP_GLOBALS, pAdapterList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress+uOffset,
								&uAddr,
								"ATMARP_GLOBALS::pAdapterList"
								);
		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
		}
		break;

    case typeid_ATMARP_INTERFACE:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ADAPTER.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ADAPTER);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ADAPTER, pInterfaceList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ADAPTER::pInterfaceList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_ATM_ENTRY:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_INTERFACE.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_INTERFACE);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_INTERFACE, pAtmEntryList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_INTERFACE::pAtmEntryList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_IP_ENTRY:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ATM_ENTRY.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ATM_ENTRY);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ATM_ENTRY, pIpEntryList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ATM_ENTRY::pIpEntryList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_VC:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ATM_ENTRY.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ATM_ENTRY);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ATM_ENTRY, pVcList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ATM_ENTRY::pVcList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

	default:
		MYASSERT(FALSE);
		break;

    }

	if (!fRet)
	{
		uAddr = 0;
	}

	MyDbgPrintf("ResolveAddress[%s] returns 0x%08lx\n", pType->szName, uAddr);
    return uAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\ndis.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	ndis.c	- DbgExtension Structure information specific to NDIS.SYS

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     04-26-98    Created

Notes:

--*/


#include "precomp.h"
//#include <ndis.h>
//#include <ndismini.h>


enum
{
    typeid_NDIS_MINIPORT_BLOCK,
    typeid_NDIS_M_DRIVER_BLOCK
};


extern TYPE_INFO *g_rgTypes[];
//
// STRUCTURES CONCERNING TYPE "NDIS_MINIPORT_BLOCK"
//

STRUCT_FIELD_INFO  rgfi_NDIS_MINIPORT_BLOCK[] =
{

  {
    "NullValue",
     FIELD_OFFSET(NDIS_MINIPORT_BLOCK, NullValue),
     FIELD_SIZE(NDIS_MINIPORT_BLOCK, NullValue)
  },
  {
  	NULL
  }


};

TYPE_INFO type_NDIS_MINIPORT_BLOCK = {
    "NDIS_MINIPORT_BLOCK",
    "mpb",
     typeid_NDIS_MINIPORT_BLOCK,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(NDIS_MINIPORT_BLOCK),
     rgfi_NDIS_MINIPORT_BLOCK,
     FIELD_OFFSET(NDIS_MINIPORT_BLOCK, NextMiniport) // offset to next pointer.
};


//
// STRUCTURES CONCERNING TYPE "NDIS_M_DRIVER_BLOCK"
//


STRUCT_FIELD_INFO  rgfi_NDIS_M_DRIVER_BLOCK[] =
{
  {
    "MiniportQueue",
     FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, MiniportQueue),
     FIELD_SIZE(NDIS_M_DRIVER_BLOCK, MiniportQueue)
  },
  {
  	NULL
  }

};

TYPE_INFO type_NDIS_M_DRIVER_BLOCK = {
    "NDIS_M_DRIVER_BLOCK",
    "mdb",
     typeid_NDIS_M_DRIVER_BLOCK,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(NDIS_M_DRIVER_BLOCK),
     rgfi_NDIS_M_DRIVER_BLOCK,
     FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, NextDriver) // offset to next pointer.
};



TYPE_INFO *g_rgNDIS_Types[] =
{
    &type_NDIS_MINIPORT_BLOCK,
    &type_NDIS_M_DRIVER_BLOCK,

    NULL
};


GLOBALVAR_INFO g_rgNDIS_Globals[] = 
{

	//
	// Check out aac.c for examples of how to add information about global
	// structures...
	//

    {
    NULL
    }

};

UINT_PTR
NDIS_ResolveAddress(
		TYPE_INFO *pType
		);

NAMESPACE NDIS_NameSpace = {
		g_rgNDIS_Types,
		g_rgNDIS_Globals,
		NDIS_ResolveAddress
		};

void
NdisCmdHandler(
	DBGCOMMAND *pCmd
	);

void
do_ndis(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &NDIS_NameSpace);
	if (pCmd)
	{
		DumpCommand(pCmd);
		DoCommand(pCmd, NdisCmdHandler);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;
}

//mdb list= (PNDIS_M_DRIVER_BLOCK)GetExpression("ndis!ndisMiniDriverList");

void
NdisCmdHandler(
	DBGCOMMAND *pCmd
	)
{
	MyDbgPrintf("Handler called \n");
}

UINT_PTR
NDIS_ResolveAddress(
		TYPE_INFO *pType
		)
{
	UINT_PTR uAddr = 0;
	UINT uOffset = 0;
	BOOLEAN fRet = FALSE;
	UINT_PTR uParentAddress = 0;

// NDIS!ndisMiniDriverList
	static UINT_PTR uAddr_ndisMiniDriverList;

	//
	// If this type has a parent (container) type, we will use the containing
	// type's cached address if its available, else we'll resolve the
	// containers type. The root types are globals -- we do an
	// expression evaluation for them.
	//

    switch(pType->uTypeID)
    {


    case typeid_NDIS_M_DRIVER_BLOCK:
    	//
    	// We pick up the global ndisMiniDriverList address if we haven't
    	// already...
    	//
		if (!uAddr_ndisMiniDriverList)
		{
  			uAddr_ndisMiniDriverList =
					 dbgextGetExpression("ndis!ndisMiniDriverList");
		}
		uAddr = uAddr_ndisMiniDriverList;

		if (uAddr)
		{
			fRet =  TRUE;
		}
		break;

    case typeid_NDIS_MINIPORT_BLOCK:
    	//
    	//
    	//
		uParentAddress =  type_NDIS_M_DRIVER_BLOCK.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  NDIS_ResolveAddress(&type_NDIS_M_DRIVER_BLOCK);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, MiniportQueue);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"NDIS_M_DRIVER_BLOCK::MiniportQueue"
								);

		#if 1
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

	default:
		MYASSERT(FALSE);
		break;

    }

	if (!fRet)
	{
		uAddr = 0;
	}

	MyDbgPrintf("ResolveAddress[%s] returns 0x%08lx\n", pType->szName, uAddr);
    return uAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\common.h ===
//
// Handlers for top-level extension commands.
//

void
do_aac(PCSTR args);

void
do_ndis(PCSTR args);

void
do_help(PCSTR args);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\parse.c ===
#include "precomp.h"

typedef struct
{
    eKEYWORD eKey;
    char *szzAliases;   // Multi-sz string of aliases.
                        // First one is the "official" name.
} KEYWORDREC;

KEYWORDREC rgKeywords[] =
{
    {keywordHELP,           "help\0"},
    {keywordDUMP_TYPE,      "dt\0"},
    {keywordDUMP_GLOBALS,   "dg\0"},
    {keywordL,              "L\0"},
    {keywordNULL,           NULL}      // sentinel, must be last.
};


//
// Contains the list of tokens created by parsing an input string.
//
typedef struct
{
    TOKEN *rgToks;
    UINT cToks;
    UINT uNextFreeTok;
    UINT uCurrentTok;

    char *rgStringBuf;
    UINT cchStringBuf;
    UINT uNextFree;
    BOOL fFinalized;
    CRITICAL_SECTION crit;

} TOKLIST;


DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace);

TOKLIST
*toklist_create(void);

void
toklist_destroy(TOKLIST *pTL);

BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID);

BOOL
toklist_finalize(TOKLIST *pTL);


TOKEN *
toklist_get_next(TOKLIST *pTL);

BOOL
toklist_restart(TOKLIST *pTL);

void
toklist_dump(TOKLIST *pTL);

void
tok_dump(TOKEN *pTok);


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput);

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      );

UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      );

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      );

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    );

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok);

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    );


ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);


DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *pNameSpace
)
{
    TOKLIST *pTL = NULL;
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = NULL;
    UINT cbInput =  (lstrlenA(szInput)+1)*sizeof(*szInput);
    char *szRWInput
        = LocalAlloc(LPTR, cbInput);

    // MyDbgPrintf("Parse(\"%s\");\n", szInput);

    if (szRWInput)
    {
        CopyMemory(szRWInput, szInput, cbInput);
        pTL =  toklist_create();
    }

    if (pTL)
    {

#if TEST_TOKLIST_ADD
    #if 0
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
    #else
        char rgInput[] =
                 // "*.?[]/"
                 // "help "
                 // "0x12340 0 1 02 "
                 // "kelp"
                "dt if[*].*handle* 0x324890 L 5"
                ;
        toklist_tokenize (pTL, rgInput);
    #endif

#endif // TEST_TOKLIST_ADD

        toklist_tokenize(pTL, szRWInput);

        toklist_finalize(pTL);

        // toklist_dump(pTL);

        pCmd = parse_command(pTL, pNameSpace);

        if (!pCmd)
        {
            toklist_destroy(pTL);
        }
        pTL = NULL;
    }

    if (szRWInput)
    {
        LocalFree(szRWInput);
        szRWInput = NULL;
    }

    return pCmd;

}

void
FreeCommand(
    DBGCOMMAND *pCmd
)
{
    if (pCmd)
    {
        TOKLIST *pTL =  (TOKLIST*)pCmd->pvContext;
        if (pTL)
        {
            // MyDbgPrintf("FreeCommand:\n");
            // toklist_restart(pTL);
            // toklist_dump(pTL);
            toklist_destroy((TOKLIST*)pCmd->pvContext);
        }

        ZeroMemory(pCmd, sizeof(*pCmd));
        LocalFree(pCmd);
    }
}

void
DumpCommand(
    DBGCOMMAND *pCmd
)
{
    char *szCmd = "";
    char *szObjPreStar = "";
    char *szObj = "";
    char *szObjSufStar = "";
    char *szObjVecRange = "";
    char *szDot = "";
    char *szSubObjPreStar = "";
    char *szSubObj = "";
    char *szSubObjSufStar = "";
    char *szObjAddr  = "";
    char *szObjCount = "";
    char rgVecRange[64];
    char rgObjAddr[64];
    char rgObjCount[64];


    if (!pCmd) goto end;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:       szCmd = "dt"; break;
    case cmdDUMP_GLOBALS:    szCmd = "dg"; break;
    case cmdHELP:            szCmd = "help"; break;
    default:            szCmd = "<unknown>"; break;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
    {
        szObjPreStar = "*";
    }
    if (pCmd->ptokObject)
    {
        szObj = pCmd->ptokObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
    {
        szObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_VECTOR_INDEX))
    {
        wsprintfA(
            rgVecRange,
            "[%ld,%ld]",
            pCmd->uVectorIndexStart,
            pCmd->uVectorIndexEnd
            );

        szObjVecRange = rgVecRange;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_SUBOBJECT))
    {
        szDot = ".";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
    {
        szSubObjPreStar = "*";
    }

    if (pCmd->ptokSubObject)
    {
        szSubObj = pCmd->ptokSubObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
    {
        szSubObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_ADDRESS))
    {
        wsprintf(rgObjAddr, "0x%lx", pCmd->uObjectAddress);
        szObjAddr = rgObjAddr;
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
    {
        wsprintf(rgObjCount, " L 0x%lx", pCmd->uObjectCount);
        szObjCount = rgObjCount;
    }

    {
    #if 0
        MyDbgPrintf(
            "\nCOMMAND = {"
            "cmd=%lu;"
            "F=0x%lx;"
            "O=0x%lx;"
            "SO=0x%lx;"
            "VS=%ld;"
            "VE=%ld;"
            "OA=0x%lx;"
            "OC=%ld;"
            "}\n",
            pCmd->ePrimaryCmd,
            pCmd->uFlags,
            pCmd->ptokObject,
            pCmd->ptokSubObject,
            pCmd->uVectorIndexStart,
            pCmd->uVectorIndexEnd,
            pCmd->uObjectAddress,
            pCmd->uObjectCount
            );
    #else
        MyDbgPrintf(
            "COMMAND = \"%s %s%s%s%s%s%s%s%s%s%s\";\n",
            szCmd,
            szObjPreStar,
            szObj,
            szObjSufStar,
            szObjVecRange,
            szDot,
            szSubObjPreStar,
            szSubObj,
            szSubObjSufStar,
            szObjAddr,
            szObjCount
        );
    #endif
    }
end:
    return;
}


#define TL_LOCK(_ptl)   EnterCriticalSection(&(_ptl)->crit)
#define TL_UNLOCK(_ptl) LeaveCriticalSection(&(_ptl)->crit)


TOKLIST
*toklist_create(void)
{
    TOKLIST *pTL = LocalAlloc(LPTR, sizeof(TOKLIST));

    if (pTL)
    {
        InitializeCriticalSection(&pTL->crit);
    }

    return pTL;
}


void
toklist_destroy(TOKLIST *pTL)
{
    if (pTL)
    {
        TL_LOCK(pTL);

        if (pTL->rgToks)
        {
            LocalFree(pTL->rgToks);
        }

        if (pTL->rgStringBuf)
        {
            LocalFree(pTL->rgStringBuf);
        }

        DeleteCriticalSection(&pTL->crit);

        ZeroMemory(pTL, sizeof(*pTL));
        LocalFree(pTL);
    }
}


BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID)
{
    BOOL fRet = FALSE;
    TOKEN *pTok = NULL;
    UINT cch  = 0;
    char *pc  = NULL;

    TL_LOCK(pTL);

    if (pTL->fFinalized) goto end;

    //
    // Make sure we've enough space for the token.
    //
    if (pTL->uNextFreeTok >= pTL->cToks)
    {
        UINT cNewToks = 2*pTL->cToks+1;
        TOKEN *pNewToks = (TOKEN*) LocalAlloc(LPTR, cNewToks*sizeof(*pNewToks));
        if (!pNewToks) goto end;

        if (pTL->rgToks)
        {
            CopyMemory(
                pNewToks,
                pTL->rgToks,
                pTL->uNextFreeTok*sizeof(*pNewToks)
                );

            LocalFree(pTL->rgToks);
        }

        pTL->rgToks = pNewToks;
        pTL->cToks = cNewToks;
    }

    //
    // Now deal with szOrig
    //

    cch = lstrlenA(szOrig)+1;

    if ((pTL->uNextFree+cch+1) > pTL->cchStringBuf) // "+1" because multisz
    {
        UINT cNewStr = 2*pTL->cchStringBuf+cch+1;
        char *pNewStr = LocalAlloc(LPTR, cNewStr*sizeof(*pNewStr));
        if (!pNewStr) goto end;

        if (pTL->rgStringBuf)
        {
            CopyMemory(
                pNewStr,
                pTL->rgStringBuf,
                pTL->uNextFree*sizeof(*pNewStr)
                );
            LocalFree(pTL->rgStringBuf);

            //
            // Since we've reallocated the string buffer, we must
            // now fixup the string pointers in the list of tokens
            //
            {
                TOKEN *pTok = pTL->rgToks;
                TOKEN *pTokEnd = pTok + pTL->uNextFreeTok;
                for(; pTok<pTokEnd; pTok++)
                {
                    pTok->szStr = pNewStr + (pTok->szStr - pTL->rgStringBuf);
                }
            }
        }

        pTL->rgStringBuf = pNewStr;
        pTL->cchStringBuf = cNewStr;
    }

    //
    // At this point we know we have enough space...
    //

    //
    // See if we already have this string and if not copy it...
    //
    {
        BOOL fFound = FALSE;
        for (pc = pTL->rgStringBuf; *pc; pc+=(lstrlenA(pc)+1))
        {
            if (!lstrcmpiA(pc, szOrig))
            {
                // found it
                fFound = TRUE;
                break;
            }
        }


        if (!fFound)
        {
            MYASSERT(pTL->uNextFree == (UINT) (pc-pTL->rgStringBuf));

            CopyMemory(
                pc,
                szOrig,
                cch*sizeof(*szOrig)
                );
            pTL->uNextFree += cch;
        }
    }

    if (eTok == tokIDENTIFIER)
    {
        //
        // For this special case we ignore the passed-in uID and
        // use instead the offset of the string in our string table.
        //
        uID =  (UINT) (pc - pTL->rgStringBuf);
    }

    pTok = pTL->rgToks+pTL->uNextFreeTok++;
    pTok->eTok = eTok;
    pTok->uID = uID;
    pTok->szStr = pc;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}


BOOL
toklist_finalize(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);

    if (pTL->fFinalized) goto end;

    pTL->fFinalized = TRUE;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}

BOOL
toklist_restart(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);

    if (!pTL->fFinalized) goto end;
    pTL->uCurrentTok = 0;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}


TOKEN *
toklist_get_next(TOKLIST *pTL)
{
    TOKEN *pTok = NULL;

    TL_LOCK(pTL);

    if (!pTL->fFinalized) goto end;

    if (pTL->uCurrentTok >= pTL->uNextFreeTok)
    {
        MYASSERT(pTL->uCurrentTok == pTL->uNextFreeTok);
        goto end;
    }
    else
    {
        pTok = pTL->rgToks+pTL->uCurrentTok++;
    }

end:
    TL_UNLOCK(pTL);


    return pTok;
}

void
toklist_dump(TOKLIST *pTL)
{
    TL_LOCK(pTL);

    MyDbgPrintf(
            "\nTOKLIST 0x%08lx = {"
            "fFin=%lu cToks=%lu  uNextFreeTok=%lu cchStr=%lu uNextFree=%lu"
            "}\n",
            pTL,
            pTL->fFinalized,
            pTL->cToks,
            pTL->uNextFreeTok,
            pTL->cchStringBuf,
            pTL->uNextFree
        );

    if (pTL->fFinalized)
    {
        TOKEN *pTok =  toklist_get_next(pTL);
        while(pTok)
        {
            tok_dump(pTok);

            pTok =  toklist_get_next(pTL);
        }
        toklist_restart(pTL);
    }

    TL_UNLOCK(pTL);
}


void
tok_dump(TOKEN *pTok)
{
    MyDbgPrintf(
            "\tTOKEN 0x%08lx = {eTok=%lu uID=0x%08lx sz=\"%s\"}\n",
            pTok,
            pTok->eTok,
            pTok->uID,
            pTok->szStr
        );

}


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput)
{
    UINT cTokens = 0;
    char *pc = szInput;
    char c = 0;
    BOOL fRet = FALSE;

    for (; (c=*pc)!=0; pc++)
    {
        switch(c)
        {

        case '*':
            fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
            continue;

        case '.':
            fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
            continue;

        case '?':
            fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
            continue;

        case '[':
            fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
            continue;

        case ']':
            fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
            continue;

        case '/':
            fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
            continue;

        case '\n':
        case '\r':
        case '\t':
        case ' ':
            continue;

        default:

            {
                UINT uCharsParsed =  0;
                char *pcEnd = pc;
                char cSave = 0;

                //
                // We'll locate the end of the potential keyword/number/ident:
                // and temprarily place a NULL char there.
                //
                //
                while (__iscsym(*pcEnd))
                {
                    pcEnd++;
                }

                cSave = *pcEnd;
                *pcEnd = 0;

                if (__iscsymf(c))
                {
                    // This may be a keyword, hex number or identifier. We try
                    // in this order
                    uCharsParsed =  toklist_parse_keyword(
                                                pTL,
                                                rgKeywords,
                                                pc
                                                );

                    if (!uCharsParsed && isxdigit(c))
                    {
                        //
                        // Didn't find a keyword and this is a hex digit --
                        // let's try to parse it as a hex number...
                        //
                        uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                    }

                    if (!uCharsParsed)
                    {
                        //
                        // Parse it as an identifier...
                        //
                        uCharsParsed =  toklist_parse_identifier(pTL, pc);
                    }

                    if (!uCharsParsed)
                    {
                        //
                        // This is an error
                        //
                        MyDbgPrintf("Error at %s\n", pc);
                        goto end;
                    }
                }
                else if (isxdigit(c))
                {
                   uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                }

                //
                // If we've parsed anything it should be ALL of the string...
                //
                MYASSERT(!uCharsParsed || uCharsParsed==(UINT)lstrlenA(pc));

                //
                // Restore the char we replaced by NULL.
                //
                *pcEnd = cSave;

                if (!uCharsParsed)
                {
                    //
                    // Syntax error
                    //
                    MyDbgPrintf("Error at %s\n", pc);
                    goto end;
                }
                else
                {
                    pc+= (uCharsParsed-1); // "-1" because of pc++ in
                                            // for clause above.
                }
            }
        }
    }

end:

return cTokens;

}

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      )
//
// Assumes 1st char is valid.
//
{
    UINT uRet = 0;
    KEYWORDREC *pkr = rgKeywords;

    if (!__iscsymf(*pcInput)) goto end;

    for (;pkr->eKey!=keywordNULL; pkr++)
    {
        if (!lstrcmpi(pcInput, pkr->szzAliases))
        {
            //
            // found it
            //
            toklist_add(pTL, tokKEYWORD,  pcInput,  pkr->eKey);
            uRet = lstrlenA(pcInput);
            break;
        }
    }

end:

    return uRet;
}

UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      )
{
    char *pc = pcInput;
    UINT uValue = 0;
    char c;
    UINT u;

    //
    //  look for and ignore the "0x" prefix...
    //
    if (pc[0]=='0' && (pc[1]=='x' || pc[1]=='X'))
    {
        pc+=2;
    }


    //
    // Reject number if it is doesn't contain hex digits or is too large
    //
    for (u=0; isxdigit(*pc) && u<8; pc++,u++)
    {
        UINT uDigit = 0;

        char c = *pc;
        if (!isdigit(c))
        {
            c = (char) _toupper(c);
            uDigit = 10 + c - 'A';
        }
        else
        {
            uDigit = c - '0';
        }

        uValue = (uValue<<4)|uDigit;
    }

    if (!u || *pc)
    {
        return 0;
    }
    else
    {
        toklist_add(pTL, tokNUMBER, pcInput, uValue);
        return pc - pcInput;
    }
}

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      )
{
    UINT uRet = 0;

    if (!__iscsymf(*pcInput)) goto end;

    toklist_add(pTL, tokIDENTIFIER,  pcInput,  0);
    uRet = lstrlenA(pcInput);

end:

    return uRet;
}

DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace)
{
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = LocalAlloc(LPTR, sizeof(*pCmd));
    TOKEN *pTok =  NULL;
    BOOL fSyntaxError = FALSE;

    if (!pCmd) goto end;

    toklist_restart(pTL);
    pTok =  toklist_get_next(pTL);

    if (!pTok) goto end;

	pCmd->pNameSpace = pNameSpace;
    //
    // Now let's step through the token list, building up our command
    // information.
    //

    // look for help or ?
    if (pTok->eTok == tokQUESTION
       || (pTok->eTok == tokKEYWORD && pTok->uID == keywordHELP))
    {
        pCmd->ePrimaryCmd = cmdHELP;
        fRet = cmd_parse_help(pCmd, pTL);
        goto end;
    }

    fSyntaxError = TRUE;
    fRet = FALSE;

	//
	// Here we would look for other keywords. Currently there are none
	// (dt and dg are not used anymore).
	//
	//
	#if OBSOLETE
    if (pTok->eTok == tokKEYWORD)
    {
           BOOL fDump = FALSE;
		if (pTok->uID == keywordDUMP_TYPE)
        {
            pCmd->ePrimaryCmd = cmdDUMP_TYPE;
            fDump = TRUE;
        }
        else if (pTok->uID == keywordDUMP_GLOBALS)
        {
            pCmd->ePrimaryCmd = cmdDUMP_GLOBALS;
            fDump = TRUE;
        }
        ...
	}
	#endif // OBSOLETE

	pCmd->ePrimaryCmd = cmdDUMP_TYPE;

	//
	// Pares the form a[b].*c* d L e
	//
	{

		BOOL   fPrefixStar = FALSE;
		// we look for patterns like...
		//!aac <type> . <field> <address> L <count> <flags>
		//!aac <type> [index] . <field>   L <count> <flags>
		//
		//!aac i[*].*handle* 0x324890 L 5
		//[*]ident[*]\[<range>\][.][*]ident[*] <number> [L <number>]

		UINT uFlags;            // One or more fCMDFLAG_*
		TOKEN *ptokObject;     // eg <type>
		TOKEN *ptokSubObject;  // eg <field>
		UINT uVectorIndexStart; // if[0]
		UINT uVectorIndexEnd; // if[0]
		UINT uObjectAddress; // <address>
		UINT uObjectCount; // L 10
	
		//
		// 1. Look for primary star
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			fPrefixStar = TRUE;
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 2.  Look for ident
		//
		if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
		{
			//
			// This will try to convert keywords and numbers to idents if
			// possible.
			//
			pCmd->ptokObject = pTok;
			pTok = toklist_get_next(pTL);
		}

		//
		// 3. Look for suffix * for object.
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 4. Look for Vector Range
		//
		if (pTok && pTok->eTok == tokLBRAC)
		{
			//
			// For now, we support either a single * or a single number.
			//
			pTok = toklist_get_next(pTL);

			if (!pTok)
			{
				goto end; // Error -- incomplete vector range
			}
			else
			{
				if (pTok->eTok == tokSTAR)
				{
					pCmd->uVectorIndexStart = 0;
					pCmd->uVectorIndexEnd = (UINT) -1;
				}
				else if (pTok->eTok == tokNUMBER)
				{
					pCmd->uVectorIndexStart =
					pCmd->uVectorIndexEnd = pTok->uID;
				}
				else
				{
					goto end; // failure...
				}

				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_VECTOR_INDEX);

				pTok = toklist_get_next(pTL);

				if (!pTok || pTok->eTok != tokRBRAC)
				{
					goto end; // failure ... expect RBRAC.
				}
				else
				{
					pTok = toklist_get_next(pTL);
				}
			}
		}

		//
		// 5. Look for DOT
		//
		if (pTok && pTok->eTok == tokDOT)
		{
			fPrefixStar = FALSE;
			pTok = toklist_get_next(pTL);

			// We expect ([*]ident[*]|*)
			//
			// 1. Look for primary star
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				fPrefixStar = TRUE;
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// 2.  Look for ident
			//
			if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
			{
				//
				// This will try to convert keywords and numbers to idents if
				// possible.
				//
				pCmd->ptokSubObject = pTok;
				pTok = toklist_get_next(pTL);
			}

			//
			// 3. Look for suffix * for object.
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// At this point we should either have a non-null IDENT
			// or the PREFIX START should be set for the object
			// (indicateing "a.*").
			//
			if (    pCmd->ptokSubObject
 				|| (pCmd->uFlags & fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_SUBOBJECT);
			}
			else
			{
				goto end; // error
			}
		}

		//
		// 6. Look for object address
		//
		if (pTok && pTok->eTok == tokNUMBER)
		{
			pCmd->uObjectAddress = pTok->uID;
			CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS);
			pTok = toklist_get_next(pTL);
		}

		//
		// 7. Look for object count
		//
		if (   pTok && pTok->eTok == tokKEYWORD
			&& pTok->uID == keywordL)
		{
			pTok = toklist_get_next(pTL);
			if (pTok && pTok->eTok == tokNUMBER)
			{
				pCmd->uObjectCount = pTok->uID;
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_COUNT);
				pTok = toklist_get_next(pTL);
			}
			else
			{
				// error
			}
		}

		//
		// At this point we should be done...
		//
		if (pTok)
		{
			// error -- extra garbage...
		}
		else
		{
			// Success.
			fRet = TRUE;
			fSyntaxError = FALSE;
		}
	}

end:

    if (fRet)
    {
        pCmd->pvContext = pTL;
    }
    else
    {
        if (fSyntaxError)
        {
            MyDbgPrintf("Unexpected: %s\n", (pTok) ? pTok->szStr : "<null>");
        }
        else
        {
            MyDbgPrintf("Parse failed\n");
        }

        if (pCmd)
        {
            ZeroMemory(pCmd, sizeof(*pCmd));
            LocalFree(pCmd);
            pCmd = NULL;
        }
    }

    if (pTL)
    {
        toklist_restart(pTL);
    }

    return pCmd;
}

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    )
{
    TOKEN *pTok = toklist_get_next(pTL);

    if (!pTok || pTok->eTok == tokSTAR)
    {
        // User type "help" or "help *"
        MyDbgPrintf("DO HELP\n");
    }

    return TRUE;
}

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok)
//
// This gets called when an identifier is expected -- so we see if this
// particular token can be interpreted as in identifier. Some examples
// of when we can do this:
//  dt if.*20334     <--- the "20334" could be part of an identifier, because
//                        of the * prefix.
//
//  dt L.help        <--- both "L" and "help" would have been parsed as
//                        keywords, but here they are intended to be
//                        identifiers.
//  dt abc.def       <--- abc and def would have been parsed as numbers (they
//                        are valid hex numbers), but are intended to be
//                        identifiers.
{
    BOOL fRet = FALSE;

    switch(pTok->eTok)
    {

    case tokNUMBER:
        //
        // We could do this, but subject to some restrictions...
        //
        if (!__iscsymf(pTok->szStr[0]) &&  !fPrefixStar)
        {
            break; // Can't to this: no prefix wild-card (*) and the
                   // number starts with a non-letter.
        }

        // FALL THROUGH ...

    case tokKEYWORD:
        //
        // We can go ahead, but we must make pTok.uID now the offset
        // from the start of the internal string array.
        //
        {
            char *pc = pTL->rgStringBuf;

            for (; *pc; pc+=(lstrlenA(pc)+1))
            {
                if (!lstrcmpiA(pc, pTok->szStr))
                {
                    // found it
                    // MyDbgPrintf("FORCE_TO_IDENT:\nOLD:\n");
                    // tok_dump(pTok);
                    pTok->uID =  (UINT) (pc - pTL->rgStringBuf);
                    pTok->eTok = tokIDENTIFIER;
                    // MyDbgPrintf("NEW:\n");
                    // tok_dump(pTok);
                    fRet = TRUE;

                    break;
                }
            }
        }
        break;

    case tokIDENTIFIER:
        //
        // nothing to do...
        //
        fRet = TRUE;
        break;

    default:
        //
        // Can't convert any other kind of token to identifier...
        //
        break;

    }

    return fRet;
}

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler)
{
    char *szMsg = NULL;

//    pCmd->pfnSpecialHandler = pfnHandler;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:
        DoDumpType(pCmd);
        break;
    case cmdDUMP_GLOBALS:
        DoDumpGlobals(pCmd);
        break;
    case cmdHELP:
        DoHelp(pCmd);
        break;

    default:
        szMsg = "Unknown command\n";
        break;
    }


    if (szMsg)
    {
        MyDbgPrintf(szMsg);
    }

    return;
}


typedef struct
{
    DBGCOMMAND *pCmd;
    TYPE_INFO  *pType;

} MY_LIST_NODE_CONTEXT;

typedef
ULONG
MyDumpListNode (
		UINT_PTR uNodeAddr,
		UINT uIndex,
		void *pvContext
		);

void
DoDumpType(DBGCOMMAND *pCmd)
{
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;
    TYPE_INFO **ppti = NULL;
    UINT uMatchCount = 0;
    TYPE_INFO *ptiDump = NULL;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }

    }

    //
    // search through global type array for type pName.
    //
    for(ppti=pCmd->pNameSpace->pTypes;*ppti;ppti++)
    {
        TYPE_INFO *pti = *ppti;
        bool fMatch  = !szPattern
                   || !_stricmp(szPattern, pti->szShortName)
                   || pfnMatchingFunction(szPattern,  pti->szName);

        if (fMatch)
        {
        #if 0
            MyDbgPrintf(
                "TYPE \"%2s\" %s (%lu Bytes)\n",
                pti->szShortName,
                pti->szName,
                pti->cbSize
                );
		#endif // 0
            uMatchCount++;
            if (!ptiDump)
            {
                ptiDump = pti;
            }

#if 0
            uAddr =
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
#endif // 0
        }
    }

    if (!uMatchCount)
    {
        MyDbgPrintf(
            "Could not find type \"%s\"",
             (szPattern ? szPattern : "*")
             );
    }
    else if (   uMatchCount==1)
    {

		UINT uObjectCount = 1;
		UINT uStartIndex = 0;
		UINT uObjectAddress = 0;
		BOOLEAN fList =  TYPEISLIST(ptiDump)!=0;

    	if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
			uObjectAddress = pCmd->uObjectAddress;
		}

		//
		// Determine start index.
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX))
		{
			uStartIndex =  pCmd->uVectorIndexStart;
			if (fList && !CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_COUNT))
			{
				uObjectCount =  pCmd->uVectorIndexEnd - uStartIndex;
				if (uObjectCount != (UINT) -1)
				{
					uObjectCount++;
				}
			}
		}

		//
		// Determine object count...
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
		{
			uObjectCount =  pCmd->uObjectCount;
		}

		//
		// If no address is specified, we'll try to resolve it ...
		//
    	if (!CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
    		BOOLEAN fUseCache = FALSE;

			//
			// Algorithm for determining whether to use cache or to resolve
			// address:
			//
			if (ptiDump->uCachedAddress)
			{
				//
				// Except for the special case of [0], we will use
				// the the cached value.
				//
				if (!(		uStartIndex ==0
					 	&& 	uObjectCount==1
					 	&&  CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX)))
				{
					fUseCache = TRUE;
				}
			}

			if (fUseCache)
			{
				uObjectAddress = ptiDump->uCachedAddress;
			}
			else
			{
				if (pCmd->pNameSpace->pfnResolveAddress)
				{
					uObjectAddress = pCmd->pNameSpace->pfnResolveAddress(
														ptiDump
														);
				}
			}
    	}

    	if (uObjectAddress && uObjectCount)
    	{

			//
			// Prune these to "reasonable" values.
			//
			if (uObjectCount > 100)
			{
				MyDbgPrintf("Limiting object count to 100\n");
				uObjectCount = 100;
			}

			if (fList)
			{
				MY_LIST_NODE_CONTEXT Context;
				Context.pCmd = pCmd;
				Context.pType = ptiDump;

				WalkList(
					uObjectAddress,		// start address
					ptiDump->uNextOffset, 		// next offset
					uStartIndex,
					uStartIndex+uObjectCount-1, // end index
					&Context,					// context
					NodeFunc_DumpType,			// function
					(char *) ptiDump->szName
					);

				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success
				//
				if (uObjectCount==1)
				{
					WalkList(
						uObjectAddress,			// start address
						ptiDump->uNextOffset, 	// next offset
						uStartIndex,
						uStartIndex,  			// end index
						ptiDump,					// context
						NodeFunc_UpdateCache,	// function
						(char *) ptiDump->szName
						);
				}
			}
			else
			{
				UINT cbSize =  ptiDump->cbSize;
				UINT uAddr  =  uObjectAddress + uStartIndex*cbSize;
				UINT uEnd   =  uAddr + uObjectCount*cbSize;
				//
				// For arays, compute offset to start address
				//
				uObjectAddress = uAddr;

				for (; uAddr<uEnd; uAddr+=cbSize)
				{
					MyDumpObject(
						pCmd,
						ptiDump,
						uAddr,
						ptiDump->cbSize,
						ptiDump->szName
						);
				}
				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success
				//
				if (uObjectCount==1)
				{
					ptiDump->uCachedAddress = uObjectAddress;
				}
			}

    	}
    	else
    	{
    		MyDbgPrintf(
				"Could not resolve address for object %s\n",
				ptiDump->szName
				);
    	}
    }

}

void
DoDumpGlobals(DBGCOMMAND *pCmd)
{
    GLOBALVAR_INFO *pgi = pCmd->pNameSpace->pGlobals;
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }

    }

    //
    // Run through our list of globals, and if the entry is selected,
    // we will display it.
    //
    for (;pgi->szName; pgi++)
    {
        bool fMatch  = !szPattern
                       || !_stricmp(szPattern, pgi->szShortName)
                       || pfnMatchingFunction(szPattern,  pgi->szName);
        if (fMatch)
        {
            pgi->uAddr = dbgextGetExpression(pgi->szName);
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
        }
    }
}

void
DoHelp(
	DBGCOMMAND *pCmd // OPTIONAL
	)
{
	//
	//
	//
    MyDbgPrintf("help unimplemented\n");
}

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    )
{
    UINT uMatchFlags = 0;
    char *szFieldSpec  = NULL;

    if (pCmd->ptokSubObject)
    {
        szFieldSpec = pCmd->ptokSubObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_SUBSTRING;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
        {
            uMatchFlags = fMATCH_SUFFIX;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_PREFIX;
        }
    }

    if (!pType)
    {
        DumpMemory(
            uAddr,
            cbSize,
            0,
            szDescription
            );
    }
    else
    {
        DumpStructure(pType, uAddr, szFieldSpec, uMatchFlags);
    }
}

ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MY_LIST_NODE_CONTEXT *pContext =  (MY_LIST_NODE_CONTEXT*) pvContext;

	MyDbgPrintf("[%lu] ", uIndex);
	MyDumpObject (
		pContext->pCmd,
		pContext->pType,
		uNodeAddr,
		pContext->pType->cbSize,
		pContext->pType->szName
		);
	return 0;
}

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	TYPE_INFO *pti = (TYPE_INFO*) pvContext;

	if (pti->uCachedAddress != uNodeAddr)
	{
		MyDbgPrintf(
			"Updating Cache from 0x%lx to 0x%lx\n",
			pti->uCachedAddress,
			uNodeAddr
			);
	}
	pti->uCachedAddress = uNodeAddr;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\dummy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dummy.c	- dummy global vars.

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created

Notes:

--*/


#include "precomp.h"
#if TESTPROGRAM


ATMARP_GLOBALS		DummyAtmArpGlobalInfo;
ATMARP_ADAPTER		DummyAtmArpAdapter;

ATMARP_INTERFACE	DummyAtmArpInterface0;
ATMARP_INTERFACE	DummyAtmArpInterface1;
ATMARP_INTERFACE	DummyAtmArpInterface2;

ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry0;
ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry1;
ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry2;

ATMARP_IP_ENTRY	DummyAtmArpIpEntry0;
ATMARP_IP_ENTRY	DummyAtmArpIpEntry1;
ATMARP_IP_ENTRY	DummyAtmArpIpEntry2;

ATMARP_VC	DummyAtmArpVc0;
ATMARP_VC	DummyAtmArpVc1;
ATMARP_VC	DummyAtmArpVc2;

NDIS_PROTOCOL_CHARACTERISTICS DummyAtmArpProtocolCharacteristics;
NDIS_CLIENT_CHARACTERISTICS DummyAtmArpClientCharacteristics;

void *pvDummyAtmArpGlobalInfo              = &DummyAtmArpGlobalInfo;
void *pvDummyAtmArpProtocolCharacteristics =&DummyAtmArpProtocolCharacteristics;
void *pvDummyAtmArpClientCharacteristics   =  &DummyAtmArpClientCharacteristics;

void
init_ATMARP_INTERFACE(ATMARP_INTERFACE *pI, ATMARP_INTERFACE *pNext);
void
init_ATMARP_ADAPTER(ATMARP_ADAPTER *pA, ATMARP_ADAPTER *pNext);
void
init_ATMARP_GLOBALS(ATMARP_GLOBALS *pG);
void
init_ATMARP_ATM_ENTRY(ATMARP_ATM_ENTRY *pAE, ATMARP_ATM_ENTRY *pNext);
void
init_ATMARP_IP_ENTRY(ATMARP_IP_ENTRY *pIP, ATMARP_IP_ENTRY *pNext);
void
init_ATMARP_VC(ATMARP_VC *pVC, ATMARP_VC *pNext);

void setup_dummy_vars(void)
{
	//
	// Set up dummy list of VCs
	//
	init_ATMARP_VC(&DummyAtmArpVc0, &DummyAtmArpVc1);
	init_ATMARP_VC(&DummyAtmArpVc1, &DummyAtmArpVc2);
	init_ATMARP_VC(&DummyAtmArpVc2, NULL);

	// Set up dummy list of IP entries..
	//
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry0, &DummyAtmArpIpEntry1);
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry1, &DummyAtmArpIpEntry2);
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry2, NULL);

	//
	// Set up dummy list of atm entries..
	//
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry0, &DummyAtmArpAtmEntry1);
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry1, &DummyAtmArpAtmEntry2);
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry2, NULL);

	//
	// Set up dummy list of interfaces..
	//
	init_ATMARP_INTERFACE(&DummyAtmArpInterface0, &DummyAtmArpInterface1);
	init_ATMARP_INTERFACE(&DummyAtmArpInterface1, &DummyAtmArpInterface2);
	init_ATMARP_INTERFACE(&DummyAtmArpInterface2, NULL);

	//
	// Set up dummy adapter structure.
	//
	init_ATMARP_ADAPTER(&DummyAtmArpAdapter, NULL);

	//
	// Set up dummy gobal info structure.
	//
	init_ATMARP_GLOBALS(&DummyAtmArpGlobalInfo);

}

void
init_ATMARP_INTERFACE(ATMARP_INTERFACE *pI, ATMARP_INTERFACE *pNext)
{
#if DBG
	pI->aai_sig = aai_signature;
#endif // DBG

	pI->pNextInterface = pNext;
	pI->pAtmEntryList = &DummyAtmArpAtmEntry0;

}

void
init_ATMARP_ADAPTER(ATMARP_ADAPTER *pA, ATMARP_ADAPTER *pNext)
{
#if DBG
	pA->aaa_sig = aaa_signature;
#endif

	pA->pNextAdapter = pNext;
	pA->pInterfaceList = &DummyAtmArpInterface0;
	pA->InterfaceCount = 3;
}

void
init_ATMARP_GLOBALS(ATMARP_GLOBALS *pG)
{
#if DBG
	pG->aag_sig  =  aag_signature;
#endif

	pG->pAdapterList = &DummyAtmArpAdapter;
	pG->AdapterCount = 1;
}

void
init_ATMARP_ATM_ENTRY(ATMARP_ATM_ENTRY *pAE, ATMARP_ATM_ENTRY *pNext)
{
#if DBG
	pAE->aae_sig = aae_signature;
#endif // DBG

	pAE->pNext = pNext;
	pAE->pIpEntryList = &DummyAtmArpIpEntry0;
	pAE->pVcList = &DummyAtmArpVc0;

	pAE->Flags =  AA_ATM_ENTRY_CLOSING;

}

void
init_ATMARP_IP_ENTRY(ATMARP_IP_ENTRY *pIP, ATMARP_IP_ENTRY *pNext)
{
#if DBG
	pIP->aip_sig = aip_signature;
#endif // DBG

	pIP->pNextToAtm = pNext;
	pIP->Flags =   AA_IP_ENTRY_ADDR_TYPE_NUCAST| AA_IP_ENTRY_MC_REVALIDATING;


}

void
init_ATMARP_VC(ATMARP_VC *pVC, ATMARP_VC *pNext)
{
#if DBG
	pVC->avc_sig = avc_signature;
#endif // DBG

	pVC->pNextVc = pNext;

}

#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>

#include <windef.h>
#include <winbase.h>
#include <winuser.h>
#include <wdbgexts.h>
#include <stdio.h>

#include <ntosp.h>
#include <ndis.h>

#include "util.h"
#include "parse.h"


#if BINARY_COMPATIBLE
#include "cmddk.h"
#endif // BINARY_COMPATIBLE

#include <atm.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#ifndef ATMARP_WIN98
#include <tdistat.h>
#include <ipifcons.h>
#endif

#include <atmarpif.h>

#ifdef NEWARP

#ifdef _PNP_POWER_
#include <ntddip.h>
#include <llipif.h>
#else

#ifdef ATMARP_WIN98
#define _PNP_POWER_ 1
#endif

#include <ntddip.h>

#ifdef ATMARP_WIN98
#undef _PNP_POWER_
#undef NT
#include <tdistat.h>
#endif

#include <llipif.h>

#ifdef ATMARP_WIN98
#define NT 1
#endif

#endif // _PNP_POWER_

#else

#include <llipif0.h>

#endif // NEWARP

#include <ntddip.h>

#include "system.h"
#include "debug.h"

#ifdef GPC
#include "gpcifc.h"
#include "traffic.h"
#include "ntddtc.h"
#endif // GPC

#include "aaqos.h"
#include "arppkt.h"

#ifdef IPMCAST
#include "marspkt.h"
#endif // IPMCAST

#include "atmarp.h"
#include "cubdd.h"
#include "macros.h"

#ifdef ATMARP_WMI
#include <wmistr.h>
#include "aawmi.h"
#endif // ATMARP_WMI

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\main.c ===
#include "precomp.h"

#ifdef TESTPROGRAM

WINDBG_EXTENSION_APIS ExtensionApis;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );
//
// dprintf          (ExtensionApis.lpOutputRoutine)
// GetExpression    (ExtensionApis.lpGetExpressionRoutine)
// GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
// Disassm          (ExtensionApis.lpDisasmRoutine)
// CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
// ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
// WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
// GetContext       (ExtensionApis.lpGetThreadContextRoutine)
// SetContext       (ExtensionApis.lpSetThreadContextRoutine)
// Ioctl            (ExtensionApis.lpIoctlRoutine)
// StackTrace       (ExtensionApis.lpStackTraceRoutine)
//

#if 0
//
// Dummy global vars for "GetExpression".
//
UINT g1;
UINT g2;
#endif // 0

ULONG
DummyMyGetExpression (
    PCSTR lpExpression
    );
void setup_dummy_vars(void);

ULONG
WDBGAPI
MyGetExpression (
    PCSTR lpExpression
    )
{
	return DummyMyGetExpression(lpExpression);
}


ULONG
WDBGAPI
MyReadMemory (
    ULONG  offset,
    PVOID  lpBuffer,
    ULONG  cb,
    PULONG lpcbBytesRead
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory(lpBuffer, (void*)offset, cb);
        *lpcbBytesRead = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
    	MyDbgPrintf("Read memory exception at 0x%lu[%lu]\n", offset, cb);
        fRet = FALSE;
    }

    return fRet;
}

ULONG
WDBGAPI
MyWriteMemory(
    ULONG   offset,
    LPCVOID lpBuffer,
    ULONG   cb,
    PULONG  lpcbBytesWritten
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory((void*)offset, lpBuffer, cb);
        *lpcbBytesWritten = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    }

    return fRet;
}

void test_walklist(void);

int __cdecl main(
	int argc,
	char *argv[]
	)
{
    UINT u=0;

    ExtensionApis.lpOutputRoutine = printf;
    ExtensionApis.lpGetExpressionRoutine = MyGetExpression;
    ExtensionApis.lpReadProcessMemoryRoutine = MyReadMemory;
    ExtensionApis.lpWriteProcessMemoryRoutine = MyWriteMemory;

    WinDbgExtensionDllInit(
        &ExtensionApis,
        0xc, // MajorVersion,
        0x0 // MinorVersion
        );

	//
	// This sets up some dummy global variables.
	//
	setup_dummy_vars();
#if 0

	test_walklist();

#else // 0

    do
    {
        char rgch[256];

        printf("> ");
        u = scanf("%[^\n]", rgch);
        if (!u || u==EOF) break;

        // printf("Input = [%s]\n", rgch);

        if (*rgch == 'q') break;

        do_aac(rgch);

      // skip past EOL
      {
          char c;
          u = scanf("%c", &c);
      }

    } while (u!=EOF);

#endif // 0

  return 0;
}

typedef struct _LIST
{
	struct _LIST *pNext;
	UINT  uKey;
} LIST;

LIST L3 = {NULL, 0x4000};
LIST L2 = {&L3,  0x3000};
LIST L1 = {&L2,  0X2000};
LIST L0 = {&L1,  0X1000};

ULONG
NodeFunc_DumpLIST (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	LIST L;
	BOOL fRet = dbgextReadMemory(
					uNodeAddr,
					&L,
					sizeof(L),
					"LIST"
					);
	if (fRet)
	{
		MyDbgPrintf(
			"LIST[%lu]@0x%08lx = {Next=0x%08lx, Key=0x%lx}\n",
			uIndex,
			uNodeAddr,
			L.pNext,
			L.uKey
			);
	}
	return 0;
}

void test_walklist(void)
{
	UINT uRet = 0;

	uRet =  WalkList(
				(UINT_PTR) &L0,
				0,
				0, // 0 start
				-1,// -1 end
				NULL,
				//NodeFunc_DumpAddress,
				NodeFunc_DumpLIST,
				"Test list"
				);

}

ULONG
DummyMyGetExpression (
    PCSTR lpExpression
    )
{
	extern void *pvDummyAtmArpGlobalInfo;
	extern void *pvDummyAtmArpProtocolCharacteristics;
	extern void *pvDummyAtmArpClientCharacteristics;


    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpGlobalInfo"))
    {
        return (ULONG) pvDummyAtmArpGlobalInfo;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpProtocolCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpProtocolCharacteristics;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpClientCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpClientCharacteristics;
    }

    return 0;

}
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\netepvcm.inf: $(_INX)\netepvcm.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)


$(O)\netepvcp.inf: $(_INX)\netepvcp.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "initguid.h"
#include "sfiltern_i.c"

// Global
//#include "sfnetcfg_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CBaseClass, CBaseClass)
END_OBJECT_MAP()





/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{


    if (dwReason == DLL_PROCESS_ATTACH)
    {
		TraceMsg (L"-- DllMain  Attach\n");

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		TraceMsg (L"-- DllMain  Detach\n");

		_Module.Term();
    }



    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	TraceMsg (L"--DllCanUnloadNow\n");

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	TraceMsg (L"--DllGetClassObject\n");

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    TraceMsg (L"--DllRegisterServer\n");

    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TraceMsg (L"--DllUnregisterServer\n");

    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\implinc.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>


//EXTERN_C const IID IID_INetLanConnectionUiInfo = {0xC08956A6,0x1CD3,0x11D1,{0xB1,0xC5,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	util.c	- Generic Debugger Extension Utilities

Abstract:

	Taken from AliD's ndiskd(ndiskd.c).

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created (taken fron AliD's ndiskd (ndiskd.c).

Notes:

--*/
#include "precomp.h"
#include "common.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?




/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD)ListEntry.Flink == dwListHeadAddr || (DWORD)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static UCHAR *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

        
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    g_pfnDbgPrintf = dprintf;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s IPATM Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{

	//
	// for now don't bother to version check
	//
	return;
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
//	VOID
//	PrintName(
//		PUNICODE_STRING Name
//		);
// print a unicode string
// Note: the Buffer field in unicode string is unmapped
//
VOID
PrintName(
	PUNICODE_STRING Name
	)
{
	USHORT i;
	WCHAR ubuf[256];
	UCHAR abuf[256];
	
	if (!GetString((DWORD)Name->Buffer, ubuf, (ULONG)Name->Length))
	{
		return;
	}

	for (i = 0; i < Name->Length/2; i++)
	{
		abuf[i] = (UCHAR)ubuf[i];
	}
	abuf[i] = 0;

	dprintf("%s",abuf);
}

MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf = NULL;




bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != cb)
    {
        ERRPRT("Read  failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != cb)
    {
        ERRPRT("Write failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }
    return 0;
}


bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pu,
                    sizeof(*pu),
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != sizeof(*pu))
    {
        ERRPRT("Read  failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    &u,
                    sizeof(uOffset),
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != sizeof(u))
    {
        ERRPRT("Write failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }
    return fRet;
}

UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    )
{
    UINT_PTR uRet =  GetExpression(pcszExpression);
    
    //
    // At such a point we use this for something besides pointers,
    // we will remove the check below.
    //

    if (!uRet)
    {
        ERRPRT("Eval  failed: \"%s\"\n", pcszExpression);
    }

    return uRet;
}


void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags)
{
    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );


    DumpMemory(
        uAddr,
        pType->cbSize,
        0,
        pType->szName
        );
    
    //
    // Dump bytes...
    //

    return;
}

BYTE rgbScratchBuffer[100000];

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    )
{
    bool fTruncated = FALSE;
    bool fRet = FALSE;
    UINT cbLeft = cb;
    char *pbSrc = rgbScratchBuffer;

    if (cbLeft>1024)
    {
        cbLeft = 1024;
        fTruncated = TRUE;
    }
    
    fRet = dbgextReadMemory(
            uAddr,
            rgbScratchBuffer,
            cbLeft,
            (char*)pszDescription
            );

    if (!fRet) goto end;

    #define ROWSIZE 16 // bytes
    //
    // Dump away...
    //
    while (cbLeft)
    {
        char rgTmp_dwords[ROWSIZE];
        char rgTmp_bytes[ROWSIZE];
        char *pb=NULL;
        UINT cbRow = ROWSIZE;
        if (cbRow > cbLeft)
        {
            cbRow = cbLeft;
        }
    
        
        memset(rgTmp_dwords, 0xff, sizeof(rgTmp_dwords));
        memset(rgTmp_bytes,  ' ', sizeof(rgTmp_bytes));

        memcpy(rgTmp_dwords, pbSrc, cbRow);
        memcpy(rgTmp_bytes,  pbSrc, cbRow);
        
        // sanitize bytes
        for (pb=rgTmp_bytes; pb<(rgTmp_bytes+sizeof(rgTmp_bytes)); pb++)
        {
            char c = *pb;
            if (c>=0x20 && c<0x7f) // isprint is too permissive.
            {
                if (*pb=='\t')
                {
                    *pb=' ';
                }
            }
            else
            {
                *pb='.';
            }
        }

        dprintf(
            "    %08lx: %08lx %08lx %08lx %08lx |%4.4s|%4.4s|%4.4s|%4.4s|\n",
            uAddr,
            ((DWORD*) rgTmp_dwords)[0],
            ((DWORD*) rgTmp_dwords)[1],
            ((DWORD*) rgTmp_dwords)[2],
            ((DWORD*) rgTmp_dwords)[3],
        #if 1
            rgTmp_bytes+0,
            rgTmp_bytes+4,
            rgTmp_bytes+8,
            rgTmp_bytes+12
        #else
            "aaaabbbbccccdddd",
            "bbbb",
            "cccc",
            "dddd"
        #endif
            );

        cbLeft -= cbRow;
        pbSrc += cbRow;
        uAddr += cbRow;
    }

#if 0
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
#endif // 

end:

    return fRet;
}


bool
MatchPrefix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}

bool
MatchSuffix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        szString += (uS-uP);
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }
    return fRet;
}

bool
MatchSubstring(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        const char *szLast =  szString + (uS-uP);
        do
        {
            fRet = (_memicmp(szPattern, szString, uP)==0);

        } while (!fRet && szString++ < szLast);
    }

    return fRet;
}

bool
MatchExactly(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP==uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}


bool
MatchAlways(const char *szPattern, const char *szString)
{
    return TRUE;
}

void
DumpBitFields(
		ULONG  			Flags,
    	BITFIELD_INFO	rgBitFieldInfo[]
		)
{
	BITFIELD_INFO *pbf = rgBitFieldInfo;

	for(;pbf->szName; pbf++)
	{
		if ((Flags & pbf->Mask) == pbf->Value)
		{
			MyDbgPrintf(" %s", pbf->szName);
		}
	}
}

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    )
{
    //
    // Determine field comparision function ...
    //
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

    //
    // Pick a selection function ...
    //
    if (szFieldSpec)
    {
        if (uFlags & fMATCH_SUBSTRING)
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (uFlags & fMATCH_SUFFIX)
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (uFlags & fMATCH_PREFIX)
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }
    }

    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );

    //
    // Run through all the fields in this type, and if the entry is selected,
    // we will display it.
    //
    {
        STRUCT_FIELD_INFO *pField = pType->rgFields;
        for (;pField->szFieldName; pField++)
        {
            bool fMatch  = !szFieldSpec
                           || pfnMatchingFunction(szFieldSpec, pField->szFieldName);
            if (fMatch)
            {
                UINT_PTR uFieldAddr = uAddr + pField->uFieldOffset;

                // special-case small fields...
                if (pField->uFieldSize<=sizeof(ULONG_PTR))
                {

					ULONG_PTR Buf=0;
    				BOOL fRet = dbgextReadMemory(
										uFieldAddr,
										&Buf,
										pField->uFieldSize,
                        				(char*)pField->szFieldName
										);
					if (fRet)
					{
						// print it as a hex number

						MyDbgPrintf(
							"\n%s\t[%lx,%lx]: 0x%lx",
							pField->szFieldName,
							pField->uFieldOffset,
							pField->uFieldSize,
							Buf
							);

						//
						// If it's an embedded object and it's a bitfield,
						// print the bitfields...
						//
						if (	FIELD_IS_EMBEDDED_TYPE(pField)
							&&  TYPEISBITFIELD(pField->pBaseType) )
						{
							DumpBitFields(
									Buf,
								    pField->pBaseType->rgBitFieldInfo
								    );
							
						}
						
						MyDbgPrintf("\n");
	
					}
					continue;
				}

            #if 0
                MyDbgPrintf(
                    "%s\ndc 0x%08lx L %03lx %s\n",
                    pField->szSourceText,
                    uFieldAddr,
                    pField->uFieldSize,
                    pField->szFieldName
                    );
            #else // 1
                MyDbgPrintf(
                    "\n%s\t[%lx,%lx]\n",
                    pField->szFieldName,
                    pField->uFieldOffset,
                    pField->uFieldSize
                    );
            #endif // 1

                // if (szFieldSpec)
                {
                #if 0
                    MyDumpObjects(
                        pCmd,
                        pgi->pBaseType,
                        pgi->uAddr,
                        pgi->cbSize,
                        pgi->szName
                        );
                #endif // 0
                    DumpMemory(
                        uFieldAddr,
                        pField->uFieldSize,
                        0,
                        pField->szFieldName
                        );
                }
            }
        }
    }

    return;
}


DECLARE_API( help )
{
    do_help(args);
}


DECLARE_API( aac )
{
    do_aac(args);
}

ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MyDbgPrintf("[%lu] 0x%08lx\n", uIndex, uNodeAddr);
	return 0;
}

UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	)
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//
{
	UINT uIndex = 0;
	UINT_PTR uAddress = uStartAddress;
	BOOL fRet = TRUE;
	UINT uRet = 0;


	//
	// First skip until we get to uStart Index
	//
	for (;fRet && uAddress && uIndex < uStartIndex; uIndex++)
	{
		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}


	//
	// Now call pFunc with each node
	//
	for (;fRet && uAddress && uIndex <= uEndIndex; uIndex++)
	{
		uRet = pFunc(uAddress, uIndex, pvContext);

		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}

	pFunc = NodeFunc_DumpAddress;
	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( sfiltern )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( sfiltern ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\kdext\util.h ===
#define  MYASSERT(_cond) \
            ((_cond) ?  0 : MyDbgPrintf("ASSERTION FAILED\n"))


typedef int bool;


//
// Debugger Extension Primitives
//


bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    );


bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );
bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    );


UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    );


#if 0   // Not sure what this one is about...
void 
dbgextGetSymbol(
    void *offset,
    UCHAR *pchBuffer,
    UINT  *pDisplacement
    );
#endif // 0

typedef
void
(__cdecl *MYPWINDBG_OUTPUT_ROUTINE)(
    const char * lpFormat,
    ...
    );

extern MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf;

#define MyDbgPrintf g_pfnDbgPrintf


//
//  User Commands Parsing Support and Structures
//
typedef struct
{
    //TOKEN tokCmd;
    UINT uParam;
    UINT uFlags;

} COMMAND;

//!aac if@0x099900.*sig*
//!aac if[0].*sig*

struct _TYPE_INFO;

typedef
UINT_PTR
(*PFN_DUMP)(
				struct _TYPE_INFO *pType,
				UINT uFlags
				);
#define fDUMP_ONE_LINE_SUMMARY (0x1)

typedef struct
{
	char *szName;
	UINT Mask;
	UINT Value;

} BITFIELD_INFO;


typedef struct _TYPE_INFO
{
    const char *	szName;
    const char *	szShortName;
    UINT 			uTypeID;
    UINT 			uFlags;		// One or more fTYPEINFO_ flags.
    UINT 			cbSize;

    struct _STRUCT_FIELD_INFO *rgFields;

    UINT 			uNextOffset;
					// If this type is a list element, this is the offset
					// in bytes to the next pointer.
					// Only valid if uFlags contains fTYPEINFO_ISLIST
					
    BITFIELD_INFO	*rgBitFieldInfo;
    				//
    				// If this type is a bitfield, this this points
    				// to an array of BITFIELD_INFO structs, giving
    				// the set of valid bitfield constants that can
    				// be held in this bitfield.
    				//
    				// Note -- only one of rgFields and rgBitField info
    				// 		   should be non-null (both can be null).
    				//

	UINT_PTR		uCachedAddress; // Set to the address of this type that
									// was most recently referenced.


	PFN_DUMP		pfnDump;

} TYPE_INFO;



#define fTYPEINFO_ISLIST     (0x1<<0)
#define fTYPEINFO_ISBITFIELD (0x1<<1)

#define TYPEISLIST(_pType) 		((_pType)->uFlags & fTYPEINFO_ISLIST)
#define TYPEISBITFIELD(_pType) 	((_pType)->uFlags & fTYPEINFO_ISBITFIELD)

//
// STRUCT_FIELD_INFO contains information about a particular field of a struct.
//
typedef struct _STRUCT_FIELD_INFO
{
    const char *szFieldName;
    UINT uFieldOffset; // Offset in bytes from start of containing structure.
    UINT uFieldSize;
    UINT uFlags;  // one or more fFI_* flags define below
    TYPE_INFO *pBaseType;

} STRUCT_FIELD_INFO;


#define fFI_PTR     (0x1<<0)    // Field is a pointer
#define fFI_LIST    (0x1<<1)    // Field is a pointer to 1st element of a list
#define fFI_ARRAY   (0x1<<2)    // Field is an array (pointer to array if 
                                // fFI_PTR is set). 
#define fFI_OPAQUE  (0x1<<3)    // Treat object as opaque, of size uObjectSize.
                                // If set then fLIST must not be set.

#define FIELD_IS_EMBEDDED_TYPE(_pFI)  \
				(   !((_pFI)->uFlags & (fFI_PTR|fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is itself a valid type
		//

#define FIELD_IS_PTR_TO_TYPE(_pFI)  \
				(   ((_pFI)->uFlags & fFI_PTR) \
				 && !((_pFI)->uFlags & (fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is pointer to a valid type
		//

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)

//
// Information about a global variable.
//
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.
    
} GLOBALVAR_INFO;


typedef
UINT_PTR
(*PFN_RESOLVE_ADDRESS)(
				TYPE_INFO *pType
				);

typedef struct
{
	TYPE_INFO	**pTypes;
	GLOBALVAR_INFO *pGlobals;
	PFN_RESOLVE_ADDRESS pfnResolveAddress;

} NAMESPACE;

void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags);

#define fMATCH_SUBSTRING (0x1<<0)
#define fMATCH_PREFIX    (0x1<<1)
#define fMATCH_SUFFIX    (0x1<<2)

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    );

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    );

typedef bool (*PFNMATCHINGFUNCTION) (
                    const char *szPattern,
                    const char *szString
                    );

bool
MatchPrefix(const char *szPattern, const char *szString);

bool
MatchSuffix(const char *szPattern, const char *szString);

bool
MatchSubstring(const char *szPattern, const char *szString);

bool
MatchExactly(const char *szPattern, const char *szString);

bool
MatchAlways(const char *szPattern, const char *szString);

typedef ULONG (*PFNNODEFUNC)(
				UINT_PTR uNodeAddr,
				UINT uIndex,
				void *pvContext
				);
//
//	 PFNNODEFUNC is the prototype of the func passed into WalkList
//


UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	);
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//


ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);
//
//	This is a sample node function -- simply dumps the specfied address.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\mystring.cpp ===
#include "pch.h"
#pragma hdrstop


MyString::MyString()
{
	Zero();

	*data = L'\0';
	m_len = 0;
}

MyString::MyString(wchar_t *str)
{	
	Zero();
	m_len = wcslen(str);
	

	// Since strlen returns the number of characters in str, excluding the terminal NULL,
	// and since strncpy does not automatically append the terminal NULL, 
	// if m_len < MAX_LEN we want to copy m_len + 1 characters because we assume the 
	// last character of the source string is the terminal NULL.  Otherwise we explicitly 
	// set the last element to the terminal NULL.

	
	if (m_len >= MAX_LEN - 1){
		m_len = MAX_LEN - 1;
		wcsncpy(data, str, m_len);
		data[m_len] = L'\0';
	}
	else {
		wcscpy(data, str);
	}
}

MyString::MyString (const MyString& MyStr)
{

	Zero();
	wcscpy(data, MyStr.data);

	//
	// We are assuming MyStr is null -terminated
	//
	m_len = wcslen(MyStr.data);

	this->NullTerminate();

}


const MyString& MyString::operator= (PCWSTR lp)
{
	Zero();

	m_len = wcslen(lp);

	if (m_len > MAX_LEN-1)
	{
		m_len = MAX_LEN-1;
	}

	wcsncpy(data, lp, m_len);
	this->NullTerminate();

	
	return (*this);
}

const MyString& MyString::operator= (const MyString& MyStr)
{
	// We assume MyStr is null terminated
	Zero();
	wcscpy(data, MyStr.data);
	
	m_len = MyStr.m_len;

	this->NullTerminate();		

	return (*this);
}




const wchar_t* MyString::wcharptr()
{
	return data;
}


int MyString::len()
{
	return m_len;
}

void MyString::append(MyString str)
{
	wcsncat(data, str.data, MAX_LEN - m_len - 1);
	data[MAX_LEN-1]=L'\0';
	m_len = wcslen(data); 

}




void
MyString::append(const wchar_t *str)
{

	if (str == NULL )
	{
		return; 
	}
	
	wcsncat(data, str, MAX_LEN - m_len - 1);
	data[MAX_LEN-1]=L'\0';
	m_len = wcslen(data);

	return ;
}

int compare(MyString firstStr, MyString secondStr)
{
	return wcscmp(firstStr.wcharptr(), secondStr.wcharptr());
}




const wchar_t* MyString::c_str() const
{
	return (data);
}



void MyString::Zero()
{
	UINT i = 0;

	m_len = 0;

	for (i = 0; i < MAX_LEN; i++)
	{
		data[i] = 0;
	}

}




VOID
MyString::NullTerminate()
{
	data[m_len] = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\macros.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       M A C R O S. H
//
//  Contents:   Local declarations for the Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#ifndef _MACROS_H
#define _MACROS_H


// =================================================================
// Defines
#define FALL_THROUGH    // For informational purpose in a switch statement
#define NOTHING // For informational purpose  in a for loop
#define IM_NAME_LENGTH 0x2e // = len ("\Device\<Guid>") in unicode

// =================================================================
// string constants
//

static const WCHAR c_szAtmEpvcP[]               = L"ATMEPVCP";
static const WCHAR c_szEpvcDevice[]             = L"Device";

const WCHAR c_szSFilterParams[]         = L"System\\CurrentControlSet\\Services\\ATMEPVCP\\Parameters";
const WCHAR c_szSFilterNdisName[]       = L"ATMEPVCP";
const WCHAR c_szAtmAdapterPnpId[]       = L"AtmAdapterPnpId";
const WCHAR c_szUpperBindings[]         = L"UpperBindings";
const WCHAR c_szDevice[]                = L"\\Device\\"; 
const WCHAR c_szInfId_MS_ATMEPVCM[]     = L"MS_ATMEPVCM";
const WCHAR c_szBackslash[]             = L"\\";
const WCHAR c_szParameters[]            = L"Parameters";
const WCHAR c_szAdapters[]              = L"Adapters";
const WCHAR c_szRegKeyServices[]        = L"System\\CurrentControlSet\\Services";
const WCHAR c_szRegParamAdapter[]       = L"System\\CurrentControlSet\\Services\\ATMEPVCP\\Parameters\\Adapters";
const WCHAR c_szIMMiniportList[]            = L"IMMiniportList";
const WCHAR c_szIMiniportName[]         = L"Name";






// ====================================================================
// macros to be used.
//



#define ReleaseAndSetToNull(_O) \
    ReleaseObj(_O);             \
    _O = NULL ;             


#define TraceBreak(_s)  TraceMsg(_s);BREAKPOINT();              



#define MemAlloc(_Len) malloc(_Len);

#define MemFree(_pv)  free(_pv);

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


    
;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\resource.h ===
//#include <ncres.h>

#pragma once

#define IDR_REG_SAMPLE_FILTER 40001

#define IDD_SAMPLE_FILTER_GENERAL 1850
#define IDC_PARAM1                1851
#define IDC_BundleId              1852
#define IDC_UpperBindings         1853
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file for the sample filter
//
//  Notes:
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <initguid.h>
#include <devguid.h>
#include <MyString.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\mystring.h ===
#ifndef MYSTRING_H_
#define MYSTRING_H_



const MAX_LEN = 100;

#if DBG
void TraceMsg(PCWSTR szFormat, ...);
#else
inline void TraceMsg(PCWSTR szFormat, ...) {}
#endif

 

class MyString
{
private:
    int m_len;
    wchar_t data[MAX_LEN];
public:
    MyString();
    MyString(wchar_t *str);
    MyString(const MyString &);

    const MyString& operator= (PCWSTR  lp);
    const MyString& operator= (const MyString& MyStr);

    VOID append(const wchar_t* str);
    void append(MyString str);
    int len();
    const wchar_t* wcharptr();
    const wchar_t* c_str() const;
    void Zero();
    void NullTerminate();
};

int compare(MyString first, MyString second);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\proto.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       P R O T O . H
//
//  Contents:   Local declarations for the Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#ifndef _PROTOS_H
#define PROTOS_H


LRESULT 
CALLBACK 
SampleFilterDialogProc(
    HWND hWnd, 
    UINT uMsg,
    WPARAM wParam, 
    LPARAM lParam
    )   ;

    
UINT 
CALLBACK 
SampleFilterPropSheetPageProc(
    HWND hWnd, 
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    );


    
HRESULT 
HrOpenAdapterParamsKey(
    GUID* pguidAdapter,
    HKEY* phkeyAdapter
    );

    

ULONG 
ReleaseObj(
    IUnknown* punk
    );


ULONG 
AddRefObj (
    IUnknown* punk
    );





typedef enum _ADD_OR_REMOVE
{
    AddMiniport,
    RemoveMiniport

} ADD_OR_REMOVE;


HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    ADD_OR_REMOVE       AddOrRemove,
    INetCfgComponent**  ppnccMiniport
    );


HRESULT
HrInstallAdapter (
    INetCfgClassSetup*  pSetupClass,
    PCWSTR           pszComponentId,
    INetCfgComponent**  ppncc
    );


HRESULT
HrDeInstallAdapter (
    INetCfgClass*       pncClass,
    INetCfgClassSetup*  pSetupClass,
    PCWSTR              pszComponentId
    );

HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pNcbPath,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName);




//
// Reg.cpp functions begin here
//


HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey);


HRESULT
HrRegOpenAdapterGuid(
    IN HKEY phkeyAdapters,
    IN PGUID pAdapterGuid,
    IN BOOL fCreate,
    OUT HKEY *phGuidKey
    );


HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition);


HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult);

HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult);


HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey);



HRESULT
HrRegOpenAString(
    IN CONST WCHAR *pcszStr ,
    IN BOOL fCreate,
    OUT PHKEY phKey 
    );

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz);



HRESULT 
HrRegSetSz (
    HKEY hkey, 
    PCWSTR pszValueName, 
    PCWSTR pszValue
    );


HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData);


HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName);

HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime);



HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue);


HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize);


HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData);


HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue);

HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue);

HRESULT 
HrRegSetSz (
    HKEY hkey, 
    PCWSTR pszValueName, 
    PCWSTR pszValue
    );
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\reg.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "proto.h"
#include "macros.h"





//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates or opens the Adapters subkey to a component
//
//  Arguments:
//      pszComponentName [in]   The name of the component being
//      fCreate [in]            TRUE if the directory is to be created
//      phkey [out]             The handle to the Adapters subkey
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//
HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;

	TraceMsg (L"--> HrRegOpenAdapterKey \n");
 


    // Build the registry path
    strKey = c_szRegParamAdapter;

	
	//
	// Now do the operation on the registry
	//
	hr = HrRegOpenAString (strKey.c_str(), fCreate, phkey);
	

	if (hr != S_OK)
	{
		phkey = NULL;
	}

	TraceMsg (L"<-- HrRegOpenAdapterKey \n");
    return hr;
}




//
// Basic utility function
//

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz)
{
	if (psz)
	{
	 	return (wcslen (psz) + 1) * sizeof(WCHAR); 

	}
	else
	{
		return 0;
	}
}



//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterGuid
//
//  Purpose:    This creates and entry under the adapter key. The entry contains
//				Guid of the underlying adapter.
//
//  Arguments:
//	IN HKEY phkeyAdapters  - key - Service-><Protocol>->Parameters\Adapters entry,
//	IN PGUID pAdapterGuid - Guid of the underlying adapter
//	OUT PHKEY phGuidKey - The key to be used to access the new entry
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenAdapterGuid(
	IN HKEY phkeyAdapters,
	IN PGUID pAdapterGuid,
	IN BOOL	fCreate,
	OUT HKEY *phGuidKey
	)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;
    WCHAR 		szGuid[64];
    ULONG		lr = 0;


	TraceMsg (L"--> HrRegCreateAdapterGuid \n");
 


    // Build the registry path
    strKey = c_szRegParamAdapter;
	strKey.append(c_szBackslash);
	
	//
	// Convert the Guid to  a string
	//
	
    StringFromGUID2(
        *pAdapterGuid,
        szGuid,
        (sizeof(szGuid) / sizeof(szGuid[0])));


	//
	//  Append it to Services\<Protocl>\Parameters\Adapters\
 	//

	strKey.append(szGuid);



	TraceMsg(L"Check String of Adapter Guid %s \n", strKey.wcharptr());
	BREAKPOINT();

	//
	// Now do the operation on the registry
	//
	hr = HrRegOpenAString (strKey.c_str(), fCreate, phGuidKey);

	if (hr != S_OK)
	{
		phGuidKey = NULL;
	}
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegCreateAdapterGuid \n");

	return hr;


}



//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates and entry under the adapter Guid key. The entry is
//              the KeyWord "Upperbindings" and it contains the Guid of the IM 
//              IM Miniport. 
//
//  Arguments:
//	IN HKEY phkeyAdapterGuid - The key to <Protocol>->Paramaters->Adapters->Guid,
//	IN PGUID pIMMiniportGuid, - The Guid of the IM miniport
//	OUT HKEY *phImMiniportKey - Key for the IMminiport key
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenIMMiniportGuid(
	IN HKEY phkeyAdapterGuid,
	IN PGUID pIMMiniportGuid,
	IN BOOL fCreate,
	OUT PHKEY phImMiniportKey
	)
{
	HRESULT 	hr = ERROR_INVALID_PARAMETER;
	tstring 	strDevice;  
	WCHAR		szGuid[GUID_LENGTH];
	DWORD       dwDisposition   = 0x0;
	HKEY 		hImMiniportKey = NULL;


	do
	{
		//
		// If the key, Guid  is NULL Return 
		//
		if ((phkeyAdapterGuid == NULL) ||
			(pIMMiniportGuid == NULL) )
		{
			TraceBreak (L"HrRegSetIMMiniportGuid Bad arguments\n");
			break;
		}
		    

		strDevice = c_szDevice;

		//
		// Convert the Guid to  a string.
		// Insert '\Device\' at the beginning of the string
		//
		//

		StringFromGUID2(
		        *pIMMiniportGuid,
		        szGuid,
		        (sizeof(szGuid) / sizeof(szGuid[0])));



		strDevice.append(szGuid);

		//
		// Now do the operation on the registry
		//
		hr = HrRegOpenAString (strDevice.c_str(), fCreate, &hImMiniportKey);


	
	}while (FALSE);
	//
	//  update the output variable
	//
	
	if (hr == S_OK && phImMiniportKey  != NULL)
	{
		*phImMiniportKey = hImMiniportKey;
	}

	
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegOpenIMMiniportGuid \n");

	return hr;



}





//---------------------------------------------------------------------------
// 			Basic Functions accessed only by the routines above
//----------------------------------------------------------------------------





//+---------------------------------------------------------------------------
//
//  Function:   HrRegCreateKeyEx
//
//  Purpose:    Creates a registry key by calling RegCreateKeyEx.
//
//  Arguments:
//      hkey                 [in]
//      pszSubkey            [in]
//      dwOptions            [in]   See the Win32 documentation for the
//      samDesired           [in]   RegCreateKeyEx function.
//      lpSecurityAttributes [in]
//      phkResult            [out]
//      pdwDisposition       [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition)
{
    LONG lr = RegCreateKeyExW (hkey, pszSubkey, 0, NULL, dwOptions, samDesired,
            lpSecurityAttributes, phkResult, pdwDisposition);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceMsg(L"HrRegCreateKeyEx %x SubKey %s\n", hr, pszSubkey);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{

	HRESULT hr = ERROR_INVALID_PARAMETER;
	long lr = ERROR_INVALID_PARAMETER;

	do 
	{
		if (hkey == NULL ||
		    pszSubkey == NULL )
		{
			TraceBreak(L"HrRegOpenKey - Invalid Parameters \n");
			break;
		}
	
    	lr = RegOpenKeyExW (hkey, 
    	                         pszSubkey, 
    	                         0, 
    	                         samDesired, 
    	                         phkResult);
    	                         
	    hr = HRESULT_FROM_WIN32(lr);
	    if (FAILED(hr))
	    {
	        *phkResult = NULL;
	    }

	    
	} while (FALSE);

	
    TraceMsg (L"HrRegOpenKeyEx %x, %x",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValue
//
//  Purpose:    Sets the data for the given registry value by calling the
//              appropriate WinReg function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//



HRESULT 
HrRegSetSz (
	HKEY hkey, 
	PCWSTR pszValueName, 
	PCWSTR pszValue
	)
{
	TraceMsg (L"--> HrHrRegSetSz  \n");

    LONG lr = RegSetValueExW(hkey, 
                             pszValueName, 
                             0, 
                             REG_SZ, 
                             (LPBYTE)pszValue, 
                             CbOfSzAndTermSafe (pszValue) );;

                             
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    
    TraceMsg (L"<-- HrRegSetValue  hr %x\n", hr);
	return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKeyTree
//
//  Purpose:    Deletes an entire registry hive.
//
//  Arguments:
//      hkeyParent  [in]   Handle to open key where the desired key resides.
//      pszRemoveKey [in]   Name of key to delete.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey)
{

    // Open the key we want to remove
    HKEY 		hkeyRemove;
    HRESULT 	hr = ERROR_INVALID_PARAMETER;
    WCHAR       szValueName [MAX_PATH];
    DWORD       cchBuffSize = MAX_PATH;
    FILETIME    ft;
    LONG        lr;


    TraceMsg(L"-->HrRegDeleteKeyTree \n");

	do
	{

	    hr = HrRegOpenKeyEx(hkeyParent, 
	                                pszRemoveKey, 
	                                KEY_ALL_ACCESS,
	                                &hkeyRemove);

	    if (S_OK != hr)
	    {
			TraceBreak(L"HrRegDeleteKeyTree->HrRegOpenKeyEx Failed\n"); 
			break;
	    }


        // Enum the keys children, and remove those sub-trees
        while (ERROR_SUCCESS == (lr = RegEnumKeyExW (hkeyRemove,
                									0,
                									szValueName,
                									&cchBuffSize,
                									NULL,
                									NULL,
                									NULL,
                									&ft)))
        {
            HrRegDeleteKeyTree (hkeyRemove, szValueName);
            cchBuffSize = MAX_PATH;
        }


        
        RegCloseKey (hkeyRemove);

        if ((ERROR_SUCCESS == lr) || (ERROR_NO_MORE_ITEMS == lr))
        {
            lr = RegDeleteKeyW (hkeyParent, pszRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lr);

    } while (FALSE);

	TraceMsg(L"<--HrRegDeleteKeyTree %x\n", hr);

    return hr;
}






















//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAString
//
//  Purpose:    This creates and entry under the adapter key. The entry contains
//				Guid of the underlying adapter.
//
//  Arguments:
//	IN WCHAR_T *pcszStr - A string 
//  IN BOOL fCreate - Create Or Open,
//	OUT PHKEY phKey - The key to be used to access the new entry
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenAString(
	IN CONST WCHAR *pcszStr ,
	IN BOOL fCreate,
	OUT PHKEY phKey 
	)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    ULONG		lr = 0;


	TraceMsg (L"--> HrRegOpenAString\n");
 


	TraceMsg(L"   String opened %s \n", pcszStr);


	if (fCreate)
	{
		//
		// Create the entry
		//
			

	   	hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
	                          pcszStr,
	                          REG_OPTION_NON_VOLATILE,
	                          KEY_ALL_ACCESS,
	                          NULL ,
	                          phKey,
	                          &dwDisposition);

	}
	else
	{
		//
		// Open the entry
		//
		   hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                pcszStr,
                                KEY_READ,
                                phKey);
    

	}

	if (hr != S_OK)
	{
		phKey = NULL;
	}
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegOpenAString\n");

	return hr;


}












//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValueEx
//
//  Purpose:    Sets the data for the given registry value by calling the
//              RegSetValueEx function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    
    LONG lr = RegSetValueExW(hkey, 
                             pszValueName, 
                             0, 
                             dwType, 
                             pbData, 
                             cbData);

                             
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceMsg(L"--HrRegSetValue ValueName %s, Data %s, hr %x \n", pszValueName, pbData, hr);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteValue
//
//  Purpose:    Deletes the given registry value.
//
//  Arguments:
//      hkey        [in]    See the Win32 documentation for the RegDeleteValue
//      pszValueName [in]    function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName)
{
    
    LONG lr = RegDeleteValueW (hkey, 
                               pszValueName);

    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceMsg(L"--HrRegDeleteValue  ValueName %s, hr %x \n", pszValueName, hr);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKeyEx
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//      pszClass         [out]
//      pcchClass        [inout]
//      pftLastWriteTime [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime)
{

    LONG lr = RegEnumKeyExW (hkey, dwIndex, pszSubkeyName, pcchSubkeyName,
                            NULL, pszClass, pcchClass, pftLastWriteTime);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceMsg(L" -- HrRegEnumKeyEx");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeWithAlloc
//
//  Purpose:    Retrieves a type'd value from the registry and returns a
//              pre-allocated buffer with the data and optionally the size of
//              the returned buffer.
//
//  Arguments:
//      hkey         [in]    Handle of parent key
//      pszValueName [in]    Name of value to query
//      ppbValue     [out]   Buffer with binary data
//      pcbValue     [out]   Size of buffer in bytes. If NULL, size is not
//                           returned.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      Free the returned buffer with MemFree.
//
HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    HRESULT hr;
    DWORD   dwTypeRet;
    LPBYTE  pbData;
    DWORD   cbData;


    // Get the value.
    //
    hr = HrRegQueryValueWithAlloc(hkey, pszValueName, &dwTypeRet,
                                  &pbData, &cbData);

    // It's type should be REG_BINARY. (duh).
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        MemFree(pbData);
        pbData = NULL;

        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // Assign the output parameters.
    if (S_OK == hr)
    {
        *ppbValue = pbData;
        if (pcbValue)
        {
            *pcbValue = cbData;
        }
    }
    else
    {
        *ppbValue = NULL;
        if (pcbValue)
        {
            *pcbValue = 0;
        }
    }

    TraceMsg  (L" -- HrRegQueryTypeWithAlloc hr %x\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueWithAlloc
//
//  Purpose:    Retrieve a registry value in a buffer allocated by this
//              function. This goes through the mess of checking the value
//              size, allocating the buffer, and then calling back to get the
//              actual value. Returns the buffer to the user.
//
//  Arguments:
//      hkey         [in]        An open HKEY (the one that contains the value
//                              to be read)
//      pszValueName [in]        Name of the registry value
//      pdwType      [in/out]    The REG_ type that we plan to be reading
//      ppbBuffer    [out]       Pointer to an LPBYTE buffer that will contain
//                              the registry value
//      pdwSize      [out]       Pointer to a DWORD that will contain the size
//                              of the ppbBuffer.
//
//
//
HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize)
{
    HRESULT hr;
    BYTE abData [256];
    DWORD cbData;
    BOOL fReQuery = FALSE;


    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    // Get the size of the data, and if it will fit, the data too.
    //
    cbData = sizeof(abData);
    hr = HrRegQueryValueEx (
            hkey,
            pszValueName,
            pdwType,
            abData,
            &cbData);
    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
    {
        // The data didn't fit, so we'll have to requery for it after
        // we allocate our buffer.
        //
        fReQuery = TRUE;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        // Allocate the buffer for the required size.
        //
        BYTE* pbBuffer = (BYTE*)MemAlloc (cbData);
        if (pbBuffer)
        {
            if (fReQuery)
            {
                hr = HrRegQueryValueEx (
                        hkey,
                        pszValueName,
                        pdwType,
                        pbBuffer,
                        &cbData);
            }
            else
            {
                CopyMemory (pbBuffer, abData, cbData);
            }

            if (S_OK == hr)
            {
                // Fill in the return values.
                //
                *ppbBuffer = pbBuffer;

                if (pdwSize)
                {
                    *pdwSize = cbData;
                }
            }
            else
            {
                MemFree (pbBuffer);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceMsg  (L" -- HrRegQueryValueWithAlloc hr %x\n", hr);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueEx
//
//  Purpose:    Retrieves the data from the given registry value by calling
//              RegQueryValueEx.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      pdwType      [out]   See the Win32 documentation for the
//      pbData       [out]   RegQueryValueEx function.
//      pcbData      [in,out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      Note that pcbData is an *in/out* param. Set this to the size
//              of the buffer pointed to by pbData *before* calling this
//              function!
//
HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData)
{
    

    LONG lr = RegQueryValueExW (hkey, pszValueName, NULL, pdwType,
                    pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceMsg  (L" -- HrRegQueryValueEx hr %x\n", hr);
    return hr;
}



HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_SZ,
                (LPBYTE*)pszValue, NULL);
}




HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
	TraceMsg  (L" -- HrRegQueryMultiSzWithAlloc pszValueName %s\n",pszValueName );
	


    return HrRegQueryTypeWithAlloc (hkey, 
                                    pszValueName, 
                                    REG_MULTI_SZ,
                                    (LPBYTE*)pszValue, 
                                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\sfilter.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S F I L T E R . C P P
//
//  Contents:   Notify object code for the sample filter.
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "proto.h"
#include "macros.h"



//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Release an object pointed to by punk by calling
//              punk->Release();
//
//  Arguments:
//      punk [in]   Object to be Released'd. Can be NULL.
//
//  Returns:    Result of Release call.
//
//
//  Notes:      Using this function to Release an object .
//

inline 
ULONG 
ReleaseObj(
	IUnknown* punk
	)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefObj
//
//  Purpose:    AddRef's the object pointed to by punk by calling
//              punk->AddRef();
//
//  Arguments:
//      punk [in]   Object to be AddRef'd. Can be NULL.
//
//  Returns:    Result of AddRef call.
//
//
//  Notes:      Using this function to AddRef an object will reduce
//              our code size.
//
inline 
ULONG 
AddRefObj (
    IUnknown* punk
    )
{
    return (punk) ? punk->AddRef () : 0;
}





//+---------------------------------------------------------------------------
//
// Function:  CIMMiniport::CIMMiniport
//
// Purpose:   constructor for class CIMMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//
CIMMiniport::CIMMiniport(VOID)
{  

    m_fDeleted 			= FALSE;
    m_fNewIMMiniport 	= FALSE;

    m_fCreateMiniportOnPropertyApply = FALSE;
    m_fRemoveMiniportOnPropertyApply = FALSE;
    pNext = NULL;
    pOldNext = NULL;
    return;
	
}


//+---------------------------------------------------------------------------
//
// Function:  CUnderlyingAdapter::CUnderlyingAdapter
//
// Purpose:   constructor for class CUnderlyingAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//
CUnderlyingAdapter::CUnderlyingAdapter(VOID)
{  
	m_fBindingChanged = FALSE;
	m_fDeleted = FALSE;
	pNext = NULL;
	m_pOldIMMiniport = NULL;
	m_pIMMiniport = NULL;
	m_NumberofIMMiniports = 0;
	
}


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::CBaseClass
//
// Purpose:   constructor for class CBaseClass
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBaseClass::CBaseClass(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_eApplyAction(eActUnknown),
        m_pUnkContext(NULL)
{
    TraceMsg(L"--> CBaseClass::CBaseClass\n");

    m_cAdaptersAdded   = 0;
    m_fDirty  			= FALSE;
    m_fUpgrade 			= FALSE;
    m_fValid 			= FALSE;
    m_fNoIMMinportInstalled = TRUE;
    m_pUnderlyingAdapter = NULL;
}


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::~CBaseClass
//
// Purpose:   destructor for class CBaseClass
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBaseClass::~CBaseClass(VOID)
{
    TraceMsg(L"--> CBaseClass::~CBaseClass\n");

    // release interfaces if acquired

    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
    ReleaseObj(m_pUnkContext);
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
STDMETHODIMP 
CBaseClass::
Initialize(
	INetCfgComponent* pnccItem,
        INetCfg* pnc, 
        BOOL fInstalling
        )
{
	HRESULT hr = S_OK;
    TraceMsg(L"--> CBaseClass::Initialize\n");
    

    // save INetCfg & INetCfgComponent and add refcount

    m_pncc = pnccItem;
    m_pnc = pnc;

    if (m_pncc)
    {
        m_pncc->AddRef();
    }
    if (m_pnc)
    {
        m_pnc->AddRef();
    }


    //
    // If this not an installation, then we need to 
    // initialize all of our data and classes
    //
    if (!fInstalling)
    {
        hr = HrLoadConfiguration();
    }

	


    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure SampleFilter
//
// Arguments:
//    pszAnswerFile    [in]  name of AnswerFile
//    pszAnswerSection [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::ReadAnswerFile(PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    TraceMsg(L"--> CBaseClass::ReadAnswerFile\n");

    PCWSTR pszParamReadFromAnswerFile = L"ParamFromAnswerFile";

    // We will pretend here that szParamReadFromAnswerFile was actually
    // read from the AnswerFile using the following steps
    //
    //   - Open file pszAnswerFile using SetupAPI
    //   - locate section pszAnswerSection
    //   - locate the required key and get its value
    //   - store its value in pszParamReadFromAnswerFile
    //   - close HINF for pszAnswerFile

    // Now that we have read pszParamReadFromAnswerFile from the
    // AnswerFile, store it in our memory structure.
    // Remember we should not be writing it to the registry till
    // our Apply is called!!
    //

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::Install(DWORD dw)
{
    TraceMsg(L"--> CBaseClass::Install\n");

    // Start up the install process
    HRESULT hr = S_OK;
    ULONG State = 0;

    m_eApplyAction = eActInstall;

	TraceMsg(L"--> Installing the miniport\n");

	m_fValid = TRUE;

	//
	// Add devices in the NotyfBindingAdd routine
	//
  	
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::Removing(VOID)
{
    TraceMsg(L"--> CBaseClass::Removing\n");

    HRESULT     hr = S_OK;

    m_eApplyAction = eActRemove;
    

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Cancel
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::CancelChanges(VOID)
{
    TraceMsg(L"--> CBaseClass::CancelChanges\n");


    //
    // Remove a device here if necessary, if the miniport has been Added (Installed)
    // but not Applied to the Registry
    //

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
STDMETHODIMP CBaseClass::ApplyRegistryChanges(VOID)
{
	TraceMsg(L"--> CBaseClass::ApplyRegistryChanges\n");
	BREAKPOINT();

	HRESULT hr=S_OK;




	if (m_fValid && m_fDirty)
	{
		//
		// TODO Do We need this?
		//
		// UpdateElanDisplayNames();

		// flush out the registry and send reconfig notifications
		hr = HrFlushConfiguration();
	}

		
	//
	// Failure Unwrap
	//
	if (FAILED(hr))
	{

    	
		TraceMsg(L"  Failed to apply registry changes \n");
		
		hr = S_OK;
	}
	

	// do things that are specific to a config action
	// TODO _ move the install down here 

	TraceMsg(L"<-- CBaseClass::ApplyRegistryChanges hr %x\n", hr);

	return hr;
}
















STDMETHODIMP
CBaseClass::ApplyPnpChanges(
    IN INetCfgPnpReconfigCallback* pICallback)
{
	WCHAR szDeviceName[64];

	TraceMsg(L"--> CBaseClass::ApplyPnpChanges\n" );



/*    pICallback->SendPnpReconfig (
        NCRL_NDIS,
        c_szSFilterNdisName,
        szDeviceName,
        m_sfParams.m_szBundleId,
        (wcslen(m_sfParams.m_szBundleId) + 1) * sizeof(WCHAR));
*/
	TraceMsg(L"<-- CBaseClass::ApplyPnpChanges \n");
	return S_OK;
}

// =================================================================
// INetCfgSystemNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//    pdwNotificationFlag [out]  pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::GetSupportedNotifications(
        OUT DWORD* pdwNotificationFlag)
{
	TraceMsg(L"--> CBaseClass::GetSupportedNotifications\n");

	*pdwNotificationFlag = NCN_NET | NCN_NETTRANS | NCN_ADD | NCN_REMOVE;

	return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysQueryBindingPath
//
// Purpose:   Allow or veto formation of a binding path
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysQueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
	TraceMsg(L"--> CBaseClass::SysQueryBindingPath\n");

	return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysNotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem)
{
	TraceMsg(L"--> CBaseClass::SysNotifyBindingPath\n");

	return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysNotifyComponent(DWORD dwChangeFlag,
        INetCfgComponent* pncc)
{
	TraceMsg(L"--> CBaseClass::SysNotifyComponent\n");

	return S_OK;
}








// =================================================================
// INetCfgComponentNotifyBinding Interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::QueryBindingPath
//
// Purpose:  This is specific to the component being installed. This will 
//            ask us if we want to bind to the Item being passed into
//            this routine. We can veto by returning NETCFG_S_DISABLE_QUERY 
//
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::QueryBindingPath(
	IN DWORD dwChangeFlag,  
	IN INetCfgBindingPath *pncbpItem  
  )
  
{
	TraceMsg(L"-- CBaseClass::QueryBindingPath\n");


	return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::NotifyBindingPath
//
// Purpose:  We are now being told to bind to the component passed to us. 
//           Use this to get the guid and populate
//           Services\<Protocol>\Parameters\Adapters\<Guid> field
//
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP 
CBaseClass::
NotifyBindingPath(
	IN DWORD dwChangeFlag,  
	IN INetCfgBindingPath *pncbpItem  
	)
{
	HRESULT hr = S_OK;
	PWSTR pszBindName = NULL;
	INetCfgComponent* pnccLastComponent = NULL;
	DWORD 	dwMyChangeFlag = 0; 	


	TraceMsg(L"--> CBaseClass::NotifyBindingPath\n");
	BREAKPOINT();
	//
	// The flags will tell us if a binding is being added.
	// If the adapter is being added, then we will also be told if 
	// this is to Enabled or Disabled
	//

	do
	{


		//
		// First, get the component from the bind object
		//
		hr = HrGetLastComponentAndInterface(pncbpItem,
                                            &pnccLastComponent, NULL);
		if (S_OK != hr)
		{
			TraceMsg(L"HrGetLastComponentAndInterface Failed");
			pnccLastComponent = NULL;
			break;
		}

		//
		// Get the name of the new component
		//

		hr = pnccLastComponent->GetBindName(&pszBindName);

		if (S_OK != hr)
		{
			TraceMsg(L"GetBindName Failed");
			pszBindName = NULL;
			break;
		}


		//
		//  Do the add/remove depending on the flags
		//
		TraceMsg (L"dwChangeFlag %x\n", dwChangeFlag);

		//
		// Isolate the Change Flags
		//
		dwMyChangeFlag = (NCN_ADD | NCN_REMOVE | NCN_UPDATE);
		dwMyChangeFlag &= dwChangeFlag;

		switch (dwMyChangeFlag)
		{
			case NCN_ADD :
			{
				TraceMsg (L" Binding Notification - add\n");

				hr = HrNotifyBindingAdd(pnccLastComponent, pszBindName);

				if (S_OK != hr)
				{
					TraceMsg(L"HrNotifyBindingAdd Failed");
				}

				
				break;
			}
			case NCN_REMOVE :
			{
				TraceMsg (L" Binding Notification - remove\n");			

				hr = HrNotifyBindingRemove(pnccLastComponent, pszBindName);
                
				if (S_OK != hr)
				{
					TraceMsg(L"HrNotifyBindingRemove Failed");
				}
			
				break;
			}
			case NCN_UPDATE:
			{
				TraceMsg (L" Binding Notification - NCN_UPDATE\n");			

			}
			default: 
			{
				TraceMsg(L"  Invalid Switch Opcode %x\n", dwMyChangeFlag);
			}




		}
		
		//
		// simply mark the adapter as changed so we don't send 
		// add / remove notifications
		//
		
		this->m_pUnderlyingAdapter->m_fBindingChanged = TRUE;

		

	} while (FALSE);


	//
	// Free all locally allocated structure
	//
	if (pszBindName != NULL)
	{
		CoTaskMemFree (pszBindName);
	}

    
	ReleaseObj (pnccLastComponent);
		

	TraceMsg(L"<-- CBaseClass::NotifyBindingPath %x\n", hr);
	

	return hr;
}









// ------------ END OF NOTIFY OBJECT FUNCTIONS --------------------





// -----------------------------------------------------------------
//
//  Utility Functions
//

HRESULT HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower)
{
    HRESULT hr=S_OK;

    // Initialize output parameters
    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    INetCfgComponent* pnccUpper;
    INetCfgComponent* pnccLower;

    hr = pncbi->GetUpperComponent(&pnccUpper);
    if (SUCCEEDED(hr))
    {
        hr = pncbi->GetLowerComponent(&pnccLower);
        if (SUCCEEDED(hr))
        {
            *ppnccUpper = pnccUpper;
            *ppnccLower = pnccLower;
        }
        else
        {
            ReleaseObj(pnccUpper);
        }
    }

    return hr;
}

HRESULT HrOpenAdapterParamsKey(GUID* pguidAdapter,
                               HKEY* phkeyAdapter)
{
    HRESULT hr=S_OK;

    HKEY hkeyServiceParams;
    WCHAR szGuid[48];
    WCHAR szAdapterSubkey[128];
    DWORD dwError;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegParamAdapter,
                     0, KEY_ALL_ACCESS, &hkeyServiceParams))
    {
        StringFromGUID2(*pguidAdapter, szGuid, 47);
        _stprintf(szAdapterSubkey, L"\\%s", szGuid);
        if (ERROR_SUCCESS !=
            (dwError = RegOpenKeyEx(hkeyServiceParams,
                                    szAdapterSubkey, 0,
                                    KEY_ALL_ACCESS, phkeyAdapter)))
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
        RegCloseKey(hkeyServiceParams);
    }

    return hr;
}

#if DBG
void TraceMsg(PCWSTR szFormat, ...)
{
    static WCHAR szTempBuf[4096];

    va_list arglist;

    va_start(arglist, szFormat);

    _vstprintf(szTempBuf, szFormat, arglist);
    OutputDebugString(szTempBuf);

    va_end(arglist);
}

#endif


// ----------------------------------------------------------------------
//
// Function:  HrAddOrRemoveAdapter 
//   
//    
// 
// Purpose:   Its purpose is to add or remove an IM adapter to the system 
//
// Arguments:
//    
// Returns:
//
// Notes:
//


HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    ADD_OR_REMOVE		AddOrRemove,
    INetCfgComponent**  ppnccMiniport
    )
{
	HRESULT hr = S_OK;
	INetCfgClass* pncClass = NULL;
	INetCfgClassSetup* pncClassSetup = NULL;

	TraceMsg (L"->HrAddOrRemoveAdapter \n");
	BREAKPOINT();

	do 
	{

		//
		//  Lets get Interface that represents all adapters
		//
		TraceMsg(L" Calling QueryNetCfgClass \n");
		
		hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET, 
	                                         IID_INetCfgClass,  // we want InetCfg class
	                                         reinterpret_cast<void**>(&pncClass));  // store the return object here
		if (S_OK != hr)
		{
			TraceBreak (L"HrAddOrRemoveAdapter  QueryNetCfgClass \n");
			break;
		}

	    
	    
		//
		// Now lets get the SetupClass that corresponds to our Net cfg Class
		//
		TraceMsg(L"Calling QueryInterface  \n");

		hr = pncClass->QueryInterface (IID_INetCfgClassSetup,
	            						reinterpret_cast<void**>(&pncClassSetup));

		if (S_OK != hr)
		{

			TraceBreak (L"HrAddOrRemoveAdapter  QueryInterface  \n");
			break;
		
		}        


		if (AddOrRemove == AddMiniport)
		{

			TraceMsg(L" Calling  HrInstallAdapter \n");
			
			hr = HrInstallAdapter (pncClassSetup,  // the setup class
			                 pszComponentId,  // which device to add
			                 ppnccMiniport
			                 );  
	        
		}
		else
		{
			TraceMsg(L"Calling  HrDeInstallAdapter  \n");
			
			hr = HrDeInstallAdapter (pncClass,
                                     pncClassSetup,
                                     pszComponentId
                                     );
                                

		}


		// Normalize the HRESULT.
		// Possible values of hr at this point are S_FALSE,
		// NETCFG_S_REBOOT, and NETCFG_S_STILL_REFERENCED.
		//
		if (! SUCCEEDED(hr))
		{
			TraceBreak (L"HrAddOrRemoveAdapter  Install Or  DeInstall\n");
			hr = S_OK;
			break;
		}


	} while (FALSE);

	if (pncClassSetup)
	{
		ReleaseObj( pncClassSetup);
	}

	if (pncClass)
	{
		ReleaseObj (pncClass);

	}
	
    TraceMsg (L"<--HrAddOrRemoveAdapter hr %x\n", hr );
    return hr;
}






// ----------------------------------------------------------------------
//
// Function:  HrInstallAdapter 
//   
//    
// 
// Purpose:   This install the IM adapter 
//
// Arguments:
//  
//   pSetupClass 		: The setup class that can install the IM miniport
//   pszComponentId		: The PnP Id of the IM miniport
//   ppncc 				: The component that was just installed
//
//
// Returns:
//
// Notes:
//


HRESULT
HrInstallAdapter (
	INetCfgClassSetup*  pSetupClass,
    PCWSTR           pszComponentId,
    INetCfgComponent**  ppncc
	)
{

	HRESULT hr;
	
	hr = pSetupClass->Install(pszComponentId , 
	                          NULL , 			// OboToken
	                          0,     			// dwSetupFlags	
	                          0, 				// dwUpgradeFromBuildNo
	                          NULL , 			// pszwAnswerFile
	                          NULL , 			// pszwAnswerSections
	                          ppncc );			// Output - Miniport Component

	TraceMsg (L"HrInstallAdapter hr %x\n", hr );

	return hr;
}



// ----------------------------------------------------------------------
//
// Function:  HrDeInstallAdapter 
//   
//    
// 
// Purpose:   This uninstalls the IM adapter 
//
// Arguments:
//    pncClass,
//	  pSetupClass,
//    pszComponentId
//
// Returns:
//
// Notes:
//

HRESULT
HrDeInstallAdapter (
	INetCfgClass* 		pncClass,
	INetCfgClassSetup*  pSetupClass,
	PCWSTR              pszComponentId
	)

{

	HRESULT hr;

	// Find and remove the component.
	//
	INetCfgComponent* pncMiniport;

	TraceMsg (L"->HrDeInstallAdapter \n");

	do
	{
		//
		// Lets find our miniport
		//
		hr = pncClass->FindComponent (pszComponentId, &pncMiniport);

		if (S_OK != hr)
		{
			break;
		}

		//
		// Use the setup class to de install our miniport
		//
		TraceMsg (L" Calling DeInstall hr %x\n", hr );

		hr = pSetupClass->DeInstall (pncMiniport,
	                				 NULL, 
	                				 NULL);

		//
		// Release the object as we are done with it
		//
		
		ReleaseObj (pncMiniport);

	} while (FALSE);


	TraceMsg (L"<-HrRemoveAdapter hr %x", hr );

	return hr;	



}










//-----------------------------------------------------------------------  
//  Private methods asocciated with the classes
//-----------------------------------------------------------------------


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingAdd 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being added to our protocol's entry
//
// Arguments:
//		pnccAdapter		: The adapter  being added, Use it to get the GUID 
//		pszBindName		: The name of the adapter (Should be in the form of a Guid)
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::HrNotifyBindingAdd (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    // we should see if this adapter is
    // is already in our list but marked as for deletion. If so, simply unmark
    // the adapter and all of it's Elans. The Binding Add could be a fake one
    // when it is in uprade process.

	BOOL					fFound = FALSE;
	CUnderlyingAdapter*  	pAdapterInfo  = NULL;
	INetCfgComponent*   	pnccNewMiniport = NULL;
	CIMMiniport* 			pIMMiniport = NULL;
	ADD_OR_REMOVE			Add  = AddMiniport;


	TraceMsg (L"-->HrNotifyBindingAdd psBindName %x\n",pszBindName );

	pAdapterInfo  = this->GetUnderlyingAdaptersListHead();


	//
	//  Search the entire list to see if this adapter (binding) has
	//  already been added
	//
	BREAKPOINT();
	while (pAdapterInfo != NULL && fFound == FALSE)
	{
	    //  search the in-memory list for this adapter

	    if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
	    {
	        fFound = TRUE;
	        break;
	    }

	    //
	    // Move to the next Adapter here
	    //
	    pAdapterInfo = pAdapterInfo->GetNext();
	}



	do
	{
	
		if (fFound) // Add an old adapter back
		{

			//
			// mark it un-deleted
			//
			pAdapterInfo->m_fDeleted = FALSE;

			//
			// No more to do
			//
			break;

		}


		//
		// We have a new underlying adapter
		//
	    
		//
		//  Create a new in-memory adapter object
		//
		pAdapterInfo = new CUnderlyingAdapter;


		if (pAdapterInfo == NULL)
		{	
			TraceMsg (L"pAdapterInfo Allocation Failed\n");
			break;
		}

		//
		// Get the Guid for the new adapter
		//
		GUID guidAdapter;
		hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 

		if (S_OK != hr)
		{
			TraceMsg (L"GetInstanceGuid Failed\n");
			break;

		}

		//
		// Update the Adapter's Guid here
		//
		pAdapterInfo->m_AdapterGuid  = guidAdapter;
        
		//
		// the adapter is newly added
		//
		pAdapterInfo->m_fBindingChanged = TRUE;

		//
		// Set the bind name of the adapter
		//
		pAdapterInfo->SetAdapterBindName(pszBindName);

		//
		// Get the PnpId of the adapter
		//
		PWSTR pszPnpDevNodeId = NULL;
		
		hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);

		if (S_OK != hr)
		{
			TraceMsg (L"GetPnpDevNodeId  Failed\n");
			break;
        
		}

		//
		// Update the PnP Id in our structure
		//
		pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
		CoTaskMemFree(pszPnpDevNodeId);


		//
		// Allocate memory for our IM Miniport that corresponds to 
		// this physical adapter
		//
		pIMMiniport = new CIMMiniport();

		
		if (pIMMiniport == NULL)
		{
			TraceMsg (L"pIMMiniport Allocation Failed\n");
			break;
		}

		
		//
		// Now lets add our IM miniport which corresponds to 
		// this adapter
		//
		TraceMsg(L" About to Add IM miniport \n");
		
		pIMMiniport->m_fNewIMMiniport = TRUE;
        
    	

		hr = HrAddOrRemoveAdapter(this->m_pnc, 				// NetConfig class
				                  c_szInfId_MS_ATMEPVCM,  	// Inf file to use,
				                  Add,						// Add a miniport
				                  &pnccNewMiniport);  		// new miniport

		if (SUCCEEDED(hr) == FALSE)
		{
			TraceMsg(L"HrAddOrRemoveAdapter failed\n");
			pnccNewMiniport = NULL;
			break;
		}


		TraceMsg(L" Updating IM miniport strings \n");
		            
		//
		//  Update the BindName
		//
		PWSTR pszIMBindName;

        
		hr = pnccNewMiniport->GetBindName(&pszIMBindName);

		if (S_OK != hr)
		{
			TraceMsg(L"Get Bind Name Failed \n");
			pszIMBindName = NULL;
			break;
		}

        
		TraceMsg(L" IM BindName %x\n",pszIMBindName );

                    
		pIMMiniport->SetIMMiniportBindName(pszIMBindName);
		CoTaskMemFree(pszIMBindName);

		//
		//  Update the Device param
		//
		tstring strIMMiniport;
		strIMMiniport= c_szDevice;
		strIMMiniport.append(pIMMiniport->SzGetIMMiniportBindName());

		TraceMsg (L"Setting IM Device Name\n");
		pIMMiniport->SetIMMiniportDeviceName(strIMMiniport.c_str());

		

		TraceMsg(L" IM Device Name  %s\n",strIMMiniport.c_str());


		{
			//
			// TODO This is different than ATMALNE 
			// Set up a display name
			//
			tstring     strNewDisplayName = L"Ethernet ATM Miniport";

			(VOID)pnccNewMiniport->SetDisplayName(strNewDisplayName.c_str());



		}



		pAdapterInfo->AddIMiniport(pIMMiniport); 

		this->AddUnderlyingAdapter(pAdapterInfo);


		if (this->m_pUnderlyingAdapter == NULL)
		{
			TraceMsg(L"m_pUnderlyingAdapter  == NULL\n");
			BREAKPOINT();
		} 

		if (pAdapterInfo->m_pIMMiniport == NULL)
		{
			TraceMsg(L"pAdapterInfo->m_pIMMiniport == NULL\n");
			BREAKPOINT();

		}


		//  Mark the in-memory configuration dirty
		m_fDirty = TRUE;


		ReleaseObj(pnccNewMiniport);
    
		hr = S_OK;



	} while (FALSE);

	if (S_OK != hr)
	{
		//
		// Failure CleanUp. 
		//
		TraceMsg(L" Main loop in HrAdd Adapter has failed\n");
		
		BREAKPOINT();
		
		//
		// remove the IM miniport if necessary
		//

		if(pAdapterInfo != NULL)
		{
			delete pAdapterInfo;
			pAdapterInfo = NULL;
		}

		if (pIMMiniport != NULL)
		{
			delete pIMMiniport;
			pIMMiniport = NULL;
		}

	}

	TraceMsg (L"<--HrNotifyBindingAdd \n");
	return hr;
}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingRemove  
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//



HRESULT
CBaseClass::
HrNotifyBindingRemove (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
	HRESULT hr = S_OK;
	CUnderlyingAdapter 	*pAdapterInfo= NULL;
	CIMMiniport			*pIMMiniport = NULL;


	TraceMsg (L"--> HrNotifyBindingRemove \n");
 
	//  search the in-memory list for this adapter
	BOOL    fFound = FALSE;



	pAdapterInfo = this->GetUnderlyingAdaptersListHead();


	//
	//  Search the entire list to see if this adapter (binding) has
	//  already been added
	//
	while (pAdapterInfo != NULL && fFound == FALSE)
	{
		//  search the in-memory list for this adapter

		TraceMsg (L" pszBindName %x m_strAdapterBindName %x\n",
		           pszBindName, 
		           pAdapterInfo->SzGetAdapterBindName() );
 
		if (!lstrcmpiW (pszBindName, pAdapterInfo->SzGetAdapterBindName()))
		{
			fFound = TRUE;
			break;
		}

		//
		// Move to the next Adapter here
		//
		pAdapterInfo = pAdapterInfo->GetNext();
	}





	TraceMsg (L"-- HrNotifyBindingRemove fFound %x\n", fFound);

	do 
	{


		if (fFound == FALSE)
		{

			TraceBreak (L" HrNotifyBindingRemove fFound FALSE\n");

			break;
		}


		//
		// mark it deleted
		//
		pAdapterInfo->m_fDeleted = TRUE;

		//
		// mark as binding changed
		//
		pAdapterInfo->m_fBindingChanged = TRUE;

		//
		// if this is upgrade, then do not delete its associated IM miniport 
		// otherwise, delete them now
		//
		HRESULT hrIm = S_OK;

		pIMMiniport  = pAdapterInfo->m_pIMMiniport;


		if (m_fUpgrade == FALSE)
		{
        	//
        	// TODO ; Atm Lane does something special on upgrades
        	//
			//break;
		}

		TraceMsg (L" About to remove a miniport instance\n");
		//
		// Remove corresponding miniport.
		//
		hrIm = HrRemoveMiniportInstance(pIMMiniport->SzGetIMMiniportBindName());

		if (SUCCEEDED(hrIm))
		{
			pIMMiniport->m_fDeleted = TRUE;
		}
		else
		{
			TraceMsg(L"HrRemoveMiniportInstance failed", hrIm);
			hrIm = S_OK;
		}
        
		//
		// mark the in-memory configuration dirty
		//
		this->m_fDirty = TRUE;
    
	    
	} while (FALSE);
	
	TraceMsg (L"<-- HrNotifyBindingRemove hr %x\n", hr);
	return hr;
}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrRemoveMiniportInstance 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//




HRESULT 
CBaseClass::
HrRemoveMiniportInstance(
	PCWSTR  pszBindNameToRemove
	)
{
	// Enumerate adapters in the system.
	//
	HRESULT 				hr = S_OK;
	BOOL 					fRemove = FALSE;
	INetCfgComponent* 		pnccAdapterInstance = NULL;


	GUID	GuidClass;

	TraceMsg (L"--> HrRemoveMiniportInstance hr %x\n", hr);

	    


	do
	{

		hr = HrFindNetCardInstance(pszBindNameToRemove,
		                           &pnccAdapterInstance );

		if (hr != S_OK)
		{
			TraceBreak(L"HrRemoveMiniportInstance  HrFindNetCardInstance FAILED \n");
			pnccAdapterInstance  = NULL;
			break;
		}

		
		

		hr = HrRemoveComponent( this->m_pnc, 
	                             pnccAdapterInstance);
		if (hr != S_OK)
		{
			TraceBreak(L"HrRemoveMiniportInstance  HrRemoveComponent FAILED \n");
			pnccAdapterInstance  = NULL;
			break;
		}

	} while (FALSE);

	//
	// Free memory and locally allocated objects
	//
	
	ReleaseAndSetToNull (pnccAdapterInstance );
  
		



	TraceMsg (L"<-- HrRemoveMiniportInstance hr %x\n", hr);

	return hr;
}




// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingAdd 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove
    )
{

	TraceMsg (L"--> HrRemoveComponent \n");

	// Get the class setup interface for this component.
	//
	GUID guidClass;
	HRESULT hr = pnccToRemove->GetClassGuid (&guidClass);

    
	if (SUCCEEDED(hr))
	{
		// Use the class setup interface to remove the component.
		//
		INetCfgClassSetup* pSetup;
		hr = pnc->QueryNetCfgClass (&guidClass,
                            IID_INetCfgClassSetup,
                            reinterpret_cast<void**>(&pSetup));
		if (SUCCEEDED(hr))
		{
			hr = pSetup->DeInstall (pnccToRemove, 
                                    NULL, 
                                    NULL);
			ReleaseObj (pSetup);
		}
	}

	TraceMsg (L"<-- HrRemoveComponent  hr %x\n", hr);

    return hr;
}



//-------------------------------------------------------------
// F U N C T I O N S   U S E D   I N   F L U S H I N G
//-------------------------------------------------------------


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushConfiguration
//   
// Purpose:  	This is called from the ApplyRegistryChange. We need
//				to modify the registry here. 
//   			
//             
//
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushConfiguration()
{
    HRESULT hr  = S_OK;
    HKEY    hkeyAdapterList = NULL;

    //  Open the "Adapters" list key
	TraceMsg (L"--> HrFlushConfiguration  \n");
	
    do
    {
	    hr = HrRegOpenAdapterKey(c_szAtmEpvcP, 
	                            TRUE, 
	                            &hkeyAdapterList);

	    if (S_OK != hr)
	    {
			TraceMsg (L" HrRegOpenAdapterKey FAILED\n");
			break;
	    }



		CUnderlyingAdapter *pAdapterInfo = NULL;

		//
		// Get the first Underlying Adapter
		//
		pAdapterInfo = this->GetUnderlyingAdaptersListHead();

		//
		// Now iterate through each of the adapters
		// and write their configuration to the 
		// registry
		//
		
		HRESULT hrTmp;

		while (pAdapterInfo != NULL)
		{

			//
			//  Flush this adapter's configuration
			//
			hrTmp = HrFlushAdapterConfiguration(hkeyAdapterList, pAdapterInfo);


			if (SUCCEEDED(hrTmp))
			{
				if (!pAdapterInfo->m_fBindingChanged)
				{
					// Compare epvc list and send notifications
					hrTmp = HrReconfigEpvc(pAdapterInfo);

					if (FAILED(hrTmp))
					{
						hrTmp = NETCFG_S_REBOOT;
					}
				}
			}
			else
			{
				TraceMsg(L"HrFlushAdapterConfiguration failed for adapter %x", pAdapterInfo);
				TraceBreak (L"HrFlushAdapterConfiguration  FAILED \n");

				hrTmp = S_OK;
				break;
			}

			if (S_OK ==hr)
			{
				hr = hrTmp;
			}

			//
			// Now move to the next adapter
			//
			pAdapterInfo = pAdapterInfo->GetNext();

			//
			// Temporary debugging
			//
			if (pAdapterInfo != NULL)
			{
				TraceBreak (L"pAdapterInfo should be Null\n");
			}
			
		} //while (pAdapterInfo != NULL);
        


        
		RegCloseKey(hkeyAdapterList);

	    
	}while (FALSE);

	TraceMsg (L"<-- HrFlushConfiguration  hr %x \n", hr);


	return hr;








}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushAdapterConfiguration
//   
//   
// Purpose:  	This function either deletes or add the Adapter BindName
//              to the registry
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::
HrFlushAdapterConfiguration(
	HKEY hkeyAdapterList,
    CUnderlyingAdapter *pAdapterInfo
	)
{

	HRESULT hr  = S_OK;

	HKEY    hkeyAdapter     = NULL;
	DWORD   dwDisposition;

	TraceMsg (L"--> HrFlushAdapterConfiguration\n");

	if (pAdapterInfo->m_fDeleted == TRUE)
	{
		//  Adapter is marked for deletion
		//  Delete this adapter's whole registry branch
		hr = HrRegDeleteKeyTree(hkeyAdapterList,
		                        pAdapterInfo->SzGetAdapterBindName());
	}
	else
	{
		

		//
		// open this adapter's subkey, we are now at 
		// Protocol->Parameters->Adapters
		//
        

		hr = HrRegCreateKeyEx(
                                hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapter,
                                &dwDisposition);

		if (S_OK == hr)
		{
        
	    	//
			// open this adapter's subkey, we are now at 
			// Protocol->Parameters->Adapters->Guid
			//
			hr = HrFlushMiniportList(hkeyAdapter, pAdapterInfo);

			RegCloseKey(hkeyAdapter);
		}
	}


	TraceMsg (L"<-- HrFlushAdapterConfiguration hr %x\n", hr);
	return hr;





}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushMiniportList
//   
//   
// Purpose:  	This function either deletes or add the Adapter BindName
//              to the registry
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushMiniportList(
	HKEY hkeyAdapterGuid,
	CUnderlyingAdapter *pAdapterInfo
	)
{
	HRESULT hr  = S_OK;
	DWORD 	dwDisposition = 0;

	CIMMiniport *pIMMiniport = NULL;
	INetCfgComponent 		*pnccIMMiniport = NULL;
	tstring					*pIMMiniportGuid;
	DWORD 					dwNumberOfIMMiniports ; 
	UINT 					i = 0;
	PWSTR					pwstr = NULL;
	UINT					index = 0;
	UINT 					Size = 0;
	HKEY 					hKeyMiniportList = NULL;
	INetCfgComponent 		*pnccAtmEpvc = NULL;
	
	
	TraceMsg (L"--> HrFlushMiniportList \n" );

	do
	{
		//
		//  Open the Elan list subkey
		//
		hr = HrRegCreateKeyEx(
		                        hkeyAdapterGuid,
		                        c_szIMMiniportList,
		                        REG_OPTION_NON_VOLATILE,
		                        KEY_ALL_ACCESS,
		                        NULL,
		                        &hKeyMiniportList,
		                        &dwDisposition);

		if (S_OK != hr)
		{
			TraceBreak (L"--> HrFlushMiniportList HrRegCreateKeyEx FAILED \n" );
			break;

		}
		
		//
		// Iterate through all the IM Miniports on this adapter 
		// and get their string.
		//
		dwNumberOfIMMiniports = pAdapterInfo->DwNumberOfIMMiniports();

		//
		// Get the IM miniport List Head
		//

	
	    
		pIMMiniport = pAdapterInfo->IMiniportListHead();

		

		if (pIMMiniport == NULL)
		{
			TraceBreak (L" HrFlushMiniportList pIMMiniport is Null = FAILED\n" );
			break;
		}

		//
		// Now iterate through all the miniports and 
		// flush them to the registry
		//

		while ( pIMMiniport != NULL)
		{
			//
			//  This function does all the hard work
			//
	     	hr = HrFlushMiniportConfiguration(hKeyMiniportList, 
	     	                                  pIMMiniport);

			if (FAILED(hr))
			{
				TraceBreak(L"HrFlushMiniportConfiguration failure");
				hr = S_OK;
			}

			//
			// If this is a first time addition to the registry
			// we need to write the ATM adapter's Pnp ID to the 
			// registry. This is ATM specific
			//

			if ((!pIMMiniport->m_fDeleted) && (pIMMiniport->m_fNewIMMiniport))
			{
				//
				// Find this Miniport and write The PnP Id 
				// of the atm adapter to the registry
				//
				hr = HrFindNetCardInstance(pIMMiniport->SzGetIMMiniportBindName(),
                                           &pnccAtmEpvc);
				if (S_OK == hr)
				{
					HKEY hkeyMiniport = NULL;

					hr = pnccAtmEpvc->OpenParamKey(&hkeyMiniport);
					if (S_OK == hr)
					{
						//
						// Write the PnP Id here
						//
						HrRegSetSz(hkeyMiniport, 
                                   c_szAtmAdapterPnpId,
                                   pAdapterInfo->SzGetAdapterPnpId());
					}
                    
					RegCloseKey(hkeyMiniport);
				}
                
				ReleaseObj(pnccAtmEpvc);

			} // if ((!pIMMiniport->m_fDeleted) && (pIMMiniport->m_fNewIMMiniport	))
        	

			
			pIMMiniport = pIMMiniport->GetNext();
		                
		}// 		while ( pIMMiniport != NULL)


		RegCloseKey(hKeyMiniportList);
   
     
	}
	while (FALSE);

	//
	// Clean Up
	//  
	
	if (pnccIMMiniport != NULL)
	{
		ReleaseObj(pnccIMMiniport);

	}

	hr = S_OK;

	TraceMsg (L"<-- HrFlushMiniportList hr %x\n", hr);
    return hr;
}




// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushMiniportConfiguration
//   
//   
// Purpose:  	This function either deletes or add the IM Miniport
//              to the registry
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushMiniportConfiguration(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)

{
	HRESULT hr = S_OK;
	PCWSTR*	pstrDeviceName = NULL;
	TraceMsg (L"--> HrFlushMiniportConfiguration \n");

    if (pIMMiniport->m_fDeleted)
    {

    	hr = HrDeleteMiniport(hkeyMiniportList, 
		                     pIMMiniport);
		                     

    }
    else
    {

    	hr = HrWriteMiniport(hkeyMiniportList, 
		                     pIMMiniport);
		                     
	}
	
	TraceMsg (L"<-- HrFlushMiniportConfiguration %x\n",hr);
	return hr;

}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrDeleteMiniport
//   
//   
// Purpose:  	As the miniport needs to be deleted from the registry
//				this function does the deletion
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//


HRESULT
CBaseClass::
HrDeleteMiniport(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)
{
	HRESULT hr = S_OK;
	TraceMsg (L"--> HrDeleteMiniport \n");



	PCWSTR szBindName = pIMMiniport->SzGetIMMiniportBindName();

	if (lstrlenW(szBindName)) // only if the bindname is not empty
	{
		//
		//  Miniport is marked for deletion
		//  Delete this Miniport's whole registry branch
		//
		hr = HrRegDeleteKeyTree(hkeyMiniportList,
                                szBindName);
	}


	TraceMsg (L"<-- HrDeleteMiniport hr %x\n", hr);
	return hr;

}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrWriteMiniport
//   
//   
// Purpose:  	To add a miniport, we make an entry under the IMMiniport 
// 				list. Under this we write the all important Upper Bindings
//              Keyword
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::
HrWriteMiniport(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)
{
	HKEY    hkeyMiniport = NULL;
	DWORD   dwDisposition;
	PWSTR	pstrDeviceName = NULL;
	DWORD 	dwLen = 0;
	HRESULT hr;

	TraceMsg (L"--> HrWriteMiniport \n");

	do
	{
		//
		// open/create this Miniport's key
		//
		hr = HrRegCreateKeyEx(
	                            hkeyMiniportList,
	                            pIMMiniport->SzGetIMMiniportBindName(),
	                            REG_OPTION_NON_VOLATILE,
	                            KEY_ALL_ACCESS,
	                            NULL,
	                            &hkeyMiniport,
	                            &dwDisposition);

		if (hr != S_OK)
		{
			TraceMsg (L"Write Miniport CreateRegKey Failed\n");
			hkeyMiniport = NULL;
			break;
		}
 
		//
		// Use the string values from the miniport to create an entry for Upperbindindings
		//

		//
		// Copy the string into our buffer, 
		//

		pstrDeviceName = (PWSTR	)pIMMiniport->SzGetIMMiniportDeviceName();

		if ( pstrDeviceName  == NULL)
		{
			TraceBreak(L"Write Miniport  - SzGetIMMiniportDeviceName Failed\n");
			break;

		}


		dwLen = wcslen(pstrDeviceName);

		if (dwLen != IM_NAME_LENGTH )
		{
			TraceMsg(L"Invalide Name Length. pstr %p - %s, Len %x",
		         pstrDeviceName,
		         pstrDeviceName,
		         dwLen);
		         
			BREAKPOINT();			    

		}

		TraceMsg(L"Str %p - %s , Len %x\n",
		         pstrDeviceName,
		         pstrDeviceName,
		         dwLen);
	         
		if (pstrDeviceName[dwLen] != L'\0')
		{
			TraceMsg (L" Null termination  pwstr %p, Index %d\n",pstrDeviceName ,dwLen);
			BREAKPOINT();

			pstrDeviceName [dwLen++] = L'\0';
		}
				

		


		hr = HrRegSetValueEx( hkeyMiniport,
		                      c_szUpperBindings,
		                      REG_SZ,
		                      (unsigned char*)pstrDeviceName,
		                      dwLen*2);  // Unicode to bytes 

		if (hr != S_OK)
		{
			TraceBreak (L"WriteMiniport - HrRegSetValueEx FAILED\n");
		}

	} while (FALSE);

	if (hkeyMiniport != NULL)
	{
		RegCloseKey(hkeyMiniport );
	}



	TraceMsg (L"<-- HrWriteMiniport\n");
	return hr;

}






HRESULT
CBaseClass::
HrFindNetCardInstance(
    PCWSTR             pszBindNameToFind,
    INetCfgComponent** ppncc)
{
    *ppncc = NULL;

    TraceMsg (L"--> HrFindNetCardInstance\n" );

	//
    // Enumerate adapters in the system.
    //
	HRESULT 				hr = S_OK;
	BOOL 					fFound = FALSE;
	IEnumNetCfgComponent *	pEnumComponent = NULL;
	INetCfgComponent* 		pNccAdapter = NULL;
	CONST ULONG 			celt = 1;  // Number of  elements wanted.
	ULONG 					celtFetched = 0;  // Number of elements fetched
	INetCfgClass* 			pncclass = NULL;
	PWSTR 					pszBindName = NULL;	
	//
	// We need to fing the component that has the name we 
	// are looking for . Look in all NetClass devices
	//

	do
	{


		hr = m_pnc->QueryNetCfgClass(&GUID_DEVCLASS_NET, 
		                             IID_INetCfgClass,
                                     reinterpret_cast<void**>(&pncclass));

		if ((SUCCEEDED(hr)) == FALSE)
		{
				pncclass = NULL;
				TraceBreak(L"HrFindNetCardInstance  QueryNetCfgClass FAILED\n");
				break;
			    }

    	//
		// Get the enumerator and set it for the base class.
		//
        
		hr = pncclass->EnumComponents(&pEnumComponent);

		if ((SUCCEEDED(hr)) == FALSE)
		{
			TraceBreak (L" HrFindNetCardInstance EnumComponents FAILED\n");
			pEnumComponent = NULL;
			break;
		}


		//
		// Now iterate through all the net class component
		//
		while ((fFound == FALSE) && (hr == S_OK))
		{
			pNccAdapter = NULL;

			//
			// Lets get the next Component
			//
			
			hr = pEnumComponent->Next(celt,
			                          &pNccAdapter,
			                          &celtFetched);
			//
			//  Get the bindname of the miniport
			//
			if (S_OK != hr)
			{
				//
				// We might break, if there are no more elements
				//
				pNccAdapter = NULL;
				break;
			}	



			hr = pNccAdapter->GetBindName(&pszBindName);

			if (S_OK != hr)
			{
				TraceBreak(L" HrFindNetCardInstance GetBindName Failed\n")
				pszBindName = NULL;
				break;
			}

			//	
			//  If the right one tell it to remove itself and end
			//

            
			fFound = !lstrcmpiW(pszBindName, pszBindNameToFind);
			CoTaskMemFree (pszBindName);

			if (fFound)
			{
				*ppncc = pNccAdapter;
			}
			else
			{
				ReleaseAndSetToNull(pNccAdapter);
			}
            
		} // end of while ((fFound == FALSE) && (hr == S_OK))


			

		
	} while (FALSE);

	if (pncclass != NULL)
	{
		ReleaseAndSetToNull(pncclass);
	}

	ReleaseAndSetToNull (pEnumComponent);
	
	
	TraceMsg (L"<-- HrFindNetCardInstance hr %x\n", hr );
	return hr;
}




//------------------------------------------------------------
//
//  simple member functions for the CBaseClass
//
//------------------------------------------------------------

VOID
CBaseClass::
AddUnderlyingAdapter(
    	CUnderlyingAdapter  * pAdapter)
{

		//
		// Insert this at the head
		//
		this->SetUnderlyingAdapterListHead(pAdapter);

		this->m_cAdaptersAdded ++;	

}


VOID
CBaseClass::
SetUnderlyingAdapterListHead(
    	CUnderlyingAdapter * pAdapter
    	)
{
	//
	// Insert this at the head
	//
	pAdapter->SetNext(this->GetUnderlyingAdaptersListHead());

	this->m_pUnderlyingAdapter = pAdapter;


}
    


CUnderlyingAdapter *
CBaseClass::
GetUnderlyingAdaptersListHead(
	VOID)
{
	return (this->m_pUnderlyingAdapter);
}

DWORD
CBaseClass::DwNumberUnderlyingAdapter()
{
	return this->m_cAdaptersAdded ;
}




//------------------------------------------------------------
//
//  member functions for the Underlying Adapter
//
//------------------------------------------------------------


VOID CUnderlyingAdapter::SetAdapterBindName(PCWSTR pszAdapterBindName)
{
    m_strAdapterBindName = pszAdapterBindName;
    return;
}

PCWSTR CUnderlyingAdapter::SzGetAdapterBindName(VOID)
{
    return m_strAdapterBindName.c_str();
}

VOID CUnderlyingAdapter::SetAdapterPnpId(PCWSTR pszAdapterPnpId)
{
    m_strAdapterPnpId = pszAdapterPnpId;
    return;
}

PCWSTR CUnderlyingAdapter::SzGetAdapterPnpId(VOID)
{
    return m_strAdapterPnpId.c_str();
}


HRESULT CUnderlyingAdapter::SetNext ( CUnderlyingAdapter *pNextUnderlyingAdapter )
{
	this->pNext = pNextUnderlyingAdapter;
	return S_OK;
}

CUnderlyingAdapter *CUnderlyingAdapter::GetNext()
{
	return pNext;
}


VOID CUnderlyingAdapter::AddIMiniport(CIMMiniport* pNextIMiniport)
{
	//
	// Set up this new Miniport as the head of the list
	//
	this->SetIMiniportListHead(pNextIMiniport);
	this->m_NumberofIMMiniports ++;
			
}


CIMMiniport* CUnderlyingAdapter::IMiniportListHead()
{
	return (this->m_pIMMiniport);
}



VOID CUnderlyingAdapter::SetIMiniportListHead(CIMMiniport* pNewHead)
{
	pNewHead->SetNext(this->IMiniportListHead() );
	

	this->m_pIMMiniport = pNewHead;
	
}

VOID CUnderlyingAdapter::AddOldIMiniport(CIMMiniport* pIMiniport)
{
	//
	// Set up this new Miniport as the head of the list
	//
	this->SetOldIMiniportListHead(pIMiniport);

			
}


CIMMiniport* CUnderlyingAdapter::OldIMiniportListHead()
{
	return (this->m_pOldIMMiniport);
}



VOID CUnderlyingAdapter::SetOldIMiniportListHead(CIMMiniport* pNewHead)
{
	pNewHead->SetNextOld(this->OldIMiniportListHead() );

	this->m_pOldIMMiniport = pNewHead;
}


DWORD CUnderlyingAdapter::DwNumberOfIMMiniports()
{
	return m_NumberofIMMiniports;
}


//------------------------------------------------------------
//
//  member functions for the IM miniport
//
//------------------------------------------------------------

VOID CIMMiniport::SetIMMiniportBindName(PCWSTR pszIMMiniportBindName)
{
    m_strIMMiniportBindName = pszIMMiniportBindName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportBindName(VOID)
{
    return m_strIMMiniportBindName.c_str();
}

VOID CIMMiniport::SetIMMiniportDeviceName(PCWSTR pszIMMiniportDeviceName)
{
    m_strIMMiniportDeviceName = pszIMMiniportDeviceName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportDeviceName(VOID)
{
    return m_strIMMiniportDeviceName.c_str();
}

DWORD CIMMiniport::DwGetIMMiniportNameLength(VOID)
{
    return m_strIMMiniportDeviceName.len();
}


VOID CIMMiniport::SetIMMiniportName(PCWSTR pszIMMiniportName)
{
    m_strIMMiniportName = pszIMMiniportName;
    return;
}

VOID CIMMiniport::SetIMMiniportName(PWSTR pszIMMiniportName)
{
    m_strIMMiniportName = pszIMMiniportName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportName(VOID)
{
    return m_strIMMiniportName.c_str();
}


VOID CIMMiniport::SetNext (	CIMMiniport *pNextIMiniport )
{
	pNext = pNextIMiniport;
}


CIMMiniport* CIMMiniport::GetNext(VOID)
{
	return pNext ;
}


VOID CIMMiniport::SetNextOld (	CIMMiniport *pNextIMiniport )
{
	pOldNext  = pNextIMiniport;
}


CIMMiniport* CIMMiniport::GetNextOld(VOID)
{
	return pOldNext ;
}











//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastComponentAndInterface
//
//  Purpose:    This function enumerates a binding path, returns the last
//              component on the path and optionally return the last binding
//              interface name in this path.
	//
//  Arguments:
//      pncbp               [in]    The INetCfgBindingPath *
//      ppncc               [out]   The INetCfgComponent * of the last component on the path
//      ppszInterfaceName   [out]   The interface name of the last binding interface of the path
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//
HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pNcbPath,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName)
{

	ULONG ulElement = 0;
	INetCfgBindingInterface* 		pNcbInterface = NULL;
	INetCfgBindingInterface* 		pncbiLast = NULL;
	INetCfgComponent* 				pnccLowerComponent = NULL;
	IEnumNetCfgBindingInterface*	pEnumInterface = NULL;  

	TraceMsg (L"--> HrGetLastComponentAndInterface \n");
		
	
	// Initialize output parameters.
	//
	*ppncc = NULL;
	if (ppszInterfaceName)
	{
		*ppszInterfaceName = NULL;
	}

	// Enumerate binding interfaces and keep track of
	// the last interface.
	//
	HRESULT hr = S_OK;

	do
	{

		hr = pNcbPath->EnumBindingInterfaces(&pEnumInterface );

		if (hr != S_OK )
		{
			TraceMsg(L" EnumBindingInterfaces FAILED\n");
			pEnumInterface = NULL;
			break;
		}

		//
		//  Iterate till we reach the last element in the path
		//
	 
		do
		{
			pNcbInterface = NULL;
		
			hr = pEnumInterface ->Next (1,
			                            &pNcbInterface,
			                            &ulElement);

			if (hr 	!= S_OK )
			{
				pNcbInterface = NULL ; // Failure

				break;
			}

			if (ulElement == 0 || pNcbInterface == NULL || hr 	!= S_OK)
			{
				pNcbInterface  = NULL;
				break;  // We have reached the last element and it is in pncbiLast.
			
			}
			ReleaseObj(pncbiLast);
			pncbiLast = pNcbInterface;
			

		} while (hr == S_OK && pNcbInterface != NULL);
		

		//
		// If this is the last element, then get its name and 
		// return it to the caller. The last element is in pncbiLast
		//
		if (pNcbInterface != NULL || pncbiLast == NULL)
		{
			//
			// We did not reach the last element
			//
			TraceMsg (L"Did not get the last interface\n");
			break;
			
		}


		hr = S_OK;



		hr = pncbiLast->GetLowerComponent(&pnccLowerComponent);
		if (S_OK != hr)
		{
			TraceMsg(L" GetLowerComponent Failed ");
			break;
		}
	    

		// Get the name of the interface if requested.
		//
		if (ppszInterfaceName)
		{
			hr = pncbiLast->GetName(ppszInterfaceName);
		}

		// If we've succeded everything, (including the optional
		// return of the interface name above) then assign and addref
		// the output interface.
		//
		if (S_OK == hr)
		{
			AddRefObj (pnccLowerComponent);
			*ppncc = pnccLowerComponent;
		}
		else
		{

			// Important to release our use of this interface in case
			// we failed and didn't assign it as an output parameter.
			//
			ReleaseAndSetToNull (pnccLowerComponent);
		}
		
	} while (FALSE);

	//
	// Don't forget to release the binding interface itself.
	//
	ReleaseObj(pncbiLast);

	
	TraceMsg (L"<-- HrGetLastComponentAndInterface  ppszInterfaceName %x\n", ppszInterfaceName);
	return hr;
}



//---------------------------------------------------------------------------
//  These functions are used to load the configuration from the registry
//---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadConfiguration
//
//  Purpose:  This loads the Miniport and adapters that have already been 
//            installed into our own data structures
//
//  Arguments:
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT 
CBaseClass::
HrLoadConfiguration(
	VOID
	)
{
	HRESULT     hr  = S_OK;
	WCHAR       szBuf[MAX_PATH+1];
	FILETIME    time;
	DWORD       dwSize;
	DWORD       dwRegIndex = 0;
	HKEY    	hkeyAdapterList = NULL;

	TraceMsg (L"-->HrLoadConfiguration \n");
	
	// mark the memory version of the registy valid
	this->m_fValid = TRUE;

	BREAKPOINT();

	do
	{
		// Try to open an existing key first.
		//
	    
		hr = HrRegOpenAdapterKey(c_szAtmEpvcP, 
	                            FALSE, 
	                            &hkeyAdapterList
	                            );
		if (FAILED(hr))
		{
			//
			// Only on failure do we try to create it
			//
			hr = HrRegOpenAdapterKey(c_szAtmEpvcP, TRUE, &hkeyAdapterList);
		}

		if (S_OK != hr)
		{
			TraceBreak(L"HrLoadConfiguration  HrRegOpenAdapterKey FAILED\n");
			hkeyAdapterList = NULL;
			break;
		}

		//
		// Initialize the Size and hr
		//

		dwSize = (sizeof(szBuf)/ sizeof(szBuf[0]));

		hr = S_OK;
	
		while (hr == S_OK)
		{
			//
			// Iterate through all the adapters in <Protocol>\Paramters\Adapters
			//

			hr = HrRegEnumKeyEx (hkeyAdapterList, 
			                     dwRegIndex,
			                     szBuf, 
			                     &dwSize, 
			                     NULL, 
			                     NULL, 
			                     &time);
			if (hr != S_OK)
			{
				break;
			}

			//		
			// load this adapter's config
			//
			hr = HrLoadAdapterConfiguration (hkeyAdapterList, szBuf);
			if (S_OK != hr)
			{
				TraceBreak (L"HrLoadConfiguration   HrLoadAdapterConfiguration  failed\n" );
				hr = S_OK;
				//
				// continue on.
				//
			}

			//
			// Re-Initialize the Size
			//
			dwRegIndex++;
			dwSize = (sizeof(szBuf)/ sizeof(szBuf[0]));
		}

		//
		// Why did we exit from our adapter enumeration
		//
		if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
		{
			hr = S_OK;
		}




	} while (FALSE);

	if (hkeyAdapterList != NULL)
	{
		RegCloseKey (hkeyAdapterList);
	}
	
	TraceMsg (L"<--HrLoadConfiguration %x\n", hr);
	return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrLoadAdapterConfiguration
//
//  Purpose:   Load the Underlying Adapter into our structure
//
//
//
//  Arguments:
//    	HKEY hkeyAdapterList - hKeyAdapterList,
//      PWSTR pszAdapterName - Adapter Name for the underlying adapter
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT 
CBaseClass::
HrLoadAdapterConfiguration(
	HKEY hkeyAdapterList,
    PWSTR pszAdapterName
    )
{
	HRESULT 							hr = S_OK;
	HKEY    							hkeyAdapter = NULL;
	DWORD   							dwDisposition;
	CUnderlyingAdapter*   	pAdapterInfo = NULL;
	INetCfgComponent*   				pnccAdapter    = NULL;
	PWSTR 								pszPnpDevNodeId = NULL;
	GUID 								guidAdapter;
    

	TraceMsg(L"-->HrLoadAdapterConfiguration %s\n",pszAdapterName);
	do
	{
		//
		// load this adapter
		//
		pAdapterInfo = new CUnderlyingAdapter;

		if (pAdapterInfo == NULL)
		{
			TraceBreak (L"HrLoadAdapterConfiguration new Adapter FAILED\n");
			break;
	    }

		pAdapterInfo->SetAdapterBindName(pszAdapterName);

		this->AddUnderlyingAdapter(pAdapterInfo);

		//
		// open this adapter's subkey
		//
		hr = HrRegCreateKeyEx(
	                hkeyAdapterList,
	                pszAdapterName,
	                REG_OPTION_NON_VOLATILE,
	                KEY_ALL_ACCESS,
	                NULL,
	                &hkeyAdapter,
	                &dwDisposition);

		if (S_OK != hr)
		{
			hkeyAdapter = NULL;
			TraceBreak(L" HrLoadAdapterConfiguration  HrRegCreateKeyEx FAILED \n");
			break;
		}

		//
		// load the PnpId
		//
		TraceMsg (L"pszAdapter->Name %x - %s \n", pszAdapterName, pszAdapterName);
	    
		hr = HrFindNetCardInstance(pszAdapterName, 
	                               &pnccAdapter);
	    
		if (S_OK != hr)
		{
			//
			// Failure - exit
			//
			TraceBreak (L"HrLoadAdapterConfiguration HrFindNetCardInstance FAILED\n");
			pnccAdapter =  NULL;
			break;

		}
		if (S_FALSE == hr)
		{
			//
			 // normalize return - but exit
			//
			hr = S_OK;
			pnccAdapter =  NULL;
			break;
		}

		hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
	
	
		if (S_OK == hr)
		{
			pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
			CoTaskMemFree(pszPnpDevNodeId);
		}
    

	    
		hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 

		if (S_OK == hr)
		{
			pAdapterInfo->m_AdapterGuid = guidAdapter;
		}

		//
		// load the IM Miniport
		//
	    
		hr = HrLoadIMMiniportListConfiguration(hkeyAdapter, 
	                                            pAdapterInfo);

		if (S_OK != hr)
		{
			TraceBreak (L"HrLoadAdapterConfiguration HrFindNetCardInstance FAILED\n");
			break;
		
		}

		        
    

	} while (FALSE);


	if (pnccAdapter != NULL)
	{
		ReleaseAndSetToNull(pnccAdapter);
	}
    
	if (hkeyAdapter != NULL)
	{	
		RegCloseKey(hkeyAdapter);
	}

	TraceMsg(L"<--HrLoadAdapterConfiguration %x\n", hr);

	return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   HrLoadIMMiniportListConfiguration
//
//  Purpose:   Load the IM miniports hanging of this adapter into our structure
//
//
//
//  Arguments:
//    	HKEY hkeyAdapterList - hKeyAdapterList,
//      PWSTR pszAdapterName - Adapter Name for the underlying adapter
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT
CBaseClass::
HrLoadIMMiniportListConfiguration(
    HKEY hkeyAdapter,
    CUnderlyingAdapter* pAdapterInfo)
{
	HRESULT hr = S_OK;
	UINT i;

	//
	// open the IMminiport under the adapter subkey
	//
	HKEY    hkeyIMMiniportList= NULL;
	DWORD   dwDisposition;
    

	WCHAR       szBuf[MAX_PATH+1];
	FILETIME    time;
	DWORD       dwSize;
	DWORD       dwRegIndex = 0;
	PWSTR		pszIMDevices = NULL;
	PWSTR		p = NULL;
	
	TraceMsg(L"--> HrLoadIMMiniportListConfiguration \n");

	do
	{
	
	    
		//
		// open the MiniportList subkey. Then we will iterate through all
		// the IM miniport that exist under this key
		//
	
	    
		hr = HrRegCreateKeyEx(hkeyAdapter, 
	                          c_szIMMiniportList, 
	                          REG_OPTION_NON_VOLATILE,
	                          KEY_ALL_ACCESS, 
	                          NULL, 
	                          &hkeyIMMiniportList, 
	                          &dwDisposition);

		if (S_OK != hr)
		{
			TraceBreak (L"LoadMiniportList - CreateRegKey FAILED \n");
			hkeyIMMiniportList = NULL;
			break;
		}

		//
		// Initialize variables through the iteration
		//
		
		dwSize = celems(szBuf);

		hr = S_OK;

	    
		while(SUCCEEDED(hr) == TRUE)
		{
			hr=  HrRegEnumKeyEx(hkeyIMMiniportList, 
	                          dwRegIndex, 
	                          szBuf,
			                  &dwSize, 
			                  NULL, 
			                  NULL, 
			                  &time);
			if (hr != S_OK)
			{
				break;
			}

			//
			// load this IMMiniport;s  configuration
			//
			hr = HrLoadIMiniportConfiguration(hkeyIMMiniportList,
	                                         szBuf,
	                                         pAdapterInfo);

			if (S_OK != hr)
			{
				TraceBreak(L"HrLoadMiniportConfiguration failed \n ");
				//
				// Do not break
				//
				hr = S_OK;
			}
			else 
			{
				if (m_fNoIMMinportInstalled)
				{
					m_fNoIMMinportInstalled = FALSE;
	                
				}
			
			}

	        
			//
			// prepare for the next iteration
			// increment index and reset size variable
			//
			dwRegIndex ++;
			dwSize = celems(szBuf);


		}// end of while(SUCCEEDED(hr) == TRUE)
	    

			if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		{
			hr = S_OK;
		}

		RegCloseKey(hkeyIMMiniportList);
	    
	} while (FALSE);
    	
	TraceMsg(L"<-- HrLoadIMMiniportListConfiguration %x\n", hr);

	return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrLoadIMiniportConfiguration
//
//  Purpose:   Load a single IM miniport hanging of this adapter into our structure
//             The Miniport is loaded into two lists . 
//
//
//  Arguments:
//    HKEY hkeyIMiniportList,
//    PWSTR pszIMiniport,
//    CUnderlyingAdapter * pAdapterInfo)
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT
CBaseClass::
HrLoadIMiniportConfiguration(
    HKEY hkeyMiniportList,
    PWSTR pszIMiniportName,
    CUnderlyingAdapter * pAdapterInfo
    )
{
	HRESULT hr  = S_OK;
	HKEY    hkeyIMiniport    = NULL;
	DWORD   dwDisposition;

	TraceMsg (L"-->HrLoadIMminiportConfiguration  \n");

    
	do
	{
		// load this IMMiniport info
		CIMMiniport* pIMMiniportInfo = NULL;
		pIMMiniportInfo = new CIMMiniport;

		CIMMiniport* pOldIMMiniportInfo = NULL;
		pOldIMMiniportInfo = new CIMMiniport;

		if ((pIMMiniportInfo == NULL) ||
			(pOldIMMiniportInfo == NULL))
		{
			hr = E_OUTOFMEMORY;
			if (pIMMiniportInfo)
			{
				delete pIMMiniportInfo;
			}
			if (pOldIMMiniportInfo)
			{
				delete pOldIMMiniportInfo;
			}

			break;
		}

		pAdapterInfo->AddIMiniport(pIMMiniportInfo);
		pIMMiniportInfo->SetIMMiniportBindName(pszIMiniportName);

		pAdapterInfo->AddOldIMiniport(pOldIMMiniportInfo);
		pOldIMMiniportInfo->SetIMMiniportBindName(pszIMiniportName);

		//
		// open the IMMiniport's key
		//
		HKEY    hkeyIMMiniport    = NULL;


		hr = HrRegCreateKeyEx (hkeyMiniportList, 
		                       pszIMiniportName, 
		                       REG_OPTION_NON_VOLATILE,
		                       KEY_ALL_ACCESS, 
		                       NULL, 
		                       &hkeyIMMiniport, 
		                       &dwDisposition);

		if (S_OK == hr)
		{
			// read the Device parameter
			PWSTR pszIMiniportDevice;

			hr = HrRegQuerySzWithAlloc (hkeyIMMiniport, 
			                            c_szUpperBindings, 
			                            &pszIMiniportDevice);
			if (S_OK == hr)
			{
				//
				// load the Device name
				//
				pIMMiniportInfo->SetIMMiniportDeviceName(pszIMiniportDevice);
				pOldIMMiniportInfo->SetIMMiniportDeviceName(pszIMiniportDevice);
				MemFree (pszIMiniportDevice);


			}
			RegCloseKey (hkeyIMMiniport);
		}
	}
	while (FALSE);

	    TraceMsg (L"<-- HrLoadIMminiportConfiguration  hr %x \n", hr);
	return hr;
}





HRESULT 
CBaseClass::
HrReconfigEpvc(
	CUnderlyingAdapter* pAdapterInfo
	)
{
    HRESULT hr = S_OK;

    // Note: if atm physical adapter is deleted, no notification of removing elan
    // is necessary. Lane protocol driver will know to delete all the elans
    // (confirmed above with ArvindM 3/12).

    // Raid #371343, don't send notification if ATM card not connected


	TraceMsg (L" -- HrReconfigEpvc\n");
	    return hr;

 #if 0
 
    if ((!pAdapterInfo->m_fDeleted) && 
        FIsAdapterEnabled(&(pAdapterInfo->m_guidInstanceId)))  
    {
        ElanChangeType elanChangeType;

        // loop thru the elan list on this adapter
        ELAN_INFO_LIST::iterator    iterLstElans;

        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                iterLstElans != pAdapterInfo->m_lstElans.end();
                iterLstElans++)
        {
            CALaneCfgElanInfo * pElanInfo = *iterLstElans;

            // if this Elan is marked as for delete
            if (pElanInfo->m_fDeleted)
            {
                PCWSTR szBindName = pElanInfo->SzGetElanBindName();

                if (lstrlenW(szBindName)) // only if the bindname is not empty
                {
                    // notify deletion
                    elanChangeType = DEL_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);
                }
            }
            else
            {
                BOOL fFound = FALSE;

                ELAN_INFO_LIST::iterator    iterLstOldElans;

                // loop through the old elan list, see if we can find a match
                for (iterLstOldElans = pAdapterInfo->m_lstOldElans.begin();
                        iterLstOldElans != pAdapterInfo->m_lstOldElans.end();
                        iterLstOldElans++)
                {
                    CALaneCfgElanInfo * pOldElanInfo = * iterLstOldElans;

                    if (0 == lstrcmpiW(pElanInfo->SzGetElanBindName(),
                                      pOldElanInfo->SzGetElanBindName()))
                    {
                        // we found a match
                        fFound = TRUE;

                        // has the elan name changed ?
                        if (lstrcmpiW(pElanInfo->SzGetElanName(),
                                     pOldElanInfo->SzGetElanName()) != 0)
                        {
                            elanChangeType = MOD_ELAN;
                            hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                                    elanChangeType);
                        }
                    }
                }

                if (!fFound)
                {
                    elanChangeType = ADD_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);

                    // Raid #384380: If no ELAN was installed, ignore the error
                    if ((S_OK != hr) &&(m_fNoIMMinportInstalled))
                    {
                        TraceError("Adding ELAN failed but error ignored 
since there was no ELAN installed so LANE driver is not started, reset hr to 
S_OK", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CALaneCfg::HrReconfigLane", hr);
    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\typedefs.h ===
typedef GUID*  PGUID;
typedef HKEY *PHKEY;




#define GUID_LENGTH sizeof(GUID) + 1
#define NOTHING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\ccdefs.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// ccdefs.h
//
// ATM - Ethernet Encapsulation Intermediate Driver 
//
// '#defines' used in the driver.
//
// 03/23/2000 ADube Created.
//


#define TESTMODE 0

//
// Define spew levels. The code will be checked in with testmode turned off
//

#if TESTMODE
    #define DEFAULTTRACELEVEL TL_T
    #define DEFAULTTRACEMASK TM_NoRM
#else
    #define DEFAULTTRACELEVEL TL_A
    #define DEFAULTTRACEMASK TM_Base
#endif


#define NDIS_WDM 1

#define PKT_STACKS 0



#if (DBG)
        // Define this to enable a whole lot of extra checking in the RM api'd -- things
        // like debug associations and extra checking while locking/unlocking.
        //
        #define RM_EXTRA_CHECKING 1
#endif // DBG

#define EPVC_NDIS_MAJOR_VERSION     5
#define EPVC_NDIS_MINOR_VERSION     0



#define DISCARD_NON_UNICAST TRUE

#define MAX_BUNDLEID_LENGTH 50
#define TAG 'Epvc'
#define WAIT_INFINITE 0
#define ATMEPVC_GLOBALS_SIG 'GvpE'
#define ATMEPVC_MP_MEDIUM NdisMedium802_3
#define ATMEPVC_DEF_MAX_AAL5_PDU_SIZE   ((64*1024)-1)
//
//  Maximum bytes for ethernet/802.3 header 
//
#define EPVC_ETH_HEADERSIZE         14
#define EPVC_HEADERSIZE             4
#define MCAST_LIST_SIZE             32
#define MAX_ETHERNET_FRAME          1514 
#define MAX_IPv4_FRAME              MAX_ETHERNET_FRAME - sizeof(EPVC_ETH_HEADER)          
#define EPVC_MAX_FRAME_SIZE         MAX_ETHERNET_FRAME
#define EPVC_MAX_PT_SIZE            EPVC_MAX_FRAME_SIZE + 20
#define MIN_ETHERNET_SIZE           sizeof (IPHeader) + sizeof (EPVC_ETH_HEADER)
#define EPVC_ETH_ENCAP_SIZE         2

//
// Packet Releated definitions
//

#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF
#define ARPDBG_REF_EVERY_PACKET 1

#define DEFAULT_MAC_HEADER_SIZE 14
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\str.h ===
//
// For now include the stl functions provided in net\config\inc
//

#include "pch.h"
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <ncreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\driver.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    ATMEPVC - Driver Entry and associated functions

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube      03-23-00    created, .

--*/


#include "precomp.h"
#pragma hdrstop

#pragma NDIS_INIT_FUNCTION(DriverEntry)


//
// temp global variables
//
NDIS_HANDLE ProtHandle, DriverHandle;


//
// global variables
//

NDIS_PHYSICAL_ADDRESS           HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);
NDIS_HANDLE                     ProtHandle = NULL;
NDIS_HANDLE                     DriverHandle = NULL;
NDIS_MEDIUM                     MediumArray[1] =
                                    {
                                        NdisMediumAtm
                                    };


LIST_ENTRY                      g_ProtocolList;                                 
EPVC_GLOBALS                    EpvcGlobals;


RM_STATUS
epvcResHandleGlobalProtocolList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );




RM_STATUS
epvcRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );




RM_STATUS
epvcUnloadDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );

RM_STATUS
epvcDeRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );

RM_STATUS
epvcIMDriverRegistration(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );


//--------------------------------------------------------------------------------
//                                                                              //
//  Global Root structure definitions                                           //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


// List of fixed resources used by ArpGlobals
//
enum
{
    RTYPE_GLOBAL_PROTOCOL_LIST,
    RTYPE_GLOBAL_REGISTER_IM
    
}; // EPVC_GLOBAL_RESOURCES;

//
// Identifies information pertaining to the use of the above resources.
// Following table MUST be in strict increasing order of the RTYPE_GLOBAL
// enum.
//

RM_RESOURCE_TABLE_ENTRY 
EpvcGlobals_ResourceTable[] =
{

    {RTYPE_GLOBAL_PROTOCOL_LIST,    epvcResHandleGlobalProtocolList},

    {RTYPE_GLOBAL_REGISTER_IM,  epvcIMDriverRegistration}


};

// Static information about ArpGlobals.
//
RM_STATIC_OBJECT_INFO
EpvcGlobals_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "EpvcGlobals",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    NULL, // pfnDelete
    NULL, // pfnVerifyLock

    sizeof(EpvcGlobals_ResourceTable)/sizeof(EpvcGlobals_ResourceTable[1]),
    EpvcGlobals_ResourceTable
};






//--------------------------------------------------------------------------------
//                                                                              //
//  Underlying Adapters. The Protocol gets called at BindAdapter for            //
//  each adapter                                                                //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



// eovcAdapter_HashInfo contains information required maintain a hashtable
// of EPVC_ADAPTER objects.
//
RM_HASH_INFO
epvcAdapter_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    epvcAdapterCompareKey,  // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    epvcAdapterHash     // pfnHash

};


// EpvcGlobals_AdapterStaticInfo  contains static information about
// objects of type EPVC_ADAPTERS.
// It is a group of Adapters that the protocol has bound to
//
RM_STATIC_OBJECT_INFO
EpvcGlobals_AdapterStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Adapter",  // TypeName
    0, // Timeout

    epvcAdapterCreate,  // pfnCreate
    epvcAdapterDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &epvcAdapter_HashInfo
};



//--------------------------------------------------------------------------------
//                                                                              //
//  Intermediate miniports - each hangs of a protocol block                     //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

// arpAdapter_HashInfo contains information required maintain a hashtable
// of EPVC_ADAPTER objects.
//
RM_HASH_INFO
epvc_I_Miniport_HashInfo= 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    epvcIMiniportCompareKey,    // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    epvcIMiniportHash       // pfnHash

};


RM_STATIC_OBJECT_INFO
EpvcGlobals_I_MiniportStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "IMiniport",    // TypeName
    0, // Timeout

    epvcIMiniportCreate,    // pfnCreate
    epvcIMiniportDelete,        // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &epvc_I_Miniport_HashInfo
};




//
// Variables used in debugging
//
#if DBG
ULONG g_ulTraceLevel= DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK ;
#endif










NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
    NDIS_STATUS                     Status;
    NTSTATUS                        NtStatus;

    BOOLEAN     AllocatedGlobals = FALSE;
    ENTER("DriverEntry", 0xbfcb7eb1)


    RM_DECLARE_STACK_RECORD(SR)

    TIMESTAMP("==>DriverEntry");

    
    TRACE ( TL_T, TM_Dr,("==>Atm Epvc DriverEntry\n"));


    do
    {
        //
        // Inititalize the global variables
        //

        
        // Must be done before any RM apis are used.
        //
        RmInitializeRm();

        RmInitializeLock(
                    &EpvcGlobals.Lock,
                    LOCKLEVEL_GLOBAL
                    );

        RmInitializeHeader(
                NULL,                   // pParentObject,
                &EpvcGlobals.Hdr,
                ATMEPVC_GLOBALS_SIG  ,
                &EpvcGlobals.Lock,
                &EpvcGlobals_StaticInfo,
                NULL,                   // szDescription
                &SR
                );


        AllocatedGlobals = TRUE;

        //
        // Initialize globals
        //
        EpvcGlobals.driver.pDriverObject = DriverObject;
        EpvcGlobals.driver.pRegistryPath  = RegistryPath;


        //
        // Register the IM Miniport with NDIS.
        //
        Status = RmLoadGenericResource(
                    &EpvcGlobals.Hdr,
                    RTYPE_GLOBAL_PROTOCOL_LIST,
                    &SR
                    );

        if (FAIL(Status)) break;

        //
        // Register the protocol with NDIS.
        //
        Status = RmLoadGenericResource(
                    &EpvcGlobals.Hdr,
                    RTYPE_GLOBAL_REGISTER_IM,
                    &SR
                    );

        if (FAIL(Status)) break;

    
    } while (FALSE);

    
    if (FAIL(Status))
    {
        if (AllocatedGlobals)
        {
            RmUnloadAllGenericResources(
                    &EpvcGlobals.Hdr,
                    &SR
                    );
            RmDeallocateObject(
                    &EpvcGlobals.Hdr,
                    &SR
                    );
        }

        // Must be done after any RM apis are used and async activity complete.
        //
        RmDeinitializeRm();

        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        NtStatus = NDIS_STATUS_SUCCESS;
    }

    EXIT()

    TIMESTAMP("<==DriverEntry");

    RM_ASSERT_CLEAR(&SR);
    
    return Status ;

}




VOID
EpvcUnload(
    IN  PDRIVER_OBJECT              pDriverObject
)
/*++

Routine Description:

    This routine is called by the system prior to unloading us.
    Currently, we just undo everything we did in DriverEntry,
    that is, de-register ourselves as an NDIS protocol, and delete
    the device object we had created.

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    NDIS_STATUS NdisStatus; 
    ENTER("Unload", 0xc8482549)
    RM_DECLARE_STACK_RECORD(sr);
    

    TIMESTAMP("==>Unload");


    RmUnloadAllGenericResources(&EpvcGlobals.Hdr, &sr);

    RmDeallocateObject(&EpvcGlobals.Hdr, &sr);

    // Must be done after any RM apis are used and async activity complete.
    //
    RmDeinitializeRm();

    // TODO? Block(250);

    RM_ASSERT_CLEAR(&sr)
    EXIT()
    TIMESTAMP("<==Unload");
    return;
}



RM_STATUS
epvcResHandleGlobalProtocolList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
    )
{
    PEPVC_GLOBALS               pGlobals    = NULL;


    ENTER("GlobalAdapterList", 0xb407e79e)
    
    TRACE (TL_T, TM_Dr, ("==>epvcResHandleGlobalProtocolList pObj %x, Op", 
                         pObj , Op ) );


    pGlobals    = CONTAINING_RECORD(
                                      pObj,
                                      EPVC_GLOBALS,
                                      Hdr);


    //
    // 
    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        RmInitializeGroup(
                        pObj,                                   // pParentObject
                        &EpvcGlobals_AdapterStaticInfo,         // pStaticInfo
                        &(pGlobals->adapters.Group),            // pGroup
                        "Adapters Group",                       // szDescription
                        pSR                                     // pStackRecord
                        );
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        ASSERT(pGlobals->adapters.Group.HashTable.NumItems == 0);


        RmDeinitializeGroup(&pGlobals->adapters.Group, pSR);
        NdisZeroMemory(&(pGlobals->adapters), sizeof(pGlobals->adapters));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(!"Unexpected OpCode epvcResHandleGlobalProtocolList ");
    }




    TRACE (TL_T, TM_Dr, ("<==epvcResHandleGlobalProtocolList Status %x", 
                         NDIS_STATUS_SUCCESS) );

    EXIT()
    RM_ASSERT_CLEAR(pSR);

    return NDIS_STATUS_SUCCESS;

}



RM_STATUS
epvcIMDriverRegistration(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{
    TRACE (TL_T, TM_Mp, ("epvcIMDriverRegistration Op %x", Op));
    if (RM_RESOURCE_OP_LOAD == Op)
    {
        epvcRegisterIMDriver(pObj,Op,pvUserParams,psr);
    }
    else
    {
        epvcDeRegisterIMDriver(pObj,Op,pvUserParams,psr);
    }

    return NDIS_STATUS_SUCCESS;
}


RM_STATUS
epvcRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{
    NDIS_STATUS                     Status = NDIS_STATUS_FAILURE;
    PEPVC_GLOBALS                   pGlobals    = NULL;
    NDIS_PROTOCOL_CHARACTERISTICS   PChars;
    NDIS_MINIPORT_CHARACTERISTICS   MChars;
    NDIS_STRING                     Name;

    ENTER("epvcRegisterIMDriver", 0x0d0f008a);
    
    pGlobals    = CONTAINING_RECORD(
                                      pObj,
                                      EPVC_GLOBALS,
                                      Hdr);



    TRACE (TL_T, TM_Dr, ("==>epvcRegisterIMDriver Globals %x", 
                         pObj) );

    //
    // Register the miniport with NDIS. Note that it is the miniport
    // which was started as a driver and not the protocol. Also the miniport
    // must be registered prior to the protocol since the protocol's BindAdapter
    // handler can be initiated anytime and when it is, it must be ready to
    // start driver instances.
    //
    NdisMInitializeWrapper(&pGlobals->driver.WrapperHandle, 
                       pGlobals->driver.pDriverObject, 
                       pGlobals->driver.pRegistryPath, 
                       NULL);
    NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    MChars.MajorNdisVersion = 5;
    MChars.MinorNdisVersion = 0;

    MChars.InitializeHandler = EpvcInitialize;
    MChars.QueryInformationHandler = EpvcMpQueryInformation;
    MChars.SetInformationHandler = EpvcMpSetInformation;
    MChars.ResetHandler = MPReset;
    MChars.TransferDataHandler = MPTransferData;
    MChars.HaltHandler = EpvcHalt;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //
    MChars.CheckForHangHandler = NULL;
    MChars.SendHandler = NULL;
    MChars.ReturnPacketHandler = EpvcReturnPacket;

    //
    // Either the Send or the SendPackets handler should be specified.
    // If SendPackets handler is specified, SendHandler is ignored
    //
     MChars.SendPacketsHandler = EpvcSendPackets;

    Status = NdisIMRegisterLayeredMiniport(pGlobals->driver.WrapperHandle,
                                           &MChars,
                                           sizeof(MChars),
                                           &EpvcGlobals.driver.DriverHandle);

    ASSERT  (EpvcGlobals.driver.DriverHandle != NULL);                                          
    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // todo: fix failure case
        //
        ASSERT (0);
    };


    //
    // Now register the protocol.
    //
    NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    PChars.MajorNdisVersion = 5;
    PChars.MinorNdisVersion = 0;

    //
    // Make sure the protocol-name matches the service-name under which this protocol is installed.
    // This is needed to ensure that NDIS can correctly determine the binding and call us to bind
    // to miniports below.
    //
    NdisInitUnicodeString(&Name, L"ATMEPVCP");  // Protocol name
    PChars.Name = Name;
    PChars.OpenAdapterCompleteHandler = EpvcOpenAdapterComplete;
    PChars.CloseAdapterCompleteHandler = EpvcCloseAdapterComplete;
    PChars.SendCompleteHandler = NULL;
    PChars.TransferDataCompleteHandler = PtTransferDataComplete;
    
    PChars.ResetCompleteHandler = EpvcResetComplete;
    PChars.RequestCompleteHandler =     EpvcRequestComplete ;
    PChars.ReceiveHandler = PtReceive;
    PChars.ReceiveCompleteHandler = EpvcPtReceiveComplete;
    PChars.StatusHandler = EpvcStatus;
    PChars.StatusCompleteHandler = PtStatusComplete;
    PChars.BindAdapterHandler = EpvcBindAdapter;
    PChars.UnbindAdapterHandler = EpvcUnbindAdapter;
    PChars.UnloadHandler = NULL;
    PChars.ReceivePacketHandler = PtReceivePacket;
    PChars.PnPEventHandler= EpvcPtPNPHandler;
    PChars.CoAfRegisterNotifyHandler = EpvcAfRegisterNotify;
    PChars.CoSendCompleteHandler = EpvcPtSendComplete;  
    PChars.CoReceivePacketHandler = EpvcCoReceive;
    

    {
        //
        // Update client characteristis
        //
        PNDIS_CLIENT_CHARACTERISTICS    pNdisCC     = &(pGlobals->ndis.CC);

        NdisZeroMemory(pNdisCC, sizeof(*pNdisCC));
        pNdisCC->MajorVersion                   = EPVC_NDIS_MAJOR_VERSION;
        pNdisCC->MinorVersion                   = EPVC_NDIS_MINOR_VERSION;
        pNdisCC->ClCreateVcHandler              = EpvcClientCreateVc;
        pNdisCC->ClDeleteVcHandler              = EpvcClientDeleteVc;
        pNdisCC->ClRequestHandler               = EpvcCoRequest;
        pNdisCC->ClRequestCompleteHandler       = EpvcCoRequestComplete;
        pNdisCC->ClOpenAfCompleteHandler        = EpvcCoOpenAfComplete;
        pNdisCC->ClCloseAfCompleteHandler       = EpvcCoCloseAfComplete;
        pNdisCC->ClMakeCallCompleteHandler      = EpvcCoMakeCallComplete;
        pNdisCC->ClModifyCallQoSCompleteHandler = NULL;
        pNdisCC->ClIncomingCloseCallHandler     = EpvcCoIncomingClose;
        pNdisCC->ClCallConnectedHandler         = EpvcCoCallConnected;
        pNdisCC->ClCloseCallCompleteHandler     = EpvcCoCloseCallComplete;
        pNdisCC->ClIncomingCallHandler          = EpvcCoIncomingCall;

    }

    NdisRegisterProtocol(&Status,
                         &pGlobals->driver.ProtocolHandle,
                         &PChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    ASSERT(Status == NDIS_STATUS_SUCCESS);

    NdisMRegisterUnloadHandler(pGlobals->driver.WrapperHandle, 
                               EpvcUnload);

    ASSERT (pGlobals == &EpvcGlobals);                                     

    
    NdisIMAssociateMiniport(EpvcGlobals.driver.DriverHandle, pGlobals->driver.ProtocolHandle);


    EXIT()
        
    TRACE (TL_T, TM_Dr, ("<==epvcRegisterIMDriver  ") );

    return Status;

}


RM_STATUS
epvcDeRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE (TL_T, TM_Pt, ("== eovcDeRegisterIMDriver"));

    while (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NdisDeregisterProtocol(&NdisStatus, EpvcGlobals.driver.ProtocolHandle);
        NdisMSleep(1000);
    }   


    return NdisStatus;
}



void
DbgMark(UINT Luid)
{
    // do nothing useful, but do something specific, so that the compiler doesn't
    // alias DbgMark to some other function that happens to do nothing.
    //
    static int i;
    i=Luid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\client.h ===
VOID
EpvcCoOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    );

VOID
EpvcCoCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    );




VOID
EpvcCoMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );




NDIS_STATUS
EpvcCoIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );


VOID
EpvcCoCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    );


VOID
EpvcCoIncomingClose(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
//
NDIS_STATUS
EpvcClientCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
EpvcClientDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

NDIS_STATUS
EpvcCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );


VOID
EpvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );

NDIS_STATUS
epvcPrepareAndSendNdisRequest(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PEPVC_NDIS_REQUEST          pEpvcNdisRequest,
    IN  REQUEST_COMPLETION          pFunc,              // OPTIONAL
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PEPVC_I_MINIPORT            pMiniport,          // OPTIONAL
    IN  BOOLEAN                     fPendedRequest,     // OPTIONAL
    IN  BOOLEAN                     fPendedSet,         // OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
epvcMiniportQueueWorkItem (
    IN PEPVC_WORK_ITEM pEpvcWorkItem,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PEVPC_WORK_ITEM_FUNC pFn,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcCoGenericWorkItem (
    IN PNDIS_WORK_ITEM pNdisWorkItem,
    IN PVOID Context
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\notify\sfilter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       S F I L T E R . H
//
//  Contents:   Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#pragma once
#include "sfiltern.h"
#include "resource.h"
#include "MyString.h"
#include "typedefs.h"


#define SINGLE_ADAPTER_ONLY 1

// What type of config change the user/system is performing
enum ConfigAction {eActUnknown, eActInstall, eActRemove, eActPropertyUI};

#define MAX_ADAPTERS 64         // max no. of physical adapters in a machine
//#define MAX_PATH   75
#define MaxPath 75

#define NO_BREAKS 1

#if NO_BREAKS
#define BREAKPOINT()
#else
#define BREAKPOINT() __asm int 3
#endif


typedef MyString tstring;
//
// This is the class to represent the IM Miniport.
//
class CIMMiniport
{

    public:
    CIMMiniport(
        VOID
        );

    VOID 
    SetIMMiniportBindName(
        PCWSTR pszIMMiniportBindName
        );

    PCWSTR 
    SzGetIMMiniportBindName(
        VOID
        );

    VOID 
    SetIMMiniportDeviceName(
        PCWSTR pszIMMiniportDeviceName
        );

    PCWSTR 
    SzGetIMMiniportDeviceName(
        VOID
        );

    VOID 
    SetIMMiniportName(
        PCWSTR pszIMMiniportName
        );

    VOID 
    SetIMMiniportName(
        PWSTR pszIMMiniportName
        );

    PCWSTR 
        SzGetIMMiniportName(
        VOID
        );

    DWORD DwGetIMMiniportNameLength(
        VOID
        );

    VOID SetNext (CIMMiniport *);       

    CIMMiniport* GetNext();

    VOID SetNextOld (CIMMiniport *);        

    CIMMiniport* GetNextOld();

    DWORD DwNumberOfIMMiniports();


    //
    // Member Variables (public) begin here
    //
    BOOL        m_fDeleted;
    BOOL        m_fNewIMMiniport;

    BOOL        m_fRemoveMiniportOnPropertyApply;
    BOOL        m_fCreateMiniportOnPropertyApply;

    
private:

    //
    // Private variables begin here
    //

    tstring     m_strIMMiniportBindName;
    tstring     m_strIMMiniportDeviceName;
    tstring     m_strIMMiniportName;
    CIMMiniport * pNext;
    CIMMiniport * pOldNext;
    
};



//------------------------------------------------
// CUnderlyingAdapter
//  - Class definition for the underlying adapter
//------------------------------------------------
class CUnderlyingAdapter
{
    public:

    //
    // Member functions
    //
    CUnderlyingAdapter(
        VOID
        );
    
    VOID 
    SetAdapterBindName(
        PCWSTR pszAdapterBindName
        );
        
    PCWSTR SzGetAdapterBindName(
        VOID
        );

    VOID 
    SetAdapterPnpId(
        PCWSTR szAdapterBindName
        );

    PCWSTR  
    SzGetAdapterPnpId(
        VOID
        );


        
    HRESULT 
    SetNext (
        CUnderlyingAdapter *
        );

    CUnderlyingAdapter *GetNext();

    DWORD DwNumberOfIMMiniports();

    //
    // Functions to access the lists
    //
    VOID AddIMiniport(CIMMiniport*);    
    CIMMiniport* IMiniportListHead();
    VOID SetIMiniportListHead(CIMMiniport* pNewHead);

    VOID AddOldIMiniport(CIMMiniport*); 
    CIMMiniport* OldIMiniportListHead();
    VOID SetOldIMiniportListHead(CIMMiniport* pHead);


    //
    // Public Variables
    //
    BOOLEAN     m_fBindingChanged;
    BOOLEAN     m_fDeleted;
    
    GUID   m_AdapterGuid ;
    CIMMiniport         *m_pIMMiniport;

    CIMMiniport         *m_pOldIMMiniport;

    
    
    
    private:

    //
    // Private variables
    //
    tstring             m_strAdapterBindName;
    tstring             m_strAdapterPnpId;
    CUnderlyingAdapter *pNext;
    DWORD           m_NumberofIMMiniports;

};

//------------------------------------------------
// CUnderlyingAdapter
//  - End
//------------------------------------------------




//------------------------------------------------
// CBaseClass 
//  - Base class for the entire notify object
//------------------------------------------------


class CBaseClass :
    public CComObjectRoot,
    public CComCoClass<CBaseClass, &CLSID_CBaseClass>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentNotifyGlobal
{
public:
    CBaseClass(VOID);
    ~CBaseClass(VOID);

    BEGIN_COM_MAP(CBaseClass)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CBaseClass)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAMPLE_FILTER)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR szAnswerFile,
                                     PCWSTR szAnswerSections);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();


// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

// Private methods
    HRESULT HrNotifyBindingAdd(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrNotifyBindingRemove(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrRemoveMiniportInstance(
        PCWSTR pszBindNameToRemove
        );

    HRESULT
    CBaseClass::HrRemoveComponent (
        INetCfg*            pnc,
        INetCfgComponent*   pnccToRemove
        );

    HRESULT HrFlushConfiguration();

    HRESULT HrFlushAdapterConfiguration(
        HKEY hkeyAdapterList,
        CUnderlyingAdapter *pAdapterInfo
        );

    HRESULT HrFlushMiniportList(
        HKEY hkeyAdapter,
        CUnderlyingAdapter *pAdapterInfo
        );
    


    HRESULT
    HrFindNetCardInstance(
        PCWSTR             pszBindNameToFind,
        INetCfgComponent** ppncc
        );



    HRESULT 
    HrReconfigEpvc(
        CUnderlyingAdapter* pAdapterInfo
        );

    
    HRESULT 
    HrLoadConfiguration(
        VOID
        );


    HRESULT 
    HrLoadAdapterConfiguration(
        HKEY hkeyAdapterList,
        PWSTR pszAdapterName
    );

    VOID
    AddUnderlyingAdapter(
        CUnderlyingAdapter  *);

    VOID
    SetUnderlyingAdapterListHead(
        CUnderlyingAdapter * 
        );

    CUnderlyingAdapter *
    GetUnderlyingAdaptersListHead();

    DWORD
    DwNumberUnderlyingAdapter();

    
    HRESULT
    HrLoadIMiniportConfiguration(
        HKEY hkeyMiniportList,
        PWSTR pszIMiniportName,
        CUnderlyingAdapter * pAdapterInfo
        );

    HRESULT
    HrLoadIMMiniportListConfiguration(
        HKEY hkeyAdapter,
        CUnderlyingAdapter* pAdapterInfo
        );

    HRESULT 
    HrFlushMiniportConfiguration(
    HKEY hkeyMiniportList, 
    CIMMiniport *pIMMiniport
    );
        
    HRESULT
    HrWriteMiniport(
        HKEY hkeyMiniportList, 
        CIMMiniport *pIMMiniport
    );


    HRESULT
    HrDeleteMiniport(
        HKEY hkeyMiniportList, 
        CIMMiniport *pIMMiniport
    );


private:
    INetCfgComponent*   m_pncc;  // Protocol's Net Config component
    INetCfg*            m_pnc;
    ConfigAction        m_eApplyAction;
    CUnderlyingAdapter  *m_pUnderlyingAdapter;

    IUnknown*           m_pUnkContext;
    UINT                m_cAdaptersAdded;
    BOOL                m_fDirty;
    BOOL                m_fUpgrade;
    BOOL                m_fValid;
    BOOL                m_fNoIMMinportInstalled;

    // Utility functions
public:

private:

};

//------------------------------------------------
// CBaseClass 
//  - End
//------------------------------------------------

#if 0
#if DBG
void TraceMsg(PCWSTR szFormat, ...);
#else
#define TraceMsg   (_Str)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\debug.h ===
// Copyright (c) 2000-2001, Microsoft Corporation, all rights reserved
//
// debug.h
// ATM - Ethernet Encapsulation Intermediate Driver 
// Debug helper header
//
//  03/23/2000 Adube Created.


#ifndef _DEBUG_H_
#define _DEBUG_H_






//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

#define MODULE_DRIVER 1
#define MODULE_MINIPORT 2
#define MODULE_PROTOCOL 3

//
//  These are the tags used in the allocation routines
//  so that the memory dumps will identify what structure
//  follows the tag.
//
//

#define TAG_FREED               'FvpE'
#define TAG_PROTOCOL            'PvpE'
#define TAG_ADAPTER             'AvpE'
#define TAG_TASK                'TvpE'
#define TAG_MINIPORT            'MvpE'
#define TAG_DEFAULT             'ZvpE'
#define TAG_WORKITEM            'WvpE'
#define TAG_RCV                 'RvpE'
//
// Trace Modules  used in debugging.
// Each module has its own number. 
//
#define TM_Dr   0x1 // Driver Entry
#define TM_Mp   0x2 // Miniport
#define TM_Pt   0x4 // Protocol
#define TM_Cl   0x20 // Client 
#define TM_Rq   0x40 // Requests
#define TM_Send 0x200 // Sends
#define TM_Recv 0x100 // Receive
#define TM_RM   0x400 // Resource Manager


//
// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_T    0x25 // Displays Entry and Exit points of all functions
#define TL_V    0x30 // Verbose
#define TL_D    0x40 // Dump packets



// Trace mask bits.
//

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Base 0x000000FF // Base only
#define TM_NoRM (TM_Base & (~(TM_RM|TM_Rq)))

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE( ulLevel, ulMask, Args)                             \
{                                                              \
    if ((ulLevel <= g_ulTraceLevel) && ((g_ulTraceMask & ulMask) )) \
    {                                                          \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "EPVC: !ASSERT( %s ) at line %d of %s\n",  \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else

extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;

#if TESTMODE
    #define epvcBreakPoint() DbgBreakPoint();
#else
    #define epvcBreakPoint() 
#endif


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#define epvcBreakPoint() 

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\client.c ===
#include "precomp.h"
#pragma hdrstop

#include "macros.h"


VOID
EpvcCoOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    )
{ 
    ENTER("OpenAdapterComplete", 0x5d75dabd)
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;
    PTASK_AF                pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
    RM_DECLARE_STACK_RECORD(sr)

    TRACE (TL_T, TM_Cl, (" == EpvcCoOpenAfComplete Context %p Status %x AfHAndle %x", 
                       pMiniport, Status, NdisAfHandle) );

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Store the Af Handle
    //

    if (NDIS_STATUS_SUCCESS == Status)
    {
        LOCKOBJ (pMiniport, &sr);
        pMiniport->af.AfHandle = NdisAfHandle;

        //
        // Update variables on the miniport structure
        // as this task has been given the go ahead
        //
        MiniportSetFlag (pMiniport, fMP_AddressFamilyOpened);
        MiniportClearFlag (pMiniport, fMP_InfoAfClosed);                

        epvcLinkToExternal(
            &pMiniport->Hdr,                    // pObject
            0x5546d299,
            (UINT_PTR)pMiniport->af.AfHandle ,              // Instance1
            EPVC_ASSOC_MINIPORT_OPEN_AF,            // AssociationID
            "    Open AF NdisHandle=%p\n",// szFormat
            &sr
            );


        

        UNLOCKOBJ(pMiniport, &sr);

    }
    else
    {
        ASSERT (pMiniport->af.AfHandle == NULL);
        
        pMiniport->af.AfHandle = NULL;
    }
    
    pAfTask ->ReturnStatus = Status; 

    //
    // Add an association between 
    //
    
    RmResumeTask (&pAfTask->TskHdr , 0, &sr); 
    RM_ASSERT_CLEAR(&sr);

    EXIT();
}


VOID
epvcCoCloseAfCompleteWorkItem(
    PRM_OBJECT_HEADER pObj,
    NDIS_STATUS Status,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Resuming  the Af task
    
Arguments:
    
    
--*/
{

    ENTER("epvcCoCloseAfCompleteWorkItem", 0xf6edfcb8)
    PEPVC_I_MINIPORT        pMiniport = NULL ;
    PTASK_AF                pAfTask = NULL;


    pMiniport = (PEPVC_I_MINIPORT)pObj ;

    LOCKOBJ (pMiniport, pSR);
    MiniportSetFlag (pMiniport, fMP_InfoAfClosed);  
    UNLOCKOBJ (pMiniport, pSR);
    
    pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
                                   
    
    if (NDIS_STATUS_SUCCESS==Status )
    {
        LOCKOBJ (pMiniport, pSR);

        epvcUnlinkFromExternal(
            &pMiniport->Hdr,                    // pObject
            0x5546d299,
            (UINT_PTR)pMiniport->af.AfHandle ,              // Instance1
            EPVC_ASSOC_MINIPORT_OPEN_AF,            // AssociationID
            pSR
            );

        pMiniport->af.AfHandle = NULL;
                    
        UNLOCKOBJ(pMiniport, pSR);

    }
    
    RmResumeTask (&pAfTask->TskHdr , 0, pSR); 

    EXIT();
    return;

}

VOID
EpvcCoCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    )
/*++

Routine Description:

    Signifies that the AF has been closed. 
    Resume the Af task - through a workitem 
    
Arguments:
    
    
--*/
{ 
    ENTER("EpvcCoCloseAfComplete ", 0x5d75dabd)
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;
    PTASK_AF                pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
    RM_DECLARE_STACK_RECORD(sr)
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseAfComplete Context %p Status %x ", 
                       pMiniport, Status) );

    //
    // Store the Status
    //

    pAfTask->ReturnStatus = Status; 

    //
    // Queue the WorkItem
    //
    epvcMiniportQueueWorkItem (
        &pMiniport->af.CloseAfWorkItem,
        pMiniport,
        epvcCoCloseAfCompleteWorkItem,
        Status,
        &sr
        );

    EXIT();
    RM_ASSERT_CLEAR(&sr);
    return;
}


VOID
EpvcCoMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     pCallParameters
    )
/*++

Routine Description:

    This is a notification from Ndis that the Make Call has completed. 
    We need to pass the Status back to the original thread, so use the Vc
    Task as a context
    
Arguments:
    
    
--*/
    
{
    ENTER ("EpvcCoMakeCallComplete", 0x1716ee4b)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) ProtocolVcContext;
    PTASK_VC            pTaskVc = pMiniport->vc.pTaskVc;

    RM_DECLARE_STACK_RECORD(SR);
    
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Cl, (" == EpvcCoMakeCallComplete Status %x", Status) );

    pTaskVc->ReturnStatus  = Status; 

    ASSERT (pCallParameters != NULL);
    epvcFreeMemory (pCallParameters ,CALL_PARAMETER_SIZE, 0);

    
    RmResumeTask (&pTaskVc->TskHdr, 0 , &SR);
        
    EXIT();
    RM_ASSERT_CLEAR(&SR);

}


VOID
epvcCoCloseCallCompleteWorkItem(
    PRM_OBJECT_HEADER pObj, 
    NDIS_STATUS Status,
    PRM_STACK_RECORD pSR            
    )
{ 
    ENTER ("EpvcCoCloseCallComplete", 0xbd67524a)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) pObj;
    PTASK_VC            pTaskVc = pMiniport->vc.pTaskVc;

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseCallComplete") );

    pTaskVc->ReturnStatus  = Status; 
    
    RmResumeTask (&pTaskVc->TskHdr, 0 , pSR);
    RM_ASSERT_CLEAR(pSR);

}


VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    )
{ 
    ENTER ("EpvcCoCloseCallComplete", 0xbd67524a)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) ProtocolVcContext;

    RM_DECLARE_STACK_RECORD(SR);

    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseCallComplete") );

    epvcMiniportQueueWorkItem (&pMiniport->vc.CallVcWorkItem,
                               pMiniport,
                               epvcCoCloseCallCompleteWorkItem,
                               Status,
                               &SR
                               );

    RM_ASSERT_CLEAR(&SR);

}





NDIS_STATUS
EpvcCoIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoIncomingCall") );
    return NDIS_STATUS_FAILURE;

}


VOID
EpvcCoCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoCallConnected") );

}


VOID
EpvcCoIncomingClose(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoIncomingClose") );

}


//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
//
NDIS_STATUS
EpvcClientCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
{

    TRACE (TL_T, TM_Cl, (" == EpvcClientCreateVc") );


    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
EpvcClientDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{
    TRACE (TL_T, TM_Cl, (" == EpvcClientDeleteVc") );
    return NDIS_STATUS_FAILURE;

}




NDIS_STATUS
EpvcCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        pNdisRequest
    )
/*++

Routine Description:

    This routine is called by NDIS when our Call Manager sends us an
    NDIS Request. NDIS Requests that are of significance to us are:
    - OID_CO_ADDRESS_CHANGE
        The set of addresses registered with the switch has changed,
        i.e. address registration is complete. We issue an NDIS Request
        ourselves to get the list of addresses registered.
    - OID_CO_SIGNALING_ENABLED
        We ignore this as of now.
        TODO: Add code that uses this and the SIGNALING_DISABLED
        OIDs to optimize on making calls.
    - OID_CO_SIGNALING_DISABLED
        We ignore this for now.
    - OID_CO_AF_CLOSE
        The Call manager wants us to shut down this AF open .

    We ignore all other OIDs.

Arguments:

    ProtocolAfContext           - Our context for the Address Family binding,
                                  which is a pointer to the ATMEPVC Interface.
    ProtocolVcContext           - Our context for a VC, which is a pointer to
                                  an ATMEPVC VC structure.
    ProtocolPartyContext        - Our context for a Party. Since we don't do
                                  PMP, this is ignored (must be NULL).
    pNdisRequest                - Pointer to the NDIS Request.

Return Value:

    NDIS_STATUS_SUCCESS if we recognized the OID
    NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/

{
    ENTER("EpvcCoRequest",0xcc5aff85)
    PEPVC_I_MINIPORT            pMiniport;
    NDIS_STATUS                 Status;
    RM_DECLARE_STACK_RECORD (SR)    
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;

    

    TRACE (TL_T, TM_Cl, (" ==> EpvcCoRequest") );


    
    //
    //  Initialize
    //
    Status = NDIS_STATUS_NOT_RECOGNIZED;

    if (pNdisRequest->RequestType == NdisRequestSetInformation)
    {
        switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
        {
            case OID_CO_ADDRESS_CHANGE:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_ADDRESS_CHANGE\n"));
                //
                //  The Call Manager says that the list of addresses
                //  registered on this interface has changed. Get the
                //  (potentially) new ATM address for this interface.
                Status = NDIS_STATUS_SUCCESS;
                break;
            
            case OID_CO_SIGNALING_ENABLED:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CoRequestHandler: CO_SIGNALING_ENABLED\n"));
                // ignored for now
                Status = NDIS_STATUS_FAILURE;
                break;

            case OID_CO_SIGNALING_DISABLED:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_SIGNALING_DISABLEDn"));
                // Ignored for now
                Status = NDIS_STATUS_FAILURE;
                break;

            case OID_CO_AF_CLOSE:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_AF_CLOSE on MINIPORT %x\n", pMiniport));

                Status = epvcProcessOidCloseAf(pMiniport, &SR);
        
                break;

            default:
                break;
        }
    }

    TRACE (TL_T, TM_Cl, (" <== EpvcCoRequest") );
    RM_ASSERT_CLEAR(&SR)
    EXIT()
    return (Status);
}




VOID
EpvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           pRequest
    )
{
    

    TRACE (TL_T, TM_Cl, (" == EpvcCoRequest pRequest %x", pRequest) );

        


}





NDIS_STATUS
epvcPrepareAndSendNdisRequest(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PEPVC_NDIS_REQUEST          pEpvcNdisRequest,
    IN  REQUEST_COMPLETION          pFunc,              // OPTIONAL
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PEPVC_I_MINIPORT            pMiniport,          // OPTIONAL
    IN  BOOLEAN                     fPendedRequest,     // OPTIONAL
    IN  BOOLEAN                     fPendedSet,         // OPTIONAL
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Send an NDIS Request to query an adapter for information.
    If the request pends, block on the EPVC Adapter structure
    till it completes.

Arguments:

    pAdapter                - Points to EPVCAdapter structure   
    pNdisRequest            - Pointer to UNITIALIZED NDIS request structure
    pTask                   - OPTIONAL Task. If NULL, we block until the operation
                              completes.
    PendCode                - PendCode to suspend pTask
    Oid                     - OID to be passed in the request
    pBuffer                 - place for value(s)
    BufferLength            - length of above
    pMiniport               - Minport associated withe this request - OPTIONAL
    fPendedRequest          - A request was pended at the miniport - OPTIONAL
    fPendedSet              - Pended a Set Request - OPTIONAL
    
Return Value:

    The NDIS status of the request.

--*/
{
    ENTER("epvcPrepareAndSendNdisRequest",0x1cc515d5)

    NDIS_STATUS         Status;
    PNDIS_REQUEST       pNdisRequest = &pEpvcNdisRequest->Request;

    TRACE (TL_T, TM_Cl, ("==>epvcSendAdapterNdisRequest pAdapter %x, pRequest %x",
                       pAdapter, pNdisRequest));

    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_V, TM_Rq, ("Cl Requesting Adapter %x, Oid %x, Buffer %x, Length %x, pFunc %x",
                         pAdapter,
                         Oid,
                         pBuffer,
                         BufferLength,
                         pFunc) );

    ASSERT (pNdisRequest != NULL);
    
    EPVC_ZEROSTRUCT(pEpvcNdisRequest);


    //
    //  Fill in the NDIS Request structure
    //
    if (RequestType == NdisRequestQueryInformation)
    {
        pNdisRequest->RequestType = NdisRequestQueryInformation;
        pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
    }
    else
    {
        ASSERT(RequestType == NdisRequestSetInformation);
        pNdisRequest->RequestType = NdisRequestSetInformation;
        pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
    }

    ASSERT (pAdapter->bind.BindingHandle != NULL);

    //
    // If the completion routine is not defined then wait for this request
    // to complete. 
    //

    if (pFunc == NULL)
    {
        // We might potentially wait.
        //
        ASSERT_PASSIVE();

        //
        //Insure that we aren't blocking a request that reached our miniport edge
        //
        ASSERT (pMiniport == NULL);

        NdisInitializeEvent(&pEpvcNdisRequest->Event);
        
        NdisRequest(
            &Status,
            pAdapter->bind.BindingHandle,
            pNdisRequest
            );
        if (PEND(Status))
        {
            NdisWaitEvent(&pEpvcNdisRequest->Event, 0);
            Status = pEpvcNdisRequest->Status;
        }

    }
    else
    {
        pEpvcNdisRequest->pFunc = pFunc;
        pEpvcNdisRequest->pMiniport = pMiniport;
        pEpvcNdisRequest->fPendedRequest  = fPendedRequest ;
        pEpvcNdisRequest->fSet = fPendedSet;
        
        //
        // Set up an assoc between the miniport and this request
        //


        epvcLinkToExternal (&pMiniport->Hdr,    // pHdr
                            0x46591e2d,         // LUID
                            (UINT_PTR)pEpvcNdisRequest, // External entity
                            EPVC_ASSOC_MINIPORT_REQUEST,    // AssocID
                            "NetWorKAddressRequest %p\n",
                             pSR
                             ) ;


        NdisRequest(
            &Status,
            pAdapter->bind.BindingHandle,
            pNdisRequest
            );
            
        if (!PEND(Status))
        {
            (pFunc) (pEpvcNdisRequest, Status);

            // Let this thread complete with a status of pending
            Status = NDIS_STATUS_PENDING;

        }
    }


    if (Status == NDIS_STATUS_SUCCESS)
    {
        TRACE(TL_V, TM_Rq,("Adapter Query - Oid %x", Oid));
        DUMPDW (TL_V, TM_Rq, pBuffer, BufferLength);
    }
    return Status;
}





VOID
epvcCoGenericWorkItem (
    IN PNDIS_WORK_ITEM pNdisWorkItem,
    IN PVOID Context
    )
/*++

Routine Description:

    Deref the miniport and invoke the function associated with 
    the workitem
    
Arguments:
    
    
--*/

{

    ENTER ("epvcCoGenericWorkItem ", 0x45b597e8)
    PEPVC_WORK_ITEM pEpvcWorkItem = (PEPVC_WORK_ITEM )pNdisWorkItem;
    RM_DECLARE_STACK_RECORD (SR);
    //
    // Deref the miniport or adapter
    //

    epvcUnlinkFromExternal(
        pEpvcWorkItem->pParentObj,                  // pObject
        0x3a70de02,
        (UINT_PTR)pNdisWorkItem,                // Instance1
        EPVC_ASSOC_WORKITEM,            // AssociationID
        &SR
        );



    //
    // Call the function so that the work is completed
    //
    (pEpvcWorkItem->pFn) (pEpvcWorkItem->pParentObj, pEpvcWorkItem->ReturnStatus, &SR);

    EXIT();

}


VOID
epvcMiniportQueueWorkItem (
    IN PEPVC_WORK_ITEM pEpvcWorkItem,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PEVPC_WORK_ITEM_FUNC pFn,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Set up the Epvc Work Item with the pfn, Status and , ref the miniport 
     and then queue the workitem    
Arguments:
    
    
--*/
{
    ENTER("epvcMiniportQueueWorkItem ", 0xc041af99); 

    //
    // Store the contexts 
    //

    pEpvcWorkItem->ReturnStatus = Status; 
    pEpvcWorkItem->pParentObj = &pMiniport->Hdr;
    pEpvcWorkItem->pFn = pFn;

    //
    // Ref the RM Obj (its a miniport or an adapter)
    //
    epvcLinkToExternal( &pMiniport->Hdr,
                         0x62efba09,
                         (UINT_PTR)&pEpvcWorkItem->WorkItem,
                         EPVC_ASSOC_WORKITEM,
                         "    WorkItem %p\n",
                         pSR);

    //
    // Queue the WorkItem
    //
    
    epvcInitializeWorkItem (&pMiniport->Hdr,
                            &pEpvcWorkItem->WorkItem,
                            epvcCoGenericWorkItem,
                            NULL,
                            pSR);


    EXIT()

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\macros.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Macros used in ATMEPVC

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/



#ifndef _MACROS_H
#define _MACROS_H


#define FALL_THROUGH    // For informational purpose in a switch statement


// Warning -- FAIL(NDIS_STATUS_PENDING) == TRUE
//
#define FAIL(_Status) ((_Status) != NDIS_STATUS_SUCCESS)
#define PEND(_Status) ((_Status) == NDIS_STATUS_PENDING)

#if RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
                        RmWriteLockObject((_pHdr), dbg_func_locid, (_psr))
#else // !RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
                        RmWriteLockObject((_pHdr), (_psr))
#endif // !RM_EXTRA_CHECKING

#define LOCKOBJ(_pObj, _psr) \
                        LOCKHDR(&(_pObj)->Hdr, (_psr))

#define UNLOCKHDR(_pHdr, _psr) \
                        RmUnlockObject((_pHdr), (_psr))
#define UNLOCKOBJ(_pObj, _psr) \
                        UNLOCKHDR(&(_pObj)->Hdr, (_psr))



#define EPVC_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

                

#define EPVC_FREE(_p)           NdisFreeMemory((_p), 0, 0)

#define EPVC_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof((_array)[0]))

#if RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr)\
                                    RmDbgAddAssociation(    \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_fmt),             \
                                        (_psr)              \
                                        )

#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr)         \
                                    RmDbgDeleteAssociation( \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_psr)              \
                                        )


// (debug only) Enumeration of types of associations.
//




#else // !RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr) (0)
#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr) (0)
#endif  // !RM_EXTRA_CHECKING





#define EPVC_ATPASSIVE()     (KeGetCurrentIrql()==PASSIVE_LEVEL)









#if DO_TIMESTAMPS

    void
    epvcTimeStamp(
        char *szFormatString,
        UINT Val
        );
    #define  TIMESTAMP(_FormatString) \
        epvcTimeStamp( "TIMESTAMP %lu:%lu.%lu ATMEPVC " _FormatString "\n", 0)
    #define  TIMESTAMP1(_FormatString, _Val) \
        epvcTimeStamp( "TIMESTAMP %lu:%lu.%lu ATMEPVC " _FormatString "\n", (_Val))

#else // !DO_TIMESTAMPS

    #define  TIMESTAMP(_FormatString)
    #define  TIMESTAMP1(_FormatString, _Val)
#endif // !DO_TIMESTAMPS


#define TRACE_BREAK(_Mod, Str)      \
    TRACE (TL_A, _Mod, Str);        \
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS); \
    break;

#define GET_ADAPTER_FROM_MINIPORT(_pM) _pM->pAdapter


//
// Miniport Flag access routines
//

#define MiniportTestFlag(_A, _F)                ((epvcReadFlags(&(_A)->Hdr.State) & (_F))!= 0)
#define MiniportSetFlag(_A, _F)                 (epvcSetFlags(&(_A)->Hdr.State, (_F)))
#define MiniportClearFlag(_A, _F)               (epvcClearFlags(&(_A)->Hdr.State, (_F)))
#define MiniportTestFlags(_A, _F)               ((epvcReadFlags(&(_A)->Hdr.State) & (_F)) == (_F))


//
// Adapter Flag access routines
//

#define AdapterTestFlag(_A, _F)                 ((epvcReadFlags(&(_A)->Hdr.State) & (_F))!= 0)
#define AdapterSetFlag(_A, _F)                  (epvcSetFlags(&(_A)->Hdr.State, (_F)))
#define AdapterClearFlag(_A, _F)                (epvcClearFlags(&(_A)->Hdr.State, (_F)))
#define AdapterTestFlags(_A, _F)                ((epvcReadFlags(&(_A)->Hdr.State) & (_F)) == (_F))

#define epvcLinkToExternal(_Hdr, _Luid, _Ext, _Num, _Str, _sr)  \
    RmLinkToExternalEx (_Hdr,_Luid,_Ext,_Num,_Str,_sr);


#define epvcUnlinkFromExternal(_Hdr, _Luid, _Ext, _Assoc, _sr)  \
        RmUnlinkFromExternalEx(                                     \
            _Hdr,                                                   \
            _Luid,                                                  \
            _Ext,                                                   \
            _Assoc,                                                 \
            _sr                                                     \
            );





/*++
ULONG
LINKSPEED_TO_CPS(
    IN  ULONG               LinkSpeed
)
Convert from NDIS "Link Speed" to cells per second
--*/
#define LINKSPEED_TO_CPS(_LinkSpeed)        (((_LinkSpeed)*100)/(48*8))




#define CALL_PARAMETER_SIZE     sizeof(CO_CALL_PARAMETERS) +   \
                                sizeof(CO_CALL_MANAGER_PARAMETERS) + \
                                sizeof(CO_MEDIA_PARAMETERS) + \
                                sizeof(ATM_MEDIA_PARAMETERS)




#define MP_OFFSET(field) ((UINT)FIELD_OFFSET(EPVC_I_MINIPORT,field))
#define MP_SIZE(field) sizeof(((PEPVC_I_MINIPORT)0)->field)


// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return (pBuf + MEMORY_ALLOCATION_ALIGNMENT);
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}



#define CanMiniportIndicate(_M) (MiniportTestFlag(_M, fMP_MiniportInitialized)== TRUE)


#define epvcIncrementMallocFailure()


#define ASSERTAndBreak(_condition)          ASSERT(_condition); break;

#define epvcSetSendPktStats()

#define epvcSendCompleteStats()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

    Abstract:

            Precompiled header file for ATMEPVC.SYS

            Author:


            Revision History:

Who         When        What
--------    --------    ----
 ADube      03-23-00   created 

--*/





//
// This file has all the C Defines that will be used in the compilation
// 
#include "ccdefs.h"

//
// Common header files in ntos\inc
//

#include <ndis.h>
#include <atm40.h>

//
// RM apis
//
#include "rmdbg.h"
#include "rm.h"

//
// Local Header files
//
#include "macros.h"
#include "debug.h"
#include "priv.h"
#include "util.h"
#include "client.h"
#include "miniport.h"
#include "protocol.h"
#include "wrapper.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\miniport.h ===
#ifndef _MINIPORT_H

#define _MINIPORT_H


//-------------------------------------------------------------//
//                                                              //
// Headers and Lengths used for Ethernet packets                    //
//                                                             //
//-------------------------------------------------------------//

#define MINIMUM_ETHERNET_LENGTH 64

#define ETHERNET_PADDING_LENGTH 2

// 64 bytes of zeroes - used in padding ethernet packets
extern UCHAR gPaddingBytes[MINIMUM_ETHERNET_LENGTH];

//-------------------------------------------------------------//
//                                                             //
// Function declarations                                          //
//                                                             //
//-------------------------------------------------------------//



PRM_OBJECT_HEADER
epvcIMiniportCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );


VOID
epvcIMiniportDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );


BOOLEAN
epvcIMiniportCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );

ULONG
epvcIMiniportHash(
    PVOID           pKey
    );

VOID
epvcVcSetupDone (
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcVcTeardownDone(
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    );
    
NDIS_STATUS
epvcSetPacketFilter(
    IN PEPVC_I_MINIPORT pMiniport,
    IN ULONG Filter,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
EpvcInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );
VOID
EpvcHalt(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );
NDIS_STATUS 
EpvcMpQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
);



NDIS_STATUS 
EpvcMpSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);







NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);


NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);


VOID
epvcSetupMakeCallParameters(
    PEPVC_I_MINIPORT pMiniport, 
    PCO_CALL_PARAMETERS *ppCallParameters
    );

VOID
epvcInitiateMiniportHalt(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PRM_STACK_RECORD pSR
    );

VOID
epvcMpHaltDoUnbind(
    PEPVC_I_MINIPORT pMiniport, 
    PRM_STACK_RECORD pSR
    );


NDIS_STATUS
epvcTaskHaltMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
    


NDIS_STATUS
epvcAddLLCEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pOldPkt,
    PNDIS_PACKET pNewPkt,
    PRM_STACK_RECORD pSR
    );
    
NDIS_STATUS
epvcAdapterSend(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    PRM_STACK_RECORD pSR
    );


VOID
epvcGetSendPkt (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pSentPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcFreeSendPkt(
    PEPVC_I_MINIPORT pMiniport,
    IN PEPVC_SEND_STRUCT pSendStruct
    );

NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );

NDIS_STATUS
epvcAddRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


NDIS_STATUS
epvcRemoveRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


VOID
EpvcSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );


NDIS_STATUS
epvcMiniportReadConfig(
    IN PEPVC_I_MINIPORT pMiniport,
    NDIS_HANDLE     WrapperConfigurationContext,
    PRM_STACK_RECORD pSR
    );


VOID
epvcDumpPkt (
    IN PNDIS_PACKET pPkt
    );

BOOLEAN
epvcCheckAndReturnArps (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET pPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    );

    
VOID
epvcFormulateArpResponse (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_ARP_CONTEXT pArpContext,
    IN PRM_STACK_RECORD pSR
    );
    


VOID
epvcInitializeMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    );


NDIS_STATUS
epvcInitializeMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    );


VOID
epvcDeleteMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcDeleteMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    );

NDIS_STATUS
epvcTaskRespondToArp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
epvcArpTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


VOID
epvcExtractPktInfo (
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket ,
    PEPVC_SEND_STRUCT       SendStruct
    );

NDIS_STATUS 
epvcRemoveEthernetHeader (
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );


NDIS_STATUS
epvcSendRoutine(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    PRM_STACK_RECORD pSR
    );

VOID
epvcSetPacketContext (
    IN PEPVC_SEND_STRUCT pSendStruct, 
    PRM_STACK_RECORD pSR
    );

VOID
epvcInitializeMiniportParameters(
    PEPVC_I_MINIPORT pMiniport
    );


VOID
epvcReturnPacketUsingAllocation(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    OUT PNDIS_PACKET *ppOriginalPacket,
    IN  PRM_STACK_RECORD        pSR

    );


VOID
epvcReturnPacketUsingStacks (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    IN  PRM_STACK_RECORD        pSR

    );

VOID
EpvcReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    );

VOID
epvcDerefSendPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    );


VOID
epvcDerefRecvPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    );
    
VOID
epvcRefRecvPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    );


NDIS_STATUS
epvcTaskCloseAddressFamily(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
epvcProcessReturnPacket (
    IN  PEPVC_I_MINIPORT    pMiniport,
    IN  PNDIS_PACKET        Packet,
    OUT PPNDIS_PACKET       ppOrigPacket, 
    IN  PRM_STACK_RECORD    pSR
    );

NDIS_STATUS 
epvcAddEthernetTail(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );

VOID
epvcRemoveEthernetTail (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket,
    IN PEPVC_PKT_CONTEXT pContext
    );

VOID
epvcRemoveEthernetPad (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket
    );

NDIS_STATUS 
epvcAddEthernetPad(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcCancelDeviceInstance(
    IN PEPVC_I_MINIPORT pMiniport ,
    IN PRM_STACK_RECORD pSR
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\miniport.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    ATM Ethernet PVC driver

Author:
    ADube - created
    
Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//--------------------------------------------------------------------------------
//                                                                              //
//  Global Variables used by miniports                                          //
//                                                                              //
//--------------------------------------------------------------------------------

static
NDIS_OID EthernetSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    };


MP_REG_ENTRY NICRegTable[] = {
// reg value name                  Offset in MP_ADAPTER            Field size        Default Value              Min             Max               
{NDIS_STRING_CONST("VCI"),       0, MP_OFFSET(config.vci),     MP_SIZE(config.vci),      0,                      0,              65535},
{NDIS_STRING_CONST("VPI"),       0, MP_OFFSET(config.vpi),     MP_SIZE(config.vpi),      0,                      0,              255},
{NDIS_STRING_CONST("Encap"),     0, MP_OFFSET(Encap),          MP_SIZE(Encap),           2,                      0,              3},
};
    

BOOLEAN g_bDumpPackets = FALSE;
BOOLEAN g_fDiscardNonUnicastPackets  = DISCARD_NON_UNICAST;

//-------------------------------------------------------------//
//                                                             //
// Pre defined LLC, SNAP and Other Headers for encapsulation        //
//                                                             //
//-------------------------------------------------------------//


//
// Ethernet Encapsulation
//
UCHAR LLCSnapEthernet[] = 
{
    0xaa, 0xaa,0x03, // LLC
    0x00, 0x80,0xc2, // OUI
    0x00, 0x07,      // PID
    0x00, 0x00       // PAD
};

//
// Ip v4 encapsulation
//
UCHAR LLCSnapIpv4[8] = 
{
    0xaa, 0xaa,0x03, // LLC
    0x00, 0x00,0x00, // OUI
    0x08, 0x00       // PID
};


UCHAR gPaddingBytes[MINIMUM_ETHERNET_LENGTH] = 
{
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0

};





//--------------------------------------------------------------------------------
//                                                                              //
//  miniports   functions                                                          //
//                                                                              //
//--------------------------------------------------------------------------------


VOID
epvcReturnPacketUsingAllocation(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    OUT PNDIS_PACKET *ppOriginalPacket,
    IN  PRM_STACK_RECORD        pSR

    )
/*++

Routine Description:
 Extracts the original packet 
 frees all the ndis buffers in new packet
 
 returns the original packet 
 

Arguments:


Return Value:


--*/
{   
    PNDIS_PACKET        pOrigPacket = NULL;
    PEPVC_PKT_CONTEXT   pPktContext = NULL;

    TRACE (TL_T, TM_Recv , ("==>epvcReturnPacketUsingAllocation  pMiniport %p, pPacket %p", 
                          pMiniport, 
                          Packet));

    pPktContext = (PEPVC_PKT_CONTEXT )(Packet->MiniportReservedEx);

    pOrigPacket = pPktContext->pOriginalPacket;

    if (pMiniport->fDoIpEncapsulation == TRUE)
    {
        //
        // Extract the lookaside buffer from the packet
        //
        PNDIS_BUFFER            pBuffer = Packet->Private.Head;
        PEPVC_IP_RCV_BUFFER     pIpBuffer= pPktContext ->Stack.ipv4Recv.pIpBuffer;


        if (pIpBuffer == NULL)
        {
            return ; // early return because of failure
        }
        ASSERT (pIpBuffer == NdisBufferVirtualAddress (pBuffer));

        

        //
        // Free the Lookaside Buffer
        //
        epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        
        //
        // In this case, we have allocated a new ndis buffer
        // so delete it and free the local memory
        epvcFreeBuffer (pBuffer);


        // 
        // The original packet is unchanged and well./
        //
    }
    else
    {
        //
        // This code path is used in both Ethernet and Ethernet+LLC encaps
        //

        // We only need to free the head of the packet as that was allocated
        // by us
        PNDIS_BUFFER            pNdisBuffer = Packet->Private.Head;

        if (pNdisBuffer != NULL)
        {
            epvcFreeBuffer (pNdisBuffer);
        }
    }

    
    epvcFreePacket(Packet,&pMiniport->PktPool.Recv);

    *ppOriginalPacket = pOrigPacket;


    TRACE (TL_T, TM_Recv , ("<==epvcReturnPacketUsingAllocation  pOrigPacket %p", 
                             *ppOriginalPacket));

    return;
}



VOID
epvcReturnPacketUsingStacks (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    IN  PRM_STACK_RECORD        pSR

    )
/*++

Routine Description:
    
    ipv4 - Restores the orginal Head and tail to this packet
    
 

Arguments:


Return Value:


--*/
{
    PEPVC_PKT_CONTEXT   pPktContext = NULL;
    BOOLEAN Remaining = FALSE; // Unused
    PNDIS_BUFFER    pOldHead = NULL;
    PNDIS_BUFFER    pOldTail = NULL;

    TRACE (TL_T, TM_Recv , ("==>epvcReturnPacketUsingStacks pMiniport %p, pPacket %p", 
                            pMiniport, 
                            Packet));
                            
    pPktContext = (PEPVC_PKT_CONTEXT ) NdisIMGetCurrentPacketStack(Packet, &Remaining);



    if (pMiniport->fDoIpEncapsulation == TRUE)
    {
        //
        // Extract the lookaside buffer from the packet
        //
        PNDIS_BUFFER            pBuffer = Packet->Private.Head;
        PEPVC_IP_RCV_BUFFER     pIpBuffer= pPktContext ->Stack.ipv4Recv.pIpBuffer;

        if (pIpBuffer == NULL)
        {
            return; // early return
        }

        //
        // Extract the old head and tail from the packet
        //
        pOldHead = pIpBuffer->pOldHead;
        pOldTail = pIpBuffer->pOldTail;


        // check to see if we are in this code path because of a failure
        if (pOldHead == NULL)
        {
            return; // early return
        }
        ASSERT (pOldHead != NULL);
        ASSERT (pOldTail != NULL);
        
        ASSERT (&pIpBuffer->u.Byte[0] == NdisBufferVirtualAddress (pBuffer));



        // 
        // Set The original Head and Tail
        //
        Packet->Private.Head = pOldHead;
        Packet->Private.Tail = pOldTail;

        Packet->Private.ValidCounts= FALSE;

        //
        // Free the Lookaside Buffer
        //
        epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        
        //
        // In this case, we have allocated a new ndis buffer
        // so delete it and free the local memory
        epvcFreeBuffer (pBuffer);
    }
    else
    {
        //
        // This code path is used in both Ethernet and Ethernet+LLC encaps
        //
        
        //
        // We need to free the head as that was locally allocated/
        // We need to revert back to the old Head and tail stored 
        // in the context
        //
        if (pPktContext->Stack.EthLLC.pOldHead == NULL)
        {
            return ; //early return 
        }

        epvcFreeBuffer (Packet->Private.Head);

        Packet->Private.Head = pPktContext->Stack.EthLLC.pOldHead;
        Packet->Private.Tail = pPktContext->Stack.EthLLC.pOldTail;

        Packet->Private.ValidCounts= FALSE;

    }

    TRACE (TL_T, TM_Recv , ("<==epvcReturnPacketUsingStacks ",pMiniport, Packet));

    return;

}


VOID
epvcProcessReturnPacket (
    IN  PEPVC_I_MINIPORT    pMiniport,
    IN  PNDIS_PACKET        Packet,
    OUT PPNDIS_PACKET       ppOrigPacket, 
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:
 Free all the locally allocated structures in the packet (packet , mdl, memory)
 Also be able to handle failure cases

Arguments:


Return Value:


--*/
{
    ENTER("epvcProcessReturnPacket", 0x7fafa89d)
    PNDIS_PACKET pOrigPacket = NULL;
    
    TRACE (TL_T, TM_Recv , ("==>epvcProcessReturnPacket  pMiniport %p, pPacket %p", 
                          pMiniport, 
                          Packet));

    if (Packet == NULL)
    {
        return;
    }
    //
    // Packet stacking: Check if this packet belongs to us.
    //
    
    if (NdisGetPoolFromPacket(Packet) != pMiniport->PktPool.Recv.Handle)
    {
        //
        // We reused the original packet in a receive indication.
        //
        epvcReturnPacketUsingStacks (pMiniport, Packet, pSR);
        pOrigPacket = Packet;
    }
    else
    {
        //
        // This is a packet allocated from this IM's receive packet pool.
        // Reclaim our packet, and return the original to the driver below.
        //
        epvcReturnPacketUsingAllocation(pMiniport, Packet, &pOrigPacket, pSR);
    }

    //
    // Update the output variable
    //
    if (ppOrigPacket)
    {
        *ppOrigPacket = pOrigPacket;
    }
    EXIT()
}
    



VOID
EpvcReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ENTER ("EpvcReturnPacket",0x58d2259e)
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    PNDIS_PACKET pOrigPacket = NULL;

    RM_DECLARE_STACK_RECORD (SR);

    // Free all the locally allocated structures in the packet
    //
    epvcProcessReturnPacket (pMiniport, Packet, &pOrigPacket ,&SR);

    // Return the original packet to ndis
    //
    if (pOrigPacket != NULL)
    {
        epvcReturnPacketToNdis(pMiniport, pOrigPacket, &SR);
    }
    else
    {
        ASSERT (!"Original packet is NULL\n");
    }
    
    EXIT();

}



NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    )
/*++

Routine Description:

    Miniport's transfer data handler.

Arguments:

    Packet                  Destination packet
    BytesTransferred        Place-holder for how much data was copied
    MiniportAdapterContext  Pointer to the adapter structure
    MiniportReceiveContext  Context
    ByteOffset              Offset into the packet for copying data
    BytesToTransfer         How much to copy.

Return Value:

    Status of transfer

--*/
{
    PEPVC_I_MINIPORT pMiniport= (PEPVC_I_MINIPORT)MiniportAdapterContext;
    NDIS_STATUS Status;

    //
    // Return, if the device is OFF
    //

    if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }


    NdisTransferData(&Status,
                     pMiniport->pAdapter->bind.BindingHandle,
                     MiniportReceiveContext,
                     ByteOffset,
                     BytesToTransfer,
                     Packet,
                     BytesTransferred);

    return(Status);
}







NDIS_STATUS
MPReset(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    )
/*++

Routine Description:

    Reset Handler. We just don't do anything.

Arguments:

    AddressingReset         To let NDIS know whether we need help from it with our reset
    MiniportAdapterContext  Pointer to our adapter

Return Value:


--*/
{
    PADAPT  pAdapt = (PADAPT)MiniportAdapterContext;



    *AddressingReset = FALSE;

    return(NDIS_STATUS_SUCCESS);
}


//
// The functions that do the LBFO work and bundling.
// If LBFO is turned off, then the Set Scondary API is never called and there are no bundles
//






//--------------------------------------------------------------------------------
//                                                                              //
//  Intermediate Miniports. We have one instantiation per address family.       //
//  Entry points used by the RM Apis                                            //
//                                                                              //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


PRM_OBJECT_HEADER
epvcIMiniportCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type EPVC_I_MINIPORT.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a EPVC_I_MINIPORT_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    PEPVC_I_MINIPORT            pIM;
    PEPVC_I_MINIPORT_PARAMS     pParams = (PEPVC_I_MINIPORT_PARAMS)pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_I_MiniportStaticInfo; 

    ENTER("IMiniport Create", 0x075b24c1);

    
    TRACE (TL_V, TM_Pt, ("--> epvcIMiniportCreate") );

    EPVC_ALLOCSTRUCT(pIM, TAG_MINIPORT  );
    do
    {


        if (pIM == NULL)
        {
            break;
        }

        EPVC_ZEROSTRUCT(pIM);

        pIM->Hdr.Sig = TAG_MINIPORT;

        //
        // Do all the initialization work here
        //

        RmInitializeLock(
            &pIM->Lock,
            LOCKLEVEL_MINIPORT
            );

        RmInitializeHeader(
            pParentObject,
            &pIM->Hdr,
            TAG_MINIPORT,
            &pIM->Lock,
            &EpvcGlobals_I_MiniportStaticInfo,
            NULL,
            psr
            );

        //
        // Now initialize the adapter structure with the parameters 
        // that were passed in.
        //

        Status = epvcCopyUnicodeString(
                        &(pIM->ndis.DeviceName),
                        pParams->pDeviceName,
                        TRUE                        // Upcase
                        );

        if (FAIL(Status))
        {
            pIM->ndis.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        //
        // initialize the informational stuff on the miniport
        //
        pIM->pAdapter               = pParams->pAdapter;
        pIM->info.PacketFilter      = 0;
        pIM->info.CurLookAhead      = pParams->CurLookAhead; 
        pIM->info.NumberOfMiniports     = pParams->NumberOfMiniports;
        pIM->info.LinkSpeed         = pParams->LinkSpeed.Outbound;
        pIM->info.MediaState        = pParams->MediaState;

        
        //
        //  Start by using the real ATM card's MAC address
        //
        
        NdisMoveMemory(
            &pIM->MacAddressEth,
            &pIM->pAdapter->info.MacAddress, 
            sizeof(MAC_ADDRESS)
            );

            //
            //  Not Elan number zero so generate a locally 
            //  administered address by manipulating the first two bytes.
            //
            pIM->MacAddressEth.Byte[0] = 
                0x02 | (((UCHAR)pIM->info.NumberOfMiniports & 0x3f) << 2);
            pIM->MacAddressEth.Byte[1] = 
                (pIM->pAdapter->info.MacAddress.Byte[1] & 0x3f) | 
                ((UCHAR)pIM->info.NumberOfMiniports & 0x3f);


            pIM->info.MacAddressDummy   =   pIM->MacAddressEth;

            pIM->info.MacAddressDummy.Byte[0]++;
            
            pIM->info.MacAddressDummy.Byte[1]++;

            pIM->info.MacAddressDummy.Byte[2]++;

        
        {
            //
            // Create a Dummy Mac address  for receive indications
            //
            pIM->info.MacAddressDest = pIM->MacAddressEth;
            
            
        
        }

        {
            //
            // Create an Ethernet Header to be used
            //
            PEPVC_ETH_HEADER    pRcvEnetHeader = &pIM->RcvEnetHeader ;

            pRcvEnetHeader->eh_daddr = pIM->info.MacAddressDest;
            pRcvEnetHeader->eh_saddr  = pIM->info.MacAddressDummy;
            pRcvEnetHeader->eh_type = net_short (IP_PROT_TYPE );  

        }

        pIM->info.McastAddrCount = 0;

        Status = NDIS_STATUS_SUCCESS;


    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pIM != NULL)
        {
            epvcIMiniportDelete ((PRM_OBJECT_HEADER) pIM, psr);
            pIM = NULL;
        }
    }

    TRACE (TL_V, TM_Pt, ("<-- epvcIMiniportCreate pIMiniport. %p",pIM) );

    return (PRM_OBJECT_HEADER) pIM;
}


VOID
epvcIMiniportDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type EPVC_I_MINIPORT.

Arguments:

    pHdr    - Actually a pointer to the EPVC_I_MINIPORT to be deleted.

--*/
{
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pObj;

    TRACE (TL_V, TM_Pt, ("-- epvcIMiniportDelete  pAdapter %p",pMiniport) );
    
    pMiniport->Hdr.Sig = TAG_FREED;

    EPVC_FREE   (pMiniport);
}




BOOLEAN
epvcIMiniportCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for EPVC_I_MINIPORT.

Arguments:

    pKey        - Points to a Epvc Protocol object.
    pItem       - Points to EPVC_I_MINIPORT.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    PEPVC_I_MINIPORT pIM = NULL;
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    BOOLEAN fCompare;

    pIM  = CONTAINING_RECORD(pItem, EPVC_I_MINIPORT, Hdr.HashLink);

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pIM->ndis.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pIM->ndis.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    

    TRACE (TL_V, TM_Pt, ("-- epvcProtocolCompareKey pIM %p, pKey, return %x",pIM, pKey, fCompare ) );

    return fCompare;
}



ULONG
epvcIMiniportHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an Epvc Protocol block.

Return Value:

    ULONG-sized hash of the string.
    

--*/
{
    TRACE(TL_T, TM_Mp, ("epvcIMiniportHash %x", pKey));
    {   
        PNDIS_STRING pName = (PNDIS_STRING) pKey;
        WCHAR *pwch = pName->Buffer;
        WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
        ULONG Hash  = 0;


        for (;pwch < pwchEnd; pwch++)
        {
            Hash ^= (Hash<<1) ^ *pwch;
        }
        
        return Hash;
    }
    
}





NDIS_STATUS
epvcTaskVcSetup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskVcSetup", 0x64085960)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_VC            pTaskVc     = (PTASK_VC) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_HANDLE         NdisVcHandle = NULL;
    PCO_CALL_PARAMETERS pCallParameters = NULL;


    enum 
    {
        Stage_Start =0, // default
        Stage_CreateVc,
        Stage_MakeCall,
        Stage_DeleteVc, // in case of failure
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task



    
    TRACE ( TL_T, TM_Pt, ("==> epvcTaskVcSetup %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->vc.pTaskVc)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->vc.pTaskVc);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->vc.pTaskVc == pTaskVc);
            //
            // Check to see if our work is already done
            //
            if (MiniportTestFlag(pMiniport,  fMP_MakeCallSucceeded) == TRUE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                pTaskVc->ReturnStatus = NDIS_STATUS_SUCCESS;

                
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }

            MiniportClearFlag (pMiniport,fMP_InfoCallClosed);
            MiniportSetFlag (pMiniport, fMP_InfoMakingCall);

            UNLOCKOBJ(pMiniport, pSR);

            //
            // Now begin the real work
            //

            //
            // Set up the call parameters. If it fails ,then exit
            //
            epvcSetupMakeCallParameters(pMiniport, &pCallParameters);

            if (pCallParameters  == NULL)
            {
                Status = NDIS_STATUS_FAILURE;
                pTaskVc->ReturnStatus = NDIS_STATUS_FAILURE;
                pTask->Hdr.State = Stage_TaskCompleted;
                break;
            
            }
            //
            // Create Vc - Syncronous call
            // 
            ASSERT (pAdapter->Hdr.Sig = TAG_ADAPTER);
            
            Status  = epvcCoCreateVc(pAdapter->bind.BindingHandle,
                                    pMiniport->af.AfHandle      OPTIONAL,   // For CM signalling VCs
                                    pMiniport,
                                    &NdisVcHandle);
                                    
            ASSERT (PEND(Status) == FALSE); // this is a synchronous call

            if (FAIL(Status) == TRUE)
            {       
                //
                // We have failed. This task is done. There are not
                // resources to be freed, although a flag has to be 
                // cleared
                //
                NdisVcHandle = NULL;
                pMiniport->vc.VcHandle = NULL;

                pTask->Hdr.State = Stage_TaskCompleted;
                break;
            }

            ASSERT (Status == NDIS_STATUS_SUCCESS);
            //
            // Store the Vc Handle
            //
            LOCKOBJ (pMiniport, pSR);

            pMiniport->vc.VcHandle = NdisVcHandle;
            epvcLinkToExternal( &pMiniport->Hdr,
                             0xf52962f1,
                             (UINT_PTR)pMiniport->vc.VcHandle,
                             EPVC_ASSOC_MINIPORT_OPEN_VC,
                             "    VcHandle %p\n",
                             pSR);


            UNLOCKOBJ (pMiniport, pSR);


    
            //
            // Do a Make Call
            //
            pTask->Hdr.State  = Stage_MakeCall;


            RmSuspendTask(pTask, 0, pSR);
            
            Status = epvcClMakeCall(NdisVcHandle,
                                 pCallParameters,
                                 NULL,  //Party Context
                                 NULL // PartyHandle
                                 );
                                 
            if (NDIS_STATUS_PENDING !=Status)
            {
                EpvcCoMakeCallComplete(Status,
                                      pMiniport,
                                      NULL,
                                      0);
                
                
            }
            break;  
        }
        case Stage_MakeCall:
        {
            //
            // The make call has been completed. 
            // If we have succeeded then we update our flags 
            // and exit.
            //
            // If the make call has failed, then I need to delete the VC
            //

            ASSERT (NDIS_STATUS_CALL_ACTIVE  != pTaskVc->ReturnStatus);
            
            if (NDIS_STATUS_SUCCESS == pTaskVc->ReturnStatus)
            {
                LOCKOBJ(pMiniport, pSR);

                MiniportSetFlag (pMiniport, fMP_MakeCallSucceeded);
                MiniportClearFlag (pMiniport, fMP_InfoMakingCall);

    
                UNLOCKOBJ (pMiniport, pSR);

                
            
            }
            else
            {
                NDIS_HANDLE VcHandle = NULL;
                //
                // Delete the VC, as we do not want a VC without an active 
                // Make call on it.
                //
                ASSERT (NDIS_STATUS_SUCCESS == pTaskVc->ReturnStatus);              
                                        
                LOCKOBJ(pMiniport, pSR);

                VcHandle = pMiniport->vc.VcHandle;
                
                epvcUnlinkFromExternal( &pMiniport->Hdr,
                                        0xa914405a,
                                        (UINT_PTR)pMiniport->vc.VcHandle,
                                        EPVC_ASSOC_MINIPORT_OPEN_VC, 
                                        pSR);

                pMiniport->vc.VcHandle = NULL;

                UNLOCKOBJ (pMiniport, pSR);

                TRACE (TL_I, TM_Mp,("Deleting Vc because of a failure in MakeCall"));

                Status = epvcCoDeleteVc(VcHandle);
                
                //
                // TODO: Fix Failure case
                //
                ASSERT (NDIS_STATUS_SUCCESS == Status );

                
            
                
            }

            //
            // This task is over. Now do the indications
            //
            pTask->Hdr.State = Stage_TaskCompleted;

            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        

    } // end of switch 

    if ( Stage_TaskCompleted == pTask->Hdr.State )
    {

        pTask->Hdr.State = Stage_End;

        ASSERT (NDIS_STATUS_PENDING !=Status );

        //
        // Do any cleanup indications to NDIS over here
        //
        epvcVcSetupDone ( pTaskVc, pMiniport);

        LOCKOBJ(pMiniport, pSR);

        pMiniport->vc.pTaskVc = NULL;
    
        UNLOCKOBJ (pMiniport, pSR);

        

    }

    TRACE ( TL_T, TM_Mp, ("<== epvcTaskVcSetup , Status %x",Status) );

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return Status;          

}


VOID
epvcVcSetupDone (
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    If the task was queued because of SetPacket Filter request then 
    this function completes the request.

    If the task was run because of the Indicate Media Connect event, then
    this thread indicates a Media Connect to NDIS

Arguments:
    Status  - Did the VcSetup Succeed or Fail
    pTaskVc - Task in question
    pMiniport - the Miniport that the task operated on
    
Return Value:

    None:
    
--*/
    
{


    if (TaskCause_NdisRequest == pTaskVc->Cause )
    {
        //
        // Since requests are serialized, we don't acquire the lock
        //
        TRACE (TL_V, TM_Rq, ("Completing SetPacketFilter Request %x", pTaskVc->ReturnStatus ));

        if (pTaskVc->ReturnStatus == NDIS_STATUS_SUCCESS)
        {
            pMiniport->info.PacketFilter = pTaskVc->PacketFilter;
        }
        NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle, pTaskVc->ReturnStatus);

    }
    else
    {
        ASSERT (TaskCause_MediaConnect == pTaskVc->Cause );

        pMiniport->info.MediaState = NdisMediaStateConnected;
        
        NdisMIndicateStatus ( pMiniport->ndis.MiniportAdapterHandle,
                              NDIS_STATUS_MEDIA_CONNECT,
                              NULL,
                              0);
    }


}



NDIS_STATUS
epvcTaskVcTeardown(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskVcTeardown", 0x68c96c4d)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_VC            pTaskVc     = (PTASK_VC) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_HANDLE         NdisVcHandle = NULL;
    PCO_CALL_PARAMETERS pCallParameters = NULL;


    enum 
    {
        Stage_Start =0, // default
        Stage_CloseCallComplete,
        Stage_DeleteVc, 
        Stage_TaskCompleted,
        Stage_End
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskVcTeardown %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->vc.pTaskVc)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->vc.pTaskVc);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->vc.pTaskVc == pTaskVc);
            //
            // Check to see if our work is already done
            //
            if (MiniportTestFlag(pMiniport,  fMP_MakeCallSucceeded) == FALSE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }

            
            MiniportClearFlag (pMiniport, fMP_MakeCallSucceeded);
            MiniportSetFlag (pMiniport, fMP_InfoClosingCall);
    
            UNLOCKOBJ(pMiniport, pSR);

            //
            // Now close the call - Asynchronously. 
            //
            pTask->Hdr.State = Stage_CloseCallComplete;

            RmSuspendTask (pTask, 0, pSR);
            
            Status = epvcClCloseCall( pMiniport->vc.VcHandle);

            if (NDIS_STATUS_PENDING != Status)
            {
                EpvcCoCloseCallComplete (Status,
                                         pMiniport,
                                         NULL
                                         );
                
            }

            Status = NDIS_STATUS_PENDING;
            break;
        }

        case Stage_CloseCallComplete:
        {
            NDIS_HANDLE VcHandle = NULL;
            
            LOCKOBJ(pMiniport, pSR);

            VcHandle = pMiniport->vc.VcHandle;
            
            epvcUnlinkFromExternal(&pMiniport->Hdr,
                                   0x5d7b5ea8,
                                   (UINT_PTR)pMiniport->vc.VcHandle,
                                   EPVC_ASSOC_MINIPORT_OPEN_VC,
                                   pSR);

            pMiniport->vc.VcHandle = NULL;
            
            UNLOCKOBJ(pMiniport, pSR);

            Status = epvcCoDeleteVc(VcHandle);
            //
            // This is an assertion because the DeleteVc cannot fail.
            // We do a DeleteVc in one place only and it is serialized.
            //

            ASSERT (Status == NDIS_STATUS_SUCCESS);

            pTask->Hdr.State = Stage_TaskCompleted;

            break;
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        
        
    }


    if (Stage_TaskCompleted == pTask->Hdr.State )
    {
        pTask->Hdr.State  = Stage_End;

        //
        // Complete the request or the Media Disconnect;
        //
        epvcVcTeardownDone(pTaskVc, pMiniport);

        LOCKOBJ (pMiniport, pSR);

        //
        // Update informational flags
        //
        MiniportClearFlag (pMiniport, fMP_InfoClosingCall);
        MiniportSetFlag (pMiniport, fMP_InfoCallClosed);

        pMiniport->vc.pTaskVc = NULL;
    
        
        UNLOCKOBJ(pMiniport, pSR);
    }
    TRACE ( TL_T, TM_Mp, ("<== epvcTaskVcTeardown , Status %x",Status) );

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return Status;          

}



VOID
epvcVcTeardownDone(
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    )
{
    TRACE ( TL_T, TM_Mp, ("==> epvcVcTeardownDone ") );

    switch (pTaskVc->Cause)
    {
        case TaskCause_NdisRequest:
        {

            ASSERT (pTaskVc->ReturnStatus != NDIS_STATUS_PENDING);

            //
            // Since requests are serialized, we don't acquire the lock
            //
            pMiniport->info.PacketFilter = pTaskVc->PacketFilter;

            NdisMSetInformationComplete(pMiniport->ndis.MiniportAdapterHandle,
                                        pTaskVc->ReturnStatus);
            
            break;
        }
        case TaskCause_MediaDisconnect:
        {
        
            pMiniport->info.MediaState = NdisMediaStateDisconnected;
            
            epvcMIndicateStatus ( pMiniport,
                                  NDIS_STATUS_MEDIA_DISCONNECT,
                                  NULL,
                                  0);
            break;
        }

        default:
        {
            // Do nothing.
            //
        }
        




    }

    
    


    TRACE ( TL_T, TM_Mp, ("<== epvcVcTeardownDone ") );

}





NDIS_STATUS
EpvcInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    )
/*++

Routine Description:

    This is the initialize handler which gets called as a result of the BindAdapter handler
    calling NdisIMInitializeDeviceInstanceEx(). The context parameter which we pass there is
    the adapter structure which we retreive here. We also need to initialize the Power Management
    variable.
    LoadBalalncing- We keep a global list of all the passthru miniports installed and bundle
    two of them together if they have the same BundleId (read from registry)

    Arguments:

    OpenErrorStatus         Not used by us.
    SelectedMediumIndex     Place-holder for what media we are using
    MediumArray             Array of ndis media passed down to us to pick from
    MediumArraySize         Size of the array
    MiniportAdapterHandle   The handle NDIS uses to refer to us
    WrapperConfigurationContext For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    ENTER ("EpvcInitialize", 0xa935a2a5)
    UINT    i;
    PEPVC_I_MINIPORT                pMiniport = NULL;
    NDIS_STATUS                     Status = NDIS_STATUS_FAILURE;
    KIRQL                           OldIrql;
    
    enum 
    {
        Stage_Start,
        Stage_AllocatedPacketPools,
        Stage_AllocatedLookasideLists
    };

    ULONG                           State = Stage_Start;

    RM_DECLARE_STACK_RECORD (SR);
    
    TRACE (TL_T, TM_Mp, ("==>EpvcInitialize MiniportAdapterHandle %x", MiniportAdapterHandle));

    //
    // Start off by retrieving the adapter context and storing the Miniport handle in it
    //
    pMiniport = NdisIMGetDeviceContext(MiniportAdapterHandle);

    if (pMiniport->Hdr.Sig != TAG_MINIPORT)
    {
        ASSERT (pMiniport->Hdr.Sig == TAG_MINIPORT);
        return NDIS_STATUS_FAILURE;
    }
    
    pMiniport->ndis.MiniportAdapterHandle  = MiniportAdapterHandle;

    //
    // Make sure the medium saved is one of the ones being offered
    //

    for (i = 0; i < MediumArraySize; i++)
    {
        if (MediumArray[i] == ATMEPVC_MP_MEDIUM )
        {
            *SelectedMediumIndex = i;
            break;
        }
    }

    if (i == MediumArraySize)
    {
        return(NDIS_STATUS_UNSUPPORTED_MEDIA);
    }


    //
    // Set the attributes now. The NDIS_ATTRIBUTE_DESERIALIZE is the key. This enables us
    // to make up-calls to NDIS w/o having to call NdisIMSwitchToMiniport/NdisIMQueueCallBack.
    // This also forces us to protect our data using spinlocks where appropriate. Also in this
    // case NDIS does not queue packets on out behalf. Since this is a very simple pass-thru
    // miniport, we do not have a need to protect anything. However in a general case there
    // will be a need to use per-adapter spin-locks for the packet queues at the very least.
    //
    NdisMSetAttributesEx(MiniportAdapterHandle,
                         pMiniport,
                         0,                                     // CheckForHangTimeInSeconds
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT   |
                            NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                            NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                            NDIS_ATTRIBUTE_DESERIALIZE,                         
                         0);


    //
    // We are done, with the no failure stuff. From now on we need to undo
    //

    do
    {

        Status = epvcMiniportReadConfig(pMiniport, WrapperConfigurationContext,&SR  );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            // Undo Configuration values
            // 
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;

        }

        epvcInitializeMiniportParameters(pMiniport);

        
        //
        // allocate Packet pools.
        //

        Status = epvcInitializeMiniportPacketPools (pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

        State = Stage_AllocatedPacketPools;
 

        //
        // Allocate lookaside lists
        //

        epvcInitializeMiniportLookasideLists(pMiniport);


        State = Stage_AllocatedLookasideLists;


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    

    TRACE (TL_T, TM_Mp, ("<==EpvcInitialize pMiniport %x, Status %x", pMiniport, Status ));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        BOOLEAN fSetDeInit = FALSE;
        
        LOCKOBJ(pMiniport, &SR);
        MiniportSetFlag(pMiniport, fMP_MiniportInitialized);

        if (MiniportTestFlag (pMiniport, fMP_MiniportCancelInstance))
        {
            fSetDeInit = TRUE;
        }
        UNLOCKOBJ(pMiniport, &SR);

        //
        // Check to see if we have a DeInit Waiting for us.
        // This will only be set if a Cancel Device Instance fails.
        //
        if (fSetDeInit  == TRUE)
        {
            epvcSetEvent (&pMiniport->pnp.DeInitEvent);
        }
    }
    else
    {
        //
        // Undo Code
        //
        ASSERT (FAIL(Status) == TRUE);
        
        switch (State)
        {

            case Stage_AllocatedLookasideLists:

                epvcDeleteMiniportLookasideLists (pMiniport);

                FALL_THROUGH
                
            case Stage_AllocatedPacketPools:

                epvcDeleteMiniportPacketPools(pMiniport);
                FALL_THROUGH


            default:
                break;



        }



    }


    RM_ASSERT_CLEAR(&SR);
    EXIT();
    return Status;
}


VOID
EpvcHalt(
    IN  NDIS_HANDLE             MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler. All the hard-work for clean-up is done here.

Arguments:

    MiniportAdapterContext  Pointer to the Adapter

Return Value:

    None.

--*/
{
    ENTER("EpvcHalt",0x6b407ae1)
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    PEPVC_ADAPTER       pAdapter    = pMiniport->pAdapter;
    PRM_TASK            pTask       = NULL;
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;

    RM_DECLARE_STACK_RECORD (SR);
    
    TRACE (TL_V, TM_Mp, ("==>Epvc MPHaltMiniport"));

    do
    {
        LOCKOBJ (pMiniport, &SR);
        //
        // Clear the flag so we can block all sends/receives/requests
        //
        MiniportClearFlag(pMiniport, fMP_MiniportInitialized);
        MiniportSetFlag(pMiniport, fMP_InfoHalting);                    
    
        //
        // Ref the miniport, this indirectly refs the adpater as well
        //
        RmTmpReferenceObject (&pMiniport->Hdr, &SR);

        //
        // Kick of the miniport halt task and wait for it to complete
        //
        Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskHaltMiniport,   // pfnHandler,
                0,                          // Timeout,
                "Task: Halt Intermediate Miniport", // szDescription
                &pTask,
                &SR
                );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        //
        // Reference the task so it is around until our Wait for completion
        // is complete
        //
        RmTmpReferenceObject (&pTask->Hdr, &SR);

        UNLOCKOBJ (pMiniport, &SR);

        //
        // This Kicks of the task that will close the Call, Delete
        // the VC and close the AF. We do this all synchronously
        //
        {
            PTASK_HALT pHalt = (PTASK_HALT) pTask;
            
            epvcInitializeEvent (&pHalt->CompleteEvent);
            
            RmStartTask(pTask, 0, &SR);

            TRACE (TL_V, TM_Mp, ("About to Wait - for Halt Complete Event"));

            epvcWaitEvent (&pHalt->CompleteEvent, WAIT_INFINITE);

            TRACE (TL_V, TM_Mp, ("Wait Complete- for Halt Complete Event"));


        }       

        LOCKOBJ (pMiniport, &SR);

        //
        // Deref the task . Ref was made above.
        //
        
        RmTmpDereferenceObject (&pTask->Hdr, &SR);


    } while (FALSE);    


    MiniportClearFlag(pMiniport, fMP_InfoHalting);

    UNLOCKOBJ(pMiniport, &SR);

    RmTmpDereferenceObject(&pMiniport->Hdr, &SR);


    RM_ASSERT_CLEAR(&SR);

    TRACE (TL_V, TM_Mp, ("<==Epvc MPHaltMiniport"));

}



VOID    
epvcSetPacketFilterWorkItem (
    PNDIS_WORK_ITEM  pWorkItem, 
    PVOID Context
    )
/*++
Routine Description:

    Decrements the refcount on the filter and processes the new packet filter
    

Return Value:

    None
    
--*/
{
    ENTER ("epvcSetPacketFilterWorkItem  ",0x3e1cdbba )
    PEPVC_I_MINIPORT    pMiniport = NULL;
    PRM_TASK            pTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    UINT                Filter ;
    
    RM_DECLARE_STACK_RECORD (SR);


    do
    {
        pMiniport = CONTAINING_RECORD (pWorkItem, 
                                       EPVC_I_MINIPORT,
                                       vc.PacketFilterWorkItem) ;

        //
        // Dereference the workitem off the miniport 
        //
            

        epvcUnlinkFromExternal( &pMiniport->Hdr,
                             0xa1f5e3cc,
                             (UINT_PTR)pWorkItem,
                             EPVC_ASSOC_SET_FILTER_WORKITEM,
                             &SR);

        //
        // Start the task to create or delete the VC
        //
        Filter = pMiniport->vc.NewFilter ;
        //
        // If this is a repition, then succeed it synchronously
        //
        if (Filter  == pMiniport->info.PacketFilter)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        LOCKOBJ(pMiniport, &SR);

        //
        // Are we moving to a Zero filter value
        //

        if (Filter  == 0)
        {
            //
            // Delete the Vc, so that we stop doing any receives
            // 

            Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskVcTeardown, // pfnHandler,
                0,                          // Timeout,
                "Task: Delete Vc",  // szDescription
                &pTask,
                &SR
                );


        }
        else
        {
            //
            // We are moving a non-zero values
            //

            //
            // Create the Vc, so that we can send 
            // 

            Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskVcSetup,    // pfnHandler,
                0,                          // Timeout,
                "Task: Create Vc",  // szDescription
                &pTask,
                &SR
                );



        }

        UNLOCKOBJ(pMiniport, &SR);
        
        if (FAIL(Status) == TRUE)
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate create/ delete Vc task!\n"));
            ASSERT (0);
            break;
        }
        


        //
        // Update the cause if the task
        //
        
        ((PTASK_VC)pTask)->Cause = TaskCause_NdisRequest;
        ((PTASK_VC)pTask)->PacketFilter  = Filter  ;
        
        RmStartTask(pTask, 0, &SR);

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);

    //
    // complete the request if the task has not been started
    //
    if (PEND(Status) != TRUE)
    {
        NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle, Status);

    }

    EXIT();
}




NDIS_STATUS
epvcSetPacketFilter(
    IN PEPVC_I_MINIPORT pMiniport,
    IN ULONG Filter,
    PRM_STACK_RECORD pSR
    )

/*++
Routine Description:

    This routine is called when a miniport get a set packet filter.
    It validates the arguments, If all is well then it process the request

    For a non-zero filter, a create VC and a Make call is done.
    For a zero filter, the call is closed and the Vc Deleted

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    ENTER ("epvcSetPacketFilter", 0x97c6b961)
    NDIS_STATUS Status = NDIS_STATUS_PENDING;
    PNDIS_WORK_ITEM pSetFilterWorItem = &pMiniport->vc.PacketFilterWorkItem; 
    PRM_TASK pTask = NULL;

    
    TRACE (TL_T, TM_Mp, ("==>epvcSetPacketFilter Filter %X", Filter ));

    do
    {
        LOCKOBJ (pMiniport, pSR);

        epvcLinkToExternal( &pMiniport->Hdr,
                             0x20bc1fbf,
                             (UINT_PTR)pSetFilterWorItem,
                             EPVC_ASSOC_SET_FILTER_WORKITEM,
                             "    PacketFilterWorkItem %p\n",
                             pSR);

        //
        // Update the cause of the task
        //
        UNLOCKOBJ(pMiniport, pSR);


        //
        // Now schedule the work item so it runs at passive level and pass the Vc as
        // an argument
        //

        pMiniport->vc.NewFilter = Filter;
        
        NdisInitializeWorkItem ( pSetFilterWorItem , 
                             (NDIS_PROC)epvcSetPacketFilterWorkItem ,
                             (PVOID)pTask );

                            

        NdisScheduleWorkItem (pSetFilterWorItem );

            

        Status = NDIS_STATUS_PENDING;


    } while (FALSE);
    


    TRACE (TL_T, TM_Mp, ("<==epvcSetPacketFilter %x", Status));

    EXIT();
    return Status;
}



NDIS_STATUS 
EpvcMpQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    The QueryInformation Handler for the virtual miniport.

Arguments:

    MiniportAdapterContext  - a pointer to the Elan.

    Oid                     - the NDIS_OID to process.

    InformationBuffer       - a pointer into the NdisRequest->InformationBuffer
                              into which store the result of the query.

    InformationBufferLength - a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten            - a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded             - If there is not enough room in the information
                              buffer then this will contain the number of bytes
                              needed to complete the request.

Return Value:

    The function value is the status of the operation.

--*/
{
    ENTER ("EpvcMpQueryInformation", 0x3da2473b)
    UINT                    BytesLeft       = InformationBufferLength;
    PUCHAR                  InfoBuffer      = (PUCHAR)(InformationBuffer);
    NDIS_STATUS             StatusToReturn  = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIUM             Medium;
    PEPVC_I_MINIPORT        pMiniport = NULL;   
    PEPVC_ADAPTER           pAdapter= NULL;
    ULONG                   GenericULong =0;
    USHORT                  GenericUShort=0;
    UCHAR                   GenericArray[6];
    UINT                    MoveBytes       = sizeof(ULONG);
    PVOID                   MoveSource      = (PVOID)(&GenericULong);
    ULONG                   i=0;
    BOOLEAN                 IsShuttingDown = FALSE;
    RM_DECLARE_STACK_RECORD (SR);
        
    TRACE(TL_T, TM_Rq, ("==>EpvcMpQueryInformation pMiniport %x, Oid, Buffer %x, Length, %x",
                       pMiniport,
                       Oid,
                       InformationBuffer,
                       InformationBufferLength));               

    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;


    LOCKOBJ(pMiniport, &SR);
    IsShuttingDown = (! MiniportTestFlag(pMiniport, fMP_MiniportInitialized));
    pAdapter = pMiniport->pAdapter;
    UNLOCKOBJ(pMiniport,&SR);

    //
    // Switch on request type
    //
    switch (Oid) 
    {
        case OID_GEN_MAC_OPTIONS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAC_OPTIONS"));

            GenericULong =                      
                NDIS_MAC_OPTION_NO_LOOPBACK;

            break;

        case OID_GEN_SUPPORTED_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_SUPPORTED_LIST"));

            MoveSource = (PVOID)(EthernetSupportedOids);
            MoveBytes = sizeof(EthernetSupportedOids);

            break;

        case OID_GEN_HARDWARE_STATUS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_HARDWARE_STATUS"));

            HardwareStatus = NdisHardwareStatusReady;
            MoveSource = (PVOID)(&HardwareStatus);
            MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MEDIA_CONNECT_STATUS"));

            MoveSource = (PVOID)(&pMiniport->info.MediaState);
            MoveBytes = sizeof(NDIS_MEDIA_STATE);

            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MEDIA_SUPPORTED"));
            Medium = ATMEPVC_MP_MEDIUM;

            MoveSource = (PVOID) (&Medium);
            MoveBytes = sizeof(NDIS_MEDIUM);

            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_LOOKAHEAD"));

            GenericULong = pMiniport->info.CurLookAhead;
            
            
            break;
            
        case OID_GEN_CURRENT_LOOKAHEAD:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_CURRENT_LOOKAHEAD"));
            GenericULong  = pMiniport->info.CurLookAhead  ;
            
            
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_FRAME_SIZE"));
            // 
            // Similiar to AtmLane . Take the size of the Ethernet frame and strip the
            // ethernet header off. 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE  - EPVC_ETH_HEADERSIZE   ;
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_TOTAL_SIZE"));
            //
            // This value is inclusive of headers 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE;
                        
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_TRANSMIT_BLOCK_SIZE"));
            //
            // This is inclusive of headers. 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE;
            

            break;
            
        case OID_GEN_RECEIVE_BLOCK_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RECEIVE_BLOCK_SIZE"));
            GenericULong = EPVC_MAX_FRAME_SIZE ;
            
            break;
        
        case OID_GEN_MAXIMUM_SEND_PACKETS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_SEND_PACKETS"));
            GenericULong = 32;      // XXX What is our limit? From adapter?
            
            break;
        
            case OID_GEN_LINK_SPEED:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_LINK_SPEED"));
            GenericULong = pMiniport->info.LinkSpeed;

            
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RECEIVE_BUFFER_SPACE"));
            GenericULong = 32 * 1024;   // XXX What should this really be?
            

            break;

        case OID_GEN_VENDOR_ID:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_VENDOR_ID"));
            NdisMoveMemory(
                (PVOID)&GenericULong,
                &pMiniport->MacAddressEth,
                3
                );
            GenericULong &= 0xFFFFFF00;
            MoveSource = (PVOID)(&GenericULong);
            MoveBytes = sizeof(GenericULong);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_VENDOR_DESCRIPTION"));
            MoveSource = (PVOID)"Microsoft ATM Ethernet Emulation";
            MoveBytes = 28;

            break;

        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_VENDOR_DRIVER_VERSION:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_DRIVER_VERSION"));
            GenericUShort = ((USHORT)5 << 8) | 0;
            MoveSource = (PVOID)(&GenericUShort);
            MoveBytes = sizeof(GenericUShort);

            break;

        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
        
            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_CURRENT_ADDRESS"));

            NdisMoveMemory((PCHAR)GenericArray,
                        &pMiniport->MacAddressEth,
                        sizeof(MAC_ADDRESS));
            MoveSource = (PVOID)(GenericArray);
            MoveBytes = sizeof(MAC_ADDRESS);


            break;


        case OID_802_3_MULTICAST_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_MULTICAST_LIST"));
            MoveSource = (PVOID) &pMiniport->info.McastAddrs[0];
            MoveBytes = pMiniport->info.McastAddrCount * sizeof(MAC_ADDRESS);

            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_MAXIMUM_LIST_SIZE"));
            GenericULong = MCAST_LIST_SIZE;
        
            
            break;
            


        case OID_GEN_XMIT_OK:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_XMIT_OK"));
            GenericULong = (UINT)(pMiniport->count.FramesXmitOk);
            
            break;

        case OID_GEN_RCV_OK:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RCV_OK"));
            GenericULong = (UINT)(pMiniport->count.FramesRecvOk);

            
            break;
        case OID_GEN_RCV_ERROR:
        
            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RCV_OK"));
            GenericULong = pMiniport->count.RecvDropped ;
            break;

        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
    
            TRACE (TL_V, TM_Rq,(" Miniport Query - Unimplemented Stats Oid"));
            GenericULong = 0;

            
            break;

        default:

            StatusToReturn = NDIS_STATUS_INVALID_OID;
            break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store and print result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            TRACE (TL_V, TM_Rq, ("Query Request Oid %x", Oid));
            DUMPDW( TL_V, TM_Rq, MoveSource, MoveBytes);
            
            (*BytesWritten) = MoveBytes;
        }
    }


    TRACE(TL_T, TM_Rq, ("<==EpvcMpQueryInformation Status %x",StatusToReturn)); 
    RM_ASSERT_CLEAR(&SR);
    return StatusToReturn;
}




NDIS_STATUS 
EpvcMpSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    Handles a set operation for a single OID.

Arguments:

    MiniportAdapterContext  - a pointer to the Elan.

    Oid                     - the NDIS_OID to process.

    InformationBuffer       - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead               - If the call is successful, returns the number
                              of bytes read from InformationBuffer.

    BytesNeeded             - If there is not enough data in InformationBuffer
                              to satisfy the OID, returns the amount of storage
                              needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    ENTER ("EpvcMpSetInformation", 0x619a7528)
    NDIS_STATUS         StatusToReturn  = NDIS_STATUS_SUCCESS;
    UINT                BytesLeft       = InformationBufferLength;
    PUCHAR              InfoBuffer      = (PUCHAR)(InformationBuffer);
    UINT                OidLength;
    ULONG               LookAhead;
    ULONG               Filter;
    PEPVC_I_MINIPORT    pMiniport = NULL;
    PEPVC_ADAPTER       pAdapter = NULL;
    BOOLEAN             IsShuttingDown = FALSE;
    RM_DECLARE_STACK_RECORD (SR);
        
    TRACE(TL_T, TM_Mp, ("==>EpvcMpSetInformation pMiniport %x, Oid, Buffer %x, Length, %x",
                       pMiniport,
                       Oid,
                       InformationBuffer,
                       InformationBufferLength));               

    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;

    LOCKOBJ(pMiniport, &SR);
    IsShuttingDown =(! MiniportTestFlag(pMiniport, fMP_MiniportInitialized));
    pAdapter = pMiniport->pAdapter;
    UNLOCKOBJ(pMiniport,&SR);

    if (IsShuttingDown)
    {
        TRACE (TL_I, TM_Mp,(" Miniport shutting down. Trivially succeeding Set OID %x \n", Oid ));
        *BytesRead = 0;
        *BytesNeeded = 0;

        StatusToReturn = NDIS_STATUS_SUCCESS;
        return (StatusToReturn);
    }

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

        case OID_802_3_MULTICAST_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Set OID_802_3_MULTICAST_LIST"));

            if (OidLength % sizeof(MAC_ADDRESS))
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
            {
                StatusToReturn = NDIS_STATUS_MULTICAST_FULL;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            NdisZeroMemory(
                    &pMiniport->info.McastAddrs[0], 
                    MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
                    );
            NdisMoveMemory(
                    &pMiniport->info.McastAddrs[0], 
                    InfoBuffer,
                    OidLength
                    );
            pMiniport->info.McastAddrCount = OidLength / sizeof(MAC_ADDRESS);


            break;

        case OID_GEN_CURRENT_PACKET_FILTER:

            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_CURRENT_PACKET_FILTER"));
            //
            // Verify length
            //
            if (OidLength != sizeof(ULONG)) 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = sizeof(ULONG);
                ASSERT (0);
                break;
            }

            BytesLeft = sizeof (ULONG);
            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InfoBuffer, BytesLeft );

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            StatusToReturn   = epvcSetPacketFilter(pMiniport, Filter, &SR);

            break;

        case OID_802_5_CURRENT_FUNCTIONAL:
        case OID_802_5_CURRENT_GROUP:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_802_5_CURRENT_GROUP"));

            // XXX just accept whatever for now ???
            
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_CURRENT_LOOKAHEAD"));

            //
            // Verify length
            //
            if (OidLength != 4) 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&LookAhead, InfoBuffer, 4);

            ASSERT (pMiniport->pAdapter != NULL);
            
            if (LookAhead <= pAdapter->info.MaxAAL5PacketSize)
            {
                pMiniport->info.CurLookAhead = LookAhead;
                TRACE (TL_V, TM_Mp, ("New Lookahead size %x \n",pMiniport->info.CurLookAhead )); 
            }
            else 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
            }

            break;

        case OID_GEN_NETWORK_LAYER_ADDRESSES:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_NETWORK_LAYER_ADDRESSES"));
            StatusToReturn = epvcMpSetNetworkAddresses(
                                pMiniport,
                                InformationBuffer,
                                InformationBufferLength,
                                &SR,
                                BytesRead,
                                BytesNeeded);
            break;
                                
        default:

            StatusToReturn = NDIS_STATUS_INVALID_OID;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

    }

    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
        DUMPDW( TL_V, TM_Rq, InformationBuffer, *BytesRead );
    }
    

    TRACE(TL_T, TM_Mp, ("<==EpvcMpSetInformation Status %x",StatusToReturn));   
    RM_ASSERT_CLEAR(&SR);
    return StatusToReturn;
}




VOID
epvcMPLocalRequestComplete (
    PEPVC_NDIS_REQUEST pEpvcRequest, 
    NDIS_STATUS Status
    )
/*++

Routine Description:

    Miniport's local Request Completion handler for the occasion
    when a locally allocated NdisRequest was sent to the miniport below us.

    We look up to see if a request to our miniport edge initiated this request.
    If so, we complete the Set/Query

    Assumes that the epvcRequest was allocated from the HEAP

Arguments:
    pEpvcRequest - Locally allocated Request structure
    
Return Value:
--*/
{
    ENTER("epvcMPLocalRequestComplete ", 0x77d107ae)
    PEPVC_I_MINIPORT pMiniport = pEpvcRequest->pMiniport;

    RM_DECLARE_STACK_RECORD (SR);
    //
    // First complete the request that we have pended
    //

    do
    {
    
        if (pMiniport == NULL || pEpvcRequest->fPendedRequest == FALSE)
        {
            //
            // No pended request to complete
            //
            break;
        }

        if (pEpvcRequest->fSet  == TRUE)
        {
            NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle,
                                         Status);
        }
        else
        {
            NdisMQueryInformationComplete (pMiniport->ndis.MiniportAdapterHandle,
                                         Status);


        }


    } while (FALSE);

    if (pMiniport != NULL)
    {
        //
        // Deref the miniport
        //
        epvcUnlinkFromExternal( &pMiniport->Hdr,  //pHdr
                                       0xaa625b37, // Luid
                                       (UINT_PTR)pEpvcRequest,// External entity
                                       EPVC_ASSOC_MINIPORT_REQUEST,         // AssocID
                                       &SR
                                       );
    }


    //
    // now free the memory that was allocated. 
    //
    NdisFreeMemory (pEpvcRequest, sizeof (*pEpvcRequest), 0);


}





NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    Called when the protocol above us wants to let us know about
    the network address(es) assigned to this interface. If this is TCP/IP,
    then we reformat and send a request to the ATM Call Manager to set
    its atmfMyIpNmAddress object. We pick the first IP address given to us.

Arguments:

    pMiniport                   - Pointer to the ELAN

    InformationBuffer       - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead               - If the call is successful, returns the number
                              of bytes read from InformationBuffer.

    BytesNeeded             - If there is not enough data in InformationBuffer
                              to satisfy the OID, returns the amount of storage
                              needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
--*/
{
    ENTER("epvcMpSetNetworkAddresses" , 0x385441e2)
    NETWORK_ADDRESS_LIST UNALIGNED *        pAddrList = NULL;
    NETWORK_ADDRESS UNALIGNED *             pAddr = NULL;
    NETWORK_ADDRESS_IP UNALIGNED *          pIpAddr= NULL;
    ULONG                                   Size;
    PUCHAR                                  pNetworkAddr = NULL;
    NDIS_HANDLE                             NdisAdapterHandle;
    NDIS_HANDLE                             NdisAfHandle;
    NDIS_STATUS                             Status;
    PEPVC_ADAPTER                           pAdapter = (PEPVC_ADAPTER)pMiniport->pAdapter;

    //
    //  Initialize.
    //
    *BytesRead = 0;
    Status = NDIS_STATUS_SUCCESS;

    pAddrList = (NETWORK_ADDRESS_LIST UNALIGNED *)InformationBuffer;

    do
    {

        *BytesNeeded = sizeof(*pAddrList) -
                        FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                        sizeof(NETWORK_ADDRESS) -
                        FIELD_OFFSET(NETWORK_ADDRESS, Address);

        if (InformationBufferLength < *BytesNeeded)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddrList->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddrList->AddressCount <= 0)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pAddr = (NETWORK_ADDRESS UNALIGNED *)&pAddrList->Address[0];

        if ((pAddr->AddressLength > InformationBufferLength - *BytesNeeded) ||
            (pAddr->AddressLength == 0))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddr->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddr->AddressLength < sizeof(NETWORK_ADDRESS_IP))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        pIpAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];

        //
        //  Allocate an NDIS request to send down to the call manager.
        //
        Size = sizeof(pIpAddr->in_addr);
        Status = epvcAllocateMemoryWithTag(&pNetworkAddr, Size, TAG_DEFAULT );

        if ((FAIL(Status) == TRUE) || pNetworkAddr == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            pNetworkAddr = NULL;
            break;
        }

        //
        //  Copy the network address in.
        //
        NdisMoveMemory(pNetworkAddr, &pIpAddr->in_addr, sizeof(pIpAddr->in_addr));

        TRACE (TL_V, TM_Mp, (" Set network layer addr: length %d\n", pAddr->AddressLength));
#if DBG
        if (pAddr->AddressLength >= 4)
        {
            TRACE(TL_V, TM_Mp, ("Network layer addr: %d.%d.%d.%d\n",
                    pNetworkAddr[0],
                    pNetworkAddr[1],
                    pNetworkAddr[2],
                    pNetworkAddr[3]));
        }
#endif // DBG

        //
        //  Send off the request.
        //
        { 
            PEPVC_NDIS_REQUEST pRequest;        

            do
            {
        
                Status = epvcAllocateMemoryWithTag (&pRequest, sizeof(*pRequest), TAG_DEFAULT) ;

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    pRequest = NULL;
                    break;
                }



                //
                // There is no failure code path in prepareandsendrequest.
                // Our completion handler will get called and free the memory
                //
                Status = epvcPrepareAndSendNdisRequest(
                                                       pAdapter,
                                                       pRequest,
                                                       epvcMPLocalRequestComplete,
                                                       OID_ATM_MY_IP_NM_ADDRESS,
                                                       pNetworkAddr,
                                                       sizeof(pIpAddr->in_addr),
                                                       NdisRequestSetInformation,
                                                       pMiniport,
                                                       TRUE, // We have Pended a Request
                                                       TRUE, // The Pended request is a Set 
                                                       pSR
                                                       );
                                
                

            } while (FALSE);
            
        }
        break;
    }
    while (FALSE);

    EXIT();
    return (Status);
}






VOID
epvcSetupMakeCallParameters(
    PEPVC_I_MINIPORT pMiniport, 
    PCO_CALL_PARAMETERS *ppCallParameters
    )
/*++

Routine Description:

    Sets up the Call parameters after reading the information
    from the miniport block

Arguments:
    pMiniport - Miniport in question
    ppCallParameter - Location of Call Parameters

Return Value:
    return value *ppCallParamter is NULL on Failure

--*/
{
    ULONG                               RequestSize = 0;
    NDIS_STATUS                         Status = NDIS_STATUS_FAILURE;
    PCO_CALL_PARAMETERS                 pCallParameters = NULL;
    PCO_CALL_MANAGER_PARAMETERS         pCallMgrParameters = NULL;
    PCO_MEDIA_PARAMETERS                pMediaParameters = NULL;
    PATM_MEDIA_PARAMETERS               pAtmMediaParameters = NULL;

    do
    {
        Status = epvcAllocateMemoryWithTag( &pCallParameters,
                                       CALL_PARAMETER_SIZE,
                                       TAG_DEFAULT);

        if (Status != NDIS_STATUS_SUCCESS || pCallParameters  == NULL)
        {
                pCallParameters = NULL;     
                Status = NDIS_STATUS_RESOURCES;
                break;
        }

        NdisZeroMemory (pCallParameters, CALL_PARAMETER_SIZE);

        //
        //  Distribute space and link up pointers amongst the various
        //  structures for the PVC.
        //
        //  pCallParameters------->+----------------------------+
        //                         | CO_CALL_PARAMETERS         |
        //  pCallMgrParameters---->+----------------------------+
        //                         | CO_CALL_MANAGER_PARAMETERS |
        //  pMediaParameters------>+----------------------------+
        //                         | CO_MEDIA_PARAMETERS        |
        //  pAtmMediaParameters--->+----------------------------+
        //                         | ATM_MEDIA_PARAMETERS       |
        //                         +----------------------------+
        //

        pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
                                ((PUCHAR)pCallParameters +
                                sizeof(CO_CALL_PARAMETERS));
        pCallParameters->CallMgrParameters = pCallMgrParameters;
        pCallMgrParameters->CallMgrSpecific.ParamType = 0;  
        pCallMgrParameters->CallMgrSpecific.Length = 0;
        pMediaParameters = (PCO_MEDIA_PARAMETERS)
            pCallMgrParameters->CallMgrSpecific.Parameters;
        pCallParameters->MediaParameters = pMediaParameters;
        pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
                                pMediaParameters->MediaSpecific.Parameters;


        //
        //  Call Manager generic flow paramters:
        //
        pCallMgrParameters->Transmit.TokenRate = 
                pMiniport->pAdapter->info.LinkSpeed.Outbound/8*100; // cnvt decibits to bytes
        pCallMgrParameters->Transmit.PeakBandwidth = 
                pMiniport->pAdapter->info.LinkSpeed.Outbound/8*100; // cnvt decibits to bytes
        pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;

        pCallMgrParameters->Receive.TokenRate = 
                pMiniport->pAdapter->info.LinkSpeed.Inbound/8*100;  // cnvt decibits to bytes
        pCallMgrParameters->Receive.PeakBandwidth = 
                pMiniport->pAdapter->info.LinkSpeed.Inbound/8*100;  // cnvt decibits to bytes
        pCallMgrParameters->Receive.ServiceType = SERVICETYPE_BESTEFFORT;

        //
        //  use 1516 per spec
        //
        pCallMgrParameters->Transmit.TokenBucketSize = 
            pCallMgrParameters->Transmit.MaxSduSize = 
            pCallMgrParameters->Receive.TokenBucketSize = 
            pCallMgrParameters->Receive.MaxSduSize = 
                 1516;

        //
        //  PVC Generic and ATM-specific Media Parameters
        //
        pMediaParameters->Flags = TRANSMIT_VC | RECEIVE_VC;
        pMediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
        pMediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

        pAtmMediaParameters->ConnectionId.Vpi = pMiniport->config.vpi;  //0
        pAtmMediaParameters->ConnectionId.Vci = pMiniport->config.vci;  

        TRACE (TL_I, TM_Mp, ("Miniport Configuration vci %x ,vpi %x", 
                             pMiniport->config.vci ,
                             pMiniport->config.vpi ));

        ASSERT (pMiniport->MaxAcceptablePkt > 1000);
        
        pAtmMediaParameters->AALType = AAL_TYPE_AAL5;
        pAtmMediaParameters->Transmit.PeakCellRate = 
            LINKSPEED_TO_CPS(pMiniport->pAdapter->info.LinkSpeed.Outbound);
        pAtmMediaParameters->Transmit.MaxSduSize = pMiniport->MaxAcceptablePkt    ;
        pAtmMediaParameters->Transmit.ServiceCategory = 
            ATM_SERVICE_CATEGORY_UBR;
        pAtmMediaParameters->Receive.PeakCellRate = 
            LINKSPEED_TO_CPS(pMiniport->pAdapter->info.LinkSpeed.Outbound);
        pAtmMediaParameters->Receive.MaxSduSize = pMiniport->MaxAcceptablePkt   ;
        pAtmMediaParameters->Receive.ServiceCategory = 
            ATM_SERVICE_CATEGORY_UBR;

        //
        //  Set PVC flag here
        //
        pCallParameters->Flags |= PERMANENT_VC;


                                
    } while (FALSE);

    if (Status == NDIS_STATUS_SUCCESS && pCallParameters != NULL)
    {
        //
        // Set up the return value here
        //
        *ppCallParameters = pCallParameters;

    }
    else
    {
        //
        // Clear the Failure case
        //
        *ppCallParameters = NULL;
    }
}   





VOID
epvcRefRecvPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    )
{

    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding  packets.
    //
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT "    indicated pkt 0x%p\n"

        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an "external" link for EVERY packet. We'll later remove this
        //      reference when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero outstanding sends, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        epvcLinkToExternal (
            pHdr,                           // pHdr
            0x92036e12,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            EPVC_ASSOC_EXTLINK_INDICATED_PKT,           // AssocID
            szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT ,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pHdr);

    #endif // !RM_EXTRA_CHECKING

    
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT 

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif
}



VOID
epvcDerefRecvPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    )
{
    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #if RM_EXTRA_CHECKING


        RM_DECLARE_STACK_RECORD(sr)
    
        epvcUnlinkFromExternal(
                pHdr,                           // pHdr
                0x110ad55b,                             // LUID
                (UINT_PTR)pNdisPacket,                  // External entity
                EPVC_ASSOC_EXTLINK_INDICATED_PKT,           // AssocID
                &sr
                );
    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast (pHdr);

    #endif // !RM_EXTRA_CHECKING

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif



}

VOID
epvcDerefSendPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    )
{
    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)
    
        epvcUnlinkFromExternal(
                pHdr,                           // pHdr
                0xf43e0a10,                             // LUID
                (UINT_PTR)pNdisPacket,                  // External entity
                EPVC_ASSOC_EXTLINK_PKT_TO_SEND,         // AssocID
                &sr
                );
    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast (pHdr);

    #endif // !RM_EXTRA_CHECKING


    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif



}


VOID
epvcRefSendPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    )
{

    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT "    send pkt 0x%p\n"


    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        epvcLinkToExternal (
            pHdr,                           // pHdr
            0xabd17475,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            EPVC_ASSOC_EXTLINK_PKT_TO_SEND,         // AssocID
            szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT ,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pHdr);

    #endif // !RM_EXTRA_CHECKING

    
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT 

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif
}


VOID
epvcExtractPktInfo (
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket ,
    PEPVC_SEND_STRUCT       pSendStruct
    )
/*++

Routine Description:


Arguments:


Return Value:
    
--*/
{

    pSendStruct->pOldPacket = pPacket;
    pSendStruct->pMiniport = pMiniport;

    epvcSetSendPktStats();

}



NDIS_STATUS
epvcSendRoutine(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine does all the hard work.
    It responds to arps if necessary..
    It removes Ethernet Headers if necessary
    It allocates a new packet if necessary 
    It sends the new packet on the wire


Arguments:
    pMiniport - Miniport in question
    Packet - Packet to be sent

Return Value:
    Returns Pending, otherwise expects the calling 
    routine to complete the packet
    
--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET            pNewPkt = NULL;
    EPVC_SEND_STRUCT        SendStruct;

    TRACE (TL_T, TM_Send, ("==>epvcSendRoutine") );

    EPVC_ZEROSTRUCT (&SendStruct);

    do
    {
        epvcExtractPktInfo (pMiniport, Packet, &SendStruct  );

        //
        // if we are doing IP encapsulation, then respond 
        // to the Arp
        //

        if (pMiniport->fDoIpEncapsulation == TRUE) 
        {
            
            //
            // We need to do some special processing for this packet
            //
            SendStruct.fIsThisAnArp = \
                     epvcCheckAndReturnArps (pMiniport, 
                                            Packet ,
                                            &SendStruct, 
                                            pSR);

                                 

            if (SendStruct.fIsThisAnArp  == TRUE  )
            {
                Status = NDIS_STATUS_SUCCESS;
                break ; // Arps are not sent to the atm driver
            }

            if (SendStruct.fNotIPv4Pkt == TRUE)
            {
                // This is not an IPv4 packet. Fail the send.
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }



        //
        // Allocate a new packet to be sent 
        //
        epvcGetSendPkt(pMiniport, 
                       Packet,
                       &SendStruct,
                       pSR);

        if (SendStruct.pNewPacket == NULL)
        {
            ASSERTAndBreak (SendStruct.pNewPacket != NULL);
        }
        //
        // SendStruct.pNewPacket is guaranteed to have the NdisBuffers Set up

        //
        // Remove Ethernet Header - if necessary
        //
        Status = epvcRemoveEthernetHeader (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add Ethernet Padding - if necessary
        //
        Status = epvcAddEthernetTail (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add Ethernet Pad 0x00 0x00 to head of packet - if necessary
        //
        Status = epvcAddEthernetPad (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add LLC Encapsulation - if necessary
        //
        Status = epvcAddLLCEncapsulation (pMiniport , Packet, SendStruct.pNewPacket, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // set the context information for the send complete
        //
        epvcSetPacketContext (&SendStruct, pSR);

        //
        // Only Send if successful
        //
        epvcDumpPkt (SendStruct.pNewPacket);


        Status = epvcAdapterSend(pMiniport,
                                 SendStruct.pNewPacket,
                                 pSR);


    } while (FALSE);

    if (Status != NDIS_STATUS_PENDING &&   // We had a failure
        SendStruct.pNewPacket != NULL )  // but we were able to get a packet
    {
        epvcFreeSendPkt (pMiniport, &SendStruct);
    }

    TRACE (TL_T, TM_Send, ("<==epvcSendRoutine") );
    return Status;
}


VOID
EpvcSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    Send Packet Array handler. Either this or our SendPacket handler is called
    based on which one is enabled in our Miniport Characteristics.


Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumberOfPackets         Self-explanatory

Return Value:

    None

--*/
{
    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    UINT                i;
    RM_DECLARE_STACK_RECORD (SR);

    DBGMARK(0xdaab68c3);

    TRACE (TL_T, TM_Send, ("==>EpvcSendPackets pMiniport %p, pPktArray %p, Num %x",
                              pMiniport, PacketArray, NumberOfPackets));

    for (i = 0; i < NumberOfPackets; i++)
    {
        PEPVC_PKT_CONTEXT           Rsvd;
        PNDIS_PACKET    Packet = NULL; 
    
        Packet = PacketArray[i];

        epvcValidatePacket (Packet);

        Status= epvcSendRoutine (pMiniport, Packet, &SR);

        if (Status != NDIS_STATUS_PENDING)
        {
            epvcMSendComplete(pMiniport, Packet , Status);
        }

    }

    TRACE (TL_T, TM_Send, ("<==EpvcSendPackets "));
    RM_ASSERT_CLEAR(&SR);

    return;
}   


VOID
epvcFreeSendPkt(
    PEPVC_I_MINIPORT pMiniport,
    IN PEPVC_SEND_STRUCT pSendStruct
    )
/*++
Routine Description:

    Pops the packet stack if stacks were used or free the new packet after
    copying the per packet info

Arguments:
    pMiniport - which the packet was sent to
    pSentPkt - The packet that is being sent.
    ppPkt - the new packet that was allocated or the old one if a stack was available
    
--*/

{
    ENTER ("epvcFreeSendPkt", 0xff3ce0fd)
    PNDIS_PACKET pOldPkt = pSendStruct->pOldPacket;
    PNDIS_PACKET pNewPkt = pSendStruct->pNewPacket;
    
    TRACE (TL_T, TM_Send, ("==>epvcFreeSendPkt pNewPkt %x, pPOldPkt ",pNewPkt, pOldPkt));

    //
    // Remove the ethernet padding - if necessary
    //
    epvcRemoveEthernetPad (pMiniport, pNewPkt);

    //
    // Remove the Ethernet Tail-  if necessary
    //
    epvcRemoveEthernetTail(pMiniport, pNewPkt, &pSendStruct->Context);

    //
    // If the two packets are the same, then we used Packet Stacks
    //

    if (pNewPkt != NULL && pSendStruct->fUsingStacks== FALSE)
    {
            NdisIMCopySendCompletePerPacketInfo (pOldPkt, pNewPkt);

            epvcFreePacket(pNewPkt,&pMiniport->PktPool.Send);

            pNewPkt = pSendStruct->pNewPacket = NULL;

    }       





    TRACE (TL_T, TM_Send, ("<==epvcFreeSendPkt pNewPkt %x, pPOldPkt ",pNewPkt, pOldPkt));
    EXIT()
    return;
}


VOID
epvcGetSendPkt (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pSentPkt,
    OUT PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Allocates an NdisPkt or pushes a Pkt Stack to get a valid NdisPkt that 
    can be sent to the adapter below.

Arguments:
    pMiniport - which the packet was sent to
    pSentPkt - The packet that is being sent.
    ppPkt - the new packet that was allocated or the old one if a stack was available
    
--*/

{
    ENTER ("epvcGetSendPkt", 0x5734054f)

    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET            pNewPkt  = NULL;
    BOOLEAN                 Remaining = FALSE;
    PVOID                   MediaSpecificInfo = NULL;
    UINT                    MediaSpecificInfoSize = 0;

    
    TRACE (TL_T, TM_Send, ("==>epvcGetSendPkt  pSentPkt %x",pSentPkt));


    do
    {
        
#if PKT_STACKS

        //
        // Packet stacks: Check if we can use the same packet for sending down.
        //
        pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
        if (Remaining)
        {
            //
            // We can reuse "Packet".
            //
            // NOTE: if we needed to keep per-packet information in packets
            // sent down, we can use pStack->IMReserved[].
            //
            
            pNewPkt = pSentPkt;
            pSendStruct->pPktStack = pStack;
            
            pSendStruct->fUsingStacks  = TRUE;
            break;
            
        }
#endif

        pSendStruct->fUsingStacks  = FALSE;

        epvcAllocatePacket(&Status,
                           &pNewPkt,
                           &pMiniport->PktPool.Send);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PACKET_EXTENSION  Old, New;
            PEPVC_PKT_CONTEXT Rsvd = NULL;


            Rsvd = (PEPVC_PKT_CONTEXT)(pNewPkt->ProtocolReserved);
            Rsvd->pOriginalPacket = pSentPkt;

            pNewPkt->Private.Flags = NdisGetPacketFlags(pSentPkt);

            pNewPkt->Private.Head = pSentPkt->Private.Head;
            pNewPkt->Private.Tail = pSentPkt->Private.Tail;

            //
            // Copy the OOB Offset from the original packet to the new
            // packet.
            //
            NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(pNewPkt),
                           NDIS_OOB_DATA_FROM_PACKET(pSentPkt),
                           sizeof(NDIS_PACKET_OOB_DATA));
            //
            // Copy relevant parts of the per packet info into the new packet
            //
            NdisIMCopySendPerPacketInfo(pNewPkt, pSentPkt);

            //
            // Copy the Media specific information
            //
            NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(pSentPkt,
                                                &MediaSpecificInfo,
                                                &MediaSpecificInfoSize);

            if (MediaSpecificInfo || MediaSpecificInfoSize)
            {
                NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(pNewPkt,
                                                    MediaSpecificInfo,
                                                    MediaSpecificInfoSize);
            }

        
        }
        else
        {
            pNewPkt = NULL;
        }

    } while (FALSE);

    
    pSendStruct->pNewPacket = pNewPkt;

    TRACE (TL_T, TM_Send, ("<==epvcGetSendPkt  pSentPkt %p ppNewPkt %p",pSentPkt, pSendStruct->pNewPacket ));
    EXIT()
    return;
}


NDIS_STATUS
epvcAdapterSend(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    PRM_STACK_RECORD pSR
    )
{
    BOOLEAN         fDoSend = FALSE;
    PEPVC_ADAPTER   pAdapter  = pMiniport->pAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;

    ENTER("epvcAdapterSend", 0x5b014909)


    TRACE (TL_T, TM_Send, (" ==>epvcAdapterSend" ) )

    do
    {
        //
        // Check to see if we have a valid Send Case
        //
        LOCKOBJ (pMiniport, pSR);
        
        fDoSend = MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded);

        if (fDoSend == FALSE)
        {
            TRACE (TL_V, TM_Send,("Send - MakeCall Not Succeeded"));
        }

        //
        // Add an association while holding the lock
        //
        if (fDoSend == TRUE)
        {
            epvcRefSendPkt(pPkt, &pMiniport->Hdr);
        }
        
        UNLOCKOBJ (pMiniport, pSR);

        if (fDoSend == TRUE)
        {
            epvcCoSendPackets(pMiniport->vc.VcHandle,
                                       &pPkt,
                                       1    
                                       );

            Status = NDIS_STATUS_PENDING;                                      
        }
        else
        {
            Status = NDIS_STATUS_FAILURE;
        }



    } while (FALSE);



    TRACE (TL_T, TM_Send, (" <==epvcAdapterSend fDoSend %x, Status %x", fDoSend, Status ) )
    return Status;
}



VOID
epvcFormulateArpResponse (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_ARP_CONTEXT pArpContext,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    This allocates an Arp Packet, looks at the Arp Request, formulates
    a response and sends it up back to the protocol

Arguments:
    pMiniport - which the packet was sent to
    pArpContext - Contains all the information relating to the Arp. 
                  the Context Is Allocated on the stack

Return:

--*/    
{
    ENTER("epvcFormulateArpResponse",  0x7a763fce)
    PEPVC_ARP_PACKET pResponse = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_ARP pTask = NULL;


    TRACE (TL_T, TM_Send, ("==>epvcFormulateArpResponse pMiniport %x, pArpContext %x",
                             pMiniport, pArpContext))
    do
    {
        //
        // Allocate a buffer from a lookaside list 
        //

        Status = epvcAllocateTask(
                &pMiniport->Hdr,        // pParentObject,
                epvcTaskRespondToArp,   // pfnHandler,
                0,                          // Timeout,
                "Task: Arp Response",   // szDescription
                &(PRM_TASK)pTask,
                pSR
                );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        //
        // Set up Arp Response
        //

        pResponse = &pTask->Pkt;
        EPVC_ZEROSTRUCT (pResponse);

        {
            //
            // Construct the Ethernet Header 
            //
        
            PEPVC_ETH_HEADER  pRespHeader = &pResponse->Header;
            PEPVC_ETH_HEADER  pSrcHeader = (PEPVC_ETH_HEADER)pArpContext->pEthHeader;

            ASSERT (pSrcHeader != NULL);
            ASSERT (pRespHeader  != NULL);

            //
            // set up the Eth header
            //
            NdisMoveMemory (&pRespHeader->eh_daddr, 
                            &pSrcHeader->eh_saddr, 
                            ARP_802_ADDR_LENGTH ) ;

            NdisMoveMemory ( &pRespHeader->eh_saddr,                            
                             &pMiniport->info.MacAddressDummy, 
                             ARP_802_ADDR_LENGTH );

            pRespHeader->eh_type = pSrcHeader->eh_type;  // copy 08 06 over
                                                        
            
        }           


        
        {

            //
            // Construct the Arp Response
            //

            PEPVC_ARP_BODY pRespBody = &pResponse->Body;
            PEPVC_ARP_BODY pSrcBody = pArpContext ->pBody;

            ASSERT (pRespBody != NULL);


            ASSERT (pSrcBody  != NULL);


            
            pRespBody->hw = pSrcBody->hw;                                       // Hardware address space. = 00 01

            pRespBody->pro = pSrcBody->pro;                                 // Protocol address space. = 08 00

            pRespBody->hlen = ARP_802_ADDR_LENGTH; // 6

            pRespBody->plen = sizeof (IP_ADDR); // 4
            
            pRespBody->opcode = net_short(ARP_RESPONSE);                        // Opcode.


            pRespBody->SenderHwAddr= pMiniport->info.MacAddressDummy;           // Source HW address.

            pRespBody->SenderIpAddr = pSrcBody->DestIPAddr ;                    // Source protocol address.

            pRespBody->DestHwAddr = pSrcBody->SenderHwAddr;                     // Destination HW address.

            pRespBody->DestIPAddr = pSrcBody->SenderIpAddr;                     // Destination protocol address.

        }



        //
        // So we have the packet ready for transmission.
        //

        RmStartTask ((PRM_TASK)pTask, 0 , pSR);

    } while (FALSE);
    
    TRACE (TL_T, TM_Send, ("<==epvcFormulateArpResponse "))

}



NDIS_STATUS
epvcTaskRespondToArp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    This function queues a zero timeout timer and indicates a receive


Arguments:


Return:

--*/    
{
    ENTER("epvcTaskRespondToArp", 0xd05c4942)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_ARP           pTaskArp    = (PTASK_ARP) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;


    enum 
    {
        Stage_Start =0, // default
        Stage_DoAllocations,
        Stage_QueuedTimer,
        Stage_PacketReturned,
        Stage_TaskCompleted,
        Stage_End       
    
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskRespondToArp %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->arps.pTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->arps.pTask);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            //
            // Check to see if the miniport is still active. 
            // If it is halting, then we don't need to do any work
            //
            if (MiniportTestFlag(pMiniport,  fMP_MiniportInitialized) == FALSE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }


            UNLOCKOBJ(pMiniport, pSR);

            pTask->Hdr.State = Stage_DoAllocations;

            FALL_THROUGH
        }

        case Stage_DoAllocations:
        {
            PNDIS_BUFFER pBuffer = NULL;
            
            TRACE (TL_V, TM_Send, ("epvcTaskRespondToArp Stage_DoAllocations Task %p", pTask) );

            //
            // Allocate An NDis Buffer
            //
            epvcAllocateBuffer(&Status,
                               &pBuffer,
                               NULL,  // Pool Handle
                               (PVOID)&pTaskArp->Pkt,
                                sizeof(pTaskArp->Pkt) ); //Length

            ASSERT (sizeof(pTaskArp->Pkt)  == 0x2a);
            
            if (FAIL(Status) == TRUE)                               
            {
                pBuffer = NULL;
                pTask->Hdr.State = Stage_TaskCompleted;


                ASSERTAndBreak (!FAIL(Status));
                break;
            }
            


            //
            // Allocate An Ndis Packet
            //


            epvcAllocatePacket (&Status,
                                &pTaskArp->pNdisPacket,
                                &pMiniport->PktPool.Recv);

            if (FAIL(Status) == TRUE)
            {
                pTask->Hdr.State = Stage_TaskCompleted;
                pTaskArp->pNdisPacket = NULL;

                //
                // Undo allocations 
                //
                epvcFreeBuffer (pBuffer);

                ASSERTAndBreak( !FAIL(Status) );
                
            }

            //
            //  Set up the Ndis Buffer within the NdisPacket
            //
            {
                PNDIS_PACKET_PRIVATE    pPktPriv = &pTaskArp->pNdisPacket->Private;

                pPktPriv->Head = pBuffer;
                pPktPriv->Tail = pBuffer;
                pBuffer->Next = NULL;
            }

            //
            // Set up the Arp response
            //



            //
            // Queue the timer
            //

            NdisMInitializeTimer ( &pTaskArp->Timer,
                                   pMiniport->ndis.MiniportAdapterHandle,
                                   epvcArpTimer,
                                   pTaskArp );

            pTask->Hdr.State = Stage_QueuedTimer;

            //
            // Now prepare to be called back througha timer to do the 
            // receive indication
            //
            RmSuspendTask(pTask, 0,pSR);
            Status = NDIS_STATUS_PENDING;
            
            NdisMSetTimer (&pTaskArp->Timer, 0); // Zero timeout

            break;
        }

        case Stage_QueuedTimer:
        {

            TRACE (TL_V, TM_Send, ("epvcTaskRespondToArp Stage_QueuedTimer Task %p", pTask) );

            //
            // The miniport could have been halted during the timer 
            //
            if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
            {
                
                pTask->Hdr.State = Stage_TaskCompleted;
                ASSERTAndBreak(MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == TRUE);
            }

            NDIS_SET_PACKET_HEADER_SIZE(pTaskArp->pNdisPacket       ,
                                      sizeof (pMiniport->RcvEnetHeader)) ; 
            
            NDIS_SET_PACKET_STATUS (pTaskArp->pNdisPacket, NDIS_STATUS_RESOURCES);

            pTask->Hdr.State = Stage_PacketReturned;


            epvcMIndicateReceivePacket (pMiniport,
                                        &pTaskArp->pNdisPacket,
                                        1 );


            FALL_THROUGH
        }

        case Stage_PacketReturned:      
        {
                            
            pTask->Hdr.State = Stage_TaskCompleted;
            Status = NDIS_STATUS_SUCCESS;
            break;
            

        }

        case Stage_TaskCompleted:
        case Stage_End      :
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }

    }

    if (pTask->Hdr.State == Stage_TaskCompleted)
    {
        //
        // Free the packet 
        //
        pTask->Hdr.State = Stage_End;
        
        if (pTaskArp->pNdisPacket != NULL)
        {
            //
            // Free the buffer
            //
            PNDIS_PACKET_PRIVATE pPrivate = & pTaskArp->pNdisPacket->Private;
            
            if (pPrivate -> Head != NULL)
            {
                
                epvcFreeBuffer (pPrivate->Head );
                pPrivate->Head = pPrivate->Tail = NULL;
            }

            //
            // free the arp packet
            //
            epvcFreePacket (pTaskArp->pNdisPacket , &pMiniport->PktPool.Recv);
            
            pTaskArp->pNdisPacket = NULL;
        }

        LOCKOBJ (pMiniport, pSR);

        epvcClearPrimaryTask  (&(PRM_TASK)(pMiniport->arps.pTask));

        UNLOCKOBJ (pMiniport, pSR);
            

        Status = NDIS_STATUS_SUCCESS;

    }
    TRACE ( TL_T, TM_Pt, ("<== epvcTaskRespondToArp %x",Status) );

    return Status;
}


VOID
epvcArpTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++
Routine Description:

    Resume the epvcTaskRespondToArp Task


Arguments:


Return:

--*/    
{
    ENTER ("epvcArpTimer",0xf2adae0e)
    PRM_TASK pTask =  (PRM_TASK) FunctionContext;
    
    RM_DECLARE_STACK_RECORD (SR);


    RmResumeTask (pTask,0,&SR);


    EXIT()
}


BOOLEAN
epvcCheckAndReturnArps (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET pPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:
    Looks at the packet that is being sent. If it is an Arp request, 
    then it formulates a responses and queues a timer of timeout zero to
    return the Arp

Arguments:
    pMiniport - which the packet was sent to
    pPkt - the packet being sent


Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER("epvcCheckAndReturnArps ", 0xb8e6a3c4)
    EPVC_ARP_CONTEXT ArpContext;
    TRACE (TL_T, TM_Send, ("==>epvcCheckAndReturnArps "));

    
    EPVC_ZEROSTRUCT (&ArpContext);
    
    do
    {

        ArpContext.pFirstBuffer  = pPkt->Private.Head;


        //
        // Do some sanity checks 
        //
        if (ArpContext.pFirstBuffer == NULL)
        {
            break;
        }

        NdisQueryBufferSafe( ArpContext.pFirstBuffer , 
                             &(PVOID)ArpContext.pEthHeader, 
                             &ArpContext.BufferLength, 
                             LowPagePriority );

        if (ArpContext.pEthHeader == NULL)
        {
            break;
        }

        //
        // It the is not an ARP request then ignore it -- 
        // during testing only
        //
        if (ArpContext.pEthHeader->eh_daddr.Byte[0] == 0xff &&
            ArpContext.pEthHeader->eh_daddr.Byte[1] == 0xff )
        {
            pSendStruct->fNonUnicastPacket = TRUE;      
        }
        
        
        
        if (ARP_ETYPE_ARP != net_short(ArpContext.pEthHeader->eh_type))
        {
            //
            //  This is not an Arp packet. Is this an IPv4 packet
            //
            if (IP_PROT_TYPE != net_short(ArpContext.pEthHeader->eh_type))
            {
                // If this is not an IPv4 packet, then mark it so that it can
                // be discarded
                pSendStruct->fNotIPv4Pkt = TRUE;
            }

           break;                            
        }

        //
        // We'll parse the structure using pre-defined structs
        //
        ArpContext.pArpPkt =  (PEPVC_ARP_PACKET)ArpContext.pEthHeader;

        ASSERT (ArpContext.BufferLength >= sizeof (EPVC_ARP_PACKET));

        if (ArpContext.BufferLength < sizeof (EPVC_ARP_PACKET))
        {
            //
            // TODO : Add Code to handle this case.
            // 
            break;
        }
        
        ArpContext.pBody =  (PEPVC_ARP_BODY)&ArpContext.pArpPkt->Body; 

        TRACE (TL_V, TM_Send, ("Received an ARP %p, Body %x\n", ArpContext.pEthHeader, ArpContext.pBody));


        //
        // Validate the Opcode, the prot type,  hard size, prot size
        //

        if (ARP_REQUEST  != net_short (ArpContext.pBody->opcode ))
        {
            //
            // This is not an Arp request
            //
            break;
        }


        if (IP_PROT_TYPE != net_short(ArpContext.pBody->pro) ||
            ARP_802_ADDR_LENGTH != ArpContext.pBody->hlen ||
            sizeof (IP_ADDR) != ArpContext.pBody->plen )
        {
            //
            // these are just sanity checks
            //
            ASSERT (!"Invalid ARP Packet");
            break;

        }

        //
        // We have a valid ArpRequest
        //
        ArpContext.fIsThisAnArp  = TRUE;

        //
        // If tcp/ip is arping for itself, then do not respond... but return
        //  TRUE, so that this packet is not sent on the wire
        //
        
        if (ArpContext.pArpPkt->Body.SenderIpAddr == ArpContext.pArpPkt->Body.DestIPAddr)
        {
            break;
        }

        //
        // Formulate and indicate an Arp Response
        //
        
        epvcFormulateArpResponse (pMiniport, &ArpContext, pSR);
        

    } while (FALSE);

    EXIT()

    return ArpContext.fIsThisAnArp ;
    TRACE (TL_T, TM_Send, ("<==epvcCheckAndReturnArps "));

}


NDIS_STATUS 
epvcRemoveEthernetHeader(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Expects that the new packet is already set up with 
    the Ndis Bufferz

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER ("epvcAddLLCEncapsulation" , 0x3ec589c9) 

    BOOLEAN             fUsedPktStack   = pSendStruct->fUsingStacks;
    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    
    TRACE (TL_T, TM_Send, ("==>epvcRemoveEthernetHeader  "));




    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->fDoIpEncapsulation == FALSE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;

            break; // we are done
        }

        //
        // There are three ways we can be given a ether net header
        // 1. In a seperate MDL - most often 
        // 2. As part of a large MDL - We need to adhust the Virtual address
        // 3. EthernetHeader is seperated across multiple 
        //                      MDLs - not implemented or expected
        //

        pBuffer  = pNewPkt->Private.Head;

        BufferLength = NdisBufferLength (pBuffer);

        if (BufferLength < sizeof (EPVC_ETH_HEADER) )
        {
            
            ASSERTAndBreak (BufferLength >= sizeof (EPVC_ETH_HEADER)) ; // we are done 
        

        }

        //
        // At this point the first  buffer is going to be replaced so keep a record of it
        //
        pSendStruct->Context.Stack.ipv4Send.pOldHeadNdisBuffer = pBuffer;

        //
        // New we check to see if all we need to do is make the 
        // Packet->Private.Head point to the next MDL
        //
        if (BufferLength == sizeof (EPVC_ETH_HEADER))
        {
            //
            // These are error conditions that should not 
            // be handled in our software
            //
            ASSERT (pBuffer->Next != NULL); // no tcp header after the Eth header

            pNewPkt->Private.Head = pBuffer->Next;

            NdisStatus = NDIS_STATUS_SUCCESS;

            break ; // we are done

        }
        
        if (BufferLength > sizeof (EPVC_ETH_HEADER))
        {
            //
            // Allocate a new NDIS Buffer pointing to start of the IP header w
            // within the current Head (pBuffer)
            //
            PNDIS_BUFFER    pNewBuffer = NULL;
            PUCHAR          pIpHeader = NdisBufferVirtualAddress(pBuffer);
            UINT            LenRemaining = BufferLength - sizeof (EPVC_ETH_HEADER);

            if (pIpHeader == NULL)
            {
                //
                // we did not get the virtual address from the system.
                // Start to fail this packet
                //
                ASSERTAndBreak(pIpHeader != NULL);

            }

            //
            // Now move the Ip Header past the Ethernet Header (where it currently points to)
            //
            pIpHeader += sizeof (EPVC_ETH_HEADER)  ;

            //
            // Now allocate the new NdisBuffer
            //
            epvcAllocateBuffer ( &NdisStatus,
                                 &pNewBuffer,
                                 NULL,
                                 pIpHeader,
                                 LenRemaining);

            if (NdisStatus != NDIS_STATUS_SUCCESS) 
            {
                pNewBuffer  = NULL;
                ASSERTAndBreak (!"Ndis Buffer Allocation failed");
            }

            //
            // Make the New Buffer the Head of the new packet
            //
            // We might have to make it the tail if there is 
            // only one ndis buffer in the packet
            //
            if (pNewPkt->Private.Head  == pNewPkt->Private.Tail)
            {
                pNewPkt->Private.Tail = pNewBuffer;
            }

            pNewBuffer->Next= pNewPkt->Private.Head->Next;
            pNewPkt->Private.Head = pNewBuffer;
            

            NdisStatus = NDIS_STATUS_SUCCESS;

            break ; // we are done
        }



    } while (FALSE);


    TRACE (TL_T, TM_Send, ("<==epvcRemoveEthernetHeader  "));

    return NdisStatus ;

}


VOID
epvcSetPacketContext (
    IN PEPVC_SEND_STRUCT pSendStruct, 
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    No allocations, just add a few pointers and exit

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    None:
    
--*/    
    
{

    PNDIS_PACKET        pPkt = pSendStruct->pNewPacket;
    PEPVC_STACK_CONTEXT pStack = NULL;
    //
    // first point the context to  the correct place 
    // in the new ndis pakcet
    //

    if (pSendStruct->fUsingStacks == TRUE)
    {   
        pStack = (PEPVC_STACK_CONTEXT)(&pSendStruct->pPktStack->IMReserved[0]);
    }
    else
    {
        PEPVC_PKT_CONTEXT pContext = NULL;

        pContext = (PEPVC_PKT_CONTEXT   )(&pPkt->ProtocolReserved[0]);

        pContext->pOriginalPacket = pSendStruct->pOldPacket;

        pStack = &pContext->Stack;

    }


    //
    // Update the packet
    //
    ASSERT (sizeof (pStack) <= (2 *sizeof (PVOID)  ));

    //
    // Now copy the stack portion of the context over
    // into the packet
    //
    *pStack = pSendStruct->Context.Stack;

    
}



NDIS_STATUS
epvcAddLLCEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pOldPkt,
    PNDIS_PACKET pNewPkt,
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Expects that the new packet is already set up with 
    the Ndis Bufferz

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER ("epvcAddLLCEncapsulation" , 0x3ec589c9) 
    BOOLEAN         fDoSend = TRUE;
    BOOLEAN         fUsedPktStack = (pOldPkt == pNewPkt);
    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    pNewBuffer = NULL;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddLLCEncapsulation "));

    do
    {
        if (pMiniport->fAddLLCHeader == FALSE)
        {
            break; // we are done
        }
        

        //
        // Allocate an MDL that points to the LLC Header
        //
        epvcAllocateBuffer ( &NdisStatus,
                             &pNewBuffer,
                             NULL,
                             pMiniport->pLllcHeader,
                             pMiniport->LlcHeaderLength);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pNewBuffer = NULL;
            break;
        }
        

        //
        // Insert the New Buffer as the Head of the new Packet
        //
        pNewBuffer->Next = pNewPkt->Private.Head;
        pNewPkt->Private.Head = pNewBuffer;

        pNewPkt->Private.ValidCounts= FALSE;

        NdisStatus = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   
        if (pNewBuffer!= NULL)
        {
            epvcFreeBuffer (pNewBuffer);
            pNewBuffer = NULL;
        }

    }

    TRACE (TL_T, TM_Send, ("<==epvcAddLLCEncapsulation "));

    return NdisStatus ;
}



NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    )
{

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
epvcRemoveRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    )
{

    return NDIS_STATUS_SUCCESS;
}


VOID
epvcDumpPkt (
    IN PNDIS_PACKET pPkt
    )
{

    PNDIS_BUFFER pPrevBuffer;

    do
    {
        PNDIS_BUFFER pBuffer = NULL;
    
        if (g_bDumpPackets == FALSE)
        {
            
            break;

        }

        pBuffer = pPkt->Private.Head;

        //
        // Now iterate through all the buffers 
        // and print out the packet. 
        //
        TRACE (TL_A, TM_Mp, ("pPkt %p, Head %p, tail %p\n ", 
                pPkt, pPkt->Private.Head, pPkt->Private.Tail));

        //
        // As we always expect the first buffer to be present
        // I do not check
        //
        do
        {
            PVOID pVa = NULL;
            ULONG Len = 0;
            pPrevBuffer = NULL;
            
            Len = NdisBufferLength (pBuffer);

            pVa = NdisBufferVirtualAddress(pBuffer);

            pPrevBuffer = pBuffer;
            pBuffer = pBuffer->Next;

            
            if (pVa == NULL)
            {
                continue;
            }

            DbgPrint ("Mdl %p, Va %p. Len %x\n", pPrevBuffer, pVa,Len);
            Dump( (CHAR* )pVa, Len, 0, 1 );                           

 
        } while (pBuffer != NULL);

    } while (FALSE);
}



NDIS_STATUS
epvcMiniportReadConfig(
    IN PEPVC_I_MINIPORT pMiniport,
    NDIS_HANDLE     WrapperConfigurationContext,
    PRM_STACK_RECORD pSR
    )
{   
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE     ConfigurationHandle;
    PMP_REG_ENTRY   pRegEntry;
    UINT            i;
    UINT            value;
    PUCHAR          pointer;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
    PUCHAR          NetworkAddress;
    UINT            Length;

    // Open the registry for this pMiniport
    NdisOpenConfiguration(
        &Status,
        &ConfigurationHandle,
        WrapperConfigurationContext);
    if(Status != NDIS_STATUS_SUCCESS)
    {
        TRACE (TL_I, TM_Mp,("NdisOpenConfiguration failed\n"));
        return Status;
    }

    // read all the registry values 
    for(i = 0, pRegEntry = NICRegTable; i < NIC_NUM_REG_PARAMS; i++, pRegEntry++)
    {
        pointer = (PUCHAR) pMiniport + pRegEntry->FieldOffset;


        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &pRegEntry->RegName,
            NdisParameterInteger);


        // If the parameter was present, then check its value for validity.
        if(Status == NDIS_STATUS_SUCCESS)
        {
            // Check that param value is not too small or too large
            if(ReturnedValue->ParameterData.IntegerData < pRegEntry->Min ||
                ReturnedValue->ParameterData.IntegerData > pRegEntry->Max)
            {
                value = pRegEntry->Default;
            }
            else
            {
                value = ReturnedValue->ParameterData.IntegerData;
            }

            TRACE (TL_I, TM_Mp, ("= 0x%x", value));
        }
        else if(pRegEntry->bRequired)
        {
            TRACE (TL_I, TM_Mp,(" -- failed"));

            ASSERT(FALSE);

            Status = NDIS_STATUS_FAILURE;
            break;
        }
        else
        {
            value = pRegEntry->Default;
            TRACE (TL_I, TM_Mp,("= 0x%x (default)", value));
            Status = NDIS_STATUS_SUCCESS;
        }

        // Store the value in the pMiniport structure.
        switch(pRegEntry->FieldSize)
        {
            case 1:
                *((PUCHAR) pointer) = (UCHAR) value;
                break;

            case 2:
                *((PUSHORT) pointer) = (USHORT) value;
                break;

            case 4:
                *((PULONG) pointer) = (ULONG) value;
                break;

            default:
                TRACE (TL_I,TM_Mp, ("Bogus field size %d", pRegEntry->FieldSize));
                break;
        }
    }

    // Read NetworkAddress registry value 
    // Use it as the current address if any

    // Close the registry
    NdisCloseConfiguration(ConfigurationHandle);

    TRACE (TL_I, TM_Mp,("vci %d\n", pMiniport->config.vci));
    TRACE (TL_I, TM_Mp,("vpi %d\n", pMiniport->config.vpi));
    TRACE (TL_I, TM_Mp,("Encap Type %x\n", pMiniport->Encap));
    
    TRACE (TL_T, TM_Mp, ("<-- NICReadRegParameters, Status=%x", Status));

    return Status;
}


VOID
epvcInitializeMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Initialize all the lookaside lists in the adapter block

Arguments:


Return Value:

    None.

--*/
    
{
    USHORT DefaultDepth = 15;
    extern const UINT MaxEthernetFrameSize ;

    TRACE( TL_T, TM_Mp, ( "==> nicInitializeMiniportLookasideLists pMiniport %x ", pMiniport ) );


    switch (pMiniport->Encap) 
    {
        case IPV4_ENCAP_TYPE:
        case IPV4_LLC_SNAP_ENCAP_TYPE:
        {

            epvcInitializeLookasideList ( &pMiniport->arps.LookasideList,
                                        sizeof (EPVC_TASK),
                                        TAG_TASK,
                                        DefaultDepth );                                


            
            epvcInitializeLookasideList ( &pMiniport->rcv.LookasideList,
                                        sizeof (EPVC_IP_RCV_BUFFER),
                                        TAG_RCV ,
                                        DefaultDepth );                                




            break;
        }
    
        case ETHERNET_ENCAP_TYPE:
        case ETHERNET_LLC_SNAP_ENCAP_TYPE:
        {

            break;
        }

        default: 
        {


        }




    }

    TRACE( TL_T, TM_Mp, ( "<== nicInitializeMiniportLookasideLists  " ) );

}



VOID
epvcDeleteMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Delete all the lookaside lists in the adapter block

Arguments:


Return Value:

    None.

--*/

{
    TRACE( TL_T, TM_Mp, ( "== epvcDeleteMiniportLookasideLists pMiniport %x ", pMiniport) );


    //
    // Deletes the lookaside lists if they have been allocated
    //
    epvcDeleteLookasideList (&pMiniport->rcv.LookasideList);

    epvcDeleteLookasideList (&pMiniport->arps.LookasideList);




}



NDIS_STATUS
epvcInitializeMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    )

/*++

Routine Description:

    Initializr all the packet pools in the miniport 

Arguments:


Return Value:

    None.

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==> epvcInitializeMiniportPacketPools  pMiniport %x ", pMiniport ) );

    do
    {

        epvcAllocatePacketPool (&Status,
                                &pMiniport->PktPool.Send,
                                MIN_PACKET_POOL_SIZE,
                                MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                sizeof(EPVC_PKT_CONTEXT));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            EPVC_ZEROSTRUCT (&pMiniport->PktPool.Send);
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

 

        epvcAllocatePacketPool (&Status,
                                &pMiniport->PktPool.Recv,
                                MIN_PACKET_POOL_SIZE,
                                MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                PROTOCOL_RESERVED_SIZE_IN_PACKET);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            EPVC_ZEROSTRUCT (&pMiniport->PktPool.Recv);
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

    } while ( FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        epvcDeleteMiniportPacketPools (pMiniport);
        
    }

    TRACE( TL_T, TM_Mp, ( "<== epvcInitializeMiniportPacketPools  Status %x ", Status ) );

    return Status;
}



VOID
epvcDeleteMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Delete all the packet pools in the miniport block

Arguments:


Return Value:

    None.

--*/
    
{
    
    TRACE( TL_T, TM_Mp, ( "== epvcDeleteMiniportPacketPools  pMiniport %x ", pMiniport ) );



        //
        // Freeing packet pools
        //
        if (pMiniport->PktPool.Recv.Handle != NULL)
        {
            epvcFreePacketPool (&pMiniport->PktPool.Recv);
        }

        if (pMiniport->PktPool.Send.Handle != NULL)
        {
            epvcFreePacketPool (&pMiniport->PktPool.Send);

        }
}



VOID
epvcInitializeMiniportParameters(
    PEPVC_I_MINIPORT pMiniport
    )
{

    //ipv4 - 0
    //ipv4 with llc header = 1
    //Ethernet - 2
    //Ethernet with llc header- 3

    //
    // Defaults for all flags are FALSE
    //
        
    pMiniport->fDoIpEncapsulation = FALSE;
    pMiniport->fAddLLCHeader  = FALSE;

    
    switch (pMiniport->Encap )
    {

        case IPV4_ENCAP_TYPE:
        {
            pMiniport->fDoIpEncapsulation = TRUE;
            pMiniport->MinAcceptablePkt =sizeof (IPHeader) ;
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE -EPVC_ETH_HEADERSIZE ;

            break;
        }

        case IPV4_LLC_SNAP_ENCAP_TYPE:
        {
            pMiniport->fAddLLCHeader = TRUE;
            pMiniport->fDoIpEncapsulation = TRUE;
            pMiniport->pLllcHeader = &LLCSnapIpv4[0];
            pMiniport->LlcHeaderLength = sizeof(LLCSnapIpv4);
            pMiniport->MinAcceptablePkt = sizeof (IPHeader) + sizeof(LLCSnapIpv4);
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE  + sizeof(LLCSnapIpv4)-EPVC_ETH_HEADERSIZE ;

            break;
        }

        case ETHERNET_LLC_SNAP_ENCAP_TYPE:
        {
            pMiniport->fAddLLCHeader = TRUE;
            pMiniport->pLllcHeader = &LLCSnapEthernet[0];
            pMiniport->LlcHeaderLength = sizeof(LLCSnapEthernet);
            pMiniport->MinAcceptablePkt = MIN_ETHERNET_SIZE + sizeof(LLCSnapEthernet);
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE +sizeof(LLCSnapEthernet);

            break;
        }

        case ETHERNET_ENCAP_TYPE:
        {

            pMiniport->MinAcceptablePkt = MIN_ETHERNET_SIZE;
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE + EPVC_ETH_ENCAP_SIZE;
            break;
        }
            
        default: 
        {
            ASSERT (!"Not supported - defaulting to Ethernet Encapsulation");
            
        }



    }

}





NDIS_STATUS
epvcTaskHaltMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler for opening address families on an underlying adapters.
    The number of address families instantiated is determined by the 
    configuration read in the registry

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    ENTER("epvcTaskHaltMiniport", 0xaac34d81)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PEPVC_ADAPTER       pAdapter = pMiniport->pAdapter;
    PTASK_HALT          pTaskHalt = (PTASK_HALT)pTask;
    BOOLEAN             fTaskCompleted = FALSE; 
    ULONG               State;  

    enum 
    {
        Stage_Start =0, // default
        Stage_DeleteVc,
        Stage_CloseAfComplete, 
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE(TL_T, TM_Mp, ("==>epvcTaskHaltMiniport State %x", pTask->Hdr.State));

    State = pTask->Hdr.State;
    
    switch (pTask->Hdr.State)
    {   
        case Stage_Start:
        {
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_Start"));


            //
            // Check to see if the miniport has already halting.
            // If so exit
            //
            LOCKOBJ (pMiniport, pSR );

            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->pnp.pTaskHalt)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->pnp.pTaskHalt);

                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            // We are the primary task and we have the lock
            //
            
            ASSERT (pMiniport->pnp.pTaskHalt == pTaskHalt);
            //
            // Lets close the Call and Delete the Vc
            //
            UNLOCKOBJ (pMiniport, pSR);
            

            if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {
                PRM_TASK pVcTask = NULL;
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskVcTeardown, // pfnHandler,
                    0,                          // Timeout,
                    "Task: TearDown Vc",    // szDescription
                    &pVcTask ,
                    pSR
                    );

                if (FAIL(Status))
                {
                    fTaskCompleted = TRUE;

                    pVcTask  = NULL;
                    ASSERT (Status == NDIS_STATUS_SUCCESS);
                    break;
                }

                //
                // Now we will pend the halt on the completion of the delete VC
                // task
                //
                pTask->Hdr.State = Stage_DeleteVc;


                
                RmPendTaskOnOtherTask(pTask,
                                      0,
                                      pVcTask,
                                      pSR
                                      );

                //
                // Start the Vc TearDown
                //
                RmStartTask (pVcTask , 0, pSR);

                //
                // Exit - We expect to complete this task in another thread
                //
                Status = NDIS_STATUS_PENDING;
                break;

            }
            else //if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {
                pTask->Hdr.State = Stage_DeleteVc;
                //
                // Continue On - the Vc has already been deleted
                //

            }
            

        }

        case Stage_DeleteVc:
        {
            //
            // Now we check to see if the address family is still
            // open for this miniport
            //
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_DeleteVc"));


            if (MiniportTestFlag(pMiniport, fMP_AddressFamilyOpened) == TRUE)
            {
                PRM_TASK pAfTask = NULL;
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskCloseIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Close Miniport", // szDescription
                    &pAfTask ,
                    pSR
                    );

                if (FAIL(Status))
                {
                    fTaskCompleted = TRUE;

                    pAfTask  = NULL;
                    ASSERT (Status == NDIS_STATUS_SUCCESS);
                    break;
                }

                ((PTASK_AF)pAfTask)->Cause = TaskCause_MiniportHalt;

                //
                // Now we will pend the halt on the completion of the delete VC
                // task
                //
                pTask->Hdr.State = Stage_CloseAfComplete;

                
                
                RmPendTaskOnOtherTask(pTask,
                                      0,
                                      pAfTask,
                                      pSR
                                      );

                //
                // Start the Af TearDown
                //
                RmStartTask (pAfTask , 0, pSR);

                //
                // Exit - We expect to complete this task in another thread
                //
                Status = NDIS_STATUS_PENDING;
                break;

            }
            else //if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {

                pTask->Hdr.State = Stage_CloseAfComplete;

                //
                // Continue On - the Af has already been deleted
                //

            }
            
    
        }
        case Stage_CloseAfComplete: 
        {
            //
            // Free all miniport resources here .- packet pools etc.
            //
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_CloseAfComplete"));

            //
            // Freeing Lookaside lists
            //
            epvcDeleteMiniportLookasideLists (pMiniport);

            //
            // Freeing packet pools
            //
            epvcDeleteMiniportPacketPools(pMiniport);
            
            //
            // If the miniport is halting we do not shut down the protocol's adapter 
            // object
            //
            fTaskCompleted = TRUE;
            Status = NDIS_STATUS_SUCCESS;
            break;


        }

        case Stage_TaskCompleted:
        {
            ASSERT(0);
            break;
        }
        case Stage_End:     
        {
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_End"));
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERT (pTask->Hdr.State <= Stage_End);
        }


    } // end of switch 


    //
    // if this thread has completed the postprocessing,
    // then signal the event.
    //

    if (TRUE == fTaskCompleted)
    {
        BOOLEAN fSetWaitEvent = FALSE;
        TRACE (TL_V, TM_Mp, ("Task Halt Miniport - Stage End"));
        pTask->Hdr.State = Stage_End;
        if (FAIL(Status))
        {

            ASSERT (0);
        }

        LOCKOBJ (pMiniport, pSR);

        pMiniport->pnp.pTaskHalt = NULL;

        if (MiniportTestFlag (pMiniport, fMP_WaitingForHalt)== TRUE)
        {
            MiniportClearFlag (pMiniport, fMP_WaitingForHalt);
            fSetWaitEvent = TRUE;
        }
        
        UNLOCKOBJ (pMiniport, pSR);

        // 
        //  This first event is for the MiniportHalt handler 
        // which fired off this task
        // 
        epvcSetEvent (&pTaskHalt->CompleteEvent);

        //
        // This second event is for the epvcMiniportDoUnbind
        // which wants to wait until the Halt is complete ,
        // before it shuts off the lower binding to the phy. adapter
        //
        if (fSetWaitEvent)
        {
            epvcSetEvent (&pMiniport->pnp.HaltCompleteEvent);
        }
  

        Status = NDIS_STATUS_SUCCESS;
    }

    
    TRACE(TL_T, TM_Mp, ("<==epvcTaskHaltMiniport Status %x", Status));



    EXIT()
    RM_ASSERT_NOLOCKS(pSR);
    return Status;
}


NDIS_STATUS 
epvcAddEthernetTail(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Makes sure the ethernet packet is greater than 64 bytes

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    Success -   if the padding was not needed or the MDL 
                was successfully appended
--*/    
{
    ENTER ("epvcAddEthernetTail" , 0x3ec589c9) 

    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    ULONG               PacketLength   = 0;
    ULONG               LengthRemaining = 0;
    PNDIS_BUFFER        pNewTailBuffer = NULL;
    PNDIS_BUFFER        pLastBuffer;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddEthernetTail"));



    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;

            break; // we are done
        }

        //
        // Check the length of the Ethernet packet
        //
        NdisQueryPacketLength(pNewPkt, &PacketLength);

        //
        // Is the packet length greater than 64
        //
        if (PacketLength >= MINIMUM_ETHERNET_LENGTH)
        {
            NdisStatus= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Add padding to fill up the minimum Ethernet frame length.
        // This is a new buffer that is appended to the original
        // NDIS_BUFFER chain.
        //
        LengthRemaining = MINIMUM_ETHERNET_LENGTH - PacketLength;

        NdisAllocateBuffer(&NdisStatus, &pNewTailBuffer, NULL, &gPaddingBytes,LengthRemaining);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pNewTailBuffer == NULL)
        {
            pNewTailBuffer = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Append the new buffer to the tail of the packet.
        //

        //
        // Locate the last NDIS_BUFFER in the packet. Do it the hard
        // way since Packet->Private.Tail is not reliable:
        //
        pLastBuffer = pNewPkt->Private.Head;

        while (pLastBuffer->Next != NULL)
        {
            pLastBuffer = pLastBuffer->Next;
        }

    
        //
        // Save a pointer to this last MDL so that we can set its
        // Next field back to NULL when we complete this send.
        //
        pSendStruct->Context.Stack.EthernetSend.pOldLastNdisBuffer = pLastBuffer;

        //
        // Append the new buffer to the tail of the chain.
        //
        pLastBuffer->Next = pNewTailBuffer;
        pNewTailBuffer->Next = NULL;


        //
        // Update our packet.
        //
        pNewPkt->Private.Tail = pNewTailBuffer;
        pNewPkt->Private.ValidCounts = FALSE;
        
        NdisStatus = NDIS_STATUS_SUCCESS;

        break ; // we are done

    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS && pNewTailBuffer != NULL)
    {
        NdisFreeBuffer (pNewTailBuffer);
    }


    TRACE (TL_T, TM_Send, ("<==epvcAddEthernetTail  "));

    return NdisStatus ;

}



VOID
epvcRemoveEthernetTail (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket,
    IN PEPVC_PKT_CONTEXT pContext
    )
/*++
Routine Description:

    Removes the extra MDL that was added to make 
    this packet greater than MINIUMUM_ETHERNET_SIZE

    Used for Ethernet , Eth +LLC Encapsulations only 
    
Arguments:
    pMiniport - Miniport structure
    pPacket - Packet allocated by EPVC
    pContext - Context of the packet - used to store the original last mdl

    
Return:
    None
--*/    
{
    PNDIS_BUFFER pOldLastNdisBuffer = NULL;

    do
    {

        //
        // Ethernet encapsulation ? If not, then exit
        //
            
        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            break; // there was no ethernet encapsulation, so exit
        }

        //                    
        // if there is no old buffer, then we can exit
        //
        pOldLastNdisBuffer = pContext->Stack.EthernetSend.pOldLastNdisBuffer;
        
        if (pOldLastNdisBuffer == NULL)
        {
            break;
        }

        //
        // Free the last buffer in the packet (this is the padding
        // we added for a runt packet).
        //
        NdisFreeBuffer(pPacket->Private.Tail);

        //
        // Set the Next pointer of the original "last buffer" to NULL.
        //
        pOldLastNdisBuffer->Next = NULL;
        
                
    } while (FALSE);

}



NDIS_STATUS 
epvcAddEthernetPad(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Makes sure the ethernet packet w/o LLC header has a pad of 
    0x00, 0x00 

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    Success -   if the padding was not needed or the MDL 
                was successfully added
--*/    
{
    ENTER ("epvcAddEthernetPad" , 0x3ec589c9) 

    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    PNDIS_BUFFER        pPaddingBuffer = NULL;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddEthernetPad"));



    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->Encap != ETHERNET_ENCAP_TYPE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;
            break; // we are done
        }

        //
        // It is pure Ethernet. We need to precede the packet
        // with a 00,00
        //

        NdisAllocateBuffer(&NdisStatus, 
                        &pPaddingBuffer, 
                        NULL, 
                        &gPaddingBytes,
                        ETHERNET_PADDING_LENGTH);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pPaddingBuffer == NULL)
        {
            pPaddingBuffer = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // no more allocations - we cannot fail from here
        //
        NdisStatus = NDIS_STATUS_SUCCESS;

        //
        // Add  the new buffer to the head of the packet
        //
        NdisChainBufferAtFront(pNewPkt,pPaddingBuffer);

 
        break ; // we are done
        


    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS && pPaddingBuffer != NULL)
    {
        NdisFreeBuffer (pPaddingBuffer);
    }


    TRACE (TL_T, TM_Send, ("<==epvcAddEthernetPad  "));

    return NdisStatus ;

}


VOID
epvcRemoveEthernetPad (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket
    )
/*++
Routine Description:

    Removes the padding  that was added to the 
    head of the packet Ethernet Head
    
    Used for Ethernet Encapsulation only 
    
Arguments:
    pMiniport - Miniport structure
    pPacket - Packet
    
Return:
    None
--*/    
{
    PNDIS_BUFFER pPaddingBuffer= NULL;

    do
    {

        if (pMiniport->Encap != ETHERNET_ENCAP_TYPE)
        {
            break; // we are done
        }

        //                    
        // it is in pure ethernet mode - remove the Padding
        //

        //
        // First - a simple sanity check
        //
        {
            PNDIS_BUFFER pBuffer = pPacket->Private.Head;
            ULONG PaddingLength = NdisBufferLength(pBuffer);
            
            if (PaddingLength !=ETHERNET_PADDING_LENGTH)
            {
                // this is not our MDL 
                ASSERT (PaddingLength !=ETHERNET_PADDING_LENGTH);
                break;
            }
        } 
        
        //
        // Free the padding buffer at the front of the Packet
        //
        
        NdisUnchainBufferAtFront(pPacket,&pPaddingBuffer );

        NdisFreeBuffer (pPaddingBuffer );
        
        
    } while (FALSE);


}



VOID
epvcCancelDeviceInstance(
    IN PEPVC_I_MINIPORT pMiniport ,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This function cancels an outstanding Device Instance. 
    If the NDIS call fails. it waits for an event in the miniprot to fire. 
    After that it goes ahead and DeInitializes the Device Instance
    
Arguments:
    pMiniport - Miniport in question.

Return Value:
    Success
--*/
{
    ENTER("epvcCancelDeviceInstance", 0x0e42d778)
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;        
    UINT iteration =0;
    BOOLEAN bWaitSuccess = FALSE;
    BOOLEAN fNeedToInitEvent = FALSE;

    do
    {
        LOCKOBJ (pMiniport, pSR);

        // Prepare the event, and mark the structure as being Canceled
        epvcResetEvent (&pMiniport->pnp.DeInitEvent);

        // Set the flag to mark it as cancelled           
        MiniportSetFlag (pMiniport, fMP_MiniportCancelInstance);

        UNLOCKOBJ (pMiniport, pSR);

        // Cancel the device instance
        Status = epvcIMCancelInitializeDeviceInstance(pMiniport);
                                                      

        if (Status == NDIS_STATUS_SUCCESS)
        {
            break;
        }   

            
        //
        // If the Cancel has not Succeeded then we should wait for 
        // the Initialize to complete
        //
        {
            BOOLEAN bWaitSuccessful;

            
            bWaitSuccessful = epvcWaitEvent (&pMiniport->pnp.DeInitEvent,WAIT_INFINITE);                                    


            if (bWaitSuccessful == FALSE)
            {
                ASSERT (bWaitSuccessful == TRUE);
            }
            

        }
        //
        // If cancel fails. Wait for the miniport to be initialized
        //
        
        ASSERT (pMiniport->ndis.MiniportAdapterHandle != NULL);

        //
        // If cancel fails. Wait for the miniport to be initialized
        //

        TRACE (TL_N, TM_Mp, ("Call DeInit after Cancel failed %p , ",pMiniport));
        
        epvcIMDeInitializeDeviceInstance (pMiniport);
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    LOCKOBJ(pMiniport, pSR);

    MiniportClearFlag (pMiniport, fMP_MiniportCancelInstance);

    UNLOCKOBJ (pMiniport, pSR);

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\protocol.h ===
#ifndef _PROTOCOL_H
#define PROTOCOL_H


//----------------------------------------------------------//
// Local structures                                         //
//----------------------------------------------------------//

typedef struct _STATUS_INDICATION_CONTEXT
{
    PVOID               StatusBuffer;
    UINT                StatusBufferSize;
    NDIS_STATUS         GeneralStatus;

} STATUS_INDICATION_CONTEXT, *PSTATUS_INDICATION_CONTEXT;



//----------------------------------------------------------//
//  epvc protocol helper functions                          //
//----------------------------------------------------------//



VOID
epvcAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

PRM_OBJECT_HEADER
epvcAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

    
ULONG
epvcAdapterHash(
    PVOID           pKey
    );

BOOLEAN
epvcAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );

NDIS_STATUS
epvcTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
epvcTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS 
epvcReadIntermediateMiniportConfiguration( 
    IN PEPVC_ADAPTER pAdapter, 
    IN NDIS_HANDLE MiniportListConfigName,
    IN PRM_STACK_RECORD pSR
    );
    

NDIS_STATUS
epvcReadAdapterConfiguration(
    PEPVC_ADAPTER       pAdapter,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
epvcTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcTaskStartIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

INT
epvcAfInitEnumerate(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        );


VOID
epvcInstantiateMiniport(
    IN PEPVC_ADAPTER pAdapter, 
    NDIS_HANDLE MIniportConfigHandle,
    PRM_STACK_RECORD pSR
    );

VOID
epvcGetAdapterInfo(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PRM_STACK_RECORD            pSR,
    IN  PRM_TASK                    pTask               // OPTIONAL
    );
    
INT
epvcProcessStatusIndication (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );



VOID
epvcMediaWorkItem(
    PNDIS_WORK_ITEM pWorkItem, 
    PVOID Context
    );


NDIS_STATUS
epvcTaskCloseIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

INT
epvcReconfigureMiniport (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
epvcPtNetEventReconfigure(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PVOID                   pBuffer,
    IN PRM_STACK_RECORD         pSR
    
    );


INT
epvcMiniportDoUnbind(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );


INT
epvcMiniportCloseAf(
        IN PEPVC_I_MINIPORT pMiniport,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
epvcProcessOidCloseAf(
    PEPVC_I_MINIPORT pMiniport,
    PRM_STACK_RECORD pSR
    );

VOID
nicCloseAfWotkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    );
    
//----------------------------------------------------------//
//  epvc protocol entry functions                           //
//----------------------------------------------------------//

VOID
EpvcRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       NdisRequest,
    IN  NDIS_STATUS         Status
    );

VOID
EpvcUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
    );


VOID
EpvcOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
);



VOID
EpvcCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
EpvcBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            pDeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );



NDIS_STATUS
EpvcPtPNPHandler(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );


VOID
EpvcPtSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

UINT
EpvcPtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

VOID
EpvcPtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    );


VOID
epvcRemoveExtraNdisBuffers (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_SEND_COMPLETE pStruct
    );


VOID
epvcExtractSendCompleteInfo (
    OUT PEPVC_SEND_COMPLETE     pStruct,
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket 
    );

NDIS_STATUS
epvcGetRecvPkt (
    IN PEPVC_RCV_STRUCT pRcvStruct,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    );


NDIS_STATUS
epvcAddEthHeaderToNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    );


NDIS_STATUS
epvcStripLLCHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcReturnPacketToOriginalState (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    );

UINT
EpvcCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );


NDIS_STATUS
epvcCopyNdisBufferChain (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PNDIS_BUFFER pInBuffer,
    IN PUCHAR pCurrOffset 
    );

VOID
epvcValidatePacket (
    IN PNDIS_PACKET pPacket
    );


INT
epvcReconfigureAdapter(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

BOOLEAN
epvcIsPacketLengthAcceptable (
    IN PNDIS_PACKET Packet, 
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
EpvcStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    );

NDIS_STATUS
epvcStripHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    ); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\protocol.c ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    ATM Ethernet PVC driver.

Author:
    ADube - created 


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


const WCHAR c_szIMMiniportList[]            = L"IMMiniportList";
const WCHAR c_szUpperBindings[]         = L"UpperBindings";


#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF





VOID
EpvcResetComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion for the reset.

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    Status                  Completion status

Return Value:

    None.

--*/
{
    PADAPT  pAdapt =(PADAPT)ProtocolBindingContext;

    //
    // We never issue a reset, so we should not be here.
    //
    ASSERT(0);
}



VOID
EpvcRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       pNdisRequest,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion handler for the previously posted request. All OIDS are completed by and sent to
    the same miniport that they were requested for.
    If Oid == OID_PNP_QUERY_POWER then the data structure needs to returned with all entries =
    NdisDeviceStateUnspecified

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    NdisRequest             The posted request
    Status                  Completion status

Return Value:

    None

--*/
{
    ENTER("EpvcRequestComplete", 0x44a78b21)
    
    PEPVC_ADAPTER       pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_NDIS_REQUEST  pEpvcRequest = (PEPVC_NDIS_REQUEST  )pNdisRequest;

    RM_DECLARE_STACK_RECORD(sr)

    pEpvcRequest = CONTAINING_RECORD(pNdisRequest, EPVC_NDIS_REQUEST, Request);
    pEpvcRequest->Status = Status;

    if (pEpvcRequest->pFunc == NULL)
    {
        //
        // Unblock the calling thread
        //
        NdisSetEvent(&pEpvcRequest ->Event);
    }
    else
    {

        //
        // Invoke the REquest completion handler
        //
        (pEpvcRequest->pFunc) (pEpvcRequest, Status);

    }

    EXIT()
    RM_ASSERT_CLEAR(&sr);
}



VOID
PtStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PEPVC_ADAPTER     pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    TRACE (TL_T, TM_Pt, ("== PtStatus Status %x", GeneralStatus));

}


VOID
EpvcStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    Call the Status indication function of all the miniports
    associated with this adapter
    
Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{

    ENTER ("EpvcStatus",0x733e2f9e)     
    PEPVC_ADAPTER               pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_WORKITEM              pWorkItem = NULL;
    STATUS_INDICATION_CONTEXT   Context;
    BOOLEAN                     bDoNotProcess = FALSE;
    BOOLEAN                     bIsMediaEvent = FALSE;
    NDIS_MEDIA_STATE            NewMediaState;
    
    RM_DECLARE_STACK_RECORD(SR);

    //
    // Store the parameter, these will be passed to the miniports
    // 
    Context.StatusBuffer = StatusBuffer ;
    Context.StatusBufferSize = StatusBufferSize;
    Context.GeneralStatus = GeneralStatus;

    do
    {
        LOCKOBJ(pAdapter, &SR);

        //
        // Check for 2 conditions i Is it a Media event and 
        // 2) if it is a  repeat indication
        //
        bIsMediaEvent = (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT  ||
                         GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT );

        //
        // Check for repitions next
        //

        if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT && 
            pAdapter->info.MediaState == NdisMediaStateConnected)
        {
            bDoNotProcess = TRUE;
        }


        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pAdapter->info.MediaState == NdisMediaStateDisconnected)
        {
            bDoNotProcess = TRUE;
        }

        //
        // Convert the Media Status into an NdisMediaState
        //
        if (bIsMediaEvent == TRUE && bDoNotProcess == FALSE)
        {
            if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT )
            {
                pAdapter->info.MediaState = NdisMediaStateDisconnected;
            }
            if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT)
            {
                pAdapter->info.MediaState = NdisMediaStateConnected;
            }
            
        }

        
        //
        // Update the Media state, if we have a new state
        //

        UNLOCKOBJ(pAdapter, &SR);


        if (bDoNotProcess == TRUE)
        {
            break;
        }

        
        epvcEnumerateObjectsInGroup(&pAdapter->MiniportsGroup, 
                                      epvcProcessStatusIndication ,
                                      (PVOID)&Context, 
                                      &SR);

    } while (FALSE);
                                      

    RM_ASSERT_CLEAR(&SR);
    EXIT()
    return;
}


INT
epvcProcessStatusIndication (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    If we get a media connect, we queue a task to do the Vc Setup

    If we get a media disconnect, we queue a task to tear the VC down

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PEPVC_I_MINIPORT            pMiniport           = (PEPVC_I_MINIPORT)pHdr;
    PEPVC_ADAPTER               pAdapter            = pMiniport->pAdapter;
    BOOLEAN                     fIsMiniportActive   = FALSE;
    PSTATUS_INDICATION_CONTEXT  pContext            = (PSTATUS_INDICATION_CONTEXT)pvContext ;
    NDIS_STATUS                 GeneralStatus       = pContext->GeneralStatus;

    
    do
    {
        //
        // if this is not a media indication pass it up to ndis.
        //

        fIsMiniportActive  = MiniportTestFlag(pMiniport, fMP_MiniportInitialized);


        if (fIsMiniportActive == FALSE)
        {
            break;
        }

  
        //
        //  Only pass up an indication if the miniport has been initialized
        //


        //
        // Filter out a duplicate Indication
        //
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pMiniport->info.MediaState == NdisMediaStateDisconnected)
        {
            break;
        }

        
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pMiniport->info.MediaState == NdisMediaStateDisconnected)
        {
            break;
        }

        //
        // Record the status and indicate it up to the protocols
        //
        if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT)
        {
            pMiniport->info.MediaState = NdisMediaStateConnected;
        }
        
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT ) 
        {
            pMiniport->info.MediaState = NdisMediaStateDisconnected;
        }
     
        epvcMIndicateStatus(pMiniport,
                                 GeneralStatus,
                                 pContext->StatusBuffer, 
                                 pContext->StatusBufferSize
                                 );
     


    } while (FALSE);

    //
    // As we continue the iteration, return TRUE
    //
    return TRUE;
}


VOID
epvcMediaWorkItem(
    PNDIS_WORK_ITEM pWorkItem, 
    PVOID Context
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    If we get a media connect, we queue a task to do the Vc Setup

    If we get a media disconnect, we queue a task to tear the VC down

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{

    ASSERT (0);
}




INT
epvcMiniportIndicateStatusComplete(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

 Indicate the status upto the protocols

Arguments:


Return Value:


--*/
{
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pHdr;

    BOOLEAN fIsMiniportActive  = MiniportTestFlag(pMiniport, fMP_MiniportInitialized);

    //
    //  Only pass up an indication if the miniport has been initialized
    //
    
    if (fIsMiniportActive  == TRUE )
    {   
        NdisMIndicateStatusComplete(pMiniport->ndis.MiniportAdapterHandle);
    }   

    return TRUE;
}



VOID
PtStatusComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ENTER("PtStatusComplete", 0x5729d194)
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(SR);
    
    //
    // Iterate through all the miniports and stop them
    //

    epvcEnumerateObjectsInGroup (&pAdapter->MiniportsGroup,
                                  epvcMiniportIndicateStatusComplete,
                                  NULL,
                                  &SR   );



}






VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet,
    IN  NDIS_STATUS         Status,
    IN  UINT                BytesTransferred
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    PEPVC_I_MINIPORT pMiniport =(PEPVC_I_MINIPORT )ProtocolBindingContext;

    
    if(pMiniport->ndis.MiniportAdapterHandle)
    {
          NdisMTransferDataComplete(pMiniport->ndis.MiniportAdapterHandle,
                                             Packet,
                                             Status,
                                             BytesTransferred);
    }
}






NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               HeaderBuffer,
    IN  UINT                HeaderBufferSize,
    IN  PVOID               LookAheadBuffer,
    IN  UINT                LookAheadBufferSize,
    IN  UINT                PacketSize
    )
/*++

Routine Description:
LBFO - need to use primary for all receives

Arguments:


Return Value:

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PNDIS_PACKET    MyPacket, Packet;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    if(!pAdapt->ndis.MiniportAdapterHandle)
    {
        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
}


VOID
PtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of received buffers.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

}


INT
PtReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet
    )
/*++

Routine Description:

    ReceivePacket handler. Called up by the miniport below when it supports NDIS 4.0 style receives.
    Re-package the packet and hand it back to NDIS for protocols above us. The re-package part is
    important since NDIS uses the WrapperReserved part of the packet for its own book-keeping. Also
    the re-packaging works differently when packets flow-up or down. In the up-path(here) the protocol
    reserved is owned by the protocol above. We need to use the miniport reserved here.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.
    Packet - Pointer to the packet

Return Value:

    == 0 -> We are done with the packet
    != 0 -> We will keep the packet and call NdisReturnPackets() this many times when done.
--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS Status;
    PNDIS_PACKET    MyPacket;
    PEPVC_PKT_CONTEXT           Resvd;

          return 0;
}






//--------------------------------------------------------------------------------
//                                                                              //
//  Address Family - Entry points and Tasks                                     //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



VOID
EpvcAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      pAddressFamily
    )
/*++

Routine Description:

    This informs us that the Call manager is bound to a NIC. and that the call 
    manager is telling us that it is ready to accepts calls.

    We expect there to be one interesting Address Family per underlying adapter
    
Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    ENTER("EpvcAfRegisterNotify", 0xaea79b12)

    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    
    RM_DECLARE_STACK_RECORD(SR);

    TRACE (TL_T, TM_Pt,("==>EpvcAfRegisterNotify\n"));


    do 
    {
        
        if (pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931)
        {
            //
            // The call manager is not indicating the address family for an atm 
            // miniport. We are not interested 
            //
            break;
        }

        LOCKOBJ(pAdapter, &SR);

        RmTmpReferenceObject(&pAdapter->Hdr, &SR);


        pAdapter->af.AddressFamily = *pAddressFamily;

        //
        //Begin a task that will call NdisClOpenAddressFamily asynchronously
        //
        UNLOCKOBJ(pAdapter, &SR);

        epvcEnumerateObjectsInGroup(&pAdapter->MiniportsGroup,
                                    epvcAfInitEnumerate,
                                    NULL, // Context
                                    &SR );

        LOCKOBJ(pAdapter, &SR);

        RmTmpDereferenceObject(&pAdapter->Hdr, &SR);
        
        UNLOCKOBJ(pAdapter, &SR);

    } while (FALSE);




    TRACE (TL_T, TM_Pt, ("<==EpvcAfRegisterNotify\n"));

    RM_ASSERT_CLEAR(&SR);

    EXIT()

}


// Enum function
//
INT
epvcAfInitEnumerate(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    We have been notified of an acceptable address family

    Iterate through all the miniort structures and open the address family
    and InitDeviceInstance on each of the miniports

    
Arguments:
    

--*/

{
    ENTER("epvcAfInitEnumerate ",0x72eb5b98 )
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pHdr; 
    //
    // Get miniport lock and tmpref it.
    //
    LOCKOBJ(pMiniport, pSR);
    RmTmpReferenceObject(&pMiniport->Hdr, pSR);

    
    do
    {
        NDIS_STATUS Status = NDIS_STATUS_FAILURE;
        PRM_TASK    pTask= NULL;
        PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;

        ASSERT (pAdapter->Hdr.Sig == TAG_ADAPTER);

        //
        // Allocate task to  complete the unbind.
        //
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskStartIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Open address Family",    // szDescription
                    &pTask,
                    pSR
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the Open Address Family.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by epvcAllocateTask.
        //
        UNLOCKOBJ(pMiniport, pSR);
        
        ((PTASK_AF) pTask)->pAf= &pAdapter->af.AddressFamily ;
        ((PTASK_AF) pTask)->Cause = TaskCause_AfNotify;
        RmStartTask(pTask, 0, pSR);

        LOCKOBJ(pMiniport, pSR);
    
    } while(FALSE);

    UNLOCKOBJ(pMiniport, pSR);
    RmTmpDereferenceObject(&pMiniport->Hdr, pSR);
    EXIT()

    //
    // As we want the enumeration to cotinue
    //
    return TRUE;

}



NDIS_STATUS
epvcTaskStartIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler for opening address families on an underlying adapters.
    The number of address families instantiated is determined by the 
    configuration read in the registry

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskStartIMiniport", 0xaac34d81)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    NDIS_STATUS         InitStatus  = NDIS_STATUS_SUCCESS;
    PTASK_AF            pAfTask     = (PTASK_AF) pTask;
    NDIS_HANDLE         NdisAfHandle = NULL;
    PEPVC_ADAPTER       pAdapter = pMiniport->pAdapter;
    ULONG               State = pTask->Hdr.State;

    enum 
    {
        Stage_Start =0, // default
        Stage_OpenAfComplete,
        Stage_CloseAfComplete, // In case of failure
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task


    TRACE ( TL_T, TM_Pt, ("==>epvcTaskStartIMiniport Code %x", Code) );
    
    TRACE (TL_V, TM_Pt, ("epvcTaskStartIMiniport Task %p Task is in state %x\n", pTask, pTask->Hdr.State));

    
    switch(pTask->Hdr.State)
    {
    
        case Stage_Start:
        {
            //
            // is there another open address family task active
            //
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->af.pAfTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->af.pAfTask);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->af.pAfTask == pAfTask);

            //
            // make sure we are bound to the adapter below. If not exit
            //
            if (CHECK_AD_PRIMARY_STATE (pAdapter, EPVC_AD_PS_INITED) == FALSE &&
                pAdapter->bind.BindingHandle == NULL)
            {
                //
                // quietly exit as the protocol is not bound to the adapter below
                //
                UNLOCKOBJ(pMiniport, pSR);
                pTask->Hdr.State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit
                break;
            }

            //
            // Check to see if our work is already done
            //


            if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == TRUE)
            {
                //
                // quietly exit as the address family is already Opened
                //
                UNLOCKOBJ(pMiniport, pSR);
                pTask->Hdr.State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit
                break;
            }


            UNLOCKOBJ(pMiniport,pSR);
            
            //
            // Get Ready to suspend the task.
            // First update the state so that the resume
            // will take it to the correct place
            //
            pTask->Hdr.State = Stage_OpenAfComplete;
            RmSuspendTask(  pTask, 0 ,pSR);

            //
            // Call Ndis  to open address family
            //
            Status = epvcClOpenAddressFamily(pAdapter->bind.BindingHandle,
                                             &pAdapter->af.AddressFamily,
                                             (NDIS_HANDLE)pMiniport,
                                             &EpvcGlobals.ndis.CC,
                                             sizeof (EpvcGlobals.ndis.CC),
                                             &NdisAfHandle
                                             );

            if (PEND(Status)== FALSE)
            {
                //
                // Call the completion handler
                //
                EpvcCoOpenAfComplete(Status,
                                   pMiniport,
                                   NdisAfHandle );
                                   
                Status = NDIS_STATUS_PENDING;                                   
            }
            //
            // Now let this thread exit. Make the Async
            // Completion handler complete the task
            //
            
            break;
        }


        case Stage_OpenAfComplete:
        {
            InitStatus = NDIS_STATUS_SUCCESS;

            // 
            // If the status is success then initialize the miniport
            //

            do 
            {
                
                if (pAfTask->ReturnStatus != NDIS_STATUS_SUCCESS)
                {

                    break;
                }

                //
                // Success, so Now initialize the miniport
                //
            
                LOCKOBJ (pMiniport, pSR);
                
                //
                // Set the appropriate flag
                //
                MiniportSetFlag(pMiniport, fMP_DevInstanceInitialized);

                UNLOCKOBJ (pMiniport, pSR);

                RM_ASSERT_NOLOCKS(pSR);

                InitStatus  = NdisIMInitializeDeviceInstanceEx( EpvcGlobals.driver.DriverHandle,
                                                               &pMiniport->ndis.DeviceName,
                                                               pMiniport);  
            } while (FALSE);
            
            //
            // Handle Failure
            //

            if (FAIL(InitStatus) || FAIL(pAfTask->ReturnStatus))
            {
                
                TRACE (TL_V, TM_Mp, ("epvcStartImMiniport Failed Status %x, InitStatus %x",Status, InitStatus));
                
                LOCKOBJ (pMiniport, pSR);

                //
                // Clear the appropriate flags
                //
                
                
                if (MiniportTestFlag(pMiniport, fMP_AddressFamilyOpened)== TRUE)
                {
                    MiniportClearFlag (pMiniport, fMP_AddressFamilyOpened);
                }
                else
                {
                    ASSERT (pMiniport->af.AfHandle == NULL);
                }
                
                UNLOCKOBJ (pMiniport, pSR);

                //
                // Close the Af if there was one.
                //

                if (pMiniport->af.AfHandle != NULL)
                {
                    pTask->Hdr.State = Stage_CloseAfComplete;
                    //
                    // Prepare to so an Async Close Af
                    //
                    RmSuspendTask (pTask, 0, pSR);
                    //
                    // Close Address Family
                    //

                    Status = epvcClCloseAddressFamily(pMiniport->af.AfHandle);

                    if (Status != NDIS_STATUS_PENDING)
                    {
                     
                        EpvcCoCloseAfComplete(Status,pMiniport );

                        Status = NDIS_STATUS_PENDING;                                       



                    }

                    break;

                }
            }

            //
            // We've finished task;
            //


            //
            // Fall through
            //
        }
        case Stage_CloseAfComplete: 
        {
            pTask->Hdr.State = Stage_TaskCompleted;
            Status = NDIS_STATUS_SUCCESS;


        }
        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;   
            break;
        }

        
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        



    }

    if (pTask->Hdr.State == Stage_TaskCompleted)
    {
        pTask->Hdr.State = Stage_End;

        
        LOCKOBJ(pMiniport, pSR);

        pMiniport->af.pAfTask   = NULL;

        UNLOCKOBJ(pMiniport, pSR);

        ASSERT (Status == NDIS_STATUS_SUCCESS);
    }
    


    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE ( TL_T, TM_Pt, ("<==epvcTaskStartIMiniport Status %x", Status) );


    return Status;
}



NDIS_STATUS
epvcTaskCloseIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    This is the task that Closes the miniport, the Device Instance and 
    the Address Family/

    There are three reason that the task could be called.
    1) Miniport Halt -MiniportInstance functions need not be called
    2) Protocol Unbind- MiniportInstance functions HAVE to be called
    3) CloseAddress Family - Miniport function are already called

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    ENTER ("epvcTaskCloseIMiniport", 0x83342651)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_AF            pAfTask     = (PTASK_AF) pTask;
    BOOLEAN             fNeedToHalt  = FALSE;
    BOOLEAN             fNeedToCancel = FALSE;
    ULONG               State;
    BOOLEAN             fAddressFamilyOpened = FALSE;
    BOOLEAN             fIsDevInstanceInitialized = FALSE;
    BOOLEAN             fIsMiniportHalting = FALSE;

    enum 
    {
        Stage_Start =0, // default
        Stage_CloseAddressFamilyCompleted,
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskCloseIMiniport State %x", pTask->Hdr.State) );

    State = pTask->Hdr.State;
    
    switch(pTask->Hdr.State)
    {
        case Stage_Start:
        {
            //
            // Check to see if the miniport has already opened an address family.
            // If so exit
            //
            LOCKOBJ (pMiniport, pSR );

            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->af.pAfTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->af.pAfTask);
                

                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);
                
            
                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->af.pAfTask == pAfTask);
            //
            // Check to see if our work is already done
            //


            if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == FALSE)
            {
                //
                // quietly exit as the address family is already closed
                //
                UNLOCKOBJ(pMiniport, pSR);
                State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_FAILURE; // Exit
                break;
            }

            fIsDevInstanceInitialized  = MiniportTestFlag (pMiniport, fMP_DevInstanceInitialized);            

            fIsMiniportHalting  = (pAfTask->Cause == TaskCause_MiniportHalt );
            
            //
            // Now do we need to halt the miniport. - 
            // Q1. Are we are in the middle of a Halt 
            // Q2. Has Our Miniport Instance been initialized  - 
            //        Has miniportInitialize been called - then DeInit the miniport
            //        If not then - cancel the Device Instance
            //
            if (TRUE == fIsDevInstanceInitialized ) 
            { 

                //
                // Clear the Device Instance flag.
                //
                MiniportClearFlag (pMiniport, fMP_DevInstanceInitialized);

                //
                // If we have called InitDeviceInstance, then figure out if 
                // we need to call CancelDeviceInstance or DeInitDeviceInstance. 
                // If the miniport is halting, we do not call any of them.
                //
                if ( FALSE ==fIsMiniportHalting)
                {
                    if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == TRUE)
                    {
                        //
                        // Our Halt Handler has not been called,
                        //
                        fNeedToHalt = TRUE;
                        
                    }
                    else
                    {
                        //
                        // Our miniport's initalized handler has not been called 
                        //
                        //
                        // We are not in the middle of a halt, so this probably
                        // an unbind .
                        //
                        fNeedToCancel = TRUE;
                    
                    }
                }                    

            }                

            //
            // Mark the address family as closed ,because this task will close it.
            //

            fAddressFamilyOpened = MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened);

            MiniportClearFlag (pMiniport, fMP_AddressFamilyOpened);
    

            UNLOCKOBJ(pMiniport,pSR);

            
            //
            // Call Ndis to Deinitialize the miniport, The miniport is already Refed
            //
            TRACE ( TL_T, TM_Pt, ("epvcTaskCloseIMiniport  ----") );

            if (TRUE == fNeedToHalt )
            {
                epvcIMDeInitializeDeviceInstance(pMiniport);
            }
            
            if (TRUE== fNeedToCancel)
            {
                ASSERT (!" Need To cancel in Task close Miniport");
                epvcCancelDeviceInstance(pMiniport, pSR);
            }

            //
            // Now close the address family asynchronously. 
            // First suspend this task
            //
            pTask->Hdr.State = Stage_CloseAddressFamilyCompleted;
            RmSuspendTask (pTask, 0 , pSR);

            if (fAddressFamilyOpened == TRUE)
            {
                
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcClCloseAddressFamily(pMiniport->af.AfHandle);

                if (Status != NDIS_STATUS_PENDING)
                {
                    EpvcCoCloseAfComplete(Status, pMiniport);
                    Status = NDIS_STATUS_PENDING;
                }
                
                
            }
            else
            {
                State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit


            }
                
            //
            // End this thread. If this thread is closing the addres family
            // then we exit. If not, then we do the cleanup below
            //
            break;
                
        }
        case Stage_CloseAddressFamilyCompleted:
        {
            Status = pAfTask->ReturnStatus;

            State = Stage_TaskCompleted ;
            break;
        
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        

    }


    if (Stage_TaskCompleted == State )
    {
        pTask->Hdr.State = Stage_End;
        Status = NDIS_STATUS_SUCCESS;


        //
        // Clear the task here
        //
        
        LOCKOBJ (pMiniport, pSR);

        pMiniport->af.pAfTask   = NULL;

        UNLOCKOBJ (pMiniport, pSR);


        //
        // Set the complete event here
        //
            
        if (pAfTask->Cause == TaskCause_ProtocolUnbind)
        {
            epvcSetEvent (&pAfTask->CompleteEvent);

        }

        if (pAfTask->Cause == TaskCause_AfCloseRequest)
        {
            //
            // Nothing to do 
            //
    
        }

    }


    RM_ASSERT_NOLOCKS(pSR);

    TRACE ( TL_T, TM_Pt, ("<== epvcTaskCloseIMiniport Status %x", Status) );
    
    EXIT();
    return Status;
}



VOID
epvcInstantiateMiniport(
    IN PEPVC_ADAPTER pAdapter, 
    NDIS_HANDLE MIniportConfigHandle,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine goes to the registry and reads the device name for the IM miniport. 
    It then allocates a structure for it. 

    If the allocation fails, it quietly returns as there is no more work to be done. 
    (Maybe we should deregister the protocol)

Arguments:


Return Value:

    None.

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE; 
    PEPVC_I_MINIPORT    pMiniport = NULL;
    NDIS_STRING UpperBindings;
    PNDIS_CONFIGURATION_PARAMETER pParameterValue = NULL;
    EPVC_I_MINIPORT_PARAMS Params;

    TRACE (TL_T, TM_Mp, ("==> epvcInstantiateMiniport pAdapter %p KeyName %p \n", pAdapter));

    do
    {

        


        //
        // Now read the upper bindings
        //

        NdisInitUnicodeString(&UpperBindings, c_szUpperBindings);

        NdisReadConfiguration(
                &NdisStatus,
                &pParameterValue,
                MIniportConfigHandle,
                &UpperBindings,
                NdisParameterString);



        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            TRACE (TL_T, TM_Mp, (" epvcInstantiateMiniport NdisReadConfiguration Failed"));
            break;

        }

        TRACE (TL_I, TM_Pt, ("Creating Miniport Adapter %x, KeyName: len %d, max %d, name: [%ws]\n",
                       pAdapter,
                       pParameterValue->ParameterData.StringData.Length,
                       pParameterValue->ParameterData.StringData.MaximumLength,
                       (unsigned char*)pParameterValue->ParameterData.StringData.Buffer)); 

        //
        // Check and see if we already have a miniport
        //
        
        RmLookupObjectInGroup(  &pAdapter->MiniportsGroup, 
                                0 , // no flags (not locked)
                                &pParameterValue->ParameterData.StringData,
                                NULL,
                                &(PRM_OBJECT_HEADER)pMiniport,
                                NULL,
                                pSR
                                );
        if (pMiniport!= NULL)
        {
            //
            // we already have a miniport, therefore exit.
            //
            break;
        }

        //
        // Create and Initialize the miniport here
        //

        
        Params.pDeviceName = &pParameterValue->ParameterData.StringData;
        Params.pAdapter = pAdapter;
        Params.CurLookAhead = pAdapter->info.MaxAAL5PacketSize;
        Params.NumberOfMiniports = (NdisInterlockedIncrement (&pAdapter->info.NumberOfMiniports) - 1);
        Params.LinkSpeed = pAdapter->info.LinkSpeed;
        Params.MacAddress = pAdapter->info.MacAddress;
        Params.MediaState = pAdapter->info.MediaState;
        
        NdisStatus =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                        &pAdapter->MiniportsGroup,
                        Params.pDeviceName,     // Key
                        &Params,                    // Init params
                        &((PRM_OBJECT_HEADER)pMiniport),
                        NULL,   // pfCreated
                        pSR
                        );

                        
        if (FAIL(NdisStatus))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pMiniport = NULL;
            break;
        }
            
        UNLOCKOBJ(pMiniport,pSR);       
        
        //
        // Initalize new miniport specific events here
        //
        epvcInitializeEvent (&pMiniport->pnp.HaltCompleteEvent);
        epvcInitializeEvent (&pMiniport->pnp.DeInitEvent);

    } while (FALSE);

    if (FAIL(NdisStatus ) == TRUE)
    {
        //
        // Do nothing
        //
        ASSERT (FAIL(NdisStatus ) == FALSE);

    }
    else
    {
        RmTmpDereferenceObject(&pMiniport->Hdr, pSR);
    }

    TRACE (TL_T, TM_Mp, ("<== epvcInstantiateMiniport pMiniport %p \n", pMiniport));

}












//--------------------------------------------------------------------------------
//                                                                              //
//  Adapter RM Object - Create, Delete, Hash and Compare functions              //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



PRM_OBJECT_HEADER
epvcAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type EPVC_ADAPTER.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a EPVC_ADAPTER_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    PEPVC_ADAPTER               pA;
    PEPVC_ADAPTER_PARAMS        pBindParams = (PEPVC_ADAPTER_PARAMS)pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_AdapterStaticInfo; 
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_I_MiniportStaticInfo ;

    ENTER("AdapterCreate", 0x9cb433f4);

    
    TRACE (TL_V, TM_Pt, ("--> epvcAdapterCreate") );

    EPVC_ALLOCSTRUCT(pA,     TAG_PROTOCOL);
    do
    {


        if (pA == NULL)
        {
            break;
        }

        EPVC_ZEROSTRUCT(pA);

        //
        // Do all the initialization work here
        //

        pA->Hdr.Sig = TAG_ADAPTER; 

        RmInitializeLock(
            &pA->Lock,
            LOCKLEVEL_ADAPTER
            );

        RmInitializeHeader(
            pParentObject,
            &pA->Hdr,
            TAG_ADAPTER,
            &pA->Lock,
            &EpvcGlobals_AdapterStaticInfo,
            NULL,
            psr
            );

        //
        // Now initialize the adapter structure with the parameters 
        // that were passed in.
        //

        // Create up-cased version of the DeviceName and save it.
        //
        //
        Status = epvcCopyUnicodeString(
                            &(pA->bind.DeviceName),
                            pBindParams->pDeviceName,
                            TRUE                        // Upcase
                            );

        if (FAIL(Status))
        {
            pA->bind.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        pA->bind.pEpvcConfigName = pBindParams->pEpvcConfigName;

        Status = epvcCopyUnicodeString(
                            &(pA->bind.EpvcConfigName),
                            pBindParams->pEpvcConfigName,
                            FALSE
                            );
                            
        pA->bind.BindContext  = pBindParams->BindContext;

        //
        // Initialize and allocate a group for all the intermediate miniports that 
        // will be instantiated over this physical adapter
        //


        RmInitializeGroup(
                        &pA->Hdr,                               // pOwningObject
                        &EpvcGlobals_I_MiniportStaticInfo ,
                        &(pA->MiniportsGroup),
                        "Intermediate miniports",                       // szDescription
                        psr
                        );



        Status = NDIS_STATUS_SUCCESS;
    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pA != NULL)
        {
            epvcAdapterDelete ((PRM_OBJECT_HEADER) pA, psr);
            pA = NULL;
        }
    }

    TRACE (TL_V, TM_Pt, ("<-- epvcAdapterCreate pAdpater. %p",pA) );

    return (PRM_OBJECT_HEADER) pA;
}


VOID
epvcAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Free an object of type EPVC_ADAPTER.

Arguments:

    pHdr    - Actually a pointer to the EPVC_ADAPTER to be deleted.

--*/
{
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) pObj;

    TRACE (TL_V, TM_Pt, ("-- epvcAdapterDelete  pAdapter %p",pAdapter) );

    pAdapter->Hdr.Sig = TAG_FREED; 


    EPVC_FREE   (pAdapter);
}




BOOLEAN
epvcAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for EPVC_ADAPTER.

Arguments:

    pKey        - Points to a Epvc Protocol object.
    pItem       - Points to EPVC_ADAPTER.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    PEPVC_ADAPTER pA = NULL;
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    BOOLEAN fCompare;

    pA  = CONTAINING_RECORD(pItem, EPVC_ADAPTER, Hdr.HashLink);

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pA->bind.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pA->bind.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    

    TRACE (TL_V, TM_Pt, ("-- epvcProtocolCompareKey pAdapter %p, pKey, return %x",pA, pKey, fCompare ) );

    return fCompare;
}



ULONG
epvcAdapterHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an Epvc Protocol block.

Return Value:

    ULONG-sized hash of the string.
    

--*/
{

    
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    WCHAR *pwch = pName->Buffer;
    WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
    ULONG Hash  = 0;

    for (;pwch < pwchEnd; pwch++)
    {
        Hash ^= (Hash<<1) ^ *pwch;
    }

    return Hash;
}





//--------------------------------------------------------------------------------
//                                                                              //
//  Bind Adapter - Entry Points and Tasks                                       //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

VOID
EpvcBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            pDeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )


/*++

Routine Description:

    This is called by NDIS when it has an adapter for which there is a
    binding to the Epvc Protocol.

    We first allocate an Adapter structure. Then we open our configuration
    section for this adapter and save the handle in the Adapter structure.
    Finally, we open the adapter.

    We then read the registry and find out how many intermediate Miniports are 
    sitting on top of this adapter. Data structures are initialized for these Miniports

    We don't do anything more for this adapter until NDIS notifies us of
    the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

    pStatus             - Place to return status of this call
    BindContext         - Not used, because we don't pend this call 
    pDeviceName         - The name of the adapter we are requested to bind to
    SystemSpecific1     - Opaque to us; to be used to access configuration info
    SystemSpecific2     - Opaque to us; not used.

Return Value:

    Always TRUE. We set *pStatus to an error code if something goes wrong before 
we
    call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
    NDIS_STATUS         Status;
    EPVC_ADAPTER        *pAdapter;
#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG

    ENTER("BindAdapter", 0xa830f919)
    RM_DECLARE_STACK_RECORD(SR)
    TIMESTAMP("==>BindAdapter");

    

    do 
    {
        PRM_TASK            pTask;
        EPVC_ADAPTER_PARAMS BindParams;

        // Setup initialization parameters
        //
        BindParams.pDeviceName          = pDeviceName;
        BindParams.pEpvcConfigName      = (PNDIS_STRING) SystemSpecific1;
        BindParams.BindContext          = BindContext;


        // Allocate and initialize adapter object.
        // This also sets up ref counts for all linkages, plus one
        // tempref for us, which we must deref when done.
        //
        Status =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                            &EpvcGlobals.adapters.Group,
                            pDeviceName,                // Key
                            &BindParams,                // Init params
                            &((PRM_OBJECT_HEADER)pAdapter),
                            NULL,   // pfCreated
                            &SR
                            );
        if (FAIL(Status))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pAdapter = NULL;
            break;
        }
    
        // Allocate task to  complete the initialization.
        // The task is tmp ref'd for us, and we must deref it when we're done here.
        // We implicitly do this by calling RmStartTask below.
        //
        Status = epvcAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    epvcTaskInitializeAdapter,  // pfnHandler,
                    0,                          // Timeout,
                    "Task: Initialize Adapter", // szDescription
                    &pTask,
                    &SR
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        UNLOCKOBJ(pAdapter, &SR);

        // Start the task to complete this initialization.
        // NO locks must be held at this time.
        // RmStartTask expect's a tempref on the task, which it deref's when done.
        // RmStartTask will free the task automatically, whether it completes
        // synchronously or asynchronously.
        //
        RmStartTask(pTask, 0, &SR);

        TRACE (TL_V, TM_Pt, ("Task InitializeAdapter - Start Task returned %x", Status));
        LOCKOBJ(pAdapter, &SR);

    } while(FALSE);

    if (pAdapter)
    {
        UNLOCKOBJ(pAdapter, &SR);

        if (!PEND(Status) && FAIL(Status))
        {
            // At this point the adapter should be a "zombie object."
            //
            ASSERTEX(RM_IS_ZOMBIE(pAdapter), pAdapter);
        }

        RmTmpDereferenceObject(&pAdapter->Hdr, &SR);

        *pStatus = NDIS_STATUS_PENDING;

    }
    else
    {
        //
        // Fail the bind as the adapter was not allocated
        //
        *pStatus = NDIS_STATUS_FAILURE;
    }
    



#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_INFO(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    RM_ASSERT_CLEAR(&SR);
    EXIT()
    TIMESTAMP("<==BindAdapter");
    TRACE (TL_T, TM_Pt, ("<==BindAdapter %x", *pStatus));

    RM_ASSERT_CLEAR(&SR);

    return ;
}



NDIS_STATUS
epvcTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) RM_PARENT_OBJECT(pTask);
    PTASK_ADAPTERINIT pAdapterInitTask;

    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_ActivateAdapterComplete,
        STAGE_DeactivateAdapterComplete,
        STAGE_End

    } Stage;

    ENTER("TaskInitializeAdapter", 0x18f9277a)

    pAdapterInitTask = (PTASK_ADAPTERINIT) pTask;

    TRACE (TL_T, TM_Pt, ("==>epvcTaskInitializeAdapter Code %x \n", Code));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                epvcSetPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_INITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the activate adapter task.
            //
            {
                PRM_TASK pActivateTask;

                Status = epvcAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            epvcTaskActivateAdapter,        // pfnHandler,
                            0,                          // Timeout,
                            "Task: Activate Adapter(init)", // szDescription
                            &pActivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pActivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc activate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_ActivateAdapterComplete,
                        pActivateTask,              // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pActivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }


        if (PEND(Status)) break;
        
        // FALL THROUGH TO NEXT STAGE

        case STAGE_ActivateAdapterComplete:
        {
            //
            // We've run the active-adapter task. On failure, we need to
            // cleanup state by calling the deactivate-adapter task.
            //

            // Save away the failure code for later...
            //
            pAdapterInitTask->ReturnStatus = Status;

            if (FAIL(Status))
            {
                PRM_TASK pDeactivateTask;

                Status = epvcAllocateTask(
                                &pAdapter->Hdr,             // pParentObject,
                                epvcTaskDeactivateAdapter,      // pfnHandler,
                                0,                          // Timeout,
                                "Task: Deactivate Adapter(init)", // szDescription
                                &pDeactivateTask,
                                pSR
                                );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    ASSERT(FALSE); // TODO: use special dealloc task pool for this.
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {

                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    //
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
        }
        break;

        case STAGE_DeactivateAdapterComplete:
        {
        
            //
            // We've completed the deactivate adapter task which we started
            // because of some init-adapter failure.
            //

            // In general, we don't expect the deactivate task to return failure.
            //
            ASSERT(!FAIL(Status));

            // We expect the original status of the init to be a failure (that's
            // why we started the deinit in the first place!
            //
            ASSERT(FAIL(pAdapterInitTask->ReturnStatus));
            Status = pAdapterInitTask->ReturnStatus;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            {
                ULONG InitState;
                InitState = FAIL(Status) ? EPVC_AD_PS_FAILEDINIT : EPVC_AD_PS_INITED;
                epvcClearPrimaryAdapterTask(pAdapter, pTask, InitState, pSR);
            }
            BindContext = pAdapter->bind.BindContext;
            UNLOCKOBJ(pAdapter, pSR);


            // On failure, pAdapter should be deallocated.
            //
            if (FAIL(Status))
            {
                if(RM_IS_ZOMBIE(pAdapter))
                {
                    TR_WARN(("END: pAdapter is already deallocated.\n"));
                }
                else
                {
                    //
                    // On failure, free the adapter here itself, because we're
                    // not going to call the shutdown task.
                    //
                    RmFreeObjectInGroup(
                        &EpvcGlobals.adapters.Group,
                        &(pAdapter->Hdr),
                        NULL,               // NULL pTask == synchronous.
                        pSR
                        );
                        
                    pAdapter = NULL;                        
                }
            }

            //
            // Clear out the variables that are valid only
            // during the BindAdapter Call
            //
            if (pAdapter != NULL)
            {
                pAdapter->bind.pEpvcConfigName = NULL;
            }
            // Signal Ndis that the bind is complete.
            //
            NdisCompleteBindAdapter(BindContext ,
                                  Status,
                                  NDIS_STATUS_PENDING);
            TIMESTAMP("== Completing the Adapter Bind");
            RM_ASSERT_NOLOCKS(pSR);

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE (TL_T, TM_Pt, ("<==epvcTaskInitializeAdapter Status %x\n", Status));

    return Status;
}


NDIS_STATUS
epvcTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) RM_PARENT_OBJECT(pTask);

    enum
    {
        PEND_OpenAdapter,
        PEND_GetAdapterInfo
    };
    ENTER("TaskInitializeAdapter", 0xb6ada31d)
    TRACE (TL_T, TM_Pt, ("==>epvcTaskActivateAdapter pAdapter %p Code %x",pAdapter, Code ));

    switch(Code)
    {

        case RM_TASKOP_START:
        {
        
            NDIS_MEDIUM                 Medium = NdisMediumAtm;


            UINT                        SelMediumIndex = 0;
            NDIS_STATUS                 OpenStatus;

            TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_START "));


            // Set ourselves as the secondary task.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcSetSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_ACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            //
            // Suspend task and call NdisOpenAdapter...
            //

            RmSuspendTask(pTask, PEND_OpenAdapter, pSR);
            RM_ASSERT_NOLOCKS(pSR);

            epvcOpenAdapter(
                &Status,
                &OpenStatus,
                &pAdapter->bind.BindingHandle,
                &SelMediumIndex,                    // selected medium index
                &Medium,                            // Array of medium types
                1,                                  // Size of Media list
                EpvcGlobals.driver.ProtocolHandle,
                (NDIS_HANDLE)pAdapter,              // our adapter bind context
                &pAdapter->bind.DeviceName,         // pDeviceName
                0,                                  // Open options
                (PSTRING)NULL,                      // Addressing Info...
                pSR);
            
            if (Status != NDIS_STATUS_PENDING)
            {
                EpvcOpenAdapterComplete(
                        (NDIS_HANDLE)pAdapter,
                        Status,
                        OpenStatus
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            PTASK_ADAPTERACTIVATE pAdapterInitTask;
            pAdapterInitTask = (PTASK_ADAPTERACTIVATE) pTask;
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            ASSERT(sizeof(TASK_ADAPTERACTIVATE) <= sizeof(EPVC_TASK));

            
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OpenAdapter:
        
                    //
                    // The open adapter operation is complete. Get adapter
                    // information and notify IP on success. On failure,
                    // shutdown the adapter if required, and notify IP of
                    // the failure.
                    //

                    TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_PENDCOMPLETE - PEND_OpenAdapter "));


                    if (FAIL(Status))
                    {
                        // Set adapter handle to null -- it may not be hull.
                        // even though the open adapter has succeeded.
                        //
                        pAdapter->bind.BindingHandle = NULL;
                        break;
                    }

                    ASSERT (pAdapter->bind.BindingHandle != NULL);

                    // FALL THROUGH on synchronous completion of arpGetAdapterInfo...

                case PEND_GetAdapterInfo:

                    //
                    // Done with getting adapter info.
                    // We need to switch to passive before going further
                    //
                    TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_PENDCOMPLETE - PEND_GetAdapterInfo "));

                    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
                    if (!EPVC_ATPASSIVE())
                    {
                        ASSERT (!"Should not be here");
                        
                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_GetAdapterInfo
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        /*RmSuspendTask(pTask, PEND_GetAdapterInfo, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &pAdapterInitTask->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;*/
                        break;
                    }
            
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        //
                        // Copy over adapter info into pAdapter->info...
                        // Then read configuration information.
                        //

                        //
                        // Query the ATM adapter for HW specific Info
                        //
                        epvcGetAdapterInfo(pAdapter, pSR, NULL);

                        // Read Adapter Configuration Information
                        //
                        Status =  epvcReadAdapterConfiguration(pAdapter, pSR);

                        Status = NDIS_STATUS_SUCCESS;
                    }

                    //
                    // NOTE: if we fail, a higher level task is responsible
                    // for "running the compensating transaction", i.e., running
                    // epvcTaskDeactivateAdapter.
                    //

                // end case  PEND_OpenAdapter, PEND_GetAdapterInfo
                
                break;
    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))


        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            
            TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_END"));
            Status = (NDIS_STATUS) UserParam;

            // We're done -- the status had better not be pending!
            //
            ASSERTEX(!PEND(Status), pTask);

            // Clear ourselves as the secondary task in the adapter object.
            //
            {
                ULONG InitState;
                LOCKOBJ(pAdapter, pSR);
                InitState = FAIL(Status)
                             ? EPVC_AD_AS_FAILEDACTIVATE
                             : EPVC_AD_AS_ACTIVATED;
                epvcClearSecondaryAdapterTask(pAdapter, pTask, InitState, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            Status = NDIS_STATUS_SUCCESS;
            
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE (TL_T, TM_Pt, ("<==epvcTaskActivateAdapter Status %x", Status ));

    return Status;
}


VOID
EpvcOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisOpenAdapter
    that had pended has completed. We now complete the BindAdapter
    that lead to this.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an EPVC_ADAPTER structure.
    Status                  - Status of OpenAdapter
    OpenErrorStatus         - Error code in case of failure.

--*/
{
    ENTER("OpenAdapterComplete", 0x06d9342c)


    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(SR)


    TIMESTAMP("==>OpenAdapterComplete");
    TRACE ( TL_T, TM_Mp, ("==>OpenAdapterComplete"));

    // We expect a nonzero task here (the bind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    {
        TR_INFO((
            "BindCtxt=0x%p, status=0x%p, OpenErrStatus=0x%p",
            ProtocolBindingContext,
            Status,
            OpenErrorStatus
            ));

        // We don't pass on OpenErrorStatus, so we have just the status
        // to pass on, which we do directly as the UINT_PTR "Param".
        //
        RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &SR);
    }

    RM_ASSERT_CLEAR(&SR)
    EXIT()
    TRACE ( TL_T, TM_Mp, ("<==OpenAdapterComplete"));
    TIMESTAMP("<==OpenAdapterComplete");

    RM_ASSERT_CLEAR(&SR);
}



NDIS_STATUS
epvcTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) RM_PARENT_OBJECT(pTask);
    BOOLEAN             fContinueShutdown = FALSE;
    enum
    {
        PEND_CloseAdapter
    };
    ENTER("TaskShutdownAdapter", 0xe262e828)
    TRACE ( TL_T, TM_Pt, ("==>epvcTaskDeactivateAdapter Code %x", Code) );

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            NDIS_HANDLE NdisAdapterHandle;

            LOCKOBJ(pAdapter, pSR);
            epvcSetSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);
            fContinueShutdown = TRUE;

            //
            // Iterate through all the miniports and stop them
            //

            epvcEnumerateObjectsInGroup (&pAdapter->MiniportsGroup,
                                          epvcMiniportDoUnbind,
                                          NULL,
                                          pSR   );


            //
            // Close the adapter below
            // 
            LOCKOBJ(pAdapter, pSR);
    
    
            NdisAdapterHandle = pAdapter->bind.BindingHandle;
            pAdapter->bind.BindingHandle = NULL;
            
            UNLOCKOBJ(pAdapter, pSR);

            if (NdisAdapterHandle != NULL)
            {
                //
                // Suspend task and call NdisCloseAdapter...
                //
            
                RmSuspendTask(pTask, PEND_CloseAdapter, pSR);
                RM_ASSERT_NOLOCKS(pSR);

                epvcCloseAdapter(
                    &Status,
                    NdisAdapterHandle,
                    pSR
                    );
            
                if (Status != NDIS_STATUS_PENDING)
                {
                    EpvcCloseAdapterComplete(
                            (NDIS_HANDLE)pAdapter,
                            Status
                            );
                }
                Status = NDIS_STATUS_PENDING;
                    

            }

            break;
        }
        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CloseAdapter:
                {

                    //
                    // The close adapter operation is complete. Free the the
                    // adapter and if there is an unbind context, notify NDIS
                    // of unbind completion.
                    //
                    
                    ASSERTEX(pAdapter->bind.BindingHandle == NULL, pAdapter);

        
                    Status = (NDIS_STATUS) UserParam;
        
                    // Status of the completed operation can't itself be pending!
                    //
                    ASSERT(Status != NDIS_STATUS_PENDING);
                }
                break;

            }
        }
        break;


        case  RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // Clear the secondary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcClearSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_DEACTIVATED, pSR);
            UNLOCKOBJ(pAdapter, pSR);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)



    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    TRACE ( TL_T, TM_Pt, ("<==epvcTaskDeactivateAdapter Status %x", Status) );

    return Status;
}




VOID
EpvcCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisCloseAdapter
    that had pended has completed. The task that called NdisCloseAdapter
    would have suspended itself, so we simply resume it now.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an EPVC_ADAPTER structure.
    Status                  - Status of CloseAdapter

Return Value:

    None

--*/
{
    ENTER("CloseAdapterComplete", 0xe23bfba7)
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>CloseAdapterComplete");
    TRACE (TL_T, TM_Pt, ("== EpvcCloseAdapterComplete"));

    LOCKOBJ (pAdapter, &sr);

    AdapterSetFlag (pAdapter,EPVC_AD_INFO_AD_CLOSED);

    UNLOCKOBJ (pAdapter, &sr);
    // We expect a nonzero task here (UNbind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);

    TIMESTAMP("<==CloseAdapterComplete");

    RM_ASSERT_CLEAR(&sr)
    EXIT()
}




NDIS_STATUS
epvcReadAdapterConfiguration(
    PEPVC_ADAPTER       pAdapter,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This function can only be called from the BindAdapter function

Arguments:
    pAdapter - Underlying adapter whose configuration is being read/
    pSR - Stack Record

Return Value:

    None
++*/
{
    NDIS_HANDLE                     AdaptersConfigHandle = NULL;
    NDIS_HANDLE                     MiniportListConfigHandle = NULL;
    NDIS_STRING                     MiniportListKeyName;
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;

    ENTER("ReadAdapterConfiguration", 0x83c48ad8)

    TRACE(TL_T, TM_Pt, ("==> epvcReadAdapterConfigurationpAdapter %p", pAdapter));
    

    do
    {
        //
        // Start off by opening the config section and reading our instance which we want
        // to export for this binding
        //
        epvcOpenProtocolConfiguration(&NdisStatus,
                                     &AdaptersConfigHandle ,
                                     &pAdapter->bind.EpvcConfigName,
                                     pSR);

        if (NDIS_STATUS_SUCCESS != NdisStatus )
        {
            AdaptersConfigHandle = NULL;
            TRACE_BREAK(TM_Pt, ("epvcOpenProtocolConfiguration failed " ) );
        }


        //
        // this should get us to the protocol\paramters\adapters\guid section in the registry
        //

        //
        //  Open the Elan List configuration key.
        //
        NdisInitUnicodeString(&MiniportListKeyName, c_szIMMiniportList);

        epvcOpenConfigurationKeyByName(
                &NdisStatus,
                AdaptersConfigHandle ,
                &MiniportListKeyName,
                &MiniportListConfigHandle,
                pSR);

        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            MiniportListConfigHandle = NULL;
            NdisStatus = NDIS_STATUS_FAILURE;
        
            TRACE_BREAK(TM_Pt, ("NdisOpenConfigurationKeyByName failed " ) );
        }

        

        //
        // Allocate and initialize all IM miniport instances that are present 
        // in the registry under this adapter
        //
        (VOID)epvcReadIntermediateMiniportConfiguration( pAdapter, 
                                                MiniportListConfigHandle,
                                                pSR);
         


    } while (FALSE);


    if (MiniportListConfigHandle!= NULL)
    {
        NdisCloseConfiguration(MiniportListConfigHandle);
        MiniportListConfigHandle = NULL;
    }
    
    if (AdaptersConfigHandle  != NULL)
    {
        NdisCloseConfiguration(AdaptersConfigHandle );
        AdaptersConfigHandle = NULL;
    }

    if (STATUS_NO_MORE_ENTRIES == NdisStatus )
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    TRACE(TL_T, TM_Pt, ("<== epvcReadAdapterConfiguration Status %x", NdisStatus));
    EXIT()
    return NdisStatus;
    


}


NDIS_STATUS
epvcReadIntermediateMiniportConfiguration(
    IN PEPVC_ADAPTER pAdapter,
    IN NDIS_HANDLE MiniportListConfigHandle,
    IN PRM_STACK_RECORD pSR
    )
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    ENTER ("ReadMiniportConfiguration", 0xb974a6fa)
    
    TRACE(TL_T, TM_Pt, ("==> epvcReadIntermediateMiniportConfiguration pAdapter %p", pAdapter));
    

    {   
        NDIS_HANDLE MiniportConfigHandle;
        NDIS_STRING MiniportKeyName;
        PEPVC_I_MINIPORT pMiniport = NULL;
    
        UINT Index = 0;
        //
        //  Iterate thru the configured Miniport
        //
        for (Index = 0;
            ;           // Stop only on error or no more Elans
             Index++)
        {
            EPVC_I_MINIPORT_PARAMS Params;
            //
            //  Open the "next" Miniport key
            //
            epvcOpenConfigurationKeyByIndex(
                        &NdisStatus,
                        MiniportListConfigHandle,
                        Index,
                        &MiniportKeyName,
                        &MiniportConfigHandle,
                        pSR
                        );

            if (NDIS_STATUS_SUCCESS != NdisStatus)
            {
                MiniportConfigHandle = NULL;
                
            }
            
            //
            //  If NULL handle, assume no more Miniports.
            //
            if (MiniportConfigHandle == NULL)
            {
                break;
            }

            //
            //  Creating this Miniport
            //
            epvcInstantiateMiniport (pAdapter, 
                                     MiniportConfigHandle,
                                     pSR);

            
            
            NdisCloseConfiguration(MiniportConfigHandle);
            MiniportConfigHandle = NULL;
        }   


        //
        //  Close config handles
        //      
        if (NULL != MiniportConfigHandle)
        {
            NdisCloseConfiguration(MiniportConfigHandle);
            MiniportConfigHandle = NULL;
        }

    }

    if (STATUS_NO_MORE_ENTRIES == NdisStatus )
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }


    TRACE(TL_T, TM_Pt, ("<== epvcReadIntermediateMiniportConfiguration NdisStatus %x", NdisStatus));
    EXIT()
    return NdisStatus;
}
        






VOID
EpvcUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
)
/*++

Routine Description:

    This routine is called by NDIS when it wants us to unbind
    from an adapter. Or, this may be called from within our Unload
    handler. We undo the sequence of operations we performed
    in our BindAdapter handler.

Arguments:

    pStatus                 - Place to return status of this operation
    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMEPVC Adapter structure.
    UnbindContext           - This is NULL if this routine is called from
                              within our Unload handler. Otherwise (i.e.
                              NDIS called us), we retain this for later use
                              when calling NdisCompleteUnbindAdapter.

Return Value:

    None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
    ENTER("UnbindAdapter", 0x3f25396e)
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnbindAdapter");

    TRACE ( TL_T, TM_Pt, ("==>UnbindAdapter ProtocolBindingContext %x\n", ProtocolBindingContext) );

    //
    // Get adapter lock and tmpref it.
    //
    LOCKOBJ(pAdapter, &sr);
    RmTmpReferenceObject(&pAdapter->Hdr, &sr);
    

    do
    {
        NDIS_STATUS Status;
        PRM_TASK    pTask;

        // Allocate task to  complete the unbind.
        //
        Status = epvcAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    epvcTaskShutdownAdapter,        // pfnHandler,
                    0,                          // Timeout,
                    "Task: Shutdown Adapter",   // szDescription
                    &pTask,
                    &sr
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the unbind.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by arpAllocateTask.
        //
        UNLOCKOBJ(pAdapter, &sr);

        ((PTASK_ADAPTERSHUTDOWN) pTask)->pUnbindContext = UnbindContext;
        RmStartTask(pTask, (UINT_PTR) UnbindContext, &sr);

        LOCKOBJ(pAdapter, &sr);
    
    } while(FALSE);

    UNLOCKOBJ(pAdapter, &sr);
    RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    *pStatus = NDIS_STATUS_PENDING;

    RM_ASSERT_CLEAR(&sr);
    TIMESTAMP("<==UnbindAdapter");
    EXIT()
}




NDIS_STATUS
epvcTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an ATMEPVC adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) RM_PARENT_OBJECT(pTask);
    TASK_ADAPTERSHUTDOWN *pMyTask = (TASK_ADAPTERSHUTDOWN*) pTask;
    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_DeactivateAdapterComplete,
        STAGE_End
    } Stage;

    ENTER("TaskShutdownAdapter", 0x3f25396e)

    TRACE (TL_T, TM_Pt, ("==>epvcTaskShutdownAdapter Code %x", Code));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;

            // Save away the UnbindContext (which we get as UserParam) in
            // the task's private context, for use later.
            //
            pMyTask->pUnbindContext = (NDIS_HANDLE) UserParam;

            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **
    }

    ASSERTEX(!PEND(Status), pTask);

    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            // We could get in this situation if someone does a
            // "net stop arp1394" while we're in the middle of initializing or
            // shutting down the adapter.
            //
            //
            TRACE (TL_V, TM_Pt, ("   epvcTaskShutdownAdapter STAGE_BecomePrimaryTask" ));

            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                epvcSetPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_DEINITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the deactivate adapter task.
            //
            {
                PRM_TASK pDeactivateTask;

                Status = epvcAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            epvcTaskDeactivateAdapter,      // pfnHandler,
                            0,                          // Timeout,
                            "Task: Deactivate Adapter(shutdown)",   // szDescription
                            &pDeactivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }
         break;

        case STAGE_DeactivateAdapterComplete:
        {
            TRACE (TL_V, TM_Pt,( "   epvcTaskShutdownAdapter STAGE_DeactivateAdapterComplete" ));

            // Nothing to do here -- we clean  up in STAGE_End.
            //
            break;
        }

        case STAGE_End:
        {
            TRACE (TL_V, TM_Pt, ("  epvcTaskShutdownAdapter STAGE_End" ));

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcClearPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_DEINITED, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            if(RM_IS_ZOMBIE(pAdapter))
            {
                TR_WARN(("END: pAdapter is already deallocated.\n"));
            }
            else
            {
                // Free the adapter.
                // (pAdapter will be allocated, but it will be in a "zombie" state).
                //
                RmDeinitializeGroup(&(pAdapter->MiniportsGroup), pSR);

                RmFreeObjectInGroup(
                    &EpvcGlobals.adapters.Group,
                    &(pAdapter->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );
            }
            // If there is an unbind-context, signal NDIS that the unbind is
            //  complete.
            //
            if (pMyTask->pUnbindContext)
            {
                TR_WARN(("END: Calling NdisCompleteUnbindAdapter. Status= 0x%lx\n",
                            Status));
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===Calling NdisCompleteUnbindAdapter");
                NdisCompleteUnbindAdapter(
                                pMyTask->pUnbindContext,
                                Status
                            );
            }

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}



VOID
epvcGetAdapterInfo(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PRM_STACK_RECORD            pSR,
    IN  PRM_TASK                    pTask               // OPTIONAL

    )
/*++

Routine Description:

    Query an adapter for hardware-specific information that we need:
        - burnt in hardware address (ESI part)
        - Max packet size
        - line rate

Arguments:

    pAdapter        - Pointer to EPVC adapter structure

Return Value:

    None

--*/
{
    NDIS_STATUS             Status  = NDIS_STATUS_FAILURE;
    EPVC_NDIS_REQUEST       Request;
    NDIS_MEDIA_STATE        MediaState=  NdisMediaStateDisconnected;

    do
    {
        //
        //  Initialize.
        //
        NdisZeroMemory(&pAdapter->info.MacAddress, sizeof(MAC_ADDRESS));
        pAdapter->info.MediaState = MediaState;
        pAdapter->info.MaxAAL5PacketSize   =  ATMEPVC_DEF_MAX_AAL5_PDU_SIZE;
        pAdapter->info.LinkSpeed.Outbound = pAdapter->info.LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;

        //
        //  MAC Address:
        //
        Status = epvcPrepareAndSendNdisRequest (pAdapter,
                                             &Request,
                                             NULL,              // OPTIONAL
                                             OID_ATM_HW_CURRENT_ADDRESS,
                                             (PVOID)(&pAdapter->info.MacAddress),
                                             sizeof (pAdapter->info.MacAddress),
                                             NdisRequestQueryInformation,
                                             NULL,  // No miniport
                                             FALSE, // No request was pended
                                             FALSE, // Pended Request info
                                             pSR);

        ASSERT (PEND(Status) == FALSE);

        if (FAIL(Status)== TRUE)
        {   
            //
            // Don't break .continue on
            //
            TRACE (TL_I, TM_Pt, ("Oid - Atm Hw Address failed %x", Status));

        }
        
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_ATM_MAX_AAL5_PACKET_SIZE,
                                            (PVOID)(&pAdapter->info.MaxAAL5PacketSize),
                                            sizeof(pAdapter->info.MaxAAL5PacketSize),
                                            NdisRequestQueryInformation,
                                             NULL,  // No miniport
                                             FALSE, // No request was pended
                                             FALSE, // Pended Request info
                                            pSR);
    
        if (FAIL(Status)== TRUE)
        {
            TRACE (TL_I, TM_Pt, ("Oid - Atm Max AAL5 Packet Size  failed %x", Status));
            
    
        }

        if (pAdapter->info.MaxAAL5PacketSize  > ATMEPVC_DEF_MAX_AAL5_PDU_SIZE)
        {
            pAdapter->info.MaxAAL5PacketSize   =  ATMEPVC_DEF_MAX_AAL5_PDU_SIZE;
        }

        //
        //  Link speed:
        //
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_GEN_CO_LINK_SPEED,
                                            &pAdapter->info.LinkSpeed,
                                            sizeof(pAdapter->info.LinkSpeed),
                                            NdisRequestQueryInformation,
                                            NULL,  // No miniport
                                            FALSE, // No request was pended
                                            FALSE, // Pended Request info
                                            pSR);

        TRACE (TL_V, TM_Mp, ("Outbound %x Inbound %x",
                             pAdapter->info.LinkSpeed.Outbound, 
                             pAdapter->info.LinkSpeed.Inbound));                                            
        
        
        if ((NDIS_STATUS_SUCCESS != Status) ||
            (0 == pAdapter->info.LinkSpeed.Inbound) ||
            (0 == pAdapter->info.LinkSpeed.Outbound))
        {
            TRACE (TL_I, TM_Pt, ( "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

            //
            //  Default and assume data rate for 155.52Mbps SONET
            //
            pAdapter->info.LinkSpeed.Outbound = pAdapter->info.LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;
        }

        //
        //  Link speed:
        //
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_GEN_MEDIA_CONNECT_STATUS,
                                            &MediaState,
                                            sizeof(MediaState),
                                            NdisRequestQueryInformation,
                                            NULL,  // No miniport
                                            FALSE, // No request was pended
                                            FALSE, // Pended Request info
                                            pSR);

        TRACE (TL_V, TM_Mp, ("MediaConnectivity %x ",MediaState));                                          
        
        
        if (NDIS_STATUS_SUCCESS != Status )
        {
            TRACE (TL_I, TM_Pt, ( "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

            //
            //  Default and assume data rate for 155.52Mbps SONET
            //
            MediaState = NdisMediaStateDisconnected;
        }

        pAdapter->info.MediaState  = MediaState ;
        
        TRACE( TL_V, TM_Pt,("GetAdapterInfo: Outbound Linkspeed %d", pAdapter->info.LinkSpeed.Outbound));
        TRACE( TL_V, TM_Pt,("GetAdapterInfo: Inbound  Linkspeed %d\n", pAdapter->info.LinkSpeed.Inbound));

    }while (FALSE);

                        
    return;
}



NDIS_STATUS
EpvcPtPNPHandler(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )

/*++
Routine Description:

    This is the Protocol PNP handlers. 
    All PNP Related OIDS(requests) are routed to this function
    
Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.
    pNetPnPEvent Pointer to a Net_PnP_Event

Return Value:

    NDIS_STATUS_SUCCESS: as we do not do much here

--*/
{
    ENTER("EpvcPtPnPHandler", 0xacded1ce)
    PEPVC_ADAPTER           pAdapter  =(PEPVC_ADAPTER)ProtocolBindingContext;
    NDIS_STATUS Status  = NDIS_STATUS_SUCCESS;
    RM_DECLARE_STACK_RECORD (SR);

    TRACE (TL_T, TM_Pt, ("==> EpvcPtPNPHandler Adapter %p, pNetPnpEvent %x", pAdapter, pNetPnPEvent));


    //
    // This will happen when all entities in the system need to be notified
    //

    switch(pNetPnPEvent->NetEvent)
    {

     case NetEventReconfigure :
        Status  = epvcPtNetEventReconfigure(pAdapter, pNetPnPEvent->Buffer, &SR);
        break;

     default :
        Status  = NDIS_STATUS_SUCCESS;
        break;
    }


    TRACE (TL_T, TM_Pt, ("<== EpvcPtPNPHandler Status %x", Status));
    RM_ASSERT_NOLOCKS(&SR)
    EXIT();
    return Status;
}

NDIS_STATUS
epvcPtNetEventReconfigure(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PVOID                   pBuffer,
    IN PRM_STACK_RECORD         pSR
    
    )
/*++
Routine Description:
    This is the function that will be called by the PNP handler 
    whenever a PNPNetEventReconfigure happens

    THis will happen if a new physical adapter has come in or the user
    has re-enabled a virtual miniport.

    To process:
    Iterate through all the adapter. If adapters are bound, then make sure that
    all of its miniport's are initialized.

    If not, then leave it and call NdisReenumerate to connect all our protocol
    instances with valid adapters

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    NDIS_STATUS_SUCCESS: as we do not do much here


--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    
    TRACE (TL_T, TM_Pt, ("==> epvcPtNetEventReconfigure Adapter %p, pBuffer %x", pAdapter, pBuffer));
    

    do
    {

        

        //
        // The notify object sets the REconfig buffer. 
        //
        if (pBuffer != NULL)
        {

            ASSERT (!"PnPBuffer != NULL - not implemented yet");
            break;
        }

        if (pAdapter == NULL)
        {
            //
            // Iterate through all the adapters and initialize
            // uninitialized miniports
            //
            
            epvcEnumerateObjectsInGroup ( &EpvcGlobals.adapters.Group,
                                          epvcReconfigureAdapter,
                                          pBuffer,
                                          pSR);


            
            //
            // Re-enumerate the protocol bindings, this will cause us to get
            // a BindAdapter on all our unbound adapters, and then we 
            // will InitDeviceInstance.
            // This is called when the protcol is not bound to the physical adapter
            //
            NdisReEnumerateProtocolBindings(EpvcGlobals.driver.ProtocolHandle);
            break;

        }

    
    } while (FALSE);

    Status = NDIS_STATUS_SUCCESS;


    TRACE (TL_T, TM_Pt, ("<== epvcPtNetEventReconfigure " ));

    return Status;
}


INT
epvcReconfigureAdapter(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++
Routine Description:

    When the Protocol's Reconfigure handler is called, this adapter will be in one 
    of two condtions - Its binding to the adapter below is open or the binding is 
    closed.

    if the blinding is closed, then the protocol will call NdisReEnumerate Bindings
    and this will restart the Binding  and re-instantiate the miniports.


Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    TRUE: so that iteration continues

--*/
{
    ENTER("epvcReconfigureAdapter", 0x2906a037)
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER )pHdr; 

    do
    {
        if (CHECK_AD_PRIMARY_STATE(pAdapter, EPVC_AD_PS_INITED)== FALSE)
        {
            //
            // no more work to be done on this adapter, 
            //
            break;        
        }

        //
        //  TODO: Go through the registry and initialize 
        //  all the IM miniports present
        //
        epvcReadAdapterConfiguration(pAdapter, pSR);
        //
        // Now go through all the miniports on this group and 
        // initialize them
        //
        epvcEnumerateObjectsInGroup ( &pAdapter->MiniportsGroup,
                                      epvcReconfigureMiniport,
                                      NULL,
                                      pSR);

 
    } while (FALSE);

    

    EXIT()

    return TRUE;
}




INT
epvcReconfigureMiniport (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++
Routine Description:

    This should check to see if the InitDev instance has been
    called on this miniport. IF not, then queue the task to 
    do it.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    TRUE: so that iteration continues

--*/
{
    ENTER( "epvcReconfigureMiniport" ,0xdd9ecb01)
    
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)pHdr;
    PTASK_AF            pTask = NULL;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;

    LOCKOBJ(pMiniport, pSR);

    //
    // If the device instance is not initialized (i.e it has been halted)
    // then this thread reinitializes the device instance
    //
    do
    {


        //
        // If the device is already Initialized then exit.
        //
        if (MiniportTestFlag (pMiniport, fMP_DevInstanceInitialized ) == TRUE)
        {
            break;
        }
        //
        // Allocate task to Initialize the Device Instance.
        //
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskStartIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Open address Family",    // szDescription
                    &((PRM_TASK)pTask),
                    pSR
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the Open Address Family.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by epvcAllocateTask.
        //
        UNLOCKOBJ(pMiniport, pSR);
        
        pTask->pAf= &pAdapter->af.AddressFamily ;
        pTask->Cause = TaskCause_ProtocolBind;
        RmStartTask((PRM_TASK)pTask, 0, pSR);

        LOCKOBJ(pMiniport, pSR);
    
    } while(FALSE);

    UNLOCKOBJ(pMiniport, pSR);
    EXIT()

    return TRUE;
}





VOID
epvcExtractSendCompleteInfo (
    OUT PEPVC_SEND_COMPLETE     pStruct,
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket 
    )
/*++

Routine Description:


Arguments:


Return Value:
    
--*/
{
    NDIS_HANDLE         PoolHandle = NULL;

    pStruct->pPacket = pPacket;


    PoolHandle = NdisGetPoolFromPacket(pPacket);

    if (PoolHandle != pMiniport->PktPool.Send.Handle)
    {
        //
        // We had passed down a packet belonging to the protocol above us.
        //

        pStruct->fUsedPktStack = TRUE;


    }
    else
    {
            pStruct->fUsedPktStack = FALSE;

    }

    epvcSendCompleteStats();

}

    

VOID
EpvcPtSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

The Vc Context is the miniport block, Use it to complete the send

Arguments:


Return Value:


--*/
{
    ENTER("EpvcPtSendComplete", 0x76beac72)
    PEPVC_I_MINIPORT        pMiniport =(PEPVC_I_MINIPORT)ProtocolVcContext;
    EPVC_SEND_COMPLETE      Struct;
    RM_DECLARE_STACK_RECORD (SR);
    

    TRACE (TL_T, TM_Send, ("EpvcPtSendComplete"));
    
    EPVC_ZEROSTRUCT (&Struct);
    
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) Packet)
    #define szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT "    send pkt 0x%p\n"

    do 
    {
        epvcExtractSendCompleteInfo (&Struct, pMiniport, Packet);

        //
        // If we are using the Packetstacking, then this packet is the
        // original packet
        //
        if (Struct.fUsedPktStack == TRUE)
        {
            BOOLEAN Remaining = FALSE;

            Struct.pOrigPkt = Packet;

            Struct.pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

            Struct.pContext =  (PEPVC_STACK_CONTEXT)(&Struct.pStack->IMReserved[0]) ;

        }
        else
        {
        
            Struct.pPktContext =(PEPVC_PKT_CONTEXT)(Packet->ProtocolReserved);

            Struct.pContext =  &Struct.pPktContext->Stack;

            Struct.pOrigPkt = Struct.pPktContext->pOriginalPacket;

            NdisIMCopySendCompletePerPacketInfo (Struct.pOrigPkt , Packet);
        }

        
        LOCKOBJ (pMiniport, &SR);

        epvcDerefSendPkt(Packet, &pMiniport->Hdr);

        UNLOCKOBJ (pMiniport, &SR);


        //
        // Make sure the original packet is in the same state 
        // when it was sent to the miniport
        //
        Struct.pPacket = Packet;

        //
        // Remove the ethernet padding - if necessary
        //
        epvcRemoveEthernetPad (pMiniport, Packet);

        //
        // Remove the ethernet padding buffer - if necessary
        //
        epvcRemoveEthernetTail (pMiniport, Packet, Struct.pPktContext);

        //
        // Remove the LLC Snap headers - if necessary
        //
        epvcRemoveExtraNdisBuffers (pMiniport, &Struct);
        


        if (Struct.fUsedPktStack == FALSE)
        {
            epvcDprFreePacket(Packet,
                              &pMiniport->PktPool.Send);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pMiniport->count.FramesXmitOk ++;
        }
        
    } while (FALSE);

    //
    // Complete the send
    //
    epvcMSendComplete(pMiniport,
                      Struct.pOrigPkt,
                      Status);

    EXIT();
    RM_ASSERT_CLEAR(&SR);

    return;                          
}


VOID
epvcRemoveExtraNdisBuffers (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_SEND_COMPLETE pStruct
    )
/*++

Routine Description:

    In the case of IP encapsulation, there will be an extra ndis buffer
    that has been made the head of the Ndispacket. Remove it and 
    reattach the old one.

Arguments:


Return Value:


--*/

{

    PNDIS_BUFFER    pOldHead = NULL;
    UINT            OldHeadLength = 0;
    
    do
    {
        //
        // if an LLC header was used, remove it and free the MDL
        // use the packet that was completed
        // 

        if (pMiniport->fAddLLCHeader== TRUE)
        {
            PNDIS_PACKET_PRIVATE    pPrivate = &pStruct->pPacket->Private;      
            PNDIS_BUFFER            pHead = pPrivate->Head;     

            //
            // Move the head of the packet past the LLC Header
            //
            pPrivate->Head = pHead->Next;

            //
            // Free the Head MDL
            //
            epvcFreeBuffer(pHead);
                    
        }

        //
        // if we are not doing IP encapsulation, then we are done.
        //
        if (pMiniport->fDoIpEncapsulation== FALSE)
        {
            break;
        }


        
        //
        // if the Ethernet header was stripped off, then put it back
        //
        pOldHead =  pStruct->pContext->ipv4Send.pOldHeadNdisBuffer;

        ASSERT (pOldHead != NULL);

        OldHeadLength = NdisBufferLength(pOldHead);
            
        //
        // two ways this can happen 
        // 1) if the ethernet header was in a seperate MDL
        //        then simply take the old Head and make it the Head again
        //
        if (OldHeadLength == sizeof (EPVC_ETH_HEADER))
        {
            PNDIS_PACKET_PRIVATE    pPrivate = &pStruct->pPacket->Private;      
            PNDIS_BUFFER            pHead = pPrivate->Head;     

            ASSERT (pOldHead->Next == pPrivate->Head);


            pOldHead->Next = pPrivate->Head;
            
            pPrivate->Head = pOldHead ;


                
            break;  // we are done

        }


        //
        // 2nd Way 2) A new MDL had been allocated which just points to the 
        // IP part of the header.
        //  For this - free the Head in Packet, Take the old Head and put it back 
        //  in the packet as the New Head
        //

        if (OldHeadLength > sizeof (EPVC_ETH_HEADER))
        {
            
            PNDIS_PACKET_PRIVATE pPrivate = &pStruct->pPacket->Private;     

            ASSERT (pOldHead->Next == pPrivate->Head->Next);

            if (pPrivate->Head == pPrivate->Tail)
            {
                pPrivate->Tail = pOldHead;  
                pOldHead->Next = NULL;
            }
            else
            {
                pOldHead->Next = pPrivate->Head->Next;
            }
            
            epvcFreeBuffer(pPrivate->Head );
            
            pPrivate->Head = pOldHead;

            
            break;  // we are done

        }       
    } while (FALSE);        
}



VOID
EpvcPtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of
    received packets.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER)ProtocolBindingContext;

    return;

}


INT
epvcMiniportDoUnbind(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
{

/*++

Routine Description:

    This is called from the Protocl Unbind code path

    This should halt the current miniport and close the address 
    family. This is all done in the CloseMiniportTask, so we 
    will simply start the task and wait for it to complete

Arguments:


Return Value:

    TRUE - as we want to iterate to the very end

--*/

    ENTER ("epvcMiniportDoUnbind", 0x26dc5d35)

    PRM_TASK            pRmTask = NULL;
    PTASK_AF            pAfTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT)pHdr;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) pMiniport->Hdr.pParentObject;
    BOOLEAN             fHaltNotCompleted = FALSE;
    
    TRACE (TL_T, TM_Mp, ("==>epvcMiniportDoUnbind pMiniport %x", pMiniport) );

    do
    {
        
        if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == TRUE)
        {

            //
            // allocate a close Miniport Task 
            //

            Status = epvcAllocateTask(
                        &pMiniport->Hdr,            // pParentObject,
                        epvcTaskCloseIMiniport, // pfnHandler,
                        0,                          // Timeout,
                        "Task: CloseIMiniport- Unbind", // szDescription
                        &pRmTask,
                        pSR
                        );
                        
            if (Status != NDIS_STATUS_SUCCESS)
            {
                ASSERT (Status == NDIS_STATUS_SUCCESS);
                pAfTask = NULL;
                break;
            }

            pAfTask= (PTASK_AF)pRmTask ;
            
            pAfTask->Cause = TaskCause_ProtocolUnbind;

            //
            // Reference the task so it is around until our Wait for completion
            // is complete
            //
            RmTmpReferenceObject (&pAfTask->TskHdr.Hdr, pSR);



            epvcInitializeEvent (&pAfTask->CompleteEvent);

            RmStartTask (pRmTask, 0, pSR);


            epvcWaitEvent(&pAfTask->CompleteEvent, WAIT_INFINITE);

            RmTmpDereferenceObject (&pAfTask->TskHdr.Hdr, pSR);

        
        }       

        LOCKOBJ (pMiniport, pSR);
            
        //
        // If the Halt has not already completed then, we should wait for it
        //
        if (MiniportTestFlag(pMiniport ,fMP_MiniportInitialized) == TRUE )
        {
            //
            // prepare to wait for halt
            //
            epvcResetEvent (&pMiniport->pnp.HaltCompleteEvent);

            //
            // Set the flag to mark it as waiting for halt 
            //
            MiniportSetFlag (pMiniport, fMP_WaitingForHalt);

            fHaltNotCompleted = TRUE;
        }

        UNLOCKOBJ (pMiniport, pSR);

        if (fHaltNotCompleted == TRUE)
        {
            BOOLEAN bWaitSuccessful;

            
            bWaitSuccessful = epvcWaitEvent (&pMiniport->pnp.HaltCompleteEvent,WAIT_INFINITE);                                    


            if (bWaitSuccessful == FALSE)
            {
                ASSERT (bWaitSuccessful == TRUE);
            }
            

        }
            
        //
        // Free the miniport object because there should be no more tasks on it.
        // this Thread will have either caused the Miniport to Halt and waited 
        // for its completion (above) or the miniport will already have been halted
        //

        TRACE ( TL_I, TM_Mp, ("epvcMiniportDoUnbind  Freeing miniport %p", pMiniport) );

        RmFreeObjectInGroup (&pAdapter->MiniportsGroup,&pMiniport->Hdr, NULL, pSR);
        
    } while (FALSE);
        
    TRACE (TL_T, TM_Mp, ("<==epvcMiniportDoUnbind pMiniport %x", pMiniport) );
    EXIT();
    return TRUE;
}



NDIS_STATUS
epvcProcessOidCloseAf(
    PEPVC_I_MINIPORT pMiniport,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This is called from the Af Close Request Code path

    This simply starts a worktitem to close the Af, if the 
    Af is open

Arguments:


Return Value:


--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_AF pTaskAf = NULL;
    PEPVC_WORK_ITEM  pCloseAfWorkItem = NULL;

    TRACE (TL_T, TM_Mp, ("==> epvcProcessOidCloseAf pMiniport %x", pMiniport) );

    
    
    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //

    do
    {
        if (MiniportTestFlag( pMiniport, fMP_AddressFamilyOpened) == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        Status = epvcAllocateMemoryWithTag (&pCloseAfWorkItem, 
                                            sizeof(*pCloseAfWorkItem) , 
                                            TAG_WORKITEM);            
        if (Status != NDIS_STATUS_SUCCESS)
        {
            pCloseAfWorkItem= NULL;
            break;                
        }

        epvcMiniportQueueWorkItem (pCloseAfWorkItem,
                                   pMiniport,
                                   epvcOidCloseAfWorkItem,
                                   Status, // Ignored
                                   pSR
                                   );
                                   
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // free locally allocated memory
        //
        if (pCloseAfWorkItem != NULL)            
        {
            epvcFreeMemory(pCloseAfWorkItem, sizeof (*pCloseAfWorkItem), 0);
        }
    }
    

    return Status;
}





VOID
epvcOidCloseAfWorkItem(
    IN PRM_OBJECT_HEADER pObj,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This is called from the Af Close Request Code path

    This simply starts a worktitem to close the Af, if the 
    Af is open

Arguments:


Return Value:


--*/
{
    
    PTASK_AF pTaskAf = NULL;
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)pObj;
    
    TRACE (TL_T, TM_Mp, ("==> epvcProcessOidCloseAf pMiniport %x", pMiniport) );

    Status = NDIS_STATUS_FAILURE;
    
    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //

    do
    {
        if (MiniportTestFlag( pMiniport, fMP_AddressFamilyOpened) == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


    
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskCloseIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: CloseIMiniport - OID CloseAf",   // szDescription
                    &(PRM_TASK)pTaskAf,
                    pSR
                    );

        if (FAIL(Status))
        {
            pTaskAf = NULL;
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }


        pTaskAf->Cause = TaskCause_AfCloseRequest;

        pTaskAf->pRequest = NULL;

        
        RmStartTask ((PRM_TASK)pTaskAf , 0, pSR);

    

    } while (FALSE);


    

    return ;
}


UINT
EpvcCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
    ENTER ("EpvcPtCoReceive", 0x1bfc168e)
    PEPVC_ADAPTER           pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolVcContext;

    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    EPVC_RCV_STRUCT         RcvStruct;

    
    RM_DECLARE_STACK_RECORD (SR);

    TRACE (TL_T, TM_Pt, ("==> EpvcCoReceive Pkt %x", Packet));

    EPVC_ZEROSTRUCT (&RcvStruct);
    
    TRACE (TL_T, TM_Recv, ("EpvcPtCoReceive pAd %p, pMp %p, pPkt %p", pAdapter, pMiniport, Packet));

    do
    {
        if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Status = epvcGetRecvPkt (&RcvStruct,pMiniport, Packet);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (RcvStruct.pNewPacket != NULL);      

        Status = epvcStripHeaderFromNewPacket (&RcvStruct, pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        Status = epvcAddEthHeaderToNewPacket (&RcvStruct, pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Now indicate the packet up
        //
        NDIS_SET_PACKET_HEADER_SIZE(RcvStruct.pNewPacket,
                                    sizeof (EPVC_ETH_HEADER)) ; 

        ASSERT (NDIS_GET_PACKET_HEADER_SIZE(RcvStruct.pNewPacket) == 14); 

        //
        // Force protocols above to make a copy if they want to hang
        // on to data in this packet. This is because we are in our
        // Receive handler (not ReceivePacket) and we can't return a
        // ref count from here.
        //

        RcvStruct.OldPacketStatus = NDIS_GET_PACKET_STATUS(Packet);

        
        NDIS_SET_PACKET_STATUS(RcvStruct.pNewPacket, 
                               RcvStruct.OldPacketStatus );

        epvcDumpPkt (RcvStruct.pNewPacket);

        epvcValidatePacket (RcvStruct.pNewPacket);

        NdisMIndicateReceivePacket(pMiniport->ndis.MiniportAdapterHandle, 
                                   &RcvStruct.pNewPacket, 
                                   1);


                
        
    } while (FALSE);

    //
    // Check if we had indicated up the packet with NDIS_STATUS_RESOURCES
    // NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket) for this since
    // it might have changed! Use the value saved in the local variable.
    //
    if (RcvStruct.OldPacketStatus == NDIS_STATUS_RESOURCES)
    {
        epvcProcessReturnPacket (pMiniport, RcvStruct.pNewPacket,NULL, &SR); 
        Status = NDIS_STATUS_RESOURCES;

    }
    else if (Status != NDIS_STATUS_SUCCESS)
    {
        epvcProcessReturnPacket (pMiniport, RcvStruct.pNewPacket,NULL, &SR); 
        Status = NDIS_STATUS_RESOURCES;
        pMiniport->count.RecvDropped ++;
    }
        


    RM_ASSERT_CLEAR(&SR);

    TRACE (TL_T, TM_Pt, ("<== EpvcCoReceive Pkt %x", Packet))

    return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    
}



NDIS_STATUS
epvcGetRecvPkt (
    IN PEPVC_RCV_STRUCT pRcvStruct,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    TRACE (TL_T, TM_Pt, ("==>epvcGetRecvPkt "))

    do
    {
        if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        epvcValidatePacket (Packet);            

        //
        // See if the packet is large enough
        //
        if (epvcIsPacketLengthAcceptable (Packet, pMiniport)== FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
    
        pRcvStruct->pPacket = Packet;
        //
        // Check if we can reuse the same packet for indicating up.
        //
        pRcvStruct->pStack = NdisIMGetCurrentPacketStack(Packet, &pRcvStruct->fRemaining);

        if (pRcvStruct->fRemaining)
        {
            //
            // We can reuse "Packet".
            //
            // NOTE: if we needed to keep per-packet information in packets
            // indicated up, we can use pStack->IMReserved[].
            //

            pRcvStruct->pNewPacket = Packet;

            pRcvStruct->fUsedPktStacks = TRUE;

            pRcvStruct->pPktContext = (PEPVC_PKT_CONTEXT)pRcvStruct->pStack;

            // Zero out our context
            NdisZeroMemory (&pRcvStruct->pPktContext->Stack, sizeof(EPVC_STACK_CONTEXT));

            NDIS_SET_PACKET_HEADER_SIZE(Packet, 14);

            Status = NDIS_STATUS_SUCCESS; // We are done
            break;
        }
        
    
        //
        // Get a packet off the pool and indicate that up
        //
        epvcDprAllocatePacket(&Status,
                                  &pRcvStruct->pNewPacket,
                                  &pMiniport->PktPool.Recv);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            pRcvStruct->pNewPacket = NULL;
            break;
        }

        {
            //
            // set up the new packet to look exactly like the old one
            //

            PNDIS_PACKET MyPacket = pRcvStruct->pNewPacket; 

            MyPacket->Private.Head = Packet->Private.Head;
            MyPacket->Private.Tail = Packet->Private.Tail;

            //
            // Set the standard Ethernet header size
            //
            NDIS_SET_PACKET_HEADER_SIZE(MyPacket, 14);

            //
            // Copy packet flags.
            //
            NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

            //
            // Set up the context pointers
            //
            pRcvStruct->pPktContext = (PEPVC_PKT_CONTEXT)&MyPacket->MiniportReservedEx[0];
            NdisZeroMemory (pRcvStruct->pPktContext, sizeof (*pRcvStruct->pPktContext));
            pRcvStruct->pPktContext->pOriginalPacket = Packet;

        }

        Status = NDIS_STATUS_SUCCESS; // We are done
    

    } while (FALSE);

    TRACE (TL_T, TM_Pt, ("<==epvcGetRecvPkt Old %p, New %p ", 
                              pRcvStruct->pPacket, pRcvStruct->pNewPacket))

    return Status;
}



NDIS_STATUS
epvcStripLLCHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
{
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET    pPacket = NULL;
    PNDIS_BUFFER    pHead, pNewHead =NULL;
    ULONG           CurLength = 0;
    PUCHAR          pCurVa = NULL;
    ULONG           LlcHeaderLength = 0;
    BOOLEAN         fIsCorrectHeader ;
    do
    {

        if (pMiniport->fAddLLCHeader == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


        pPacket = pRcvStruct->pNewPacket;
        pHead = pPacket->Private.Head;      
        LlcHeaderLength = pMiniport->LlcHeaderLength;
        //
        // Move the Head past the LLC Header
        //
        ASSERT (NdisBufferLength (pHead) > LlcHeaderLength);

        //
        // Adjust the length and start VA of the MDL
        //
        CurLength = NdisBufferLength(pHead); 

        pCurVa = NdisBufferVirtualAddress(pHead);


        //
        // Check arguments
        //
        if (pCurVa == NULL)
        {
            break;
        }

        if (CurLength <= LlcHeaderLength)
        {
            break;
        }

        //
        // Compare and make sure that it is the right header
        //
        
        fIsCorrectHeader = NdisEqualMemory (pCurVa , 
                                           pMiniport->pLllcHeader, 
                                           pMiniport->LlcHeaderLength) ;

        
        // If the IsCorrectheader is still false, then there is more to do
        if (fIsCorrectHeader == FALSE)
        {
            break;
        }


        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            //
            // In the case of IPEncap + LLC Header, the function
            // which adds the Mac Header will strip the LLC Header
            //
            Status= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Strip the LLC Header Length
        //
        CurLength -= pMiniport->LlcHeaderLength;
        pCurVa += pMiniport->LlcHeaderLength;

        epvcAllocateBuffer(&Status ,
                            &pNewHead, 
                            NULL,
                            pCurVa, 
                            CurLength
                            );
                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewHead = NULL;
            break;
        }

        //
        // Set up the Packet context
        //

        pPacket->Private.ValidCounts= FALSE;

        pRcvStruct->pPktContext->Stack.EthLLC.pOldHead = pHead;
        pRcvStruct->pPktContext->Stack.EthLLC.pOldTail = pPacket->Private.Tail;
        
        //
        // Set the New Ndis buffer in the Packet
        //
        pNewHead->Next = pHead->Next;

        pPacket->Private.Head = pNewHead;

        if (pPacket->Private.Tail == pHead)
        {
               //
               // Update the Tail of the packet as well
               //
               pPacket->Private.Tail = pNewHead; 
        }



        Status = NDIS_STATUS_SUCCESS;
    

    } while (FALSE);


    return Status;
}




NDIS_STATUS
epvcAddEthHeaderToNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
{
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE    ;
    PNDIS_BUFFER        pOldHead = NULL;
    PNDIS_BUFFER        pNewBuffer = NULL;
    PNDIS_PACKET        pNewPacket = NULL;
    PUCHAR              pStartOfValidData = NULL;
    PUCHAR              pCurrOffset = NULL;

    PEPVC_IP_RCV_BUFFER pIpBuffer = NULL; 
    
    extern UCHAR LLCSnapIpv4[8] ;


    
    
    TRACE (TL_T, TM_Pt, ("==>epvcAddEthHeaderToNewPacket pRcvStruct %p ", pRcvStruct))
    do
    {
        if (pMiniport->fDoIpEncapsulation == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Copy the data into a new buffer. The start of the data is adjusted 
        // to account for the LLC header and ethernet header
        //
        pNewPacket = pRcvStruct->pNewPacket;
        
        pOldHead = pNewPacket->Private.Head;
        
        pStartOfValidData  = NdisBufferVirtualAddress (pOldHead );

        if (pStartOfValidData  == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pMiniport->fAddLLCHeader == TRUE)
        {
            pStartOfValidData += sizeof (LLCSnapIpv4);
            pRcvStruct->fLLCHeader = TRUE;
        }

        pRcvStruct->pStartOfValidData = pStartOfValidData ;
        

        //
        // Get a locally allocated buffer to copy the packet into
        //
        

        pIpBuffer = epvcGetLookasideBuffer (&pMiniport->rcv.LookasideList);

        if (pIpBuffer  == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        //
        // Start of the data
        //
        pCurrOffset  = pRcvStruct->pLocalMemory = (PUCHAR)(&pIpBuffer->u.Pkt.Eth);
        


        //
        // First copy the Ethernet Header into the LocalMemory
        //
        NdisMoveMemory (pCurrOffset , 
                        &pMiniport->RcvEnetHeader, 
                        sizeof(pMiniport->RcvEnetHeader));          

        pCurrOffset += sizeof(pMiniport->RcvEnetHeader);

        pRcvStruct->BytesCopied += sizeof(pMiniport->RcvEnetHeader);


        //
        // Now copy the NdisBufferChain into the Locally allocated memory
        //
        Status = epvcCopyNdisBufferChain (pRcvStruct,
                                          pOldHead ,
                                          pCurrOffset
                                          );

        //
        // We have to add an Ethernet Header for this packet.
        //

        
        
        epvcAllocateBuffer (&Status,
                            &pNewBuffer,
                            NULL,
                            pRcvStruct->pLocalMemory,
                            pRcvStruct->BytesCopied);

                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewBuffer = NULL;
            ASSERTAndBreak(Status == NDIS_STATUS_SUCCESS);
            break;
        }

        //
        // Make the new Ndis Buffer the head
        //
        {
            PNDIS_PACKET_PRIVATE pPrivate = &pRcvStruct->pNewPacket->Private;

            //
            // Save the head and tail of the old packet
            //
            pIpBuffer->pOldHead = pPrivate->Head ;  
            pIpBuffer->pOldTail = pPrivate->Tail ;  


            //
            // Now set up the new packet
            //
            pNewBuffer->Next = NULL;
            pPrivate->Head = pNewBuffer;
            pPrivate->Tail = pNewBuffer; 


            pPrivate->ValidCounts= FALSE;

            pRcvStruct->pPktContext->Stack.ipv4Recv.pIpBuffer = pIpBuffer;

        }
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);    


    if (Status == NDIS_STATUS_SUCCESS)
    {
        pRcvStruct->pNewBuffer = pNewBuffer;
        pRcvStruct->pIpBuffer = pIpBuffer;
    }
    else
    {
        pRcvStruct->pNewBuffer  = NULL;
        pRcvStruct->pIpBuffer = NULL;
        if (pIpBuffer != NULL)
        {
            epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        }
    }

    TRACE (TL_T, TM_Pt, ("<==epvcAddEthHeaderToNewPacket Status %x ", Status))
    
    return Status;
}



NDIS_STATUS
epvcCopyNdisBufferChain (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PNDIS_BUFFER pInBuffer,
    IN PUCHAR pCurrOffset 
    )
{

    //
    //  This function copies the data the belongs to the 
    //  pInMdl chain to the local Buffer. 
    //  BufferLength is used for validation purposes only
    //  Fragmentation and insertion of headers will take place here
    //


    UINT BufferLength = MAX_ETHERNET_FRAME- sizeof (EPVC_ETH_HEADER);
    
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    UINT        LocalBufferIndex = 0;       // Used as an index to the LocalBuffer, used for validation

    UINT        MdlLength = 0;              

    PUCHAR      MdlAddress = NULL;
    
    PNDIS_BUFFER pCurrBuffer = pInBuffer;

    PUCHAR      pLocalBuffer = pCurrOffset;

    extern UCHAR LLCSnapIpv4[8];

    //
    // Use the pStartOfValidData for the first MDL
    //

    MdlLength = NdisBufferLength(pCurrBuffer);
    MdlAddress= NdisBufferVirtualAddress(pCurrBuffer);

    //
    // Adjust for the LLC Header if any
    //

    
    if (pRcvStruct->fLLCHeader == TRUE)
    {
        //
        // We have an LLC encapsulation
        // 
        MdlLength -= sizeof (LLCSnapIpv4);
        ASSERT (pRcvStruct->pStartOfValidData - MdlAddress == sizeof (LLCSnapIpv4));
        
        MdlAddress = pRcvStruct->pStartOfValidData;
    }


    //
    //  Copy the first buffer Data to local memory.
    //


    NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer),
                MdlAddress,
                MdlLength);

    LocalBufferIndex += MdlLength;

    pCurrBuffer = pCurrBuffer->Next;

    //
    // now walk through the ndis buffer chain
    //
    
    while (pCurrBuffer!= NULL)
    {
    
    
        MdlLength = NdisBufferLength(pCurrBuffer);
        MdlAddress= NdisBufferVirtualAddress(pCurrBuffer);


        if (MdlLength != 0)
        {
            if (MdlAddress == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }

            if ( LocalBufferIndex + MdlLength > BufferLength)
            {

                ASSERT(LocalBufferIndex + MdlLength <= BufferLength);

                NdisStatus = NDIS_STATUS_BUFFER_TOO_SHORT;

                break;
            }

            //
            //  Copy the Data to local memory.
            //


            NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer+LocalBufferIndex),
                        MdlAddress,
                        MdlLength);

            LocalBufferIndex += MdlLength;
        }

        pCurrBuffer = pCurrBuffer->Next;

    } 
    pRcvStruct->BytesCopied += LocalBufferIndex;

    return NdisStatus;

}



VOID
epvcValidatePacket (
    IN PNDIS_PACKET pPacket
    )
/*++

Routine Description:

    Takes a packet and makes sure that the MDL chain is valid
Arguments:


Return Value:

--*/
{
    ULONG TotalLength = 0;
    //ASSERT (pPacket->Private.Tail->Next == NULL);


    if (pPacket->Private.Head != pPacket->Private.Tail)
    {
        PNDIS_BUFFER pTemp = pPacket->Private.Head;
        
        while (pTemp != NULL)
        {
            TotalLength += NdisBufferLength(pTemp);
            pTemp = pTemp->Next;
        }

    }
    else
    {
        TotalLength += NdisBufferLength(pPacket->Private.Head);
        
    }

    if (TotalLength != pPacket->Private.TotalLength)
    {
        ASSERT (pPacket->Private.ValidCounts == FALSE);
    }
}   


BOOLEAN
epvcIsPacketLengthAcceptable (
    IN PNDIS_PACKET Packet, 
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Validates the packet length of an incoming packet
Arguments:


Return Value:

--*/

{   
    UINT PktLength;
    BOOLEAN fValid = FALSE;

    epvcQueryPacket (Packet, NULL, NULL, NULL, &PktLength);

    fValid =  (PktLength >= pMiniport->MinAcceptablePkt);

    if (fValid == TRUE)
    {
        fValid = (PktLength <= pMiniport->MaxAcceptablePkt);
    }
    
    return fValid;
    

}



NDIS_STATUS
epvcStripHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    In the pure bridged (ethernet) encapsulation, all ethernet packets 
    are preceeded by a 0x00, 0x00 header. Check if it is present 

    in the ethernet/llc case, verify the LLC header is correct.

    In both cases, allocate a new Ndis Buffer which does not include the
    2684 headers.

    Store the old head and tail into the NdisPacket and send it up to the
    

    
Arguments:


Return Value:

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET    pPacket = NULL;
    PNDIS_BUFFER    pHead, pNewHead =NULL;
    ULONG           CurLength = 0;
    PUCHAR          pCurVa = NULL;
    ULONG           EpvcHeaderLength = 0;
    PUCHAR          pEpvcHeader = NULL;
    BOOLEAN         fIsCorrectHeader ;
    do
    {
        //
        // we are not interested in the pure ipv4 case
        //
        if (pMiniport->Encap == IPV4_ENCAP_TYPE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


        pPacket = pRcvStruct->pNewPacket;
        pHead = pPacket->Private.Head;      

        switch (pMiniport->Encap)
        {
            case IPV4_LLC_SNAP_ENCAP_TYPE:
            case ETHERNET_LLC_SNAP_ENCAP_TYPE:
            {
                EpvcHeaderLength = pMiniport->LlcHeaderLength; 
                pEpvcHeader = pMiniport->pLllcHeader;
                break;
            }
            case ETHERNET_ENCAP_TYPE:
            {
                EpvcHeaderLength = ETHERNET_PADDING_LENGTH; 
                pEpvcHeader = &gPaddingBytes[0];
                break;
            }                        
                
            case IPV4_ENCAP_TYPE:
            default:
            {
                //
                // pMiniport->Encap is only allowed four values,
                // therefore we should never hit the defualt case.
                //
                Status = NDIS_STATUS_FAILURE; 
                ASSERT (Status != NDIS_STATUS_FAILURE);
                return Status;

            }
            
        }

        //
        // Adjust the length and start VA of the MDL
        //
        CurLength = NdisBufferLength(pHead); 

        pCurVa = NdisBufferVirtualAddress(pHead);


        //
        // Check arguments
        //
        if (pCurVa == NULL)
        {
            break;
        }

        if (CurLength <= EpvcHeaderLength )
        {
            //
            // we do not handle the case where the header is longer than
            // the first mdl
            //
            ASSERT (CurLength > EpvcHeaderLength );
            break;
        }

        //
        // Compare and make sure that it is the right header
        //
        
        fIsCorrectHeader = NdisEqualMemory (pCurVa , 
                                           pEpvcHeader, 
                                           EpvcHeaderLength) ;

        
        // If the IsCorrectheader is still false, then there is more to do
        if (fIsCorrectHeader == FALSE)
        {
            break;
        }


        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            //
            // In the case of IPEncap + LLC Header, the function
            // which adds the Mac Header will strip the LLC Header
            //
            Status= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Strip the LLC Header Length
        //
        CurLength -= EpvcHeaderLength;
        pCurVa += EpvcHeaderLength;

        epvcAllocateBuffer(&Status ,
                            &pNewHead, 
                            NULL,
                            pCurVa, 
                            CurLength
                            );
                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewHead = NULL;
            break;
        }

        //
        // Set up the Packet context
        //

        pPacket->Private.ValidCounts= FALSE;

        pRcvStruct->pPktContext->Stack.EthLLC.pOldHead = pHead;
        pRcvStruct->pPktContext->Stack.EthLLC.pOldTail = pPacket->Private.Tail;
        
        //
        // Set the New Ndis buffer in the Packet
        //
        pNewHead->Next = pHead->Next;

        pPacket->Private.Head = pNewHead;

        if (pPacket->Private.Tail == pHead)
        {
               //
               // Update the Tail of the packet as well
               //
               pPacket->Private.Tail = pNewHead; 
        }

        Status = NDIS_STATUS_SUCCESS;
    

    } while (FALSE);


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\priv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    priv.h

Abstract:

    Common header file for ATM Epvc IM miniport.

Author:

    ADube 03/23/2000
    
Environment:


Revision History:

 
--*/


#ifndef _PRIV_H

#define _PRIV_H


//advance declaration
typedef struct _EPVC_I_MINIPORT     _ADAPT, ADAPT, *PADAPT;
typedef struct _EPVC_I_MINIPORT     EPVC_I_MINIPORT,    *PEPVC_I_MINIPORT   ;
typedef struct _EPVC_GLOBALS        EPVC_GLOBALS,   *PEPVC_GLOBALS;
typedef struct _EPVC_ARP_PACKET     EPVC_ARP_PACKET, *PEPVC_ARP_PACKET      ;
typedef struct _EPVC_NDIS_REQUEST   EPVC_NDIS_REQUEST, *PEPVC_NDIS_REQUEST;
        



extern LIST_ENTRY g_ProtocolList;
//
// Temp declarations
//
extern NDIS_HANDLE ProtHandle, DriverHandle;




extern EPVC_GLOBALS EpvcGlobals;



//--------------------------------------------------------------------------------
//                                                                              //
//  Driver Functions - Prototypes                                               //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

extern
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

extern
VOID
EpvcUnload(
    IN  PDRIVER_OBJECT              pDriverObject
    ); 

//--------------------------------------------------------------------------------
//                                                                              //
//  Protocol Functions - Prototypes                                             //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


extern
VOID
EpvcResetComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );


extern
VOID
PtStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

extern
VOID
PtStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );


extern
VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

extern
NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

extern
VOID
PtReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

extern
INT
PtReceivePacket(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet
    );

    
VOID
EpvcUnload(
    IN  PDRIVER_OBJECT          DriverObject
    );




extern
VOID
EpvcAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );
   
VOID
epvcOidCloseAfWorkItem(
    IN PRM_OBJECT_HEADER pObj,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    );

    

//--------------------------------------------------------------------------------
//                                                                              //
//  Miniport Functions - Prototypes                                             //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    );


NDIS_STATUS
MPReset(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );








#define DBGPRINT(Fmt)                                       \
    {                                                       \
        DbgPrint("*** %s (%d) *** ", __FILE__, __LINE__);   \
        DbgPrint (Fmt);                                     \
    }

#define NUM_PKTS_IN_POOL    256




extern  NDIS_PHYSICAL_ADDRESS           HighestAcceptableMax;
extern  NDIS_HANDLE                     ProtHandle, DriverHandle;
extern  NDIS_MEDIUM                     MediumArray[1];

//
// Custom Macros to be used by the passthru driver 
//
/*
bool
IsIMDeviceStateOn(
   PADAPT 
   )

*/
#define IsIMDeviceStateOn(_pP)      ((_pP)->MPDeviceState == NdisDeviceStateD0 && (_pP)->PTDeviceState == NdisDeviceStateD0 ) 

//--------------------------------------------------------------------------------
//                                                                              //
//  New stuff for atmepvc starts here                                           //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------
//                                                                                 //
//   Arp Packet Parsing structs                                                    //
//                                                                                 //
//-----------------------------------------------------------------------------------

//
// Len of an Ethernet Header.
//
#define ARP_802_ADDR_LENGTH 6

//
// HwType should be one of the two below.
//
#define ARP_HW_ENET     1
#define ARP_HW_802      6

//
// Ip Address
//
typedef ULONG        IP_ADDR;

#define ARP_ETYPE_ARP   0x806
#define ARP_REQUEST     1
#define ARP_RESPONSE    2
#define ARP_HW_ENET     1
#define IP_PROT_TYPE   0x800

//
// As these data structs are used to parse data off the wire.
// make sure it is packed at 1
//
#pragma pack( push, enter_include1, 1 )

//
//  The following object is a convenient way to 
//  store and access an IEEE 48-bit MAC address.
//
typedef struct _MAC_ADDRESS
{
    UCHAR   Byte[ARP_802_ADDR_LENGTH];
} MAC_ADDRESS, *PMAC_ADDRESS;


//
// Structure of the Ethernet Arp packet. The 14 byte ethernet header is not here.
//

typedef struct _EPVC_ETH_HEADER{

    MAC_ADDRESS         eh_daddr;
    MAC_ADDRESS         eh_saddr;
    USHORT              eh_type;

} EPVC_ETH_HEADER, *PEPVC_ETH_HEADER;


// Structure of an ARP header.
typedef struct _EPVC_ARP_BODY {
    USHORT      hw;                      // Hardware address space. = 00 01
    USHORT      pro;                     // Protocol address space. = 08 00
    UCHAR       hlen;                    // Hardware address length. = 06
    UCHAR       plen;                    // Protocol address length.  = 04
    USHORT      opcode;                  // Opcode.
    MAC_ADDRESS SenderHwAddr; // Source HW address.
    IP_ADDR     SenderIpAddr;                  // Source protocol address.
    MAC_ADDRESS DestHwAddr; // Destination HW address.
    IP_ADDR     DestIPAddr;                  // Destination protocol address.

} EPVC_ARP_BODY, *PEPVC_ARP_BODY;




//
// Complete Arp Packet
//

typedef struct _EPVC_ARP_PACKET
{
    //
    // The first fourteen bytes
    // 
    EPVC_ETH_HEADER Header;

    //
    // The body of the Arp packets
    //
    EPVC_ARP_BODY   Body;

} EPVC_ARP_PACKET, *PEPVC_ARP_PACKET;



//
// This is the struct that is allocated 
// by the Rcv Code path if The Rcv packet 
// is to be copied into a local buffer
//

typedef struct _EPVC_IP_RCV_BUFFER
{

    //
    // The Old Head in the Packet that was indicated
    // to our Rcv Handler
    // 
    PNDIS_BUFFER pOldHead;
    
    //
    // The Old Tail in the Packet that was indiacated to 
    // our Rcv Hnadler
    //

    PNDIS_BUFFER pOldTail;

    //
    // The actual Ethernet packet is copied into the 
    // memory below
    //
    union 
    {
        UCHAR Byte[MAX_ETHERNET_FRAME    ];

        struct
        {
            EPVC_ETH_HEADER Eth;

            //
            // the ip portion of the packet begins here.
            //
            UCHAR ip[1];



        }Pkt;

    } u;


} EPVC_IP_RCV_BUFFER, *PEPVC_IP_RCV_BUFFER;


//* IP Header format.
typedef struct IPHeader {
    UCHAR       iph_verlen;             // Version and length.
    UCHAR       iph_tos;                // Type of service.
    USHORT      iph_length;             // Total length of datagram.
    USHORT      iph_id;                 // Identification.
    USHORT      iph_offset;             // Flags and fragment offset.
    UCHAR       iph_ttl;                // Time to live.
    UCHAR       iph_protocol;           // Protocol.
    USHORT      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
} IPHeader;



//
// Restore the Pack value to the original
//

#pragma pack( pop, enter_include1 )



//
// The structure all the info required to process 
// an arp.
//

typedef struct _EPVC_ARP_CONTEXT
{

    //
    // Data about the Ndis Packet
    //
    BOOLEAN                 fIsThisAnArp ;
    BOOLEAN                 Pad[3];
    PNDIS_BUFFER            pFirstBuffer ;


    //
    // Data about the Current Ndis Buffer
    //
    UINT BufferLength ;


    //
    // Virtual Addresses'. Pointers to 
    // the Header and the Body of the 
    // Arp Pkt
    //
    PEPVC_ARP_PACKET pArpPkt;
    PEPVC_ETH_HEADER pEthHeader ;
    PEPVC_ARP_BODY   pBody;

}EPVC_ARP_CONTEXT, *PEPVC_ARP_CONTEXT;


//
// This is stored in the Packet Stack and should be of the 
// size of 2 Ulong_Ptrs
//
typedef union _EPVC_STACK_CONTEXT
{

    
    
    struct
    {
        //
        // 1st containing the Buffer 
        //
        PNDIS_BUFFER            pOldHeadNdisBuffer;

    } ipv4Send;

    struct
    {
        PEPVC_IP_RCV_BUFFER     pIpBuffer;
    
    } ipv4Recv;

    struct
    {
        //
        // Head and tail of the original packet . Used in recv
        //
        PNDIS_BUFFER pOldHead;
        PNDIS_BUFFER pOldTail;

    }EthLLC;

    struct
    {
        //
        // Keep track of the last NDIS buffer in original
        // chain of buffers in a sent packet, when we pad
        // the end of a runt packet.
        //
        PNDIS_BUFFER            pOldLastNdisBuffer;

    }EthernetSend;

} EPVC_STACK_CONTEXT, *PEPVC_STACK_CONTEXT;


//
// Protocol reserved part of the packet, only in case the 
// packet is allocated by us
//

typedef struct _EPVC_PKT_CONTEXT
{
    //
    // Contains the miniport and the old ndis buffer
    //
    EPVC_STACK_CONTEXT Stack;

    //
    // Original packet which is being repackaged
    //
    PNDIS_PACKET pOriginalPacket;

}EPVC_PKT_CONTEXT, *PEPVC_PKT_CONTEXT;



//
// This a struct that tracks a send packets
// as it is sent down to physical miniport
//

typedef struct _EPVC_SEND_STRUCT 
{

    //
    // Old Ndis PAcket
    //
    PNDIS_PACKET pOldPacket;

    //
    // New Ndis Packet
    //
    PNDIS_PACKET pNewPacket;

    PNDIS_PACKET_STACK pPktStack;

    //
    // Are we using the Packet Stack
    //
    BOOLEAN fUsingStacks;

    //
    // is this an arp packet
    //
    BOOLEAN fIsThisAnArp;

    BOOLEAN fNonUnicastPacket; 

    BOOLEAN fNotIPv4Pkt;
    
    //
    // Old Packet's first NdisBuffer (Head)
    //
    PNDIS_BUFFER pHeadOldNdisBuffer;


    //
    // Context to be set up in the packet
    //
    EPVC_PKT_CONTEXT Context;

    //
    // EpvcMiniport
    //
    PEPVC_I_MINIPORT        pMiniport;

} EPVC_SEND_STRUCT , *PEPVC_SEND_STRUCT ;


typedef struct _EPVC_SEND_COMPLETE
{
    PNDIS_PACKET_STACK      pStack;

    PNDIS_PACKET            pOrigPkt;

    PNDIS_PACKET            pPacket;

    PEPVC_PKT_CONTEXT       pPktContext;

    BOOLEAN                 fUsedPktStack ;

    PEPVC_STACK_CONTEXT     pContext;

} EPVC_SEND_COMPLETE, *PEPVC_SEND_COMPLETE;


typedef struct _EPVC_RCV_STRUCT
{

    //
    // pPacket that was indicated to us
    //
    PNDIS_PACKET            pPacket;

    //
    // Packet that was allocated by us
    //
    PNDIS_PACKET            pNewPacket;

    //
    // Packet STack, if stacks were used
    //
    PNDIS_PACKET_STACK      pStack;


    //
    // This points to the  context for the 
    // Rcv Indication 
    //
    PEPVC_PKT_CONTEXT       pPktContext;
    
    //
    // Tells me if stacks were used
    //
    BOOLEAN                 fUsedPktStacks;

    //
    // Tels me if a stack still  remains 
    //
    BOOLEAN                 fRemaining;

    //
    // Was an LLC header a part of the indicated packet
    //
    BOOLEAN                 fLLCHeader;

    //
    // Old Packet Status
    //
    NDIS_STATUS             OldPacketStatus;

    //
    // pNew Buffer that is allocated
    // 
    PNDIS_BUFFER            pNewBuffer;


    //
    // Start of valid data within the old packet
    //
    PUCHAR                  pStartOfValidData   ;

    //
    // Number of bytes that were copied
    //
    ULONG                   BytesCopied;

    //
    // Contains some ndis buffers and the memory
    // where packets will be copied into
    //
    PEPVC_IP_RCV_BUFFER     pIpBuffer;

    //
    // Local Memory where the rcvd packet 
    // is copied into . - a part of ip buffer
    //
    PUCHAR                  pLocalMemory;

    
} EPVC_RCV_STRUCT, *PEPVC_RCV_STRUCT;


//--------------------------------------------------------------------------------
//                                                                              //
//  Structures used by the Protocol and miniport                                //
//  These need to declared before the Miniprot and the Protocol Blocks          //
//                                                                              //
//--------------------------------------------------------------------------------

typedef VOID (*REQUEST_COMPLETION)(PEPVC_NDIS_REQUEST, NDIS_STATUS);


// This structure is used when calling NdisRequest.
//
typedef struct _EPVC_NDIS_REQUEST
{
    NDIS_REQUEST        Request;            // The NDIS request structure.
    NDIS_EVENT          Event;              // Event to signal when done.
    NDIS_STATUS         Status;             // Status of completed request.
    REQUEST_COMPLETION  pFunc;          // Completion function
    BOOLEAN             fPendedRequest ; // Set to true if a pended request caused this request
    BOOLEAN             fSet;           // Was the orig. request a query
    USHORT              Pad;
    PEPVC_I_MINIPORT    pMiniport; 
    
} EPVC_NDIS_REQUEST, *PEPVC_NDIS_REQUEST;



//------------------------------------------------------------------------------//
//  Structures used to wrap Ndis Wrapper structures                             //
//                                                                              //
//------------------------------------------------------------------------------//


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _EPVC_PACKET_POOL
{
    ULONG AllocatedPackets;

    NDIS_HANDLE Handle;


} EPVC_PACKET_POOL, *PEPVC_PACKET_POOL;



//
// The structure that defines the lookaside list used by this miniport
//
typedef struct _EPVC_NPAGED_LOOKASIDE_LIST 
{
    //
    // The lookaside list structure
    //
    NPAGED_LOOKASIDE_LIST   List;   

    //
    // The size of an individual buffer
    //

    
    ULONG Size;

    //
    // Outstanding Fragments - Interlocked access only
    //
    ULONG OutstandingPackets;

    //
    // Verifies if this lookaside list has been allocated
    //

    BOOLEAN bIsAllocated;

    UCHAR Pad[3];
    
} EPVC_NPAGED_LOOKASIDE_LIST , *PEPVC_NPAGED_LOOKASIDE_LIST ;

typedef 
VOID    
(*PEVPC_WORK_ITEM_FUNC)(
    PRM_OBJECT_HEADER, 
    NDIS_STATUS,
    PRM_STACK_RECORD 
    );


typedef union _EPVC_WORK_ITEM_CONTEXT
{
    struct
    {
        //
        // Oid for the request
        //
        NDIS_OID Oid;

        //
        // Currently the only data is 1 Dword long
        //
        ULONG Data;

    }Request;

}EPVC_WORK_ITEM_CONTEXT, *PEPVC_WORK_ITEM_CONTEXT;


typedef struct _EPVC_WORK_ITEM 
{
    //
    // Normal NdisWork Item - Do not move from 
    // the top of this structure
    //
    NDIS_WORK_ITEM WorkItem;

    //
    // Miniport or Adapter to whom this adapter belongs
    //
    PRM_OBJECT_HEADER pParentObj;

    PEVPC_WORK_ITEM_FUNC pFn;
    //
    // Status of async task that was completed
    //
    NDIS_STATUS ReturnStatus;


} EPVC_WORK_ITEM, *PEPVC_WORK_ITEM;


//--------------------------------------------------------------------------------
//                                                                              //
//  Tasks used in the Atmepvc driver                                            //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

typedef enum _TASK_CAUSE
{
    TaskCause_Invalid=0,

    TaskCause_NdisRequest,

    TaskCause_MediaConnect,

    TaskCause_MediaDisconnect,

    TaskCause_MiniportHalt,

    TaskCause_AfNotify,

    TaskCause_ProtocolUnbind,

    TaskCause_AfCloseRequest,

    TaskCause_ProtocolBind,

    TaskCause_IncomingClose

} TASK_CAUSE, *PTASK_CAUSE;

typedef struct
{
    RM_TASK                     TskHdr;

    // Used to save the true return status (typically a failure status,
    // which we don't want to forget during async cleanup).
    //
    NDIS_STATUS ReturnStatus;

} TASK_ADAPTERINIT, *PTASK_ADAPTERINIT;

typedef struct
{
    RM_TASK             TskHdr;

} TASK_ADAPTERACTIVATE, *PTASK_ADAPTERACTIVATE;

typedef struct
{
    RM_TASK             TskHdr;
    NDIS_HANDLE         pUnbindContext;
    TASK_CAUSE          Cause;

} TASK_ADAPTERSHUTDOWN, *PTASK_ADAPTERSHUTDOWN;

typedef struct
{
    RM_TASK                 TskHdr;
    NDIS_STATUS             ReturnStatus;
    TASK_CAUSE              Cause;
    PCO_ADDRESS_FAMILY      pAf;
    union
    {
        PNDIS_REQUEST           pRequest;
        NDIS_EVENT              CompleteEvent;
    };
    
} TASK_AF, *PTASK_AF;

typedef struct _TASK_VC
{
    RM_TASK             TskHdr;
    NDIS_STATUS         ReturnStatus;
    ULONG               FailureState;
    TASK_CAUSE          Cause;
    ULONG               PacketFilter;

} TASK_VC, *PTASK_VC;


typedef struct _TASK_HALT
{
    RM_TASK             TskHdr;
    NDIS_EVENT          CompleteEvent;  

}TASK_HALT, *PTASK_HALT;



typedef struct _TASK_ARP
{
    //
    // Rm Task associated with the Arp
    //
    RM_TASK                     TskHdr;

        
    //
    // Back pointer to the miniport
    //
    PEPVC_I_MINIPORT            pMiniport;

    //
    // Timer to fire - this does the receive indication
    //
    NDIS_MINIPORT_TIMER         Timer;

    //
    // Arp Packet that will be indicated up. 
    //
    EPVC_ARP_PACKET             Pkt;

    //
    // NdisPacket to wrap the ArpPkt
    //
    PNDIS_PACKET                pNdisPacket; 

} TASK_ARP, *PTASK_ARP;



//
// EPVC_TASK is the union of all tasks structures used in atmepvc.
// arpAllocateTask allocates memory of sizeof(EPVC_TASK), which is 
// guaranteed to be large enough to hold any task.
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_ADAPTERINIT        AdapterInit;
    TASK_ADAPTERACTIVATE    AdapterActivate;
    TASK_ADAPTERSHUTDOWN    AdapterShutdown;
    TASK_AF                 OpenAf;
    TASK_HALT               MiniportHalt;
    TASK_ARP                Arp;
    
}  EPVC_TASK, *PEPVC_TASK;




//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Adapter block.                                                         //
//  There is one epvc_adapter per underlying adapter                            //
//                                                                              //
//--------------------------------------------------------------------------------

//
// PRIMARY_STATE flags (in Hdr.State)
//
//  PRIMARY_STATE is the primary state of the adapter.
//

#define EPVC_AD_PS_MASK                 0x00f
#define EPVC_AD_PS_DEINITED             0x000
#define EPVC_AD_PS_INITED               0x001
#define EPVC_AD_PS_FAILEDINIT           0x002
#define EPVC_AD_PS_INITING              0x003
#define EPVC_AD_PS_REINITING            0x004
#define EPVC_AD_PS_DEINITING            0x005

#define SET_AD_PRIMARY_STATE(_pAD, _IfState) \
            RM_SET_STATE(_pAD, EPVC_AD_PS_MASK, _IfState)

#define CHECK_AD_PRIMARY_STATE(_pAD, _IfState) \
            RM_CHECK_STATE(_pAD, EPVC_AD_PS_MASK, _IfState)

#define GET_AD_PRIMARY_STATE(_pAD) \
            RM_GET_STATE(_pAD, EPVC_AD_PS_MASK)


//
// ACTIVE_STATE flags (in Hdr.State)
//
// ACTIVE_STATE is a secondary state of the adapter.
// Primary state takes precedence over secondary sate. For example,
// the interface is REINITING and ACTIVE, one should not actively use the
// interface.
//
// NOTE: When the primary state is INITED, the secondary state WILL be
// ACTIVATED. It is thus usually only necessary to look at the primary state.
//

#define EPVC_AD_AS_MASK                 0x0f0
#define EPVC_AD_AS_DEACTIVATED          0x000
#define EPVC_AD_AS_ACTIVATED            0x010
#define EPVC_AD_AS_FAILEDACTIVATE       0x020
#define EPVC_AD_AS_DEACTIVATING         0x030
#define EPVC_AD_AS_ACTIVATING           0x040

#define SET_AD_ACTIVE_STATE(_pAD, _IfState) \
            RM_SET_STATE(_pAD, EPVC_AD_AS_MASK, _IfState)

#define CHECK_AD_ACTIVE_STATE(_pAD, _IfState) \
            RM_CHECK_STATE(_pAD, EPVC_AD_AS_MASK, _IfState)

#define GET_AD_ACTIVE_STATE(_pAD) \
            RM_GET_STATE(_pAD, EPVC_AD_AS_MASK)

#define EPVC_AD_INFO_AD_CLOSED          0X10000000


typedef struct _EPVC_ADAPTER
{


    RM_OBJECT_HEADER            Hdr;            // RM Object header
    RM_LOCK                     Lock;           // RM Lock 

    //
    // Flags
    //
    ULONG Flags;
    //
    // List of instantiated protocols
    //
    
    LIST_ENTRY PtListEntry;

    //
    // NDIS bind info.
    //
    struct
    {
        
        // Init/Deinit/Reinit task
        //
        PRM_TASK pPrimaryTask;

        // Activate/Deactivate task
        //
        PRM_TASK pSecondaryTask;
        //
        // Device Name of the adapter
        //
        NDIS_STRING                 DeviceName;


        NDIS_HANDLE                 BindingHandle;  // To the lower miniport

        //
        // Bind Context - used in async completion of 
        // the bind adapter routine
        //
        NDIS_HANDLE                 BindContext;

        //
        // pConfig Name - Only to be used in the context of the Bind adapter call.
        //
        PNDIS_STRING                pEpvcConfigName;

        //
        // Copy of the ConfigName
        //
        NDIS_STRING                EpvcConfigName;
    
        //
        // Device Name - Name of the underlying adapter
        //
        PNDIS_STRING            pAdapterDeviceName;

        
    } bind;


    struct 
    {
        CO_ADDRESS_FAMILY      AddressFamily;
        
    }af;

    struct
    {
        //
        // Mac Address of the underlying adapter
        //
        MAC_ADDRESS             MacAddress;
        //
        // Max AAL5 PAcket Size - used in determining Lookahead
        //
        ULONG                   MaxAAL5PacketSize;

        //
        // Link speed of the ATM adapter. We'll use the same link speed
        // for the miniport
        //
        NDIS_CO_LINK_SPEED      LinkSpeed;

        //
        // Number of miniports instatiated by this adapter
        //
        ULONG                   NumberOfMiniports;

        //
        // MEdia State // default disconnected
        //

        NDIS_MEDIA_STATE        MediaState;

    }info;
    //  Group containing local ip addresses, of type  EPVC_I_MINIPORT
    //
    RM_GROUP MiniportsGroup;

}EPVC_ADAPTER, *PEPVC_ADAPTER;


//------------------------------------------------------------------------------------
//                                                                                  //
// The Epvc ADapter Params is used as a constructor for the adapter block           //  
// It contains all the parameters that are to be initialized in the adapter block   //
//                                                                                  //
//------------------------------------------------------------------------------------


typedef struct _EPVC_ADAPTER_PARAMS
{

    PNDIS_STRING pDeviceName;
    PNDIS_STRING pEpvcConfigName;
    NDIS_HANDLE BindContext;

}EPVC_ADAPTER_PARAMS, *PEPVC_ADAPTER_PARAMS;


//------------------------------------------------------------------------------------
//                                                                                  //
// The Epvc Miniports Params is used as a constructor for the miniport block        //  
// It contains all the parameters that are to be initialized in the miniport block  //
//                                                                                  //
//------------------------------------------------------------------------------------


typedef struct _EPVC_I_MINIPORT_PARAMS
{

    PNDIS_STRING        pDeviceName;
    PEPVC_ADAPTER       pAdapter;
    ULONG               CurLookAhead ;
    ULONG               NumberOfMiniports;
    NDIS_CO_LINK_SPEED  LinkSpeed;
    MAC_ADDRESS         MacAddress;
    NDIS_MEDIA_STATE    MediaState;
        

}EPVC_I_MINIPORT_PARAMS, *PEPVC_I_MINIPORT_PARAMS       ;


//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Miniport block.                                                        //
//                                                                              //
//  There is one Miniport structure for each address family                     //
//                                                                              //
//--------------------------------------------------------------------------------

#define fMP_AddressFamilyOpened             0x00000001
#define fMP_DevInstanceInitialized          0x00000010
#define fMP_MiniportInitialized             0x00000020
#define fMP_MiniportCancelInstance      0x00000080
#define fMP_MiniportVcSetup             0x00000100
#define fMP_MakeCallSucceeded           0x00000200
#define fMP_WaitingForHalt              0x00000400


//
// Informational flags
//
#define fMP_InfoClosingCall             0x10000000
#define fMP_InfoCallClosed              0x20000000
#define fMP_InfoMakingCall              0x40000000
#define fMP_InfoHalting                 0x80000000
#define fMP_InfoAfClosed                0x01000000

typedef struct _EPVC_I_MINIPORT
{
    RM_OBJECT_HEADER            Hdr;            // RM Object header
    RM_LOCK                     Lock;           // RM Lock 

    PEPVC_ADAPTER pAdapter;
    struct 
    {
        //
        // Flags of the address family
        //
        ULONG AfFlags;

        //
        // Af Handle
        //
        NDIS_HANDLE AfHandle;

        //
        // Open/Close Miniport Task 
        //
        PTASK_AF  pAfTask;

        //
        // Close Address Family Workitem
        // 
        EPVC_WORK_ITEM CloseAfWorkItem;

        //
        // CloseAF RequestTask
        //
        PTASK_AF pCloseAfTask;



    }af;

    struct 
    {   
        //
        // Task used in creating/deleting Vcs and Open/Close Make Calls
        //
        PTASK_VC pTaskVc;           

        //
        // Vc Handle
        //
        NDIS_HANDLE VcHandle;
        
        //
        // Close Address Family Workitem
        // 
        NDIS_WORK_ITEM PacketFilterWorkItem;

        //
        // New filter
        //
        ULONG NewFilter;

        //
        // Work item for CloseCall and Delete VC
        //
        EPVC_WORK_ITEM CallVcWorkItem;
    } vc;

    struct 
    {

        //
        // Device Name 
        //
        NDIS_STRING     DeviceName;

        //
        // Ndis' context
        //
        NDIS_HANDLE MiniportAdapterHandle;

        //
        // Lookahead size
        //
        ULONG CurLookAhead;
    }ndis;

    struct 
    {
        //
        // Task to Halt the miniport
        //
        PTASK_HALT pTaskHalt;

        //
        // Task to Init the miniport
        //
        PTASK_HALT pTaskInit;

        //
        // Halt Complete Event
        //
        NDIS_EVENT HaltCompleteEvent;

        //
        // DeInitialize Event used to wait for
        // InitializeHandler to compelte in 
        // the CancelDevInst code path
        //
        NDIS_EVENT DeInitEvent;


        

    } pnp;

    //
    // Information used to keep state in the miniport
    //
    struct
    {

        //
        // Current Packet filter on this miniport instance
        //
        ULONG               PacketFilter;


        //
        // Media State - Connected or disconnected
        //
        NDIS_MEDIA_STATE    MediaState;

        //
        // Mac Address of the miniport
        //
        MAC_ADDRESS         MacAddressEth;

        //
        // Fake Mac Address used in IP encapsulation
        //
        MAC_ADDRESS         MacAddressDummy;

        //
        // Mac Address destination  - used in indicating packets
        //
        MAC_ADDRESS         MacAddressDest;


        //
        // Size of the header that will be attached to packets that are sent out
        // by the miniport
        //
        ULONG               MaxHeaderLength;

        //
        // # of this miniport
        //
        ULONG               NumberOfMiniports;

        //
        // Lookahead length
        //
        ULONG               CurLookAhead;

        //
        // Muticast Info
        //
        MAC_ADDRESS         McastAddrs[MCAST_LIST_SIZE];    

        //
        // Number of MCast addresses present
        //
        ULONG               McastAddrCount; 

        //
        // Link Speed of the ATM adapter. We'll use it for our speed as well
        //

        ULONG               LinkSpeed;
        

        //
        // Indicating Receives
        //
        BOOLEAN             IndicateRcvComplete;
        
    }info;

    //
    // Mac Address of the miniport
    //
    MAC_ADDRESS         MacAddressEth;

    //
    // Ethernet Header for incoming packets
    //
    EPVC_ETH_HEADER     RcvEnetHeader;

    //
    // LLC Header, address and length 
    //
    PUCHAR              pLllcHeader;

    ULONG               LlcHeaderLength;

    // Minimum length of an incoming packet
    //
    ULONG               MinAcceptablePkt;

    // Maximum length of an incoming packet
    //
    ULONG               MaxAcceptablePkt;

    struct 
    {
        ULONG vpi;

        ULONG vci;

    
        ULONG MaxPacketSize;

        USHORT Gap;
        
    } config;

    ULONG Encap;

    BOOLEAN fAddLLCHeader;

    BOOLEAN fDoIpEncapsulation;



    struct 
    {
        ULONG FramesXmitOk;

        ULONG FramesRecvOk;

        ULONG RecvDropped;


    }count;

    struct
    {
        //
        // Send and Recv Packet Pools
        //
        EPVC_PACKET_POOL            Send;
        
        EPVC_PACKET_POOL            Recv;
    
    } PktPool;


    struct 
    {
        EPVC_NPAGED_LOOKASIDE_LIST LookasideList;

        PTASK_ARP                   pTask;

    } arps;


    struct 
    {
        EPVC_NPAGED_LOOKASIDE_LIST LookasideList;

    } rcv;

    // This maintains miniport-wide information relevant to the send path.
    //
    struct
    {
        // Lock used exclusively for sending.
        // Protects the following:
        //      ??? this->sendinfo.listPktsWaitingForHeaders
        //      ??? this->sendinfo.NumSendPacketsWaiting
        //      pLocalIp->sendinfo
        //      pDest->sendinfo
        //
        //
        RM_LOCK     Lock;

        // List of send packets waiting for header buffers to become available.
        //
        LIST_ENTRY  listPktsWaitingForHeaders;

        // Length of the above list
        //
        UINT        NumSendPacketsWaiting;

    } sendinfo;

#if 0 
    //
    // Temporary stuff
    // 
    NDIS_HANDLE                 SendPacketPoolHandle;
    NDIS_HANDLE                 RecvPacketPoolHandle;
    NDIS_STATUS                 Status;         // Open Status
    NDIS_EVENT                  Event;          // Used by bind/halt for Open/Close Adapter synch.
    NDIS_MEDIUM                 Medium;
    NDIS_REQUEST                Request;        // This is used to wrap a request coming down
                                                // to us. This exploits the fact that requests
                                                // are serialized down to us.
    PULONG                      BytesNeeded;
    PULONG                      BytesReadOrWritten;
    BOOLEAN                     IndicateRcvComplete;
    
    BOOLEAN                     OutstandingRequests;    //True - if a request has been passed to the miniport below the IM protocol 
    BOOLEAN                     QueuedRequest;          //True - if a request is queued with the IM miniport and needs to be either
                                                        // failed or sent to the miniport below the IM Protocol

    BOOLEAN                     StandingBy;             // True - When the miniport or protocol is transitioning from a D0 to Standby (>D0) State
                                                        // False - At all other times, - Flag is cleared after a transition to D0

    NDIS_DEVICE_POWER_STATE     MPDeviceState;          // Miniport's Device State 
    NDIS_DEVICE_POWER_STATE     PTDeviceState;          // Protocol's Device State 

    BOOLEAN                     isSecondary;            // Set if miniport is secondary of a bundle
    NDIS_STRING                 BundleUniString;        // Strores the bundleid
    PADAPT                      pPrimaryAdapt;          // Pointer to the primary
    PADAPT                      pSecondaryAdapt;        // Pointer to Secondary's structure
    KSPIN_LOCK                  SpinLock;               // Spin Lock to protect the global list
    PADAPT                      Next;
#endif

}EPVC_I_MINIPORT, *PEPVC_I_MINIPORT;




//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Global Block.                                                          //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


typedef struct _EPVC_GLOBALS
{

    RM_OBJECT_HEADER            Hdr;

    RM_LOCK                     Lock;

    // Driver global state
    //
    struct
    {
        // Handle to Driver Object for ATMEPVC
        //
        PVOID                   pDriverObject;
    
        // Handle to the single device object representing this driver.
        //
        PVOID pDeviceObject;

        //
        // Registry path 
        //
        PUNICODE_STRING         pRegistryPath;

        //
        // Wrapper Handle
        //
        NDIS_HANDLE             WrapperHandle;      

        //
        // Protocol Handle 
        //

        NDIS_HANDLE             ProtocolHandle;

        //
        // Driver Handle
        //
        NDIS_HANDLE             DriverHandle;
    
    } driver;



    struct 
    {
        RM_GROUP Group;
    } adapters;

    struct 
    {
        NDIS_CLIENT_CHARACTERISTICS CC;
        
    }ndis;
    


} EPVC_GLOBALS, *PEPVC_GLOBALS;

//--------------------------------------------------------------------------------
//                                                                              //
//  Enumerated types    .                                                       //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

//
// This is an enumeration that is used in acquiring locks in a particular order.
// If lock A needs to be acquired before lock B, this enumeration will enforce the 
// order
//
enum
{
    LOCKLEVEL_GLOBAL=1, // Must start > 0.
    LOCKLEVEL_ADAPTER,
    LOCKLEVEL_MINIPORT,
    LOCKLEVEL_SEND

};

// (debug only) Enumeration of types of associations.
//
enum
{
    EPVC_ASSOC_AD_PRIMARY_TASK,
    EPVC_ASSOC_ACTDEACT_AD_TASK,
    EPVC_ASSOC_MINIPORT_OPEN_VC,
    EPVC_ASSOC_MINIPORT_OPEN_AF,
    EPVC_ASSOC_MINIPORT_ADAPTER_HANDLE,
    EPVC_ASSOC_ADAPTER_MEDIA_WORKITEM,
    EPVC_ASSOC_EXTLINK_PKT_TO_SEND,
    EPVC_ASSOC_CLOSE_AF_WORKITEM,
    EPVC_ASSOC_SET_FILTER_WORKITEM,
    EPVC_ASSOC_EXTLINK_INDICATED_PKT,
    EPVC_ASSOC_WORKITEM,
    EPVC_ASSOC_MINIPORT_REQUEST
    
};



enum 
{
    IPV4_ENCAP_TYPE,
    IPV4_LLC_SNAP_ENCAP_TYPE,
    ETHERNET_ENCAP_TYPE,
    ETHERNET_LLC_SNAP_ENCAP_TYPE


};

//--------------------------------------------------------------------------------
//                                                                              //
//  WorkItems                                                                   //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

typedef struct _EPVC_WORKITEM_MEDIA_EVENT
{
    NDIS_WORK_ITEM WorkItem;

    NDIS_STATUS State;

    PEPVC_ADAPTER pAdapter;


}EPVC_WORKITEM_MEDIA_EVENT, *PEPVC_WORKITEM_MEDIA_EVENT;



typedef union
{
    NDIS_WORK_ITEM WorkItem;
    EPVC_WORKITEM_MEDIA_EVENT Media;
        

} EPVC_WORKITEM, *PEPVC_WORKITEM;


//
// Local declarations for reading the registry
//


typedef struct _MP_REG_ENTRY
{
    NDIS_STRING RegName;                // variable name text
    BOOLEAN     bRequired;              // 1 -> required, 0 -> optional
    UINT        FieldOffset;            // offset to MP_ADAPTER field
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MP_REG_ENTRY, *PMP_REG_ENTRY;


#define NIC_NUM_REG_PARAMS (sizeof (NICRegTable) / sizeof(MP_REG_ENTRY))


 #endif // _PRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

NDIS_STATUS
epvcAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
epvcSetPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );


VOID
epvcClearPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );
    
VOID
epvcSetSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
epvcClearSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
epvcTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

NDIS_STATUS
epvcCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        );

VOID
epvcSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
epvcClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );
    
ULONG
epvcReadFlags(
    IN ULONG* pulFlags );

BOOLEAN
epvcIsThisTaskPrimary (
    PRM_TASK pTask,
    PRM_TASK* ppLocation 
    );


VOID
epvcClearPrimaryTask (
    PRM_TASK* ppLocation 
    );


#if DBG

    VOID
    Dump(
        IN CHAR* p,
        IN ULONG cb,
        IN BOOLEAN fAddress,
        IN ULONG ulGroup );



#else


    #define Dump(p,cb,fAddress,ulGroup )

#endif


#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
__inline
USHORT
FASTCALL
net_short(
    UINT NaturalData)
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
__inline
ULONG
FASTCALL
net_long(
    ULONG NaturalData)
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}
#endif

NDIS_STATUS
epvcAllocateTaskUsingLookasideList(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pList,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );



VOID
epvcInitializeLookasideList(
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    );


VOID
epvcDeleteLookasideList (
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    );


PVOID
epvcGetLookasideBuffer(
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    );

VOID
epvcFreeToNPagedLookasideList (
    IN PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\rm.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.c

Abstract:

    Implementation of the "Resource Manager" APIs.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-18-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_RM

//=========================================================================
//                  U T I L I T Y     M A C R O S
//=========================================================================

#define RM_ALLOC(_pp, _size, _tag) \
                NdisAllocateMemoryWithTag((_pp), (_size), (_tag))

#define RM_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define RM_FREE(_p)         NdisFreeMemory((_p), 0, 0)

#define RM_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define RM_PRIVATE_UNLINK_NEXT_HASH(_pHashTable, _ppLink) \
            ((*(_ppLink) = (*(_ppLink))->pNext), ((_pHashTable)->NumItems--))

#define SET_RM_STATE(_pHdr, _Mask, _Val)    \
            (((_pHdr)->RmState) = (((_pHdr)->RmState) & ~(_Mask)) | (_Val))

#define CHECK_RM_STATE(_pHdr, _Mask, _Val)  \
            ((((_pHdr)->RmState) & (_Mask)) == (_Val))

#define RMISALLOCATED(_pHdr) \
                CHECK_RM_STATE((_pHdr), RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED)

#define SET_RM_TASK_STATE(_pTask, _pState) \
    SET_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define CHECK_RM_TASK_STATE(_pTask, _pState) \
    CHECK_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define GET_RM_TASK_STATE(_pTask) \
        ((_pTask)->Hdr.RmState &  RMTSKSTATE_MASK)

#if RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
         rmLock(&(_pobj)->RmPrivateLock, 0, rmPrivateLockVerifier, (_pobj), (_psr))
#else // !RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
        rmLock(&(_pobj)->RmPrivateLock, (_psr))
#endif // !RM_EXTRA_CHECKING

#define RMPRIVATEUNLOCK(_pobj, _psr) \
        rmUnlock(&(_pobj)->RmPrivateLock, (_psr))
        

#if 0
    #define RM_TEST_SIG          0x59dcfd36
    #define RM_TEST_DEALLOC_SIG  0x21392147
    #define RM_OBJECT_IS_ALLOCATED(_pobj) \
                    ((_pobj)->Sig == RM_TEST_SIG)
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj) \
                    ((_pobj)->Sig = RM_TEST_DEALLOC_SIG)
#else
    #define RM_OBJECT_IS_ALLOCATED(_pobj)  0x1
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj)  (0)
#endif

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

#if RM_EXTRA_CHECKING

// The lowest AssociationID used internal to the RM API implementation.
//
#define RM_PRIVATE_ASSOC_BASE (0x1<<31)

// Association types internal to RM API impmenentation.
//
enum
{
    RM_PRIVATE_ASSOC_LINK =  RM_PRIVATE_ASSOC_BASE,
    RM_PRIVATE_ASSOC_LINK_CHILDOF,
    RM_PRIVATE_ASSOC_LINK_PARENTOF,
    RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
    RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
    RM_PRIVATE_ASSOC_INITGROUP,
    RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,
    RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED
};


const char *szASSOCFORMAT_LINK                  = "    Linked  to 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_CHILDOF          = "    Child   of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_PARENTOF         = "    Parent  of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKPENDINGON    = "    Pending on 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKBLOCKS       = "    Blocks     0x%p (%s)\n";
const char *szASSOCFORMAT_INITGROUP             = "    Owns group 0x%p (%s)\n";
const char *szASSOCFORMAT_RESUME_TASK_ASYNC     = "    Resume async (param=0x%p)\n";
const char *szASSOCFORMAT_RESUME_TASK_DELAYED   = "    Resume delayed (param=0x%p)\n";

//  Linked to 0x098889(LocalIP)
//  Parent of 0x098889(InitIPTask)
//  Child  of 0x098889(Interface)

#endif // RM_EXTRA_CHECKING

// Private RM task to unload all objects in a group.
//
typedef struct
{
    RM_TASK             TskHdr;             // Common task header
    PRM_GROUP           pGroup;         // Group being unloaded
    UINT                uIndex;             // Index of hash-table currently being
                                            // unloaded.
    NDIS_EVENT          BlockEvent;         // Event to optionally signal when done.
    BOOLEAN             fUseEvent;          // TRUE IFF event is to be signaled.
    PFN_RM_TASK_HANDLER             pfnTaskUnloadObjectHandler; // ...
                                             // Object's unload task.
    PFN_RM_TASK_ALLOCATOR   pfnUnloadTaskAllocator;

} TASK_UNLOADGROUP;


//
// RM_PRIVATE_TASK is the union of all tasks structures used intenally in rm.c.
// rmAllocateTask allocates memory of sizeof(RM_PRIVATE_TASK), which is guaranteed
// to be large enough to hold any task internal to rm.c
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_UNLOADGROUP        UnloadGroup;

}  RM_PRIVATE_TASK;


#if RM_EXTRA_CHECKING

VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
);

#endif // RM_EXTRA_CHECKING


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    );


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
rmDerefObject(
    PRM_OBJECT_HEADER       pObject,
    PRM_STACK_RECORD        pSR
    );

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    );

VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID);

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        );

#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
    );


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    );

typedef struct
{
    PFN_RM_GROUP_ENUMERATOR pfnObjEnumerator;
    PVOID pvCallerContext;
    INT   fContinue;

} RM_STRONG_ENUMERATION_CONTEXT, *PRM_STRONG_ENUMERATION_CONTEXT;


typedef struct
{
    PRM_OBJECT_HEADER *ppCurrent;
    PRM_OBJECT_HEADER *ppEnd;

} RM_WEAK_ENUMERATION_CONTEXT, *PRM_WEAK_ENUMERATION_CONTEXT;


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

//=========================================================================
//                  L O C A L       D A T A
//=========================================================================

// Global struture for the RM apis.
//
struct
{
    // Accessed via interlocked operation.
    //
    ULONG           Initialized;

    RM_OS_LOCK          GlobalOsLock;
    LIST_ENTRY      listGlobalLog;
    UINT            NumGlobalLogEntries;

}   RmGlobals;


RM_STATIC_OBJECT_INFO
RmPrivateTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "RM Private Task",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    rmPrivateTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


// TODO: make constant
static
RM_STATIC_OBJECT_INFO
RmTask_StaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Task", // TypeName
    0, // Timeout

    NULL, // Create
    NULL, // Delete
    NULL, // LockVerifier

    0,   // ResourceTable size
    NULL // ResourceTable
};


//=========================================================================
//                  R M         A P I S
//=========================================================================


#define RM_INITIALIZATION_STARTING 1
#define RM_INITIALIZATION_COMPLETE 2

VOID
RmInitializeRm(VOID)
/*++
    Must be called before any RM APIs are called.
    TODO: replace by registration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmInitializeRm", 0x29f5d167)

    if (InterlockedCompareExchange(
            &RmGlobals.Initialized, RM_INITIALIZATION_STARTING, 0)==0)
    {
        TR_INFO(("Initializing RM APIs Global Info\n"));
        NdisAllocateSpinLock(&RmGlobals.GlobalOsLock);
        InitializeListHead(&RmGlobals.listGlobalLog);

        InterlockedExchange(&RmGlobals.Initialized, RM_INITIALIZATION_COMPLETE);
    }
    else
    {
        // Spin waiting for it to get to RM_INITIALIZATION_COMPLETE (allocated).
        TR_INFO(("Spinning, waiting for initialization to complete.\n"));
        while (RmGlobals.Initialized != RM_INITIALIZATION_COMPLETE)
        {
            // spin
        }
    }

    EXIT()
}


VOID
RmDeinitializeRm(VOID)
/*++
    Must be called to deinitialze, after last RM api is called and all async
    activity is over.
    TODO: replace by deregistration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmDeinitializeRm", 0x9a8407e9)

    ASSERT(RmGlobals.Initialized == RM_INITIALIZATION_COMPLETE);
    TR_INFO(("Deinitializing RM APIs Global Info\n"));

    // Make sure global log list is empty. Acquiring the GLobalOsLock is
    // not necessary here because all activity has stopped by now.
    //
    ASSERT(IsListEmpty(&RmGlobals.listGlobalLog));

    EXIT()
}


VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the RM_OBJECT_HEADER portion of an object.

Arguments:

    pParentObject       - NULL for a root object.
    pObject             - Object to be initialized.
    Sig                 - Signature of the object.
    pLock               - Lock used to serialize access to the object.
    pStaticInfo         - Static informatation about the object.
    szDescription       - A discriptive string (for debugging only) to be associated
                          with this object.
--*/
{
    ENTER("RmInitializeHeader", 0x47dea382)

    NdisZeroMemory(pObject, sizeof(*pObject));

    if (szDescription == NULL)
    {
        szDescription = pStaticInfo->szTypeName;
    }

    TR_VERB(("Initializing header 0x%p (%s)\n", pObject, szDescription));

    pObject->Sig = Sig;
    pObject->pLock = pLock;
    pObject->pStaticInfo = pStaticInfo;
    pObject->szDescription = szDescription;
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED);

    // The private lock is set to level (UINT)-1, which is the highest
    // possible level.
    //
    RmInitializeLock(&pObject->RmPrivateLock, (UINT)-1);

#if RM_EXTRA_CHECKING
    rmDbgInitializeDiagnosticInfo(pObject, pSR);
#endif //RM_EXTRA_CHECKING

    // Link to parent if non NULL.
    //

    if (pParentObject != NULL)
    {
        pObject->pParentObject = pParentObject;
        pObject->pRootObject =  pParentObject->pRootObject;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            pObject,
            pParentObject,
            0x11f25620,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            szASSOCFORMAT_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            szASSOCFORMAT_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING


    }
    else
    {
        pObject->pRootObject = pObject;
    }


    // We increment the total-ref count once for the allocation. This
    // reference is removed in the call to RmDeallocateObject.
    // Note that this reference is in addition to the reference implicitly
    // added by the call to RmLinkObjects above.
    //
    NdisInterlockedIncrement(&pObject->TotRefs);

#if RM_TRACK_OBJECT_TREE

    // Initialize our list of children.
    //
    InitializeListHead(&pObject->listChildren);

    if (pParentObject != NULL)
    {
        // Insert ourselves into our parent's list of children.
        //
        RMPRIVATELOCK(pParentObject, pSR);
        InsertHeadList(&pParentObject->listChildren, &pObject->linkSiblings);
        RMPRIVATEUNLOCK(pParentObject, pSR);
    }
#endif //  RM_TRACK_OBJECT_TREE

    EXIT()
    return;
}


VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Logically deallocate the object pObject. We don't actually unlink it from
    its parent or deallocate if there are non zero references to it.

--*/
{
    UINT Refs;
    ENTER("RmDeallocateObject", 0xa87fdf4a)
    TR_INFO(("0x%p (%s)\n", pObject, pObject->szDescription));

    RMPRIVATELOCK(pObject, pSR);

    RETAILASSERTEX(RMISALLOCATED(pObject), pObject);


    // Set state to deallocated.
    //
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_DEALLOCATED);

    RMPRIVATEUNLOCK(pObject, pSR);

    // Remove the ref explicitly added in RmInitializeAllocateObject.
    // rmDerefObject will remove the link to the parent, if any, if the
    // ref count drop to 1.
    //
    rmDerefObject(pObject, pSR);

    EXIT()
}


VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    )
/*++

Routine Description:

    Initialize a lock.

Arguments:

    pLock       - Unitialized memory to hold a struct of type RM_LOCK.
    Level       - Level to be associated with this lock. Locks must be acquired
                  in strictly increasing order of the locks' "Level" values.
--*/
{
    ASSERT(Level > 0);
    NdisAllocateSpinLock(&pLock->OsLock);
    pLock->Level = Level;
    
#if RM_EXTRA_CHECKING
    pLock->pDbgInfo = &pLock->DbgInfo;
    NdisZeroMemory(&pLock->DbgInfo, sizeof(pLock->DbgInfo));
#endif //  RM_EXTRA_CHECKING
}


VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Acquire (write lock) lock pLock.

--*/
{
    rmLock(
        pLock,
    #if RM_EXTRA_CHECKING
        0x16323980, // uLocID,
        NULL,
        NULL,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
}


VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock lock pLock.

--*/
{
    rmUnlock(
        pLock,
        pSR
        );
}

#if TODO // Currently RmReadLockObject is a macro defined to be RmWriteLockObject.
         // TODO: Verifier need to to also make sure that object hasn't changed state
         //       *while* the object has been read-locked.
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (read lock)  lock pLock.

--*/
{
    ASSERT(!"Unimplemented");
}
#endif //TODO


VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (write lock) the lock associated with object pObj.

Arguments:

    pObj        --      Object whose lock to acquire.
    uLocID      --      Arbitrary UINT identifying static location from which this
                        call is made.

--*/
{
    ENTER("RmWriteLockObject", 0x590ed543)
    TR_VERB(("Locking 0x%p (%s)\n", pObj, pObj->szDescription));

    rmLock(
        pObj->pLock,
    #if RM_EXTRA_CHECKING
        uLocID,
        // pObj->pStaticInfo->pfnLockVerifier,
        rmVerifyObjectState,
        pObj,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
    EXIT()
}


VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Release the lock associated with object pObj.

--*/
{
    ENTER("RmUnLockObject", 0x0307dd84)
    TR_VERB(("Unlocking 0x%p (%s)\n", pObj, pObj->szDescription));

#if RM_EXTRA_CHECKING
    //
    // Make sure that pObject is the object that is *supposed* to be freed.
    //
    ASSERT(pSR->LockInfo.pNextFree[-1].pVerifierContext  == (PVOID) pObj);
#endif // RM_EXTRA_CHECKING

    rmUnlock(
        pObj->pLock,
        pSR
        );

    EXIT()
}


VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Unlocks all currently held locks as recorded in pSR.
    If the locks are associated with objects, RmUnlockObject is called for
    each of the held locks. Otherwise the raw unlock is performed.

--*/
{
    ENTER("RmUnLockObject", 0x9878be96)
    TR_VERB(("Unlocking all\n"));

    while (pSR->LockInfo.CurrentLevel != 0)
    {
        rmUnlock(
            pSR->LockInfo.pNextFree[-1].pLock,
            pSR
            );
    }

    EXIT()
}


VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    (Debug only)

    Munge things so that the following sequence works:
    Rm[Read|Write]LockObject(pPreviouslyLockedObject, pSR);
    RmChangeLockScope(pPreviouslyLockedObject, pSR);
    RmUnlockObject(pObject, pSR);

    Of course, we require that the two objects have the same lock!

    NOTE: We only support changing scope of the MOST RECENTLY 
    acquired lock.


Arguments:

    pPreviouslyLockedObject     - Currently locked object.
    pObject                     - Object to transfer lock scope to.
    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
--*/
{
    //
    // This is a NOOP unless extra-checking is enabled.
    // TODO: make this inline in the fre build.
    //
#if RM_EXTRA_CHECKING
    RM_LOCKING_INFO * pLI = pSR->LockInfo.pNextFree-1;
    PRM_LOCK        pLock =  pPreviouslyLockedObject->pLock;
    ASSERT(
            pLock->Level == pSR->LockInfo.CurrentLevel
        &&  pLock == pObject->pLock
        &&  pLock == pLI->pLock
        &&  pLI->pVerifierContext == (PVOID) pPreviouslyLockedObject);

    ASSERT(pLI->pfnVerifier == rmVerifyObjectState);

    rmVerifyObjectState(pLock, FALSE, pLI->pVerifierContext, pSR);
    pLI->pVerifierContext   =  pObject;
    pLock->DbgInfo.uLocID   =  LocID;
    rmVerifyObjectState(pLock, TRUE, pLI->pVerifierContext, pSR);
    
#endif // RM_EXTRA_CHECING

}


VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    )
/*++

Routine Description:

        Link object pObj1 to object pObj2. Basically, this function refs both
        objects.

        OK to call with some locks held, including RmPrivateLock.
        TODO: remove arp pSr above -- we don't need it.
--*/
{
    ENTER("RmLinkObjects", 0xfe2832dd)

    // Maybe we're being too harsh here -- if required, remove this...
    // This could happen where a task is linked at the point where the object
    // is being deallocated, so I'm changing the following  to debug asserts
    // (used to be retail asserts).
    //
    ASSERT(RMISALLOCATED(pObj1));
    ASSERT(RMISALLOCATED(pObj2));

    TR_INFO(("0x%p (%s) linked to 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));

    NdisInterlockedIncrement(&pObj1->TotRefs);
    NdisInterlockedIncrement(&pObj2->TotRefs);

}


VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmLinkObjects, execpt that (debug only) it also sets up  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        on object pObj2

Arguments:

    pObj1                   - Object whose lock to acquire.
    pObj2                   - Object whose lock to acquire.
    LocID                   - Arbitrary UINT identifying static location from which
                              this call is made.
    AssocID                 - ID of the association (see RmDbgAddAssociation) that
                              represents the link from pObj1 to pObj2.
    szAssociationFormat     - Format of the association (see RmDbgAddAssociation)
    InvAssocId              - ID of the inverse association (i.e., represents
                              link from pObj2 to pObj1).
    szInvAssociationFormat  - Format of the inverse association.

--*/
{
    ENTER("RmLinkObjectsEx", 0xef50263b)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        szInvAssociationFormat,
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmLinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:
    
    Unlink objects pObj1 and pObj2 (i.e., undo the effect of
    RmLinkObjects(pObj1, pObj2, pSR)).

--*/
{
    ENTER("RmUnlinkObjects", 0x7c64356a)
    TR_INFO(("0x%p (%s) unlinked from 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));
#if RM_EXTRA_CHECKING
    //
    // TODO: remove explict link
    //
#endif // RM_EXTRA_CHECKING

    // Remove link refs.
    //
    rmDerefObject(pObj1, pSR);
    rmDerefObject(pObj2, pSR);
}


VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmUnlinkObjects, execpt that it also removes the  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        object pObj2

Arguments:

        See RmLinkObjectsEx.

--*/
{
    ENTER("RmUnlinkObjectsEx", 0x65d3536c)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        pSR
        );

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmUnlinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Links object pObj to external entity ExternalEntity. Basically, this function
    adds a reference to pObj. In addition (debug only) this function sets up
    an association on pObj that links the external entity to pObj. pObj can be
    linked to ExternalEntity with the specified association ID AssocID only ONCE
    at any particular point of time.

    Once this link is setup, an attempt to deallocate pObj without removing the
    link results in an assertion failure.

    RmUnlinkFromExternalEx is the inverse function.

Arguments:

    pObj                        - Object to be linked to an external entity.

    (following are for debug only...)

    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
    ExternalEntity              - Opaque value representing the external entity.
    AssocID                     - Association ID representing the linkage.
    szAssociationFormat         - Association format for the linkage.

--*/
{
    ENTER("RmLinkToExternalEx", 0x9aeaca74)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmLinkToExternalFast(pObj);

    EXIT()
}


VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Inverse of RmUnlinkFromExternalEx -- removes the link set up between
    pObj and ExternalEntity.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    ENTER("RmUnlinkFromExternalEx", 0x9fb084c3)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmUnlinkFromExternalFast(pObj);

    EXIT()
}


VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++

Routine Description:

    Fast version of RmLinkToExternalEx -- same behavior in retail. No associations
    are setup.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++
Routine Description:

    Inverse of RmUnlinkFromExternalFast -- removes the link set up between
    pObj and ExternalEntity.

    TODO -- we need a fast implementation for the case that the object is
    not going to go away. For now we actually declare a stack record here each
    time, becaues rmDerefObject wants one! Bad bad.

Arguments:

    See RmLinkToExternalFast.

--*/
{
    RM_DECLARE_STACK_RECORD(sr)
    rmDerefObject(pObj, &sr);
}


VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Add a temporary reference to object pObj.
    (Debug only) Increments the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpReferenceObject", 0xdd981024)
    TR_VERB(("RmTmpReferenceObject 0x%p (%s) %x\n", pObj, pObj->szDescription, pObj->TotRefs+1));

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObj));

    pSR->TmpRefs++;

    

    NdisInterlockedIncrement(&pObj->TotRefs);
    NdisInterlockedIncrement(&pObj->TempRefs);

}


VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove a temporary reference to object pObj.
    (Debug only) Decrements the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpDereferenceObject", 0xd1630c11)
    TR_VERB(("RmTmpDereferenceObject 0x%p (%s) %x\n", pObj, pObj->szDescription, pObj->TotRefs-1));

    RETAILASSERTEX(pSR->TmpRefs>0, pSR);
    pSR->TmpRefs--;
    NdisInterlockedDecrement (&pObj->TempRefs);
    
    rmDerefObject(pObj, pSR);
}


VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++


Routine Description:

        Add an arbitrary association, for debugging purposes, under
        object pObject. The association is defined by the triple
        (Entity1, Entity2, AssociationID) -- only ONE such tuple may
        be registered at any time with object pParentObject.
        Note: It is valid for both of the following to be registered at the same
        time: (a, b, 1) and (a, b, 2)

        No association should exist at the point the object is deleted.

Arguments:

        LocID           -   Arbitrary ID, typically representing the source location
                        -   from which this function is called.
        pObject         -   Object to add the association.
        Entity1         -   The 1st entity making up the association. May be NULL.
        Entity2         -   The 2nd entity making up the association. May be NULL.
        AssociationID   -   ID defining the association. 
                            NOTE: AssociationID must not have the high-bit set.
                            Associations with the high bit set are reserved for
                            internal use of the Rm API implementation.

--*/
{
#if RM_EXTRA_CHECKING
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;
    ENTER("RmDbgAddAssociation", 0x512192eb)

    if (pDiagInfo)
    {

        //
        // Allocate an association and  enter it into the hash table.
        // Assert if it already exists.
        //

        RM_PRIVATE_DBG_ASSOCIATION *pA;
        RM_ALLOCSTRUCT(pA, MTAG_DBGINFO); // TODO use lookaside lists.
    
        if (pA == NULL)
        {
            //
            // Allocation failed. Record this fact, so that
            // RmDbgDeleteAssociation doesn't assert
            // if an attempt is made to remove an assertion which doesn't exist.
            //
            NdisAcquireSpinLock(&pDiagInfo->OsLock);
            pDiagInfo->AssociationTableAllocationFailure = TRUE;
            NdisReleaseSpinLock(&pDiagInfo->OsLock);
        }
        else
        {
            BOOLEAN fFound;
            PRM_HASH_LINK *ppLink;
            RM_ZEROSTRUCT(pA);

            pA->Entity1 = Entity1;
            pA->Entity2 = Entity2;
            pA->AssociationID = AssociationID;

            if (szFormatString == NULL)
            {
                // Put in the default description format string.
                //
                szFormatString = "    Association (E1=0x%x, E2=0x%x, T=0x%x)\n";
            }

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,((char*)szFormatString, Entity1, Entity2, AssociationID));

            pA->szFormatString = szFormatString;

            NdisAcquireSpinLock(&pDiagInfo->OsLock);
    
            fFound = RmLookupHashTable(
                            &pDiagInfo->AssociationTable,
                            &ppLink,
                            pA      // We use pA as the key.
                            );
    
            if (fFound)
            {
                ASSERTEX(
                    !"Association already exists:",
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink)
                    );
                RM_FREE(pA);
                pA = NULL;
            }
            else
            {
                //
                // Enter the association into the hash table.
                //
    
                RmAddHashItem(
                    &pDiagInfo->AssociationTable,
                    ppLink,
                    &pA->HashLink,
                    pA      // We use pA as the key
                    );
            }
            NdisReleaseSpinLock(&pDiagInfo->OsLock);

            // Now, just for grins, make a note of this in the object's log.
            // TODO/TODO....
            // WARNING: Although pEntity1/2 may contain pointers, 
            // we expect the the format string is such that if there are any
            // references to regular or unicode strings, those strings will
            // be valid for the life of the object (typically these strings
            // are statically-allocated strings).
            //
            // We  COULD use the more conservative format string to display the
            // log entry, but it's useful to have the information displayed
            // properly.
            //
            // Note-- we could also do different things depending on the type
            // of association.
            //
            #if 0 // conservative format
            RmDbgLogToObject(
                    pObject,
            "    Add association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                    Entity1,
                    Entity2,
                    AssociationID,
                    0, // Param4  // (UINT_PTR) szFormatString,
                    NULL,
                    NULL
                    );
            #else // aggresive format
            {
                #define szADDASSOC "    Add assoc:"

#if OBSOLETE        //  This doesn't work because rgMungedFormat is on the stack!
                char rgMungedFormat[128];
                UINT uLength;
                rgMungedFormat[0]=0;
                rmSafeAppend(rgMungedFormat, szADDASSOC, sizeof(rgMungedFormat));
                uLength = rmSafeAppend(
                            rgMungedFormat,
                            szFormatString,
                            sizeof(rgMungedFormat)
                            );
                if (uLength && rgMungedFormat[uLength-1] != '\n')
                {
                    rgMungedFormat[uLength-1] = '\n';
                }
                RmDbgLogToObject(
                        pObject,
                        rgMungedFormat,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
#endif // OBSOLETE

                RmDbgLogToObject(
                        pObject,
                        szADDASSOC,
                        (char*)szFormatString,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
            }
            #endif // aggressive format
        }
    }

    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Removes the previously-added association (Entity1, Entity2, Association)
        from object pObject. See the description of RmDbgAddAssociation for
        details.

Arguments:

        See RmDbgAddAssociation.

--*/
{

#if RM_EXTRA_CHECKING
    ENTER("RmDbgDelAssociation", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink;
        RM_PRIVATE_DBG_ASSOCIATION TrueKey;

        // Only the following 3 fields of TrueKey make up the key
        //
        TrueKey.Entity1 = Entity1;
        TrueKey.Entity2 = Entity2;
        TrueKey.AssociationID = AssociationID;

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        fFound = RmLookupHashTable(
                        &pDiagInfo->AssociationTable,
                        &ppLink,
                        &TrueKey
                        );

        if (fFound)
        {
            RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            /*TRACE0(TL_INFO,
                ((char*)pA->szFormatString,
                 pA->Entity1,
                 pA->Entity2,
                 pA->AssociationID));
            */
            //
            // Now, just for grins, make a note of this in the oject's log.
            // Note that of pEntity1/2 contain pointers, we can't expect them
            // to be valid for as long as the object is alive, so we use
            // the more conservative format string to display the log entry.
            //
            //  TODO/BUGUG -- see comments under RmDbgAddAssociation
            //                  about the risk of directly passing szFormat
            //
            
        #if 0 // conservative
                RmDbgLogToObject(
                        pObject,
                        NULL,
                "    Deleted Association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0,
                        NULL,
                        NULL
                        );
        #else // aggressive
                #define szDELASSOC "    Del assoc:"
                RmDbgLogToObject(
                        pObject,
                        szDELASSOC,
                        (char*) pA->szFormatString,
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0, // Param4  // (UINT_PTR) szFormatString,
                        NULL,
                        NULL
                        );
        #endif // aggressive

            //
            // Remove the association and free it.
            //

            RM_PRIVATE_UNLINK_NEXT_HASH( &pDiagInfo->AssociationTable, ppLink );

            RM_FREE(pA);
        }
        else
        {
            if  (!pDiagInfo->AssociationTableAllocationFailure)
            {
                ASSERT(!"Association doesn't exist");
            }
        }
        NdisReleaseSpinLock(&pDiagInfo->OsLock);


    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintAssociations(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    (Debug only) Dumps the associations on object pObject.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintAssociations", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        TR_INFO((
            "Obj 0x%p (%s):\n",
            pObject,
            pObject->szDescription
            ));

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        RmEnumHashTable(
                    &pDiagInfo->AssociationTable,
                    rmDbgPrintOneAssociation,   // pfnEnumerator
                    pObject,        // context
                    pSR
                    );

        NdisReleaseSpinLock(&pDiagInfo->OsLock);
    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    )
/*++

Routine Description:

    Make one log entry in pObject's log.

    TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    on how we will find the deallocator function fo pvBuf. For now we simply
    use NdisFreeMemory.

    TODO: need to implement trimming of log when we reach a maximum. Currently we
    just stop logging. 

Arguments:
        pfnDumpEntry    - Function to be used for dumping the log.
                          If NULL, a default function is used, which interprets
                          szFormatString as the standard printf format string.

        szFormatString  - Format string for log display -- 1st arg to pfnDumpEntry

        Param1-4        - Remaining args to pfnDumpEntry;

        pvBuf           - If non-NULL, piece of memory to be freed when the log entry
                          is freed.

        NOTE:   If Param1-4 contain pointers, the memory they refer to is assumed
        to be valid for as long as the object is alive. If the entities being logged
        may go away before the object is deallocated, the caller should
        allocate a buffer to hold a copy of the entities, and pass the pointer to
        that buffer as pvBuf.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgLogToObject", 0x2b2015b5)

    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo && RmGlobals.NumGlobalLogEntries < 4000)
    {
        RM_DBG_LOG_ENTRY *pLogEntry;

        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

        pLogEntry = rmDbgAllocateLogEntry();

        if (pLogEntry != NULL)
        {
            if (pfnDumpEntry == NULL)
            {
                pfnDumpEntry = rmDefaultDumpEntry;
            }

            pLogEntry->pObject      = pObject;
            pLogEntry->pfnDumpEntry = pfnDumpEntry;
            pLogEntry->szPrefix = szPrefix;
            pLogEntry->szFormatString = szFormatString;
            pLogEntry->Param1 = Param1;
            pLogEntry->Param2 = Param2;
            pLogEntry->Param3 = Param3;
            pLogEntry->Param4 = Param4;
            pLogEntry->pvBuf  = pvBuf;

            // Insert item at head of object log.
            //
            InsertHeadList(&pDiagInfo->listObjectLog, &pLogEntry->linkObjectLog);

            // Insert item at head of global log.
            //
            InsertHeadList(&RmGlobals.listGlobalLog, &pLogEntry->linkGlobalLog);


            pDiagInfo->NumObjectLogEntries++;
            RmGlobals.NumGlobalLogEntries++;
        }

        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    #if 0
        pfnDumpEntry(
                szFormatString,
                Param1,
                Param2,
                Param3,
                Param4
                );
    #endif // 0
    }
    else
    {
        // TODO/TODO -- free pvBuf if NON NULL.
    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    )
/*++

Routine Description:

    (Debug only) Dumps object pObject's log.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintObjectLog", 0xe06507e5)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_INFO((" pObj=0x%p (%s)\n", pObject, pObject->szDescription));


    if (pDiagInfo != NULL)
    {
        LIST_ENTRY          *pLink=NULL;
        LIST_ENTRY *        pObjectLog =  &pDiagInfo->listObjectLog;
        
        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);
    
        for(
            pLink =  pObjectLog->Flink;
            pLink != pObjectLog;
            pLink = pLink->Flink)
        {
            RM_DBG_LOG_ENTRY    *pLE;
    
            pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);

            if (pLE->szPrefix != NULL)
            {
                // Print the prefix.
                DbgPrint(pLE->szPrefix);
            }
    
            // Call the dump function for this entry.
            //
            // 
            pLE->pfnDumpEntry(
                            pLE->szFormatString,
                            pLE->Param1,
                            pLE->Param2,
                            pLE->Param3,
                            pLE->Param4
                            );
    
        }
        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
    }
    EXIT()

#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintGlobalLog(VOID)
/*++

Routine Description:

    (Debug only) Dumps the global log (which contains entries from all object's
    logs.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintGlobalLog", 0xe9915066)
    LIST_ENTRY          *pLink=NULL;
    LIST_ENTRY          *pGlobalLog =  &RmGlobals.listGlobalLog;

    TR_INFO(("Enter\n"));

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink =  pGlobalLog->Flink;
        pLink != pGlobalLog;
        pLink = pLink->Flink)
    {
        RM_DBG_LOG_ENTRY    *pLE;

        pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkGlobalLog);

        // Print the ptr and name of the object whose entry this is...
        //
        DbgPrint(
            "Entry for 0x%p (%s):\n",
            pLE->pObject,
            pLE->pObject->szDescription
            );

        if (pLE->szPrefix != NULL)
        {
            // Print the prefix.
            DbgPrint(pLE->szPrefix);
        }

        // Call the dump function for this entry.
        //
        // 
        pLE->pfnDumpEntry(
                        pLE->szFormatString,
                        pLE->Param1,
                        pLE->Param2,
                        pLE->Param3,
                        pLE->Param4
                        );

    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    EXIT()

#endif // RM_EXTRA_CHECKING
}


RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));


    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (!RMISALLOCATED(pObj))
        {
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // The resource entry indexed must have its ID == GenericResourceID
        //
        //
        if (pSI->pResourceTable[GenericResourceID].ID != GenericResourceID)
        {
            ASSERTEX(!"Resource ID doesn't match table entry", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( ResFlag & pObj->ResourceMap)
        {
            ASSERTEX(!"Resource already allocated", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        pObj->ResourceMap |= ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        Status = pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_LOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        if (FAIL(Status))
        {
            // Clear the resource map bit on failure.
            //
            RMPRIVATELOCK(pObj, pSR);
            ASSERTEX(ResFlag & pObj->ResourceMap, pObj);
            pObj->ResourceMap &= ~ResFlag;
            RMPRIVATEUNLOCK(pObj, pSR);
        }

    } while (FALSE);

    return Status;
}


VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));

    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( !(ResFlag & pObj->ResourceMap))
        {
            ASSERTEX(!"Resource not allocated", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

    } while (FALSE);

}


VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    Synchronously unload all previously loaded resources for this object,
    in reverse order to which they were loaded.

    TODO this function is going away...
--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;
    UINT                   u;

    RMPRIVATELOCK(pObj, pSR);

    for(u = pSI->NumResourceTableEntries;
        u && pObj->ResourceMap;
        u--)
    {
        UINT  ResID = u-1;
        UINT ResFlag = 1<<ResID;
        if ( !(ResFlag & pObj->ResourceMap))
        {
            continue;
        }

        if (pSI->NumResourceTableEntries <= ResID)
        {
            ASSERTEX(!"Corrupt ResourceMap", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }


        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[ResID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        RMPRIVATELOCK(pObj, pSR);

    }

    ASSERTEX(!pObj->ResourceMap, pObj);

    RMPRIVATEUNLOCK(pObj, pSR);

}


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize a group structure.

Arguments:

    pOwningObject   - Object that will own the group.
    pStaticInfo     - Static information about objects IN the group.
    pGroup          - Uninitialized memory that is to hold the group structure. It
                      will be initialized on return from this function.
    szDescription   - (Debug only) descriptive name for this group.

    TODO: make pStaticInfo const.

--*/
{
    NdisZeroMemory(pGroup, sizeof(*pGroup));

    RMPRIVATELOCK(pOwningObject, pSR);

    do
    {
        if (!RMISALLOCATED(pOwningObject))
        {
            ASSERT(!"pObject not allocated");
            break;
        }

        if (pStaticInfo->pHashInfo == NULL)
        {
            ASSERT(!"NULL pHashInfo");
            // Static info MUST have non-NULL pHashInfo in order
            // for it to be used for groups.
            //
            break;
        }

    
        RmInitializeHashTable(
            pStaticInfo->pHashInfo,
            pOwningObject,  // pAllocationContext
            &pGroup->HashTable
            );


        pGroup->pOwningObject = pOwningObject;
        pGroup->pStaticInfo = pStaticInfo;
        pGroup->szDescription = szDescription;

        NdisAllocateSpinLock(&pGroup->OsLock);
        pGroup->fEnabled = TRUE;

    #if RM_EXTRA_CHECKING
        RmDbgAddAssociation(
            0xc0e5362f,                         // Location ID
            pOwningObject,                      // pObject
            (UINT_PTR) pGroup,                  // Instance1
            (UINT_PTR) (pGroup->szDescription), // Instance2
            RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
            szASSOCFORMAT_INITGROUP,            // szAssociationFormat
            pSR
            );
    #endif // RM_EXTRA_CHECKING

    } while (FALSE);

    RMPRIVATEUNLOCK(pOwningObject, pSR);

}


VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Deinitialize group structure pGroup. Must only be called when there are no
    members in the group.

--*/
{

#if RM_EXTRA_CHECKING
    RmDbgDeleteAssociation(
        0x1486def9,                         // Location ID
        pGroup->pOwningObject,              // pObject
        (UINT_PTR) pGroup,                  // Instance1
        (UINT_PTR) (pGroup->szDescription), // Instance2
        RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
        pSR
        );
#endif // RM_EXTRA_CHECKING

    NdisAcquireSpinLock(&pGroup->OsLock);

    RmDeinitializeHashTable(&pGroup->HashTable);

    NdisReleaseSpinLock(&pGroup->OsLock);
    NdisFreeSpinLock(&pGroup->OsLock);
    NdisZeroMemory(pGroup, sizeof(*pGroup));

}


RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // create, remove, lock
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    TODO: split this into a pure lookup and a lookupand/orcreate function..

    Lookup and/or create an object in the specified group.


#if OBSOLETE // Must allow fCreate w/o locking -- see notes.txt  entry:
               //   03/04/1999   JosephJ  Problems with deadlock when using Groups.
        MUST ONLY be NON-NULL if the fLOCKED flag is specified.
        Why? Because if the lock is not held on exit, it would be possible
        for someone else to pick up the object in the freshly-created state.
        We want to discourage that situation.
#endif // OBSOLETE

         Typically the caller specifes the
        fRM_LOCKED|fRM_CREATE flags as well as non-null pfCreated. On return, if
        *pfCreated is TRUE, the caller then would go on to do some more
        initialization before releasing the lock.

        FUNDAMENTAL ASSUMPTION: The key of an object doesn't change once
        it's in the group. Based on this assumption, we don't try to claim
        the object's lock when looking for the object with a matching key.

Arguments:

    pGroup          - Group in which to lookup/create object.
    Flags           - One or more of fRM_LOCKED, fRM_CREATE, fRM_NEW
    pvKey           - Key used to lookup object.
    pvCreateParams  - If object is to be created, parameters to be passed to the
                      object's creation function.
    ppObject        - Place to store pointer to the found/created object.
    pfCreated       - If non-NULL, *pfCreated is set to TRUE IFF the object was
                      created.

Return Value:

    NDIS_STATUS_SUCCESS     If the operation succeeded.
    NDIS_STATUS_RESOURCES   If a new object could not be created.
    NDIS_STATUS_RFAILURE    If the object was not found.

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    BOOLEAN             fUnlockOutOfOrder = FALSE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG
    ENTER("RmLookupObjectInGroup",  0xd2cd6379)

    ASSERT(pOwningObject!=NULL);
    // OBSOLETE -- see comments above: ASSERT(pfCreated==NULL || (Flags&RM_LOCKED));

    if (pfCreated != NULL) *pfCreated = FALSE;

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        fFound = RmLookupHashTable(
                        &pGroup->HashTable,
                        &ppLink,
                        pvKey
                        );

        if (fFound)
        {
            if (Flags & RM_NEW)
            {
                // Caller wanted us to created a new object, but the object already
                // exists, so we fail...
                //
                // TODO: return appropriate error code.
                //
                break;
            }

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(*ppLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            if (!(Flags & RM_CREATE))
            {
                // Couldn't find it, and caller doesn't want us to create one, so
                // we fail...
                break;
            }
            
            // Create object...
            //
            ASSERTEX(pGroup->pStaticInfo->pfnCreate!=NULL, pGroup);
            pObject = pGroup->pStaticInfo->pfnCreate(
                                                pOwningObject,
                                                pvCreateParams,
                                                pSR
                                                );
            
            if (pObject == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            TR_INFO((
                "Created 0x%p (%s) in Group 0x%p (%s)\n",
                pObject,
                pObject->szDescription,
                pGroup,
                pGroup->szDescription
                ));

            ASSERTEX(RMISALLOCATED(pObject), pObject);

            // Now enter it into the hash table.
            //
            RmAddHashItem(
                &pGroup->HashTable,
                ppLink,
                &pObject->HashLink,
                pvKey
                );
            if (pfCreated != NULL)
            {
                *pfCreated = TRUE;
            }

        }

        if (Flags & RM_LOCKED)
        {
            RmWriteLockObject(
                    pObject,
                #if RM_EXTRA_CHECKING
                    0x6197fdda,
                #endif //RM_EXTRA_CHECKING
                    pSR
                    );

            if  (!RMISALLOCATED(pObject))
            {
                // We don't allow this...
                RmUnlockObject(
                    pObject,
                    pSR
                    );
                break;
            }

            fUnlockOutOfOrder = TRUE;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    if (fUnlockOutOfOrder)
    {
        //
        // WARNING WARNING WARNING -- this code breaks rules --
        // This is so we can unlock out-of order....
        //
    #if !TESTPROGRAM
        pObject->pLock->OsLock.OldIrql = pGroup->OsLock.OldIrql;
    #endif // !TESTPROGRAM
        NdisDprReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
    }

    if (FAIL(Status))
    {
        *ppObject = NULL;
    }
    else
    {
        *ppObject = pObject;
    }

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_VERB(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    return Status;
}


RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject, // OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Get the 1st object in group (if pCurrentObject == NULL), or the object
    "after" pCurrentObject (if pCurrentObject != NULL).
    
    The definition of "after" is hidden -- the only guarantee is if this
    function is 1st called with NULL pCurrentObject and subsequently with
    pCurrentObject set to the value previously returned in ppNextObject, until
    the function returns NDIS_STATUS_FAILURE, all objects in the group will
    be returned once and only once. This guarantee is only valid if no objects
    are added or removed during the enumeration process.

    On success, the "next" object is tmpref'd a pointer to it is saved in
    *ppNextObject.

Arguments:

    pGroup          - The group
    pCurrentObject  - (OPTIONAL) An object in the group.
    ppNextObject    - Place to return the the object  "after" pCurrentObject
                      (see RoutineDescription for details.)
                     

Return Value:

    NDIS_STATUS_SUCCESS if we could find a "next" object.
    NDIS_STATUS_FAILURE otherwise

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

    ENTER("RmGetNextObjectInGroup",  0x11523db7)

    ASSERT(pOwningObject!=NULL);

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK pLink = NULL;
        PRM_HASH_LINK pCurrentLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        if (pCurrentObject != NULL)
        {
            pCurrentLink = &pCurrentObject->HashLink;
        }

        fFound =  RmNextHashTableItem(
                        &pGroup->HashTable,
                        pCurrentLink,   // pCurrentLink
                        &pLink  // pNextLink
                        );

        if (fFound)
        {

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            // Couldn't find one.
            // we fail...
            break;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    if (FAIL(Status))
    {
        *ppNextObject = NULL;
    }
    else
    {
        *ppNextObject = pObject;
    }

    return Status;
}


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL  // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove object pObject from group pGroup and deallocate pObject.

--*/
{
    ENTER("RmFreeObjectInGroup",  0xd2cd6379)
    PRM_OBJECT_HEADER pOwningObject = pGroup->pOwningObject;

    ASSERTEX(pOwningObject!=NULL, pGroup);
    ASSERTEX(pTask==NULL, pGroup);

    NdisAcquireSpinLock(&pGroup->OsLock);

    // TODO: what if at this time, someone else is doing FreeAllObjects in Group?
    //
    TR_INFO((
        "Freeing 0x%p (%s) in Group 0x%p (%s)\n",
        pObject,
        pObject->szDescription,
        pGroup,
        pGroup->szDescription
        ));

    ASSERTEX(RMISALLOCATED(pObject), pObject);

    RmRemoveHashItem(
            &pGroup->HashTable,
            &pObject->HashLink
            );

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Deallocate the object.
    //
    RmDeallocateObject(
                pObject,
                pSR
                );

    EXIT()
}


VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove and deallocate all object in pGroup.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (pGroup->fEnabled)
    {
        pGroup->fEnabled = FALSE;
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
        return;                                 // EARLY RETURN
    }

    //
    // With fEnabled set to FALSE by us, we expect the following:
    // (a) pHashTable->pTable is going to stay the same size.
    // (b) No items are going to be added or removed by anyone else.
    //

    ppLink      = pGroup->HashTable.pTable;
    ppLinkEnd   = ppLink + pGroup->HashTable.TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        while (*ppLink != NULL)
        {
            PRM_HASH_LINK pLink =  *ppLink;
            PRM_OBJECT_HEADER pObj;
    
            // Remove it from the bucket list.
            //
            *ppLink = pLink->pNext;
            pLink->pNext = NULL;
            pGroup->HashTable.NumItems--;
    
            NdisReleaseSpinLock(&pGroup->OsLock);
    
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
    
            // Deallocate the object.
            //
            RmDeallocateObject(
                        pObj,
                        pSR
                        );
        
            NdisAcquireSpinLock(&pGroup->OsLock);
        }
    }

    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Stops new objects from being added and unloads(see below) all objects
    currently in the group.

    "Unload" consists of allocating and starting a pfnUnloadTaskHask task
    on each object. The unload task is responsible for
    removing and deallocating the object from the group.

    If pTask if non-NULL, it will be resumed on completion of the unload.
    Otherwise, this function will BLOCK until the unload is complete.

Arguments:

    pGroup                  - Group to unload.
    pfnUnloadTaskAllocator  - Use to allocate the object-unload tasks.
    pfnTaskAllocator        - Function used to allocate the unload task.
    pfnUnloadTaskHandler    - The handler of the unload task
    pvUserParam             - Task creation user-param. 
                            WARNING: this param must be valid for the duration
                            of the unload process, not just until this
                            function returns. Of course, if pTask is NULL,
                            the two cases are equivalent.
    pTask                   - (OPTIONAL) Task to resume when unload is complete.
                            If NULL, this function will block until the
                            unload is complete.
    uTaskPendCode           - (OPTIONAL) PendCode to use when resuming pTask.
        
--*/
{
    PRM_TASK    pUnloadTask;
    NDIS_STATUS Status;

    NdisAcquireSpinLock(&pGroup->OsLock);

    //
    // We don't check if there is already an unload task active for this group.
    // Instead we go ahead and allocate and start an unload task. This latter
    // task will pend on the already running unload task if there is on.
    //

    // Allocate a private task to coordinate the unloading of all the objects.
    //
    Status =    rmAllocatePrivateTask(
                            pGroup->pOwningObject,
                            rmTaskUnloadGroup,
                            0,
                            "Task:UnloadAllObjectsInGroup",
                            &pUnloadTask,
                            pSR
                            );

    if (FAIL(Status))
    {
        //
        // Ouch -- ugly failure...
        //
        ASSERT(FALSE);

        NdisReleaseSpinLock(&pGroup->OsLock);

    }
    else
    {
        TASK_UNLOADGROUP *pUGTask =  (TASK_UNLOADGROUP *) pUnloadTask;

        pUGTask->pGroup                     = pGroup;
        pUGTask->pfnTaskUnloadObjectHandler =    pfnUnloadTaskHandler;
        pUGTask->pfnUnloadTaskAllocator     =   pfnUnloadTaskAllocator;

        if (pTask == NULL)
        {

            // Set up an event which we'll wait on. The event will be signaled
            // by pUnloadTask when it completes.
            //
            NdisInitializeEvent(&pUGTask->BlockEvent);
            pUGTask->fUseEvent = TRUE;

            // Tmpref it so pUnloadTask will stay around even afer it's
            // completed -- because we wait on the event that's actually
            // located in the task memory.
            //
            RmTmpReferenceObject(&pUnloadTask->Hdr, pSR);
        }

        NdisReleaseSpinLock(&pGroup->OsLock);

        if (pTask != NULL)
        {
            RmPendTaskOnOtherTask(
                    pTask,
                    uTaskPendCode,
                    pUnloadTask,
                    pSR
                    );
        }

        Status = RmStartTask(pUnloadTask, 0, pSR);

        if (pTask == NULL)
        {
            NdisWaitEvent(&pUGTask->BlockEvent, 0);
            RmTmpDereferenceObject(&pUnloadTask->Hdr, pSR);
        }
    }
}

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    TODO: need better name for this.

Routine Description:

    Enables items to be added to a group.
    This function is typically called with a group which has completed
    RmUnloadAllObjectsFromGroup or RmFreeAllObjectsInGroup.
    On return from this call items may once more be added to this group.

    This call must only be called after UnloadAllObjectsInGroup or
    RmFreeAllObjectsInGroup have completed (synchronously or asynchronously).

    If there are items in in group or there is an unload
    task associated with the group at the time this function is called,
    the group is NOT reinited and the DBG version will assert.

    This function and may be called with an already enabled group, provided
    the condition above is met (no items in group, no unload task).

--*/
{
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (    pGroup->pUnloadTask == NULL 
        &&  pGroup->HashTable.NumItems == 0)
    {
        pGroup->fEnabled = TRUE;
    }
    else
    {
        ASSERT("invalid state.");
    }
    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmInitializeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
    IN  const char *                szDescription,  OPTIONAL
    IN  UINT                        Timeout,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified task.

    The task is tempref'd. It is the responsibility of the caller to
    de-ref it when done. Typically this is implicitly done by calling
    RmStartTask.

Arguments:

    pTask           -   points to unitialized memory to hold the task.
    pParentObject   -   will be the parent of the task.
    pfnHandler      -   task's handler function.
    pStaticInfo     -   (OPTIONAL) Static information about the task.
    szDescription   -   (debug only, OPTIONAL) description of the task
    Timeout         -   unused
        
--*/
{
    ASSERT(!Timeout); // TODO: Timeouts unimplemented.

    NdisZeroMemory(pTask, sizeof(*pTask));

    RmInitializeHeader(
            pParentObject,
            &pTask->Hdr,
            MTAG_TASK,
            pParentObject->pLock,
            (pStaticInfo) ? pStaticInfo : &RmTask_StaticInfo,
            szDescription,
            pSR
            );
    pTask->pfnHandler = pfnHandler;
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE);
    InitializeListHead(&pTask->listTasksPendingOnMe);

    RmTmpReferenceObject(&pTask->Hdr, pSR);

}


VOID
RmAbortTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
{
    ASSERT(!"Unimplemented");
}



RM_STATUS
RmStartTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Start the specified task.

    NO locks should be held on entry and none are held on exit.
    pTask is expected to have a tmp-ref which is deref'd here.
    The task is automatically deallocated on completion (either  synchronous
    or asynchronous completion, either successful or failed completion).
    Unless the caller is explicitly added a reference to pTask before calling
    this function, the caller should not assume that pTask is still valid
    on return from this function.

Arguments:

    pTask           -   points to the task to be started.
    UserParam       -   opaque value passed to the task handler with the
                        RM_TASKOP_START message.
        
--*/
{
    ENTER("RmStartTask", 0xf80502d5)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);
    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE))
    {
        ASSERTEX(!"Invalid state", pTask);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        if (!RMISALLOCATED(pTask->Hdr.pParentObject))
        {
            //
            // TODO: consider not calling the handler if the parent object is
            // deallocated, but that may be confusing.
            // Consider not allowing children to be linked to an object
            // (RmInitializeHeader returns failure) if the parent object is
            // deallocated.
            //
            TR_WARN((
                "Starting task 0x%p (%s) with DEALLOCATED parent 0x%p (%s).\n",
                pTask,
                pTask->Hdr.szDescription,
                pTask->Hdr.pParentObject,
                pTask->Hdr.pParentObject->szDescription
                ));
        }

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        TR_INFO((
            "STARTING Task 0x%p (%s); UserParam = 0x%lx\n",
            pTask,
            pTask->Hdr.szDescription,
            UserParam
            ));

        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_START,
                            UserParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_STARTING:

            // This task is completing synchronously.
            //
            ASSERT(Status != NDIS_STATUS_PENDING);
            SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            rmEndTask(pTask, Status, pSR);
            RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            // ??? ASSERT(Status != NDIS_STATUS_PENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            // ??? RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            // Fall through ...

        case RMTSKSTATE_ACTIVE:
            // This can happen if the task is in the process of being resumed
            // in the context of some other thread. Nothing to do here...
            // (This actually happens sometimes on a MP machine).
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;
        }
        
    }

    // Remove the tmp ref added when the task was allocated.
    //
    RmTmpDereferenceObject(
                &pTask->Hdr,
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmDbgDumpTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
)
{
}


RM_STATUS
RmSuspendTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Suspends the specified task.

    RmSuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   context to be presented to the task's handler when
                        the task is subsequently resumed. Specifically, this 
                        context may be accessed using the RM_PEND_CODE macro,
                        when the task's handler is called with code
                        RM_TASKOP_PENDCOMPLETE.
        
--*/
{
    ENTER("RmSuspendTask", 0xd80fdc00)
    NDIS_STATUS Status;
    // RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "SUSPENDING Task 0x%p (%s); SuspendContext = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendContext
        ));

    if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
        &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
    {
        ASSERTEX(!"Invalid state", pTask);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;
        Status = NDIS_STATUS_SUCCESS;
    }

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    // RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmUnsuspendTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Undoes the effect of a previous call to RmSuspendTask.

    Task MUST be in the pending state and MUST NOT be pending on another task.
    Debug version will ASSERT if above conditions are not met.

    RmUnsuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
        
--*/
{
    ENTER("RmUnsuspendTask", 0xcf713639)

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "UN-SUSPENDING Task 0x%p (%s). SuspendContext = 0x%x\n",
        pTask,
        pTask->Hdr.szDescription,
        pTask->SuspendContext
        ));

    ASSERT(CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING));
    ASSERT(pTask->pTaskIAmPendingOn == NULL);
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
    pTask->SuspendContext = 0;

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    EXIT()
}


VOID
RmResumeTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume a previously-suspended task.

    No locks held on entry or exit.
    
    SuspendCompletionParam is user-defined, and must be agreed upon between
    the caller of RmUnpendTask and the task that's being unpended.
    The Task's handler is ALWAYS called in the context of the caller of RmUnpendTask.
    So it is ok for the caller to declare a structure on the stack and pass
    a pointer to it as SuspendCompletionParam.

    WARNING: pTask could well be invalid (deallocate) by the time we return
    from this function. The caller is responsible for tmprefing pTask if it needs
    to access after return from this function.

Arguments:

    pTask                   -   task to be resumed.
    SuspendCompletionParam  -   arbitrary value that is passed on to the task's
                                handler as "UserParan" when the handler is called
                                with code RM_TASKOP_PENDCOMPLETE.
--*/
{
    ENTER("RmResumeTask", 0xd261f3c6)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "RESUMING Task 0x%p (%s); SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendCompletionParam
        ));

    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
    {
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        ASSERTEX(!"Invalid state", pTask);
    }
    else
    {
        // Add tmp ref, because we need to look at pTask after the return
        // from calling pfnHandler.
        //
        RmTmpReferenceObject(&pTask->Hdr, pSR);

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_PENDCOMPLETE,
                            SuspendCompletionParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_ACTIVE:

            // This task is completing here (maybe)
            //
            if (Status != NDIS_STATUS_PENDING)
            {
                SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
                rmEndTask(pTask, Status, pSR);
                RmDeallocateObject(&pTask->Hdr, pSR);
            }
            else
            {
                // It could be returning pending, but the state could
                // by now be active because it was completed elsewhere.
                // ASSERT(Status != NDIS_STATUS_PENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            }
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
        
        // Remove tmpref added above. pTask may well go away now...
        //
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
}


VOID
RmResumeTaskAsync(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  OS_WORK_ITEM            *   pOsWorkItem,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a work-item thread.

Arguments:
    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsWorkItem             - caller supplied UNitialized work item (must stay
                              around until the task is resumed). Typically this
                              will be located within the user-specific portion
                              of pTask
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                         // Location ID
        &pTask->Hdr,                        // pObject
        (UINT_PTR) SuspendCompletionParam,  // Instance1
        (UINT_PTR) pOsWorkItem,             // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC, // AssociationID
        szASSOCFORMAT_RESUME_TASK_ASYNC,    // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // We don't need to grab the private lock to set this, because only one
    // entity can call RmResumeTaskAsync. Note that we also ensure things are clean
    // (in the debug case) by the association added above.
    //
    pTask->AsyncCompletionParam = SuspendCompletionParam;

    NdisInitializeWorkItem(
        pOsWorkItem,
        rmWorkItemHandler_ResumeTaskAsync,
        pTask
        );

    Status = NdisScheduleWorkItem(pOsWorkItem);
    if (FAIL(Status))
    {
        ASSERT(!"NdisStatusWorkItem failed.");

        // It so happens that NdisScheudleWorkItem (current implementation
        // doesn't fail. Nevertheless, we do the best we can and actually
        // resume the task. If the caller was at dpc level and was expecting
        // the task to resume at passive, they're out of luck.
        //
        RmResumeTask(pTask, SuspendCompletionParam, pSR);
    }
}


VOID
RmResumeTaskDelayed(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  ULONG                       MsDelay,
    IN  OS_TIMER                *   pOsTimer,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a os timer handler which is set to fire after MsDelay milliseconds
    from the time RmResumeTaskDelayed is called.

    EXCEPTION: if someone has previously called RmResumeDelayedTaskNow, this
    task could be resumed in the context of this function call itself.

    Abort implementation notes: see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsTimer                - caller supplied UNitialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                             // Location ID
        &pTask->Hdr,                            // pObject
        (UINT_PTR) SuspendCompletionParam,      // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        szASSOCFORMAT_RESUME_TASK_DELAYED,      // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // Ddk states that it's best to call this function at passive level.
    //
    NdisInitializeTimer(
        pOsTimer,
        rmTimerHandler_ResumeTaskDelayed,
        pTask
        );

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    // The task-del state should NOT be "delayed"
    //
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, 0));
    pTask->AsyncCompletionParam = SuspendCompletionParam;
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED);

    if (RM_CHECK_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY))
    {
        // Oops, the delay has been aborted -- we call the tick handler now!
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        rmTimerHandler_ResumeTaskDelayed(
                NULL, // SystemSpecific1,
                pTask, // FunctionContext,
                NULL,  // SystemSpecific2,
                NULL   // SystemSpecific3
                );

    }
    else
    {
        //
        // Not currently aborting, let's set the timer.
        //
        NdisSetTimer(pOsTimer, MsDelay);

        // Very important to unlock the private lock AFTER calling set timer,
        // other wise someone could call RmResumeDelayedTaskNow BEFORE we call
        // NdisSetTimer, in which we would not end up aborting the delayed task.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }

}


VOID
RmResumeDelayedTaskNow(
    IN  PRM_TASK                    pTask,
    IN  OS_TIMER                *   pOsTimer,
    OUT PUINT                       pTaskResumed,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Cut's short the delay and resumes the task immediately.

    Implementation notes:  see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    pOsTimer                - caller supplied initialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
    pTaskResumed            - Points to a caller-supplied variable.
                              RmResumeDelayedTask sets this variable to TRUE if the
                              task was resumed as a consequence of this call, or to
                              FALSE if the task was resumed due to some other reason.
--*/
{
    UINT_PTR    CompletionParam = pTask->AsyncCompletionParam;

    *pTaskResumed = FALSE;
    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY);

    if (RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED))
    {
        BOOLEAN     TimerCanceled = FALSE;

        //
        // The task is actually delayed. Let's go ahead and cancel the timer
        // and resume the task now (which we do indirectly by calling
        // the timer handler ourselves).
        //
        NdisCancelTimer(pOsTimer, &TimerCanceled);
        if (TimerCanceled)
        {
            //
            // The timer was actually canceled -- so we call the timer handler
            // ourselves.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    
            rmTimerHandler_ResumeTaskDelayed(
                    NULL, // SystemSpecific1,
                    pTask, // FunctionContext,
                    NULL,  // SystemSpecific2,
                    NULL   // SystemSpecific3
                    );
            *pTaskResumed = TRUE;
        }
        else
        {
            //
            // Hmm -- the timer is not enabled. This is either because
            // the timer handler has just been called (and not yet cleared
            // the "DELAY" state) OR someone has previously called
            // RmResumeDelayedTaskNow.
            //
            //
            // Nothing to do.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
    }
    else
    {
        //
        // The task state is not delayed -- so we just set the abort state
        // and go away.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }
}


RM_STATUS
RmPendTaskOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    Pend task pTask on task pOtherTask.

    Note: RmPendTaskOnOtherTask will cause pTask's pend operation to be
    completed in the context of this call itself, if pOtherTask is already
    in the completed state.
    03/26/1999 -- see RmPendTaskOnOtherTaskV2, and also
    03/26/1999 notes.txt entry "Some proposed ..."

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   Context associated with the suspend (see
                        RmSuspendTask for details).
    pOtherTask      -   task that pTask is to pend on.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    NDIS_STATUS_FAILURE on failure (typically because pTask is not in as
                        position to be suspended.)
--*/
{
    ENTER("RmPendTaskOnOtherTask", 0x0416873e)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    ASSERT(pTask != pOtherTask);
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }

        Status = NDIS_STATUS_SUCCESS;

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;

        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we resume pTask before returning...
            //
            fResumeTask = TRUE;
            break;
        }

        //
        // pOtherTask is not ended -- add pTask to the list of tasks pending
        // on pOtherTask.
        //
        pTask->pTaskIAmPendingOn  = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                NDIS_STATUS_SUCCESS, // SuspendCompletionParam. TODO: put real code.
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


RM_STATUS
RmPendOnOtherTaskV2(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    if pOtherTask is not complete, Pend task pTask on task pOtherTask and return
    NDIS_STATUS_PENDING. However, if pOtherTask is already complete,
    then don't pend and instead return NDIS_STATUS_SUCCESS.

    See  03/26/1999 notes.txt entry "Some proposed ...". This function
    is currently used only by rmTaskUnloadGroup, to avoid the problem describted
    in the above-referenced notes.txt entry.

    TODO: Eventually get rid of RmPendTaskOnOtherTask.

Arguments:

    See RmPendTaskOnOtherTask
    
Return Value:

    NDIS_STATUS_PENDING if pTask is pending on pOtherTask
    NDIS_STATUS_SUCCESS if pOtherTask is complete.
    NDIS_STATUS_FAILURE if there was some failure (typically pTask is not
                        in a position to be pended.)
--*/
{
    ENTER("RmPendTaskOnOtherTaskV2", 0x0e7d1b89)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING(V2) Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));

    // This is not a useless assert -- I'e had a bug elsewhere which caused this
    // assert to get hit.
    //
    ASSERT(pTask != pOtherTask);
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }


        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we simply return success...
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // pOtherTask is not ended -- set pTask state to pending, and
        // add it to the list of tasks pending on pOtherTask.
        //
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext       = SuspendContext;
        pTask->pTaskIAmPendingOn    = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );
        Status = NDIS_STATUS_PENDING;

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


VOID
RmCancelPendOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_TASK                    pOtherTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume task pTask which is currently pending on pOtherTask.

    Since no locks are held, pOtherTask needs to be specified, to make sure
    that pTask is indeed pending on pOtherTask before canceling the pend.

    If pTask is indeed pending on pOtherTask, this function will cause the
    completion of the pend status with the specified user param.

    Has no effect if the task is not pending.

Arguments:

    pTask       - Task to be "unpended"
    pOtherTask  - Task pTask is currently pending on.
    UserParam   - Passed to pTask's handler if and when pTask is resumed.

--*/
{
    ENTER("RmCancelPendOnOtherTask", 0x6e113266)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //

    TR_INFO((
        "CANCEL PEND of Task 0x%p (%s) on other Task 0x%p (%s); UserParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        UserParam
        ));

    // With pTask locked, tmp ref the task it is pending on, if any...
    //
    {
        NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
        if (pOtherTask == pTask->pTaskIAmPendingOn)
        {
            RmTmpReferenceObject(&(pOtherTask->Hdr), pSR);
        }
        else
        {
            // Oops -- pTask is not pending on pOtherTask ...
            //
            pOtherTask = NULL;
        }
        NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    }

    if (pOtherTask == NULL) return;                 // EARLY RETURN


    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Now that we have both task's locks, check again if pTask is pending
        // on pOtherTask
        //
        if (pTask->pTaskIAmPendingOn != pOtherTask)
        {
            // Oops -- the situation is different than when we started -- quietly
            // get out of here...
            //
            break;
        }

        pTask->pTaskIAmPendingOn = NULL;

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x6992b7a1,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        RemoveEntryList(&pTask->linkFellowPendingTasks);
        pTask->linkFellowPendingTasks.Flink = NULL;
        pTask->linkFellowPendingTasks.Blink = NULL;

        if (CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
        {
            fResumeTask = TRUE;
        }
        else
        {
            //
            // We shouldn't get here -- after we are pending on another task...
            //
            ASSERTEX(!"Invalid state", pTask);
            break;
        }

    } while (FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    RmTmpDereferenceObject(&(pOtherTask->Hdr), pSR);
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                UserParam, // SuspendCompletionParam
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}



VOID
RmInitializeHashTable(
    PRM_HASH_INFO pHashInfo,
    PVOID         pAllocationContext,
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Initialize a hash table data structure.
    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashInfo           - Points to static information about the hash table
    pAllocationContext  - Passed to the allocation and deallocation functions
                          (pHashInfo->pfnTableAllocator and
                          pHashInfo0->pfnTableDeallocator) which are used to
                          dynamically grow /shrink the hash table.
    pHashTable          - Points to uninitialized memory that is to contain the
                          hash table.
--*/
{

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

    pHashTable->pHashInfo = pHashInfo;
    pHashTable->pAllocationContext = pAllocationContext;
    pHashTable->pTable =  pHashTable->InitialTable;
    pHashTable->TableLength = sizeof(pHashTable->InitialTable)
                                /sizeof(pHashTable->InitialTable[0]);
}

VOID
RmDeinitializeHashTable(
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Deinitialize a previously-initialized a hash table data structure.
    There must be no items in the hash table when this function is called.

    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashTable          - Hash table to be deinitialized.

--*/
{
    PRM_HASH_LINK *pTable = pHashTable->pTable;
    
    ASSERTEX(pHashTable->NumItems == 0, pHashTable);

    if (pTable != pHashTable->InitialTable)
    {
        NdisZeroMemory(pTable, pHashTable->TableLength*sizeof(*pTable));

        pHashTable->pHashInfo->pfnTableDeallocator(
                                    pTable,
                                    pHashTable->pAllocationContext
                                    );
    }

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

}


BOOLEAN
RmLookupHashTable(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK **    pppLink,
    PVOID               pvRealKey
    )
/*++

Routine Description:

    Lookup an item in the hash table and/or find the place where the item
    is to be inserted.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    Return value: TRUE if item found; false otherwise.
    On return, *pppLink is set to a the location containing a pointer to
    a RM_HASH_LINK. If the return value is TRUE, the latter pointer points
    to the found RM_HASH_LINK. If the return value is FALSE, the location
    is where the item is to be inserted, if required.

Arguments:

    pHashTable          - Hash table to look up
    pppLink             - place to store a pointer to a link which points
                          to an item (see above for details).
    pvRealKey           - Key used to lookup item.

Return Value:
    
    TRUE    if item is found
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT LinksTraversed = 0;
    UINT TableLength = pHashTable->TableLength;
    PFN_RM_COMPARISON_FUNCTION pfnCompare =  pHashTable->pHashInfo->pfnCompare;
    BOOLEAN fRet = FALSE;
    ULONG               uHash = pHashTable->pHashInfo->pfnHash(pvRealKey);

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext), LinksTraversed++)
    {
        if (pLink->uHash == uHash
            && pfnCompare(pvRealKey, pLink))
        {
            // found it
            //
            fRet = TRUE;
            break;
        }
    }

    // Update stats
    //
    rmUpdateHashTableStats(&pHashTable->Stats, LinksTraversed);
    
    *pppLink = ppLink;

    return fRet;
}


BOOLEAN
RmNextHashTableItem(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
    PRM_HASH_LINK *    ppNextLink
    )
/*++

Routine Description:

    Find the first (if pCurrentLink is NULL) or "next" (if pCurrentLink is not NULL)
    item in the hash table.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    NOTE: The "next" item returned is in no particular order.

Arguments:

    pHashTable          - Hash table to look up
    pCurrentLink        - if non-NULL, points to an existing hash link in the
                          hash table.
    ppLinkLink          - place to store a pointer to the link "after"
                          pCurrentLink, or the first link (if pCurrentLink is NULL).

Return Value:
    
    TRUE    if there is a "next" item.
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK pLink, *ppLink, *ppLinkEnd;
    UINT TableLength;

    ppLink      = pHashTable->pTable;
    TableLength = pHashTable->TableLength;
    ppLinkEnd   = ppLink + TableLength;

    if (pCurrentLink != NULL)
    {

    #if DBG
        {
            // Make sure this link is valid!
            pLink =  *(ppLink + (pCurrentLink->uHash % TableLength));
            while (pLink != NULL && pLink != pCurrentLink)
            {
                pLink = pLink->pNext;
            }
            if (pLink != pCurrentLink)
            {
                ASSERTEX(!"Invalid pCurrentLink", pCurrentLink);
                *ppNextLink = NULL;
                return FALSE;                           // EARLY RETURN
            }
        }
    #endif // DBG

        if (pCurrentLink->pNext != NULL)
        {
            // Found a next link.
            //
            *ppNextLink = pCurrentLink->pNext;
            return TRUE;                            // EARLY RETURN
        }
        else
        {
            // End of current bucket, move to next one.
            // We check later if we've gone past the end of the table.
            //
            ppLink +=  (pCurrentLink->uHash % TableLength) + 1;
        }
    }


    // Look for next non-null item.
    //
    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        pLink =  *ppLink;
        if (pLink != NULL)
        {
            *ppNextLink = pLink;
            return TRUE;                        // EARLY RETURN
        }
    }

    *ppNextLink = NULL;
    return FALSE;
}


VOID
RmAddHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK * ppLink,
    PRM_HASH_LINK   pLink,
    PVOID           pvKey
    )
/*++

Routine Description:

    Add an item to the hash table at the specified location.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    ppLink          - Points to place within table to add new item.
    pLink           - New item to add.
    pvKey           - key associated with the item.

    TODO: pvKey is only used to compute uHash -- consider passing in uHash directly.

--*/
{
    pLink->uHash = pHashTable->pHashInfo->pfnHash(pvKey);
    pLink->pNext = *ppLink;
    *ppLink = pLink;

    pHashTable->NumItems++;

    // TODO: if required, resize
}

VOID
RmRemoveHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK   pLinkToRemove
    )
/*++

Routine Description:

    Remove an item from the hash table.
    Caller is expected to serialize access to the hash table.

    (debug only): Asserts if pLinkToRemove is no in the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    pLinkToRemove   - Link to remove.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT TableLength = pHashTable->TableLength;
    ULONG uHash = pLinkToRemove->uHash;
    BOOLEAN     fFound = FALSE;

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext))
    {
        if (pLink == pLinkToRemove)
        {
            // found it -- remove it and get out.
            //
            RM_PRIVATE_UNLINK_NEXT_HASH(pHashTable, ppLink);
            pLink->pNext = NULL; // Important, so that enumeration works.
            fFound=TRUE;
            break;
        }
    }

    // TODO: if required, resize

    ASSERT(fFound);
}


VOID
RmEnumHashTable(
    PRM_HASH_TABLE          pHashTable,
    PFN_ENUM_HASH_TABLE     pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the hash table.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;

    ppLink      = pHashTable->pTable;
    ppLinkEnd   = ppLink + pHashTable->TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        PRM_HASH_LINK pLink =  *ppLink;
        while (pLink != NULL)
        {

            pfnEnumerator(
                pLink,
                pvContext,
                pSR 
                );
    
            pLink = pLink->pNext;
        }
    }
}


VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    WARNING: Enumeration is "STRONG" -- the group lock
    is held during the whole enumeration process. The
    enumerator function is therefore called at DPR level, and more importantly,
    the enumerator function avoid locking anything to avoid risk of deadlock.
    Specifically, the enumerator function MUST NOT lock the object -- if any other
    thread has called a group-related RM function with the object's lock held,
    we WILL deadlock.

    This function should only be used to access parts of the object that do
    not need to be protected by the objects lock.

    If locking needs to be performed, use RmWeakEnumerateObjectsInGroup.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.
    fStrong         - MUST be TRUE.
--*/
{

    if (fStrong)
    {
        RM_STRONG_ENUMERATION_CONTEXT Ctxt;
        Ctxt.pfnObjEnumerator = pfnEnumerator;
        Ctxt.pvCallerContext = pvContext;
        Ctxt.fContinue           = TRUE;

        NdisAcquireSpinLock(&pGroup->OsLock);

        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmEnumObjectInGroupHashTable,   // pfnEnumerator
                    &Ctxt,                          // context
                    pSR
                    );

        NdisReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        ASSERT(!"Unimplemented");
    }

}


VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    Enumeration is "WEAK" -- the group lock is
    NOT held the whole time, and is not held when the enumerator
    function is called.

    A snapshot of the entire group is first taken with the group lock held,
    and each object is tempref'd. The group lock is then released and the
    enumerator function is called for each object in the snapshot. 
    The objects are then derefd.

    NOTE: It is possible that when the enumeration function is called for an
    object, the object is no longer in the group. The enumeration function can
    lock the object and check its internal state to determine if it is still
    relevant to process the object.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.


--*/
{
    #define RM_SMALL_GROUP_SIZE         10
    #define RM_MAX_ENUM_GROUP_SIZE      100000
    PRM_OBJECT_HEADER *ppSnapshot = NULL;
    PRM_OBJECT_HEADER SmallSnapshot[RM_SMALL_GROUP_SIZE];
    UINT NumItems = pGroup->HashTable.NumItems;

    do
    {
        RM_WEAK_ENUMERATION_CONTEXT Ctxt;

        if (NumItems <= RM_SMALL_GROUP_SIZE)
        {
            if (NumItems == 0) break;
            ppSnapshot = SmallSnapshot;
        }
        else if (NumItems > RM_MAX_ENUM_GROUP_SIZE)
        {
            // TODO: LOG_RETAIL_ERROR
            ASSERT(FALSE);
        }
        else
        {
            RM_ALLOC(
                    &(void* )ppSnapshot,
                    NumItems,
                    MTAG_RMINTERNAL
                    );

            if (ppSnapshot == NULL)
            {
                ASSERT(FALSE);
                break;
            }
        }

        Ctxt.ppCurrent = ppSnapshot;
        Ctxt.ppEnd     = ppSnapshot+NumItems;

        NdisAcquireSpinLock(&pGroup->OsLock);
    
        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmConstructGroupSnapshot,   // pfnEnumerator
                    &Ctxt,                      // context
                    pSR
                    );
    
        NdisReleaseSpinLock(&pGroup->OsLock);

        ASSERT(Ctxt.ppCurrent >= ppSnapshot);
        ASSERT(Ctxt.ppCurrent <= Ctxt.ppEnd);

        // Fix up ppEnd to point to the last actually-filled pointer.
        //
        Ctxt.ppEnd = Ctxt.ppCurrent;
        Ctxt.ppCurrent = ppSnapshot;

        for  (;Ctxt.ppCurrent < Ctxt.ppEnd; Ctxt.ppCurrent++)
        {
            pfnEnumerator(
                    *Ctxt.ppCurrent,
                    pvContext,
                    pSR
                    );
            RmTmpDereferenceObject(*Ctxt.ppCurrent, pSR);
        }

        if (ppSnapshot != SmallSnapshot)
        {
            RM_FREE(ppSnapshot);
            ppSnapshot = NULL;
        }

    } while (FALSE);
}


//=========================================================================
//                  L O C A L   F U N C T I O N S
//=========================================================================


VOID
rmDerefObject(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dereference object pObject. Deallocate it if the reference count goes to zero.

--*/
{
    ULONG Refs;
    ENTER("rmDerefObject", 0x5f9d81dd)

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObject));

    //
    // On entry, the ref count should be at-least 2 -- one the
    // explicit ref added in RmAllocateObject, and the 2nd the ref due to
    // the link to the parent.
    //
    // Exception to the above: if the object has no parent, the refcount should be
    // at-least 1.
    //

    // Deref the ref added in RmAllocateObject, and if the ref count is now <=1, 
    // we actually unlink and free the object.
    //
    Refs = NdisInterlockedDecrement(&pObject->TotRefs);

    if (Refs <= 1)
    {
        PRM_OBJECT_HEADER pParentObject;
        RMPRIVATELOCK(pObject, pSR);

        //
        // Unlink from parent, if there is one...
        //
    
        pParentObject =  pObject->pParentObject;
        pObject->pParentObject = NULL;

    #if RM_TRACK_OBJECT_TREE
        // Verify that there are no siblings...
        //
        RETAILASSERTEX(IsListEmpty(&pObject->listChildren), pObject);
    #endif // RM_TRACK_OBJECT_TREE

        RMPRIVATEUNLOCK(pObject, pSR);

        if (pParentObject != NULL)
        {
            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            ASSERTEX(Refs == 1, pObject);

        #if RM_TRACK_OBJECT_TREE
            RMPRIVATELOCK(pParentObject, pSR);

            // Remove object from parent's list of children.
            //
            RETAILASSERTEX(
                !IsListEmpty(&pParentObject->listChildren),
                pObject);
            RemoveEntryList(&pObject->linkSiblings);

            RMPRIVATEUNLOCK(pParentObject, pSR);
        #endif // RM_TRACK_OBJECT_TREE

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            pObject,
            pParentObject,
            0xac73e169,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
            RmUnlinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING

        }
        else if (Refs == 0)
        {
            //
            // Free to deallocate this thing...
            //

            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            #if RM_EXTRA_CHECKING
            rmDbgDeinitializeDiagnosticInfo(pObject, pSR);
            #endif // RM_EXTRA_CHECKING

            RM_MARK_OBJECT_AS_DEALLOCATED(pObject);

            if (pObject->pStaticInfo->pfnDelete!= NULL)
            {

                TR_INFO((
                    "Actually freeing 0x%p (%s)\n",
                    pObject,
                    pObject->szDescription
                    ));

                pObject->pStaticInfo->pfnDelete(pObject, pSR);
            }
        }
    }

    EXIT()
}

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Lock pLock.

Arguments:

    pLock               - Lock to lock.
    LocID               - Arbitrary ID, typically representing the source location
                          from which this function is called.
    
    Following are for debug only:

    pfnVerifier         - Optional function that is called just after locking
    pfnVerifierContext  - Passed in call to pfnVerifier

--*/
{
    //UINT Level  = pSR->LockInfo.CurrentLevel;
    RM_LOCKING_INFO li;

    RETAILASSERTEX(pLock->Level > pSR->LockInfo.CurrentLevel, pLock);
    RETAILASSERTEX(pSR->LockInfo.pNextFree < pSR->LockInfo.pLast, pLock);

    pSR->LockInfo.CurrentLevel = pLock->Level;

    // Save information about this lock in the stack record.
    //
    li.pLock = pLock;
#if RM_EXTRA_CHECKING
    li.pfnVerifier = pfnVerifier;
    li.pVerifierContext = pVerifierContext;
#endif //RM_EXTRA_CHECKING
    *(pSR->LockInfo.pNextFree++) = li; // struct copy.

    // Get the lock.
    // TODO: uncomment the following optimization...
    //if (Level)
    //{
    //  NdisDprAcquireSpinLock(&pLock->OsLock);
    //}
    //else
    //{
    NdisAcquireSpinLock(&pLock->OsLock);
    //}

#if RM_EXTRA_CHECKING

    ASSERTEX(pLock->DbgInfo.uLocID == 0, pLock);
    ASSERTEX(pLock->DbgInfo.pSR == NULL, pLock);
    pLock->DbgInfo.uLocID = uLocID;
    pLock->DbgInfo.pSR = pSR;
    // Call the verifier routine if there is one.
    //
    if (pfnVerifier)
    {
        pfnVerifier(pLock, TRUE, pVerifierContext, pSR);
    }
#endif //RM_EXTRA_CHECKING

}


VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock pLock.

    Debug only: if there is a verifier function associated with this lock
    we call it just before unlocking pLock.

Arguments:

    pLock               - Lock to unlock.

--*/
{
    RM_LOCKING_INFO * pLI;
    pSR->LockInfo.pNextFree--;
    pLI = pSR->LockInfo.pNextFree;
    RETAILASSERTEX(pLI->pLock == pLock, pLock);

    ASSERTEX(pLock->DbgInfo.pSR == pSR, pLock);
    ASSERTEX(pLock->Level == pSR->LockInfo.CurrentLevel, pLock);

    pLI->pLock = NULL;

    if (pLI > pSR->LockInfo.pFirst)
    {
        PRM_LOCK pPrevLock =  (pLI-1)->pLock;
        pSR->LockInfo.CurrentLevel = pPrevLock->Level;
        ASSERTEX(pPrevLock->DbgInfo.pSR == pSR, pPrevLock);
    }
    else
    {
        pSR->LockInfo.CurrentLevel = 0;
    }


#if RM_EXTRA_CHECKING

    // Call the verifier routine if there is one.
    //
    if (pLI->pfnVerifier)
    {
        pLI->pfnVerifier(pLock, FALSE, pLI->pVerifierContext, pSR);
        pLI->pfnVerifier = NULL;
        pLI->pVerifierContext = NULL;
    }
    pLock->DbgInfo.uLocID = 0;
    pLock->DbgInfo.pSR = NULL;

#endif //RM_EXTRA_CHECKING


    // Release the lock.
    //
    NdisReleaseSpinLock(&pLock->OsLock);
}


#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    The Verifier function for an object's RmPrivateLock.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
Return Value:

    Unused: TODO make return value VOID.

--*/
{
    ENTER("rmPrivateLockVerifier", 0xc3b63ac5)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pContext=%p\n",
                pLock, fLock, pContext, pSR));
    EXIT()

    return 0;
}

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    Uses the object's verification function (if there is one) to
    compute a signature that is checked each time the object is locked,
    and is updated each time the object is unlocked. Assert if this signature
    has changed while the object was supposedly unlocked.

    Also: Update RM_OBJECT_HEADER.pDiagInfo->PrevState if there is been a
    change of state while the object was locked.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
    pContext            - Actually pointer to object being locked.

Return Value:

    Unused: TODO make return value VOID.

--*/
{
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER) pContext;
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObj->pDiagInfo;
    ULONG NewChecksum;
    ENTER("rmVerifyObjectState", 0xb8ff7a67)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pObj=%p\n",
                pLock, fLock, pObj, pSR));

    if (pDiagInfo != NULL
        && !(pDiagInfo->DiagState & fRM_PRIVATE_DISABLE_LOCK_CHECKING))

    {
        
        // Compute the new checksum and as part of that call the
        // object-specific verifier if there is one....
        //
        {
            PFNLOCKVERIFIER         pfnVerifier;

            // We verify that the objset-specific state was not modified
            // without the lock held. This is done by including the object-specific
            // state in the checksum computation.
            //
            NewChecksum = pObj->State;
    
            // Then, if the object has a verifier function, we call it, and 
            // fold in the return value into the checkum.
            //
            pfnVerifier = pObj->pStaticInfo->pfnLockVerifier;
            if (pfnVerifier != NULL)
            {
                NewChecksum ^= pfnVerifier(pLock, fLock, pObj, pSR);
    
            }
        }

        if (fLock)  // We've just locked the object.
        {

            // First thing we do is to save the current value of pObj->State in
            // the TmpState location -- we'll look at it again on unlocking.
            //
            pDiagInfo->TmpState = pObj->State;


            // Now we compare the new checksum value with the value that wase
            // saved the last time this object was locked...
            // Special case: old Checksum was 0 -- as it is on initialization.
            //
            if (NewChecksum != pDiagInfo->Checksum && pDiagInfo->Checksum)
            {
                TR_WARN((
                    "Object 0x%p (%s) possibly modified without lock held!\n",
                    pObj,
                    pObj->szDescription
                    ));

            // Unfortunately we hit this assert because there are places where
            // the same lock is shared by many objects and 
            #if 0
                // Give users the option to ignore further validation on this 
                // object.
                //
                TR_FATAL((
                    "To skip this assert, type \"ed 0x%p %lx; g\"\n",
                    &pDiagInfo->DiagState,
                    pDiagInfo->DiagState | fRM_PRIVATE_DISABLE_LOCK_CHECKING
                    ));
                ASSERTEX(!"Object was modified without lock held!", pObj);
            #endif // 0
            }
        }
        else    // We're just about to unlock the object....
        {
            // Update the signature...
            //
            pDiagInfo->Checksum = NewChecksum;

            // If there has been a change in state between locking and unlockng
            // this object, save the previous state.
            //
            if (pDiagInfo->TmpState != pObj->State)
            {
                pDiagInfo->PrevState = pDiagInfo->TmpState;
            }
        }
    }


    EXIT()

    return 0;
}
#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
)
/*++

Routine Description:

    Send the RM_TASKOP_END to the task handler, and resume any tasks pending on
    pTask.

Arguments:

    pTask       - Task to end.
    Status      - Completion status -- passed on to the task handler.

--*/
{
    ENTER("rmEndtask", 0x5060d952)
    PRM_TASK pPendingTask;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "ENDING Task 0x%p (%s); Status = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        Status
        ));

    // TODO: could change behavior so that we use the return value, but
    // currently we ignore it...
    //
    pTask->pfnHandler(
                pTask,
                RM_TASKOP_END,
                Status, // UserParam is overloaded here.
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        pPendingTask = NULL;
    
        RMPRIVATELOCK(&pTask->Hdr, pSR);
        if (!IsListEmpty(&pTask->listTasksPendingOnMe))
        {
            pPendingTask = CONTAINING_RECORD(
                                (pTask->listTasksPendingOnMe.Flink),
                                RM_TASK,
                                linkFellowPendingTasks
                                );
            RmTmpReferenceObject(&pPendingTask->Hdr, pSR);
        }
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        if (pPendingTask != NULL)
        {

            RmCancelPendOnOtherTask(
                pPendingTask,
                pTask,
                Status,
                pSR
                );
            RmTmpDereferenceObject(&pPendingTask->Hdr, pSR);
        }
    
    }
    while(pPendingTask != NULL);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocate and initialize a task of subtype RM_PRIVATE_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise

--*/
{
    RM_PRIVATE_TASK *pRmTask;
    NDIS_STATUS Status;

    RM_ALLOCSTRUCT(pRmTask, MTAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pRmTask != NULL)
    {
        RM_ZEROSTRUCT(pRmTask);

        RmInitializeTask(
                &(pRmTask->TskHdr),
                pParentObject,
                pfnHandler,
                &RmPrivateTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pRmTask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for unloading all the objects in the group.

    pTask is a pointer to TASK_UNLOADGROUP, and that structure is expected
    to be initialized, including containing the  pGroup to unload.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    TASK_UNLOADGROUP    *pMyTask = (TASK_UNLOADGROUP*) pTask;
    PRM_GROUP           pGroup = pMyTask->pGroup;
    BOOLEAN             fContinueUnload = FALSE;
    ENTER("TaskUnloadGroup", 0x964ee422)


    enum
    {
        PEND_WaitOnOtherTask,
        PEND_UnloadObject
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            // If there is already an unload task bound to pGroup, we
            // pend on it.
            //
            NdisAcquireSpinLock(&pGroup->OsLock);
            if (pGroup->pUnloadTask != NULL)
            {
                PRM_TASK pOtherTask = pGroup->pUnloadTask;
                TR_WARN(("unload task 0x%p already bound to pGroup 0x%p; pending on it.\n",
                pOtherTask, pGroup));

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                NdisReleaseSpinLock(&pGroup->OsLock);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_WaitOnOtherTask,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else if (!pGroup->fEnabled)
            {
                //
                // Presumably this group has already been unloaded of all objects
                // and is simply sitting around. We complete right away.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We're the 1st ones here -- continue on to unloading objects, if
                // any...
                //
                pGroup->pUnloadTask = pTask;
                pGroup->fEnabled = FALSE; // This will prevent new objects from
                                        // being added and from the hash table
                                        // itself from changing size.
                pMyTask->uIndex = 0;    // This keeps track of where we are in the
                                    // hash table.
                                            
                fContinueUnload = TRUE;
            }
            NdisReleaseSpinLock(&pGroup->OsLock);
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_WaitOnOtherTask:
                {
                    //
                    // Nothing to do -- finish task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                case  PEND_UnloadObject:
                {
                    //
                    // Just done unloading an object; unload another if required.
                    //
                    fContinueUnload = TRUE;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                ASSERTEX(!"Unknown pend code!", pTask);
                break;
            }

        }
        break;


        case  RM_TASKOP_END:
        {
            BOOLEAN fSignal;
            NdisAcquireSpinLock(&pGroup->OsLock);

            // Clear ourselves from pGroup, if we're there.
            //
            if (pGroup->pUnloadTask == pTask)
            {
                pGroup->pUnloadTask = NULL;
            }
            fSignal = pMyTask->fUseEvent;
            pMyTask->fUseEvent = FALSE;
            NdisReleaseSpinLock(&pGroup->OsLock);

            if (fSignal)
            {
                NdisSetEvent(&pMyTask->BlockEvent);
            }
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        ASSERTEX(!"Unknown task op", pTask);
        break;

    } // switch (Code)


    if (fContinueUnload)
    {
        do {
            PRM_HASH_LINK *ppLink, *ppLinkEnd;
            UINT uIndex;
            PRM_HASH_LINK pLink;
            PRM_OBJECT_HEADER pObj;
            PRM_TASK pUnloadObjectTask;

            NdisAcquireSpinLock(&pGroup->OsLock);
    
            uIndex = pMyTask->uIndex;

            //
            // With fEnabled set to FALSE by us, we expect the following:
            // (a) pHashTable->pTable is going to stay the same size.
            // (b) No items are going to be added or removed by anyone else.
            //

            // Find the next non-empty hash table entry, starting at
            // offset pMyTask->uIndex.
            //
            ASSERTEX(!pGroup->fEnabled, pGroup);
            ASSERTEX(uIndex <= pGroup->HashTable.TableLength, pGroup);
            ppLinkEnd = ppLink      = pGroup->HashTable.pTable;
            ppLink      += uIndex;
            ppLinkEnd   += pGroup->HashTable.TableLength;
            while (ppLink < ppLinkEnd && *ppLink == NULL)
            {
                ppLink++;
            }

            // Update index to our current position in the hash table.
            //
            pMyTask->uIndex =  (UINT)(ppLink - pGroup->HashTable.pTable);

            if (ppLink >= ppLinkEnd)
            {
                //
                // We're done...
                //
                NdisReleaseSpinLock(&pGroup->OsLock);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // Found another object to unload...
            // We'll allocate a task (pUnloadObjectTask) to unload that object,
            // pend ourselves on it, and then start it.
            //
            //

            pLink =  *ppLink;
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            RmTmpReferenceObject(pObj, pSR);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
            NdisReleaseSpinLock(&pGroup->OsLock);

            Status = pMyTask->pfnUnloadTaskAllocator(
                        pObj,                                   // pParentObject,
                        pMyTask->pfnTaskUnloadObjectHandler,    // pfnHandler,
                        0,                                      // Timeout,
                        "Task:Unload Object",
                        &pUnloadObjectTask,
                        pSR
                        );
            if (FAIL(Status))
            {
                // Aargh... we couldn't allocate a task to unload this object.
                // We'll return quietly, leaving the other objects intact...
                //
                ASSERTEX(!"Couldn't allocat unload task for object.", pObj);
                RmTmpDereferenceObject(pObj, pSR);
                break;
            }

            RmTmpDereferenceObject(pObj, pSR);
    
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."

            RmPendTaskOnOtherTask(
                pTask,
                PEND_UnloadObject,
                pUnloadObjectTask,              // task to pend on
                pSR
                );
    
            (void)RmStartTask(
                        pUnloadObjectTask,
                        0, // UserParam (unused)
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;

    #else   // !OBSOLETE
            RmTmpReferenceObject(&pUnloadObjectTask->Hdr, pSR);
            RmStartTask(
                pUnloadObjectTask,
                0, // UserParam (unused)
                pSR
                );
            Status = RmPendOnOtherTaskV2(
                        pTask,
                        PEND_UnloadObject,
                        pUnloadObjectTask,
                        pSR
                        );
            RmTmpDereferenceObject(&pUnloadObjectTask->Hdr, pSR);
            if (PEND(Status))
            {
                break;
            }
    #endif  // !OBSOLETE
    
        }
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."
        while (FALSE);
    #else   // !OBSOLETE
        while (TRUE);
    #endif  // !OBSOLETE

    }   // if(fContinueUnload)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}

#if RM_EXTRA_CHECKING

BOOLEAN
rmDbgAssociationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Comparison function used to test for exact equality of items
    in the debug association table.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.
    pItem       - Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.

Return Value:

    TRUE IFF the (Entity1, Entity2 and AssociationID) fields of the key
    exactly match the corresponding fields of 
    CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
             CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;


    if (    pA->Entity1 == pTrueKey->Entity1
        &&  pA->Entity2 == pTrueKey->Entity2
        &&  pA->AssociationID == pTrueKey->AssociationID)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
rmDbgAssociationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash generating function used to compute a ULONG-sized hash from
    key, which is actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Return Value:

    ULONG-sized hash generated from the (Entity1, Entity2 and AssociationID)
    fields of the key.

--*/
{
    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;
    ULONG_PTR big_hash;

    big_hash =   pTrueKey->Entity1;
    big_hash ^=  pTrueKey->Entity2;
    big_hash ^=  pTrueKey->AssociationID;

    // Warning: Below, the return value would be truncated in 64-bit.
    // That tolerable because after all this is just a hash.
    // TODO: for 64-bit, consider  xoring hi- and lo- DWORD instead of truncationg.
    //

    return (ULONG) big_hash;
}


// Static hash information use for the hash table (in the diagnostic information
// of each object) that keeps track of associations.
//
RM_HASH_INFO
rmDbgAssociation_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    rmDbgAssociationCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    rmDbgAssociationHash        // pfnHash

};


VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Allocate and initialize the diagnostic information associated with
    object pObject. This includes initializing the hash table used to keep
    track of arbitrary associations.

--*/
{
    ENTER("InitializeDiagnosticInfo",  0x55db57a2)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;

    TR_VERB(("   pObj=0x%p\n", pObject));
    // TODO: use lookaside lists for the allocation of these objects.
    //
    RM_ALLOCSTRUCT(pDiagInfo,   MTAG_DBGINFO);
    if (pDiagInfo != NULL)
    {
        RM_ZEROSTRUCT(pDiagInfo);

        NdisAllocateSpinLock(&pDiagInfo->OsLock);
        RmInitializeHashTable(
            &rmDbgAssociation_HashInfo,
            NULL,   // pAllocationContext
            &pDiagInfo->AssociationTable
            );
        pObject->pDiagInfo  = pDiagInfo;
        pDiagInfo->pOwningObject = pObject;

        // Initialize the per-object log list.
        //
        InitializeListHead(&pDiagInfo->listObjectLog);
    }
}


VOID
rmDbgFreeObjectLogEntries(
        LIST_ENTRY *pObjectLog
)
/*++

Routine Description:

    Remove and free all items from the object log pObjectLog.
    It is assumed that no one is trying  to add items to this log at this time.

--*/
{
    LIST_ENTRY          *pLink=NULL, *pNextLink=NULL;
    
    if (IsListEmpty(pObjectLog))    return;             // EARLY RETURN 

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink = pObjectLog->Flink;
        pLink != pObjectLog;
        pLink = pNextLink)
    {
        RM_DBG_LOG_ENTRY    *pLogEntry;
        LIST_ENTRY          *pLinkGlobalLog;

        pLogEntry = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);
        pLinkGlobalLog =  &pLogEntry->linkGlobalLog;

        // Remove entry from global log.
        // We don't bother removing the entry from the local log list, because
        //  it's going away anyway.
        //
        RemoveEntryList(pLinkGlobalLog);

        // Move to next entry in object's log (which may not be the next entry
        // in the global log).
        //
        pNextLink = pLink->Flink;

        // Free the buffer in the log entry, if any.
        // TODO: need to use log buffer deallocation function --
        //      See notes.txt  03/07/1999  entry "Registering root objects with RM".
        // For now we assume the this memory was allocated using
        // NdisAllocateMemory[WithTag].
        //
        if (pLogEntry->pvBuf != NULL)
        {
            NdisFreeMemory(pLogEntry->pvBuf, 0, 0);
        }

        // Free the log entry itself.
        //
        rmDbgDeallocateLogEntry(pLogEntry);
        
    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
}


VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        (Debug only)

        Deinitialize and free  the diagnostic information associated with
        object pObject. This includes verifying that there are no remaining
        associations and links.
--*/
{
    ENTER("DeinitializeDiagnosticInfo", 0xa969291f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_VERB((" pObj=0x%p\n", pObject));
    if (pDiagInfo != NULL)
    {

        // Free all the per-object log entries.
        // Note: no one should be trying to add items to this log at this time
        // because we're aboute to deallocate this object.
        //
        {
            rmDbgFreeObjectLogEntries(&pDiagInfo->listObjectLog);
            RM_ZEROSTRUCT(&pDiagInfo->listObjectLog);
        }


        if (pDiagInfo->AssociationTable.NumItems != 0)
        {
            //
            // Ouch! Associations still left. We print out the associations and then
            // DebugBreak.
            //

            TR_FATAL((
                "FATAL: Object 0x%p still has some associations left!\n",
                pObject
                ));
            RmDbgPrintAssociations(pObject, pSR);
            ASSERT(!"Object has associations left at deallocation time.");
        }

        pObject->pDiagInfo = NULL;

        RmDeinitializeHashTable(
            &pDiagInfo->AssociationTable
            );

        //
        // Add any other checks here...
        //

        NdisFreeSpinLock(&pDiagInfo->OsLock);
        RM_FREE(pDiagInfo);
    }
}


VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dump a single association.

Arguments:

    pLink       -  Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.
    pvContext   -  Unused

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(pLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);
    DbgPrint(
        (char*) (pA->szFormatString),
        pA->Entity1,
        pA->Entity2,
        pA->AssociationID
        );
}


VOID
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
)
/*++

Routine Description:

    Default function to dump the contents of an association.

--*/
{
    DbgPrint(
        szFormatString,
        Param1,
        Param2,
        Param3,
        Param4
        );
}

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
)
/*++

Routine Description:

    Append szAppend to szBuf, but don't exceed cbBuf, and make sure the 
    resulting string is null-terminated.

Return Value:

    Total length of string (excluding null termination) after append.

--*/
{
    UINT uRet;
    char *pc = szBuf;
    char *pcEnd = szBuf+cbBuf-1;    // possible overflow, but we check below.
    const char *pcFrom = szAppend;

    if (cbBuf==0) return 0;             // EARLY RETURN;

    // Skip to end of szBuf
    //
    while (pc < pcEnd && *pc!=0)
    {
        pc++;
    }

    // Append szAppend
    while (pc < pcEnd && *pcFrom!=0)
    {
        *pc++ = *pcFrom++;  
    }

    // Append final zero 
    //
    *pc=0;

    return (UINT) (UINT_PTR) (pc-szBuf);
}

#endif //RM_EXTRA_CHECKING

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    )
/*++

Routine Description:

    NDIS work item handler which resumes the give task.

Arguments:

    pWorkItem           - Work item associated with the handler.
    pTaskToResume       - Actually a pointer to the task to resume.

--*/
{
    PRM_TASK pTask  = pTaskToResume;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyAsync...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) pWorkItem,                   // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,     // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    NDIS timer handler which resumes the give task.

    WARNING: This handler is also called internally by the RM APIs.
    Implementation notes: -- see notes.txt  07/14/1999 entry.

Arguments:

    SystemSpecific1     - Unused
    FunctionContext     - Actually a pointer to the task to be resumed.
    SystemSpecific2     - Unused
    SystemSpecific3     - Unused

--*/
{
    PRM_TASK pTask  = FunctionContext;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyDelayed...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    RMPRIVATELOCK(&pTask->Hdr, &sr);
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED));
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, 0);
    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, 0);
    RMPRIVATEUNLOCK(&pTask->Hdr, &sr);

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free a private task (which was allocated using  rmAllocatePrivateTask.

Arguments:

    pObj    - Actually a pointer to a task of subtype RM_PRIVATE_TASK.

--*/
{
    RM_FREE(pObj);
}


#if RM_EXTRA_CHECKING


RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID)
/*++

Routine Description:

    Allocate an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_DBG_LOG_ENTRY *pLE;
    RM_ALLOCSTRUCT(pLE, MTAG_DBGINFO);
    return  pLE;
}

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        )
/*++

Routine Description:

    Free an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_FREE(pLogEntry);
}
#endif // RM_EXTRA_CHECKING


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    )
/*++

Routine Description:

    Update the stats (loword == links traversed, hiword == num accesses)

--*/
{
    ULONG OldStats;
    ULONG Stats;
    
    // Clip LinksTraversed to 2^13, or 8192 
    //
    if (LinksTraversed > (1<<13))
    {
        LinksTraversed = 1<<13;
    }
    
    Stats = OldStats = *pStats;
    
    // If either the loword or hiword of Stats is greater-than 2^13, we
    // intiger-devide both by 2. We're really only interested in the ratio
    // of the two, which is preserved by the division.
    //
    #define rmSTATS_MASK (0x11<<30|0x11<<14)
    if (OldStats & rmSTATS_MASK)
    {
        Stats >>= 1;
        Stats &= ~rmSTATS_MASK;
    }

    // Compute the updated value of stats..
    //  "1<<16" below means "one access"
    //
    Stats += LinksTraversed | (1<<16);

    // Update the stats, but only if they haven't already been updated by
    // someone else. Note that if they HAVE been updated, we will lose this
    // update. Not a big deal as we are not looking for 100% exact statistics here.
    //
    InterlockedCompareExchange(pStats, Stats, OldStats);
}


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to implement "STRONG" enumeration -- see
    RmEnumerateObjectsInGroup.
--*/
{
    PRM_STRONG_ENUMERATION_CONTEXT pCtxt = (PRM_STRONG_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->fContinue)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        pCtxt->fContinue = pCtxt->pfnObjEnumerator(
                                    pHdr,
                                    pCtxt->pvCallerContext,
                                    pSR
                                    );
    }
}


VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to construct a snapshot of a group for weak enumeration.
    See RmWeakEnumerateObjectsInGroup.
--*/
{
    PRM_WEAK_ENUMERATION_CONTEXT pCtxt = (PRM_WEAK_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->ppCurrent < pCtxt->ppEnd)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        RmTmpReferenceObject(pHdr, pSR);
        *pCtxt->ppCurrent = pHdr;
        pCtxt->ppCurrent++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\util.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    ATMEPVC - utilities

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/


#include "precomp.h"
#pragma hdrstop


#if DO_TIMESTAMPS

void
epvcTimeStamp(
    char *szFormatString,
    UINT Val
    )
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}

#endif // DO_TIMESTAMPS

//------------------------------------------------------------------------
//                                                                      //
//  Task Data structures and functions begin here                       //
//                                                                      //
//----------------------------------------------------------------------//


//
// EpvcTasks_StaticInfo contains static information about
// objects of type  EPVC_TASK;
//
RM_STATIC_OBJECT_INFO
EpvcTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ATM Epvc Task",    // TypeName
    0, // Timeout

    NULL, // pfnCreate
    epvcTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


VOID
epvcTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type EPVC_TASK.

Arguments:

    pHdr    - Actually a pointer to the EPVC_TASK to be deleted.

--*/
{
    EPVC_FREE(pObj);
}



NDIS_STATUS
epvcAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    EPVC_TASK *pATask;
    NDIS_STATUS Status;

    Status = EPVC_ALLOCSTRUCT(pATask, TAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pATask != NULL && (FAIL(Status)== FALSE))
    {
        EPVC_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &EpvcTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}




NDIS_STATUS
epvcAllocateTaskUsingLookasideList(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pList,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    EPVC_TASK *pATask;
    NDIS_STATUS Status;

    pATask = epvcGetLookasideBuffer (pList);

    
    Status = EPVC_ALLOCSTRUCT(pATask, TAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pATask != NULL && (FAIL(Status)== FALSE))
    {
        EPVC_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &EpvcTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}




VOID
epvcSetPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcSetPrimaryAdapterTask", 0x49c9e2d5)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    ASSERT(pAdapter->bind.pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == epvcTaskInitializeAdapter) && (PrimaryState == EPVC_AD_PS_INITING))
         || ((pfn == epvcTaskShutdownAdapter) && (PrimaryState == EPVC_AD_PS_DEINITING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        EPVC_ASSOC_AD_PRIMARY_TASK,
        "   Primary task\n",
        pSR
        );

    pAdapter->bind.pPrimaryTask = pTask;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
epvcClearPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcClearPrimaryAdapterTask", 0x593087b1)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);
    ASSERT(pAdapter->bind.pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == EPVC_AD_PS_INITED)
        ||  (PrimaryState == EPVC_AD_PS_FAILEDINIT)
        ||  (PrimaryState == EPVC_AD_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        EPVC_ASSOC_AD_PRIMARY_TASK,
        pSR
        );

    pAdapter->bind.pPrimaryTask = NULL;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
epvcSetSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcSetSecondaryAdapterTask", 0x56bbb567)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
               ((pfn == epvcTaskActivateAdapter) && (SecondaryState == EPVC_AD_AS_ACTIVATING))
            || ((pfn == epvcTaskDeactivateAdapter) && (SecondaryState == EPVC_AD_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        EPVC_ASSOC_ACTDEACT_AD_TASK,
        "   Secondary task\n",
        pSR
        );

    pAdapter->bind.pSecondaryTask = pTask;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}


VOID
epvcClearSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcClearSecondaryAdapterTask", 0x698552bd)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == EPVC_AD_AS_ACTIVATED)
        ||  (SecondaryState == EPVC_AD_AS_FAILEDACTIVATE)
        ||  (SecondaryState == EPVC_AD_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        EPVC_ASSOC_ACTDEACT_AD_TASK,
        pSR
        );

    pAdapter->bind.pSecondaryTask = NULL;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}



NDIS_STATUS
epvcCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        )
/*++

Routine Description:

    Copy the contents of unicode string pSrc into pDest.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

    EXTRA EXTRA EXTRA:
        This make sure the destination is NULL terminated.
        IPAddInterface expects the Unicode string passed in to be
        NULL terminated.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS failure status on failure.
--*/
{
    USHORT Length = pSrc->Length;
    PWCHAR pwStr;
    epvcAllocateMemoryWithTag(&pwStr, Length+sizeof(WCHAR), MTAG_STRING);
    EPVC_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Length = Length;
        pDest->MaximumLength = Length+sizeof(WCHAR);

        pDest->Buffer = pwStr;

        {
            NdisMoveMemory(pwStr, pSrc->Buffer, Length);
            if (Length & 0x1)
            {
                ((PUCHAR)pwStr)[Length] = 0;
            }
            else
            {
                pwStr[Length/sizeof(*pwStr)] = 0;
            }
        }

        return NDIS_STATUS_SUCCESS;
    }
}





VOID
epvcSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

VOID
epvcClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

ULONG
epvcReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return *pulFlags;
}



BOOLEAN
epvcIsThisTaskPrimary (
    PRM_TASK pTask,
    PRM_TASK* ppLocation 
    )
{
    BOOLEAN fIsThisTaskPrimary = FALSE;

    ASSERT (*ppLocation != pTask);

    if (*ppLocation  == NULL)
    {
        *ppLocation = pTask;
        return TRUE;
    }
    else
    {
        return FALSE;
        
    }
}

VOID
epvcClearPrimaryTask (
    PRM_TASK* ppLocation 
    )
{

        *ppLocation = NULL;

}



#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "EPVC: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "EPVC: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif

#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "EPVC: %p: ", p );
    else
        DbgPrint( "EPVC: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif





VOID
epvcInitializeLookasideList(
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    )
/*++

Routine Description:
  Allocates and initializes a epvc Lookaside list

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Mp, ( "==> epvcInitializeLookasideList pLookaside List %x, size %x, Tag %x, Depth %x, ", 
                                pLookasideList, Size, Tag, Depth) );
                             
    NdisInitializeNPagedLookasideList( &pLookasideList->List,
                                       NULL,                        //Allocate 
                                       NULL,                            // Free
                                       0,                           // Flags
                                       Size,
                                       Tag,
                                       Depth );                             // Depth

    pLookasideList->Size =  Size;
    pLookasideList->bIsAllocated = TRUE;

    TRACE( TL_T, TM_Mp, ( "<== epvcInitializeLookasideList " ) );
}   
                                  

VOID
epvcDeleteLookasideList (
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    )

/*++

Routine Description:
    Deletes a lookaside list, only if it has been allocated

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Mp, ( "==> epvcDeleteLookasideList  pLookaside List %x",pLookasideList ) );

    if (pLookasideList && pLookasideList->bIsAllocated == TRUE)
    {
        while (pLookasideList->OutstandingPackets != 0)
        {
            NdisMSleep( 10000);
        
        }
        
        NdisDeleteNPagedLookasideList (&pLookasideList->List);
    }

    TRACE( TL_T, TM_Mp, ( "<== epvcDeleteLookasideList pLookaside List %x", pLookasideList) );
    
}


PVOID
epvcGetLookasideBuffer(
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
    // Function Description:
    //    Allocate an buffer from the lookaside list.
    //    will be changed to a macro
    //
    //
    //
    // Arguments
    //  Lookaside list - from which the buffer is allocated
    //
    //
    // Return Value:
    //  Return buffer can be NULL
    //
{

    PVOID pLocalBuffer = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>epvcGetLookasideBuffer pList %x",pLookasideList) );
    
    ASSERT (pLookasideList != NULL);

    //
    // Optimize the lookaside list code path
    //
    pLocalBuffer = NdisAllocateFromNPagedLookasideList (&pLookasideList->List);

    if (pLocalBuffer != NULL)
    {   
        NdisZeroMemory (pLocalBuffer, pLookasideList->Size); 
        NdisInterlockedIncrement (&pLookasideList->OutstandingPackets);
    }
    else
    {
        epvcIncrementMallocFailure();
    }

        
    
    TRACE( TL_T, TM_Send, ( "<==epvcGetLookasideBuffer, %x", pLocalBuffer ) );
    
    return pLocalBuffer ;

}


VOID
epvcFreeToNPagedLookasideList (
    IN PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    )

    // Function Description:
    //   Return the local buffer to the lookaside list
    //
    // Atguments
    // Lookaside list and its buffer
    // Return Value:
    // None 
{

    
    TRACE( TL_T, TM_Send, ( "==> epvcFreeToNPagedLookasideList , Lookaside list %x, plocalbuffer %x",pLookasideList, pBuffer ) );

    NdisFreeToNPagedLookasideList (&pLookasideList->List, pBuffer);     
    NdisInterlockedDecrement (&pLookasideList->OutstandingPackets);

    TRACE( TL_T, TM_Send, ( "<== epvcFreeToNPagedLookasideList ") );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\rm.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.h

Abstract:

    "Resource Manager" structures and APIs

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created

--*/

//=================================================================================
//                  O S - S P E C I F I C   T Y P E S
//=================================================================================

#define RM_OS_LOCK                          NDIS_SPIN_LOCK
#define OS_WORK_ITEM                        NDIS_WORK_ITEM
#define OS_TIMER                            NDIS_TIMER

#define RM_STATUS                            NDIS_STATUS

#define RM_OS_FILL_MEMORY(_dest, _len, _fill) NdisFillMemory(_dest, _len, _fill)
#define RM_OS_ZERO_MEMORY(_dest, _len)        NdisZeroMemory(_dest, _len)
#define RM_OS_GET_CURRENT_THREAD_HANDLE()     NULL

// If set, the object tree is explicitly maintained.
//
#define RM_TRACK_OBJECT_TREE 1

//=================================================================================
//                  F O R W A R D       R E F E R E N C E S
//=================================================================================

typedef struct _RM_STACK_RECORD     RM_STACK_RECORD,        *PRM_STACK_RECORD;
typedef struct _RM_OBJECT_HEADER    RM_OBJECT_HEADER,       *PRM_OBJECT_HEADER;
typedef struct _RM_TASK             RM_TASK,                *PRM_TASK;
typedef struct _RM_RESOURCE_TABLE_ENTRY
                                RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


//=================================================================================
//                  T Y P E D E F S
//=================================================================================

//
// RM_DBG_LOCK_INFO Keeps debugging information specific to an instance of a RM_LOCK.
//
typedef struct _RM_DBG_LOCK_INFO
{
    //
    // If nonzero, LocID is a magic number which uniquely identifies the source
    // location where the lock was aquired.
    //
    ULONG uLocID;

    //
    // pSR points to the stack record of the currently owning thread, if there
    // is one. If a function F expects an object pObj to be locked on entry,
    // it can  ASSERT(pObj->pLock->pDbgInfo->pSR == pSR);
    //
    struct _RM_STACK_RECORD *pSR;


} RM_DBG_LOCK_INFO, *PRM_DBG_LOCK_INFO;

//
// RM_LOCK keeps information about a lock.
//
typedef struct _RM_LOCK
{
    //
    // Native, os-provided lock structure.
    //
    RM_OS_LOCK OsLock;

    //
    // Level of this lock. Multiple locks can only be acquired in increasing order
    // of this value.
    //
    ULONG Level;

    //
    // Pointer to debugging info for this lock. Could be NULL.
    //
    PRM_DBG_LOCK_INFO pDbgInfo;

#if RM_EXTRA_CHECKING
    RM_DBG_LOCK_INFO DbgInfo;
#endif // RM_EXTRA_CHECKING

} RM_LOCK, *PRM_LOCK;


typedef
ULONG
(*PFNLOCKVERIFIER) (
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
    );

// RM_LOCKING_INFO keeps information about a particular lock being held.
// In non-checking mode, this is just the pointer to the lock.
// In checking mode, this additionally contains information that can be used
// to verify that the entity being protected by the lock is not changed when
// the lock is not being held.
//
typedef struct
{
    PRM_LOCK pLock;

#if RM_EXTRA_CHECKING
    PFNLOCKVERIFIER pfnVerifier;
    PVOID           pVerifierContext;
#endif // RM_EXTRA_CHECKING

}  RM_LOCKING_INFO, PRM_LOCKING_INFO;

//
// RM_STACK_RECORD keeps information relevant to the current call tree.
//
typedef struct _RM_STACK_RECORD
{
    //
    // LockInfo contains information about currently-held locks.
    //
    struct
    {
        //
        // Level of the currently held lock. Locks must be claimed in
        // order of increasing Level values. The lowest level value is 1. Level
        // 0 indicates no locks held.
        //
        UINT    CurrentLevel;

        //
        // Pointer to the first location to store a pointers to a locks.
        //
        PRM_LOCKING_INFO *pFirst;

        //
        // Pointer to the next free location to store a pointer to a lock
        // that has been claimed in this call tree.
        //
        PRM_LOCKING_INFO *pNextFree;

        //
        // Pointer to the last valid location to store a lock pointer.
        //
        PRM_LOCKING_INFO *pLast;

    } LockInfo;


    //
    // Count of tmp refs taken with this stack record.
    //
    ULONG TmpRefs;

#if DBG

    //
    // DbgInfo contains diagnostic information relevant to this call tree.
    //
    struct
    {
        //
        // Verbosity level
        //
        ULONG Level;

        //
        //  Points to the os-provided thread handle of the current thread.
        //  if there is one.
        //
        PVOID pvThread;


    } DbgInfo;

#endif // DBG

} RM_STACK_RECORD, *PRM_STACK_RECORD;

#if DBG
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)                \
        _sr.DbgInfo.Level           = _dbglevel;                    \
        _sr.DbgInfo.pvThread        = RM_OS_GET_CURRENT_THREAD_HANDLE();
#else
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)
#endif 

//
// RM_DECLARE_STACK_RECORD_EX is a macro to reserve some stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD_EX(_sr, _max_locks, _dbglevel)      \
    RM_LOCKING_INFO rm_lock_array[_max_locks];                      \
    RM_STACK_RECORD _sr;                                            \
    RM_OS_ZERO_MEMORY(rm_lock_array, sizeof(rm_lock_array));        \
    _sr.TmpRefs                 = 0;                                \
    _sr.LockInfo.CurrentLevel   = 0;                                \
    _sr.LockInfo.pFirst     = rm_lock_array;                    \
    _sr.LockInfo.pNextFree  = rm_lock_array;                    \
    _sr.LockInfo.pLast      = rm_lock_array+(_max_locks)-1;     \
    RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel);


//
// RM_DECLARE_STACK_RECORD is a macro to reserve default stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD(_sr)                                \
    RM_DECLARE_STACK_RECORD_EX(_sr, 4, 0)



//
// Generic memory allocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_ALLOCATOR)(
    PVOID pAllocationContext,
    UINT  Size                  // in bytes
    );

//
// Generic memory deallocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_DEALLOCATOR)(
    PVOID pMem,
    PVOID pAllocationContext
    );


//  RM_HASH_LINK is the field in the structures being hashed that is
//  used to link all items in the same bucket. It also contains the
//  "HashKey", which is a potentially-nonunique UINT-sized hash of the
//  real key.
//
typedef struct _RM_HASH_LINK
{
    struct _RM_HASH_LINK *pNext;
    UINT                  uHash;
} RM_HASH_LINK, *PRM_HASH_LINK;


//
// Hash table comparison function.
//
typedef
BOOLEAN
(*PFN_RM_COMPARISON_FUNCTION)(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );


//
// Hash computation function.
//
typedef
ULONG
(*PFN_RM_HASH_FUNCTION)(
    PVOID           pKey
    );


//
// RM_HASH_INFO specifies customizing information about a hash table.
//
typedef struct
{
    // Allocator used to allocate the hash table if it needs to grow.
    //
    PFN_RM_MEMORY_ALLOCATOR pfnTableAllocator;

    // Free function for the above allocator.
    PFN_RM_MEMORY_DEALLOCATOR pfnTableDeallocator;

    // Comparison function for strict equality.
    //
    PFN_RM_COMPARISON_FUNCTION pfnCompare;

    // Function to generate a ULONG-sized hash.
    //
    PFN_RM_HASH_FUNCTION pfnHash;

#if OBSOLETE
    // Offset in sizeof(UINT) to location of the place to keep
    // the next pointer for the bucket list.
    //
    UINT    OffsetNext;

    // Offset in sizeof(UINT) to location of UINT-sized Temp ref
    //
    UINT    OffsetTmpRef;

    // Offset in sizeof(UINT) to location of UINT-sized Tot ref
    //
    UINT    OffsetTotRef;

    // Offset in sizeof(UINT) to location of ULONG-sized hash key.
    //
    UINT    OffsetHashKey;
#endif // OBSOLETE

} RM_HASH_INFO, *PRM_HASH_INFO;

#define RM_MIN_HASH_TABLE_SIZE 4

//
// RM_HASH_TABLE is a hash table.
//
typedef struct
{
    //  Number of items currently in hash table.
    //
    UINT NumItems;

    //  Stats is a 32-bit quantity keeps a running total of number of accesses
    //  (add+search+remove) in the HIWORD and the total number of list nodes
    //  traversed in the LOWORD. This field gets updated even on searches, but
    //  it is not protected by the hash table lock -- instead it is
    //  updated using  an interlocked operation. This allows us to use
    //  a read lock for searches while still updating this statistic value.
    //  The Stats field is re-scaled when the counts get too high, to avoid
    //  overflow and also to favor more recent stats in preference to older
    //  stats.
    //
    //  NumItems, Stats and TableLength are used to decide whether to
    //  dynamically resize the hash table.
    //
    ULONG Stats;

    //  Length of hash table in units of PVOID
    //
    ULONG TableLength;

    // Pointer to TableLength-sized array of PVOIDs -- this is the actual hash table
    //
    PRM_HASH_LINK *pTable;


    // The hash table
    //
    PRM_HASH_LINK InitialTable[RM_MIN_HASH_TABLE_SIZE];

    // Static information about this hash table.
    //
    PRM_HASH_INFO pHashInfo;

    // Passed into the allocate/deallocate functions.
    //
    PVOID pAllocationContext;

} RM_HASH_TABLE, *PRM_HASH_TABLE;

// Returns approximate value of (num-nodes-traversed)/(num-accesses)
//
#define RM_HASH_TABLE_TRAVERSE_RATIO(_pHash_Table) \
            (((_pHash_Table)->Stats & 0xffff) / (1+((_pHash_Table)->Stats >> 16)))
            //
            // NOTE: the "1+" above is simply to guard against devide-by-zero.


//
// RM_OBJECT_DIAGNOSTIC_INFO keeps diagnostic info specific to an instance of
// an object.
//
// This structure is for private use of the RM APIs.
// The only field of general interest is PrevState.
//
typedef struct
{
    // Back pointer to owning object.
    //
    RM_OBJECT_HEADER *pOwningObject;

    // Each time the object-specific State field is updated, it's previous
    // value is saved here.
    //
    ULONG               PrevState;

    // Used for correctly updating PrevState.
    //
    ULONG               TmpState;

    // Diagnostic-related state.
    //
    ULONG               DiagState;
    #define fRM_PRIVATE_DISABLE_LOCK_CHECKING (0x1<<0)

    // This is an object-specific checksum that is computed and 
    // saved just before the object is unlocked. It is  checked
    // just after the object is locked.
    //
    ULONG               Checksum;

    // Native OS lock to be *only* to serialize access to the information
    // in this structure.
    //
    RM_OS_LOCK          OsLock;

    // Keeps an associative list of all entities which have been registered
    // (using RmDbgAddAssociation) with this object. Ths includes objects which
    // have been linked to this object using the RmLinkObjects call, as well
    // as childen and parents of this object.
    //
    RM_HASH_TABLE       AssociationTable;

    // Following is set to TRUE IFF  there was an allocation failure when trying to
    // add an association. If there'e been an allocation failure, we don't complain
    // (i.e. ASSERT) if an attempt is made to remove an assertion that doesn't
    // exist. In this way we gracefully deal with allocation failures of the
    // association table entries.
    //
    INT                 AssociationTableAllocationFailure;

    // The per-object list of log entries.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    LIST_ENTRY          listObjectLog;

    // Count of entries in this object's log.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    UINT                NumObjectLogEntries;

#if TODO    // We haven't implemented the following yet...

    // Future:
    // RM_STATE_HISTORY -- generalization of PrevState.

#endif //  TODO


} RM_OBJECT_DIAGNOSTIC_INFO, *PRM_OBJECT_DIAGNOSTIC_INFO;

typedef
PRM_OBJECT_HEADER
(*PFN_CREATE_OBJECT)(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

typedef
VOID
(*PFN_DELETE_OBJECT)(PRM_OBJECT_HEADER, PRM_STACK_RECORD psr);


//
// RM_STATIC_OBJECT_INFO keeps information that is common to all instances of
// a particular type of object.
//
typedef struct
{
    ULONG   TypeUID;
    ULONG   TypeFlags;
    char*   szTypeName;
    UINT    Timeout;

    //
    // Various Handlers
    //
    PFN_CREATE_OBJECT           pfnCreate;
    PFN_DELETE_OBJECT           pfnDelete;
    PFNLOCKVERIFIER             pfnLockVerifier;

    //
    // Resource Information
    //
    UINT    NumResourceTableEntries;
    struct  _RM_RESOURCE_TABLE_ENTRY *  pResourceTable;

    //
    // Hash-table info, if this object is part of a group.
    //
    PRM_HASH_INFO pHashInfo;

} RM_STATIC_OBJECT_INFO, *PRM_STATIC_OBJECT_INFO;

//
// RM_OBJECT_HEADER is the common header for all objects.
//
typedef struct _RM_OBJECT_HEADER
{
    //
    // Object-type-specific signature.
    //
    ULONG Sig;

    //
    // Description of this object (could be the same as pStaticInfo->szTypeName,
    // but may be something more specific).
    // Used only for debugging purposes.
    // TODO: consider moving this into the pDiagInfo struct. For now, leave it
    // here because it's useful when debugging.
    //
    const char *szDescription;

    //
    // Object-specific state.
    //
    ULONG State;

    ULONG RmState; // One or more RMOBJSTATE_* or RMTSKSTATE_* flags below...

    //
    // RM state flags....
    //
    
    // Object allocation state...
    //
    #define RMOBJSTATE_ALLOCMASK        0x00f
    #define RMOBJSTATE_ALLOCATED        0x001
    #define RMOBJSTATE_DEALLOCATED      0x000

    // Task state ...
    //
    #define RMTSKSTATE_MASK             0x0f0
    #define RMTSKSTATE_IDLE             0x000
    #define RMTSKSTATE_STARTING         0x010
    #define RMTSKSTATE_ACTIVE           0x020
    #define RMTSKSTATE_PENDING          0x030
    #define RMTSKSTATE_ENDING           0x040

    //  Task delay state
    //
    #define RMTSKDELSTATE_MASK          0x100
    #define RMTSKDELSTATE_DELAYED       0x100

    //  Task abort state
    //
    #define RMTSKABORTSTATE_MASK        0x200
    #define RMTSKABORTSTATE_ABORT_DELAY 0x200

    //
    // Bitmap identifying resources used by this object.
    //
    ULONG ResourceMap;

    // Total reference count.
    //
    //
    ULONG TotRefs;


    //
    // Pointer to a RM_LOCK object used to serialize access to this object.
    //
    PRM_LOCK pLock;

    //
    // Pointer to information common to all instances of this object type.
    //
    PRM_STATIC_OBJECT_INFO    pStaticInfo;

    //
    // Points to diagnostic information about this object.  Could be NULL.
    //
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;


    //
    //  Points to the parent object.
    //
    struct _RM_OBJECT_HEADER *pParentObject;

    //
    //  Points to the root (ancestor of all object) -- could be the same
    //  as pParentObject;
    //
    struct _RM_OBJECT_HEADER *pRootObject;

    //
    // This is a private lock used exclusively by the RM apis. It is
    // never left unlocked by the RM apis.
    // TODO: maybe make this a native-os lock.
    //
    RM_LOCK RmPrivateLock;

    // Used to create groups of objects.
    // TODO: make this a private field, present only if the object is
    // meant to be in a group.
    //
    RM_HASH_LINK HashLink;

#if RM_TRACK_OBJECT_TREE
    LIST_ENTRY          listChildren; // Protected by this object's RmPrivateLock.
    LIST_ENTRY          linkSiblings; // Protected by parent object's RmPrivateLock.
    
#endif // RM_TRACK_OBJECT_TREE

    ULONG TempRefs;

} RM_OBJECT_HEADER, *PRM_OBJECT_HEADER;


//
// Diagnostic resource tracking.
//
typedef struct
{
    ULONG_PTR               Instance;
    ULONG                   TypeUID;
    PRM_OBJECT_HEADER       pParentObject;
    ULONG                   CallersUID;
    ULONG                   CallersSrUID;

} RM_DBG_RESOURCE_ENTRY;


typedef enum
{
    RM_RESOURCE_OP_LOAD,
    RM_RESOURCE_OP_UNLOAD

} RM_RESOURCE_OPERATION;

typedef
RM_STATUS
(*PFN_RM_RESOURCE_HANDLER)(
    PRM_OBJECT_HEADER       pObj,
    RM_RESOURCE_OPERATION   Op,
    PVOID                   pvUserParams,
    PRM_STACK_RECORD        psr
);

typedef struct _RM_RESOURCE_TABLE_ENTRY
{
    UINT                    ID;
    PFN_RM_RESOURCE_HANDLER pfnHandler;
    
} RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


typedef struct
{
    UINT u;

} RM_OBJECT_INDEX,  *PRM_OBJECT_INDEX;


typedef struct
{
    PRM_OBJECT_HEADER           pOwningObject;
    const char *                szDescription;
    PRM_STATIC_OBJECT_INFO      pStaticInfo;
    RM_HASH_TABLE               HashTable;


    // Private lock used ONLY by group access functions.
    //
    RM_OS_LOCK                      OsLock;

    // When non-NULL, points to the task responsible for unloading all objects
    // in this group.
    //
    PRM_TASK                    pUnloadTask;

    BOOLEAN fEnabled;

} RM_GROUP,  *PRM_GROUP;


typedef enum
{
    RM_TASKOP_START,
    RM_TASKOP_PENDCOMPLETE,
    RM_TASKOP_END,
    RM_TASKOP_PRIVATE,
    RM_TASKOP_ABORT,
    RM_TASKOP_TIMEOUT

} RM_TASK_OPERATION;


typedef
RM_STATUS
(*PFN_RM_TASK_HANDLER)(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Op,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
//
// For START and PENDCOMPLETE, a return value other than PENDING causes
// the task to end. Of course, it is illegal to return non-pending when
// the task is in a pending state.
//


// Task allocator prototype
//
typedef
RM_STATUS
(*PFN_RM_TASK_ALLOCATOR)(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

typedef struct _RM_TASK
{
    RM_OBJECT_HEADER                Hdr;

    PFN_RM_TASK_HANDLER             pfnHandler;
    LIST_ENTRY                      linkFellowPendingTasks;
    LIST_ENTRY                      listTasksPendingOnMe;
    struct _RM_TASK *               pTaskIAmPendingOn;


    // In the case that we need to asynchronously notify the completion of a
    // pending operation, we can save the completion param here.
    //
    UINT_PTR                        AsyncCompletionParam;

    UINT                            SuspendContext;

} RM_TASK, *PRM_TASK;

typedef
VOID
(*PFN_DBG_DUMP_LOG_ENTRY) (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);


#if RM_EXTRA_CHECKING

// (For debugging only)
// Keeps track of a single association (See RmDbgAddAssociation)
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    ULONG           LocID;
    ULONG_PTR       Entity1;
    ULONG_PTR       Entity2;
    ULONG           AssociationID;
    const char *    szFormatString;
    RM_HASH_LINK    HashLink;

} RM_PRIVATE_DBG_ASSOCIATION;

// (For debugging only)
// Keeps track of a single per-object log entry.
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    // Link to other entries for this object
    //
    LIST_ENTRY linkObjectLog;

    // Link to other entries in the global list.
    //
    LIST_ENTRY linkGlobalLog;

    // Object this entry belongs to
    //
    PRM_OBJECT_HEADER   pObject;

    // Function to be used for dumping the log.
    //
    PFN_DBG_DUMP_LOG_ENTRY pfnDumpEntry;

    // Prefix string to be dumped *before* the log display.
    // This was added so we could log associations properly, otherwise it's
    // extra baggage. Can be null.
    //
    char *szPrefix;

    // Format string for log display -- 1st arg to pfnDumpEntry
    //
    char *szFormatString;

    // Remaining args to pfnDumpEntry;
    //
    //
    UINT_PTR Param1;
    UINT_PTR Param2;
    UINT_PTR Param3;
    UINT_PTR Param4;

    // If non-NULL, piece of memory to be freed when the log entry is freed.
    // TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    // on how we will find the deallocator function. For now we simply
    // use NdisFreeMemory.
    //
    PVOID pvBuf;

} RM_DBG_LOG_ENTRY;

#endif RM_EXTRA_CHECKING

//=================================================================================
//                      U T I L I T Y       M A C R O S
//=================================================================================

#define RM_PARENT_OBJECT(_pObj)             \
            ((_pObj)->Hdr.pParentObject)

#define RM_PEND_CODE(_pTask)                \
            ((_pTask)->SuspendContext)

#define RM_ASSERT_SAME_LOCK_AS_PARENT(_pObj)                                        \
                ASSERTEX(                                                       \
                    ((_pObj)->Hdr.pLock == (_pObj)->Hdr.pParentObject->pLock),  \
                    (_pObj))

#define RM_SET_STATE(_pObj, _Mask, _Val)    \
            (((_pObj)->Hdr.State) = (((_pObj)->Hdr.State) & ~(_Mask)) | (_Val))

#define RM_CHECK_STATE(_pObj, _Mask, _Val)  \
            ((((_pObj)->Hdr.State) & (_Mask)) == (_Val))

#define RM_GET_STATE(_pObj, _Mask)  \
            (((_pObj)->Hdr.State) & (_Mask))

// Asserts that the object is in the "zombie" state, i.e., it
// lives on just because of references.
// WARNING: It is upto the caller to synchronize access to this -- for example
// if they're going to do thing's like if (!RM_IS_ZOMBIE(pObj)) {do-stuff}, they
// had better make sure that only one of them goes on to "does-stuff".
//
#define RM_IS_ZOMBIE(_pobj) \
            (((_pobj)->Hdr.RmState&RMOBJSTATE_ALLOCMASK)==RMOBJSTATE_DEALLOCATED)

// Asserts that no locks are held.
//
#define RM_ASSERT_NOLOCKS(_psr) \
        ASSERTEX((_psr)->LockInfo.CurrentLevel == 0, (_psr))

// Assert that no locks or tmprefs are held.
//
#define RM_ASSERT_CLEAR(_psr) \
        ASSERTEX(((_psr)->LockInfo.CurrentLevel==0), (_psr)); \
        ASSERTEX((_psr)->TmpRefs==0, (_psr));

#if RM_EXTRA_CHECKING

//
// TODO: rename the following to something better...
//

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   \
    ASSERTEX((_pLk)->DbgInfo.pSR == (_pSR), (_pHdr))

// TODO -- replace calls to this by calls to RM_ASSERT_OBJLOCKED
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

// Note that we can't assume DbgInfo.pSR is NULL below (it could be locked
// by some other thread), but we CAN assert that DbgInfo.pSR is not equal to the
// current pSR!
//
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR != (_pSR), (_pHdr))

#else // !RM_EXTRA_CHECKING

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   (0)
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   (0)
#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    (0)
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  (0)


#endif // !RM_EXTRA_CHECKING

#define RM_NUM_ITEMS_IN_GROUP(_pGroup) \
            ((_pGroup)->HashTable.NumItems)

//=================================================================================
//                  F U N C T I O N     P R O T O T Y P E S
//=================================================================================

VOID
RmInitializeRm(VOID);

VOID
RmDeinitializeRm(VOID);

VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    );
//
// Object allocation and deallocation APIs
//

VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    );


//
// locking
//

VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    );

VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if TODO
VOID
RmDoReadLock(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmDoReadLock    RmDoWriteLock
#endif //!TODO

VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );


#if TODO
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmReadLockObject RmWriteLockObject
#endif //!TODO

VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            
    );

//
// reference counting
//

VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Generic resource management
//

RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Diagnostic per-object tracking of arbitrary "associations"
//

//
// NOTE: AssociationID must not have the high-bit set. Associations with the
// high bit set are reserved for internal use of the Rm API implementation.
//

VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Instance1,
    IN  ULONG_PTR                   Instance2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgPrintAssociations(
    IN  PRM_OBJECT_HEADER pObject,
    IN  PRM_STACK_RECORD pSR
    );

//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    );


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    );

VOID
RmDbgPrintGlobalLog(VOID);

//
// Groups of Objects
//


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );

RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // Lookup flags defined below
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated,
    IN  PRM_STACK_RECORD            pSR
    );

//
//  Lookup flags
//
#define RM_CREATE       0x1
#define RM_NEW          (0x1<<1)
#define RM_LOCKED       (0x1<<2)


#define RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _pParams, _ppHdr, _fC,_psr)\
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_CREATE|RM_NEW|RM_LOCKED,                             \
                            (_pKey),                                                \
                            (_pParams),                                             \
                            (_ppHdr),                                               \
                            (_fC),                                                  \
                            (_psr)                                                  \
                            );

// RM_STATUS
// RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(
//                  PRM_GROUP           _pGrp,
//                  PVOID               _pKey,
//                  PRM_OBJECT_HEADER * _ppHdr,
//                  PRM_STACK_RECORD    _psr
//                  )
// Lookup (don't create) and lock an object in the specified group.
//
#define RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _ppHdr, _psr)              \
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_LOCKED,                                              \
                            (_pKey),                                                \
                            NULL,                                                   \
                            (_ppHdr),                                               \
                            NULL,                                                   \
                            (_psr)                                                  \
                            );

RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject,     OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );



// Enumeration function prototype. This function is passed into
// RmEnumerateObjectsInGroup and gets called for each object in the group
// until the function returns FALSE.
//
typedef
INT
(*PFN_RM_GROUP_ENUMERATOR) (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    );

VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );

//
// Task APIs
//

VOID
RmInitializeTask(
IN  PRM_TASK                    pTask,
IN  PRM_OBJECT_HEADER           pParentObject,
IN  PFN_RM_TASK_HANDLER         pfnHandler,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
IN  const char *                szDescription,  OPTIONAL
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmStartTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmAbortTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmDbgDumpTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmSuspendTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmUnsuspendTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskAsync(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  OS_WORK_ITEM            *   pOsWorkItem,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskDelayed(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  ULONG                       MsDelay,
IN  OS_TIMER                *   pOsTimerObject,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmResumeDelayedTaskNow(
IN  PRM_TASK                    pTask,
IN  OS_TIMER                *   pOsTimer,
OUT PUINT                       pTaskResumed,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmPendTaskOnOtherTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

// See  03/26/1999 notes.txt entry "Some proposed ..."
//
RM_STATUS
RmPendOnOtherTaskV2(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmCancelPendOnOtherTask(
IN  PRM_TASK                    pTask,
IN  PRM_TASK                    pOtherTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);

//
// Timer management
//
VOID
RmResetAgeingTimer(
IN  PRM_OBJECT_HEADER           pObj,
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);

//
// Hash table manipulation.
//

VOID
RmInitializeHashTable(
PRM_HASH_INFO pHashInfo,
PVOID         pAllocationContext,
PRM_HASH_TABLE pHashTable
);

VOID
RmDeinitializeHashTable(
PRM_HASH_TABLE pHashTable
);

BOOLEAN
RmLookupHashTable(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK **    pppLink,
PVOID               pvRealKey
);

BOOLEAN
RmNextHashTableItem(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
PRM_HASH_LINK *    ppNextLink
);

VOID
RmAddHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK * ppLink,
PRM_HASH_LINK   pLink,
PVOID           pvKey
);

VOID
RmRemoveHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK   pLinkToRemove
);

typedef
VOID
(*PFN_ENUM_HASH_TABLE)
(
PRM_HASH_LINK pLink,
PVOID pvContext,
PRM_STACK_RECORD pSR
);

VOID
RmEnumHashTable(
PRM_HASH_TABLE          pHashTable,
PFN_ENUM_HASH_TABLE     pfnEnumerator,
PVOID                   pvContext,
PRM_STACK_RECORD        pSR
);

#if OBSOLETE
//
// Indexes of objects.
//

RM_STATUS
RmAllocateObjectIndex(
IN  PRM_OBJECT_HEADER           pParentObject,
// OBSOLETE IN  PRM_OBJECT_ALLOCATOR        pObjectAllocator,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
IN  PULONG                      Flags,
OUT PRM_OBJECT_INDEX *          ppObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmFreeObjectIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmLookupObjectInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PULONG                      Flags, // create, remove, lock
IN  PVOID                       pvKey,
OUT PRM_OBJECT_HEADER *         ppObject,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmRemoveObjectFromIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_OBJECT_HEADER           pObject,
IN  PRM_STACK_RECORD            pSR
);

typedef
RM_STATUS
(*PFN_RM_OBJECT_INDEX_ENUMERATOR)(
IN  PRM_OBJECT_HEADER           pObject,
IN  PVOID                       pvContext,
IN  PRM_STACK_RECORD            pSR
);

RmEnumerateObjectsInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PFN_RM_OBJECT_INDEX_ENUMERATOR
                                pfnEnumerator,
IN  PRM_STACK_RECORD            pSR
);

#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\wrapper.c ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    wrapper.c

Abstract:

    This file contains wrapper for all function calls that call outside atmepvc.sys.

Author:

    ADube , 03/31/00

Environment:


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

VOID
epvcOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection,
    PRM_STACK_RECORD            pSR
    )
{
    TRACE (TL_T, TM_Pt, (" == NdisOpenProtocolConfiguration") );    

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenProtocolConfiguration(Status,
                             ConfigurationHandle,
                             ProtocolSection);

}



VOID
epvcOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle,
    PRM_STACK_RECORD            pSR
    )
{
    TRACE (TL_T, TM_Pt, (" == NdisOpenConfigurationKeyByName") );   

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenConfigurationKeyByName(
                                Status,
                                ConfigurationHandle,
                                SubKeyName,
                                SubKeyHandle
                                );


}



VOID
epvcOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle,
    PRM_STACK_RECORD            pSR
    
    )
{

    TRACE (TL_T, TM_Pt, (" == NdisOpenConfigurationKeyByIndex") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenConfigurationKeyByIndex(
                                Status,
                                ConfigurationHandle,
                                Index,
                                KeyName,
                                KeyHandle);

}



VOID
epvcOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL,
    PRM_STACK_RECORD            pSR
    )
{

    TRACE (TL_T, TM_Pt, (" == epvcOpenAdapter") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenAdapter(
        Status,
        OpenErrorStatus,
        NdisBindingHandle,
        SelectedMediumIndex,
        MediumArray,
        MediumArraySize,
        NdisProtocolHandle,
        ProtocolBindingContext,
        AdapterName,
        OpenOptions,
        AddressingInformation OPTIONAL
        );


}




VOID
epvcCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    PRM_STACK_RECORD            pSR
    )
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Pt, (" == epvcCloseAdapter") ); 
    NdisCloseAdapter(
        Status,
        NdisBindingHandle
        );

}


NDIS_STATUS
epvcClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    )

{

    TRACE (TL_T, TM_Pt, (" == epvcClOpenAddressFamily") );  
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClOpenAddressFamily(
                                NdisBindingHandle,
                                AddressFamily,
                                ProtocolAfContext,
                                ClCharacteristics,
                                SizeOfClCharacteristics,
                                NdisAfHandle
                                );
}



NDIS_STATUS
epvcCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle        OPTIONAL,   // For CM signalling VCs
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PNDIS_HANDLE         NdisVcHandle
    )
{


    TRACE (TL_T, TM_Pt, (" == epvcCoCreateVc") );
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisCoCreateVc(NdisBindingHandle,
                       NdisAfHandle     OPTIONAL,   // For CM signalling VCs
                       ProtocolVcContext,
                       NdisVcHandle
                       );

}

NDIS_STATUS
epvcClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle
    )
{

    TRACE (TL_T, TM_Pt, (" == EpvcClCloseCall") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClCloseCall( NdisVcHandle,
                            NULL,
                            NULL,
                            0);


}




NDIS_STATUS
epvcClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    )
{
    TRACE (TL_T, TM_Pt, (" == EpvcClMakeCall") );   
    ASSERT (NdisVcHandle != NULL);
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClMakeCall( NdisVcHandle,
                        CallParameters,
                        ProtocolPartyContext    OPTIONAL,
                        NdisPartyHandle         OPTIONAL
                        );


}



NDIS_STATUS
epvcCoDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    )
{

    TRACE (TL_T, TM_Pt, (" == epvcCoDeleteVc") );   

    ASSERT (NdisVcHandle!= NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisCoDeleteVc(NdisVcHandle);

}



NDIS_STATUS
epvcAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    )
{

    return NdisAllocateMemoryWithTag(
                           VirtualAddress,
                           Length,
                           Tag
                           );


}


VOID
epvcFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    )
{
    NdisFreeMemory( VirtualAddress,
                    Length,
                    MemoryFlags
                    );


}


VOID
epvcInitializeEvent(
    IN  PNDIS_EVENT             Event
)
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisInitializeEvent(Event);
}


BOOLEAN
epvcWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
)
{
    return (NdisWaitEvent(Event,msToWait));
}



VOID
epvcSetEvent(
    IN  PNDIS_EVENT             Event   
    )
{
    NdisSetEvent(Event);
}

VOID
epvcResetEvent(
    IN  PNDIS_EVENT             Event
    )
{
    
    NdisResetEvent(Event);
}



VOID
epvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
{
    TRACE (TL_T, TM_Cl, ("-- epvcCoRequestComplete"));
    NdisCoRequestComplete(Status,
                        NdisAfHandle,
                        NdisVcHandle    OPTIONAL,
                        NdisPartyHandle OPTIONAL,
                        NdisRequest
                         );



}



VOID
epvcEnumerateObjectsInGroup (
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
{


    RmWeakEnumerateObjectsInGroup(pGroup,
                                  pfnEnumerator,
                                  pvContext,
                                  pSR
                                  );

    return;

}



VOID
epvcAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PEPVC_PACKET_POOL       pPktPool,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
{

    EPVC_ZEROSTRUCT(pPktPool);

    NdisAllocatePacketPoolEx(
        Status,
        &pPktPool->Handle,
        NumberOfDescriptors,
        NumberOfOverflowDescriptors,
        ProtocolReservedLength
        );


}


VOID
epvcFreePacketPool(
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{
    //
    // Callable at PASSIVE ONLY
    //
    UINT i = 0;
    
    ASSERT (pPktPool->Handle != NULL);



    while (NdisPacketPoolUsage(pPktPool->Handle) != 0)
    {
        if (i >0)
        {
            TRACE (TL_I, TM_Mp, ("Looping in epvcFreePacketPool"));
        }
        NdisMSleep (10000); // 10 ms
        i++;
    }

    
    NdisFreePacketPool(pPktPool->Handle );

    // 
    // Zero out the Handle, 
    //
    EPVC_ZEROSTRUCT (pPktPool);
}



VOID
epvcAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{


    NdisAllocatePacket(Status,Packet,pPktPool->Handle);
    if (*Status == NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement (&pPktPool->AllocatedPackets);

    } 
    else
    {
        Packet = NULL;
    }

}


VOID 
epvcFreePacket (
    IN PNDIS_PACKET pPkt,
    IN PEPVC_PACKET_POOL pPool
    )
{

    NdisInterlockedDecrement (&pPool->AllocatedPackets);
    NdisFreePacket(pPkt);

}


VOID
epvcDprFreePacket(
    IN  PNDIS_PACKET            Packet,
    IN  PEPVC_PACKET_POOL       pPool
    )
{

    NdisInterlockedDecrement (&pPool->AllocatedPackets);
    NdisDprFreePacket(Packet);

}


VOID
epvcDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{
    NdisDprAllocatePacket(  Status,
                            Packet,
                            pPktPool->Handle    );


    if (*Status == NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement (&pPktPool->AllocatedPackets);

    } 
    else
    {
        Packet = NULL;
    }
    

}


NDIS_STATUS
epvcClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    )
{

    TRACE (TL_V, TM_Pt, ("epvcClCloseAddressFamily "));
    return NdisClCloseAddressFamily(NdisAfHandle);


}


VOID
epvcMIndicateStatus(
    IN  PEPVC_I_MINIPORT        pMiniport ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
{



    if (CanMiniportIndicate(pMiniport) == FALSE)
    {
        return;
    }
    


    NdisMIndicateStatus(pMiniport->ndis.MiniportAdapterHandle,
                        GeneralStatus,
                        StatusBuffer,
                        StatusBufferSize
                        );


}



VOID
epvcMIndicateReceivePacket(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PPNDIS_PACKET           ReceivedPackets,
    IN  UINT                    NumberOfPackets
    )
{

    NdisMIndicateReceivePacket(pMiniport->ndis.MiniportAdapterHandle,
                               ReceivedPackets,
                               NumberOfPackets  );




}



VOID
epvcFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    )
{
    NdisFreeBuffer(Buffer);

}



VOID
epvcAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
{

    NdisAllocateBuffer(Status,
                       Buffer,
                       PoolHandle,
                       VirtualAddress,
                       Length
                       );




}




VOID
epvcMSendComplete(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    IN NDIS_STATUS Status
    )
{
    epvcValidatePacket (pPkt);

    NdisMSendComplete(pMiniport->ndis.MiniportAdapterHandle,
                             pPkt,
                             Status);


}



VOID
epvcReturnPacketToNdis(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PNDIS_PACKET            pPacket,
    IN  PRM_STACK_RECORD        pSR
    )
{

    epvcValidatePacket (pPacket);
    NdisReturnPackets(&pPacket, 1 );

}



VOID
epvcInitializeWorkItem(
    IN  PRM_OBJECT_HEADER       pObj,   
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context,
    IN PRM_STACK_RECORD         pSR
    )
{




    NdisInitializeWorkItem(WorkItem,
                           Routine,
                           Context);


    NdisScheduleWorkItem(WorkItem);                            



}


VOID
epvcCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{

    ASSERT (NumberOfPackets == 1);
    epvcValidatePacket (*PacketArray);
    
    NdisCoSendPackets(NdisVcHandle,PacketArray,NumberOfPackets);


}

VOID
epvcQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    )
{


NdisQueryPacket(
    _Packet,
    _PhysicalBufferCount OPTIONAL,
    _BufferCount OPTIONAL,
    _FirstBuffer OPTIONAL,
    _TotalPacketLength OPTIONAL
    );



}


VOID
epvcIMDeInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport    
    )
{
    TRACE (TL_I, TM_Pt, ("    NdisIMDeInitializeDeviceInstance pMiniport %p", pMiniport) );

    NdisIMDeInitializeDeviceInstance(pMiniport->ndis.MiniportAdapterHandle);
}

NDIS_STATUS
epvcIMCancelInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport
    )

{
    NDIS_STATUS Status;
    TRACE (TL_I, TM_Pt, ("    NdisIMCancelInitializeDeviceInstance pMiniport %p", pMiniport) );

    Status = NdisIMCancelInitializeDeviceInstance (EpvcGlobals.driver.DriverHandle,&pMiniport->ndis.DeviceName);

    TRACE (TL_I, TM_Pt, ("    Status %x\n", Status) );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\wrapper.h ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    wrapper.c

Abstract:

    This file contains declarations for all wrapper function calls .

Author:

    ADube , 03/31/00

Environment:


Revision History:


--*/


#ifndef _ATMEPVC_WRAPPER
#define _ATMEPVC_WRAPPER 1


VOID
epvcOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection,
    PRM_STACK_RECORD            pSR
    );


VOID
epvcOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle,
    PRM_STACK_RECORD            pSR
    );



VOID
epvcOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle,
    PRM_STACK_RECORD            pSR
    
    );


VOID
epvcOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL,
    PRM_STACK_RECORD            pSR
    );


VOID
epvcCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    );

NDIS_STATUS
epvcCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle        OPTIONAL,   // For CM signalling VCs
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PNDIS_HANDLE         NdisVcHandle
    );

NDIS_STATUS
epvcClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    );


NDIS_STATUS
epvcClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle
    );

NDIS_STATUS
epvcAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    );

NDIS_STATUS
epvcCoDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );

VOID
epvcFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    );

VOID
epvcInitializeEvent(
    IN  PNDIS_EVENT             Event
);

BOOLEAN
epvcWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
);

VOID
epvcSetEvent(
    IN  PNDIS_EVENT             Event
    );

VOID
epvcResetEvent(
    IN  PNDIS_EVENT             Event
    );

VOID
epvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

VOID
epvcEnumerateObjectsInGroup (
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );


VOID
epvcAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PEPVC_PACKET_POOL       pPktPool,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

VOID
epvcFreePacketPool(
    IN  PEPVC_PACKET_POOL       pPktPool
    );

VOID 
epvcFreePacket (
    IN PNDIS_PACKET pPkt,
    IN PEPVC_PACKET_POOL pPool
    );
    
VOID
epvcAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    );


VOID
epvcDprFreePacket(
    IN  PNDIS_PACKET            Packet,
    IN  PEPVC_PACKET_POOL       pPool
    );

VOID
epvcDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    );

NDIS_STATUS
epvcClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    );

VOID
epvcMIndicateStatus(
    IN  PEPVC_I_MINIPORT        pMiniport ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );


VOID
epvcMIndicateReceivePacket(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PPNDIS_PACKET           ReceivedPackets,
    IN  UINT                    NumberOfPackets
    );

VOID
epvcFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    );



VOID
epvcAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    );

VOID
epvcMSendComplete(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    IN NDIS_STATUS Status
    );


VOID
epvcReturnPacketToNdis(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PNDIS_PACKET            pPacket,
    IN  PRM_STACK_RECORD        pSR
    );

VOID
epvcInitializeWorkItem(
    IN  PRM_OBJECT_HEADER       pObj,   
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context,
    IN  PRM_STACK_RECORD        pSR
    );

VOID
epvcCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

VOID
epvcQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );


VOID
epvcIMDeInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport    
    );

NDIS_STATUS
epvcIMCancelInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\epvc\sys\rmdbg.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    Debug-related definitions for RM Apis in ATMEPVC

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the EPVC driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

// Rm/generic tags
// 
#define MTAG_DBGINFO    'd31A'
#define MTAG_TASK       't31A'
#define MTAG_STRING     's31A'
#define MTAG_FREED      'z31A'
#define MTAG_RMINTERNAL 'r31A'


// Trace levels.
//
#define TL_FATAL    TL_A // Fatal errors -- always printed in checked build.
#define TL_WARN     TL_I // Warnings
#define TL_INFO     TL_N // Informational (highest level workable for general use)
#define TL_VERB     TL_V     // VERBOSE


#if DBG

#define TR_FATAL(Args)                                         \
    TRACE(TL_FATAL, TM_RM, Args)

#define TR_INFO(Args)                                          \
    TRACE(TL_INFO, TM_RM, Args)

#define TR_WARN(Args)                                          \
    TRACE(TL_WARN,TM_RM, Args)

#define TR_VERB(Args)                                          \
    TRACE(TL_VERB, TM_RM, Args)

#define ENTER(_Name, _locid)                                    \
    char *dbg_func_name =  (_Name);                             \
    UINT dbg_func_locid = (_locid);
    
#define EXIT()


// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                               \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !ASSERT( %s ) L:%d,F:%s\n",            \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define ASSERTEX(x, ctxt)                                       \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "Epvc: !ASSERT( %s ) C:0x%p L:%d,F:%s\n",     \
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

//
// DbgMark does nothing useful. But it is convenient to insert DBGMARK in
// places in your code while debugging, and set a breakpoint on DbgMark, so that
// the debugger will stop at the places you inserted DBGMARK. It's a bit more
// flexible than inserting a hardcoded DbgBreakPoint.
//
void DbgMark(UINT Luid);
#define DBGMARK(_Luid) DbgMark(_Luid)


#define DBGSTMT(_stmt)      _stmt

#define RETAILASSERTEX ASSERTEX
#define RETAILASSERT   ASSERT


// TRACE0 is like TRACE, except that it doesn't print the prefix.
//
#define TRACE0(ulLevel,  Args)                                  \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint Args;                                         \
    }                                                          \
}



#else // !DBG

#define TR_FATAL(Args)
#define TR_INFO(Args)
#define TR_WARN(Args)
#define TR_VERB(Args)
// Debug macros compile out of non-DBG builds.
//
#undef ASSERT
#define ASSERT(x)
#define ASSERTEX(x, ctxt)
#define ENTER(_Name, _locid)
#define EXIT()
#define DBGMARK(_Luid) (0)
#define DBGSTMT(_stmt)


#define RETAILASSERT(x)                                         \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !RETAILASSERT( %s ) L:%d,F:%s\n",      \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define RETAILASSERTEX(x, ctxt)                                 \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !RETAILASSERT( %s ) C:0x%p L:%d,F:%s\n",\
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

#endif



#if BINARY_COMPATIBLE
#define         ASSERT_PASSIVE() (0)
#else // !BINARY_COMPATIBLE
#define     ASSERT_PASSIVE() \
                ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL)
            
#endif // !BINARY_COMPATIBLE
//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\inc\atm40.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

	atm.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ATM aware components.

Author:

	Jameel Hyder - jameelh@microsoft.com

Revision History:

	Initial Version - March 1996
#ifdef MS_UNI4
	John Dalgas (v-jdalga)	09/18/97		added support for UNI4.0 ATM CM
#endif // MS_UNI4

--*/

#ifndef	_ATM_H_
#define	_ATM_H_

//
// Address type
//
typedef ULONG	ATM_ADDRESSTYPE;

#define	ATM_NSAP				0
#define	ATM_E164				1

//
// ATM Address
//
#define	ATM_MAC_ADDRESS_LENGTH	6		// Same as 802.x
#define	ATM_ADDRESS_LENGTH		20

//
//  Special characters in ATM address string used in textual representations
//
#define ATM_ADDR_BLANK_CHAR				L' '
#define ATM_ADDR_PUNCTUATION_CHAR		L'.'
#define ATM_ADDR_E164_START_CHAR		L'+'

typedef struct _ATM_ADDRESS
{
	ATM_ADDRESSTYPE				AddressType;
	ULONG						NumberOfDigits;
	UCHAR						Address[ATM_ADDRESS_LENGTH];
} ATM_ADDRESS, *PATM_ADDRESS;



//
// AAL types that the miniport supports
//
#define	AAL_TYPE_AAL0			1
#define	AAL_TYPE_AAL1			2
#define	AAL_TYPE_AAL34			4
#define	AAL_TYPE_AAL5			8

typedef ULONG	ATM_AAL_TYPE, *PATM_AAL_TYPE;


//
// Flags for Information Element types
//
#define ATM_IE_RESPONSE_FLAG		0x80000000
#define ATM_IE_EMPTY_FLAG			0x40000000


//
// Types of Information Elements
//
typedef enum
{
	// These identify request IEs
	IE_AALParameters,
	IE_TrafficDescriptor,
	IE_BroadbandBearerCapability,
	IE_BHLI,
	IE_BLLI,
	IE_CalledPartyNumber,
	IE_CalledPartySubaddress,
	IE_CallingPartyNumber,
	IE_CallingPartySubaddress,
	IE_Cause,
	IE_QOSClass,
	IE_TransitNetworkSelection,
	IE_BroadbandSendingComplete,
	IE_LIJCallId,
	IE_Raw,
#ifdef MS_UNI4
	IE_TrafficDescriptor_AddOn,
	IE_BroadbandBearerCapability_Uni40,
	IE_BLLI_AddOn,
	IE_ConnectionId,
	IE_NotificationIndicator,
	IE_MinimumTrafficDescriptor,
	IE_AlternativeTrafficDescriptor,
	IE_ExtendedQOS,
	IE_EndToEndTransitDelay,
	IE_ABRSetupParameters,
	IE_ABRAdditionalParameters,
	IE_LIJParameters,
	IE_LeafSequenceNumber,
	IE_ConnectionScopeSelection,
	IE_UserUser,
	IE_GenericIDTransport,
	IE_ConnectedNumber,					// invalid to use in request
	IE_ConnectedSubaddress,         	// invalid to use in request
#endif // MS_UNI4
	// End of request IEs
	IE_NextRequest,						// invalid to use in request

	// These identify empty IE buffers, to hold a possible response
	IE_Cause_Empty						= IE_Cause			   		| ATM_IE_EMPTY_FLAG,
#ifdef MS_UNI4
	IE_ConnectionId_Empty				= IE_ConnectionId			| ATM_IE_EMPTY_FLAG,
	IE_ConnectedNumber_Empty			= IE_ConnectedNumber		| ATM_IE_EMPTY_FLAG,
	IE_ConnectedSubaddress_Empty		= IE_ConnectedSubaddress	| ATM_IE_EMPTY_FLAG,
	IE_NotificationIndicator_Empty		= IE_NotificationIndicator	| ATM_IE_EMPTY_FLAG,
	IE_UserUser_Empty					= IE_UserUser				| ATM_IE_EMPTY_FLAG,
	IE_GenericIDTransport_Empty			= IE_GenericIDTransport		| ATM_IE_EMPTY_FLAG,
#endif // MS_UNI4

	// These identify response IEs
	IE_Cause_Response					= IE_Cause					| ATM_IE_RESPONSE_FLAG,
	IE_AALParameters_Response			= IE_AALParameters			| ATM_IE_RESPONSE_FLAG,
	IE_BLLI_Response					= IE_BLLI					| ATM_IE_RESPONSE_FLAG,
#ifdef MS_UNI4
	IE_BLLI_AddOn_Response				= IE_BLLI_AddOn			   	| ATM_IE_RESPONSE_FLAG,
	IE_TrafficDescriptor_Response		= IE_TrafficDescriptor		| ATM_IE_RESPONSE_FLAG,
	IE_TrafficDescriptor_AddOn_Response	= IE_TrafficDescriptor_AddOn| ATM_IE_RESPONSE_FLAG,
	IE_ConnectionId_Response			= IE_ConnectionId			| ATM_IE_RESPONSE_FLAG,
	IE_NotificationIndicator_Response	= IE_NotificationIndicator	| ATM_IE_RESPONSE_FLAG,
	IE_ExtendedQOS_Response				= IE_ExtendedQOS			| ATM_IE_RESPONSE_FLAG,
	IE_EndToEndTransitDelay_Response	= IE_EndToEndTransitDelay	| ATM_IE_RESPONSE_FLAG,
	IE_ABRSetupParameters_Response		= IE_ABRSetupParameters		| ATM_IE_RESPONSE_FLAG,
	IE_ABRAdditionalParameters_Response	= IE_ABRAdditionalParameters| ATM_IE_RESPONSE_FLAG,
	IE_ConnectedNumber_Response			= IE_ConnectedNumber		| ATM_IE_RESPONSE_FLAG,
	IE_ConnectedSubaddress_Response		= IE_ConnectedSubaddress	| ATM_IE_RESPONSE_FLAG,
	IE_UserUser_Response				= IE_UserUser				| ATM_IE_RESPONSE_FLAG,
	IE_GenericIDTransport_Response		= IE_GenericIDTransport		| ATM_IE_RESPONSE_FLAG,
#endif // MS_UNI4
} Q2931_IE_TYPE;



//
// Common header for each Information Element
//
typedef struct _Q2931_IE
{
	Q2931_IE_TYPE				IEType;
	ULONG						IELength;	// Bytes, including IEType and IELength fields
	UCHAR						IE[1];
} Q2931_IE, *PQ2931_IE;


//
// Definitions for SapType in CO_SAP
//
#define SAP_TYPE_NSAP			0x00000001
#define SAP_TYPE_E164			0x00000002

//
// Values used for the Mode field in AAL5_PARAMETERS
//
#define AAL5_MODE_MESSAGE			0x01
#define AAL5_MODE_STREAMING			0x02

//
// Values used for the SSCSType field in AAL5_PARAMETERS
//
#define AAL5_SSCS_NULL				0x00
#define AAL5_SSCS_SSCOP_ASSURED		0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED	0x02
#define AAL5_SSCS_FRAME_RELAY		0x04


//
// AAL Parameters
//
typedef struct _AAL1_PARAMETERS
{
	UCHAR						Subtype;
	UCHAR						CBRRate;
	USHORT						Multiplier;							// optional (exception: zero if absent)
	UCHAR						SourceClockRecoveryMethod;			// optional
	UCHAR						ErrorCorrectionMethod;				// optional
	USHORT						StructuredDataTransferBlocksize;	// optional (exception: zero if absent)
	UCHAR						PartiallyFilledCellsMethod;			// optional
} AAL1_PARAMETERS, *PAAL1_PARAMETERS;

typedef struct _AAL34_PARAMETERS
{
	USHORT						ForwardMaxCPCSSDUSize;
	USHORT						BackwardMaxCPCSSDUSize;
	USHORT						LowestMID;					// optional
	USHORT						HighestMID;					// optional
	UCHAR						SSCSType;					// optional
} AAL34_PARAMETERS, *PAAL34_PARAMETERS;

typedef struct _AAL5_PARAMETERS
{
	ULONG						ForwardMaxCPCSSDUSize;
	ULONG						BackwardMaxCPCSSDUSize;
	UCHAR						Mode;
	UCHAR						SSCSType;					// optional
} AAL5_PARAMETERS, *PAAL5_PARAMETERS;

typedef struct _AALUSER_PARAMETERS
{
	ULONG						UserDefined;
} AALUSER_PARAMETERS, *PAALUSER_PARAMETERS;

typedef struct _AAL_PARAMETERS_IE
{
	ATM_AAL_TYPE				AALType;
	union
	{
		AAL1_PARAMETERS			AAL1Parameters;
		AAL34_PARAMETERS		AAL34Parameters;
		AAL5_PARAMETERS			AAL5Parameters;
		AALUSER_PARAMETERS		AALUserParameters;
	} AALSpecificParameters;

} AAL_PARAMETERS_IE, *PAAL_PARAMETERS_IE;

//
// ATM Traffic Descriptor
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;			// optional
	ULONG						PeakCellRateCLP01;			// optional
	ULONG						SustainableCellRateCLP0;	// optional
	ULONG						SustainableCellRateCLP01;	// optional
	ULONG						MaximumBurstSizeCLP0;		// optional
	ULONG						MaximumBurstSizeCLP01;		// optional
	BOOLEAN						Tagging;
} ATM_TRAFFIC_DESCRIPTOR, *PATM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR		BackwardTD;
	BOOLEAN						BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE, *PATM_TRAFFIC_DESCRIPTOR_IE;


#ifdef MS_UNI4
//
// ATM Traffic Descriptor Add-On for UNI 4.0+
//
// REQUIREMENT: An add-on IE must follow immediately after its ancestor IE.
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR_ADDON	// For one direction
{
	ULONG						ABRMinimumCellRateCLP01;	// optional
	BOOLEAN						FrameDiscard;
} ATM_TRAFFIC_DESCRIPTOR_ADDON, *PATM_TRAFFIC_DESCRIPTOR_ADDON;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE_ADDON
{
	ATM_TRAFFIC_DESCRIPTOR_ADDON		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR_ADDON		BackwardTD;
} ATM_TRAFFIC_DESCRIPTOR_IE_ADDON, *PATM_TRAFFIC_DESCRIPTOR_IE_ADDON;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Alternative Traffic Descriptor IE for UNI 4.0+
//
typedef struct ATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR_IE			Part1;
	ATM_TRAFFIC_DESCRIPTOR_IE_ADDON		Part2;
} ATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE, *PATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// ATM Minimum Acceptable Traffic Descriptor
//
typedef struct _ATM_MINIMUM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;			// optional
	ULONG						PeakCellRateCLP01;			// optional
	ULONG						MinimumCellRateCLP01;		// optional
} ATM_MINIMUM_TRAFFIC_DESCRIPTOR, *PATM_MINIMUM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_MINIMUM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_MINIMUM_TRAFFIC_DESCRIPTOR		BackwardTD;
} ATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE, *PATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE;

#endif // MS_UNI4


//
// values used for the BearerClass field in the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//


#define BCOB_A					0x00	// Bearer class A
#define BCOB_C					0x01	// Bearer class C
#define BCOB_X					0x02	// Bearer class X
#ifdef MS_UNI4_NOT_USED
#define BCOB_VP_SERVICE			0x03	// VP service
#endif

//
// values used for the TrafficType field in the Broadband Bearer Capability IE
//
#define TT_NOIND				0x00	// No indication of traffic type
#define TT_CBR					0x04	// Constant bit rate
#ifdef MS_UNI3_ERROR_KEPT
#define TT_VBR					0x06	// Variable bit rate
#else
#define TT_VBR					0x08	// Variable bit rate
#endif

//
// values used for the TimingRequirements field in the Broadband Bearer Capability IE
//
#define TR_NOIND				0x00	// No timing requirement indication
#define TR_END_TO_END			0x01	// End-to-end timing required
#define TR_NO_END_TO_END		0x02	// End-to-end timing not required

//
// values used for the ClippingSusceptability field in the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//
#define CLIP_NOT				0x00	// Not susceptible to clipping
#define CLIP_SUS				0x20	// Susceptible to clipping

//
// values used for the UserPlaneConnectionConfig field in
// the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//
#define UP_P2P					0x00	// Point-to-point connection
#define UP_P2MP					0x01	// Point-to-multipoint connection


//
// Broadband Bearer Capability for UNI 3.1
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE
{
	UCHAR			BearerClass;
	UCHAR			TrafficType;
	UCHAR			TimingRequirements;
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE, *PATM_BROADBAND_BEARER_CAPABILITY_IE;


#ifdef MS_UNI4
//
// values used for the TransferCapability field in the UNI 4.0 Broadband Bearer Capability IE
//
									// Usage		Usage	Corresponding UNI3.x values
									// UNI 4.0		UNI 3.0	TrafficType	TimingRequirements
									// ------------	-------	-----------	------------------
#define XCAP_NRT_VBR_RCV_0	0x00	// Only rcv				NOIND		NOIND	   
#define XCAP_RT_VBR_RCV_1	0x01	// Only rcv				NOIND		END_TO_END
#define XCAP_NRT_VBR_RCV_2	0x02	// Only rcv				NOIND		NO_END_TO_END
#define XCAP_CBR_RCV_4		0x04	// Only rcv				CBR			NOIND	   
#define XCAP_CBR			0x05	// 						CBR			END_TO_END
#define XCAP_CBR_RCV_6		0x06	// Only rcv				CBR			NO_END_TO_END
#define XCAP_CBR_W_CLR		0x07	// 				None 	CBR			<reserved>
#define XCAP_NRT_VBR_RCV_8	0x08	// Only rcv				VBR			NOIND	   
#define XCAP_RT_VBR			0x09	// 						VBR			END_TO_END
#define XCAP_NRT_VBR		0x0A	// 						VBR			NO_END_TO_END
#define XCAP_NRT_VBR_W_CLR	0x0B	// 				None 	VBR			<reserved>
#define XCAP_ABR			0x0C	// 				None	<reserved>	NOIND	   
#define XCAP_RT_VBR_W_CLR	0x13	// 				None	(NOIND)	<reserved>

//
// Broadband Bearer Capability for UNI 4.0+
// Note: This can be used for UNI 3.1 as well.
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40
{
	UCHAR			BearerClass;
	UCHAR			TransferCapability;				// optional
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40, *PATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40;
#endif // MS_UNI4


//
// values used for the HighLayerInfoType field in ATM_BHLI
//
#define BHLI_ISO				0x00	// ISO
#define BHLI_UserSpecific		0x01	// User Specific
#define BHLI_HighLayerProfile	0x02	// High layer profile (only in UNI3.0)
#define BHLI_VendorSpecificAppId 0x03	// Vendor-Specific Application ID

//
// Broadband High layer Information
//
typedef struct _ATM_BHLI_IE
{
	ULONG			HighLayerInfoType;		// High Layer Information Type
	ULONG			HighLayerInfoLength;	// number of bytes in HighLayerInfo
	UCHAR			HighLayerInfo[8];		// The value dependent on the
											// HighLayerInfoType field
} ATM_BHLI_IE, *PATM_BHLI_IE;

//
// values used for Layer2Protocol in B-LLI
//
#define BLLI_L2_ISO_1745		0x01	// Basic mode ISO 1745
#define BLLI_L2_Q921			0x02	// CCITT Rec. Q.921
#define BLLI_L2_X25L			0x06	// CCITT Rec. X.25, link layer
#define BLLI_L2_X25M			0x07	// CCITT Rec. X.25, multilink
#define BLLI_L2_ELAPB			0x08	// Extended LAPB; for half duplex operation
#ifdef MS_UNI3_ERROR_KEPT
#define BLLI_L2_HDLC_NRM		0x09	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0A	// HDLC ABM (ISO 4335)
#define BLLI_L2_HDLC_ARM		0x0B	// HDLC ARM (ISO 4335)
#else
#define BLLI_L2_HDLC_ARM		0x09	// HDLC ARM (ISO 4335)
#define BLLI_L2_HDLC_NRM		0x0A	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0B	// HDLC ABM (ISO 4335)
#endif
#define BLLI_L2_LLC				0x0C	// LAN logical link control (ISO 8802/2)
#define BLLI_L2_X75				0x0D	// CCITT Rec. X.75, single link procedure
#define BLLI_L2_Q922			0x0E	// CCITT Rec. Q.922
#define BLLI_L2_USER_SPECIFIED	0x10	// User Specified
#define BLLI_L2_ISO_7776		0x11	// ISO 7776 DTE-DTE operation

//
// values used for Layer3Protocol in B-LLI
//
#define BLLI_L3_X25				0x06	// CCITT Rec. X.25, packet layer
#define BLLI_L3_ISO_8208		0x07	// ISO/IEC 8208 (X.25 packet layer for DTE
#define BLLI_L3_X223			0x08	// X.223/ISO 8878
#define BLLI_L3_SIO_8473		0x09	// ISO/IEC 8473 (OSI connectionless)
#define BLLI_L3_T70				0x0A	// CCITT Rec. T.70 min. network layer
#define BLLI_L3_ISO_TR9577		0x0B	// ISO/IEC TR 9577 Network Layer Protocol ID
#define BLLI_L3_USER_SPECIFIED	0x10	// User Specified
#ifdef MS_UNI4
#define BLLI_L3_H310			0x0C	// ITU H.310
#define BLLI_L3_H321			0x0D	// ITU H.321
#endif // MS_UNI4

//
// values used for Layer3IPI in struct B-LLI
//
#define BLLI_L3_IPI_SNAP		0x80	// IEEE 802.1 SNAP identifier
#define BLLI_L3_IPI_IP			0xCC	// Internet Protocol (IP) identifier

//
// Broadband Lower Layer Information
//
typedef struct _ATM_BLLI_IE
{
	ULONG						Layer2Protocol;
	UCHAR						Layer2Mode;
	UCHAR						Layer2WindowSize;
	ULONG						Layer2UserSpecifiedProtocol;
	ULONG						Layer3Protocol;
	UCHAR						Layer3Mode;
	UCHAR						Layer3DefaultPacketSize;
	UCHAR						Layer3PacketWindowSize;
	ULONG						Layer3UserSpecifiedProtocol;
	ULONG						Layer3IPI;
	UCHAR						SnapId[5];
} ATM_BLLI_IE, *PATM_BLLI_IE;


#ifdef MS_UNI4

//
// Values used for Layer3H310TerminalType in struct B-LLI ADDON
//
#define BLLI_L3_H310_TT_RECEIVE_ONLY		0x01
#define BLLI_L3_H310_TT_SEND_ONLY			0x02
#define BLLI_L3_H310_TT_RECEIVE_AND_SEND	0x03


//
// Values used for Layer3H310ForwardMultiplexingCapability
// and Layer3H310BackwardMultiplexingCapability in struct B-LLI ADDON
//
#define BLLI_L3_H310_MUX_NONE						0x00
#define BLLI_L3_H310_MUX_TRANSPORT_STREAM			0x01
#define BLLI_L3_H310_MUX_TRANSPORT_STREAM_WITH_FEC	0x02
#define BLLI_L3_H310_MUX_PROGRAM_STREAM				0x03
#define BLLI_L3_H310_MUX_PROGRAM_STREAM_WITH_FEC	0x04
#define BLLI_L3_H310_MUX_H221						0x05


//
// Broadband Lower Layer Information Add-On for UNI4.0+
//
// REQUIREMENT: An add-on IE must follow immediately after its ancestor IE.
//
typedef struct _ATM_BLLI_IE_ADDON
{
	UCHAR						Layer3H310TerminalType;						// optional
	UCHAR						Layer3H310ForwardMultiplexingCapability;	// optional
	UCHAR						Layer3H310BackwardMultiplexingCapability;	// optional
} ATM_BLLI_IE_ADDON, *PATM_BLLI_IE_ADDON;

#endif // MS_UNI4


//
// Values used for PresentationIndication in struct ATM_CALLING_PARTY_NUMBER_IE
//

#define CALLING_NUMBER_PRESENTATION_ALLOWED			0x00
#define CALLING_NUMBER_PRESENTATION_RESTRICTED		0x01
#define CALLING_NUMBER_PRESENTATION_NOT_AVAIL		0x02
#define CALLING_NUMBER_PRESENTATION_RESERVED		0x03

//
// Values used for ScreeningIndicator in struct ATM_CALLING_PARTY_NUMBER_IE
//

#define CALLING_NUMBER_SCREENING_USER_PROVIDED_NOT_SCREENED		0x00
#define CALLING_NUMBER_SCREENING_USER_PROVIDED_PASSED_SCREENING	0x01
#define CALLING_NUMBER_SCREENING_USER_PROVIDED_FAILED_SCREENING	0x02
#define CALLING_NUMBER_SCREENING_NW_PROVIDED		   			0x03


//
// Called Party Number
//
// If present, this IE overrides the Called Address specified in
// the main parameter block.
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_NUMBER_IE;


//
// Called Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_SUBADDRESS_IE;



//
// Calling Party Number
//
typedef struct _ATM_CALLING_PARTY_NUMBER_IE
{
	ATM_ADDRESS					Number;
	UCHAR						PresentationIndication;		// optional
	UCHAR						ScreeningIndicator;			// optional
} ATM_CALLING_PARTY_NUMBER_IE, *PATM_CALLING_PARTY_NUMBER_IE;


//
// Calling Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLING_PARTY_SUBADDRESS_IE;


#ifdef MS_UNI4
//
// Connected Number IE for UNI 4.0 (for COLP Supplementary Services option)
//
typedef ATM_CALLING_PARTY_NUMBER_IE ATM_CONNECTED_NUMBER_IE, *PATM_CONNECTED_NUMBER_IE;


//
// Connected Subaddress IE for UNI 4.0 (for COLP Supplementary Services option)
//
typedef ATM_CALLING_PARTY_SUBADDRESS_IE ATM_CONNECTED_SUBADDRESS_IE, *PATM_CONNECTED_SUBADDRESS_IE;

#endif // MS_UNI4


//
// Values used for the QOSClassForward and QOSClassBackward
// fields in ATM_QOS_CLASS_IE
//
#define QOS_CLASS0				0x00
#define QOS_CLASS1				0x01
#define QOS_CLASS2				0x02
#define QOS_CLASS3				0x03
#define QOS_CLASS4				0x04

//
// QOS Class
//
typedef struct _ATM_QOS_CLASS_IE
{
	UCHAR						QOSClassForward;
	UCHAR						QOSClassBackward;
} ATM_QOS_CLASS_IE, *PATM_QOS_CLASS_IE;


#ifdef MS_UNI4
//
// Values used for the Origin field in ATM_EXTENDED_QOS_PARAMETERS_IE
//
#define ATM_XQOS_ORIGINATING_USER	0x00
#define ATM_XQOS_INTERMEDIATE_NW	0x01

//
// Extended QoS Parameters for UNI 4.0+
//
typedef struct _ATM_EXTENDED_QOS_PARAMETERS_IE
{
	UCHAR						Origin;
	UCHAR						Filler[3];
	ULONG						AcceptableForwardPeakCDV;	// optional
	ULONG						AcceptableBackwardPeakCDV;	// optional
	ULONG						CumulativeForwardPeakCDV;	// optional
	ULONG						CumulativeBackwardPeakCDV;	// optional
	UCHAR						AcceptableForwardCLR;		// optional
	UCHAR						AcceptableBackwardCLR;		// optional
} ATM_EXTENDED_QOS_PARAMETERS_IE, *PATM_EXTENDED_QOS_PARAMETERS_IE;

#endif // MS_UNI4


//
// Broadband Sending Complete
//
typedef struct _ATM_BROADBAND_SENDING_COMPLETE_IE
{
	UCHAR						SendingComplete;
} ATM_BROADBAND_SENDING_COMPLETE_IE, *PATM_BROADBAND_SENDING_COMPLETE_IE;


//
// Values used for the TypeOfNetworkId field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_TYPE_NATIONAL			0x40

//
// Values used for the NetworkIdPlan field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_PLAN_CARRIER_ID_CODE	0x01

//
// Transit Network Selection
//
typedef struct _ATM_TRANSIT_NETWORK_SELECTION_IE
{
	UCHAR						TypeOfNetworkId;
	UCHAR						NetworkIdPlan;
	UCHAR						NetworkIdLength;
	UCHAR						NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE, *PATM_TRANSIT_NETWORK_SELECTION_IE;


// 
// Values used for the Location field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_LOC_USER							0x00
#define ATM_CAUSE_LOC_PRIVATE_LOCAL					0x01
#define ATM_CAUSE_LOC_PUBLIC_LOCAL					0x02
#define ATM_CAUSE_LOC_TRANSIT_NETWORK				0x03
#define ATM_CAUSE_LOC_PUBLIC_REMOTE					0x04
#define ATM_CAUSE_LOC_PRIVATE_REMOTE				0x05
#ifdef MS_UNI3_ERROR_KEPT
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x06
#else
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x07
#endif
#define ATM_CAUSE_LOC_BEYOND_INTERWORKING			0x0A

// 
// Values used for the Cause field in struct ATM_CAUSE_IE
//
#ifdef MS_UNI4
#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_SEND_SPECIAL_TONE					0x04	// UNI 4.0+
#define ATM_CAUSE_MISDIALLED_TRUNK_PREFIX			0x05	// UNI 4.0+
#define ATM_CAUSE_CHANNEL_UNACCEPTABLE				0x06	// UNI 4.0+
#define ATM_CAUSE_CALL_AWARDED_IN_EST_CHAN			0x07	// UNI 4.0+
#define ATM_CAUSE_PREEMPTION						0x08	// UNI 4.0+
#define ATM_CAUSE_PREEMPTION_CIRC_RES_REUSE			0x09	// UNI 4.0+
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A	// UNI 3.0 only!
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10	// UNI 3.1+
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_NO_ANSWER_FROM_USER_ALERTED		0x13	// UNI 4.0+
#define ATM_CAUSE_SUBSCRIBER_ABSENT					0x14	// UNI 4.0+
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_NONSELECTED_USER_CLEARING			0x1A	// UNI 4.0+
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_FACILITY_REJECTED					0x1D	// UNI 4.0+
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_TOO_MANY_ADD_PARTY				0x20	// UNI 4.0+
#define ATM_CAUSE_NO_CIRCUIT_CHANNEL_AVAIL			0x22	// UNI 4.0+
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_VPCI_VCI_ASSIGN_FAIL				0x24	// UNI 3.1+
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x25	// UNI 3.1+
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_PFM_CONNECTION_OUT_OF_ORDER		0x27	// UNI 4.0+
#define ATM_CAUSE_PFM_CONNNECTION_OPERATIONAL		0x28	// UNI 4.0+
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_SWITCH_EQUIPM_CONGESTED			0x2A	// UNI 4.0+
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_REQUESTED_CIRC_CHANNEL_NOT_AVAIL	0x2C	// UNI 4.0+
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_REQ_FACILITY_NOT_SUBSCRIBED		0x32	// UNI 4.0+
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE__UNI30	0x33	// UNI 3.0 only!
#define ATM_CAUSE_OUTG_CALLS_BARRED_W_CUG			0x35	// UNI 4.0+
#define ATM_CAUSE_INCOM_CALLS_BARRED_W_CUG			0x37	// UNI 4.0+
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_INCONSIST_OUTG_ACCESS_INFO		0x3E	// UNI 4.0+
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_CHANNEL_TYPE_NOT_IMPLEMENTED		0x42	// UNI 4.0+
#define ATM_CAUSE_REQ_FACILITY_NOT_IMPLEMENTED		0x45	// UNI 4.0+
#define ATM_CAUSE_ONLY_RESTR_BEAR_CAP_AVAIL			0x46	// UNI 4.0+
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x4E	// UNI 3.1+
#define ATM_CAUSE_SERVICE_OPTION_NOT_AVAIL			0x4F	// UNI 4.0+
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_SUSP_CALL_EXISTS_NOT_CALL_ID		0x53	// UNI 4.0+
#define ATM_CAUSE_CALL_ID_IN_USE					0x54	// UNI 4.0+
#define ATM_CAUSE_NO_CALL_SUSPENDED					0x55	// UNI 4.0+
#define ATM_CAUSE_CALL_W_REQ_ID_CLEARED				0x56	// UNI 4.0+
#define ATM_CAUSE_USER_NOT_MEMBER_CUG				0x57	// UNI 4.0+
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_NON_EXISTENT_CUG 					0x5A	// UNI 4.0+
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED__UNI30	0x5D	// UNI 3.0 only!
#define ATM_CAUSE_INVALID_MSG_UNSPECIFIED			0x5F	// UNI 4.0+
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_MSG_CONFL_STATE_OR_UNIMPL			0x62	// UNI 4.0+
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_IE_INVAL_UNIMPL_PASSED_ON			0x67	// UNI 4.0+
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_UNRECOGNIZED_PARM_MSG_DISCARDED	0x6E	// UNI 4.0+
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F
#define ATM_CAUSE_INTERWORKING_UNSPECIFIED			0x7F	// UNI 4.0+

#else // !MS_UNI4

#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x33
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x5D
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F
#endif // !MS_UNI4

//
// Values used for the Condition portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_COND_UNKNOWN						0x00
#define ATM_CAUSE_COND_PERMANENT					0x01
#define ATM_CAUSE_COND_TRANSIENT					0x02

//
// Values used for the Rejection Reason portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_REASON_USER						0x00
#define ATM_CAUSE_REASON_IE_MISSING					0x04
#define ATM_CAUSE_REASON_IE_INSUFFICIENT			0x08

//
// Values used for the P-U flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_PU_PROVIDER						0x00
#define ATM_CAUSE_PU_USER							0x08

//
// Values used for the N-A flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_NA_NORMAL							0x00
#define ATM_CAUSE_NA_ABNORMAL						0x04

#ifdef MS_UNI4
//
// values used for placing IE identifiers in the Diagnostics field
//
#define	ATM_CAUSE_DIAG_IE_NARROW_BEARER_CAPABILITY	0x04
#define	ATM_CAUSE_DIAG_IE_CAUSE						0x08
#define	ATM_CAUSE_DIAG_IE_CALL_STATE				0x14
#define	ATM_CAUSE_DIAG_IE_PROGRESS_IND				0x1E
#define	ATM_CAUSE_DIAG_IE_NOTIF_IND					0x27
#define	ATM_CAUSE_DIAG_IE_END_TO_END_TDELAY			0x42
#define	ATM_CAUSE_DIAG_IE_CONNECTED_NUMBER			0x4C
#define	ATM_CAUSE_DIAG_IE_CONNECTED_SUBADDR			0x4D
#define	ATM_CAUSE_DIAG_IE_ENDPOINT_REF				0x54
#define	ATM_CAUSE_DIAG_IE_ENDPOINT_STATE			0x55
#define	ATM_CAUSE_DIAG_IE_AAL_PARMS					0x58
#define	ATM_CAUSE_DIAG_IE_TRAFFIC_DESCRIPTOR		0x59
#define	ATM_CAUSE_DIAG_IE_CONNECTION_ID				0x5A
#define ATM_CAUSE_DIAG_IE_OAM_TRAFFIC_DESCRIPTOR	0x5B
#define	ATM_CAUSE_DIAG_IE_QOS						0x5C
#define	ATM_CAUSE_DIAG_IE_HIGH_LAYER_INFO			0x5D
#define	ATM_CAUSE_DIAG_IE_BEARER_CAPABILITY			0x5E
#define	ATM_CAUSE_DIAG_IE_LOW_LAYER_INFO			0x5F
#define	ATM_CAUSE_DIAG_IE_LOCKING_SHIFT				0x60
#define	ATM_CAUSE_DIAG_IE_NON_LOCKING_SHIFT			0x61
#define	ATM_CAUSE_DIAG_IE_SENDING_COMPLETE			0x62
#define	ATM_CAUSE_DIAG_IE_REPEAT_INDICATOR			0x63
#define	ATM_CAUSE_DIAG_IE_CALLING_PARTY_NUMBER		0x6C
#define	ATM_CAUSE_DIAG_IE_CALLING_PARTY_SUBADDR		0x6D
#define	ATM_CAUSE_DIAG_IE_CALLED_PARTY_NUMBER		0x70
#define	ATM_CAUSE_DIAG_IE_CALLED_PARTY_SUBADDR		0x71
#define	ATM_CAUSE_DIAG_IE_TRANSIT_NETWORK_SELECT	0x78
#define	ATM_CAUSE_DIAG_IE_RESTART_INDICATOR			0x79
#define	ATM_CAUSE_DIAG_IE_NARROW_LOW_LAYER_COMPAT	0x7C
#define	ATM_CAUSE_DIAG_IE_NARROW_HIGH_LAYER_COMPAT	0x7D
#define	ATM_CAUSE_DIAG_IE_USER_USER					0x7E
#define	ATM_CAUSE_DIAG_IE_GENERIC_ID				0x7F
#define	ATM_CAUSE_DIAG_IE_MIN_TRAFFIC_DESCRIPTOR	0x81
#define	ATM_CAUSE_DIAG_IE_ALT_TRAFFIC_DESCRIPTOR	0x82
#define	ATM_CAUSE_DIAG_IE_ABR_SETUP_PARMS			0x84
#define	ATM_CAUSE_DIAG_IE_CALLED_SOFT_PVPC_PVCC		0xE0
#define	ATM_CAUSE_DIAG_IE_CRANKBACK					0xE1
#define	ATM_CAUSE_DIAG_IE_DESIGNATED_TRANSIT_LIST	0xE2
#define	ATM_CAUSE_DIAG_IE_CALLING_SOFT_PVPC_PVCC	0xE3
#define	ATM_CAUSE_DIAG_IE_ABR_ADD_PARMS				0xE4
#define	ATM_CAUSE_DIAG_IE_LIJ_CALL_ID				0xE8
#define	ATM_CAUSE_DIAG_IE_LIJ_PARMS					0xE9
#define	ATM_CAUSE_DIAG_IE_LEAF_SEQ_NO				0xEA
#define	ATM_CAUSE_DIAG_IE_CONNECTION_SCOPE_SELECT	0xEB
#define	ATM_CAUSE_DIAG_IE_EXTENDED_QOS				0xEC

//
// values used for placing IE subfield identifiers in the Diagnostics field
//
#define ATM_CAUSE_DIAG_RATE_ID_FW_PEAK_CLP0			0x82
#define ATM_CAUSE_DIAG_RATE_ID_BW_PEAK_CLP0			0x83
#define ATM_CAUSE_DIAG_RATE_ID_FW_PEAK_CLP01		0x84
#define ATM_CAUSE_DIAG_RATE_ID_BW_PEAK_CLP01		0x85
#define ATM_CAUSE_DIAG_RATE_ID_FW_SUST_CLP0			0x88
#define ATM_CAUSE_DIAG_RATE_ID_BW_SUST_CLP0			0x89
#define ATM_CAUSE_DIAG_RATE_ID_FW_SUST_CLP01		0x90
#define ATM_CAUSE_DIAG_RATE_ID_BW_SUST_CLP01		0x91
#define ATM_CAUSE_DIAG_RATE_ID_FW_ABR_MIN_CLP01		0x92
#define ATM_CAUSE_DIAG_RATE_ID_BW_ABR_MIN_CLP01		0x93
#define ATM_CAUSE_DIAG_RATE_ID_FW_BURST_CLP0		0xA0
#define ATM_CAUSE_DIAG_RATE_ID_BW_BURST_CLP0		0xA1
#define ATM_CAUSE_DIAG_RATE_ID_FW_BURST_CLP01		0xB0
#define ATM_CAUSE_DIAG_RATE_ID_BW_BURST_CLP01		0xB1
#define ATM_CAUSE_DIAG_RATE_ID_BEST_EFFORT			0xBE
#define ATM_CAUSE_DIAG_RATE_ID_TM_OPTIONS			0xBF

//
// Values used for placing a CCBS indicator in the Diagnostics field 
//
#define ATM_CAUSE_DIAG_CCBS_SPARE					0x00
#define ATM_CAUSE_DIAG_CCBS_CCBS_POSSIBLE			0x01
#define ATM_CAUSE_DIAG_CCBS_CCBS_NOT_POSSIBLE		0x02

//
// Values used for placing Attribute Numbers in the Diagnostics field
//
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_CAP		0x31
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_MODE		0x32
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_RATE		0x33
#define ATM_CAUSE_DIAG_ATTR_NO_STRUCTURE			0x34
#define ATM_CAUSE_DIAG_ATTR_NO_CONFIG				0x35
#define ATM_CAUSE_DIAG_ATTR_NO_ESTABL				0x36
#define ATM_CAUSE_DIAG_ATTR_NO_SYMMETRY				0x37
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_RATE2		0x38
#define ATM_CAUSE_DIAG_ATTR_NO_LAYER_ID				0x39
#define ATM_CAUSE_DIAG_ATTR_NO_RATE_MULT			0x3A

#endif // MS_UNI4


//
// Cause
//
// Note: If used as empty buffer for response IE, then the DiagnosticsLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_CAUSE_IE
{
	UCHAR						Location;
	UCHAR						Cause;
	UCHAR						DiagnosticsLength;
	UCHAR						Diagnostics[4];		// Variable length information (minimum 4 bytes)
} ATM_CAUSE_IE, *PATM_CAUSE_IE;


#ifdef MS_UNI4
//
// Connection Identifier IE for UNI 4.0+
//
// Setting VPCI to SAP_FIELD_ABSENT, means it is "VP-associated" signalling,
// (which is not supported by this CallManager);
//
// Otherwise we assume "explicit VPCI" (this is the normal setting),
// and the Vpci value is used.
//
// Setting the VCI to SAP_FIELD_ABSENT, means it is "switched VP",
// which is not supported by this CallManager;
//
// Setting the VCI to SAP_FIELD_ANY, means it is "explicit VPCI, any VCI";
//
// Setting both the Vpci and the Vci fields to SAP_FIELD_ANY,
// or setting both the Vpci and the Vci fields to SAP_FIELD_ABSENT,
// means that the ConnectionId is not defined,
// so it will not be sent to the peer.
// (This allows an empty ConnectionIdentifier IE to hold the response).
//
// Otherwise we assume "explicit VPCI, explicit VCI" (this is the normal
// setting), and the Vci value is used.
//
typedef struct _ATM_CONNECTION_ID_IE
{
	ULONG						Vpci;	// Optional: Can use SAP_FIELD_ANY or SAP_FIELD_ABSENT here.
	ULONG						Vci;	// Optional: Can use SAP_FIELD_ANY or SAP_FIELD_ABSENT here.
} ATM_CONNECTION_ID_IE, *PATM_CONNECTION_ID_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// End-to-End Transit Delay IE for UNI 4.0+
//
typedef struct _ATM_END_TO_END_TRANSIT_DELAY_IE
{
	ULONG						CumulativeTransitDelay;			// optional (Milliseconds)
	ULONG						MaximumEndToEndTransitDelay;	// optional (Milliseconds)
	BOOLEAN						NetworkGenerated;
} ATM_END_TO_END_TRANSIT_DELAY_IE, *PATM_END_TO_END_TRANSIT_DELAY_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Notification Indicator IE for UNI 4.0+
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_NOTIFICATION_INDICATOR_IE
{
	USHORT						NotificationId;
	USHORT						InformationLength;
	UCHAR						NotificationInformation[1];		// Variable length information
} ATM_NOTIFICATION_INDICATOR_IE, *PATM_NOTIFICATION_INDICATOR_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// User-User IE for UNI 4.0+ (for UUS Supplementary Services option)
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_USER_USER_IE
{
	UCHAR						ProtocolDescriminator;
	UCHAR						Filler[1];
	USHORT						InformationLength;
	UCHAR						UserUserInformation[1];			// Variable length information
} ATM_USER_USER_IE, *PATM_USER_USER_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Generic ID Transport IE for UNI 4.0+
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_GENERIC_ID_TRANSPORT_IE
{
	USHORT						InformationLength;
	UCHAR						GenericIDInformation[1];		// Variable length information
} ATM_GENERIC_ID_TRANSPORT_IE, *PATM_GENERIC_ID_TRANSPORT_IE;

#endif // MS_UNI4


//
// Leaf Initiated Join (LIJ) Identifier
//
typedef struct _ATM_LIJ_CALLID_IE
{
	ULONG						Identifier;
} ATM_LIJ_CALLID_IE, *PATM_LIJ_CALLID_IE;


#ifdef MS_UNI4
//
// Values used for the ScreeningIndication field in struct ATM_LIJ_PARAMETERS_IE
//
#define ATM_LIJ_PARMS_SCREEN_NO_ROOT_NOTIF	0x00

//
// Leaf Initiated Join (LIJ) Parameters IE for UNI 4.0+
//
typedef struct _ATM_LIJ_PARAMETERS_IE
{
	UCHAR						ScreeningIndication;
} ATM_LIJ_PARAMETERS_IE, *PATM_LIJ_PARAMETERS_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Leaf Sequence Number IE for UNI 4.0+
//
typedef struct _ATM_LEAF_SEQUENCE_NUMBER_IE
{
	ULONG						SequenceNumber;
} ATM_LEAF_SEQUENCE_NUMBER_IE, *PATM_LEAF_SEQUENCE_NUMBER_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Values used for the ConnectionScopeType field in _ATM_CONNECTION_SCOPE_SELECTION_IE
//
#define ATM_SCOPE_TYPE_ORGANIZATIONAL				0x01

//
// Values used for the ConnectionScopeSelection field in _ATM_CONNECTION_SCOPE_SELECTION_IE
//
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW			0x01
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW_PLUS1		0x02
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW_PLUS2		0x03
#define ATM_SCOPE_ORGANIZATIONAL_SITE_MINUS1		0x04
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_SITE			0x05
#define ATM_SCOPE_ORGANIZATIONAL_SITE_PLUS1			0x06
#define ATM_SCOPE_ORGANIZATIONAL_ORG_MINUS1			0x07
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_ORG			0x08
#define ATM_SCOPE_ORGANIZATIONAL_ORG_PLUS1			0x09
#define ATM_SCOPE_ORGANIZATIONAL_COMM_MINUS1		0x0A
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_COMM			0x0B
#define ATM_SCOPE_ORGANIZATIONAL_COMM_PLUS1			0x0C
#define ATM_SCOPE_ORGANIZATIONAL_REGIONAL			0x0D
#define ATM_SCOPE_ORGANIZATIONAL_INTER_REGIONAL		0x0E
#define ATM_SCOPE_ORGANIZATIONAL_GLOBAL				0x0F

//
// Connection Scope Selection IE for UNI 4.0+
//
typedef struct _ATM_CONNECTION_SCOPE_SELECTION_IE
{
	UCHAR						ConnectionScopeType;
	UCHAR						ConnectionScopeSelection;
} ATM_CONNECTION_SCOPE_SELECTION_IE, *PATM_CONNECTION_SCOPE_SELECTION_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Values used for the XxxxAdditionalParameters fields in _ATM_ABR_ADDITIONAL_PARAMETERS_IE
//
#define			ATM_ABR_PARMS_NRM_PRESENT		0x80000000
#define			ATM_ABR_PARMS_TRM_PRESENT		0x40000000
#define			ATM_ABR_PARMS_CDF_PRESENT		0x20000000
#define			ATM_ABR_PARMS_ADTF_PRESENT		0x10000000
#define			ATM_ABR_PARMS_NRM_MASK			0x0E000000
#define			ATM_ABR_PARMS_NRM_SHIFT			25
#define			ATM_ABR_PARMS_TRM_MASK			0x01C00000
#define			ATM_ABR_PARMS_TRM_SHIFT			22
#define			ATM_ABR_PARMS_CDF_MASK			0x00380000
#define			ATM_ABR_PARMS_CDF_SHIFT			19
#define			ATM_ABR_PARMS_ADTF_MASK			0x0007FE00
#define			ATM_ABR_PARMS_ADTF_SHIFT		9
#define 		ATM_ABR_PARMS_NRM_DEFAULT		4
#define 		ATM_ABR_PARMS_TRM_DEFAULT		7
#define 		ATM_ABR_PARMS_CDF_DEFAULT		3
#define 		ATM_ABR_PARMS_ADTF_DEFAULT		50

typedef struct _ATM_ABR_ADDITIONAL_PARAMETERS_IE
{
	ULONG	ForwardAdditionalParameters;
	ULONG	BackwardAdditionalParameters;
} ATM_ABR_ADDITIONAL_PARAMETERS_IE, *PATM_ABR_ADDITIONAL_PARAMETERS_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// ABR Setup Parameters IE for UNI 4.0+
//
typedef struct _ATM_ABR_SETUP_PARAMETERS_IE
{
	ULONG	ForwardABRInitialCellRateCLP01;			// optional
	ULONG	BackwardABRInitialCellRateCLP01;		// optional
	ULONG	ForwardABRTransientBufferExposure;		// optional
	ULONG	BackwardABRTransientBufferExposure;		// optional
	ULONG	CumulativeRmFixedRTT;
	UCHAR	ForwardABRRateIncreaseFactorLog2;		// optional (0..15 [log2(RIF*32768)])
	UCHAR	BackwardABRRateIncreaseFactorLog2;		// optional (0..15 [log2(RIF*32768)])
	UCHAR	ForwardABRRateDecreaseFactorLog2;		// optional (0..15 [log2(RDF*32768)])
	UCHAR	BackwardABRRateDecreaseFactorLog2;		// optional (0..15 [log2(RDF*32768)])
} ATM_ABR_SETUP_PARAMETERS_IE, *PATM_ABR_SETUP_PARAMETERS_IE;

#endif // MS_UNI4


//
// Raw Information Element - the user can fill in whatever he wants
//
typedef struct _ATM_RAW_IE
{
	ULONG						RawIELength;
	ULONG						RawIEType;
	UCHAR						RawIEValue[1];		// Vaiable length information
} ATM_RAW_IE, *PATM_RAW_IE;


//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains ATM media specific values in the structure
// ATM_MEDIA_PARAMETERS.
//
#define ATM_MEDIA_SPECIFIC		0x00000001

//
// The Q2931 Call Manager Specific parameters that goes into the
// CallMgrParameters->CallMgrSpecific.Parameters
//
typedef struct _Q2931_CALLMGR_PARAMETERS
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_PARAMETERS, *PQ2931_CALLMGR_PARAMETERS;


//
// This is the specific portion of either the Media parameters or the CallMgr
// Parameters. The following define is used in the ParamType field
// depending on the signaling type.
//
#define CALLMGR_SPECIFIC_Q2931	0x00000001

typedef struct _ATM_VPIVCI
{
	ULONG						Vpi;
	ULONG						Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

//
// ATM Service Category
//
#define	ATM_SERVICE_CATEGORY_CBR	1	// Constant Bit Rate
#define	ATM_SERVICE_CATEGORY_VBR	2	// Variable Bit Rate
#define	ATM_SERVICE_CATEGORY_UBR	4	// Unspecified Bit Rate
#define	ATM_SERVICE_CATEGORY_ABR	8	// Available Bit Rate

typedef ULONG	ATM_SERVICE_CATEGORY, *PATM_SERVICE_CATEGORY;


//
// ATM flow parameters for use in specifying Media parameters
//
typedef struct _ATM_FLOW_PARAMETERS
{
	ATM_SERVICE_CATEGORY		ServiceCategory;
	ULONG						AverageCellRate;			// in cells/sec
	ULONG						PeakCellRate;				// in cells/sec
	ULONG						MinimumCellRate;			// in cells/sec (ABR MCR)
	ULONG						InitialCellRate;			// in cells/sec (ABR ICR)
	ULONG						BurstLengthCells;			// in cells
	ULONG						MaxSduSize;					// MTU in bytes
	ULONG						TransientBufferExposure;	// in cells (ABR TBE)
	ULONG						CumulativeRMFixedRTT;		// in microseconds (ABR FRTT)
	UCHAR						RateIncreaseFactor;			// UNI 4.0 coding (ABR RIF)
	UCHAR						RateDecreaseFactor;			// UNI 4.0 coding (ABR RDF)
	USHORT						ACRDecreaseTimeFactor;		// UNI 4.0 coding (ABR ADTF)
	UCHAR						MaximumCellsPerForwardRMCell; // UNI 4.0 coding (ABR Nrm)
	UCHAR						MaximumForwardRMCellInterval; // UNI 4.0 coding (ABR Trm)
	UCHAR						CutoffDecreaseFactor;		// UNI 4.0 coding (ABR CDF)
	UCHAR						Reserved1;					// padding
	ULONG						MissingRMCellCount;			// (ABR CRM)
	ULONG						Reserved2;
	ULONG						Reserved3;
} ATM_FLOW_PARAMETERS, *PATM_FLOW_PARAMETERS;

//
// ATM Specific Media parameters - this is the Media specific structure for ATM
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _ATM_MEDIA_PARAMETERS
{
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ULONG						CellDelayVariationCLP0;
	ULONG						CellDelayVariationCLP1;
	ULONG						CellLossRatioCLP0;
	ULONG						CellLossRatioCLP1;
	ULONG						CellTransferDelayCLP0;
	ULONG						CellTransferDelayCLP1;
	ULONG						DefaultCLP;
	ATM_FLOW_PARAMETERS			Transmit;
	ATM_FLOW_PARAMETERS			Receive;
} ATM_MEDIA_PARAMETERS, *PATM_MEDIA_PARAMETERS;

#ifdef MS_UNI4
//
// Generic ATM Call Manager Specific parameters.
// These may be used for call/leaf teardown and for certain NdisCoRequest calls.
//
// When used for closing a call and for dropping a leaf, by either client or
// Call Manager, this struct is referenced by the `Buffer` parameter of
// the relevant NDIS functions.
//
// When used for NdisCoRequest calls to make ATM UNI protocol specific
// requests and indications
//		OID_ATM_CALL_PROCEEDING
//		OID_ATM_CALL_ALERTING
//		OID_ATM_LEAF_ALERTING
//		OID_ATM_CALL_NOTIFY
// this struct is referenced by the `InformationBuffer` parameter.
//
typedef struct _Q2931_CALLMGR_SUBSEQUENT_PARAMETERS
{
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_SUBSEQUENT_PARAMETERS, *PQ2931_CALLMGR_SUBSEQUENT_PARAMETERS;
#endif // MS_UNI4

#ifdef MS_UNI4
//
// Field values that may be used whereever applicable to signify absence
// of data or wildcard data.
//
#endif // MS_UNI4

#ifndef SAP_FIELD_ABSENT
#define SAP_FIELD_ABSENT		((ULONG)0xfffffffe)
#endif

#ifndef SAP_FIELD_ABSENT_USHORT
#define SAP_FIELD_ABSENT_USHORT	((USHORT)0xfffe)
#endif

#ifndef SAP_FIELD_ABSENT_UCHAR
#define SAP_FIELD_ABSENT_UCHAR	((UCHAR)0xfe)
#endif

#ifndef SAP_FIELD_ANY
#define SAP_FIELD_ANY			((ULONG)0xffffffff)
#endif

#define SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

//
// The ATM Specific SAP definition
//
typedef struct _ATM_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
	ULONG						NumberOfAddresses;
	UCHAR						Addresses[1];	// each of type ATM_ADDRESS
} ATM_SAP, *PATM_SAP;

//
// The ATM Specific SAP definition when adding PVCs
//
typedef struct _ATM_PVC_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
} ATM_PVC_SAP, *PATM_PVC_SAP;

//
// The structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an ADD PVC request for Q.2931
//
typedef struct _Q2931_ADD_PVC
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ATM_FLOW_PARAMETERS			ForwardFP;
	ATM_FLOW_PARAMETERS			BackwardFP;
	ULONG						Flags;
	ATM_PVC_SAP					LocalSap;
	ATM_PVC_SAP					DestinationSap;
	BOOLEAN						LIJIdPresent;
	ATM_LIJ_CALLID_IE			LIJId;
} Q2931_ADD_PVC, *PQ2931_ADD_PVC;

//
// These flags are defined to be used with Q2931_ADD_PVC above
//
// this VC should be used by the CallMgr as the signaling VC now
#define CO_FLAG_SIGNALING_VC	0x00000001

//
// use this flag when the VC cannot be used for a MakeCall - incoming call only
// the call mgr can then be optimized not to search these PVCs during make call
// processing.
#define CO_FLAG_NO_DEST_SAP		0x00000002

//
//  Use this flag for a PVC that cannot be used to indicate an incoming call.
//
#define CO_FLAG_NO_LOCAL_SAP	0x00000004

//
// the structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an NDIS_CO_PVC request for Q2931
//
typedef struct _Q2931_DELETE_PVC
{
	ATM_VPIVCI					ConnectionId;
} Q2931_DELETE_PVC, *PQ2931_DELETE_PVC;

typedef struct _CO_GET_CALL_INFORMATION
{
	ULONG						CallInfoType;
	ULONG						CallInfoLength;
	PVOID						CallInfoBuffer;
} CO_GET_CALL_INFORMATION, *PCO_GET_CALL_INFORMATION;

//
// the structure for returning the supported VC rates from the miniport,
// returned in response to OID_ATM_SUPPORTED_VC_RATES
//
typedef struct _ATM_VC_RATES_SUPPORTED
{
	ULONG						MinCellRate;
	ULONG						MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
//	NDIS_PACKET out of band information for ATM.
//
typedef struct _ATM_AAL_OOB_INFO
{
	ATM_AAL_TYPE		AalType;
	union
	{
		struct _ATM_AAL5_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		UserToUserIndication;
			UCHAR		CommonPartIndicator;
		} ATM_AAL5_INFO;

		struct _ATM_AAL0_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		PayLoadTypeIdentifier;
		} ATM_AAL0_INFO;
	};
} ATM_AAL_OOB_INFO, *PATM_AAL_OOB_INFO;


//
//  Physical Line Speeds in bits/sec.
//
#define ATM_PHYS_RATE_SONET_STS3C						155520000
#define ATM_PHYS_RATE_IBM_25						 	 25600000

//
//  ATM cell layer transfer capacities in bits/sec. This is the throughput
//  available for ATM cells, after allowing for physical framing overhead.
//
#define ATM_CELL_TRANSFER_CAPACITY_SONET_STS3C			149760000
#define ATM_CELL_TRANSFER_CAPACITY_IBM_25			 	 25125926



//
//  User data rate in units of 100 bits/sec. This is returned in response to
//  the OID_GEN_CO_LINK_SPEED query. This is the effective rate of
//  transfer of data available to the ATM layer user, after allowing for
//  the ATM cell header.
//
#define ATM_USER_DATA_RATE_SONET_155					  1356317
#define ATM_USER_DATA_RATE_IBM_25			               227556



//
//  The ATM Service Registry MIB Table is used to locate ATM network
//  services. OID_ATM_GET_SERVICE_ADDRESS is used by clients to access
//  this table.
//

typedef ULONG		ATM_SERVICE_REGISTRY_TYPE;

#define ATM_SERVICE_REGISTRY_LECS		1	// LAN Emulation Configuration Server
#define ATM_SERVICE_REGISTRY_ANS		2	// ATM Name Server

//
//  Structure passed to OID_ATM_GET_SERVICE_ADDRESS.
//
typedef struct _ATM_SERVICE_ADDRESS_LIST
{
	ATM_SERVICE_REGISTRY_TYPE	ServiceRegistryType;
	ULONG						NumberOfAddressesAvailable;
	ULONG						NumberOfAddressesReturned;
	ATM_ADDRESS					Address[1];
} ATM_SERVICE_ADDRESS_LIST, *PATM_SERVICE_ADDRESS_LIST;

#endif	//	_ATM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\inc\ws2atmsp.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ws2atmsp.h

Abstract:

    This header file defines constants and types for accessing the ATM-specific
	component of the NT RAW WAN driver.

Author:

    ArvindM					October 13, 1997

Revision History:

--*/

#ifndef _WS2ATMSP__H
#define _WS2ATMSP__H


#define DD_ATM_DEVICE_NAME		L"\\Device\\Atm"


typedef UINT	ATM_OBJECT_ID;

//
//  ATM Object IDs
//
#define ATMSP_OID_NUMBER_OF_DEVICES			((ATM_OBJECT_ID)10)
#define ATMSP_OID_ATM_ADDRESS				((ATM_OBJECT_ID)11)
#define ATMSP_OID_PVC_ID					((ATM_OBJECT_ID)12)
#define ATMSP_OID_CONNECTION_ID				((ATM_OBJECT_ID)13)

//
//  Query Information structure. This is passed in as the InputBuffer in
//  the DeviceIoControl. The return information is to be filled into the
//  OutputBuffer.
//
typedef struct _ATM_QUERY_INFORMATION_EX
{
	ATM_OBJECT_ID			ObjectId;
	INT						ContextLength;
	UCHAR					Context[1];
} ATM_QUERY_INFORMATION_EX, *PATM_QUERY_INFORMATION_EX;


//
//  Set Information structure. This is passed in as the InputBuffer to
//  the DeviceIoControl. There is no OutputBuffer.
//
typedef struct _ATM_SET_INFORMATION_EX
{
	ATM_OBJECT_ID			ObjectId;
	INT						BufferSize;
	UCHAR					Buffer[1];
} ATM_SET_INFORMATION_EX, *PATM_SET_INFORMATION_EX;


#endif // _WS2ATMSP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\atmlane.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.h

Abstract:

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	__ATMLANE_ATMLANE_H
#define __ATMLANE_ATMLANE_H

//
//	Configuration defaults and stuff
//
#define DEF_HEADER_BUF_SIZE				LANE_HEADERSIZE

#define DEF_HDRBUF_GROW_SIZE			50	// these used for packet pad buffers also
#define DEF_MAX_HEADER_BUFS				300

#define DEF_PROTOCOL_BUF_SIZE			sizeof(LANE_CONTROL_FRAME)
#define DEF_MAX_PROTOCOL_BUFS			100

#define MCAST_LIST_SIZE					32

#define FAST_VC_TIMEOUT					30  // seconds

// 
//	The registry parameter strings
//
#define ATMLANE_LINKNAME_STRING			L"\\DosDevices\\AtmLane"
#define ATMLANE_NTDEVICE_STRING			L"\\Device\\AtmLane"
#define ATMLANE_PROTOCOL_STRING			L"AtmLane"
#define ATMLANE_USELECS_STRING 			L"UseLecs"
#define	ATMLANE_DISCOVERLECS_STRING		L"DiscoverLecs"
#define	ATMLANE_LECSADDR_STRING			L"LecsAddr"
#define ATMLANE_ELANLIST_STRING			L"ElanList"
#define ATMLANE_DEVICE_STRING			L"Device"
#define ATMLANE_ELANNAME_STRING			L"ElanName"
#define	ATMLANE_LANTYPE_STRING			L"LanType"
#define	ATMLANE_MAXFRAMESIZE_STRING		L"MaxFrameSizeCode"
#define	ATMLANE_LESADDR_STRING			L"LesAddr"
#define ATMLANE_UPPERBINDINGS_STRING    L"UpperBindings"
// Deprecated registry keys:
// #define	ATMLANE_MACADDR_STRING			L"MacAddr"
// #define ATMLANE_HEADERBUFSIZE_STRING	L"HeaderBufSize"
// #define ATMLANE_MAXHEADERBUFS_STRING	L"MaxHeaderBufs"
// #define ATMLANE_MAXPROTOCOLBUFS_STRING	L"MaxProtocolBufs"
// #define ATMLANE_DATADIRECTPCR_STRING	L"DataDirectPCR"

//
//	MAC table size 
//	Current sized at 256.
//	Hash function currently uses byte 5 of MAC Address as index.
//	Some research at Digital has shown it to be the best byte to use.
//
#define ATMLANE_MAC_TABLE_SIZE			256


//
//	Some misc defaults
//
#define ATMLANE_DEF_MAX_AAL5_PDU_SIZE	((64*1024)-1)

//
//  Timer configuration.
//
#define ALT_MAX_TIMER_SHORT_DURATION            60      // Seconds
#define ALT_MAX_TIMER_LONG_DURATION         (30*60)     // Seconds

#define ALT_SHORT_DURATION_TIMER_PERIOD			 1		// Second
#define ALT_LONG_DURATION_TIMER_PERIOD			10		// Seconds


//
//	Foward References
//
struct _ATMLANE_VC;
struct _ATMLANE_ATM_ENTRY;
struct _ATMLANE_ELAN;
struct _ATMLANE_ADAPTER;


//
//	Blocking data structure.
//
typedef struct _ATMLANE_BLOCK
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMLANE_BLOCK, *PATMLANE_BLOCK;


//
//	The following object is a convenient way to 
//	store and access an IEEE 48-bit MAC address.
//
typedef struct _MAC_ADDRESS
{
	UCHAR	Byte[6];
}
	MAC_ADDRESS,
	*PMAC_ADDRESS;
	

//
//	Packet context data in ProtocolReserved area of 
//	NDIS Packet header owned by ATMLANE.
//
typedef struct _SEND_PACKET_RESERVED
{
#if DBG
	ULONG						Signature;
	PNDIS_PACKET				pNextInSendList;
#endif
	ULONG						Flags;
	PNDIS_PACKET				pOrigNdisPacket;
	ULONG						OrigBufferCount;
	ULONG						OrigPacketLength;
	ULONG						WrappedBufferCount;
	PNDIS_PACKET				pNextNdisPacket;
#if PROTECT_PACKETS
	ATMLANE_LOCK				Lock;
	NDIS_STATUS					CompletionStatus;
#endif	// PROTECT_PACKETS
}	
	SEND_PACKET_RESERVED,
	*PSEND_PACKET_RESERVED;

//
//	Packet context data in MiniportReserved area of
//	NDIS packet header owned by ATMLANE.
//
typedef struct _RECV_PACKET_RESERVED
{
	ULONG						Flags;
	PNDIS_PACKET				pNdisPacket;
}
	RECV_PACKET_RESERVED,
	*PRECV_PACKET_RESERVED;
//
//	Definitions of Flags in both  (SEND/RECV)_PACKET_RESERVED.
//
#define PACKET_RESERVED_OWNER_MASK			0x00000007
#define PACKET_RESERVED_OWNER_PROTOCOL		0x00000001
#define PACKET_RESERVED_OWNER_ATMLANE		0x00000002
#define PACKET_RESERVED_OWNER_MINIPORT		0x00000004

#if PROTECT_PACKETS
#define PACKET_RESERVED_COSENDRETURNED		0x10000000
#define PACKET_RESERVED_COMPLETED			0x01000000
#endif	// PROTECT_PACKETS

#define PSEND_RSVD(_pPkt) \
	((PSEND_PACKET_RESERVED)(&((_pPkt)->ProtocolReserved)))
#define ZERO_SEND_RSVD(_pPkt) \
	NdisZeroMemory(&((_pPkt)->ProtocolReserved), sizeof(SEND_PACKET_RESERVED))

//
//  ------------------------ Global Data Object ------------------------
//

typedef struct _ATMLANE_GLOBALS
{
#if DBG
	ULONG						atmlane_globals_sig;	// debug signature
#endif
	ATMLANE_LOCK				GlobalLock;				// global data lock
	ATMLANE_BLOCK				Block;					 
	NDIS_HANDLE					NdisWrapperHandle;		// returned by NdisMInitializeWrapper
	NDIS_HANDLE					MiniportDriverHandle;	// returned by NdisIMRegisterLayeredMiniport
	NDIS_HANDLE					NdisProtocolHandle;		// returned by NdisRegisterProtocol
	LIST_ENTRY					AdapterList;			// list of bound adapters 
	PDRIVER_OBJECT				pDriverObject;			// our driver object
	PDEVICE_OBJECT				pSpecialDeviceObject;	// special protocol ioctl device object ptr
	NDIS_HANDLE					SpecialNdisDeviceHandle;// special protocol ioctl device handle
} 	
	ATMLANE_GLOBALS, 	
	*PATMLANE_GLOBALS;

#if DBG
#define atmlane_globals_signature	'LGLA'
#endif

//
//  ------------------------ Timer Management ------------------------
//

struct _ATMLANE_TIMER ;
struct _ATMLANE_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*ATMLANE_TIMEOUT_HANDLER)(
	IN	struct _ATMLANE_TIMER *		pTimer,
	IN	PVOID						ContextPtr
);

//
//  An ATMLANE_TIMER structure is used to keep track of each timer
//  in the ATMLANE module.
//
typedef struct _ATMLANE_TIMER
{
	struct _ATMLANE_TIMER *			pNextTimer;
	struct _ATMLANE_TIMER *			pPrevTimer;
	struct _ATMLANE_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _ATMLANE_TIMER_LIST *	pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	ATMLANE_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							ContextPtr;			// To be passed to timeout handler
	
} ATMLANE_TIMER, *PATMLANE_TIMER;

//
//  NULL pointer to ATMLANE Timer
//
#define NULL_PATMLANE_TIMER	((PATMLANE_TIMER)NULL)


//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _ATMLANE_TIMER_LIST
{
#if DBG
	ULONG							atmlane_timerlist_sig;
#endif // DBG
	PATMLANE_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure

} ATMLANE_TIMER_LIST, *PATMLANE_TIMER_LIST;

#if DBG
#define atmlane_timerlist_signature		'LTLA'
#endif // DBG

//
//  Timer Classes
//
typedef enum
{
	ALT_CLASS_SHORT_DURATION,
	ALT_CLASS_LONG_DURATION,
	ALT_CLASS_MAX

} ATMLANE_TIMER_CLASS;

//
//  ------------------------ ATMLANE SAP --------------------------------
//
//  Each of these structures maintains information about an individual SAP
//	associated with an ELAN.  Each ELAN registers 3 SAPs.
//	- Incoming Control Distribute VC
//	- Incoming Data Direct VCs
//  - Incoming Multicast Forward VC
//
typedef struct _ATMLANE_SAP
{
#if DBG
	ULONG							atmlane_sap_sig;
#endif
	struct _ATMLANE_ELAN *			pElan	;	// back pointer
	NDIS_HANDLE						NdisSapHandle;
	ULONG							Flags;		// state information
	ULONG							LaneType;	// LES\BUS\DATA
	PCO_SAP							pInfo;		// SAP characteristics.
} 	
	ATMLANE_SAP,
	*PATMLANE_SAP;

#if DBG
#define atmlane_sap_signature			'PSLA'
#endif

//
//  NULL pointer to ATMLANE SAP
//
#define NULL_PATMLANE_SAP			((PATMLANE_SAP)NULL)

//
//  Definitions for Flags in ATMLANE SAP
//
//
//  Bits 0 to 3 contain the SAP-registration state.
//
#define SAP_REG_STATE_MASK						0x0000000f
#define SAP_REG_STATE_IDLE						0x00000000
#define SAP_REG_STATE_REGISTERING				0x00000001	// Sent RegisterSap
#define SAP_REG_STATE_REGISTERED				0x00000002	// RegisterSap completed
#define SAP_REG_STATE_DEREGISTERING				0x00000004	// Sent DeregisterSap


//
//  ---- ATMLANE Buffer Tracker ----
//
//  Keeps track of allocation information for a pool of buffers. A list
//  of these structures is used to maintain info about a dynamically
//  growable pool of buffers (e.g. for LANE data packet header buffers)
//

typedef struct _ATMLANE_BUFFER_TRACKER
{
	struct _ATMLANE_BUFFER_TRACKER *	pNext;		// in a list of trackers
	NDIS_HANDLE							NdisHandle;	// for Buffer Pool
	PUCHAR								pPoolStart;	// start of memory chunk allocated
													// from the system
} ATMLANE_BUFFER_TRACKER, *PATMLANE_BUFFER_TRACKER;

//
//  NULL pointer to ATMARP Buffer tracker structure
//
#define NULL_PATMLANE_BUFFER_TRACKER	((PATMLANE_BUFFER_TRACKER)NULL)


//
//  ------------------------ ATM Address Entry ------------------------
//
//  All information about an ATM destination and the VCs associated 
//	with it.  One of these entries is used for a given ATM Address
//	with the exception of LANE services ATM Addresses

//  
//  It is deleted when all references (see below) to this entry are gone.
//  
//  One Data Direct VC can associated with this entry. One or more ARP Table 
//  Entries could point to this entry, because more than one MAC address 
//  could map to this ATM address.
//  
//  Reference Count: we add one to the RefCount for each of the following:
//  - Each VC associated with the entry.
//  - Each MAC Entry that points to it.
//	- BusTimer active.
//	- FlushTimer active.
//  - For the duration that another structure points to it.
//  
typedef struct _ATMLANE_ATM_ENTRY
{
#if DBG
	ULONG						atmlane_atm_sig;	// Signature for debugging
#endif
	struct _ATMLANE_ATM_ENTRY *	pNext;				// Next entry on this elan 
	ULONG						RefCount;			// References to this struct
	ULONG						Flags;				// State information
	ULONG						Type;				// Type of entry
	ATMLANE_LOCK				AeLock;				
	struct _ATMLANE_ELAN  *		pElan;				// Back pointer to parent
	struct _ATMLANE_VC  *		pVcList;				// List of VCs to this address
	struct _ATMLANE_VC	*		pVcIncoming;		// Optional incoming VC if server
	struct _ATMLANE_MAC_ENTRY *	pMacEntryList;		// List of MAC entries that
													// point to this entry
	ATM_ADDRESS					AtmAddress;			// ATM Address of this entry
	PATMLANE_TIMER				FlushTimer;			// Flush protocol timer
	ULONG						FlushTid;			// Transaction ID of Flush Request
}
	ATMLANE_ATM_ENTRY,
	*PATMLANE_ATM_ENTRY;

#if DBG
#define atmlane_atm_signature	'EALA'
#endif

//
//  NULL pointer to ATMLANE ATM ENTRY
//
#define NULL_PATMLANE_ATM_ENTRY		((PATMLANE_ATM_ENTRY)NULL)

//
//  Definitions for Flags in ATMLANE ATM ENTRY
//
//
//	Bits 0-4 contain the state of an ATM Entry.
//
#define ATM_ENTRY_STATE_MASK					0x00000007
#define ATM_ENTRY_IDLE							0x00000000	// Just created
#define ATM_ENTRY_VALID							0x00000001	// Installed into the database
#define ATM_ENTRY_CONNECTED						0x00000002	// VC connected
#define ATM_ENTRY_CLOSING						0x00000004  // entry is about to go away

#define ATM_ENTRY_CALLINPROGRESS				0x00000010	// Call underway
#define ATM_ENTRY_WILL_ABORT					0x80000000	// Preparing to abort this

//
//	Definitions for Type in ATMLANE ATM ENTRY
//
#define ATM_ENTRY_TYPE_PEER						0
#define ATM_ENTRY_TYPE_LECS						1
#define ATM_ENTRY_TYPE_LES						2
#define ATM_ENTRY_TYPE_BUS						3



//
//  ------------------------ MAC (ARP Table) Entry ------------------------
//
//	Contains information about one remote MAC address.
//
//	It is assumed that each MAC address resolves to exactly on ATM address.
//	So there is at most one ARP Table entry for a given MAC address.
//
//	The MAC entry participates in two lists:
//	(1) A list of all entries that hash to the same bucket in the ARP Table.
//	(2) A list of all entries that resolve to the same ATM address.
//
//	Reference Count: We add one to its ref count for each of the following:
//	- For the duration an active timer exists on this entry.
//  - For the duration the entry belongs to the list of MAC entries linked
//	  to an ATM entry.
//
typedef struct _ATMLANE_MAC_ENTRY
{
#if DBG
	ULONG						atmlane_mac_sig;	// Signature for debugging
#endif
	struct _ATMLANE_MAC_ENTRY *	pNextEntry;			// Next in hash list
	struct _ATMLANE_MAC_ENTRY * pNextToAtm;			// List of entries pointing to 
													// the save ATM Entry
	ULONG						RefCount;			// References to this struct
	ULONG						Flags;				// State and Type information
	ATMLANE_LOCK				MeLock;				// Lock for this structure
	MAC_ADDRESS					MacAddress;			// MAC Address
	ULONG						MacAddrType;		// Type of Addr (MAC vs RD)
	struct _ATMLANE_ELAN *		pElan;				// Back pointer to Elan
	PATMLANE_ATM_ENTRY			pAtmEntry;			// Pointer to ATM entry
	ATMLANE_TIMER				Timer;				// For ARP and Aging
	ATMLANE_TIMER				FlushTimer;			// For Flushing
	ULONG						RetriesLeft;		// Number of ARP retries left
	PNDIS_PACKET				PacketList;			// Packet list
	ULONG						PacketListCount;	// Number packets queued
	NDIS_TIMER					BusTimer;			// For metering Bus Sends
    ULONG						BusyTime;			// For metering Bus Sends
    ULONG						LimitTime;			// For metering Bus Sends
    ULONG						IncrTime;			// For metering Bus Sends
    ULONG						FlushTid;			// TID of outstanding flush
    ULONG						ArpTid;				// TID of outstanding arp
}
	ATMLANE_MAC_ENTRY,
	*PATMLANE_MAC_ENTRY;

#if DBG
#define atmlane_mac_signature	'EMLA'
#endif

//
//  NULL pointer to ATMLANE MAC ENTRY
//
#define NULL_PATMLANE_MAC_ENTRY		((PATMLANE_MAC_ENTRY)NULL)

//
//  Definitions for Flags in ATMLANE MAC ENTRY
//
#define MAC_ENTRY_STATE_MASK		0x0000007F
#define MAC_ENTRY_NEW				0x00000001		// Brand new
#define MAC_ENTRY_ARPING			0x00000002		// Running ARP protocol
#define MAC_ENTRY_RESOLVED			0x00000004		// Calling
#define MAC_ENTRY_FLUSHING			0x00000008		// Flushing
#define MAC_ENTRY_ACTIVE			0x00000010		// Connected
#define MAC_ENTRY_AGED				0x00000020		// Aged Out
#define MAC_ENTRY_ABORTING			0x00000040		// Aborting

#define MAC_ENTRY_BROADCAST			0x00010000		// Is broadcast address (BUS)
#define MAC_ENTRY_BUS_TIMER			0x00040000		// BUS timer running
#define MAC_ENTRY_USED_FOR_SEND		0x00080000      // Was used for send 

//
//  ------------------------ ATMLANE Virtual Circuit (VC) ---------------------
//
//	One of these is used for each call terminated at the ELAN.
//	Creation and deletion of this structure is linked to NdisCoCreateVc and
//	NdisCoDeleteVc.
//
typedef struct _ATMLANE_VC
{
#if DBG
	ULONG						atmlane_vc_sig;		// Signature for debuging
#endif
	struct _ATMLANE_VC *		pNextVc;			// Next VC in list
	ULONG						RefCount;			// References to this struct
	ULONG						OutstandingSends;	// Packets pending CoSendComplete
	ATMLANE_LOCK				VcLock;
	ULONG						Flags;				// State and Type information
	ULONG						LaneType;			// LANE type of VC 
	NDIS_HANDLE					NdisVcHandle;		// NDIS handle for this VC
	struct _ATMLANE_ELAN *		pElan;				// Back pointer to parent Elan
	PATMLANE_ATM_ENTRY			pAtmEntry;			// Back pointer to ATM Entry
	ATMLANE_TIMER				AgingTimer;			// Aging Timer
	ULONG						AgingTime;			// Aging Time
	ATMLANE_TIMER				ReadyTimer;			// Ready Timer
	ULONG						RetriesLeft;		// retries left
	ATM_ADDRESS					CallingAtmAddress;	// Calling party ATM Address
													//   in call for this VC
	ULONG						ReceiveActivity;	// non-zero if receive activity seen													
}
	ATMLANE_VC,
	*PATMLANE_VC;

#if DBG
#define atmlane_vc_signature	'CVLA'
#endif
	
//
//  NULL pointer to ATMLANE VC
//
#define NULL_PATMLANE_VC	((PATMLANE_VC)NULL)

//
//  Definitions for ATMLANE VC flags. The following information is kept
//  here:
//		- Is this VC an SVC or PVC
//  	- Is this created (owned) by an Elan or the Call Manager
//  	- Call State: Incoming in progress, Outgoing in progress, Active,
//		- LANE Ready state
//		- Close in progress
//

//  Bits 0-1 for svc vs pvc type
#define VC_TYPE_MASK							0x00000003
#define VC_TYPE_UNUSED							0x00000000
#define VC_TYPE_SVC								0x00000001
#define VC_TYPE_PVC								0x00000002

//  Bits 2-3 for "Owner"
#define VC_OWNER_MASK							0x0000000C
#define VC_OWNER_IS_UNKNOWN						0x00000000
#define VC_OWNER_IS_ATMLANE						0x00000004	// NdisClCreateVc done
#define VC_OWNER_IS_CALLMGR						0x00000008	// CreateVcHandler done

// Bits 4-7 for Call State
#define VC_CALL_STATE_MASK						0x000000F0
#define VC_CALL_STATE_IDLE						0x00000000
#define VC_CALL_STATE_INCOMING_IN_PROGRESS		0x00000010	// Wait for CallConnected
#define VC_CALL_STATE_OUTGOING_IN_PROGRESS		0x00000020	// Wait for MakeCallCmpl
#define VC_CALL_STATE_ACTIVE					0x00000040
#define VC_CALL_STATE_CLOSE_IN_PROGRESS			0x00000080	// Wait for CloseCallCmpl

// Bits 8-9 to indicate waiting for LANE Ready state
#define VC_READY_STATE_MASK						0x00000300
#define VC_READY_WAIT							0x00000100
#define VC_READY_INDICATED						0x00000200

// Bit 10 to indicate whether we are closing this VC
#define VC_CLOSE_STATE_MASK						0x00000400
#define VC_CLOSE_STATE_CLOSING					0x00000400

// Bit 12 to indicate whether we have seen an incoming close
#define VC_SEEN_INCOMING_CLOSE					0x00001000

//
// Definitions for LaneType
//
#define VC_LANE_TYPE_UNKNOWN					0
#define VC_LANE_TYPE_CONFIG_DIRECT				1	// LECS Connection (bidirectional)
#define VC_LANE_TYPE_CONTROL_DIRECT				2	// LES Connection  (bidirectional)
#define VC_LANE_TYPE_CONTROL_DISTRIBUTE			3	// LES Connection  (uni,incoming)
#define VC_LANE_TYPE_DATA_DIRECT				4	// LEC Connection  (bidirectional)
#define VC_LANE_TYPE_MULTI_SEND					5	// BUS Connection  (bidirectional)
#define VC_LANE_TYPE_MULTI_FORWARD				6	// BUS Connection  (uni,incoming)

//
//	------------------------ ELAN Event Object ------------------
//

typedef struct _ATMLANE_EVENT
{
	ULONG						Event;				// Latest state-related event 
	NDIS_STATUS					EventStatus;		// Status related to current event
	LIST_ENTRY					Link;				// event queue link
} 
	ATMLANE_EVENT,
	*PATMLANE_EVENT;

//
//	------------------------ ELAN Delayed Event Object ----------
//

typedef struct _ATMLANE_DELAYED_EVENT
{
	struct _ATMLANE_EVENT		DelayedEvent;		// event info
	struct _ATMLANE_ELAN *		pElan;				// target ELAN for this event
	NDIS_TIMER					DelayTimer;			// To implement the delay
} 
	ATMLANE_DELAYED_EVENT,
	*PATMLANE_DELAYED_EVENT;
	
	
//
//  ------------------------ ELAN Object ------------------------
//

//
//  ELAN object represents an ELAN instance and it's 
//  corresponding virtual miniport adapter.
//

typedef struct _ATMLANE_ELAN
{
#if DBG
	ULONG						atmlane_elan_sig;
#endif // DBG
	LIST_ENTRY					Link;				// for adapter's elan list
	ATMLANE_LOCK				ElanLock;			// Mutex for elan struct
	ATMLANE_BLOCK				Block;
	ULONG						RefCount;			// references to this elan
	ULONG						AdminState;			// Desired state of this elan
	ULONG						State;				// (Actual) State of this elan
	LIST_ENTRY					EventQueue;			// Event queue
	NDIS_WORK_ITEM				EventWorkItem;		// For event handling
	ULONG						RetriesLeft;		// For retry handling
	ATMLANE_TIMER				Timer;				// Timer for svr call & request timeouts
	NDIS_WORK_ITEM				NdisWorkItem;		// For scheduling a passive-level thread
	ULONG						Flags;				// Misc state information
	PATMLANE_DELAYED_EVENT		pDelayedEvent;		// Event to be queued in a while

	//
	//	------ Adapter related ----
	//
	struct _ATMLANE_ADAPTER *	pAdapter;			// back pointer to adapter parent
	NDIS_HANDLE					NdisAdapterHandle;	// cached adapter handle

	//
	//	------ Call Manager related ----
	//
	NDIS_HANDLE					NdisAfHandle;		// handle to call manager
	ULONG						AtmInterfaceUp;		// The ATM interface is considered
													// "up" after ILMI addr reg is over
	ATMLANE_SAP					LesSap;				// Control Distribute SAP
	ATMLANE_SAP					BusSap;				// Multicast Forward SAP
	ATMLANE_SAP					DataSap;			// Data Direct SAP
	ULONG						SapsRegistered;		// Number of Saps registered
	ATMLANE_BLOCK				AfBlock;			// Used to block shutdown while
													// AF open is in progress

	//
	//	------ Virtual Miniport related ----
	//
	NDIS_HANDLE					MiniportAdapterHandle;// Virtual Miniport NDIS handle
	NDIS_STRING					CfgDeviceName;		// Miniport netcard driver name
	ULONG						CurLookAhead;		// Current established lookahead size
	ULONG						CurPacketFilter;	// Current packet filter bits
	ULONG						FramesXmitGood;
	ULONG						FramesRecvGood;
	ATMLANE_BLOCK				InitBlock;			// Used to block while IMInit
													// is in progress

	//
	//	------ Timer data ----
	//
	ATMLANE_TIMER_LIST			TimerList[ALT_CLASS_MAX];
	ATMLANE_LOCK				TimerLock;			// Mutex for timer structures

	//
	//	----- LECS Configuration Parameters ----
	//
	BOOLEAN					    CfgUseLecs;
	BOOLEAN					    CfgDiscoverLecs;
	ATM_ADDRESS				    CfgLecsAddress;
	
	//
	//	----- ELAN Configuration Parameters ----
	//
	NDIS_STRING					CfgBindName;
	NDIS_STRING					CfgElanName;
	ULONG						CfgLanType;
	ULONG						CfgMaxFrameSizeCode;
	ATM_ADDRESS					CfgLesAddress;
	
	//
	//	----- ELAN Run-Time Parameters ----
	//
	ULONG						ElanNumber;			// logical Elan number
	ATM_ADDRESS					AtmAddress;			// (C1)  - LE Client's ATM Address
	UCHAR						LanType;			// (C2)  - LAN Type
	UCHAR						MaxFrameSizeCode;	// (C3)  - Maximum Data Frame Size Code
	ULONG						MaxFrameSize;		//		 - Maximum Data Frame Size Value
	USHORT						LecId;				// (C14) - LE Client Identifier
	UCHAR		ElanName[LANE_ELANNAME_SIZE_MAX];	// (C5)  - ELAN Name
	UCHAR						ElanNameSize;		//         Size of above
	MAC_ADDRESS					MacAddressEth;		// (C6)  - Elan's MAC Address (Eth/802.3 format)
	MAC_ADDRESS					MacAddressTr;		//		   Elan's MAC Address (802.5 format)
	ULONG						ControlTimeout;		// (C7)  - Control Time-out
	ATM_ADDRESS					LesAddress;			// (C9)  - LE Server ATM Address
	ULONG						MaxUnkFrameCount;	// (C10) - Maximum Unknown Frame Count
	ULONG						MaxUnkFrameTime;	// (C11) - Maximum Unknown Frame Time
	ULONG						LimitTime;			//         Precalculated values for
	ULONG						IncrTime;			//           limiting bus traffic
	ULONG						VccTimeout;			// (C12) - VCC Time-out Period
	ULONG						MaxRetryCount;		// (C13) - Maximum Retry Count
	MAC_ADDRESS	   McastAddrs[MCAST_LIST_SIZE]; 	// (C15) - Multicast MAC Addresses
	ULONG						McastAddrCount;		//		   Number of above
	ULONG						AgingTime;			// (C17) - Aging Time
	ULONG						ForwardDelayTime;	// (C18) - Forward Delay Time
	ULONG						TopologyChange;		// (C19) - Topology Change
	ULONG						ArpResponseTime;	// (C20) - Expected LE_ARP Response Time
	ULONG						FlushTimeout;		// (C21) - Flush Time-out
	ULONG						PathSwitchingDelay;	// (C22) - Path Switching Delay
	ULONG						LocalSegmentId;		// (C23) - Local Segment ID
	ULONG						McastSendVcType;	// (C24) - Mcast Send VCC Type (ignored)
	ULONG						McastSendVcAvgRate; // (C25) - Mcast Send Avg Rate (ignored)
	ULONG						McastSendVcPeakRate;// (C26) - Mcast Send Peak Rate (ignored)
	ULONG						ConnComplTimer;		// (C28) - Connection Completion Timer
	ULONG						TransactionId;		// LANE Control Frame Tid
	ATM_ADDRESS					LecsAddress;		// LECS ATM Address
	ATM_ADDRESS					BusAddress;			// BUS ATM Address
	ULONG						MinFrameSize;		// Minimum LANE frame size
	NDIS_STATUS					LastEventCode;		// Used to avoid repeated event logging
	
	//
	//  ----- Buffer Management: Header buffers and Protocol buffers ----
	//
	ATMLANE_LOCK				HeaderBufferLock;	// Mutex for header buffers
	PNDIS_BUFFER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						RealHeaderBufSize;	// Above size rounded up to mult of 4
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMLANE_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers
	PNDIS_BUFFER				PadBufList;
	ULONG						PadBufSize;			// Size of pad buffers
	ULONG						MaxPadBufs;			// Max pad buffers we can allocate
	ULONG						CurPadBufs;			// Current pad buffers allocated
	PATMLANE_BUFFER_TRACKER		pPadTrkList;		// Info about allocated pad buffers
	NDIS_HANDLE					ProtocolPacketPool;	// Handle for Packet pool
	NDIS_HANDLE					ProtocolBufferPool;	// Handle for Buffer pool
	PUCHAR						ProtocolBufList;	// Free list of protocol buffers (for
													// LANE control packets)
	PUCHAR						ProtocolBufTracker;	// Start of chunk of memory used for
													// the above.
	ULONG						ProtocolBufSize;	// Size of each protocol buffer
	ULONG						MaxProtocolBufs;	// Number of protocol buffers
	NDIS_HANDLE					TransmitPacketPool;	// Handle for transmit packet pool
	NDIS_HANDLE					ReceivePacketPool;	// Handle for receive packet pool
	NDIS_HANDLE					ReceiveBufferPool;	// Handle for receive buffer pool 
#if PKT_HDR_COUNTS
	ULONG						XmitPktCount;
	ULONG						RecvPktCount;
	ULONG						ProtPktCount;
#endif // PKT_HDR_COUNTS
#if SENDLIST
	PNDIS_PACKET				pSendList;
	NDIS_SPIN_LOCK				SendListLock;
#endif // SENDLIST

	//
	//	----- MAC Entry Cache ----- (C16)
	//
	PATMLANE_MAC_ENTRY	*		pMacTable;			// (C16) LE_ARP Cache
	ULONG						NumMacEntries;		// Count of entries in cache
	ATMLANE_LOCK				MacTableLock;		// Mutex for above table

	//
	//	----- Connection Cache -----
	//
	PATMLANE_ATM_ENTRY			pLecsAtmEntry;		// LE Configuration Server
	PATMLANE_ATM_ENTRY			pLesAtmEntry;		// LAN Emulation Server
	PATMLANE_ATM_ENTRY			pBusAtmEntry;		// Broadcast & Unknown Server
	PATMLANE_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
	ULONG						NumAtmEntries;		// Count of entries
	ATMLANE_LOCK				AtmEntryListLock;	// Mutex for above list
	
}
	ATMLANE_ELAN,
	*PATMLANE_ELAN;

#if DBG
#define atmlane_elan_signature 'LELA'
#endif

//
//  NULL pointer to ATMLANE ELAN
//
#define NULL_PATMLANE_ELAN	((PATMLANE_ELAN)NULL)

//
//	Definitions of ATMLANE ELAN States.
//
#define ELAN_STATE_ALLOCATED				0
#define ELAN_STATE_INIT						1
#define ELAN_STATE_LECS_CONNECT_ILMI		2
#define ELAN_STATE_LECS_CONNECT_WKA			3
#define ELAN_STATE_LECS_CONNECT_PVC			4
#define ELAN_STATE_LECS_CONNECT_CFG			5
#define ELAN_STATE_CONFIGURE				6
#define ELAN_STATE_LES_CONNECT				7
#define ELAN_STATE_JOIN						8
#define ELAN_STATE_BUS_CONNECT				9
#define ELAN_STATE_OPERATIONAL				10
#define ELAN_STATE_SHUTDOWN					11

//
//	Definitions of ATMLANE Elan Flags
//
//
//	Bits 0 thru 3 define the current LECS Connect attempt
//
#define ELAN_LECS_MASK						0x0000000f
#define ELAN_LECS_ILMI						0x00000001
#define ELAN_LECS_WKA						0x00000002
#define ELAN_LECS_PVC						0x00000004
#define ELAN_LECS_CFG						0x00000008

//
//	Bit 4 & 5 define the virtual miniport state
//
#define ELAN_MINIPORT_INITIALIZED			0x00000010
#define ELAN_MINIPORT_OPERATIONAL			0x00000020

//
//	Bit 6 defines event work item scheduling state
//
#define ELAN_EVENT_WORK_ITEM_SET			0x00000040

//
//  Bit 7 specifies if we want to restart this ELAN
//
#define ELAN_NEEDS_RESTART					0x00000080

#define ELAN_SAW_AF_CLOSE					0x00000100

//
//  Bit 9 defines whether there is a pending IMInitializeDeviceInstance
//  on the ELAN, i.e. we expect to see a MiniportInitialize.
//
#define ELAN_MINIPORT_INIT_PENDING			0x00000200

//
//  Bit 10 defines whether we are in the process of opening
//  an AF handle.
//
#define ELAN_OPENING_AF						0x00000400

//
//  This bit indicates whether this ELAN is being deallocated.
//
#define ELAN_DEALLOCATING					0x80000000

//
//	Elan events
//
#define ELAN_EVENT_START					1
#define ELAN_EVENT_NEW_ATM_ADDRESS			2
#define ELAN_EVENT_GOT_ILMI_LECS_ADDR		3
#define ELAN_EVENT_SVR_CALL_COMPLETE		4
#define ELAN_EVENT_CONFIGURE_RESPONSE		5
#define ELAN_EVENT_SAPS_REGISTERED			6
#define ELAN_EVENT_JOIN_RESPONSE			7
#define ELAN_EVENT_ARP_RESPONSE				8
#define ELAN_EVENT_BUS_CALL_CLOSED			9
#define ELAN_EVENT_LES_CALL_CLOSED			10
#define ELAN_EVENT_LECS_CALL_CLOSED			11
#define ELAN_EVENT_RESTART					12
#define ELAN_EVENT_STOP						13

//
//	Event status codes - use NDIS status codes
//	but make up one for timeout
//
#define NDIS_STATUS_TIMEOUT					((NDIS_STATUS)STATUS_TIMEOUT)


//
//	------------------------ ElanName Object ------------------------
//

typedef struct _ATMLANE_NAME
{
	struct _ATMLANE_NAME *	pNext;
	NDIS_STRING				Name;
} ATMLANE_NAME,
  *PATMLANE_NAME;


//
//  ------------------------ Adapter Object ------------------------
//


//
//  Adapter object represents an actual ATM adapter.
//

typedef struct _ATMLANE_ADAPTER
{
#if DBG
	ULONG					atmlane_adapter_sig;
#endif
	//
	//  Reference count and lock to protect this object.
	//
	ULONG					RefCount;
	ATMLANE_LOCK			AdapterLock;
	//
	//	State
	//
	ULONG					Flags;

	//
	//	Block data structure for blocking threads during adapter requests.
	//
	ATMLANE_BLOCK			Block;

	//
	//	Link for global adapter list.
	//
	LIST_ENTRY				Link;

	//
	//	Adapter handle and such.
	//
	NDIS_HANDLE				NdisAdapterHandle;
	NDIS_HANDLE				BindContext;
	NDIS_HANDLE				UnbindContext;

	//
	//	Protocol configuration handle and string for opening it.
	//
	NDIS_STRING				ConfigString;

	//
	//	Adapter parameters acquired from miniport
	//
	MAC_ADDRESS				MacAddress;
	ULONG					MaxAAL5PacketSize;
	NDIS_CO_LINK_SPEED		LinkSpeed;

	//
	//  Adapter configuration parameters.
	//  These only exist on Memphis/Win98.
	//	
	BOOLEAN					RunningOnMemphis;
    NDIS_STRING				CfgUpperBindings;
    PATMLANE_NAME			UpperBindingsList;
	NDIS_STRING				CfgElanName;
	PATMLANE_NAME			ElanNameList;

	//
	//	List of created ELANs.
	//
	LIST_ENTRY				ElanList;
	UINT					ElanCount;

	//
	//  Used to block Unbind while bootstrapping ELANs.
	//
	ATMLANE_BLOCK			UnbindBlock;

	//
	//  Used to block AF notification while querying the ATM adapter.
	//
	ATMLANE_BLOCK			OpenBlock;

	//
	//  Name of device. Used to protect against multiple calls to our
	//  BindAdapter handler for the same device.
	//
	NDIS_STRING				DeviceName;
}
	ATMLANE_ADAPTER,
	*PATMLANE_ADAPTER;

#if DBG
#define atmlane_adapter_signature 'DALA'
#endif

//
//  NULL pointer to ATMLANE Adapter
//
#define NULL_PATMLANE_ADAPTER	((PATMLANE_ADAPTER)NULL)

//
//  Definitions for Adapter State Flags
//
#define ADAPTER_FLAGS_AF_NOTIFIED               0x00000001
#define ADAPTER_FLAGS_UNBINDING					0x00000002
#define ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING	0x00000004
#define ADAPTER_FLAGS_CLOSE_IN_PROGRESS			0x00000008
#define ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS		0x00000010
#define ADAPTER_FLAGS_OPEN_IN_PROGRESS			0x00000100
#define ADAPTER_FLAGS_DEALLOCATING				0x80000000

#endif // __ATMLANE_ATMLANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\adapter.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	adapter.c

Abstract:

	Handlers for adapter events.
	
Author:

	Larry Cleeton, FORE Systems (v-lcleet)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NDIS_STATUS
AtmLanePnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
)
/*++

Routine Description:

	Handler for PnP Events.

Arguments:

	ProtocolBindingContext		-	Handle to protocol's adapter binding context.
									Actually a pointer to our adapter struct.

	pNetPnPEvent				- 	Pointer to PnP Event structure describing the event.

Return Value:

	Status of handling the event.
	
--*/
{
	NDIS_STATUS						Status;
	PATMLANE_ADAPTER				pAdapter;
	PNET_DEVICE_POWER_STATE			pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(PnPEventHandler);

	//	Extract the adapter struct pointer - this will be NULL for
	//  global reconfig messages.

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	
	switch (pNetPnPEvent->NetEvent)
	{
		case NetEventSetPower:
			DBGP((1, "PnPEventHandler: NetEventSetPower\n"));
			switch (*pPowerState)
			{
				case NetDeviceStateD0:

					Status = NDIS_STATUS_SUCCESS;
					break;
				
				default:

					//
					//  We can't suspend, so we ask NDIS to unbind us by
					//  returning this status:
					//
					Status = NDIS_STATUS_NOT_SUPPORTED;
					break;
			}
			break;
		case NetEventQueryPower:
			DBGP((1, "PnPEventHandler: NetEventQueryPower succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventQueryRemoveDevice:
			DBGP((1, "PnPEventHandler: NetEventQueryRemoveDevice succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventCancelRemoveDevice:
			DBGP((1, "PnPEventHandler: NetEventCancelRemoveDevice succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventBindList:
			DBGP((1, "PnPEventHandler: NetEventBindList not supported\n"));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		case NetEventMaximum:
			DBGP((1, "PnPEventHandler: NetEventMaximum not supported\n"));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		case NetEventReconfigure:
			DBGP((1, "PnPEventHandler: NetEventReconfigure\n"));
			Status = AtmLaneReconfigureHandler(pAdapter, pNetPnPEvent);
			break;
		default:
			DBGP((1, "PnPEventHandler: Unknown event 0x%x not supported\n", 
					pNetPnPEvent->NetEvent));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}
		
	TRACEOUT(PnPEventHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return Status;
}


VOID
AtmLaneBindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	)
/*++

Routine Description:

	Handler for BindAdapter event from NDIS.

Arguments:

	Status			-	Points to a variable to return the status
						of the bind operation.
	BindContext		- 	NDIS supplied handle to be used in call to 
						NdisCompleteBindAdapter.
	pDeviceName		- 	Points to a counted, zero-terminated Unicode
						string naming the adapter to open. 
	SystemSpecific1	-	Registry path pointer to be used in call to
						NdisOpenProtocolConfiguration. 
	SystemSpecific2 - 	Reserved.

Return Value:

	None.
	
--*/
{
	PATMLANE_ADAPTER				pAdapter;
	PATMLANE_ELAN					pElan;
	NDIS_STATUS						Status;
	NDIS_STATUS						OutputStatus;
	NDIS_STATUS						OpenStatus;
	NDIS_MEDIUM						Media;
	UINT							MediumIndex;
	ULONG							rc;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(BindAdapterHandler);

	do
	{
		//
		//	Initialize for error clean-up.
		//
		Status = NDIS_STATUS_SUCCESS;
		pAdapter = NULL_PATMLANE_ADAPTER;

		if (AtmLaneIsDeviceAlreadyBound(pDeviceName))
		{
			DBGP((0, "BindAdapterHandler: duplicate bind to %ws\n", pDeviceName->Buffer));
			Status = NDIS_STATUS_NOT_ACCEPTED;
			break;
		}

		//
		//	Allocate Adapter structure.
		//
		pAdapter = AtmLaneAllocAdapter(pDeviceName, SystemSpecific1);
		if (NULL_PATMLANE_ADAPTER == pAdapter)
		{
			DBGP((0, "BindAdapterHandler: Allocate of adapter struct failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Put open adapter reference on the Adapter struct.
		//
		(VOID)AtmLaneReferenceAdapter(pAdapter, "openadapter");		

		//
		//	Save bind context
		//
		pAdapter->BindContext = BindContext;

		//
		//	Open the Adapter.
		//
		INIT_BLOCK_STRUCT(&(pAdapter->Block));
		INIT_BLOCK_STRUCT(&(pAdapter->OpenBlock));
		pAdapter->Flags |= ADAPTER_FLAGS_OPEN_IN_PROGRESS;
		
		Media = NdisMediumAtm;

		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(MediumIndex),						
			&Media,
			1,
			pAtmLaneGlobalInfo->NdisProtocolHandle,
			(NDIS_HANDLE)pAdapter,
			pDeviceName,
			0,
			(PSTRING)NULL);
			
		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for completion.
			//
			Status = WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "BindAdapterHandler: NdisOpenAdapter failed, status %x\n",
						Status));
			break;
		}

		//
		//  Get info from Adapter
		//
		AtmLaneGetAdapterInfo(pAdapter);

		//
		//  Allow an AF notification thread to proceed now.
		//
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags &= ~ADAPTER_FLAGS_OPEN_IN_PROGRESS;
		SIGNAL_BLOCK_STRUCT(&pAdapter->OpenBlock, NDIS_STATUS_SUCCESS);
		RELEASE_ADAPTER_LOCK(pAdapter);

		break;		

	} while (FALSE);


	//
	//	If bad status then cleanup.
	//
	if (NDIS_STATUS_SUCCESS != Status)
	{
		//
		//	Dereference the Adapter struct if it exists
		//
		if (NULL_PATMLANE_ADAPTER != pAdapter)
		{
			rc = AtmLaneDereferenceAdapter(pAdapter, "openadapter");
			ASSERT(rc == 0);
		}
		
		DBGP((0, "BindAdapterHandler: Bad status %x\n", Status));
	}

	//
	//	Output Status
	//
	*pStatus = Status;


	TRACEOUT(BindAdapterHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneUnbindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	)
/*++

Routine Description:

	Handler for UnBindAdapter event from NDIS.

Arguments:

	Status					-	Points to a variable to return the status
								of the unbind operation.
	ProtocolBindingContext	- 	Specifies the handle to a protocol-allocated context area
								in which the protocol driver maintains per-binding runtime
								state. The driver supplied this handle when it called
								NdisOpenAdapter. 
	UnbindContext			-	Specifies a handle, supplied by NDIS, that the protocol
								passes subsequently to NdisCompleteUnbindAdapter. 

Return Value:

	None.
	
--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PLIST_ENTRY				p;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNextAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	ULONG					rc;
	ULONG					i;
	BOOLEAN					WasCancelled;
	BOOLEAN					CompleteUnbind;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(UnbindAdapterHandler);

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	DBGP((0, "UnbindAdapterHandler: pAdapter %p, UnbindContext %x\n",
				pAdapter, UnbindContext));

	*pStatus = NDIS_STATUS_PENDING;


	//
	//  Save the unbind context for a possible later call to
	//  NdisCompleteUnbindAdapter.
	//  
	ACQUIRE_ADAPTER_LOCK(pAdapter);
	
	pAdapter->UnbindContext = UnbindContext;

	pAdapter->Flags |= ADAPTER_FLAGS_UNBINDING;

	while (pAdapter->Flags & ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS)
	{
		RELEASE_ADAPTER_LOCK(pAdapter);
		(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		ACQUIRE_ADAPTER_LOCK(pAdapter);
	}

	if (IsListEmpty(&pAdapter->ElanList))
	{	
		CompleteUnbind = TRUE;
	}
	else
	{
		//
		//  We will complete the unbind later.
		//
		pAdapter->Flags |= ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING;
		CompleteUnbind = FALSE;
	}

	RELEASE_ADAPTER_LOCK(pAdapter);

	//
	//  If there are no elans on this adapter, we are done.
	//

	if (CompleteUnbind)
	{
		AtmLaneCompleteUnbindAdapter(pAdapter);
		CHECK_EXIT_IRQL(EntryIrql); 
		return;
	}

	//
	//	Shutdown each ELAN
	//
	ACQUIRE_ADAPTER_LOCK(pAdapter);

	p = pAdapter->ElanList.Flink;
	while (p != &pAdapter->ElanList)
	{
		pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		ACQUIRE_ELAN_LOCK(pElan);
		AtmLaneReferenceElan(pElan, "tempUnbind");
		RELEASE_ELAN_LOCK(pElan);

		p = p->Flink;
	}

	RELEASE_ADAPTER_LOCK(pAdapter);

	p = pAdapter->ElanList.Flink;
	while (p != &pAdapter->ElanList)
	{
		pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		//
		// get next pointer before elan goes away
		//
		p = p->Flink;

		//
		//  Kill the ELAN
		//
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "tempUnbind");
		if (rc != 0)
		{
			AtmLaneShutdownElan(pElan, FALSE);
		}
	}

	TRACEOUT(UnbindAdapterHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCompleteUnbindAdapter(
	IN	PATMLANE_ADAPTER				pAdapter
)
/*++

Routine Description:

	Complete the process of adapter unbinding. All Elans on this
	adapter are assumed to have been removed.

	We start it off by calling NdisCloseAdapter. Action continues
	in our CloseAdapterComplete routine.

Arguments:

	pAdapter		- Pointer to the adapter being unbound.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CompleteUnbindAdapter);
	
	DBGP((3, "CompleteUnbindAdapter: pAdapter %x, AdapterHandle %x\n",
			pAdapter, pAdapter->NdisAdapterHandle));

	ASSERT(pAdapter->NdisAdapterHandle != NULL);

	pAdapter->Flags |= ADAPTER_FLAGS_CLOSE_IN_PROGRESS;

	NdisCloseAdapter(
		&Status,
		pAdapter->NdisAdapterHandle
		);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneCloseAdapterCompleteHandler(
			(NDIS_HANDLE)pAdapter,
			Status
			);
	}
	
	TRACEOUT(CompleteUnbindAdapter);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisOpenAdapter
	that had pended has completed. The thread that called NdisOpenAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of OpenAdapter
	OpenErrorStatus			- Error code in case of failure.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(OpenAdapterCompleteHandler);

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	
	TRACEOUT(OpenAdapterCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisCloseAdapter
	that had pended has completed. The thread that called NdisCloseAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of CloseAdapter

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;
	NDIS_HANDLE					UnbindContext;
	ULONG						rc;
#if DEBUG_IRQL
	KIRQL						EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CloseAdapterCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	pAdapter->Flags &= ~ADAPTER_FLAGS_CLOSE_IN_PROGRESS;

	pAdapter->NdisAdapterHandle = NULL;
	UnbindContext = pAdapter->UnbindContext;

	DBGP((0, "CloseAdapterComplete: pAdapter %x, UnbindContext %x\n",
			pAdapter, UnbindContext));

	//
	//	Dereference the Adapter (should free structure)
	//
	ACQUIRE_ADAPTER_LOCK(pAdapter);
	rc = AtmLaneDereferenceAdapter(pAdapter, "openadapter");
	ASSERT(rc == 0);

	//
	//  If NDIS had requested us to Unbind, complete the
	//  request now.
	//
	if (UnbindContext != (NDIS_HANDLE)NULL)
	{
		NdisCompleteUnbindAdapter(
			UnbindContext,
			NDIS_STATUS_SUCCESS
			);
	}
	else
	{
		//
		//  We initiated the unbind from our Unload handler,
		//  which would have been waiting for us to complete.
		//  Wake up that thread now.
		//
		SIGNAL_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block), NDIS_STATUS_SUCCESS);
	}

	TRACEOUT(CloseAdapterCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This routine is called when the miniport indicates that a Reset
	operation has just completed. We ignore this event.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of the reset operation.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;

	TRACEIN(ResetCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	DBGP((3, "Reset Complete on Adapter %x\n", pAdapter));

	TRACEOUT(ResetCompleteHandler);

	return;
}

VOID
AtmLaneRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call we made to NdisRequest() has
	completed. We would be blocked on our adapter structure, waiting for this
	to happen -- wake up the blocked thread.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure
	pNdisRequest			- The request that completed
	Status					- Status of the request.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(RequestCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	
	TRACEOUT(RequestCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This is currently ignored.
	
Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
	PATMLANE_ELAN					pElan;
	PLIST_ENTRY						Entry;

	TRACEIN(ReceiveCompleteHandler);
	
	TRACEOUT(ReceiveCompleteHandler);
	
	return;
}

VOID
AtmLaneStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates an adapter-wide
	status change. We ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{

	TRACEIN(StatusHandler);

	DBGP((3, "StatusHandler: ProtocolBindContext %x, Status %x\n",
			ProtocolBindingContext,
			GeneralStatus));

	TRACEOUT(StatusHandler);
			
	return;
}


VOID
AtmLaneStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This routine is called when the miniport wants to tell us about
	completion of a status change (?). Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	TRACEIN(StatusCompleteHandler);


	DBGP((3, "StatusCompleteHandler: ProtocolBindingContext %x\n",
					ProtocolBindingContext));
					
	TRACEOUT(StatusCompleteHandler);

	return;
}

VOID
AtmLaneCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This routine is called by NDIS when the ATM miniport is finished
	with a packet we had previously sent via NdisCoSendPackets.

	If packet originated within ATMLANE it is freed here.

	If packet originated in protocol above the virtual miniport
	the packet must be put back in it's original condition and
	returned to the protocol.
	
Arguments:

	Status					- Status of the NdisCoSendPackets.
	ProtocolVcContext		- Our context for the VC on which the packet was sent
							  (i.e. pointer to ATMLANE VC).
	pNdisPacket				- The packet whose "send" is being completed.

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;
	PATMLANE_ELAN			pElan;
	UINT					TotalLength;
	BOOLEAN					OwnerIsLane;
	PNDIS_BUFFER			pNdisBuffer;
	PNDIS_PACKET			pProtNdisPacket;
	ULONG					rc;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CoSendCompleteHandler);
	
	TRACELOGWRITE((&TraceLog, TL_COSENDCMPLTIN, pNdisPacket, Status));
	TRACELOGWRITEPKT((&TraceLog, pNdisPacket));

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc)

	ACQUIRE_VC_LOCK(pVc);

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	rc = AtmLaneDereferenceVc(pVc, "sendpkt");
	if (rc > 0)
	{
		pVc->OutstandingSends--;

		if ((pVc->OutstandingSends == 0) &&
			(IS_FLAG_SET(pVc->Flags,
						VC_CLOSE_STATE_MASK,
						VC_CLOSE_STATE_CLOSING)))
		{
			DBGP((1, "CoSendComplete: Vc %p, closing call\n", pVc));
			AtmLaneCloseCall(pVc);
			//
			//  VC lock is released above.
			//
		}
		else
		{
			RELEASE_VC_LOCK(pVc);
		}
	}

#if SENDLIST
	//
	//	Remove packet from send list if there
	//
	NdisAcquireSpinLock(&pElan->SendListLock);
	{
		PNDIS_PACKET 	*ppNextPkt;
		BOOLEAN			Found = FALSE;

		ppNextPkt = &(pElan->pSendList);
		
		while (*ppNextPkt != (PNDIS_PACKET)NULL)
		{
			if (*ppNextPkt == pNdisPacket)
			{
				*ppNextPkt = PSEND_RSVD(pNdisPacket)->pNextInSendList;
				Found = TRUE;
				break;
			}
			else
			{
				ppNextPkt = &(PSEND_RSVD((*ppNextPkt))->pNextInSendList);
			}
		}

		if (!Found)
		{
			DBGP((0, "CoSendCompleteHandler: Pkt %x Duplicate Completion\n", pNdisPacket));
			NdisReleaseSpinLock(&pElan->SendListLock);
			goto skipit;
		}
	}

	NdisReleaseSpinLock(&pElan->SendListLock);
#endif // SENDLIST

#if PROTECT_PACKETS
	//
	//	Lock the packet
	//
	ACQUIRE_SENDPACKET_LOCK(pNdisPacket);

	//
	//	Mark it as having been completed by miniport.
	//	Remember completion status.
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) == 0);
	PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
	PSEND_RSVD(pNdisPacket)->CompletionStatus = Status;
	
	//
	//	Complete the packet only if the call to NdisCoSendPackets
	//	for this packet has returned.  Otherwise it will be completed
	//	when NdisCoSendPackets returns.
	//
	if ((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) != 0)
	{
		AtmLaneCompleteSendPacket(pElan, pNdisPacket, Status);
		//
		//	packet lock released in above
		//
	}
	else
	{
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
	}
#else	// PROTECT_PACKETS
	AtmLaneCompleteSendPacket(pElan, pNdisPacket, Status);
#endif	// PROTECT_PACKETS

#if SENDLIST
skipit:
#endif

	TRACELOGWRITE((&TraceLog, TL_COSENDCMPLTOUT, pNdisPacket));
	
	TRACEOUT(CoSendCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates a status
	change, possibly on a VC. Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	TRACEIN(CoStatusHandler);

	DBGP((3, "CoStatusHandler: ProtocolBindingContext %x "
			"ProtocolVcContext %x, Status %x\n",
			ProtocolBindingContext,
			ProtocolVcContext,
			GeneralStatus));

	TRACEOUT(CoStatusHandler);

	return;
}

NDIS_STATUS
AtmLaneSendAdapterNdisRequest(
	IN	PATMLANE_ADAPTER			pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS (non-Connection Oriented) request to the Miniport. 
	Initialize the NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	pAdapter				- Pointer to our Adapter structure representing
							  the adapter to which the request is to be sent
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisRequest.

--*/
{
	NDIS_STATUS			Status;

	TRACEIN(SendAdapterNdisRequest);

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	INIT_BLOCK_STRUCT(&(pAdapter->Block));
	
	NdisRequest(
			&Status,
			pAdapter->NdisAdapterHandle,
			pNdisRequest);

	if (Status == NDIS_STATUS_PENDING)
	{
		Status = WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
	}
		
	TRACEOUT(SendAdapterNdisRequest);

	return (Status);
}

VOID
AtmLaneGetAdapterInfo(
	IN	PATMLANE_ADAPTER			pAdapter
)
/*++

Routine Description:

	Query an adapter for hardware-specific information that we need:
		- burnt in hardware address (ESI part)
		- Max packet size
		- line rate

Arguments:

	pAdapter		- Pointer to ATMLANE adapter structure

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	NDIS_REQUEST			NdisRequest;
	ULONG					Value;

	TRACEIN(GetAdapterInfo);

	//
	//  Initialize.
	//
	NdisZeroMemory(&pAdapter->MacAddress, sizeof(MAC_ADDRESS));

	//
	//  MAC Address:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_HW_CURRENT_ADDRESS,
						(PVOID)&(pAdapter->MacAddress),
						sizeof(MAC_ADDRESS)
						);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		DBGP((0, "GetAdapterInfo: OID_ATM_HW_CURRENT_ADDRESS failed\n"));
	}
	else
	{
		DBGP((1, "GetAdapterInfo: ATM card MacAddr %s\n", 
			MacAddrToString(&pAdapter->MacAddress)));
	}

						
	//
	//  Max Frame Size:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_MAX_AAL5_PACKET_SIZE,
						(PVOID)&(pAdapter->MaxAAL5PacketSize),
						sizeof(ULONG)
						);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		DBGP((0, "GetAdapterInfo: OID_ATM_MAX_AAL5_PACKET_SIZE failed\n"));

		//
		//  Use the default.
		//
		pAdapter->MaxAAL5PacketSize = ATMLANE_DEF_MAX_AAL5_PDU_SIZE;
	}

	if (pAdapter->MaxAAL5PacketSize > ATMLANE_DEF_MAX_AAL5_PDU_SIZE)
	{
		pAdapter->MaxAAL5PacketSize = ATMLANE_DEF_MAX_AAL5_PDU_SIZE;
	}
	DBGP((1, "GetAdapterInfo: MaxAAL5PacketSize %d\n", pAdapter->MaxAAL5PacketSize));


	//
	//  Link speed:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_GEN_CO_LINK_SPEED,
						(PVOID)(&(pAdapter->LinkSpeed)),
						sizeof(NDIS_CO_LINK_SPEED)
						);

	if ((NDIS_STATUS_SUCCESS != Status) ||
		(0 == pAdapter->LinkSpeed.Inbound) ||
		(0 == pAdapter->LinkSpeed.Outbound))
	{
		DBGP((0, "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

		//
		//  Default and assume data rate for 155.52Mbps SONET
		//
		pAdapter->LinkSpeed.Outbound = pAdapter->LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;
	}
	DBGP((1, "GetAdapterInfo: Outbound Linkspeed %d\n", pAdapter->LinkSpeed.Outbound));
	DBGP((1, "GetAdapterInfo: Inbound  Linkspeed %d\n", pAdapter->LinkSpeed.Inbound));

	TRACEOUT(GetAdapterInfo);
	return;
}

UINT
AtmLaneCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is routine is called when a packet is received on a VC owned
	by the ATMLANE module.  It is dispatched based on the VC type.

Arguments:

	ProtocolBindingContext		- Actually a pointer to our Adapter structure
	ProtocolVcContext			- Actually a pointer to our VC structure
	pNdisPacket					- NDIS packet being received.

Return Value:

	0	- if packet is a LANE Control Packet or undesired data packet.
	1 	- if data packet indicated up to protocol.
	
--*/
{
	PATMLANE_ELAN			pElan;
	PATMLANE_VC				pVc;
	UINT					TotalLength;	// Total bytes in packet
	PNDIS_BUFFER			pNdisBuffer;	// Pointer to first buffer
	UINT					BufferLength;
	UINT					IsNonUnicast;	// Is this to a non-unicast destn MAC addr?
	BOOLEAN					RetainIt;		// Should we hang on to this packet?
	static ULONG			Count = 0;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CoReceivePacketHandler);
	
	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);
	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	// if ((++Count % 10) == 0)
	//  	DBGP((0, "%d Packets Received\n", Count));

	DBGP((2, "CoReceivePacketHandler: pVc %x Pkt %x\n", pVc, pNdisPacket));

	TRACELOGWRITE((&TraceLog, 
				TL_CORECVPACKET,	
				pNdisPacket,
				pVc));

	//
	//	Initialize
	//
	RetainIt = FALSE;	// default to discarding received packet
	
	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{

		switch(pVc->LaneType)
		{
			case VC_LANE_TYPE_CONFIG_DIRECT:

				AtmLaneConfigureResponseHandler(pElan, pVc, pNdisPacket); 
	
				break;

			case VC_LANE_TYPE_CONTROL_DIRECT:
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:

				AtmLaneControlPacketHandler(pElan, pVc, pNdisPacket);
				
				break;

			case VC_LANE_TYPE_DATA_DIRECT:
			case VC_LANE_TYPE_MULTI_SEND:
			case VC_LANE_TYPE_MULTI_FORWARD:
				
				if (ELAN_STATE_OPERATIONAL == pElan->State)
				{
					RetainIt = AtmLaneDataPacketHandler(pElan, pVc, pNdisPacket);
				}
				else
				{
					DBGP((0, "%d Dropping Pkt %x cuz Elan %x state is %d\n",
							pElan->ElanNumber,
							pNdisPacket,
							pElan,
							pElan->State));
				}

				break;

			default:

				DBGP((0, "CoReceivePacketHandler: pVc %x Type UNKNOWN!\n", pVc));

				break;
		}
	}

	TRACEOUT(CoReceivePacketHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (RetainIt);
}

VOID
AtmLaneUnloadProtocol(
	VOID
)
/*++

Routine Description:

	Unloads the ATMLANE protocol module. We unbind from all adapters,
	and deregister from NDIS as a protocol.

Arguments:

	None.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMLANE_ADAPTER	pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(UnloadProtocol);
	Status = NDIS_STATUS_SUCCESS;
	
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	//
	//	Until adapter list is empty...
	//
	while (!IsListEmpty(&pAtmLaneGlobalInfo->AdapterList))
	{
		//
		// Keep grabbing the first one on the list.
		//	
		pAdapter = CONTAINING_RECORD(
			pAtmLaneGlobalInfo->AdapterList.Flink,
			ATMLANE_ADAPTER, 
			Link
			);
		
		STRUCT_ASSERT(pAdapter, atmlane_adapter);

		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

		DBGP((3, "UnloadProtocol: will unbind adapter %x\n", pAdapter));

		INIT_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block));

		//
		// unbind which should delete the adapter struct
		// and remove it from global list
		//
		AtmLaneUnbindAdapterHandler(
				&Status,
				(NDIS_HANDLE)pAdapter,
				(NDIS_HANDLE)NULL		// No UnbindContext ==> Don't complete NdisUnbind
				);

		if (NDIS_STATUS_PENDING == Status)
		{
			//
			//  Wait for the unbind to complete
			//
			(VOID)WAIT_ON_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block));
		}

		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	FREE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	FREE_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

#if 0
	AuditShutdown();
#endif 

	if (pAtmLaneGlobalInfo->SpecialNdisDeviceHandle)
	{
		DBGP((0, "Deregistering device from UnloadProtocol\n"));
		Status = NdisMDeregisterDevice(pAtmLaneGlobalInfo->SpecialNdisDeviceHandle);
		pAtmLaneGlobalInfo->SpecialNdisDeviceHandle = NULL;
		ASSERT(NDIS_STATUS_SUCCESS == Status);
	}

	if (pAtmLaneGlobalInfo->NdisProtocolHandle)
	{
		DBGP((0, "UnloadProtocol: NdisDeregisterProtocol now, "
				"NdisProtocolHandle %x\n",
				pAtmLaneGlobalInfo->NdisProtocolHandle));

		NdisDeregisterProtocol(
			&Status,
			pAtmLaneGlobalInfo->NdisProtocolHandle
			);

		pAtmLaneGlobalInfo->NdisProtocolHandle = NULL;
	}

	ASSERT(NDIS_STATUS_SUCCESS == Status);

	TRACEIN(UnloadProtocol);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

//
// Dummy handlers so that a debug build won't complain
//
VOID
AtmLaneSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status
	)
{
}

VOID
AtmLaneTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
	)
{
}

NDIS_STATUS
AtmLaneReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					MacReceiveContext,
	IN	PVOID						HeaderBuffer,
	IN	UINT						HeaderBufferSize,
	IN	PVOID						LookAheadBuffer,
	IN	UINT						LookaheadBufferSize,
	IN	UINT						PacketSize
	)
{
	return(NDIS_STATUS_FAILURE);
}



BOOLEAN
AtmLaneIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
)
/*++

Routine Description:

	Check if we have already bound to a device (adapter).

Arguments:

	pDeviceName		- Points to device name to be checked.

Return Value:

	TRUE iff we already have an Adapter structure representing
	this device.

--*/
{
	PATMLANE_ADAPTER	pAdapter;
	BOOLEAN				bFound = FALSE;
	PLIST_ENTRY			pListEntry;

	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
		 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
		 pListEntry = pListEntry->Flink)
	{
		//
		// Keep grabbing the first one on the list.
		//	
		pAdapter = CONTAINING_RECORD(
			pListEntry,
			ATMLANE_ADAPTER, 
			Link
			);

		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			bFound = TRUE;
			break;
		}
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	return (bFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\kdext\kdlane.c ===
#include <windows.h>
#include <wtypes.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntverp.h>

#include "tracelog.h"
#include "event.h"

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry);

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry);

EXT_API_VERSION        ApiVersion = { 4, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

// ======================================================================

#define MAXREAD 3500

BOOL ReadMemoryEx(ULONG_PTR From, ULONG_PTR To, ULONG Size, PULONG OutBytesRead)
	{
	ULONG BytesRead;
	ULONG TotalBytesRead = 0;
	BOOL success;

//	dprintf("ReadMemoryEx: reading %08x bytes from %08x to %08x\n", Size, From, To);

	while (Size)
		{
		if (CheckControlC())
			return 0;
		if (Size > MAXREAD)
			{
//			dprintf("(reading %08x bytes from %08x to %08x)\n",	MAXREAD, From, To);
			success = ReadMemory((ULONG_PTR)From, (PVOID)To, MAXREAD, &BytesRead);
			if (!success)
				{
       			dprintf("Problem reading memory at %x for %x bytes\n", From, MAXREAD);
				break;
				}
			TotalBytesRead += BytesRead;
			}
		else
			{
//			dprintf("(reading %08x bytes from %08x to %08x)\n",	Size, From, To);
			success = ReadMemory((ULONG_PTR)From, (PVOID)To, Size, &BytesRead);
			if (!success)
				{
       			dprintf("Problem reading memory at %x for %x bytes\n", From, Size);
				break;
				}
			TotalBytesRead += BytesRead;
			}

		if (Size > MAXREAD)
			{
			Size -= MAXREAD;
			From += MAXREAD;
			To += MAXREAD;
			}
		else
			Size = 0;
		}

	*OutBytesRead = TotalBytesRead;
	return success;
	}

// ======================================================================

ULONG_PTR GetTraceLogAddress(VOID)
	{
	ULONG_PTR TargetTraceLog;
	PUCHAR symbol = "ATMLANE!TraceLog";	
	
	TargetTraceLog = (ULONG_PTR)GetExpression(symbol);	

    if ( !TargetTraceLog ) 
		{
        dprintf("Unable to resolve symbol \"%s\". Try .reload cmd.\n", symbol);
        return 0;
	    }
	return TargetTraceLog;
	}

// ======================================================================

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

// ======================================================================

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

// ======================================================================

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

// ======================================================================

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

// ======================================================================

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

// ======================================================================

DECLARE_API(dumplog)
	{
	ULONG_PTR		 	TargetTraceLogAddress;
	TRACELOG			TargetTraceLog;
	TRACELOG 			LocalTraceLog;
	PUCHAR 				LocalLogStorage;
	PTRACEENTRY 		TraceEntry;
	PUCHAR 				CurString, NullPos;
	UCHAR 				SaveChar;
	ULONG 				LogLength;
    ULONG 				bytesread, firstsize;
	char *				indexstr, *filenamestr;
	ULONG 				index;
	FILE *				outfile;

	filenamestr = strtok((char *)args, " ");	

	if (filenamestr == NULL)
		{
        dprintf("usage: dumplog <filename>\n");
		return;
		}

	TargetTraceLogAddress = GetTraceLogAddress();
	if (!TargetTraceLogAddress)
		return;

    // read trace log struct out of target's memory

    if (!ReadMemoryEx( (ULONG_PTR)TargetTraceLogAddress, (ULONG_PTR)&TargetTraceLog, 
			sizeof(TRACELOG), &bytesread))
        return;

#if 1
	// display trace log vars
	dprintf("TraceLog\n");
	dprintf("\tStorage = 0x%08x\n", TargetTraceLog.Storage);
	dprintf("\tSize    = 0x%08x\n", TargetTraceLog.StorageSizeBytes);
	dprintf("\tFirst   = 0x%08x\n", TargetTraceLog.First);
	dprintf("\tLast    = 0x%08x\n", TargetTraceLog.Last);	
	dprintf("\tCurrent = 0x%08x\n", TargetTraceLog.Current);
#endif

    // see if logging enabled (i.e. log has storage allocated
	
	if (TargetTraceLog.Storage == NULL)
		{
		dprintf("Trace Log is disabled\n");
		return;
		}

	// alloc local memory for log
	
	LocalLogStorage = (PUCHAR) malloc(TargetTraceLog.StorageSizeBytes);
	if (LocalLogStorage == NULL)
		{
		dprintf("can't alloc %d bytes for local storage\n",
			TargetTraceLog.StorageSizeBytes); 
		return;
		}

	// open the output file

	outfile = fopen(filenamestr, "wt");
	if (outfile == NULL)
		{
		dprintf("open of file '%s' failed, errno = %d\n", filenamestr, errno);
		free(LocalLogStorage);
		return;
		}

	// read the log out of target's memory
	
	dprintf("reading log from target system, please wait...\n");

	if (!ReadMemoryEx((ULONG_PTR)TargetTraceLog.Storage, (ULONG_PTR)LocalLogStorage,
			TargetTraceLog.StorageSizeBytes, &bytesread))
			{
			fclose(outfile);
			free(LocalLogStorage);
			return;
			}

	// convert addresses to local trace log
	
	LocalTraceLog.Storage = LocalLogStorage;
	LocalTraceLog.First = (PTRACEENTRY) LocalTraceLog.Storage;
	LocalTraceLog.Last = LocalTraceLog.First + 
		(TargetTraceLog.Last - TargetTraceLog.First);
	LocalTraceLog.Current = LocalTraceLog.First + 
		(TargetTraceLog.Current - TargetTraceLog.First);


	// loop thru the trace log printing out the values

	TraceEntry = LocalTraceLog.Current - 1;

	dprintf("writing formatted log to file...\n");

	for (;;)			
		{
		if (TraceEntry < LocalTraceLog.First)
			TraceEntry = LocalTraceLog.Last;
		if (TraceEntry->EventId == 0 || TraceEntry == LocalTraceLog.Current)
			{		
			dprintf("done.\n");
			break;
			}
		PrintTraceLogEntry(outfile, TraceEntry);	
		TraceEntry--;
		if (CheckControlC()) 
			{		
			dprintf("Aborted before end of log.\n");
			break;
			}
		}


	// cleanup
	
	fclose(outfile);
	free(LocalLogStorage);
	}

// ======================================================================

DECLARE_API( help )
	{
    dprintf("ATMLANE driver kd extensions\n\n");
    dprintf("\tdumplog <filename>  - dumps & formats tracelog buffer to file\n");
	}

// ======================================================================

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry)
	{
	ULONG params, i;

	switch (TraceEntry->EventId)
		{

		case TL_MSENDPKTIN:
			fprintf(outfile, "[% 10u] MSENDPKTIN: PktCnt %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_MSENDPKTBEGIN:
			fprintf(outfile, "[% 10u] MSENDPKTBEGIN: Index %d Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;

		case TL_MSENDPKTEND:
			fprintf(outfile, "[% 10u] MSENDPKTEND: Index %d Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2]
				);
			break;

		case TL_MSENDPKTOUT:
			fprintf(outfile, "[% 10u] MSENDPKTOUT\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_MSENDCOMPL:
			fprintf(outfile, "[% 10u] MSENDCOMPL: Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
		
		case TL_WRAPSEND:
			fprintf(outfile, "[% 10u] WRAPSEND: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_UNWRAPSEND:
			fprintf(outfile, "[% 10u] UNWRAPSEND: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_WRAPRECV:
			fprintf(outfile, "[% 10u] WRAPRECV: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;

		case TL_UNWRAPRECV:
			fprintf(outfile, "[% 10u] UNWRAPRECV: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_COSENDPACKET:
			fprintf(outfile, "[% 10u] COSENDPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_COSENDCMPLTIN:
			fprintf(outfile, "[% 10u] COSENDCMPLTIN: Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
			
		case TL_COSENDCMPLTOUT:
			fprintf(outfile, "[% 10u] COSENDCMPLTOUT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_CORECVPACKET:
			fprintf(outfile, "[% 10u] CORECVPKT: Pkt %x Vc %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
			
		case TL_CORETNPACKET:
			fprintf(outfile, "[% 10u] CORETNPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;
			
		case TL_MINDPACKET:
			fprintf(outfile, "[% 10u] MINDPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;
			
		case TL_MRETNPACKET:
			fprintf(outfile, "[% 10u] MRETNPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_NDISPACKET:
			fprintf(outfile, "[% 10u] NDISPKT: %x Cnt %d Len %d Bufs %x %x %x %x %x\n",
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3],
				TraceEntry->Params[4],
				TraceEntry->Params[5],
				TraceEntry->Params[6],
				TraceEntry->Params[7]
				);
			break;
				
		default:
			params = TL_GET_PARAM_COUNT(TraceEntry->EventId);
			fprintf(outfile, "****: Unknown Event ID %d with %d Params: ",
				TL_GET_EVENT(TraceEntry->EventId), params);
			for (i = 0; i <	params; i++)
				fprintf(outfile, "%x ", TraceEntry->Params[i]);
			fprintf(outfile, "\n");
			break;
		}
	}


// ======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\inc\rwanuser.h ===
/*++ BUILD Version: 0001

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    rwanuser.h

Abstract:

    This header file defines constants and types for accessing the NT
    RAW WAN driver. Based on ntddtcp.h

Author:

    ArvindM					October 13, 1997

Revision History:

--*/

#ifndef _RWANUSER__H
#define _RWANUSER__H


#define FSCTL_RAWWAN_BASE     FILE_DEVICE_NETWORK

#define _RAWWAN_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_RAWWAN_BASE, function, method, access)

#define IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY	\
			_RAWWAN_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_SET  \
            _RAWWAN_CTL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_SET	\
            _RAWWAN_CTL_CODE(3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET	\
            _RAWWAN_CTL_CODE(5, METHOD_BUFFERED, FILE_ANY_ACCESS)



#define IOCTL_RWAN_GENERIC_GLOBAL_QUERY	\
			_RAWWAN_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_GLOBAL_SET  \
            _RAWWAN_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_CONN_HANDLE_SET	\
            _RAWWAN_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_ADDR_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET	\
            _RAWWAN_CTL_CODE(15, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef UINT	RWAN_OBJECT_ID;

//
//  Query Information structure. This is passed in as the InputBuffer in
//  the DeviceIoControl. The return information is to be filled into the
//  OutputBuffer.
//
typedef struct _RWAN_QUERY_INFORMATION_EX
{
	RWAN_OBJECT_ID			ObjectId;
	INT						ContextLength;
	UCHAR					Context[1];
} RWAN_QUERY_INFORMATION_EX, *PRWAN_QUERY_INFORMATION_EX;


//
//  Set Information structure. This is passed in as the InputBuffer to
//  the DeviceIoControl. There is no OutputBuffer.
//
typedef struct _RWAN_SET_INFORMATION_EX
{
	RWAN_OBJECT_ID			ObjectId;
	INT						BufferSize;
	UCHAR					Buffer[1];
} RWAN_SET_INFORMATION_EX, *PRWAN_SET_INFORMATION_EX;


//
//  Raw WAN Object IDs
//
#define RWAN_OID_ADDRESS_OBJECT_FLAGS		((RWAN_OBJECT_ID)1)
#define RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE	((RWAN_OBJECT_ID)2)



//
//  Bit definitions for Address Object Flags
//
#define RWAN_AOFLAG_C_ROOT					((ULONG)0x00000001)
#define RWAN_AOFLAG_C_LEAF					((ULONG)0x00000002)
#define RWAN_AOFLAG_D_ROOT					((ULONG)0x00000004)
#define RWAN_AOFLAG_D_LEAF					((ULONG)0x00000008)


#endif // _RWANUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\exe\atmlane.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.c

Abstract:

	ATM LAN Emulation Client Admin Utility.

	Usage:

		atmlane 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	v-lcleet	02-03-98	Created

Notes:

	Modelled after atmadm utility from the UNI 3.1 Call Manager

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winerror.h>
#include <winsock.h>

#ifndef NDIS_STATUS
#define NDIS_STATUS		ULONG
#endif

#include "laneinfo.h"
#include "atmmsg.h"


//
//	Private types
//
typedef struct {
	DWORD				Message;
	LPSTR				String;
} MESSAGE_STRING, *PMESSAGE_STRING;

#define MSG_NO_MESSAGE			0

#define MAX_ATMLANE_ADAPTERS	64
#define MAX_ATMLANE_ELANS		64
#define MAX_ATMLANE_NAME_LEN	256
#define MAX_ATMLANE_ARP_ENTRIES	4096
#define MAX_ATMLANE_CONNECTIONS	4096

//
//	Globals
//
CHAR							DefaultDeviceName[] = "\\\\.\\AtmLane";
CHAR							*pDeviceName = DefaultDeviceName;

//
//  Data structures to store list of adapters:
//
#define ADAPTER_LIST_BUFFER_SIZE	(sizeof(ATMLANE_ADAPTER_LIST) + \
									(MAX_ATMLANE_ADAPTERS * \
			 (sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR)))))

UCHAR							AdapterListBuffer[ADAPTER_LIST_BUFFER_SIZE];
PATMLANE_ADAPTER_LIST			pAdapterList = (PATMLANE_ADAPTER_LIST)AdapterListBuffer;


//
//	Data structures to store list of ELANS on an adapter:
//
#define ELAN_LIST_BUFFER_SIZE		(sizeof(ATMLANE_ELAN_LIST) + \
									(MAX_ATMLANE_ELANS * \
			(sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR)))))

UCHAR							ElanListBuffer[ELAN_LIST_BUFFER_SIZE];
PATMLANE_ELAN_LIST				pElanList = (PATMLANE_ELAN_LIST)ElanListBuffer;


//
//	Data structure to hold ELAN information
//
#define ELAN_INFO_BUFFER_SIZE		(sizeof(ATMLANE_ELANINFO) + \
			((sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR))) * 2))

UCHAR							ElanInfoBuffer[ELAN_INFO_BUFFER_SIZE];
PATMLANE_ELANINFO				pElanInfo = (PATMLANE_ELANINFO)ElanInfoBuffer;


//
//	Data structure to hold an ELAN's ARP table
//
#define ARP_TABLE_BUFFER_SIZE		(sizeof(ATMLANE_ARPTABLE) + \
			((sizeof(ATMLANE_ARPENTRY) * MAX_ATMLANE_ARP_ENTRIES)))

UCHAR							ArpTableBuffer[ARP_TABLE_BUFFER_SIZE];
PATMLANE_ARPTABLE				pArpTable = (PATMLANE_ARPTABLE)ArpTableBuffer;


//
//	Data structure to hold an ELAN's connection table
//
#define CONN_TABLE_BUFFER_SIZE		(sizeof(ATMLANE_CONNECTTABLE) + \
			((sizeof(ATMLANE_CONNECTENTRY) * MAX_ATMLANE_CONNECTIONS)))

UCHAR							ConnTableBuffer[CONN_TABLE_BUFFER_SIZE];
PATMLANE_CONNECTTABLE			pConnTable = (PATMLANE_CONNECTTABLE)ConnTableBuffer;


//
//	Internationalizable message strings loaded by this module.  If we fail
//	to load, default to English language strings.
//
MESSAGE_STRING ElanState[] = {
	MSG_ELAN_STATE_UNKNOWN,					TEXT(" ? "),
	MSG_ELAN_STATE_INIT,					TEXT("INITIAL"),
	MSG_ELAN_STATE_LECS_CONNECT_ILMI,		TEXT("LECS CONNECT ILMI"),
	MSG_ELAN_STATE_LECS_CONNECT_WKA,		TEXT("LECS CONNECT WKA"),
	MSG_ELAN_STATE_LECS_CONNECT_PVC,		TEXT("LECS CONNECT PVC"),
	MSG_ELAN_STATE_LECS_CONNECT_CFG,		TEXT("LECS CONNECT CFG"),
	MSG_ELAN_STATE_CONFIGURE,				TEXT("CONFIGURE"),
	MSG_ELAN_STATE_LES_CONNECT,				TEXT("LES CONNECT"),
	MSG_ELAN_STATE_JOIN,					TEXT("JOIN"),
	MSG_ELAN_STATE_BUS_CONNECT,				TEXT("BUS CONNECT"),
	MSG_ELAN_STATE_OPERATIONAL,				TEXT("OPERATIONAL"),
	MSG_ELAN_STATE_SHUTDOWN,				TEXT("SHUTDOWN")
};

#define NUMBER_OF_ELAN_STATES	(sizeof(ElanState)/sizeof(ElanState[0]))

MESSAGE_STRING LanType[] = {
	MSG_LANTYPE_UNKNOWN,					TEXT(" ? "),
	MSG_LANTYPE_UNSPECIFIED,				TEXT("Unspecified"),
	MSG_LANTYPE_ETHERNET,					TEXT("Ethernet/802.3"),
	MSG_LANTYPE_TOKENRING,					TEXT("Token Ring/802.5")
};

#define NUMBER_OF_LAN_TYPES	(sizeof(LanType)/sizeof(LanType[0]))

MESSAGE_STRING VcType[] = {
	MSG_VCTYPE_UNKNOWN,						TEXT(" ? "),
	MSG_VCTYPE_DATA_DIRECT,					TEXT("DataDirect"),
	MSG_VCTYPE_CONFIG_DIRECT,				TEXT("ConfigDirect"),
	MSG_VCTYPE_CONTROL_DIRECT,				TEXT("CtrlDirect"),
	MSG_VCTYPE_CONTROL_DISTRIBUTE,			TEXT("+ CtrlDistr"),
	MSG_VCTYPE_MULTI_SEND,					TEXT("McastSend"),
	MSG_VCTYPE_MULTI_FORWARD,				TEXT("+ McastFwd")
};

#define NUMBER_OF_VC_TYPES	(sizeof(VcType)/sizeof(VcType[0]))

MESSAGE_STRING McastSendVcType[] = {
	MSG_MCAST_VCTYPE_UNKNOWN,				TEXT(" ? "),
	MSG_MCAST_VCTYPE_BESTEFFORT,			TEXT("Best Effort"),
	MSG_MCAST_VCTYPE_VARIABLE,				TEXT("Variable"),
	MSG_MCAST_VCTYPE_VARIABLE,				TEXT("Constant"),
};

#define NUMBER_OF_MCAST_VC_TYPES	(sizeof(McastSendVcType)/sizeof(McastSendVcType[0]))

MESSAGE_STRING Misc[] = {
	MSG_NONE,								TEXT("None"),
	MSG_OFF,								TEXT("Off"),
	MSG_ON,									TEXT("On"),
	MSG_UNSPECIFIED,						TEXT("Unspecified"),
	MSG_NOCONNECT,							TEXT("<no connection>")
};

#define NUMBER_OF_MISC 	(sizeof(Misc)/sizeof(Misc[0]))

MESSAGE_STRING ConnType[] = {
	MSG_CONNTYPE_PEER,						TEXT("PEER"),
	MSG_CONNTYPE_LECS,						TEXT("LECS"),
	MSG_CONNTYPE_LES,						TEXT("LES "),
	MSG_CONNTYPE_BUS,						TEXT("BUS ")
};

#define NUMBER_OF_CONN_TYPES 	(sizeof(ConnType)/sizeof(ConnType[0]))

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
)
{
    LPTSTR string;
    DWORD count;

    //
    // for all messages in a MESSAGE_STRING table, load the string from this
    // module, replacing the default string in the table (only there in case
    // we get an error while loading the string, so we at least have English
    // to fall back on)
    //

    while (MessageCount--) {
        if (Table->Message != MSG_NO_MESSAGE) {

            //
            // we really want LoadString here, but LoadString doesn't indicate
            // how big the string is, so it doesn't give us an opportunity to
            // allocate exactly the right buffer size. FormatMessage does the
            // right thing
            //

            count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL, // use default hModule
                                  Table->Message,
                                  0,    // use default language
                                  (LPTSTR)&string,
                                  0,    // minimum size to allocate
                                  NULL  // no arguments for inclusion in strings
                                  );
            if (count) {

                //
                // Format message returned the string: replace the English
                // language default
                //

                Table->String = string;
            } else {

                //
                // this is ok if there is no string (e.g. just %0) in the .mc
                // file
                //

                Table->String = TEXT("");
            }
        }
        ++Table;
    }
}


//
//  LoadMessages - courtesy IPCONFIG
//
//  Loads all internationalizable messages into the various tables
//
VOID
LoadMessages(
)
{
	LoadMessageTable(ElanState, 		NUMBER_OF_ELAN_STATES);
	LoadMessageTable(LanType, 			NUMBER_OF_LAN_TYPES);
	LoadMessageTable(VcType, 			NUMBER_OF_VC_TYPES);
	LoadMessageTable(McastSendVcType, 	NUMBER_OF_MCAST_VC_TYPES);
	LoadMessageTable(Misc,				NUMBER_OF_MISC);
	LoadMessageTable(ConnType,			NUMBER_OF_CONN_TYPES);
}

VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
)
{
	va_list		pArg;
	CHAR		MessageBuffer[2048];
	INT			Count;

	va_start(pArg, MessageId);

	Count = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE,
				NULL,				// default hModule
				MessageId,
				0,					// default language
				MessageBuffer,
				sizeof(MessageBuffer),
				&pArg
				);

	va_end(pArg);

	if (Tabbed)
	{
		putchar('\t');
	}

	printf(MessageBuffer);
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}


VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
	CloseHandle(DeviceHandle);
}

BOOLEAN
CheckVersion(
	HANDLE		DeviceHandle
)
{
	ULONG						Version;
	ULONG						BytesReturned;

	if (!DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_INFO_VERSION,
				(PVOID)&Version,
				sizeof(Version),
				(PVOID)&Version,
				sizeof(Version),
				&BytesReturned,
				0))
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_VERSION_INFO);
		return FALSE;
	}	

	if (Version != ATMLANE_INFO_VERSION)
	{
		DisplayMessage(FALSE, MSG_ERROR_INVALID_INFO_VERSION);
		return FALSE;
	}

	return TRUE;
}

BOOLEAN
GetAdapterList(
	HANDLE		DeviceHandle
)
{
	ULONG		BytesReturned;
	BOOLEAN		Result = FALSE;

	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_ENUM_ADAPTERS,
				(PVOID)pAdapterList,
				ADAPTER_LIST_BUFFER_SIZE,
				(PVOID)pAdapterList,
				ADAPTER_LIST_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ADAPTER_LIST);
	}

	return Result;
}


BOOLEAN
GetElanList(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;

	//
	// Copy adapter name in to buffer as input
	//
	memcpy(pElanList, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_ENUM_ELANS,
				(PVOID)pElanList,
				sizeof(UNICODE_STRING)+pAdapterName->Length,
				(PVOID)pElanList,
				ELAN_LIST_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_LIST);
	}

	return Result;
}



BOOLEAN
GetElanInfo(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;

	//
	//	copy adapter name into buffer as input
	//
	memcpy(ElanInfoBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ElanInfoBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_INFO,
				(PVOID)pElanInfo,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pElanInfo,
				ELAN_INFO_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_INFO);
	}

	return Result;
}

BOOLEAN
GetElanArpTable(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;
	
	//
	//	copy adapter name into buffer as input
	//
	memcpy(ArpTableBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ArpTableBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_ARP_TABLE,
				(PVOID)pArpTable,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pArpTable,
				ARP_TABLE_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_ARP_TABLE);
	}

	return Result;
}

BOOLEAN
GetElanConnTable(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;
	
	//
	//	copy adapter name into buffer as input
	//
	memcpy(ConnTableBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ConnTableBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_CONNECT_TABLE,
				(PVOID)pConnTable,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pConnTable,
				CONN_TABLE_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_CONN_TABLE);
	}

	return Result;
}


LPSTR
ElanStateToString(ULONG In)
{
	switch(In)
	{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			return (ElanState[In].String);
		default:
			return (ElanState[0].String);
	}
}


LPSTR
ElanLanTypeToString(ULONG In)
{
	switch(In)
	{
		case 0:
			return LanType[1].String;
		case 1:
			return LanType[2].String;
		case 2:
			return LanType[3].String;
		default:
			return LanType[0].String;
	}
}

LPSTR
ElanMaxFrameSizeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return Misc[3].String;
		case 1:
			return "1516";
		case 2:
			return "4544";
		case 3:
			return "9234";
		case 4:
			return "18190";
		default:
			return " ? ";
	}
}

LPSTR
McastVcTypeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return McastSendVcType[1].String;
		case 1:
			return McastSendVcType[2].String;
		case 2:
			return McastSendVcType[3].String;
		default:
			return McastSendVcType[0].String;
	}
}

PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        *s++ = '.';
        }
    *(--s) = '\0';
    return String; 
    }


PUCHAR
AtmAddrToString(PVOID In)
    {
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
    }


VOID
DisplayElanInfo(
	VOID
)
{
	DisplayMessage(FALSE, MSG_ELAN_NUMBER, 	pElanInfo->ElanNumber);
	DisplayMessage(FALSE, MSG_ELAN_STATE,  	ElanStateToString(pElanInfo->ElanState));
	DisplayMessage(FALSE, MSG_C1,  			AtmAddrToString(&pElanInfo->AtmAddress));
	DisplayMessage(FALSE, MSG_C2,  			ElanLanTypeToString(pElanInfo->LanType));
	DisplayMessage(FALSE, MSG_C3,  			ElanMaxFrameSizeToString(pElanInfo->MaxFrameSizeCode));
	DisplayMessage(FALSE, MSG_C4,  			Misc[1].String); // always off
	if (pElanInfo->ElanName[0] == '\0')
	{
		DisplayMessage(FALSE, MSG_C5,  		Misc[3].String); // unspecified
	}
	else
	{
		DisplayMessage(FALSE, MSG_C5,  		pElanInfo->ElanName);
	}
	DisplayMessage(FALSE, MSG_C6,  			MacAddrToString(&pElanInfo->MacAddress));
	DisplayMessage(FALSE, MSG_C7,  			pElanInfo->ControlTimeout);
	DisplayMessage(FALSE, MSG_C8,  			Misc[0].String);
	DisplayMessage(FALSE, MSG_LECS_ADDR,  	AtmAddrToString(&pElanInfo->LecsAddress));
	DisplayMessage(FALSE, MSG_C9,  			AtmAddrToString(&pElanInfo->LesAddress));
	DisplayMessage(FALSE, MSG_BUS_ADDR,  	AtmAddrToString(&pElanInfo->BusAddress));
	DisplayMessage(FALSE, MSG_C10,  		pElanInfo->MaxUnkFrameCount);
	DisplayMessage(FALSE, MSG_C11,  		pElanInfo->MaxUnkFrameTime);
	DisplayMessage(FALSE, MSG_C12,  		pElanInfo->VccTimeout);
	DisplayMessage(FALSE, MSG_C13,  		pElanInfo->MaxRetryCount);
	DisplayMessage(FALSE, MSG_C14,  		pElanInfo->LecId);
	DisplayMessage(FALSE, MSG_C15);
	DisplayMessage(FALSE, MSG_C16);
	DisplayMessage(FALSE, MSG_C17,  		pElanInfo->AgingTime);
	DisplayMessage(FALSE, MSG_C18,  		pElanInfo->ForwardDelayTime);
	DisplayMessage(FALSE, MSG_C19,  		pElanInfo->TopologyChange==0?Misc[1].String:Misc[2].String);
	DisplayMessage(FALSE, MSG_C20,  		pElanInfo->ArpResponseTime);
	DisplayMessage(FALSE, MSG_C21,  		pElanInfo->FlushTimeout);
	DisplayMessage(FALSE, MSG_C22,  		pElanInfo->PathSwitchingDelay);
	DisplayMessage(FALSE, MSG_C23,  		pElanInfo->LocalSegmentId);
	DisplayMessage(FALSE, MSG_C24,  		McastVcTypeToString(pElanInfo->McastSendVcType));
	DisplayMessage(FALSE, MSG_C25,  		pElanInfo->McastSendVcAvgRate);
	DisplayMessage(FALSE, MSG_C26,  		pElanInfo->McastSendVcPeakRate);
	DisplayMessage(FALSE, MSG_C27,  		Misc[0].String);
	DisplayMessage(FALSE, MSG_C28,  		pElanInfo->ConnComplTimer);
}


VOID
DisplayElanArpTable(
	VOID
)
{
	PATMLANE_ARPENTRY	pArpEntry;
	ULONG 				i;
	
	DisplayMessage(FALSE, MSG_C16_LE_ARP_CACHE);

	pArpEntry = (PATMLANE_ARPENTRY) (ArpTableBuffer + sizeof(ATMLANE_ARPTABLE));
	for (i = 0; i < pArpTable->ArpEntriesReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ARP_ENTRY,
			MacAddrToString(pArpEntry->MacAddress),
			AtmAddrToString(pArpEntry->AtmAddress));
		pArpEntry++;
	}

}



VOID
DisplayElanConnTable(
	VOID
)
{
	PATMLANE_CONNECTENTRY	pConnEntry;
	ULONG 					i;

	DisplayMessage(FALSE, MSG_CONN_CACHE);
	
	pConnEntry = (PATMLANE_CONNECTENTRY) (ConnTableBuffer + sizeof(ATMLANE_CONNECTTABLE));
	for (i = 0; i < pConnTable->ConnectEntriesReturned; i++)
	{
		switch (pConnEntry->Type)
		{

			default:
			case 0: // peer
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[0].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[1].String:Misc[4].String,
					TEXT(""));
				break;
					
			case 1: // lecs
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[1].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[2].String:Misc[4].String,
					TEXT(""));
				break;

			case 2: // les
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[2].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[3].String:Misc[4].String,
					pConnEntry->VcIncoming?VcType[4].String:TEXT(""));
				break;

			case 3: // bus
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[3].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[5].String:Misc[4].String,
					pConnEntry->VcIncoming?VcType[6].String:TEXT(""));
				break;
		}
		
		pConnEntry++;
	}
}

	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{
	HANDLE	DeviceHandle;
	PUNICODE_STRING				pAdapterName;
	PUNICODE_STRING				pElanName;
	ULONG						i, j;
	BOOLEAN						Result;
	
	DisplayMessage(FALSE, MSG_ATMLANE_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_DEVICE);
		return;
	}

	//
	//	First check the version
	//
	if (!CheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	First get the list of available adapters
	//
	if (!GetAdapterList(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	Loop thru the adapters getting each adapter's elan list
	//
	pAdapterName = &pAdapterList->AdapterList;
	for (i = 0; i < pAdapterList->AdapterCountReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ADAPTER, 
			(PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)));

		if (GetElanList(DeviceHandle, pAdapterName))
		{

			//
			//	Loop thru the elan list getting ELAN info
			//
			pElanName = &pElanList->ElanList;
			for (j = 0; j < pElanList->ElanCountReturned; j++)
			{
				DisplayMessage(FALSE, MSG_ELAN, 
					(PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING)));

				if (GetElanInfo(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanInfo();
				}

				if (GetElanArpTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanArpTable();
				}

				if (GetElanConnTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanConnTable();
				}

				//
				//	next elan
				//
				pElanName = (PUNICODE_STRING)((PUCHAR)pElanName +
						sizeof(UNICODE_STRING) + pElanName->Length);
			}

		}

		//
		//	next adapter
		//
		pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName +
				sizeof(UNICODE_STRING) + pAdapterName->Length);
	}

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\debug.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	debug.c

Abstract:

	This file contains debugging support.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:


--*/

#include "precomp.h"

#include <stdarg.h>
#include <stdio.h>

#pragma hdrstop


#if DBG

ULONG			DbgVerbosity = 0;
#if DBG_TRACE
ULONG			DbgLogSize = 128*1024;
TRACELOG		TraceLog;
PUCHAR			pTraceLogSpace;
#endif
#include "oidstrng.h"
#include "irpstrng.h"

#define MAX_HD_LENGTH		128

VOID
DbgOut(ULONG Level, PUCHAR Message, ...)
	{
    char buf[DBG_OUTBUF_SIZE];
	va_list ap;
	LONG numchars;
	
	if (Level > DbgVerbosity)
    	return;

    va_start(ap, Message);
	
	numchars = _vsnprintf(buf, DBG_OUTBUF_SIZE, Message, ap);

	buf[DBG_OUTBUF_SIZE-1] = '\0';

	DbgPrint("ATMLANE: %s", buf);
}

//
//	Careful! Uses static storage for string
//
PUCHAR
UnicodeToString(PUNICODE_STRING unicodeString)
{
	static CHAR 	ansiStringBuffer[129];
	ANSI_STRING		ansiString;

	ansiString.Length = 0;
	ansiString.MaximumLength = 128;
	ansiString.Buffer = ansiStringBuffer;

	if (unicodeString->Length > 0)
	{
		NdisUnicodeStringToAnsiString(
   			&ansiString,
    		unicodeString);
    }

	ansiStringBuffer[ansiString.Length] = '\0';

	return ansiStringBuffer;
}


//
// Careful! Uses static storage for string.
//
PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        }
    *s = '\0';
    return String; 
    }

//
// Careful! Uses static storage for string.
//
PUCHAR
AtmAddrToString(PVOID In)
    {
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
    }

PUCHAR
OidToString(ULONG Oid)
	{
    struct _string_table *oidtab;
	
    
	for (oidtab = &oid_string_table[0]; oidtab->value != 0; oidtab++)
	    if (oidtab->value == Oid)
        	return oidtab->string;

	return oid_string_table[(sizeof(oid_string_table) / 
    	sizeof(struct _string_table)) - 1].string;
    }
    
PUCHAR
IrpToString(ULONG Irp)
	{
    struct _string_table *irptab;
	
    
	for (irptab = &irp_string_table[0]; irptab->value != 0xffffffff; irptab++)
	    if (irptab->value == Irp)
        	return irptab->string;

	return irp_string_table[(sizeof(irp_string_table) / 
    	sizeof(struct _string_table)) - 1].string;
    }

VOID
DbgPrintHexDump(
	IN	ULONG			Level,
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Level > DbgVerbosity)
    	return;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}

VOID
TraceLogWritePkt(
	IN	PTRACELOG		pTraceLog,
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PNDIS_BUFFER	pBuffer[5] = {(PNDIS_BUFFER)NULL};

	do
	{
		pBuffer[0] = pNdisPacket->Private.Head;
		if (pBuffer[0] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[1] = pBuffer[0]->Next;
		if (pBuffer[1] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[2] = pBuffer[1]->Next;
		if (pBuffer[2] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[3] = pBuffer[2]->Next;
		if (pBuffer[3] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[4] = pBuffer[3]->Next;
	}
	while (FALSE);


	TraceLogWrite(
		pTraceLog, 
		TL_NDISPACKET,
		pNdisPacket,
		pNdisPacket->Private.PhysicalCount,
		pNdisPacket->Private.TotalLength,
		pBuffer[0],
		pBuffer[1],
		pBuffer[2],
		pBuffer[3],
		pBuffer[4]
		);
}		

#endif

#if DEBUG_SPIN_LOCK

ULONG				SpinLockInitDone = 0;
NDIS_SPIN_LOCK		LockLock;

VOID
AtmLaneAllocateSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((2, "ALLOCATE LOCK %x %s\n", pLock, String));
	
	if (SpinLockInitDone == 0)
	{

		SpinLockInitDone = 1;
		NdisAllocateSpinLock(&(LockLock));
	}

	NdisAcquireSpinLock(&(LockLock));
	pLock->Signature = ATMLANE_LOCK_SIG;
	NdisMoveMemory(pLock->TouchedByFileName, FileName, 32);
	pLock->TouchedByFileName[31] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(LockLock));
}

VOID
AtmLaneFreeSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((2, "FREE LOCK %x %s\n", pLock, String));

	NdisFreeSpinLock(pLock);
}

VOID
AtmLaneAcquireSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	DBGP((4, "ACQUIRE LOCK %x %s\n", pLock, String));

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(LockLock));
	if (pLock->Signature != ATMLANE_LOCK_SIG)
	{
		DbgPrint("Trying to acquire uninited lock %x, File %s, Line %d\n",
				pLock, FileName, LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock %x, File %s, Line %d\n",
				pLock, FileName, LineNumber);
			DbgPrint("pLock %x already acquired in File %s, Line %d\n",
				pLock, 
				pLock->TouchedByFileName, 
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	//
	//  Mark this lock.
	//
	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(LockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	pLock->OwnerThread = pThread;
	NdisMoveMemory(pLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
	pLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;

}


VOID
AtmLaneReleaseSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((4, "RELEASE LOCK %x %s\n", pLock, String));

	NdisAcquireSpinLock(&(LockLock));
	if (pLock->Signature != ATMLANE_LOCK_SIG)
	{
		DbgPrint("Trying to release uninited lock %x, File %s, Line %d\n",
				pLock,
				FileName,
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock %x, File %s, Line %d\n",
				pLock,
				FileName,
				LineNumber);
		DbgBreakPoint();
	}

	NdisMoveMemory(pLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
	pLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisReleaseSpinLock(&(LockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DEBUG_SPIN_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\callmgr.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	callmgr.c

Abstract:

	Call Manager interface routines.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/


#include <precomp.h>
#pragma	hdrstop

//
//  Rounded-off size of generic Q.2931 IE header
//

#define SIZEOF_Q2931_IE	 			ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define ATMLANE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )

//
// Size of Call Manager Parameters Block
//
#define ATMLANE_Q2931_CALLMGR_PARAMETERS_SIZE	 	\
	sizeof(Q2931_CALLMGR_PARAMETERS) - 1 +			\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(AAL_PARAMETERS_IE) +						\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_TRAFFIC_DESCRIPTOR_IE) +				\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE) +	\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_BLLI_IE) +							\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_QOS_CLASS_IE)					

//
//	ATMLANE Call Manager Parameters Block
//
typedef struct _ATMLANE_Q2931_CALLMGR_PARAMETERS
{
	UCHAR Q2931CallMgrParameters[ATMLANE_Q2931_CALLMGR_PARAMETERS_SIZE];
}
	ATMLANE_Q2931_CALLMGR_PARAMETERS,
	*PATMLANE_Q2931_CALLMGR_PARAMETERS;




VOID
AtmLaneAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
)
/*++

Routine Description:

	This routine is called by NDIS when a Call manager registers its support
	for an Address Family over an adapter. If this is the Address Family we
	are interested in (UNI 3.1), then we bootstrap the Elans for this adapter.

Arguments:

	ProtocolBindingContext	- our context passed in NdisOpenAdapter, which is
							  a pointer to our Adapter structure.
	pAddressFamily			- points to a structure describing the Address Family
							  being registered by a Call Manager.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(AfRegisterNotifyHandler);
	
	do
	{
		DBGP((1, "AfRegisterNotifyHandler: AF %x MajVer %x MinVer %x\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
	
		//
		//  Only interested in UNI Version 3.1
		//
		if ((pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931) ||
			(pAddressFamily->MajorVersion != 3) ||
			(pAddressFamily->MinorVersion != 1))
		{
			DBGP((2, "AfRegisterNotifyHandler: ignoring AF %x MajVer %x MinVer %x\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
			break;
		}

		pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
		STRUCT_ASSERT(pAdapter, atmlane_adapter);

		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags |= ADAPTER_FLAGS_AF_NOTIFIED;

		while (pAdapter->Flags & ADAPTER_FLAGS_OPEN_IN_PROGRESS)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
			DBGP((0, "AfRegisterNotifyHandler: Adapter %p/%x still opening\n",
					pAdapter, pAdapter->Flags));
			(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->OpenBlock);
			ACQUIRE_ADAPTER_LOCK(pAdapter);
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

        //
        //  Bootstrap the ELANs configured on this adapter
        //
        AtmLaneBootStrapElans(pAdapter);


	} while (FALSE);

	TRACEOUT(AfFRegisterNotifyHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


NDIS_STATUS
AtmLaneOpenCallMgr(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Start access to the Call Manager on an Elan,
	by doing the following:
		- Open Address Family

	For all of these, we wait for completion in case they pend.

	It is assumed that the Elan structure is locked.

Arguments:

	pElan	- pointer to the ATMLANE Elan

Return Value:

	NDIS status.

--*/
{
	PCO_ADDRESS_FAMILY			pAddressFamily;
	NDIS_STATUS					Status;
	ULONG						RequestSize;
	NDIS_CLIENT_CHARACTERISTICS	AtmLaneClientChars;

	TRACEIN(OpenCallMgr);


	pAddressFamily = (PCO_ADDRESS_FAMILY)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do {

		//
		//  Allocate address family struct.
		//
		ALLOC_MEM(&pAddressFamily, sizeof(CO_ADDRESS_FAMILY));

		if ((PCO_ADDRESS_FAMILY)NULL == pAddressFamily)
		{
			DBGP((0, "OpenCallMgr: Alloc address family struct failed\n"));
			break;
		}

		//
		//  Init the address family struct.
		//
		NdisZeroMemory(pAddressFamily, sizeof(CO_ADDRESS_FAMILY));
		pAddressFamily->AddressFamily = CO_ADDRESS_FAMILY_Q2931;
		pAddressFamily->MajorVersion = 3;
		pAddressFamily->MinorVersion = 1;

		//
		//	Init the call manager client characteristics.
		//
		NdisZeroMemory(&AtmLaneClientChars, sizeof(AtmLaneClientChars));
		AtmLaneClientChars.MajorVersion = 5;
		AtmLaneClientChars.MinorVersion = 0;
		AtmLaneClientChars.ClCreateVcHandler = AtmLaneCreateVcHandler;
		AtmLaneClientChars.ClDeleteVcHandler = AtmLaneDeleteVcHandler;
		AtmLaneClientChars.ClRequestHandler = AtmLaneCoRequestHandler;
		AtmLaneClientChars.ClRequestCompleteHandler = AtmLaneCoRequestCompleteHandler;
		AtmLaneClientChars.ClOpenAfCompleteHandler = AtmLaneOpenAfCompleteHandler;
		AtmLaneClientChars.ClCloseAfCompleteHandler = AtmLaneCloseAfCompleteHandler;
		AtmLaneClientChars.ClRegisterSapCompleteHandler = AtmLaneRegisterSapCompleteHandler;
		AtmLaneClientChars.ClDeregisterSapCompleteHandler = AtmLaneDeregisterSapCompleteHandler;
		AtmLaneClientChars.ClMakeCallCompleteHandler = AtmLaneMakeCallCompleteHandler;
		AtmLaneClientChars.ClModifyCallQoSCompleteHandler = AtmLaneModifyQosCompleteHandler;
		AtmLaneClientChars.ClCloseCallCompleteHandler = AtmLaneCloseCallCompleteHandler;
		AtmLaneClientChars.ClAddPartyCompleteHandler = AtmLaneAddPartyCompleteHandler;
		AtmLaneClientChars.ClDropPartyCompleteHandler = AtmLaneDropPartyCompleteHandler;
		AtmLaneClientChars.ClIncomingCallHandler = AtmLaneIncomingCallHandler;
		AtmLaneClientChars.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
		AtmLaneClientChars.ClIncomingCloseCallHandler = AtmLaneIncomingCloseHandler;
		AtmLaneClientChars.ClIncomingDropPartyHandler = AtmLaneIncomingDropPartyHandler;
		AtmLaneClientChars.ClCallConnectedHandler = AtmLaneCallConnectedHandler;

		//
		//	Open the call manager
		//
		INIT_BLOCK_STRUCT(&pElan->Block);
		Status = NdisClOpenAddressFamily(
					pElan->NdisAdapterHandle,
					pAddressFamily,
					pElan,
					&AtmLaneClientChars,
					sizeof(AtmLaneClientChars),
					&pElan->NdisAfHandle);
		if (NDIS_STATUS_PENDING == Status)
		{
			//
			//  Wait for completion
			//
			Status = WAIT_ON_BLOCK_STRUCT(&pElan->Block);
		}
		if (NDIS_STATUS_SUCCESS != Status)
		{
			DBGP((0, "%d OpenCallMgr: OpenAddressFamily failed, status %x, Elan %x\n",
				pElan->ElanNumber, Status, pElan));
			break;
		}
		break;
	}
	while (FALSE);

	//
	//	clean up.

	if (pAddressFamily != (PCO_ADDRESS_FAMILY)NULL)
	{
		NdisFreeMemory(pAddressFamily,0,0);
	}

	TRACEOUT(OpenCallMgr);
	
	return (Status);
}

VOID
AtmLaneOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClOpenAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	If open is successful, store NdisAfHandle in Adapter.

	We don't need to acquire locks here because the thread that called
	OpenAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our Adapter structure
	NdisAfHandle			- NDIS handle to the AF association

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(OpenAfCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	STRUCT_ASSERT(pElan, atmlane_elan);

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pElan->NdisAfHandle = NdisAfHandle;
	}

	//
	//  Store status, Wake up the blocked thread.
	//
	SIGNAL_BLOCK_STRUCT(&pElan->Block, Status);

	TRACEOUT(OpenAfCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClCloseAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	We don't need to acquire locks here because the thread that called
	CloseAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our Adapter structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN		pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);


	TRACEIN(CloseAfCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	STRUCT_ASSERT(pElan, atmlane_elan);
	DBGP((0, "%d CloseAF complete on Elan %x sts %x\n", pElan->ElanNumber, pElan, Status));

	AtmLaneContinueShutdownElan(pElan);
	
	TRACEOUT(CloseAfCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Register the LANE SAPs for the given Elan.

	We just issue the NdisClRegisterSap requests for all SAPs.
	We don't wait for completion.

Arguments:

	pElan			- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PATMLANE_SAP				pAtmLaneLesSap;
	PATMLANE_SAP				pAtmLaneBusSap;
	PATMLANE_SAP				pAtmLaneDataSap;
	PATM_ADDRESS				pAtmAddress;
	PATM_SAP					pAtmSap;
	NDIS_STATUS					Status;
	ULONG						rc;				// Ref count on Elan
	ATM_BLLI_IE UNALIGNED *		pBlli;
	ATM_BHLI_IE UNALIGNED *		pBhli;
	

	TRACEIN(RegisterSaps);

	if (pElan->AdminState != ELAN_STATE_OPERATIONAL)
	{
		RELEASE_ELAN_LOCK(pElan);
		return;
	}

	//
	//	Initialize SAPs
	// 
	pElan->SapsRegistered = 0;
	pAtmLaneLesSap = &pElan->LesSap;
	pAtmLaneBusSap = &pElan->BusSap;
	pAtmLaneDataSap = &pElan->DataSap;
	
	//
	//	First init the LES control distribute connection SAP
	//
	SET_FLAG(pAtmLaneLesSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneLesSap->LaneType = VC_LANE_TYPE_CONTROL_DISTRIBUTE;
	pAtmLaneLesSap->pElan = pElan;
	pAtmLaneLesSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneLesSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneLesSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneLesSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	pBlli->SnapId[4] = 0x01;		// control distribute
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);

	//
	//	Now init the BUS mulicast forward connection SAP
	//
	SET_FLAG(pAtmLaneBusSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneBusSap->LaneType = VC_LANE_TYPE_MULTI_FORWARD;
	pAtmLaneBusSap->pElan = pElan;
	pAtmLaneBusSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneBusSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneBusSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneBusSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	if (pElan->LanType == LANE_LANTYPE_ETH)
	{
		pBlli->SnapId[4] = 0x04;		// Ethernet/802.3 Multicast Forward
	}
	else
	{
		pBlli->SnapId[4] = 0x05;		// 802.5 Multicast Forward
	}
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);
	
	//
	//	Now init the DATA direct connection SAP
	//
	SET_FLAG(pAtmLaneDataSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneDataSap->LaneType = VC_LANE_TYPE_DATA_DIRECT;
	pAtmLaneDataSap->pElan = pElan;
	pAtmLaneDataSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneDataSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneDataSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneDataSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	if (pElan->LanType == LANE_LANTYPE_ETH)
	{
		pBlli->SnapId[4] = 0x02;		// Ethernet/802.3 Data Direct
	}
	else
	{
		pBlli->SnapId[4] = 0x03;		// 802.5 Data Direct
	}
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);

	//
	//  Make sure that the Elan doesn't go away.
	//
	AtmLaneReferenceElan(pElan, "tempregsaps");

	RELEASE_ELAN_LOCK(pElan);

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the LES Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneLesSap,	// ProtocolSapContext
					pAtmLaneLesSap->pInfo,
					&(pAtmLaneLesSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneLesSap,
					pAtmLaneLesSap->pInfo,
					pAtmLaneLesSap->NdisSapHandle
					);
	}

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the BUS Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneBusSap,	// ProtocolSapContext
					pAtmLaneBusSap->pInfo,
					&(pAtmLaneBusSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneBusSap,
					pAtmLaneBusSap->pInfo,
					pAtmLaneBusSap->NdisSapHandle
					);
	}

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the DATA Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneDataSap,	// ProtocolSapContext
					pAtmLaneDataSap->pInfo,
					&(pAtmLaneDataSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneDataSap,
					pAtmLaneDataSap->pInfo,
					pAtmLaneDataSap->NdisSapHandle
					);
	}

	//
	//  Remove the reference we added earlier to the Elan.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "tempregsaps");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	//
	//  else the Elan is gone!

	TRACEOUT(RegisterSaps);

	return;
}

VOID
AtmLaneDeregisterSaps(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Deregister all SAPs on an ATMLANE Elan. We issue NdisClDeregisterSap
	calls on all SAPs we have currently registered.

Arguments:

	pElan			- Pointer to ATMLANE Elan

Return Value:

	None

--*/
{
	NDIS_HANDLE					NdisSapHandle;
	ULONG						rc;				// Reference count on Interface
	PATMLANE_SAP				pAtmLaneSap;
	NDIS_STATUS					Status;

	TRACEIN(DeregisterSaps);

	ACQUIRE_ELAN_LOCK(pElan);

	//
	//  Make sure the Elan structure doesn't go away.
	//
	AtmLaneReferenceElan(pElan, "tempDeregSap");
	RELEASE_ELAN_LOCK(pElan);

	//
	//  First the LES SAP
	//
	pAtmLaneSap = &(pElan->LesSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}
	
	//
	//  Then the BUS SAP
	//
	pAtmLaneSap = &(pElan->BusSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}

	//
	//  And finally the Data SAP
	//
	pAtmLaneSap = &(pElan->DataSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}

	//
	//  Remove the reference we added earlier to the Interface.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "tempDeregSap");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	//
	//  else the interface is gone
	//

	TRACEOUT(DeregisterSaps);
	return;
}

NDIS_STATUS
AtmLaneMakeCall(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT,
	IN	BOOLEAN						UsePvc
)
/*++

Routine Description:

	Place a call to the given destination. 

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which will be released here. The reason we do it this way is so that
	nobody else can come in and try to make another call (of the same kind)
	to this ATM Entry -- once we get a new VC into the ATM Entry's list,
	we can release its lock.

	SIDE EFFECT: If the NDIS call doesn't pend, then we call our
	MakeCall completion handler from here, and return NDIS_STATUS_PENDING
	to the caller.


Arguments:

	pElan				- the Elan originating this call
	pAtmEntry			- Pointer to ATM Address Entry corresponding to the
						  called address.

Return Value:

	If there is an immediate failure (e.g. allocation failure), we return
	appropriate NDIS_STATUS value denoting that failure.

	If we made it to the call to NdisClMakeCall(), we return NDIS_STATUS_PENDING.
	However, if NDIS returns other than NDIS_STATUS_PENDING, we'd also
	call our MakeCall completion handler.

--*/
{
	PATMLANE_VC										pVc;
	NDIS_STATUS										Status;
	NDIS_HANDLE										NdisVcHandle;
	NDIS_HANDLE										NdisAfHandle;
	NDIS_HANDLE										ProtocolVcContext;	
	PCO_CALL_PARAMETERS								pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS						pCallMgrParameters;
	PQ2931_CALLMGR_PARAMETERS						pAtmCallMgrParameters;
	PCO_MEDIA_PARAMETERS							pMediaParameters;
	PATM_MEDIA_PARAMETERS							pAtmMediaParameters;
	Q2931_IE UNALIGNED *							pIe;
	AAL_PARAMETERS_IE UNALIGNED *					pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc;
	ATM_BLLI_IE UNALIGNED *							pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos;
	
	ULONG											RequestSize;
	BOOLEAN											bIsLockHeld;
	
	TRACEIN(MakeCall);

	STRUCT_ASSERT(pElan, atmlane_elan);
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	bIsLockHeld = TRUE;	// do we hold the ATM Entry lock?
	pVc = NULL_PATMLANE_VC;

	do
	{
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (!UsePvc)
		{
			// 
			// 	Default case is to make an server/peer SVC call.
			//	Compute size of the SVC call parameters.
			//
			RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
						  	sizeof(CO_CALL_MANAGER_PARAMETERS) +
							sizeof(Q2931_CALLMGR_PARAMETERS) +
							ATMLANE_CALL_IE_SPACE;
		}
		else
		{
			//
			//	This is the LECS PVC (vpi 0, vci 17).
			//	Compute size of the PVC call parameters.
			//		
			RequestSize =	sizeof(CO_CALL_PARAMETERS) +
						  	sizeof(CO_CALL_MANAGER_PARAMETERS) +
							sizeof(CO_MEDIA_PARAMETERS) +
							sizeof(ATM_MEDIA_PARAMETERS);
		}

		ALLOC_MEM(&pCallParameters, RequestSize);
		if ((PCO_CALL_PARAMETERS)NULL == pCallParameters)
		{
			DBGP((0, "MakeCall: callparams alloc (%d) failed\n", RequestSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate a VC structure for the call
		//
		pVc = AtmLaneAllocateVc(pElan);

		if (NULL_PATMLANE_VC == pVc)
		{
			DBGP((0, "MakeCall: VC alloc failed\n"));
			FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	For later call to MakeCallComplete
		//
		ProtocolVcContext = pVc;

		//
		//	Get NDIS handle for this VC
		//
		NdisVcHandle = NULL_NDIS_HANDLE;
		NdisAfHandle = pElan->NdisAfHandle;

		if (NULL == NdisAfHandle)
		{
			DBGP((0, "%d MakeCall: ELAN %p: AfHandle is NULL!\n",
					pElan->ElanNumber, pElan));
			FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		Status = NdisCoCreateVc(
						pElan->NdisAdapterHandle,
						NdisAfHandle,
						ProtocolVcContext,
						&NdisVcHandle
						);

		if (NDIS_STATUS_SUCCESS != Status)
		{
			ASSERT(NDIS_STATUS_PENDING != Status);

			DBGP((0, "MakeCall: NdisCoCreateVc failed: %x, pAtmEnt %x, RefCount %d\n",
						Status, pAtmEntry, pAtmEntry->RefCount));
			FREE_MEM(pCallParameters);
			AtmLaneDeallocateVc(pVc);
			break;
		}

		DBGP((3, "MakeCall: pAtmEntry %x pVc %x NdisVcHandle %x\n",
				pAtmEntry,
				pVc,
				NdisVcHandle));

		AtmLaneReferenceVc(pVc, "vc");	// CreateVc reference

		//
		//	Now fill in the rest of the VC structure.  We don't need a lock
		//	for the VC until it gets linked to the ATM Entry structure.
		//
		pVc->NdisVcHandle = NdisVcHandle;
		NdisMoveMemory((PUCHAR)&(pVc->CallingAtmAddress),
					  (PUCHAR)&(pElan->AtmAddress),
					  sizeof(ATM_ADDRESS));
		pVc->Flags = 	VC_TYPE_SVC |
						VC_OWNER_IS_ATMLANE |
						VC_CALL_STATE_OUTGOING_IN_PROGRESS;

		//
		//	Start with with normal timeout, 
		//	AtmLaneLinkVcToAtmEntry will accelerate	if necessary.
		//
		pVc->AgingTime = pElan->VccTimeout;		

		switch (pAtmEntry->Type)
		{
			case ATM_ENTRY_TYPE_PEER:
				DBGP((1, "%d Outgoing call %x to PEER\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_DATA_DIRECT;
				break;
			case ATM_ENTRY_TYPE_LECS:
				DBGP((1, "%d Outgoing call %x to LECS\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_CONFIG_DIRECT;
				break;
			case ATM_ENTRY_TYPE_LES:
				DBGP((1, "%d Outgoing call %x to LES\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_CONTROL_DIRECT;
				break;
			case ATM_ENTRY_TYPE_BUS:
				DBGP((1, "%d Outgoing call %x to BUS\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_MULTI_SEND;
				break;
			default:
				ASSERT(FALSE);
				break;
		}
						
		//
		//	Zero out call parameters.
		//
		NdisZeroMemory(pCallParameters, RequestSize);

		if (!UsePvc)
		{
			//
			//	Distribute space and link up pointers amongst the various
			//	structures for an SVC.
			//
			//	pCallParameters------->+------------------------------------+
			//	                       | CO_CALL_PARAMETERS                 |
			//	pCallMgrParameters---->+------------------------------------+
			//	                       | CO_CALL_MANAGER_PARAMETERS         |
			//	pAtmCallMgrParameters->+------------------------------------+
			//	                       | Q2931_CALLMGR_PARAMETERS           |
			//	                       +------------------------------------+
			//	                       | AAL_PARAMETERS_IE                  |
			//	                       +------------------------------------+
			//	                       | ATM_TRAFFIC_DESCRIPTOR_IE          |
			//	                       +------------------------------------+
			//	                       | ATM_BROADBAND_BEARER_CAPABILITY_IE |
			//	                       +------------------------------------+
			//	                       | ATM_BLLI_IE                        |
			//	                       +------------------------------------+
			//	                       | ATM_QOS_CLASS_IE                   |
			//	                       +------------------------------------+
			
			//
			pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
									((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		    pCallParameters->CallMgrParameters = pCallMgrParameters;
			pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;
			pCallMgrParameters->CallMgrSpecific.ParamType = CALLMGR_SPECIFIC_Q2931;	
			pCallMgrParameters->CallMgrSpecific.Length = 
								sizeof(Q2931_CALLMGR_PARAMETERS) +
								ATMLANE_CALL_IE_SPACE;
			pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

		}
		else
		{
			//
			//	Distribute space and link up pointers amongst the various
			//	structures for the LECS PVC.
			//
			//	pCallParameters------->+----------------------------+
			//	                       | CO_CALL_PARAMETERS         |
			//	pCallMgrParameters---->+----------------------------+
			//	                       | CO_CALL_MANAGER_PARAMETERS |
			//	pMediaParameters------>+----------------------------+
			//	                       | CO_MEDIA_PARAMETERS        |
			//	pAtmMediaParameters--->+----------------------------+
			//	                       | ATM_MEDIA_PARAMETERS       |
			//	                       +----------------------------+
			//
			pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
									((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		    pCallParameters->CallMgrParameters = pCallMgrParameters;
			pCallMgrParameters->CallMgrSpecific.ParamType = 0;	
			pCallMgrParameters->CallMgrSpecific.Length = 0;
			pMediaParameters = (PCO_MEDIA_PARAMETERS)
				pCallMgrParameters->CallMgrSpecific.Parameters;
			pCallParameters->MediaParameters = pMediaParameters;
			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
									pMediaParameters->MediaSpecific.Parameters;
		}

		//
		//	Call Manager generic flow paramters:
		//
		pCallMgrParameters->Transmit.TokenRate = 
				pElan->pAdapter->LinkSpeed.Outbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Transmit.PeakBandwidth = 
				pElan->pAdapter->LinkSpeed.Outbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;

		pCallMgrParameters->Receive.TokenRate = 
				pElan->pAdapter->LinkSpeed.Inbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Receive.PeakBandwidth = 
				pElan->pAdapter->LinkSpeed.Inbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Receive.ServiceType = SERVICETYPE_BESTEFFORT;

		if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type ||
			ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
		{
			//
			//	Is data direct or multicast send VC so use configured size
			//
			pCallMgrParameters->Transmit.TokenBucketSize = 
				pCallMgrParameters->Transmit.MaxSduSize = 
				pCallMgrParameters->Receive.TokenBucketSize = 
				pCallMgrParameters->Receive.MaxSduSize = 
					 pElan->MaxFrameSize;
		}
		else
		{
			//
			//	Is control VC so use 1516 per spec
			//
			pCallMgrParameters->Transmit.TokenBucketSize = 
				pCallMgrParameters->Transmit.MaxSduSize = 
				pCallMgrParameters->Receive.TokenBucketSize = 
				pCallMgrParameters->Receive.MaxSduSize = 
					 1516;
		}


		if (!UsePvc)
		{
			//
			//  SVC Q2931 Call Manager Parameters:
			//

			//
			//  Called address:
			//
			NdisMoveMemory((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
						  (PUCHAR)&(pAtmEntry->AtmAddress),
						  sizeof(ATM_ADDRESS));

			//
			//  Calling address:
			//
			NdisMoveMemory((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
						  (PUCHAR)&(pElan->AtmAddress),
						  sizeof(ATM_ADDRESS));

			//
			//  LANE spec says that the following IEs MUST be present in the
			//  SETUP message, so fill them all.
			//
			//      AAL Parameters
			//      Traffic Descriptor
			//      Broadband Bearer Capability
			//      Broadband Low Layer Info
			//      QoS
			//

			//
			//  Initialize the Info Element list
			//
			pAtmCallMgrParameters->InfoElementCount = 0;
			pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


			//
			//  AAL Parameters:
			//		AAL5
			//		SDU size 
			//			1516 for control
			//			ELAN MaxFrameSize for data
			{
				UNALIGNED AAL5_PARAMETERS	*pAal5;
	
				pIe->IEType = IE_AALParameters;
				pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
				pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
				pAalIe->AALType = AAL_TYPE_AAL5;
				pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);


			if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type ||
				ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
				{
					//
					//	Is data direct or multicast send VC so use configured size
					//
					pAal5->ForwardMaxCPCSSDUSize = 
						pAal5->BackwardMaxCPCSSDUSize = (USHORT)pElan->MaxFrameSize;
				}
				else
				{
					//
					//	Is control VC so use 1516 per spec
					//
					pAal5->ForwardMaxCPCSSDUSize = 
						pAal5->BackwardMaxCPCSSDUSize = 1516;
				}
			}

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


			//
			//  Traffic Descriptor:
			//		Line Rate Best Effort
			//
			pIe->IEType = IE_TrafficDescriptor;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
			pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 = 
					LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			DBGP((2, "MakeCall: fwd PeakCellRateCLP01 %d\n",
				pTrafficDescriptor->ForwardTD.PeakCellRateCLP01));
			pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
					LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Inbound);
			DBGP((2, "MakeCall: bwd PeakCellRateCLP01 %d\n",
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01));
			pTrafficDescriptor->BestEffort = TRUE;

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

			//
			//  Broadband Bearer Capability
			//
			pIe->IEType = IE_BroadbandBearerCapability;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
			pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;
	
			pBbc->BearerClass = BCOB_X;
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
			pBbc->UserPlaneConnectionConfig = UP_P2P;
	
			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	
			//
			//  Broadband Lower Layer Information
			//
			pIe->IEType = IE_BLLI;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
			pBlli = (PATM_BLLI_IE)pIe->IE;
	
			pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
			pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
			pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	
			pBlli->SnapId[0] = 0x00;
			pBlli->SnapId[1] = 0xa0;
			pBlli->SnapId[2] = 0x3e;
			pBlli->SnapId[3] = 0x00;
	
			pBlli->SnapId[4] = 0x01;			// default to Config Direct or 
												// Control Direct
											
			if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type)
			{
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					pBlli->SnapId[4] = 0x02;	// Eth/802.3 Data Direct
				}
				else
				{
					pBlli->SnapId[4] = 0x03;	// 802.5 Data Direct
				}
			}
			if (ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
			{
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					pBlli->SnapId[4] = 0x04;	// Eth/802.3 Multicast Send
				}
				else
				{
					pBlli->SnapId[4] = 0x05;	// 802.5 Multicast Send
				}
			}
	
			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

			//
			//  QoS
			//
			pIe->IEType = IE_QOSClass;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
			pQos = (PATM_QOS_CLASS_IE)pIe->IE;
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}
		else
		{
			//
			//  PVC Generic and ATM-specific Media Parameters
			//
			pMediaParameters->Flags = TRANSMIT_VC | RECEIVE_VC;
			pMediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
			pMediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

			pAtmMediaParameters->ConnectionId.Vpi = 0;
			pAtmMediaParameters->ConnectionId.Vci = 17;
			pAtmMediaParameters->AALType = AAL_TYPE_AAL5;
			pAtmMediaParameters->Transmit.PeakCellRate = 
				LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			pAtmMediaParameters->Transmit.MaxSduSize = 1516;
			pAtmMediaParameters->Transmit.ServiceCategory = 
				ATM_SERVICE_CATEGORY_UBR;
			pAtmMediaParameters->Receive.PeakCellRate = 
				LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			pAtmMediaParameters->Receive.MaxSduSize = 1516;
			pAtmMediaParameters->Receive.ServiceCategory = 
				ATM_SERVICE_CATEGORY_UBR;

			//
			//	Set PVC flag here
			//
			pCallParameters->Flags |= PERMANENT_VC;

		}

		//
		//  We add the Call reference
		//  right here
		//
		AtmLaneReferenceVc(pVc, "call");	// Call reference (MakeCall coming up)

		//
		//  We are ready to make the call. Before we do so, we need to
		//  link the VC structure to the ATM Entry, and release the
		//  ATM Entry lock
		//
		AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, FALSE);
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);	// acquired by caller
		bIsLockHeld = FALSE;

		//
		//  Make the Call now
		//
		Status = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						(NDIS_HANDLE)NULL,	// No Party context
						(PNDIS_HANDLE)NULL	// No Party handle expected
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneMakeCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL,	// No Party handle
						pCallParameters
						);
			Status = NDIS_STATUS_PENDING;
		}
		//
		//  else the MakeCall complete handler will be called
		//  later
		//

	} while (FALSE);

	if (bIsLockHeld)
	{
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	DBGP((3, "MakeCall: pVc %x, returning status %x\n",
						pVc, Status));

	TRACEOUT(MakeCall);
	return Status;
}


VOID
AtmLaneCloseCall(
	IN	PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Closes an existing call on a VC. It is assumed that a call exists
	on the VC, and the VC is not linked with any ATM Entry.

	NOTE: The caller is assumed to hold a lock to the VC structure,
	and it will be released here.

	SIDE EFFECT: If the NDIS call returns other than NDIS_STATUS_PENDING,
	we call our CloseCall Complete handler from here.

Arguments:

	pVc			- Pointer to ATMLANE VC structure.

Return Value:

	None

--*/
{
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				ProtocolVcContext;
	NDIS_STATUS				Status;
	PATMLANE_ELAN			pElan;
	BOOLEAN					WasRunning;	
	ULONG					rc;	

	TRACEIN(CloseCall);
	
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	NdisVcHandle = pVc->NdisVcHandle;
	ProtocolVcContext = (NDIS_HANDLE)pVc;
	pElan = pVc->pElan;

	DBGP((1, "%d Closing call %x\n", pVc->pElan->ElanNumber, pVc));

	rc = pVc->RefCount;

	//
	//  Stop any timers running on this VC.
	//
	WasRunning = AtmLaneStopTimer(&(pVc->ReadyTimer), pElan);
	if (WasRunning)
	{
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
	}
	if (rc > 0)
	{
		WasRunning = AtmLaneStopTimer(&(pVc->AgingTimer), pElan);
		if (WasRunning)
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
		}
	}

	//
	//  Continue only if the VC remains.
	//
	if (rc > 0)
	{
		//
		//  Check the call state on this VC. If the call is active,
		//  close it. Otherwise, simply mark the VC as closing, we'll
		//  continue this process when the current operation on the VC
		//  completes.

		if (IS_FLAG_SET(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE) &&
			(pVc->OutstandingSends == 0))
		{
			//
			//  Set VC call state to "Close Call in progress"
			//
			SET_FLAG(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_CLOSE_IN_PROGRESS);


			RELEASE_VC_LOCK(pVc);

			DBGP((3,
				"Closecall: NdisClCloseCall on NdisVcHandle %x\n",
			 		NdisVcHandle));

			Status = NdisClCloseCall(
						NdisVcHandle,
						(NDIS_HANDLE)NULL,	// No Party Handle
						(PVOID)NULL,		// No Buffer
						(UINT)0				// Size of above
						);

			if (Status != NDIS_STATUS_PENDING)
			{
				AtmLaneCloseCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL
						);
			}
		}
		else
		{
			//
			//  Some operation is going on here (call setup). Mark this
			//  VC so that we know what to do when this operation completes.
			//
			SET_FLAG(
					pVc->Flags,
					VC_CLOSE_STATE_MASK,
					VC_CLOSE_STATE_CLOSING);

			RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone.
	//

	
	TRACEOUT(CloseCall);

	return;
}



NDIS_STATUS
AtmLaneCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
)
/*++

Routine Description:

	Entry point called by NDIS when the Call Manager wants to create
	a new endpoint (VC). We allocate a new ATMLANE VC structure, and
	return a pointer to it as our VC context.

Arguments:

	ProtocolAfContext	- Actually a pointer to the ATMLANE Interface structure
	NdisVcHandle		- Handle for this VC for all future references
	pProtocolVcContext	- Place where we (protocol) return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could create a VC
	NDIS_STATUS_RESOURCES otherwise

--*/
{
	PATMLANE_ELAN		pElan;
	PATMLANE_VC			pVc;
	NDIS_STATUS			Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CreateVcHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	

	pVc = AtmLaneAllocateVc(pElan);
	if (pVc != NULL_PATMLANE_VC)
	{
		*pProtocolVcContext = (NDIS_HANDLE)pVc;
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = VC_OWNER_IS_CALLMGR;
		AtmLaneReferenceVc(pVc, "vc");	// Create VC ref

		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	DBGP((3, "CreateVcHandler: pVc %x, Status %x\n", pVc, Status));

	TRACEOUT(CreateVcHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (Status);
}

NDIS_STATUS
AtmLaneDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	Our Delete VC handler. This VC would have been allocated as a result
	of a previous entry into our CreateVcHandler, and possibly used for
	an incoming call.

	At this time, this VC structure should be free of any calls, and we
	simply free this.

Arguments:

	ProtocolVcContext	- pointer to our VC structure

Return Value:

	NDIS_STATUS_SUCCESS always

--*/
{
	PATMLANE_VC			pVc;
	ULONG				rc;		// Ref count on the VC
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(DeleteVcHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;

	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ASSERT((pVc->Flags & VC_OWNER_MASK) == VC_OWNER_IS_CALLMGR);

	ACQUIRE_VC_LOCK(pVc);
	rc = AtmLaneDereferenceVc(pVc, "vc");
	if (rc > 0)
	{
		//
		//  This can happen if there is a timer still running
		//  on this VC. When the timer elapses, the VC will be
		//  freed.
		//
		DBGP((2, "Delete VC handler: pVc %x, Flags %x, refcount %d\n",
					pVc, pVc->Flags, rc));
		RELEASE_VC_LOCK(pVc);
	}
	//
	//  else the VC is gone.
	//
	DBGP((3, "Delete Vc Handler: %x: done\n", pVc));

	TRACEOUT(DeleteVcHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
AtmLaneIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
)
/*++

Routine Description:

	This handler is called when there is an incoming call matching our
	SAPs. 

Arguments:

	ProtocolSapContext		- Pointer to ATMLANE Interface structure
	ProtocolVcContext		- Pointer to ATMLANE VC structure
	pCallParameters			- Call parameters

Return Value:

	NDIS_STATUS_SUCCESS if we accept this call
	NDIS_STATUS_FAILURE if we reject it.

--*/
{
	PATMLANE_VC										pVc;
	PATMLANE_ATM_ENTRY								pAtmEntry;
	PATMLANE_ELAN									pElan;
	PATMLANE_SAP									pSap;

	Q2931_CALLMGR_PARAMETERS UNALIGNED *			pAtmCallMgrParameters;

	//
	//  To traverse the list of Info Elements
	//
	Q2931_IE UNALIGNED *							pIe;
	ULONG											InfoElementCount;

	//
	//  Info Elements in the incoming call, that are of interest to us.
	//  Initialize these to <not present>.
	//
	ATM_ADDRESS UNALIGNED *							pCallingAddress = NULL;
	AAL_PARAMETERS_IE UNALIGNED *					pAal = NULL;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor = NULL;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc = NULL;
	ATM_BLLI_IE UNALIGNED *							pBlli = NULL;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos = NULL;
	AAL5_PARAMETERS UNALIGNED *						pAal5;
	UCHAR											AddrTypeLen;
	UCHAR											SubaddrTypeLen;
	PUCHAR											pAtmSubaddress;
	NDIS_STATUS										Status;
	ULONG											Type;
	ULONG											rc;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(IncomingCallHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	pSap = (PATMLANE_SAP)ProtocolSapContext;

	STRUCT_ASSERT(pVc, atmlane_vc);
	STRUCT_ASSERT(pSap, atmlane_sap);

	ASSERT((pVc->Flags & VC_TYPE_MASK) == VC_TYPE_UNUSED);
	ASSERT((pVc->Flags & VC_OWNER_MASK) == VC_OWNER_IS_CALLMGR);
	ASSERT((pVc->Flags & VC_CALL_STATE_MASK) == VC_CALL_STATE_IDLE);

	pElan = pVc->pElan;
	DBGP((3, "Incoming Call: pElan %x, pVc %x, pCallParams %x Type %s\n",
				pElan, pVc, pCallParameters,
				(pSap->LaneType == VC_LANE_TYPE_CONTROL_DISTRIBUTE?"LES":
				(pSap->LaneType == VC_LANE_TYPE_MULTI_FORWARD?"BUS":"DATA"))
				));

	do
	{
		//
		//	Start off with accepting the call
		//
		Status = NDIS_STATUS_SUCCESS;

	
		//
		//	If Elan is going down or staying down then reject the call
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			DBGP((2, "IncomingCallHandler: Elan is down, rejecting call\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Reject PVCs for now...
		//
		if ((pCallParameters->Flags & PERMANENT_VC) != 0)
		{
			DBGP((0, "IncomingCallHandler: PVCs not supported\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get the following info from the Incoming call:
		//		Calling Address
		//		AAL Parameters
		//		Traffic Descriptor
		//		Broadband Bearer Capability
		//		QoS
		//
		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
					pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

		pCallingAddress = &(pAtmCallMgrParameters->CallingParty);
		InfoElementCount = pAtmCallMgrParameters->InfoElementCount;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);

		while (InfoElementCount--)
		{
			switch (pIe->IEType)
			{
				case IE_AALParameters:
					pAal = (PAAL_PARAMETERS_IE)(pIe->IE);
					break;
				case IE_TrafficDescriptor:
					pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)(pIe->IE);
					break;
				case IE_BroadbandBearerCapability:
					pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)(pIe->IE);
					break;
				case IE_QOSClass:
					pQos = (PATM_QOS_CLASS_IE)(pIe->IE);
					break;
				case IE_BLLI:
					pBlli = (PATM_BLLI_IE)(pIe->IE);
					break;
				default:
					break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}

		//
		//  Make sure all mandatory IEs are present. If not, reject the call
		//
		if ((pAal == 				(PAAL_PARAMETERS_IE)NULL) ||
			(pTrafficDescriptor == 	(PATM_TRAFFIC_DESCRIPTOR_IE)NULL) ||
			(pBbc == 				(PATM_BROADBAND_BEARER_CAPABILITY_IE)NULL) ||
			(pQos == 				(PATM_QOS_CLASS_IE)NULL) ||
			(pBlli ==				(PATM_BLLI_IE)NULL))
		{
			DBGP((0, "IncomingCallHandler: IE missing: "
			         " AAL %x TRAF %x BBC %x QOS %x BLLI %x",
					pAal,
					pTrafficDescriptor,
					pBbc,
					pQos,
					pBlli));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Calling Address must be present
		//
		if (((pCallParameters->Flags & PERMANENT_VC) == 0) &&
			(pCallingAddress->NumberOfDigits == 0))
		{
			DBGP((0, "IncomingCallHandler: calling address missing\n"));
			Status = NDIS_STATUS_INVALID_ADDRESS;
			break;
		}

		//
		//  Make sure that the requested SDU sizes are sane.
		//	Originally this failed the call but now just a warning in DBG mode.
		//
#if DBG	
		pAal5 = &(pAal->AALSpecificParameters.AAL5Parameters);
		switch (pSap->LaneType)
		{
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:		// LES incoming
				if (pAal5->ForwardMaxCPCSSDUSize != 1516)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d"
							 "Incorrect for Control Distribute VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}
				break;
			case VC_LANE_TYPE_MULTI_FORWARD:			// BUS incoming
				if (pAal5->ForwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d "
							 "Invalid for Multicast Forward VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}
				break;
			case VC_LANE_TYPE_DATA_DIRECT:				// PEER
				if (pAal5->ForwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d "
							 "Invalid for Data Direct VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}

				if (pAal5->BackwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) BackwardMaxCPCSSDUSize %d "
							 "Invalid for Data Direct VCC\n",
							 pAal5->BackwardMaxCPCSSDUSize));
				}
				break;
		}
#endif

		//
		//	Earlier SAP matching problem required looking at the
		//	BLLI.  It was corrected. Now it is just redundant.
		//
		
		switch (pBlli->SnapId[4])
		{
			case 0x01:
				Type = VC_LANE_TYPE_CONTROL_DISTRIBUTE;
				break;
			case 0x02:
				Type = VC_LANE_TYPE_DATA_DIRECT;
				if (pElan->LanType == LANE_LANTYPE_TR)
				{
					DBGP((0, "IncomingCallHandler: Got ETH call on TR LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x03:
				Type = VC_LANE_TYPE_DATA_DIRECT;
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					DBGP((0, "IncomingCallHandler: Got TR call on ETH LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x04:
				Type = VC_LANE_TYPE_MULTI_FORWARD;
				if (pElan->LanType == LANE_LANTYPE_TR)
				{
					DBGP((0, "IncomingCallHandler: Got ETH call on TR LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x05:
				Type = VC_LANE_TYPE_MULTI_FORWARD;
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					DBGP((0, "IncomingCallHandler: Got TR call on ETH LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
		}
		if (NDIS_STATUS_SUCCESS != Status)
		{
			break;
		}

		if (Type != pSap->LaneType)
		{
			DBGP((0, 
				"IncomingCallHandler: Type %d from BLLI"
				" differs from Type %d in SAP\n",
				Type, pSap->LaneType));
		}
		
		//
		//	Now link up the VC to ATM Entry based on type
		//
		pVc->LaneType = Type;

		switch (Type)
		{
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:		// LES incoming
				DBGP((1, "%d Incoming call %x from LES\n", pVc->pElan->ElanNumber, pVc));
				pAtmEntry = pElan->pLesAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							// copy in caller's addr
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
				if (pAtmEntry->pVcIncoming != NULL_PATMLANE_VC)
				{
					DBGP((0, "IncomingCallHandler: Redundant LES incoming call\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, TRUE);
					SET_FLAG(
							pAtmEntry->Flags,
							ATM_ENTRY_STATE_MASK,
							ATM_ENTRY_CONNECTED
							);
					pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				}
				RELEASE_VC_LOCK_DPC(pVc);
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				break;
				
			case VC_LANE_TYPE_MULTI_FORWARD:			// BUS incoming
				DBGP((1, "%d Incoming call %x from BUS\n", pVc->pElan->ElanNumber, pVc));
				pAtmEntry = pElan->pBusAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							// copy in caller's addr
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
				if (pAtmEntry->pVcIncoming != NULL_PATMLANE_VC)
				{
					DBGP((0, "IncomingCallHandler: Redundant BUS incoming call\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, TRUE);
					SET_FLAG(
							pAtmEntry->Flags,
							ATM_ENTRY_STATE_MASK,
							ATM_ENTRY_CONNECTED
							);
					pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				}
				RELEASE_VC_LOCK_DPC(pVc);
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				break;

			case VC_LANE_TYPE_DATA_DIRECT:				// PEER
				DBGP((1, "%d Incoming call %x from PEER\n", pVc->pElan->ElanNumber, pVc));


				//
				//	Find/create an ATM Entry
				//
				pAtmEntry = AtmLaneSearchForAtmAddress(
										pElan, 
										pCallingAddress->Address,
										ATM_ENTRY_TYPE_PEER,
										TRUE
										);
				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

				//
				//	Remember caller's address
				//
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
							
				//
				//	Start with with normal timeout, 
				//	AtmLaneLinkVcToAtmEntry will accelerate	if necessary.
				//
				pVc->AgingTime = pElan->VccTimeout;		
							
				//
				//	Link up the VC with ATM Entry
				//
				if (pAtmEntry->pVcList != NULL_PATMLANE_VC)
				{
					DBGP((2, 
						"IncomingCallHandler: Multiple VCs for Dest ATM Addr\n"));
				}
				AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, FALSE);
				SET_FLAG(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED
						);
				pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				RELEASE_VC_LOCK_DPC(pVc);

				//
				//  Remove ref added by SearchFor...
				//
				rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
				if (rc != 0)
				{
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				}
				break;
		}

		break;

	}
	while (FALSE);

	DBGP((3, "Incoming call: pVc %x, Status %x\n", pVc, Status));
		
	TRACEOUT(IncomingCallHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return Status;
}


VOID
AtmLaneCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	This handler is called as the final step in an incoming call, to inform
	us that the call is fully setup.

	For a PVC, we link the ATMLANE VC structure in the list of unresolved PVCs,
	and use InATMLANE to resolve both the IP and ATM addresses of the other
	end.

	For an SVC, 
	
Arguments:

	ProtocolVcContext		- Pointer to ATMLANE VC structure

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ELAN		pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CallConnectedHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ASSERT((pVc->Flags & VC_CALL_STATE_MASK)
						 == VC_CALL_STATE_INCOMING_IN_PROGRESS);

	ACQUIRE_VC_LOCK(pVc);

	DBGP((1, "%d Incoming call %x connected\n", pVc->pElan->ElanNumber, pVc));

	//
	//  Note down that a call is active on this VC.
	//
	SET_FLAG(
			pVc->Flags,
			VC_CALL_STATE_MASK,
			VC_CALL_STATE_ACTIVE
			);

	AtmLaneReferenceVc(pVc, "call");		// Incoming call reference

	DBGP((2, "CallConnectedHandler: pVc %x Flags %x pAtmEntry %x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);


	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{
		if (pVc->LaneType == VC_LANE_TYPE_DATA_DIRECT)
		{
			//
			//	Start ready protocol on non-server connections
			//  only if ready indication not already received.
			//
			if (!IS_FLAG_SET(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED))
			{
				DBGP((2, "CallConnectedHandler: pVc %x Starting Ready Timer\n", pVc));
				SET_FLAG(
						pVc->Flags,
						VC_READY_STATE_MASK,
						VC_READY_WAIT
						);
				pVc->RetriesLeft = 1;
				AtmLaneReferenceVc(pVc, "ready timer");
				AtmLaneStartTimer(
						pElan, 
						&pVc->ReadyTimer, 
						AtmLaneReadyTimeout, 
						pElan->ConnComplTimer, 
						pVc);

						
			}
			
			//
			//  Start VC aging timer
			//
			AtmLaneReferenceVc(pVc, "aging timer");
			AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);
		}
		else
		{
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED
					);
		}
		RELEASE_VC_LOCK(pVc);

	}
	else
	{
		//
		//  The elan is going down. Close this call.
		//
		AtmLaneCloseCall(pVc);
		//
		// VC lock released in above
		//
	}

	TRACEOUT(CallConnectedHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


VOID
AtmLaneIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called when a call is closed, either by the network
	or by the remote peer.

Arguments:

	CloseStatus			- Reason for the call clearing
	ProtocolVcContext	- Actually a pointer to the ATMLANE VC structure
	pCloseData			- Additional info about the close
	Size				- Length of above

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ATM_ENTRY	pAtmEntry;
	PATMLANE_ELAN		pElan;
	ULONG				rc;				// Ref Count
	BOOLEAN				IsServer = FALSE;
	ULONG				ServerType = 0;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(IncomingCloseHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ACQUIRE_VC_LOCK(pVc);
	
	pVc->Flags |= VC_SEEN_INCOMING_CLOSE;

	pAtmEntry = pVc->pAtmEntry;
	pElan = pVc->pElan;
	
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//	Determine if this is server connection
		//
		IsServer = (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type) ? FALSE : TRUE;
		if (IsServer)
		{
			ServerType = pAtmEntry->Type;
		}

		//
		//	Unlink the VC from the AtmEntry
		//
		if (AtmLaneUnlinkVcFromAtmEntry(pVc))
		{
			rc = AtmLaneDereferenceVc(pVc, "atm");
			ASSERT(rc > 0);
		}
	}

	//
	//  If we're seeing this just after accepting an incomingcall,
	//  fake the call state to Active, so that AtmLaneCloseCall will
	//  tear down the call.
	//
	if (IS_FLAG_SET(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_INCOMING_IN_PROGRESS))
	{
		SET_FLAG(
				pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_ACTIVE);

		AtmLaneReferenceVc(pVc, "call");	// Incoming call reference - CloseCall
	}

	//
	//	Complete tearing down the call
	//
	AtmLaneCloseCall(pVc);

	//
	//	If server connection - notify the event handler
	//
	if (IsServer)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		switch(ServerType)
		{
			case ATM_ENTRY_TYPE_LECS:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_LECS_CALL_CLOSED, 0);
				break;
			case ATM_ENTRY_TYPE_LES:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_LES_CALL_CLOSED, 0);
				break;
			case ATM_ENTRY_TYPE_BUS:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_BUS_CALL_CLOSED, 0);
				break;
		}
		RELEASE_ELAN_LOCK(pElan);
	}

	TRACEOUT(IncomingCloseHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called if the network (or remote peer) drops
	a leaf node from a point-to-multipoint call rooted at us.

	Since we don't use point-to-multipoint calls, we should never
	see one of these.

Arguments:

	Not relevant to us since we never expect to see this.

Return Value:

	None

--*/
{
	TRACEIN(IncomingDropPartyHandler);

	DBGP((0, "IncomingDropPartyHandler: UNEXPECTED CALL!\n"));
	ASSERT(FALSE);
	
	TRACEOUT(IncomingDropPartyHandler);

	return;
}

VOID
AtmLaneQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This handler is called if the remote peer modifies call parameters
	"on the fly", i.e. after the call is established and running.

	This isn't supported by existing ATM signalling, and shouldn't happen,
	but we'll allow this.

	FUTURE: The FlowSpecs associated with the call are affected by this.

Arguments:

	ProtocolVcContext		- Pointer to our ATMLANE VC structure
	pCallParameters			- updated call parameters.

Return Value:

	None

--*/
{
	PATMLANE_VC		pVc;

	TRACEIN(QosChangeHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;

	DBGP((0, "Ignoring Qos Change, VC: %x\n", pVc));

	TRACEOUT(QosChangeHandler);

	return;
}



VOID
AtmLaneRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClRegisterSap. If the call was successful, save the
	allocated NdisSapHandle in our SAP structure.

Arguments:

	Status						- Status of Register SAP
	ProtocolSapContext			- Pointer to our ATMLANE Interface structure
	pSap						- SAP information we'd passed in the call
	NdisSapHandle				- SAP Handle

Return Value:

	None

--*/
{
	PATMLANE_SAP					pAtmLaneSap;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(RegisterSapCompleteHandler);

	pAtmLaneSap = (PATMLANE_SAP)ProtocolSapContext;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmLaneSap->NdisSapHandle = NdisSapHandle;
		SET_FLAG(pAtmLaneSap->Flags,
				SAP_REG_STATE_MASK,
				SAP_REG_STATE_REGISTERED);
				
		NdisInterlockedIncrement(&pAtmLaneSap->pElan->SapsRegistered);
		if (pAtmLaneSap->pElan->SapsRegistered == 3)
			AtmLaneQueueElanEvent(
					pAtmLaneSap->pElan, 
					ELAN_EVENT_SAPS_REGISTERED, 
					Status);
	}
	else
	{
		SET_FLAG(pAtmLaneSap->Flags,
				SAP_REG_STATE_MASK,
				SAP_REG_STATE_IDLE);
		AtmLaneQueueElanEvent(
				pAtmLaneSap->pElan, 
				ELAN_EVENT_SAPS_REGISTERED, 
				Status);
	}
	
	TRACEOUT(RegisterSapCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
)
/*++

Routine Description:

	This routine is called when a previous call to NdisClDeregisterSap
	has completed. If it was successful, we update the state of the ATMLANE
	SAP structure representing the Sap.

Arguments:

	Status						- Status of the Deregister SAP request
	ProtocolSapContext			- Pointer to our ATMLANE SAP structure

Return Value:

	None

--*/
{

	PATMLANE_ELAN					pElan;
	PATMLANE_SAP					pAtmLaneSap;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(DeregisterSapCompleteHandler);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmLaneSap = (PATMLANE_SAP)ProtocolSapContext;

		STRUCT_ASSERT(pAtmLaneSap, atmlane_sap);
		pElan = pAtmLaneSap->pElan;

		ACQUIRE_ELAN_LOCK(pElan);

		pAtmLaneSap->NdisSapHandle = NULL;

		SET_FLAG(pAtmLaneSap->Flags,
					SAP_REG_STATE_MASK,
					SAP_REG_STATE_IDLE);
		
		RELEASE_ELAN_LOCK(pElan);
	}

	TRACEOUT(DeregisterSapCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called when an outgoing call request (NdisClMakeCall)
	has completed. The "Status" parameter indicates whether the call was
	successful or not.

	If the call was successful and this is a server connection then
	the an event handler is called.  If it is a peer connection then
	???

	If the call failed ??

Arguments:

	Status						- Result of the NdisClMakeCall
	ProtocolVcContext			- Pointer to ATMLANE VC structure
	NdisPartyHandle				- Not used (no point-to-multipoint calls)
	pCallParameters				- Pointer to call parameters

Return Value:

	None

--*/
{
	PATMLANE_VC					pVc;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_MAC_ENTRY			PMacEntryNext;
	PATMLANE_ELAN				pElan;
	ULONG						rc;			
	NDIS_HANDLE					NdisVcHandle;
	BOOLEAN						IsServer;	
	ULONG						EventStatus;
#if DEBUG_IRQL
	KIRQL						EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(MakeCallCompleteHandler);

	//
	//  Initialize
	//
	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);

	ACQUIRE_VC_LOCK(pVc);

	DBGP((3, "MakeCallCompleteHandler: Status %x, pVc %x, pAtmEntry %x\n",
				Status, pVc, pVc->pAtmEntry));
	
	pElan = pVc->pElan;

	DBGP((1, "%d Outgoing call %x %s\n", pVc->pElan->ElanNumber, pVc,
		(Status == NDIS_STATUS_SUCCESS)?"complete":"failed"));

	if ((ELAN_STATE_OPERATIONAL == pElan->AdminState) &&

		(!IS_FLAG_SET(pVc->Flags,
					  VC_CLOSE_STATE_MASK,
					  VC_CLOSE_STATE_CLOSING)))
	{
		pAtmEntry = pVc->pAtmEntry;
		STRUCT_ASSERT(pAtmEntry, atmlane_atm);

		//
		//	Determine if this is server connection
		//
		IsServer = (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type) ? FALSE : TRUE;

		if (Status == NDIS_STATUS_SUCCESS)
		{
			//
			//  Update the call state on this VC.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE);

			//
			//  Update the call type on this VC. 
			//
			if (pCallParameters->Flags & PERMANENT_VC)
			{
				SET_FLAG(pVc->Flags,
						VC_TYPE_MASK,
						VC_TYPE_PVC);
			}
			else
			{
				SET_FLAG(pVc->Flags,
						VC_TYPE_MASK,
						VC_TYPE_SVC);
			}

			//
			//  Start VC aging timer if not server
			//
			if (!IsServer)
			{
				AtmLaneReferenceVc(pVc, "aging timer");
				AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);
			}
			//
			//	Update the ready state on this VC
			//
			SET_FLAG(pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED);
			if (!IsServer)
			{
				AtmLaneSendReadyIndication(pElan, pVc);
				//
				//	VC lock released in above
				//
			}
			else
			{
				RELEASE_VC_LOCK(pVc);
			}

			//
			//	Update the Atm Entry
			//
			//	Clear call-in-progress and mark connected
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

			pAtmEntry->Flags &= ~ ATM_ENTRY_CALLINPROGRESS;

			SET_FLAG(
					pAtmEntry->Flags,
					ATM_ENTRY_STATE_MASK,
					ATM_ENTRY_CONNECTED);

			//
			//	Go through the Mac Entry List and see if any
			//	need the flush protocol initiated.
			//
			pMacEntry = pAtmEntry->pMacEntryList;
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{
				PATMLANE_MAC_ENTRY		pNextMacEntry;

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

				pNextMacEntry = pMacEntry->pNextToAtm;

				if (IS_FLAG_SET(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED))
				{
					//
					//	Start the Flush protocol
					//
					pMacEntry->RetriesLeft = 0;
					AtmLaneReferenceMacEntry(pMacEntry, "timer");
					AtmLaneStartTimer(
						pElan,
						&pMacEntry->FlushTimer,
						AtmLaneFlushTimeout,
						pElan->FlushTimeout,
						(PVOID)pMacEntry
						);

					SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_FLUSHING);

					//
					//	Send the flush
					//
					AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
					//
					//	MacEntry lock released in above
					//
				}
				else
				{
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				pMacEntry = pNextMacEntry;
			}
		}
		else
		{
			//
			//  The call failed.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_IDLE);

			//
			//	Clear call in progress on Atm Entry
			//	Add temp reference to keep the AtmEntry around
			//
			RELEASE_VC_LOCK(pVc);
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
			pAtmEntry->Flags &= ~ATM_ENTRY_CALLINPROGRESS;
			AtmLaneReferenceAtmEntry(pAtmEntry, "temp1");
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			ACQUIRE_VC_LOCK(pVc);

			//
			//  Delete the Call reference
			//
			rc = AtmLaneDereferenceVc(pVc, "call");
			ASSERT(rc > 0);

			//
			//  Unlink this VC from the ATM Entry it belonged to.
			//
			ASSERT(pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				ASSERT(rc > 0);
			}

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			DBGP((3, 
				"MakeCallCompleteHandler: DeleteVc  Vc %x NdisVcHandle %x\n",
				pVc, NdisVcHandle));

			//
			//	Abort all the MAC entries attached to this Atm Entry.
			//
			pMacEntry = pAtmEntry->pMacEntryList;
			while ( pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{
				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneAbortMacEntry(pMacEntry);
				ASSERT(pAtmEntry->pMacEntryList != pMacEntry);
				pMacEntry = pAtmEntry->pMacEntryList;
			}

			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
			rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "temp1");
			if (rc > 0)
			{
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			}
		}

		//
		//	Free the Call Parameters allocated in MakeCall().
		//
		FREE_MEM(pCallParameters);

		//
		//	If this is server connection then 
		//	send an event to the elan state machine.
		//
	
		if (IsServer)
		{
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			RELEASE_ELAN_LOCK(pElan);
		}
	}
	else
	{
		//
		//  The Elan is going down and/or we are aborting the
		//  ATM entry: clean up everything first.
		//

		//
		//	Free the Call Parameters allocated in MakeCall().
		//
		FREE_MEM(pCallParameters);

		//
		//  Unlink this VC from the ATM Entry
		//
		if (pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				ASSERT(rc > 0);
			}
		}

		if (NDIS_STATUS_SUCCESS == Status)
		{
			//
			//  The call had been set up successfully, so close it.
			//
			//
			//  Update the call state on this VC.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE);

			AtmLaneCloseCall(pVc);
			//
			//  The VC lock is released by CloseCall
			//
		}
		else
		{
			//  MakeCall had failed. (And the ELAN is going down)

			SET_FLAG(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_IDLE);

			//
			//  Delete the Call reference
			//
			AtmLaneDereferenceVc(pVc, "call");

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}

			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			DBGP((3,
			"MakeCallCompleteHandler: Deleted NDIS VC on pVc %x: NdisVcHandle %x\n",
				pVc, NdisVcHandle));
		}
	}
			
	TRACEOUT(MakeCallCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
)
/*++

Routine Description:

	This routine handles completion of a previous NdisClCloseCall.
	It is assumed that Status is always NDIS_STATUS_SUCCESS.

Arguments:

	Status					- Status of the Close Call.
	ProtocolVcContext		- Pointer to ATMLANE VC structure.
	ProtocolPartyContext	- Not used.

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;
	ULONG					rc;			// Ref Count
	NDIS_HANDLE				NdisVcHandle;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CloseCallCompleteHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);

	DBGP((1, "%d Close call %x complete\n", pVc->pElan->ElanNumber, pVc));

	ACQUIRE_VC_LOCK(pVc);

	rc = AtmLaneDereferenceVc(pVc, "call");	// Call reference
	SET_FLAG(pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_IDLE);

	//
	//  If this VC belongs to us, delete it.
	//
	if (IS_FLAG_SET(pVc->Flags,
						VC_OWNER_MASK,
						VC_OWNER_IS_ATMLANE))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//  Delete the NDIS association
		//
		(VOID)NdisCoDeleteVc(NdisVcHandle);
		DBGP((3, "CloseCallComplete: deleted NDIS VC on pVc %x: NdisVcHandle %x\n",
				pVc, NdisVcHandle));
	}
	else
	{
		//
		//  VC belongs to the Call Manager -- take it back to the
		//  state it was when it was just created (via our CreateVcHandler).
		//  The Call Manager can either re-use it or delete it.
		//
		pVc->Flags = VC_OWNER_IS_CALLMGR;
		RELEASE_VC_LOCK(pVc);
	}

	TRACEOUT(CloseCallCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


VOID
AtmLaneAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(AddPartyCompleteHandler);

	DBGP((0, "Add Party Complete unexpectedly called\n"));

	TRACEOUT(AddPartyCompleteHandler);

	return;
}

VOID
AtmLaneDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClDropParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(DropPartyCompleteHandler);

	DBGP((0, "Drop Party Complete unexpectedly called\n"));

	TRACEOUT(DropPartyCompleteHandler);

	return;
}



VOID
AtmLaneModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClModifyCallQoS. Since we don't call this, this should never
	get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(ModifyQosCompleteHandler);

	DBGP((0, "Modify QOS Complete unexpectedly called\n"));

	TRACEOUT(ModifyQosCompleteHandler);

	return;
}

NDIS_STATUS
AtmLaneSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Connection Oriented request to the Call Manager. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	NdisAdapterHandle		- Binding Handle to be used in the request
	NdisAfHandle			- AF Handle value to be used in the request
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisCoRequest.

--*/
{
	NDIS_STATUS			Status;

	TRACEIN(SendNdisCoRequest);

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	if (NULL == NdisAfHandle ||
		NULL == NdisAdapterHandle)
	{
		Status = NDIS_STATUS_INTERFACE_DOWN;
	}
	else
	{

		Status = NdisCoRequest(
					NdisAdapterHandle,
					NdisAfHandle,
					NULL,			// No VC handle
					NULL,			// No Party Handle
					pNdisRequest);
	}
		
	TRACEOUT(SendNdisCoRequest);

	return (Status);
}




NDIS_STATUS
AtmLaneCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when our Call Manager sends us an
	NDIS Request. NDIS Requests that are of significance to us are:
	- OID_CO_ADDRESS_CHANGE
		The set of addresses registered with the switch has changed,
		i.e. address registration is complete. We issue an NDIS Request
		ourselves to get the list of addresses registered.
	- OID_CO_SIGNALING_ENABLED
		We ignore this as of now.
	- OID_CO_SIGNALING_DISABLED
		We ignore this for now.
	- OID_CO_AF_CLOSE
		The Call manager wants us to shut down this AF open (== ELAN).

	We ignore all other OIDs.

Arguments:

	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMLANE Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMLANE VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.

Return Value:

	NDIS_STATUS_SUCCESS if we recognized the OID
	NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/
{
	PATMLANE_ELAN				pElan;
	PATMLANE_ADAPTER			pAdapter;
	NDIS_STATUS					Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CoRequestHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  Initialize
	//
	Status = NDIS_STATUS_NOT_RECOGNIZED;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:
				DBGP((1, "CoRequestHandler: CO_ADDRESS_CHANGE\n"));
				//
				//  The Call Manager says that the list of addresses
				//  registered on this interface has changed. Get the
				//  (potentially) new ATM address for this interface.
				//
				ACQUIRE_ELAN_LOCK(pElan);
				pElan->AtmInterfaceUp = FALSE;
				//
				//	zero out the Elan's ATM address
				//
				NdisZeroMemory((PUCHAR)&(pElan->AtmAddress), sizeof(ATM_ADDRESS));
				
				RELEASE_ELAN_LOCK(pElan);

				AtmLaneGetAtmAddress(pElan);
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case OID_CO_SIGNALING_ENABLED:
				DBGP((1, "CoRequestHandler: CO_SIGNALING_ENABLED\n"));
				// ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_SIGNALING_DISABLED:
				DBGP((1, "CoRequestHandler: CO_SIGNALING_DISABLED\n"));
				// Ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_AF_CLOSE:
				DBGP((0, "CoRequestHandler: CO_AF_CLOSE on ELAN %x/%x\n", pElan, pElan->Flags));
				pAdapter = pElan->pAdapter;
				ACQUIRE_ADAPTER_LOCK(pAdapter);
				while (pAdapter->Flags & ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS)
				{
					RELEASE_ADAPTER_LOCK(pAdapter);
					(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->UnbindBlock);
					ACQUIRE_ADAPTER_LOCK(pAdapter);
				}
				RELEASE_ADAPTER_LOCK(pAdapter);

				ACQUIRE_ELAN_LOCK(pElan);
				pElan->Flags |= ELAN_SAW_AF_CLOSE;
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_STOP, 0, 1*1000);
				RELEASE_ELAN_LOCK(pElan);
				Status = NDIS_STATUS_SUCCESS;
				break;

			default:
				break;
		}
	}

	TRACEOUT(CoRequestHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (Status);
}

VOID
AtmLaneCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when a previous call to NdisCoRequest
	that had pended, is complete. We handle this based on the request
	we had sent, which has to be one of:
	- OID_CO_GET_ADDRESSES
		Get all addresses registered on the specified AF binding.

Arguments:

	Status						- Status of the Request.
	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMLANE Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMLANE VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.


Return Value:

	None

--*/
{
	PATMLANE_ELAN				pElan;
	ULONG						Oid;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CoRequestCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		switch (pNdisRequest->DATA.QUERY_INFORMATION.Oid)
		{
			case OID_CO_GET_ADDRESSES:
				AtmLaneGetAtmAddressComplete(
							Status,
							pElan,
							pNdisRequest
							);
				break;

			case OID_ATM_LECS_ADDRESS:
				AtmLaneGetLecsIlmiComplete(
							Status,
							pElan,
							pNdisRequest
							);
				break;

			default:
				DBGP((0, "CoRequestComplete: pNdisReq %x, unknown Query Oid %x\n",
					 		pNdisRequest,
					 		pNdisRequest->DATA.QUERY_INFORMATION.Oid));
				ASSERT(FALSE);
				break;
		}
	}
	else
	{
		Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;

		switch (Oid)
		{
			case OID_ATM_MY_IP_NM_ADDRESS:
				DBGP((3, "CoRequestComplete: IP addr: Status %x\n", Status));
				break;
			default:
				DBGP((0, "CoRequestComplete: pNdisReq %x, unknown Set Oid %x\n",
					 		pNdisRequest, Oid));
				ASSERT(FALSE);
				break;
		}
	}

	FREE_MEM(pNdisRequest);

	TRACEOUT(CoRequestCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}



NDIS_STATUS
AtmLaneGetAtmAddress(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve the ATM address
	registered with the switch on the given interface.

	This is called when the Call Manager tells us that there has been
	a change in its list of addresses registered with the switch.
	Normally, this happens when we start up our signalling stack (i.e.
	initial address registration), but it might happen during runtime,
	for example, if the link goes down and up, or we get physically
	connected to a different switch...

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the first address it has registered. Action then continues in
	AtmLaneGetAtmAddressComplete.

Arguments:

	pElan				- Elan structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PCO_ADDRESS_LIST			pAddressList;
	ULONG						RequestSize;

	TRACEIN(GetAtmAddress);

	DBGP((3, "GetAtmAddress: pElan %x\n", pElan));

	ACQUIRE_ELAN_LOCK(pElan);

	NdisAfHandle = pElan->NdisAfHandle;
	NdisAdapterHandle = pElan->NdisAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	do
	{
		if (NULL == NdisAfHandle ||
			NULL == NdisAdapterHandle)
		{
			DBGP((0, "%d Aborting GetAtmAddress, Elan %x, AfH %x AdH %x\n",
					pElan->ElanNumber, pElan, NdisAfHandle, NdisAdapterHandle));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Allocate all that we need.
		//
		RequestSize = 	sizeof(NDIS_REQUEST) +
						sizeof(CO_ADDRESS_LIST) + 
						sizeof(CO_ADDRESS) + 
						sizeof(ATM_ADDRESS);
						
		ALLOC_MEM(&pNdisRequest, RequestSize);
	
		if ((PNDIS_REQUEST)NULL == pNdisRequest)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		//	Init request data
		//
		pAddressList = (PCO_ADDRESS_LIST)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		NdisZeroMemory(pAddressList, sizeof(CO_ADDRESS_LIST));

		//
		//	Send off request
		//
		Status = AtmLaneSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_CO_GET_ADDRESSES,
						(PVOID)pAddressList,
						RequestSize - sizeof(NDIS_REQUEST)
						);

		if (NDIS_STATUS_PENDING != Status)
		{
			AtmLaneCoRequestCompleteHandler(
						Status,
						(NDIS_HANDLE)pElan,	// ProtocolAfContext
						NULL,				// Vc Context
						NULL,				// Party Context
						pNdisRequest
						);
		}

		
	} while (FALSE);

	TRACEOUT(GetAtmAddress);

	return Status;
}


VOID
AtmLaneGetAtmAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). If any addresses returned,
	copy the first for our address.

	If the address is different from the previous signal an event.
	
Arguments:

	Status					- result of the request
	pElan					- ATMLANE Elan on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PCO_ADDRESS_LIST		pAddressList;
	ATM_ADDRESS UNALIGNED *	pAtmAddress;

	TRACEIN(GetAtmAddressComplete);

	DBGP((3, "GetAtmAddressComplete: pElan %x, Status %x\n",
			pElan, Status));

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pAddressList = (PCO_ADDRESS_LIST)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

		DBGP((3, "GetAtmAddressComplete: pElan %x, Count %d\n",
					pElan, pAddressList->NumberOfAddresses));

		if (pAddressList->NumberOfAddresses > 0)
		{
			//
			//  We have at least one address
			//
			ACQUIRE_ELAN_LOCK(pElan);

			//
			//	Mark AtmInterface "up"
			//
			pElan->AtmInterfaceUp = TRUE;

			pAtmAddress = (ATM_ADDRESS UNALIGNED *)(pAddressList->AddressList.Address);

			//
			//	See if address(without selector byte) differs from
			//	one we already have.  First time will differ as ATM
			//	address starts as all zeros.
			//
			
			if (!NdisEqualMemory(
					pElan->AtmAddress.Address,
					pAtmAddress->Address,
					ATM_ADDRESS_LENGTH-1))
			{

				//
				//	Copy in the new address
				//
				NdisMoveMemory(
						(PUCHAR)&(pElan->AtmAddress),
						(PUCHAR)pAtmAddress,
						sizeof(ATM_ADDRESS)
						);

				//
				//  Patch the selector byte with the Elan number.
				//
				pElan->AtmAddress.Address[ATM_ADDRESS_LENGTH-1] = 
								(UCHAR)(pElan->ElanNumber);

				DBGP((1, 
					"%d GetAtmAddressComplete: New ATMAddr %s\n",
					pElan->ElanNumber,
					AtmAddrToString(pElan->AtmAddress.Address)
					));
					
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_NEW_ATM_ADDRESS, Status, 1*1000);
			}

			RELEASE_ELAN_LOCK(pElan);
		}
	}
	//
	//  else our request failed! Wait for another ADDRESS_CHANGE notification
	//

	TRACEOUT(GetAtmAddressComplete);

	return;
}

NDIS_STATUS
AtmLaneGetLecsIlmi(
	IN	PATMLANE_ELAN			pElan	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve (using ILMI) 
	the ATM address	of the LECS.

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the address. Action	then continues in AtmLaneGetLecsIlmiComplete.

Arguments:

	pElan				- Elan structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PATM_ADDRESS				pAtmAddress;
	ULONG						RequestSize;

	TRACEIN(GetIlmiLecs);

	DBGP((3, "GetIlmiLecs: pElan %x\n", pElan));

	ACQUIRE_ELAN_LOCK(pElan);

	NdisAfHandle = pElan->NdisAfHandle;
	NdisAdapterHandle = pElan->NdisAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	pNdisRequest = NULL;

	//
	//	Zero LecsAddress in Elan
	//
	NdisZeroMemory(&pElan->LecsAddress, sizeof(ATM_ADDRESS));

	do
	{
		//
		//  Allocate NDIS_REQUEST plus one ATM_ADDRESS
		//
		RequestSize =  sizeof(NDIS_REQUEST) + sizeof(ATM_ADDRESS);
		ALLOC_MEM(&pNdisRequest, RequestSize);
	
		if ((PNDIS_REQUEST)NULL == pNdisRequest)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		//	Init request data
		//
		pAtmAddress = (PATM_ADDRESS)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		NdisZeroMemory(pAtmAddress, sizeof(ATM_ADDRESS));

		//
		//	Send off request
		//
		Status = AtmLaneSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_LECS_ADDRESS,
						(PVOID)pAtmAddress,
						RequestSize - sizeof(NDIS_REQUEST)
						);
	}
	while (FALSE);

	if ((NDIS_STATUS_PENDING != Status) &&
		(pNdisRequest != NULL))
	{
		AtmLaneCoRequestCompleteHandler(
					Status,
					(NDIS_HANDLE)pElan,	// ProtocolAfContext
					NULL,				// Vc Context
					NULL,				// Party Context
					pNdisRequest
					);
	}
		
	TRACEOUT(GetIlmiLecs);

	return Status;
}


VOID
AtmLaneGetLecsIlmiComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). Check if we got any addresses
	back: if we did, store the address as our Local ATM Address, and
	if conditions are ripe, start registering ourselves with the ARP
	server.

	Since we allocated the NDIS request, free it here.

Arguments:

	Status					- result of the request
	pElan					- ATMLANE Elan on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PATM_ADDRESS UNALIGNED *	pAtmAddress;

	TRACEIN(GetLecsIlmiComplete);


	ACQUIRE_ELAN_LOCK(pElan);

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pAtmAddress = (PATM_ADDRESS UNALIGNED *)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
		

		//
		//  We have the address. Copy it to elan run-time variable.
		//
		NdisMoveMemory(
				(PUCHAR)&(pElan->LecsAddress),
				(PUCHAR)pAtmAddress,
				sizeof(ATM_ADDRESS)
				);
				
		DBGP((1, "%d ILMI LECS Addr %s\n",
			pElan->ElanNumber,
			AtmAddrToString(pElan->LecsAddress.Address)
			));

		
	}
	else
	{
		DBGP((3, "%d OID_ATM_LECS_ADDRESS Failed %x\n",
				pElan->ElanNumber,
				Status));

	}
	
	AtmLaneQueueElanEvent(pElan, ELAN_EVENT_GOT_ILMI_LECS_ADDR, Status);
	
	RELEASE_ELAN_LOCK(pElan);
	
	TRACEOUT(HandleGetIlmiLecsComplete);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\event.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.h

Abstract:

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef _ATMLANE_EVENT_H_
#define _ATMLANE_EVENT_H_

#define TL_MSENDPKTIN			TL_BUILD_EVENT_ID(1,2)
#define TL_MSENDPKTBEGIN		TL_BUILD_EVENT_ID(2,2)
#define TL_MSENDPKTEND			TL_BUILD_EVENT_ID(3,3)
#define TL_MSENDPKTOUT			TL_BUILD_EVENT_ID(4,1)

#define TL_COSENDCMPLTIN		TL_BUILD_EVENT_ID(5,2)
#define TL_COSENDCMPLTOUT		TL_BUILD_EVENT_ID(6,1)

#define TL_MSENDCOMPL			TL_BUILD_EVENT_ID(7,1)

#define TL_WRAPSEND				TL_BUILD_EVENT_ID(8,4)

#define TL_UNWRAPSEND			TL_BUILD_EVENT_ID(9,4)

#define TL_WRAPRECV				TL_BUILD_EVENT_ID(10,4)

#define TL_UNWRAPRECV			TL_BUILD_EVENT_ID(11,4)

#define TL_COSENDPACKET			TL_BUILD_EVENT_ID(12,1)

#define TL_CORECVPACKET			TL_BUILD_EVENT_ID(13,2)
#define TL_CORETNPACKET			TL_BUILD_EVENT_ID(14,1)

#define TL_MINDPACKET			TL_BUILD_EVENT_ID(15,1)
#define TL_MRETNPACKET			TL_BUILD_EVENT_ID(16,1)

#define TL_NDISPACKET			TL_BUILD_EVENT_ID(17,8)


#endif // _ATMLANE_EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\irpstrng.h ===
struct _string_table irp_string_table[] = {
	{"IRP_MJ_CREATE",					IRP_MJ_CREATE},
	{"IRP_MJ_CREATE_NAMED_PIPE",		IRP_MJ_CREATE_NAMED_PIPE},
	{"IRP_MJ_CLOSE",					IRP_MJ_CLOSE},
	{"IRP_MJ_READ",					  	IRP_MJ_READ},
	{"IRP_MJ_WRITE",					IRP_MJ_WRITE},
	{"IRP_MJ_QUERY_INFORMATION",		IRP_MJ_QUERY_INFORMATION},
	{"IRP_MJ_SET_INFORMATION",			IRP_MJ_SET_INFORMATION},
	{"IRP_MJ_QUERY_EA",					IRP_MJ_QUERY_EA},
	{"IRP_MJ_SET_EA",					IRP_MJ_SET_EA},
	{"IRP_MJ_FLUSH_BUFFERS",			IRP_MJ_FLUSH_BUFFERS},
	{"IRP_MJ_QUERY_VOLUME_INFORMATION",	IRP_MJ_QUERY_VOLUME_INFORMATION},
	{"IRP_MJ_SET_VOLUME_INFORMATION",	IRP_MJ_SET_VOLUME_INFORMATION},
	{"IRP_MJ_DIRECTORY_CONTROL",		IRP_MJ_DIRECTORY_CONTROL},
	{"IRP_MJ_FILE_SYSTEM_CONTROL",		IRP_MJ_FILE_SYSTEM_CONTROL},
	{"IRP_MJ_DEVICE_CONTROL",			IRP_MJ_DEVICE_CONTROL},
	{"IRP_MJ_INTERNAL_DEVICE_CONTROL",	IRP_MJ_INTERNAL_DEVICE_CONTROL},
	{"IRP_MJ_SHUTDOWN",					IRP_MJ_SHUTDOWN},
	{"IRP_MJ_LOCK_CONTROL",				IRP_MJ_LOCK_CONTROL},
	{"IRP_MJ_CLEANUP",					IRP_MJ_CLEANUP},
	{"IRP_MJ_CREATE_MAILSLOT",			IRP_MJ_CREATE_MAILSLOT},
	{"IRP_MJ_QUERY_SECURITY",			IRP_MJ_QUERY_SECURITY},
	{"IRP_MJ_SET_SECURITY",				IRP_MJ_SET_SECURITY},
	{"IRP_MJ_POWER",					IRP_MJ_POWER},
	{"IRP_MJ_SYSTEM_CONTROL",			IRP_MJ_SYSTEM_CONTROL},
	{"IRP_MJ_DEVICE_CHANGE",			IRP_MJ_DEVICE_CHANGE},
	{"IRP_MJ_QUERY_QUOTA",				IRP_MJ_QUERY_QUOTA},
	{"IRP_MJ_SET_QUOTA",				IRP_MJ_SET_QUOTA},
	{"IRP_MJ_PNP",					 	IRP_MJ_PNP},
    {"*** UNKNOWN IRP MJ CODE ***",    	0xffffffff}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\externs.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	externs.h

Abstract:

	All external declarations for ATMLANE modules (functions,
	variables) are here.

Revision History:

Notes:

--*/

#ifndef __ATMLANE_EXTERNS_H
#define __ATMLANE_EXTERNS_H

#ifndef EXTERN
#define EXTERN extern
#endif // EXTERN

//
//  --------------- From adapter.c ----------------------------
//
#if 0
EXTERN VOID Adapter();
#endif

EXTERN
NDIS_STATUS
AtmLanePnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			NetPnPEvent
);

EXTERN
VOID
AtmLaneBindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
);

EXTERN
VOID
AtmLaneUnbindAdapterHandler(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
);

EXTERN
VOID
AtmLaneCompleteUnbindAdapter(
	IN	PATMLANE_ADAPTER				pAdapter
);

EXTERN
VOID
AtmLaneOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
);

EXTERN
VOID
AtmLaneCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
AtmLaneTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
	);

EXTERN
NDIS_STATUS
AtmLaneReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					MacReceiveContext,
	IN	PVOID						HeaderBuffer,
	IN	UINT						HeaderBufferSize,
	IN	PVOID						LookAheadBuffer,
	IN	UINT						LookaheadBufferSize,
	IN	UINT						PacketSize
	);

EXTERN
VOID
AtmLaneResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmLaneStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
VOID
AtmLaneStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmLaneCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
NDIS_STATUS
AtmLaneSendAdapterNdisRequest(
	IN	PATMLANE_ADAPTER			pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
VOID
AtmLaneGetAdapterInfo(
	IN	PATMLANE_ADAPTER			pAdapter
);

EXTERN
UINT
AtmLaneCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneUnloadProtocol(
	VOID
);

EXTERN
BOOLEAN
AtmLaneIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
);

//
//  --------------- From callmgr.c ----------------------------
//
#if 0
EXTERN VOID CallMgr();
#endif

EXTERN
VOID
AtmLaneAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
);

EXTERN
NDIS_STATUS
AtmLaneOpenCallMgr(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
);

EXTERN
VOID
AtmLaneCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN

VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeregisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
NDIS_STATUS
AtmLaneMakeCall(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						UsePvc
);

EXTERN
VOID
AtmLaneCloseCall(
	IN	PATMLANE_VC					pVc
);

EXTERN
NDIS_STATUS
AtmLaneCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmLaneDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmLaneIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
);


EXTERN
VOID
AtmLaneCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
VOID
AtmLaneIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmLaneIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmLaneQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
);

EXTERN
VOID
AtmLaneDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
);

EXTERN
VOID
AtmLaneMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
);

EXTERN
VOID
AtmLaneAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
);

EXTERN
VOID
AtmLaneModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
NDIS_STATUS
AtmLaneSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
NDIS_STATUS
AtmLaneCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
);

EXTERN
VOID
AtmLaneCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
NDIS_STATUS
AtmLaneGetAtmAddress(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneGetAtmAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
NDIS_STATUS
AtmLaneGetLecsIlmi(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneGetLecsIlmiComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
);

//
//  --------------- From elanpkt.c ----------------------------
//
#if 0
EXTERN VOID ElanPkt();
#endif

EXTERN
VOID
AtmLaneSendConfigureRequest(
	IN PATMLANE_ELAN				pElan	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendJoinRequest(
	IN PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneSendArpRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendReadyQuery(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendReadyIndication(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendFlushRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT,
	IN PATMLANE_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmLaneConfigureResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneControlPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneJoinResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneReadyQueryHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pQueryNdisPacket
);

EXTERN
VOID
AtmLaneFlushRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pRequestNdisPacket
);

EXTERN
VOID
AtmLaneArpRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneArpResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneFlushResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneReadyIndicationHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pIndNdisPacket
);

EXTERN
VOID
AtmLaneTopologyRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME			pCf
);

EXTERN
BOOLEAN
AtmLaneDataPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneSendPacketOnVc(
	IN	PATMLANE_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	BOOLEAN						Refresh
);
	
EXTERN
VOID
AtmLaneQueuePacketOnHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneQueuePacketOnTail(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmLaneDequeuePacketFromHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
NDIS_STATUS
AtmLaneSendUnicastPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						DestAddrType,
	IN	PMAC_ADDRESS				pDestAddress,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneStartBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
);

EXTERN
VOID
AtmLaneDoBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
);

EXTERN
VOID
AtmLaneBusSendTimer(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						pContext,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
BOOLEAN
AtmLaneOKToBusSend(
	IN	PATMLANE_MAC_ENTRY		pMacEntry
);

EXTERN
VOID
AtmLaneFreePacketQueue(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneCompleteSendPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
);

EXTERN
PWSTR
AtmLaneMacAddrToString(
	IN	VOID * pIn
);

EXTERN
PWSTR
AtmLaneAtmAddrToString(
	IN	PATM_ADDRESS pIn
);


//
//  --------------- From elanproc.c ----------------------------
//
#if 0
EXTERN VOID elanproc();
#endif

EXTERN
VOID
AtmLaneEventHandler(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						pContext
);

EXTERN
VOID
AtmLaneBootStrapElans(
    IN  PATMLANE_ADAPTER            pAdapter
);

EXTERN
NDIS_STATUS
AtmLaneCreateElan(
    IN  PATMLANE_ADAPTER            pAdapter,
    IN  PNDIS_STRING                pElanKey,
    OUT	PATMLANE_ELAN *				ppElan
);

EXTERN
NDIS_STATUS
AtmLaneReconfigureHandler(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNET_PNP_EVENT			pNetPnPEvent
);

EXTERN
PATMLANE_ELAN
AtmLaneFindElan(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNDIS_STRING			pElanKey
);

EXTERN
VOID
AtmLaneConnectToServer(
	IN	PATMLANE_ELAN				pElan		LOCKIN NOLOCKOUT,
	IN	ULONG						ServerType,
	IN	BOOLEAN						UsePvc
);

EXTERN
VOID
AtmLaneInvalidateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneCloseVCsOnAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneGenerateMacAddr(
	PATMLANE_ELAN					pElan
);

EXTERN
PATMLANE_MAC_ENTRY
AtmLaneSearchForMacAddress(
	PATMLANE_ELAN					pElan,
	ULONG							pMacAddrType,
	PMAC_ADDRESS					pMacAddress,
	BOOLEAN							CreateNew
);

EXTERN
PATMLANE_ATM_ENTRY
AtmLaneSearchForAtmAddress(
	IN	PATMLANE_ELAN				pElan,
	IN	PUCHAR						pAtmAddress,
	IN	ULONG						Type,
	IN	BOOLEAN						CreateNew
);

EXTERN
ULONG
AtmLaneMacAddrEqual(
	PMAC_ADDRESS			pMacAddr1,
	PMAC_ADDRESS			pMacAddr2
);

EXTERN
VOID
AtmLaneAbortMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneMacEntryAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneArpTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneConfigureResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneJoinResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneInitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneReadyTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneFlushTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneVcAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneShutdownElan(
	IN	PATMLANE_ELAN				pElan		LOCKIN	NOLOCKOUT,
	IN	BOOLEAN						Restart
);

EXTERN
VOID
AtmLaneContinueShutdownElan(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneGetProtocolConfiguration(
	IN	NDIS_HANDLE				AdapterConfigHandle,
	IN	PATMLANE_ADAPTER		pAdapter
);


EXTERN
VOID
AtmLaneGetElanConfiguration(
	IN	NDIS_HANDLE				ElanConfigHandle,
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneQueueElanEventAfterDelay(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus,
	IN	ULONG					DelayMs
	);

EXTERN
VOID
AtmLaneQueueDelayedElanEvent(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					TimerContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
	);


EXTERN
VOID
AtmLaneQueueElanEvent(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus
);

EXTERN
PATMLANE_EVENT
AtmLaneDequeueElanEvent(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDrainElanEventQueue(
	IN	PATMLANE_ELAN			pElan
);


//
//  --------------- From miniport.c ----------------------------
//
#if 0
EXTERN VOID Miniport();
#endif

EXTERN
NDIS_STATUS 
AtmLaneMInitialize(
	OUT	PNDIS_STATUS			OpenErrorStatus,
	OUT	PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM				MediumArray,
	IN	UINT						MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
);

EXTERN
VOID
AtmLaneMSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT						NumberOfPackets
);

EXTERN
VOID
AtmLaneMReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET				Packet
);

EXTERN
NDIS_STATUS 
AtmLaneMQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID					Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesWritten,
	OUT	PULONG					BytesNeeded
);

EXTERN
NDIS_STATUS 
AtmLaneMSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID					Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
);

EXTERN
NDIS_STATUS 
AtmLaneMReset(
	OUT	PBOOLEAN 				AddressingReset,
	IN	NDIS_HANDLE 			MiniportAdapterContext
);

EXTERN
VOID 
AtmLaneMHalt(
	IN	NDIS_HANDLE MiniportAdapterContext
);

EXTERN
PNDIS_PACKET
AtmLaneWrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pSendNdisPacket,
	OUT	ULONG *					pMacAddrType,
	OUT	PMAC_ADDRESS			pMacAddress,
	OUT	BOOLEAN	*				pSendViaBUS
);

EXTERN
PNDIS_PACKET
AtmLaneUnwrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmLaneWrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pRecvNdisPacket,
	OUT	ULONG *					pMacHdrSize,
	OUT	ULONG *					pDestAddrType,					
	OUT	PMAC_ADDRESS			pDestAddr,
	OUT	BOOLEAN	*				pDestIsMulticast
)
;		

EXTERN
PNDIS_PACKET
AtmLaneUnwrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
NDIS_STATUS
AtmLaneMSetNetworkAddresses(
	IN	PATMLANE_ELAN			pElan,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
);

//
//  --------------- From space.c ----------------------------
//
#if 0
EXTERN VOID Space();
#endif

EXTERN	PATMLANE_GLOBALS	pAtmLaneGlobalInfo;
EXTERN 	ATM_ADDRESS 		gWellKnownLecsAddress;

EXTERN	ATM_ADDRESS 		gWellKnownLecsAddress;
EXTERN	MAC_ADDRESS			gMacBroadcastAddress;
EXTERN	ULONG				AtmLaneMaxTimerValue[];
EXTERN	ULONG				AtmLaneTimerListSize[];
EXTERN	ULONG				AtmLaneTimerPeriod[];

//
//  --------------- From utils.c ----------------------------
//
#if 0
EXTERN VOID Utils();
#endif

EXTERN
VOID
AtmLaneInitGlobals(
	VOID
);

EXTERN
PATMLANE_ADAPTER
AtmLaneAllocAdapter(
	IN	PNDIS_STRING		pDeviceName,
	IN	PVOID				SystemSpecific1
);

EXTERN
VOID
AtmLaneDeallocateAdapter(
	IN	PATMLANE_ADAPTER	pAdapter
);

EXTERN
BOOLEAN
AtmLaneReferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
);

EXTERN
ULONG
AtmLaneDereferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
);
	
EXTERN
NDIS_STATUS
AtmLaneAllocElan(
	IN		PATMLANE_ADAPTER	pAdapter,
	IN OUT	PATMLANE_ELAN		*ppElan
);

EXTERN
VOID
AtmLaneDeallocateElan(
	IN	PATMLANE_ELAN		pElan
);

EXTERN
VOID
AtmLaneReferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
);

EXTERN
ULONG
AtmLaneDereferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
);

EXTERN
VOID
AtmLaneUnlinkElanFromAdapter(
	IN	PATMLANE_ELAN		pElan
);

EXTERN
PATMLANE_ATM_ENTRY
AtmLaneAllocateAtmEntry(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmLaneReferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
);

EXTERN
PATMLANE_VC
AtmLaneAllocateVc(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneDeallocateVc(
	IN	PATMLANE_VC					pVc
);

EXTERN
VOID
AtmLaneReferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
);

EXTERN
PATMLANE_MAC_ENTRY
AtmLaneAllocateMacEntry(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneReferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
);

EXTERN
PNDIS_PACKET
AtmLaneAllocProtoPacket(
	IN	PATMLANE_ELAN			pElan
);

VOID
AtmLaneFreeProtoPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket
);

EXTERN
PNDIS_BUFFER
AtmLaneGrowHeaders(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocateHeader(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
);

EXTERN
VOID
AtmLaneFreeHeader(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
);

EXTERN
VOID
AtmLaneDeallocateHeaderBuffers(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneGrowPadBufs(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocatePadBuf(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
);

EXTERN
VOID
AtmLaneFreePadBuf(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
);

EXTERN
VOID
AtmLaneDeallocatePadBufs(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocateProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmLaneFreeProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer
);

EXTERN
NDIS_STATUS
AtmLaneInitProtoBuffers(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateProtoBuffers(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneLinkVcToAtmEntry(
	IN	PATMLANE_VC					pVc,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ServerIncoming
);

EXTERN
BOOLEAN
AtmLaneUnlinkVcFromAtmEntry(
	IN	PATMLANE_VC					pVc
);

EXTERN
BOOLEAN
AtmLaneUnlinkMacEntryFromAtmEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneStartTimer(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_TIMER				pTimer,
	IN	ATMLANE_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						ContextPtr
);

EXTERN
BOOLEAN
AtmLaneStopTimer(
	IN	PATMLANE_TIMER			pTimer,
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneRefreshTimer(
	IN	PATMLANE_TIMER				pTimer
);

EXTERN
VOID
AtmLaneTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
ULONG
AtmLaneSystemTimeMs(
	void
);

EXTERN
VOID
AtmLaneBitSwapMacAddr(
	IN OUT	PUCHAR		ap
);

EXTERN
BOOLEAN
AtmLaneCopyUnicodeString(
	IN OUT	PUNICODE_STRING pDestString,
	IN OUT	PUNICODE_STRING pSrcString,
	IN		BOOLEAN			AllocDest,
	IN		BOOLEAN			ConvertToUpper
);

EXTERN
PWSTR
AtmLaneStrTok(
	IN	PWSTR	StrToken,
	IN	WCHAR	ChrDelim,
	OUT	PUSHORT	pStrLength
);

#endif	//	__ATMLANE_EXTERNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\ioctl.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	IOCTL Handler functions

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Notes:

--*/
#include <precomp.h>


PATMLANE_ADAPTER
AtmLaneIoctlNameToAdapter(
	IN	PUNICODE_STRING		pDeviceName
)
/*++

Routine Description:

	Given the name of an adapter, return a pointer to the corresponding
	adapter structure if one exists, else NULL.

	This routine also references the adapter.

Arguments:

	pDeviceName	- Pointer to Device name we are searching for.

Return Value:

	See above.

--*/
{
	PLIST_ENTRY				pListEntry;
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ADAPTER		pAdapterToReturn = NULL_PATMLANE_ADAPTER;
	BOOLEAN                 bReferenced = FALSE;

	TRACEIN(IoctlNameToAdapter);

	// fixup the Buffer pointer
	
	pDeviceName->Buffer = (PWSTR)((PUCHAR)pDeviceName + sizeof(UNICODE_STRING));
	

	// loop thru the adapters looking for the ELAN

	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
		 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
		 pListEntry = pListEntry->Flink)
	{
		// get pointer to Adapter
	
		pAdapter = CONTAINING_RECORD(pListEntry, ATMLANE_ADAPTER, Link);
		STRUCT_ASSERT(pAdapter, atmlane_adapter);
		
		// compare length first and then actual names

		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			// match - return this adapter
		
			pAdapterToReturn = pAdapter;

			ACQUIRE_ADAPTER_LOCK_DPC(pAdapter);
			bReferenced = AtmLaneReferenceAdapter(pAdapter, "ioctl");
			RELEASE_ADAPTER_LOCK_DPC(pAdapter);

			break;
		}
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	TRACEOUT(IoctlNameToAdapter);
	return (bReferenced? pAdapterToReturn: NULL);
}


PATMLANE_ELAN
AtmLaneIoctlNameToElan(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	UNICODE_STRING UNALIGNED *		pDeviceName
)
/*++

Routine Description:

	Given a pointer to an adapter data structure and an 
	ELAN device name, return a pointer to the corresponding
	ELAN structure if one exists, else NULL.

	This also references the ELAN structure.

Arguments:
	pAdapter	- Pointer to Adapter data structure.
	pDeviceName	- Pointer to Device name we are searching for.

Return Value:

	See above.

--*/
{
	PLIST_ENTRY				pListEntry;
	PATMLANE_ELAN			pElan;
	PATMLANE_ELAN			pElanToReturn = NULL_PATMLANE_ELAN;

	TRACEIN(IoctlNameToElan);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	// fixup the Buffer pointer

	pDeviceName->Buffer = (PWSTR)((PUCHAR)pDeviceName + sizeof(UNICODE_STRING));
	
	ACQUIRE_ADAPTER_LOCK(pAdapter);

	// loop thru the ELANs looking for the given name

	for (pListEntry = pAdapter->ElanList.Flink;
		 pListEntry != &(pAdapter->ElanList);
		 pListEntry = pListEntry->Flink)
	{
		// get pointer to ELAN
	
		pElan = CONTAINING_RECORD(pListEntry, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		// compare length first and then actual names

		if ((pDeviceName->Length == pElan->CfgDeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pElan->CfgDeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			// match - return this ELAN
		
			pElanToReturn = pElan;

			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneReferenceElan(pElan, "iocnametoelan");
			RELEASE_ELAN_LOCK(pElan);

			break;
		}
	}
	
	RELEASE_ADAPTER_LOCK(pAdapter);

	TRACEOUT(IoctlNameToElan);

	return (pElanToReturn);
}

NTSTATUS
AtmLaneIoctlGetInfoVersion (
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return the version number of the information exported by
	these ioctl codes. 
	
Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	NTSTATUS			Status;
	
	TRACEIN(IoctlGetInfoVersion);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;

	do
	{
		//	check for enough output space

		if (OutputBufferLength < sizeof(ULONG))
		{
			Status =  STATUS_BUFFER_OVERFLOW;
			break;
		}

		//	output the version

		*((PULONG)pBuffer) = ATMLANE_INFO_VERSION;
		
		*pBytesWritten = sizeof(ULONG);
	}
	while (FALSE);

	TRACEOUT(IoctlGetInfoVersion);

	return STATUS_SUCCESS;
}

NTSTATUS
AtmLaneIoctlEnumerateAdapters (
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return a list of adapters bound to the AtmLane protocol.
	We go through the list of Adapter structures and concatenate the
	device names stored in each into the output buffer.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	UINT					Remaining;
	PATMLANE_ADAPTER_LIST	pAdapterList;
	PUNICODE_STRING			pAdapterName;
	NTSTATUS				Status;
	PLIST_ENTRY				pListEntry;

	TRACEIN(IoctlEnumAdapters);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;

	do
	{
		//	check for minimal output space

		Remaining = OutputBufferLength;
		if (Remaining < sizeof(ATMLANE_ADAPTER_LIST))
		{
			Status =  STATUS_BUFFER_OVERFLOW;
			break;
		}

		pAdapterList = (PATMLANE_ADAPTER_LIST)pBuffer;

		//	setup to return empty list

		pAdapterList->AdapterCountReturned = 0;
		*pBytesWritten = FIELD_OFFSET(ATMLANE_ADAPTER_LIST, AdapterList);
		pAdapterName = &pAdapterList->AdapterList;

		//  adjust space for output
		Remaining -= FIELD_OFFSET (ATMLANE_ADAPTER_LIST, AdapterList);

		//	loop thru the adapters

		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
		for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
			 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
			 pListEntry = pListEntry->Flink)
		{
			//	get pointer to adapter struct
	
			pAdapter = CONTAINING_RECORD(pListEntry, ATMLANE_ADAPTER, Link);
			STRUCT_ASSERT(pAdapter, atmlane_adapter);

			//	quit loop if no more space

			if (Remaining < sizeof(NDIS_STRING) + pAdapter->DeviceName.Length)
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	count and copy the adapter name

			pAdapterList->AdapterCountReturned++;
			pAdapterName->Buffer = (PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING));
			memcpy(pAdapterName->Buffer, pAdapter->DeviceName.Buffer, pAdapter->DeviceName.Length);
			pAdapterName->MaximumLength = pAdapterName->Length = pAdapter->DeviceName.Length;

			//  convert the Buffer pointer to an offset - caller expects it

			pAdapterName->Buffer = (PWSTR)((PUCHAR)pAdapterName->Buffer - (PUCHAR)pAdapterList);

			//	move ptr past the name we just copied

			pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)
							+ pAdapter->DeviceName.Length);

			//	update bytes written and remaining space

			*pBytesWritten += sizeof(UNICODE_STRING) + pAdapter->DeviceName.Length;
			Remaining -= sizeof(UNICODE_STRING) + pAdapter->DeviceName.Length;
		}
	

		//	check count available same as count returned

		pAdapterList->AdapterCountAvailable = pAdapterList->AdapterCountReturned;

		//	count any remaining adapters that there wasn't space for

		while (pListEntry != &(pAtmLaneGlobalInfo->AdapterList))
		{
			pAdapterList->AdapterCountAvailable++;
			pListEntry = pListEntry->Flink;
		}

		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	} while (FALSE);
	
	TRACEOUT(IoctlEnumerateAdapters);
				
	return (Status);

}


NTSTATUS
AtmLaneIoctlEnumerateElans(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return a list of adapters bound to the AtmLane protocol.
	We go through the list of Adapter structures and concatenate the
	device names stored in each into the output buffer.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	UINT					Remaining;
	PATMLANE_ELAN_LIST		pElanList;
	PUNICODE_STRING			pElanName;
	NTSTATUS				Status;
	PATMLANE_ELAN			pElan;
	PLIST_ENTRY				pListEntry;
	ULONG					rc;

	TRACEIN(IoctlEnumerateElans);

	// init
	
	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;

	do
	{
		//	check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + ((PUNICODE_STRING)pBuffer)->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//	get the adapter struct from the name
	
		pAdapter = AtmLaneIoctlNameToAdapter((PUNICODE_STRING)pBuffer);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	check for minimal output space

		Remaining = OutputBufferLength;
		if (Remaining < sizeof(ATMLANE_ELAN_LIST))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		pElanList = (PATMLANE_ELAN_LIST)pBuffer;

		//	setup to return empty list
	
		pElanList->ElanCountReturned = 0;
		*pBytesWritten = FIELD_OFFSET(ATMLANE_ELAN_LIST, ElanList);
		Remaining -= FIELD_OFFSET(ATMLANE_ELAN_LIST, ElanList);

		pElanName = &pElanList->ElanList;

		//	loop thru the Elans

		ACQUIRE_ADAPTER_LOCK(pAdapter);
	
		for (pListEntry = pAdapter->ElanList.Flink;
		 	pListEntry != &(pAdapter->ElanList);
		 	pListEntry = pListEntry->Flink)
		{
			//	get pointer to adapter struct
	
			pElan = CONTAINING_RECORD(pListEntry, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);

			//	quit loop if no more space

			if (Remaining < sizeof(NDIS_STRING) + pElan->CfgDeviceName.Length)
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	count and copy the adapter name

			pElanList->ElanCountReturned++;
			pElanName->Buffer = (PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING));
			memcpy(pElanName->Buffer, pElan->CfgDeviceName.Buffer, pElan->CfgDeviceName.Length);
			pElanName->MaximumLength = pElanName->Length = pElan->CfgDeviceName.Length;

			//  convert the Buffer pointer to an offset - caller expects it

			pElanName->Buffer = (PWSTR)((PUCHAR)pElanName->Buffer - (PUCHAR)pElanList);

			//	move ptr past the name we just copied

			pElanName = (PUNICODE_STRING)((PUCHAR)pElanName + sizeof(UNICODE_STRING)
							+ pElan->CfgDeviceName.Length);

			//	update bytes written and remaining space

			*pBytesWritten += (sizeof(UNICODE_STRING) + pElan->CfgDeviceName.Length);
			Remaining -= sizeof(UNICODE_STRING) + pElan->CfgDeviceName.Length;
		}

		//	set count available same as count returned

		pElanList->ElanCountAvailable = pElanList->ElanCountReturned;

		//	count any remaining adapters that there wasn't space for

		while (pListEntry != &(pAdapter->ElanList))
		{
			pElanList->ElanCountAvailable++;
			pListEntry = pListEntry->Flink;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

	} while (FALSE);
	
	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: enumelans");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlEnumerateElans);

	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanInfo(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the state information about a specific Elan.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status Code

--*/
{
	PATMLANE_ADAPTER					pAdapter;
	PATMLANE_ELAN						pElan;
	PUNICODE_STRING						pAdapterNameIn;
	PUNICODE_STRING						pElanNameIn;
	PATMLANE_ELANINFO					pElanInfo;
	NTSTATUS							Status;
	ULONG								rc;

	TRACEIN(IoctlGetElanInfo);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
	
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < ((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if minimal output space

		if (OutputBufferLength < sizeof(ATMLANE_ELANINFO))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct - check the lengths passed in first.

		InputBufferLength -= (sizeof(UNICODE_STRING) + pAdapterNameIn->MaximumLength);

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + pElanNameIn->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (pElanNameIn->MaximumLength < pElanNameIn->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// setup to fill in ELAN info

		pElanInfo = (PATMLANE_ELANINFO)pBuffer;
	
		NdisZeroMemory(pElanInfo, sizeof(ATMLANE_ELANINFO));
			
		ACQUIRE_ELAN_LOCK(pElan);

		pElanInfo->ElanNumber 			= pElan->ElanNumber;
		pElanInfo->ElanState			= pElan->State;
		NdisMoveMemory(
			&pElanInfo->AtmAddress,	
			&pElan->AtmAddress.Address,
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->LecsAddress, 
			&pElan->LecsAddress.Address, 
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->LesAddress,	
			&pElan->LesAddress.Address,	 
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->BusAddress,	
			&pElan->BusAddress.Address,	 
			ATM_ADDRESS_LENGTH);
		pElanInfo->LanType				= pElan->LanType;
		pElanInfo->MaxFrameSizeCode 	= pElan->MaxFrameSizeCode;
		pElanInfo->LecId				= SWAPUSHORT(pElan->LecId);
		NdisMoveMemory(
			pElanInfo->ElanName,	
			pElan->ElanName, 
			pElan->ElanNameSize);
		if (pElan->LanType == LANE_LANTYPE_TR)
		{
			NdisMoveMemory(
				&pElanInfo->MacAddress, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS));
		}
		else
		{
			NdisMoveMemory(
				&pElanInfo->MacAddress, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS));
		}
		pElanInfo->ControlTimeout		= pElan->ControlTimeout;
		pElanInfo->MaxUnkFrameCount 	= pElan->MaxUnkFrameCount;
		pElanInfo->MaxUnkFrameTime		= pElan->MaxUnkFrameTime;
		pElanInfo->VccTimeout			= pElan->VccTimeout;
		pElanInfo->MaxRetryCount		= pElan->MaxRetryCount;
		pElanInfo->AgingTime			= pElan->AgingTime;
		pElanInfo->ForwardDelayTime 	= pElan->ForwardDelayTime;
		pElanInfo->TopologyChange 		= pElan->TopologyChange;
		pElanInfo->ArpResponseTime		= pElan->ArpResponseTime;
		pElanInfo->FlushTimeout			= pElan->FlushTimeout;
		pElanInfo->PathSwitchingDelay 	= pElan->PathSwitchingDelay;
		pElanInfo->LocalSegmentId		= pElan->LocalSegmentId;		
		pElanInfo->McastSendVcType		= pElan->McastSendVcType;	
		pElanInfo->McastSendVcAvgRate	= pElan->McastSendVcAvgRate; 
		pElanInfo->McastSendVcPeakRate	= pElan->McastSendVcPeakRate;
		pElanInfo->ConnComplTimer		= pElan->ConnComplTimer;
	
		RELEASE_ELAN_LOCK(pElan);

		*pBytesWritten = sizeof(ATMLANE_ELANINFO);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelaninfo");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelaninfo");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanInfo);
	
	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanArpTable(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the ARP table for the specified ELAN.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:
	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PUNICODE_STRING			pAdapterNameIn;
	PUNICODE_STRING			pElanNameIn;
	PATMLANE_ARPTABLE		pArpTable;
	PATMLANE_ARPENTRY		pArpEntry;
	UINT					Remaining;
	PATMLANE_MAC_ENTRY		pMacEntry;
	NTSTATUS				Status;
	UINT					i;
	ULONG					rc;

	TRACEIN(IoctlGetElanArpTable);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// sanity check the unicode string fields.
		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < (((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength)))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		// check if minimum output space

		if (OutputBufferLength < sizeof(ATMLANE_ARPTABLE))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	setup to return empty list

		pArpTable = (PATMLANE_ARPTABLE)pBuffer;
		pArpTable->ArpEntriesAvailable = pElan->NumMacEntries;
		pArpTable->ArpEntriesReturned = 0;
		*pBytesWritten = sizeof(ATMLANE_ARPTABLE);
		Remaining = OutputBufferLength - sizeof(ATMLANE_ARPTABLE);
	
		pArpEntry = (PATMLANE_ARPENTRY)(pBuffer + sizeof(ATMLANE_ARPTABLE));
	
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);

		//	loop thru array of lists
	
		for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
		{
			pMacEntry = pElan->pMacTable[i];

			while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{

				//	check if enough space remaining

				if (Remaining < sizeof(ATMLANE_ARPENTRY))
				{
					Status = STATUS_BUFFER_OVERFLOW;
					break;
				}

				// 	output the entry

				NdisZeroMemory(pArpEntry, sizeof(ATMLANE_ARPENTRY));

				NdisMoveMemory(
					pArpEntry->MacAddress, 
					&pMacEntry->MacAddress, 
					sizeof(MAC_ADDRESS));

				if (pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
				{
					NdisMoveMemory(
						pArpEntry->AtmAddress,
						pMacEntry->pAtmEntry->AtmAddress.Address,
						ATM_ADDRESS_LENGTH);
				}

				//	update space used and space remaining

				*pBytesWritten += sizeof(ATMLANE_ARPENTRY);
				Remaining -= sizeof(ATMLANE_ARPENTRY);

				// 	increment in and out pointers
				
				pArpEntry++;
				pMacEntry = pMacEntry->pNextEntry;

				// 	add one to EntriesReturned
				
				pArpTable->ArpEntriesReturned++;
				
			}
		}
			
		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelanarp");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelanarp");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanArpTable);

	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanConnectTable(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the Connection table for the specified ELAN.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:
	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PUNICODE_STRING			pAdapterNameIn;
	PUNICODE_STRING			pElanNameIn;
	PATMLANE_CONNECTTABLE	pConnTable;
	PATMLANE_CONNECTENTRY	pConnEntry;
	UINT					Remaining;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	NTSTATUS				Status;
	ULONG					rc;

	TRACEIN(IoctlGetElanConnectTable);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < (((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength)))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if minimum output space

		if (OutputBufferLength < sizeof(ATMLANE_CONNECTTABLE))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// How much of the input buffer do we have left?
		InputBufferLength -= (sizeof(UNICODE_STRING) + pAdapterNameIn->MaximumLength);

		// validate the ELAN name buffer
		if (pElanNameIn->MaximumLength < pElanNameIn->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + pElanNameIn->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	setup to return empty list

		pConnTable = (PATMLANE_CONNECTTABLE)pBuffer;
		pConnTable->ConnectEntriesAvailable = pElan->NumAtmEntries;
		pConnTable->ConnectEntriesReturned = 0;
		*pBytesWritten = sizeof(ATMLANE_CONNECTTABLE);
		Remaining = OutputBufferLength - sizeof(ATMLANE_CONNECTTABLE);
	
		pConnEntry = 
			(PATMLANE_CONNECTENTRY)(pBuffer + sizeof(ATMLANE_CONNECTTABLE));
	
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		//	loop thru the list
		
		pAtmEntry = pElan->pAtmEntryList;

		while (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{

			//	check if enough space for another entry
	
			if (Remaining < sizeof(ATMLANE_CONNECTENTRY))
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	fill in entry
		
			NdisMoveMemory(
				pConnEntry->AtmAddress, 
				&pAtmEntry->AtmAddress.Address,
				ATM_ADDRESS_LENGTH
				);
			pConnEntry->Type = pAtmEntry->Type;
			pConnEntry->Vc = (pAtmEntry->pVcList!=NULL_PATMLANE_VC);
			pConnEntry->VcIncoming = (pAtmEntry->pVcIncoming!=NULL_PATMLANE_VC);

			// 	update space used and space remaining

			*pBytesWritten += sizeof(ATMLANE_CONNECTENTRY);
			Remaining -= sizeof(ATMLANE_CONNECTENTRY);
			
			//	increment in and out pointers

			pConnEntry++;
			pAtmEntry = pAtmEntry->pNext;

			// 	add one to EntriesReturned

			pConnTable->ConnectEntriesReturned++;
		}

		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelanconntab");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelanconntab");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanConnectTable);

	return (Status);
}


NTSTATUS
AtmLaneIoctlRequest(
	IN	PIRP					pIrp
)
/*++

Routine Description:

	Starting point for all IOCTL Requests.

Arguments:

	pIrp			: Pointer to the IRP
	pHandled		: If request handled TRUE otherwise FALSE

Return Value:

	Status of the request

--*/
{
	NTSTATUS            Status = STATUS_SUCCESS;
	PUCHAR				pBuf;
	UINT				BufLen;
	UINT				OutBufLen;
	UNICODE_STRING		IfName;
    PIO_STACK_LOCATION 	pIrpSp;

	TRACEIN(IoctlRequest);
	
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
		case ATMLANE_IOCTL_GET_INFO_VERSION:
			DBGP((3, "IoctlRequest: Get Info Version\n"));

			Status = AtmLaneIoctlGetInfoVersion(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
	
		case ATMLANE_IOCTL_ENUM_ADAPTERS:

			DBGP((3, "IoctlRequest: Enum Adapters\n"));
		
			Status = AtmLaneIoctlEnumerateAdapters(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
			
		case ATMLANE_IOCTL_ENUM_ELANS:

			DBGP((3, "IoctlRequest: Enum ELANs\n"));
		
			Status = AtmLaneIoctlEnumerateElans(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_INFO:

			DBGP((3, "IoctlRequest: Get ELAN Info\n"));
		
			Status = AtmLaneIoctlGetElanInfo(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_ARP_TABLE:

			DBGP((3, "IoctlRequest: Getl ELAN ARP table\n"));
		
			Status = AtmLaneIoctlGetElanArpTable(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_CONNECT_TABLE:

			DBGP((3, "IoctlRequest: Get ELAN Connection table\n"));
		
			Status = AtmLaneIoctlGetElanConnectTable(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		default:
		
			DBGP((0, "IoctlRequest: Unknown control code %x\n", 
				pIrpSp->Parameters.DeviceIoControl.IoControlCode));
			break;
	}
	
	TRACEOUT(IoctlRequest);

	return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\elanpkt.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	elanpkt.c

Abstract:

Revision History:

Notes:

--*/

#include <precomp.h>
#pragma	hdrstop


VOID
AtmLaneSendConfigureRequest(
	IN PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Send an LE_CONFIGURE_REQUEST for the given ELAN to the LECS.
	It is assumed that caller holds a lock on the ELAN structure
	and it will be released here.

Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;	
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;		
	LANE_CONTROL_FRAME UNALIGNED *	pCf;	
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;

	DBGP((3, "SendConfigureRequest: Elan %x\n", pElan));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLecsAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendConfigureRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendConfigureRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_CONFIGURE_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_CONFIGURE_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->SourceMacAddress.Type = LANE_MACADDRTYPE_MACADDR;

		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS)
				);
		}
		else
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS)
				);
		}
		
		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		DBGP((4, "%d: sending Config Req, Elan %x has LanType %d, CfgLanType %d\n",
				pElan->ElanNumber,
				pElan,
				pElan->LanType,
				pElan->CfgLanType));

		pCf->LanType = LANE_LANTYPE_UNSPEC;
		pCf->MaxFrameSize = (UCHAR) pElan->CfgMaxFrameSizeCode;

		pCf->ElanNameSize = pElan->ElanNameSize;
		NdisMoveMemory(
			&pCf->ElanName,
			pElan->ElanName,
			LANE_ELANNAME_SIZE_MAX
			);

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendConfigureRequest);
	return;
}


VOID
AtmLaneSendJoinRequest(
	IN PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Send an LE_JOIN_REQUEST for the given ELAN to the LES.
	It is assumed that caller holds a lock on the ELAN structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;
	LANE_CONTROL_FRAME UNALIGNED *	pCf;	
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;
	
	TRACEIN(SendJoinRequest);

	DBGP((3, "SendJoinRequest: Elan %x\n", pElan));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendJoinRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendJoinRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_JOIN_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_JOIN_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->SourceMacAddress.Type = LANE_MACADDRTYPE_MACADDR;
		
		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS)
				);
		}
		else
		{
			DBGP((0, "%d Send Join with MAC addr: %s\n",
					pElan->ElanNumber,
					MacAddrToString(&pElan->MacAddressEth)));

			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS)
				);
		}

		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		pCf->LanType = pElan->LanType;
		pCf->MaxFrameSize = pElan->MaxFrameSizeCode;

		pCf->ElanNameSize = pElan->ElanNameSize;
		NdisMoveMemory(
			&pCf->ElanName,
			pElan->ElanName,
			LANE_ELANNAME_SIZE_MAX
			);

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendJoinRequest);
	return;
}


VOID
AtmLaneSendArpRequest(
	IN PATMLANE_ELAN					pElan,
	IN PATMLANE_MAC_ENTRY				pMacEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Send an LE_ARP_REQUEST for a particular Mac Entry to the LES.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pMacEntry				- Pointer to ATMLANE Mac Entry for which
							  to send the LE_ARP_REQUEST.

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;
	LANE_CONTROL_FRAME UNALIGNED *	pCf;
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;
	BOOLEAN							MacEntryLockReleased;
	
	TRACEIN(SendArpRequest);

	DBGP((3, "SendArpRequest: Elan %x MacEntry %x\n", 
		pElan, pMacEntry));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	MacEntryLockReleased = FALSE;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendArpRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendArpRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_ARP_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_ARP_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);
		pCf->LecId		= pElan->LecId;		// already swapped
		
		//
		//	Leave SourceMacAddress zero (not present).
		// 	TargetMacAddress is what we are looking for!
		//
		pCf->TargetMacAddress.Type = (USHORT) pMacEntry->MacAddrType;
		NdisMoveMemory(
			&pCf->TargetMacAddress.Byte, 
			&pMacEntry->MacAddress, 
			sizeof(MAC_ADDRESS)
			);

		//
		//	SourceAtmAddr is the Elan's
		//
		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		//
		//	Store swapped Tid in MacEntry for later matching!
		//
		pMacEntry->ArpTid = SWAPULONG(ulTemp);
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		MacEntryLockReleased = TRUE;
		
		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			DBGP((2, "SendArpRequest: %s Sending ARP Request: Atm Entry %x pVc %x\n", 
					MacAddrToString(&pMacEntry->MacAddress), pAtmEntry, pVc));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);
	
	if (!MacEntryLockReleased)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}
	
	TRACEOUT(SendArpRequest);
	return;
}

VOID
AtmLaneSendReadyQuery(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Sends a READY_QUERY frame on the VC.
	It is assumed that caller holds a lock on the VC structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	pVc						- Pointer to the ATMLANE VC structure
							  on which to send the frame.
Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pQueryRf;
	NDIS_STATUS				Status;

	TRACEIN(SendReadyQuery);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do
	{
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendReadyQuery: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_READY_FRAME),
								&((PUCHAR)(pQueryRf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendReadyQuery: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Indication
		//
		pQueryRf->Marker 		= LANE_CONTROL_MARKER;
		pQueryRf->Protocol		= LANE_PROTOCOL;
		pQueryRf->Version		= LANE_VERSION;
		pQueryRf->OpCode		= LANE_READY_QUERY;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			//
			//	Send it 
			//
			DBGP((2, "SendReadyQuery: pVc %x sending READY QUERY\n", pVc));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
			ASSERT(Status == NDIS_STATUS_SUCCESS);
		}
		else
		{
			//
			//  The VC is being torn down.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		break;
	}
	while (FALSE);

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		RELEASE_VC_LOCK(pVc);
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendReadyQuery);

	return;
}


VOID
AtmLaneSendReadyIndication(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Sends a ready indication frame on the VC.
	It is assumed that caller holds a lock on the VC structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	pVc						- Pointer to the ATMLANE VC structure
							  on which to send the frame.
							  
Return Value:

	None

--*/
{
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pIndRf;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;

	TRACEIN(SendReadyIndication);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do
	{
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendReadyIndication: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_READY_FRAME),
								&((PUCHAR)(pIndRf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendReadyIndication: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Indication
		//
		pIndRf->Marker 		= LANE_CONTROL_MARKER;
		pIndRf->Protocol	= LANE_PROTOCOL;
		pIndRf->Version		= LANE_VERSION;
		pIndRf->OpCode		= LANE_READY_IND;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			//
			//	Send it 
			//
			DBGP((2, "SendReadyIndication: pVc %x sending READY INDICATION\n", pVc));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
			ASSERT(Status == NDIS_STATUS_SUCCESS);
		}
		else
		{
			//
			//  The VC is being torn down.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}
			
		break;
	}
	while (FALSE);

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		RELEASE_VC_LOCK(pVc);
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendReadyIndication);

	return;
}


VOID
AtmLaneSendFlushRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT,
	IN PATMLANE_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Sends a flush request to the BUS for a particular MAC Entry
	using the destination ATM address in the specified ATM Entry.
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure
	pMacEntry				- Pointer to ATMLANE Mac entry structure
	pAtmEntry				- Pointer to ATMLANE Atm entry structure
							  
Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pBusAtmEntry;
	PATMLANE_VC				pVc;
	ULONG					TotalLength;
	ULONG					BufferLength;
	ULONG					ulTemp;
	PLANE_CONTROL_FRAME		pCf;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					rc;
	BOOLEAN					MacEntryLockReleased;

	TRACEIN(SendFlushRequest);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	MacEntryLockReleased = FALSE;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pBusAtmEntry = pElan->pBusAtmEntry;

		if (pBusAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
		pVc = pBusAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendFlushRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_CONTROL_FRAME),
								&((PUCHAR)(pCf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendFlushRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Flush Request
		//

		NdisZeroMemory((PUCHAR)pCf, sizeof(LANE_CONTROL_FRAME));
		
		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode		= LANE_FLUSH_REQUEST;

		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->LecId		= pElan->LecId;		// already swapped

		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		NdisMoveMemory(
			&pCf->TargetAtmAddr, 
			&pAtmEntry->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		//
		//	Store swapped Tid in MacEntry for later matching!
		//
		pMacEntry->FlushTid = SWAPULONG(ulTemp);
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		MacEntryLockReleased = TRUE;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			DBGP((2, "SendFlushRequest: sending FLUSH REQUEST for MacEntry %x\n", pMacEntry));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}

 		break;
	}
	while (FALSE);

	if (!MacEntryLockReleased)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendFlushRequest);

	return;
}


VOID
AtmLaneConfigureResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the Configuration Direct VC.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pCf;
	ULONG					NumTlvs;
	ULONG UNALIGNED *		pType;
	PUCHAR					pLength;
	USHORT UNALIGNED *		pUShort;
	ULONG UNALIGNED *		pULong;
	NDIS_STATUS				EventCode;
	USHORT					NumStrings;
	PWCHAR					StringList[2];
	BOOLEAN					FreeString[2];
	
	
	TRACEIN(ConfigureResponseHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pNdisBuffer, 
				(PVOID *)&pCf,
				&BufferLength,
				&TotalLength);

		//
		//	Packet must be at least the size of a control frame.
		//	Could be larger with optional TLVs.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"ConfigureResponseHandler: Received runt control frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "ConfigureResponseHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a configure reponse
		//
		if (pCf->Marker != LANE_CONTROL_MARKER 		||
			pCf->Protocol != LANE_PROTOCOL 			||
			pCf->Version != LANE_VERSION			||
			pCf->OpCode != LANE_CONFIGURE_RESPONSE)
		{
			DBGP((0, "ConfigureResponseHandler: Not a configure response\n"));
			//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);
			break;
		}
		
		//
		//	Check for successful configure status
		//
		if (pCf->Status != LANE_STATUS_SUCCESS)
		{
			//
			//	Failure
			//		
			DBGP((0,
				"ConfigureResponseHandler: Unsuccessful Status 0x%x (%d)\n", 
				SWAPUSHORT(pCf->Status), SWAPUSHORT(pCf->Status)));


			//
			//	Setup to log event
			//
			StringList[0] = NULL;
			FreeString[0] = FALSE;
			StringList[1] = NULL;
			FreeString[1] = FALSE;
			
			switch (pCf->Status)
			{
				case LANE_STATUS_VERSNOSUPP:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
		
				case LANE_STATUS_REQPARMINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_INSUFFRES:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_NOACCESS:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_REQIDINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_LANDESTINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
				
				case LANE_STATUS_ATMADDRINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
				
				case LANE_STATUS_NOCONF:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_NOCONF;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_CONFERROR:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_INSUFFINFO:
				default:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
			}						

			//
			//	If not repeated event on this ELAN write the event to log
			//
			if (pElan->LastEventCode != EventCode)
			{
				pElan->LastEventCode = EventCode;
				(VOID) NdisWriteEventLogEntry(
						pAtmLaneGlobalInfo->pDriverObject,
						EventCode, 0, NumStrings, StringList, 0, NULL);
			}

			//
			//	Free any strings allocated
			//
			if (FreeString[0] && StringList[0] != NULL)
			{
				FREE_MEM(StringList[0]);
			}
			if (FreeString[1] && StringList[1] != NULL)
			{
				FREE_MEM(StringList[1]);
			}
			
			//
			//	Notify event handler of failure
			//
			ACQUIRE_ELAN_LOCK(pElan);
			
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_FAILURE);

			RELEASE_ELAN_LOCK(pElan);
			
			break;
		}

		//
		//	Successful Configure Response
		//
		//
		//	Extract the required Elan parameters
		//
		ACQUIRE_ELAN_LOCK(pElan);
		
		pElan->LanType = pCf->LanType;
		DBGP((1, "%d LanType = %x\n", pElan->ElanNumber, pElan->LanType));
		if (pElan->LanType == LANE_LANTYPE_UNSPEC)
		{
			DBGP((1, "Defaulting to LanType 1 (Ethernet/802.3)\n"));
			pElan->LanType = LANE_LANTYPE_ETH;
		}
		pElan->MaxFrameSizeCode = pCf->MaxFrameSize;
		DBGP((1, "%d MaxFrameSizeCode = %x\n", pElan->ElanNumber, pElan->MaxFrameSizeCode));
		if (pElan->MaxFrameSizeCode == LANE_MAXFRAMESIZE_CODE_UNSPEC)
		{
			DBGP((1, "Defaulting to MaxFrameSizeCode 1 (1516)\n"));
			pElan->MaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_1516;
		}
		switch (pElan->MaxFrameSizeCode)
		{
			case LANE_MAXFRAMESIZE_CODE_18190:
				pElan->MaxFrameSize = 18190;
				break;
			case LANE_MAXFRAMESIZE_CODE_9234:
				pElan->MaxFrameSize = 9234;
				break;
			case LANE_MAXFRAMESIZE_CODE_4544:
				pElan->MaxFrameSize = 4544;
				break;
			case LANE_MAXFRAMESIZE_CODE_1516:
			case LANE_MAXFRAMESIZE_CODE_UNSPEC:
			default:
				pElan->MaxFrameSize = 1516;
				break;
		}				

		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			pElan->MinFrameSize = LANE_MIN_ETHPACKET;
		}
		else
		{
			pElan->MinFrameSize = LANE_MIN_TRPACKET;
		}

		NdisZeroMemory(
				pElan->ElanName,
				LANE_ELANNAME_SIZE_MAX);
		NdisMoveMemory(
				pElan->ElanName,
				pCf->ElanName,
				pCf->ElanNameSize);
		pElan->ElanNameSize = pCf->ElanNameSize;
		
		pElan->LesAddress.AddressType = ATM_NSAP;
		pElan->LesAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
		NdisMoveMemory(
				pElan->LesAddress.Address,
				&pCf->TargetAtmAddr,
				ATM_ADDRESS_LENGTH);
		DBGP((1, "%d LES ATMAddr: %s\n",
			pElan->ElanNumber,
			AtmAddrToString(pElan->LesAddress.Address)));
	
		//
		//	Check for TLVs
		//
		if (pCf->NumTlvs > 0)
		{
			DBGP((2, "ConfigureReponseHandler: NumTlvs is %d\n", pCf->NumTlvs));

			NumTlvs = pCf->NumTlvs;
			
			pType = (ULONG UNALIGNED *)
				(((PUCHAR)pCf) + sizeof(LANE_CONTROL_FRAME));
			
			while (NumTlvs--)
			{
				pLength = (PUCHAR)pType + sizeof(*pType);
				pUShort = (USHORT UNALIGNED *)
					(((PUCHAR)pLength) + sizeof(*pLength));
				pULong = (ULONG UNALIGNED *)
					(((PUCHAR)pLength) + sizeof(*pLength));

				switch (*pType)
				{
					case LANE_CFG_CONTROL_TIMEOUT:			// C7
						pElan->ControlTimeout = SWAPUSHORT(*pUShort);
						if (pElan->ControlTimeout < LANE_C7_MIN || 
							pElan->ControlTimeout > LANE_C7_MAX)
							pElan->ControlTimeout = LANE_C7_DEF;
						DBGP((1, "%d Control Time-out %d\n",
							pElan->ElanNumber,
							pElan->ControlTimeout));
						break;
					case LANE_CFG_UNK_FRAME_COUNT:			// C10
						pElan->MaxUnkFrameCount = SWAPUSHORT(*pUShort);
						if (pElan->MaxUnkFrameCount < LANE_C10_MIN || 
							pElan->MaxUnkFrameCount > LANE_C10_MAX)
							pElan->MaxUnkFrameCount = LANE_C10_DEF;
						DBGP((1, "%d Maximum Unknown Frame Count %d\n",
							pElan->ElanNumber,
							pElan->MaxUnkFrameCount));
						break;
					case LANE_CFG_UNK_FRAME_TIME:			// C11
						pElan->MaxUnkFrameTime = SWAPUSHORT(*pUShort);
						if (pElan->MaxUnkFrameTime < LANE_C11_MIN || 
							pElan->MaxUnkFrameTime > LANE_C11_MAX)
							pElan->MaxUnkFrameTime = LANE_C11_DEF;
						DBGP((1, "%d Maximum Unknown Frame Time %d\n", 
							pElan->ElanNumber,
							pElan->MaxUnkFrameTime));
						break;
					case LANE_CFG_VCC_TIMEOUT:				// C12
						pElan->VccTimeout = SWAPULONG(*pULong);
						if (pElan->VccTimeout < LANE_C12_MIN)
							pElan->VccTimeout = LANE_C12_DEF;
						DBGP((1, "%d VCC Timeout Period %d\n", 
							pElan->ElanNumber,
							pElan->VccTimeout));
						break;
					case LANE_CFG_MAX_RETRY_COUNT:			// C13
						pElan->MaxRetryCount = SWAPUSHORT(*pUShort);
						if (/* pElan->MaxRetryCount < LANE_C13_MIN || */
							pElan->MaxRetryCount > LANE_C13_MAX)
							pElan->MaxRetryCount = LANE_C13_DEF;
						DBGP((1, "%d Maximum Retry Count %d\n", 
							pElan->ElanNumber,
							pElan->MaxRetryCount));
						break;
					case LANE_CFG_AGING_TIME:				// C17
						pElan->AgingTime = SWAPULONG(*pULong);
						if (pElan->AgingTime < LANE_C17_MIN || 
							pElan->AgingTime > LANE_C17_MAX)
							pElan->AgingTime = LANE_C17_DEF;
						DBGP((1, "%d Aging Time %d\n",
							pElan->ElanNumber,
							pElan->AgingTime));
						break;
					case LANE_CFG_FWD_DELAY_TIME:			// C18
						pElan->ForwardDelayTime = SWAPUSHORT(*pUShort);
						if (pElan->ForwardDelayTime < LANE_C18_MIN || 
							pElan->ForwardDelayTime > LANE_C18_MAX)
							pElan->ForwardDelayTime = LANE_C18_DEF;
						DBGP((1, "%d Forward Delay Time %d\n", 
							pElan->ElanNumber,
							pElan->ForwardDelayTime));
						break;
					case LANE_CFG_ARP_RESP_TIME:			// C20
						pElan->ArpResponseTime = SWAPUSHORT(*pUShort);
						if (pElan->ArpResponseTime < LANE_C20_MIN || 
							pElan->ArpResponseTime > LANE_C20_MAX)
							pElan->ArpResponseTime = LANE_C20_DEF;
						DBGP((1, "%d Arp Response Time %d\n", 
							pElan->ElanNumber,
							pElan->ArpResponseTime));
						break;
					case LANE_CFG_FLUSH_TIMEOUT:			// C21
						pElan->FlushTimeout = SWAPUSHORT(*pUShort);
						if (pElan->FlushTimeout < LANE_C21_MIN || 
							pElan->FlushTimeout > LANE_C21_MAX)
							pElan->FlushTimeout = LANE_C21_DEF;
						DBGP((1, "%d Flush Time-out %d\n", 
							pElan->ElanNumber,
							pElan->FlushTimeout));
						break;
					case LANE_CFG_PATH_SWITCH_DELAY:		// C22
						pElan->PathSwitchingDelay = SWAPUSHORT(*pUShort);
						if (pElan->PathSwitchingDelay < LANE_C22_MIN || 
							pElan->PathSwitchingDelay > LANE_C22_MAX)
							pElan->PathSwitchingDelay = LANE_C22_DEF;
						DBGP((1, "%d Path Switching Delay %d\n", 
							pElan->ElanNumber,
							pElan->PathSwitchingDelay));
						break;
					case LANE_CFG_LOCAL_SEGMENT_ID:			// C23
						pElan->LocalSegmentId = SWAPUSHORT(*pUShort);
						DBGP((1, "%d Local Segment ID %d\n",
							pElan->ElanNumber,
							pElan->LocalSegmentId));
						break;
					case LANE_CFG_MCAST_VCC_TYPE:			// C24
						pElan->McastSendVcType = SWAPUSHORT(*pUShort);
						DBGP((1, "%d Mcast Send VCC Type %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcType));
						break;
					case LANE_CFG_MCAST_VCC_AVG:			// C25
						pElan->McastSendVcAvgRate = SWAPULONG(*pULong);
						DBGP((1, "%d Mcast Send VCC AvgRate %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcAvgRate));
						break;
					case LANE_CFG_MCAST_VCC_PEAK:			// C26
						pElan->McastSendVcPeakRate = SWAPULONG(*pULong);
						DBGP((1, "%d Mcast Send VCC PeakRate %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcPeakRate));
						break;
					case LANE_CFG_CONN_COMPL_TIMER:			// C28
						pElan->ConnComplTimer = SWAPUSHORT(*pUShort);
						if (pElan->ConnComplTimer < LANE_C28_MIN || 
							pElan->ConnComplTimer > LANE_C28_MAX)
							pElan->ConnComplTimer = LANE_C28_DEF;
						DBGP((1, "%d Connection Completion Timer %d\n", 
							pElan->ElanNumber,
							pElan->ConnComplTimer));
						break;
				}

				pType = (ULONG UNALIGNED *)
					(((PUCHAR)pType) + sizeof(pType) + 
					sizeof(*pLength) + *pLength);

			} // while (NumTlvs--)

			//
			//	Recalc the bus rate limiter parameters 
			//			
			pElan->LimitTime = pElan->MaxUnkFrameTime * 1000;
			pElan->IncrTime  = pElan->LimitTime / pElan->MaxUnkFrameCount;
		}

		//
		//	Notify event handler of success
		//
		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_SUCCESS);

		RELEASE_ELAN_LOCK(pElan);

	}
	while (FALSE);

	TRACEOUT(ConfigureResponsehandler);
	return;
}


VOID
AtmLaneControlPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the control VC(s) to/from the LES.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pCf;
	NDIS_STATUS				Status;

	
	TRACEIN(ControlPacketHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pNdisBuffer, 
				(PVOID *)&pCf,
				&BufferLength,
				&TotalLength);

		//
		//	Packet must be at least the size of a control frame.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"ConPacketHandler: Received runt control frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "ConfigureResponseHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a control packet
		//
		if (pCf->Marker != LANE_CONTROL_MARKER 		||
			pCf->Protocol != LANE_PROTOCOL 			||
			pCf->Version != LANE_VERSION)
		{
			DBGP((0, "ControlPacketHandler: Not a control packet!\n"));
			//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);
			break;
		}

		//
		//	Now handle by type of control packet
		//
		switch (pCf->OpCode)
		{
			case LANE_JOIN_RESPONSE:

				DBGP((2, "ControlPacketHandler: Join Response\n"));

				AtmLaneJoinResponseHandler(pElan, pCf);

				break;
			
			case LANE_ARP_RESPONSE:

				DBGP((2, "ControlPacketHandler: ARP Response\n"));

				AtmLaneArpResponseHandler(pElan, pCf);

				break;
				
			case LANE_ARP_REQUEST:

				DBGP((1, "ControlPacketHandler: ARP Request\n"));

				AtmLaneArpRequestHandler(pElan, pCf);

				break;

			case LANE_NARP_REQUEST:

				DBGP((1, "ControlPacketHandler: NARP Request\n"));

				// Drop it.

				break;

			case LANE_TOPOLOGY_REQUEST:

				DBGP((1, "ControlPacketHandler: TOPOLOGY Request\n"));

				AtmLaneTopologyRequestHandler(pElan, pCf);
				
				break;

			case LANE_FLUSH_RESPONSE:
				DBGP((2, "ControlPacketHandler: FLUSH Response\n"));

				AtmLaneFlushResponseHandler(pElan, pCf);

				break;

			default:

				DBGP((0, "ControlPacketHandler: Unexpected OpCode %x!\n",
					pCf->OpCode));
				//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);

				break;

		} // switch (pCf->OpCode)

		break;
	
	}
	while (FALSE);

	TRACEOUT(ControlPackethandler);
	return;
}

VOID
AtmLaneJoinResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handles incoming Join Response packets from the LES.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pCf						- Pointer to LANE Control Frame

Return Value:

	None

--*/
{
	PWCHAR					StringList[2];
	BOOLEAN					FreeString[2];
	NDIS_STATUS				EventCode;
	USHORT					NumStrings;

	TRACEIN(JoinResponseHandler);
	
	ACQUIRE_ELAN_LOCK(pElan);

	if (ELAN_STATE_JOIN == pElan->State)
	{
		//
		//	Only handle join response in JOIN state!
		//	
		if (LANE_STATUS_SUCCESS == pCf->Status)
		{
			//
			//	Success.
			//
			//	Extract the info we need
			//
			pElan->LecId = pCf->LecId;		// leave in network byte order
			DBGP((2,
				"ControlPacketHandler: LECID %x\n",
				SWAPUSHORT(pElan->LecId)));
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_SUCCESS);
		}
		else
		{
			//
			//	Failure
			//		
			DBGP((0,
				"ControlPacketHandler: Unsuccessful Status (%d)\n",
				pCf->Status));

			//
			//	Setup to write error to event log
			//
			StringList[0] = NULL;
			FreeString[0] = FALSE;
			StringList[1] = NULL;
			FreeString[1] = FALSE;
			
			switch (pCf->Status)
			{
				case LANE_STATUS_VERSNOSUPP:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_DUPLANDEST:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
					

				case LANE_STATUS_DUPATMADDR:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
				
				case LANE_STATUS_INSUFFRES:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_NOACCESS:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_REQIDINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_LANDESTINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
				
				case LANE_STATUS_ATMADDRINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
					
				case LANE_STATUS_REQPARMINVAL:
				default:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
			}

			//
			//	If not repeated event on this ELAN write the event to log
			//
			if (pElan->LastEventCode != EventCode)
			{
				pElan->LastEventCode = EventCode;
				(VOID) NdisWriteEventLogEntry(
						pAtmLaneGlobalInfo->pDriverObject,
						EventCode, 0, NumStrings, StringList, 0, NULL);
			}

			//
			//	Free any strings allocated
			//
			if (FreeString[0] && StringList[0] != NULL)
			{
				FREE_MEM(StringList[0]);
			}
			if (FreeString[1] && StringList[1] != NULL)
			{
				FREE_MEM(StringList[1]);
			}

				
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_FAILURE);
		}
	}
	else
	{
		//
		// else bad elan state - ignore packet
		//
		DBGP((0, 
			"ControlPacketHandler: Elan state wrong - Ignoring packet\n",
			pCf->Status));
			
	}
	RELEASE_ELAN_LOCK(pElan);

	TRACEOUT(JoinResponseHandler);
	return;
}

VOID
AtmLaneReadyQueryHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pQueryNdisPacket
)
/*++

Routine Description:

	Handles incoming READY_QUERY packets from peers.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE VC for this packet

	pQueryNdisPacket		- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pQueryRf;
	PLANE_READY_FRAME		pIndRf;
	PNDIS_PACKET			pIndNdisPacket;
	
	TRACEIN(ReadyQueryHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pQueryNdisPacket, 
				&pNdisBuffer, 
				&pQueryRf,
				&BufferLength,
				&TotalLength);
				
		//
		//	Packet must be at least the size of a READY frame.
		//
		if (TotalLength < sizeof(LANE_READY_FRAME))
		{
			DBGP((0,
				"ReadyQueryHandler: Received runt ready frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a ready frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_READY_FRAME))
		{
			DBGP((0, "ReadyQueryHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a ready query
		//
		if (pQueryRf->Marker != LANE_CONTROL_MARKER 		||
			pQueryRf->Protocol != LANE_PROTOCOL 			||
			pQueryRf->Version != LANE_VERSION			||
			pQueryRf->OpCode != LANE_READY_QUERY)
		{
			DBGP((0, "ReadyQueryHandler: Not a ready query\n"));
			//DbgPrintHexDump(0, (PUCHAR)pQueryRf, BufferLength);
			break;
		}

		//
		//	Send Ready Indication back on VC
		//
		ACQUIRE_VC_LOCK(pVc);
		AtmLaneSendReadyIndication(pElan, pVc);
		//
		//	VC lock released in above
		//

		break;
	}
	while (FALSE);

	TRACEOUT(ReadyQueryHandler);
	return;
}


VOID
AtmLaneFlushRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pRequestNdisPacket
)
/*++

Routine Description:

	Handles incoming FLUSH_REQUEST packets from peers.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pRequestNdisPacket		- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PNDIS_BUFFER			pRequestNdisBuffer;
	PNDIS_PACKET			pResponseNdisPacket;
	PNDIS_BUFFER			pResponseNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pRequestCf;
	PLANE_CONTROL_FRAME		pResponseCf;
	NDIS_STATUS				Status;
	ULONG					rc;
	
	TRACEIN(FlushRequestHandler);

	//
	//	Initialize
	//
	pResponseNdisPacket = (PNDIS_PACKET)NULL;
	pResponseNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
	
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pRequestNdisPacket, 
				&pRequestNdisBuffer, 
				(PVOID *)&pRequestCf,
				&BufferLength,
				&TotalLength);
				
		//
		//	Packet must be at least the size of a control frame.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"FlushRequestHandler: Received runt control frame (%d)\n",
				TotalLength));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "FlushRequestHandler: Control frame is fragmented\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Verify that this is really a flush request
		//
		if (pRequestCf->Marker != LANE_CONTROL_MARKER 		||
			pRequestCf->Protocol != LANE_PROTOCOL 			||
			pRequestCf->Version != LANE_VERSION			||
			pRequestCf->OpCode != LANE_FLUSH_REQUEST)
		{
			DBGP((0, "FlushRequestHandler: Not a flush request\n"));
			//DbgPrintHexDump(0, (PUCHAR)pRequestCf, BufferLength);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	See if it is really destined for us
		//
		if (!ATM_ADDR_EQUAL(pRequestCf->TargetAtmAddr, pElan->AtmAddress.Address))
		{
			DBGP((1, "FlushRequestHandler: bad target addr, discarding, Vc %x\n", pVc));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Turn packet around and send it to the LES
		//
		do
		{
			//
			//	Allocate the Ndis packet header.
			//
			pResponseNdisPacket = AtmLaneAllocProtoPacket(pElan);
			if ((PNDIS_PACKET)NULL == pResponseNdisPacket)
			{
				DBGP((0, "FlushRequestHandler: allocate packet failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Allocate the protocol buffer
			//
			pResponseNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&((PUCHAR)(pResponseCf))
									);
			if ((PNDIS_BUFFER)NULL == pResponseNdisBuffer)
			{
				DBGP((0, "FlushRequestHandler: allocate proto buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Copy in the request packet
			//
			NdisMoveMemory(
					pResponseCf, 
					pRequestCf, 
					sizeof(LANE_CONTROL_FRAME)
					);
			

			//
			//	Change to a response opcode
			//
			pResponseCf->OpCode = LANE_FLUSH_RESPONSE;

			//
			//	Link the ndis buffer to the ndis packet
			//
			NdisChainBufferAtFront(pResponseNdisPacket, pResponseNdisBuffer);
					
			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "FlushRequestHandler: Sent FLUSH RESPONSE\n"));
				AtmLaneSendPacketOnVc(pVc, pResponseNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
			}
			else
			{
				Status = NDIS_STATUS_FAILURE;
				RELEASE_VC_LOCK(pVc);
			}

			break;
		}
		while (FALSE);

		break;
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pResponseNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pResponseNdisPacket);
		}
		if (pResponseNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pResponseNdisBuffer);
		}
	}

	TRACEOUT(FlushRequestHandler);
	return;
}

VOID
AtmLaneArpRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pRequestCf
)
/*++

Routine Description:

	Handles incoming Arp Request packets from the LES.
		
Arguments:

	pRequestCf		- Pointer to ARP Request Frame

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PNDIS_PACKET			pResponseNdisPacket;
	PNDIS_BUFFER			pResponseNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pResponseCf;
	NDIS_STATUS				Status;
	ULONG					rc;
	PMAC_ADDRESS			pMacAddress;

	TRACEIN(ArpRequestHandler);

	//
	//	Initialize
	//
	pResponseNdisPacket = (PNDIS_PACKET)NULL;
	pResponseNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	pMacAddress = (PMAC_ADDRESS)pRequestCf->TargetMacAddress.Byte;

	do
	{
		DBGP((2, "%d Arp Request for MAC %s\n",
				pElan->ElanNumber, MacAddrToString(pMacAddress)));

		//
		//  Check if this is a targetless ARP request. Drop it if so.
		//
		if (pRequestCf->TargetMacAddress.Type == LANE_MACADDRTYPE_NOTPRESENT)
		{
			DBGP((1, "%d dropping targetless ARP request for %s\n",
				pElan->ElanNumber, MacAddrToString(pMacAddress)));
			break;
		}

		//
		// 	If not looking for our MAC address then done.
		//
		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			if (!MAC_ADDR_EQUAL(pMacAddress, &pElan->MacAddressTr))
			{
				break;
			}
		
		}
		else
		{
			if (!MAC_ADDR_EQUAL(pMacAddress, &pElan->MacAddressEth))
			{
				break;
			}
		}

		DBGP((1, "%d ARP REQUEST\n", pElan->ElanNumber));
			
		//
		//	Get the LES Vc
		//
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			DBGP((0, "%d ARP REQUEST before we have an LES entry\n", pElan->ElanNumber));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			DBGP((0, "%d ARP REQUEST with no VC to LES\n", pElan->ElanNumber));
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
	
		//
		//	Send Arp Response to the LES
		//
		do
		{
			//
			//	Allocate the Ndis packet header.
			//
			pResponseNdisPacket = AtmLaneAllocProtoPacket(pElan);
			if ((PNDIS_PACKET)NULL == pResponseNdisPacket)
			{
				DBGP((0, "ArpRequestHandler: allocate packet failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Allocate the protocol buffer
			//
			pResponseNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&((PUCHAR)(pResponseCf))
									);
			if ((PNDIS_BUFFER)NULL == pResponseNdisBuffer)
			{
				DBGP((0, "ArpRequestHandler: allocate proto buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Copy in the request packet
			//
			NdisMoveMemory(
					pResponseCf, 
					pRequestCf, 
					sizeof(LANE_CONTROL_FRAME)
					);

			//
			//	Change to a response opcode
			//
			pResponseCf->OpCode = LANE_ARP_RESPONSE;

			//
			//	Fill in our ATM Address
			//
			NdisMoveMemory(
				&pResponseCf->TargetAtmAddr,
				&pElan->AtmAddress.Address,
				ATM_ADDRESS_LENGTH
				);
				
			//
			//	Link the ndis buffer to the ndis packet
			//
			NdisChainBufferAtFront(pResponseNdisPacket, pResponseNdisBuffer);
					
			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "ArpRequestHandler: Sent ARP RESPONSE\n"));
				AtmLaneSendPacketOnVc(pVc, pResponseNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
			}
			else
			{
				Status = NDIS_STATUS_FAILURE;
				RELEASE_VC_LOCK(pVc);
			}

			break;
		}
		while (FALSE);

		break;
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pResponseNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pResponseNdisPacket);
		}
		if (pResponseNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pResponseNdisBuffer);
		}
	}
	
	TRACEOUT(ArpRequestHandler);
	return;
}


VOID
AtmLaneArpResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handle an LE_ARP Response frame.
	
	The MAC Entry should already exist and the Tid in the
	ARP frame should match the one in the MAC Entry.
	If either is not true then the information is ignored.

	An ATM Entry is created or and existing one is found.
	The MAC Entry is linked to it and appropriate actions
	are taken based on the MAC Entry state.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	pMacAddress				- MAC Address
	pAtmAddress				- ATM Address

Return Value:

	None.

--*/
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PMAC_ADDRESS				pMacAddress;
	PUCHAR						pAtmAddress;				
	BOOLEAN						WasRunning;
	BOOLEAN						bFound;
	ULONG						MacAddrType;
	ULONG						rc;

	TRACEIN(ArpResponseHandler);

	//
	//  Initialize
	//
	pMacEntry = NULL_PATMLANE_MAC_ENTRY;
	pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	MacAddrType = pCf->TargetMacAddress.Type;
	pMacAddress = (PMAC_ADDRESS)pCf->TargetMacAddress.Byte;
	pAtmAddress = pCf->TargetAtmAddr;

	do
	{
		//
		//	Check Status
		//				
		if (pCf->Status != LANE_STATUS_SUCCESS)
		{
			DBGP((0,
				"ArpResponseHandler: Unsuccessful Status (%d) for %s\n",
				pCf->Status,
				MacAddrToString(pMacAddress)));
			break;
		}

		//
		//  Get an existing MAC Entry
		//
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		pMacEntry = AtmLaneSearchForMacAddress(
								pElan,
								MacAddrType,
								pMacAddress,
								FALSE
								);
		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
			DBGP((0, "ArpResponseHandler: non-existing MAC %s\n",
				MacAddrToString(pMacAddress)));
			break;
		}

		ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);
		AtmLaneReferenceMacEntry(pMacEntry, "tmpArpResp");
		RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);

		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		rc = AtmLaneDereferenceMacEntry(pMacEntry, "tmpArpResp");
		if (rc == 0)
		{
			//
			//  the MAC entry has been deref'ed away.
			//
			break;
		}

		//
		//	Verify that Tid matches
		//
		if (pMacEntry->ArpTid != pCf->Tid)
		{
			DBGP((0, "ArpResponseHandler: invalid Tid for MAC %s\n",
				MacAddrToString(pMacAddress)));
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}
		
		DBGP((1, "%d Resolved %s to %s\n", 
			pElan->ElanNumber,
			MacAddrToString(pMacAddress),
			AtmAddrToString(pAtmAddress)));
	
		//
		//  Get an existing or create new ATM Entry
		//
		pAtmEntry = AtmLaneSearchForAtmAddress(
								pElan,
								pAtmAddress,
								(((pMacEntry->Flags & MAC_ENTRY_BROADCAST) != 0)
									? ATM_ENTRY_TYPE_BUS
									: ATM_ENTRY_TYPE_PEER),
								TRUE
								);
		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			//
			//	resource problem - ARP timeout will clean up MAC Entry
			//		
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}
		
		//
		//  Got both entries.
		//
		//  If the MAC Entry is linked to a different
		//	ATM Entry, unlink it from the old entry.
		//
		if ((pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY) && 
			(pMacEntry->pAtmEntry != pAtmEntry))
		{
			DBGP((0, 
				"LearnMacToAtm: MacEntry %x moving from ATM Entry %x to ATM Entry %x\n",
				pMacEntry, pMacEntry->pAtmEntry, pAtmEntry));

			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);
					
			bFound = AtmLaneUnlinkMacEntryFromAtmEntry(pMacEntry);
			pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

			if (bFound)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "atm");
				if (rc == 0)
				{
					//
					//  The MAC entry is gone. Let the next outgoing packet
					//  cause a new entry to be created.
					//
					break;
				}
			}
		}

		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING))
		{
			//
			//	MAC Entry is in ARPING state
			//
			ASSERT(pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY);

			//
			//	Link MAC Entry and ATM Entry together
			//
			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
#if DBG1
			{
				PATMLANE_MAC_ENTRY		pTmpMacEntry;
				ULONG					Count = 0;

				for (pTmpMacEntry = pAtmEntry->pMacEntryList;
					 pTmpMacEntry != NULL;
					 pTmpMacEntry = pTmpMacEntry->pNextToAtm)
				{
					if (pTmpMacEntry == pMacEntry)
					{
						DBGP((0, "LearnMacToAtm: pMacEntry %x already in list for pAtmEntry %x\n",
							pTmpMacEntry, pAtmEntry));
						DbgBreakPoint();
					}

					Count++;
					if (Count > 5000)
					{
						DBGP((0, "Loop in list on pAtmEntry %x\n", pAtmEntry));
						DbgBreakPoint();
						break;
					}
				}
			}
#endif // DBG
			pMacEntry->pAtmEntry = pAtmEntry;
			AtmLaneReferenceAtmEntry(pAtmEntry, "mac");
			pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
			pAtmEntry->pMacEntryList = pMacEntry;
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			AtmLaneReferenceMacEntry(pMacEntry, "atm");

			DBGP((1, "%d Linked1 MAC %x to ATM %x\n",
					pAtmEntry->pElan->ElanNumber,
					pMacEntry,
					pAtmEntry));

			//
			//	Cancel ARP timer
			//
			WasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
			if (WasRunning)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");
				ASSERT(rc > 0);
			}

			//
			//	Transition to RESOLVED state
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_RESOLVED);

			//
			//	Handle special case for broadcast address.
			//	
			if ((pMacEntry->Flags & MAC_ENTRY_BROADCAST) != 0)
			{
				RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				
				//
				//	Cache the AtmEntry in the Elan
				//
				ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
				pElan->pBusAtmEntry = pAtmEntry;
				RELEASE_ELAN_ATM_LIST_LOCK(pElan);
				
				//
				//	Copy the Atm Address into the AtmEntry
				//
				pAtmEntry->AtmAddress.AddressType = ATM_NSAP;
				pAtmEntry->AtmAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
				NdisMoveMemory(
						pAtmEntry->AtmAddress.Address, 
						pAtmAddress,
						ATM_ADDRESS_LENGTH
						);

				//
				//	Signal the event to the state machine
				//
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_ARP_RESPONSE, NDIS_STATUS_SUCCESS);

				//
				//	Event handler will initiate the call to the bus
				//

				break; // done
			}

			//
			//	Not broadcast address.
			//
			//  Start the Aging timer.
			//	Use Elan AgingTime if TopologyChange is inactive.
			//	Use Elan ForwardDelayTime if TopologyChange is active.
			//  
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
						pElan,
						&pMacEntry->Timer,
						AtmLaneMacEntryAgingTimeout,
						pElan->TopologyChange?pElan->ForwardDelayTime:pElan->AgingTime,
						(PVOID)pMacEntry
						);
		
			//
			//	If ATM Entry not connected and a call not in progress
			//  then start a call
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		
			if (!IS_FLAG_SET(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED))
			{
				if ((pAtmEntry->Flags & ATM_ENTRY_CALLINPROGRESS) == 0)
				{
					// 
					//	Mark ATM entry with call in progress
					//
					pAtmEntry->Flags |= ATM_ENTRY_CALLINPROGRESS;

					//
					//	Release the MAC lock and reacquire ATM lock
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
					AtmLaneMakeCall(pElan, pAtmEntry, FALSE);
					//
					//	ATM Entry released in above
					//
				}
				else
				{
					//
					//	Call already in progress
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				break; // done
			}

			//
			//	ATM Entry is connected
			//

			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			//
			//	Transition to FLUSHING state
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_FLUSHING);

			//
			//	 Start flushing
			//
			pMacEntry->RetriesLeft = 0;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->FlushTimer,
					AtmLaneFlushTimeout,
					pElan->FlushTimeout,
					(PVOID)pMacEntry
					);
	
			AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
			//
			// MAC Entry released in above
			//

			break; // done
		}

		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED))
		{
			//
			//	MAC Entry is being revalidated 
			//
			//
			//	Cancel ARP timer
			//
			WasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
			if (WasRunning)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");
				ASSERT(rc > 0);
			}

			//
			//	Start the Aging timer up again
			//
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneMacEntryAgingTimeout,
					pElan->TopologyChange?pElan->ForwardDelayTime:pElan->AgingTime,
					(PVOID)pMacEntry
					);

			//
			//	Check if MAC Entry is switching to new ATM Entry

			if (pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
			{
				//
				//	Link MAC Entry and new ATM Entry together
				//
				ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
#if DBG1
			{
				PATMLANE_MAC_ENTRY		pTmpMacEntry;
				ULONG					Count = 0;

				for (pTmpMacEntry = pAtmEntry->pMacEntryList;
					 pTmpMacEntry != NULL;
					 pTmpMacEntry = pTmpMacEntry->pNextToAtm)
				{
					if (pTmpMacEntry == pMacEntry)
					{
						DBGP((0, "RespHandler: pMacEntry %x already in list for pAtmEntry %x\n",
							pTmpMacEntry, pAtmEntry));
						DbgBreakPoint();
					}

					Count++;
					if (Count > 5000)
					{
						DBGP((0, "RespHandler: Loop in list on pAtmEntry %x\n", pAtmEntry));
						DbgBreakPoint();
						break;
					}
				}
			}
#endif // DBG
				pMacEntry->pAtmEntry = pAtmEntry;
				AtmLaneReferenceAtmEntry(pAtmEntry, "mac");
				pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
				pAtmEntry->pMacEntryList = pMacEntry;
				RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				AtmLaneReferenceMacEntry(pMacEntry, "atm");

				DBGP((1, "%d Linked2 MAC %x to ATM %x\n",
						pAtmEntry->pElan->ElanNumber,
						pMacEntry,
						pAtmEntry));

				//
				//	Transition back to resolved state
				//
				SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED);
			}

			//
			//	If ATM Entry not connected and a call not in progress
			//  then start a call
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		
			if (!IS_FLAG_SET(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED))
			{
				if ((pAtmEntry->Flags & ATM_ENTRY_CALLINPROGRESS) == 0)
				{
					// 
					//	Mark ATM entry with call in progress
					//
					pAtmEntry->Flags |= ATM_ENTRY_CALLINPROGRESS;

					//
					//	Release the MAC lock and reacquire ATM lock
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
					AtmLaneMakeCall(pElan, pAtmEntry, FALSE);
					//
					//	ATM Entry released in above
					//
				}
				else
				{
					//
					//	Call already in progress
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				break; // done
			}

			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			//
			//	MAC Entry is now either still AGED or 
			//	transitioned to RESOLVED state.  
			//

			ASSERT((pMacEntry->Flags & (MAC_ENTRY_AGED | MAC_ENTRY_RESOLVED)) != 0);

			if (IS_FLAG_SET(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED))
			{
				// 
				//	MAC entry must have moved to new, connected ATM Entry
				//	Do the flush
				//
				SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_FLUSHING);

				pMacEntry->RetriesLeft = 0;
				AtmLaneReferenceMacEntry(pMacEntry, "timer");
				AtmLaneStartTimer(
						pElan,
						&pMacEntry->FlushTimer,
						AtmLaneFlushTimeout,
						pElan->FlushTimeout,
						(PVOID)pMacEntry
						);

				AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
				//
				// MAC Entry released in above
				//

				break; // done
			}

			//
			//	MAC Entry can just transition back to ACTIVE
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ACTIVE);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			break;
		}

		//
		//	Shouldn't get here
		//
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		DBGP((0, "LearnMacToAtm: MacEntry in wrong state!\n"));
		break;

	}
	while (FALSE);

	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//  Remove the temp ref added by SearchFor...
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
	}

	TRACEOUT(ArpResponseHandler);

	return;
}

VOID
AtmLaneFlushResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handles incoming Flush Response packets from peers.
		
Arguments:

	pCf						- Pointer to LANE Control Frame

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_PACKET			pNextPacket;
	PATMLANE_VC				pVc;
	BOOLEAN					WasRunning;
	ULONG					rc;

	TRACEIN(FlushResponseHandler);

	pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	do
	{
		//
		// 	Check that we originated the request
		//
		if (!ATM_ADDR_EQUAL(pCf->SourceAtmAddr, &pElan->AtmAddress.Address))
		{
			DBGP((0, "FlushResponseHandler: Response not addressed to us!\n"));
			break;
		}
	
		//
		//	Find the Atm Entry for the target address
		//
		pAtmEntry = AtmLaneSearchForAtmAddress(
							pElan,
							pCf->TargetAtmAddr,
							ATM_ENTRY_TYPE_PEER,
							FALSE);				// don't create a new one
		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			DBGP((0, "FlushResponseHandler: No matching ATM entry\n"));
			break;
		}

		//
		//	Grab and Reference the VC for this ATM Entry 
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			DBGP((0, "FlushResponseHandler: No VC on ATM Entry\n"));
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			break;
		}
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);

		//
		//	Find the Mac Entry on this Atm Entry that matches the Tid
		//
		pMacEntry = pAtmEntry->pMacEntryList;
		while(pMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			if (pMacEntry->FlushTid == pCf->Tid)
				break;
			pMacEntry = pMacEntry->pNextToAtm;
		}
		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{	
			//
			//	No MAC Entry still exists that originated this flush
			//
			DBGP((0, "FlushResponseHandler: No MAC entry with matching TID\n"));

			ACQUIRE_VC_LOCK(pVc);
			rc = AtmLaneDereferenceVc(pVc, "temp");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			break;
		}
		else
		{
			//
			//	Found it
			//		
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}

		//
		//	Mark MAC Entry ACTIVE
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		AtmLaneReferenceMacEntry(pMacEntry, "temp");
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ACTIVE);

		//
		//	Cancel the flush timer
		//
		WasRunning = AtmLaneStopTimer(&pMacEntry->FlushTimer, pElan);
		if (WasRunning)
		{
			rc = AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
			ASSERT(rc > 0);
		}

		//
		//	Send any queued packets
		//
		while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) != 
				(PNDIS_PACKET)NULL)
		{
			//
			//	Send it
			//
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);
			}
			else
			{
				//
				//  The VC is being torn down.
				//
				RELEASE_VC_LOCK(pVc);

				//
				//  Queue this packet back, and abort.
				//
				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

				break;
			}

			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		}


		//
		//	Dereference the MAC Entry
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "temp");
		if (rc > 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
		
		//
		//	Dereference the VC
		//
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		
		break;
	}
	while (FALSE);
	
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//  Remove the temp ref added by SearchFor...
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
	}

	TRACEOUT(FlushResponseHandler);
	return;
}



VOID
AtmLaneReadyIndicationHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pIndNdisPacket
)
/*++

Routine Description:

	Handles incoming READY_INDICATION packets from peers.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE VC for this packet

	pIndNdisPacket			- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	BOOLEAN				WasRunning;
	ULONG				rc;
	
	TRACEIN(ReadyIndicationHandler);

	ACQUIRE_VC_LOCK(pVc);
	
	//
	//	Cancel the ready timer on VC
	//
	WasRunning = AtmLaneStopTimer(&pVc->ReadyTimer, pElan);
	if (WasRunning)
	{
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
	}
	else
	{
		rc = pVc->RefCount;
	}

	//
	//	If VC still around update state
	//
	if (rc > 0)
	{
		DBGP((2, "ReadyIndicationHandler: pVc %x State to INDICATED\n", pVc));
		SET_FLAG(
			pVc->Flags,
			VC_READY_STATE_MASK,
			VC_READY_INDICATED
			);
		RELEASE_VC_LOCK(pVc);
	}
	//
	//	else VC is gone
	//

	TRACEOUT(ReadyIndicationHandler);
	return;
}

VOID
AtmLaneTopologyRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME			pCf
)
/*++

Routine Description:

	Handles incoming Topology Request packets from the LES.
		
Arguments:

	pRequestCf		- Pointer to ARP Request Frame

Return Value:

	None

--*/
{
	ULONG					i;
	PATMLANE_MAC_ENTRY		pMacEntry;

	TRACEIN(TopologyRequestHandler);

	if ((pCf->Flags & LANE_CONTROL_FLAGS_TOPOLOGY_CHANGE) == 0)
	{
		//
		//	Topology change state OFF
		//
		DBGP((1, "%d TOPOLOGY CHANGE OFF\n", pElan->ElanNumber));
		pElan->TopologyChange = 0;
	}
	else
	{
		//
		//	Topology change state ON
		//
		DBGP((1, "%d TOPOLOGY CHANGE ON\n", pElan->ElanNumber));
		pElan->TopologyChange = 1;

		//
		//	Abort all MAC table entries.
		//
		for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
		{
			ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
			while (pElan->pMacTable[i] != NULL_PATMLANE_MAC_ENTRY)
			{
				pMacEntry = pElan->pMacTable[i];
				RELEASE_ELAN_MAC_TABLE_LOCK(pElan);		

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneAbortMacEntry(pMacEntry);
				//
				//  MAC Entry Lock is released within the above.
				//
				ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
			}
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		}
		
	}

	TRACEOUT(TopologyRequestHandler);
	return;
}

BOOLEAN
AtmLaneDataPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the data VCs from peers and
	unknown and multicast packets from the BUS.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	TRUE 					- if packet will be retained (i.e. sent
							  up to protocols)

	FALSE					- if packet was a flush request packet and
							  can be reliquished back to adapter
							  immediately.

--*/
{
	ULONG					TotalLength;
	ULONG					TempLength;
	PUCHAR					pBuffer;
	BOOLEAN					RetainIt;
	PLANE_CONTROL_FRAME		pCf;
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pFirstNdisBuffer;
	PNDIS_BUFFER			pTempNdisBuffer;
	PNDIS_BUFFER			pNewNdisBuffer;
	PUCHAR					pTempBuffer;
	NDIS_STATUS				Status;
	ULONG					MacHdrSize;
	ULONG					DestAddrType;
	MAC_ADDRESS				DestAddr;
	BOOLEAN					DestIsMulticast;
	NDIS_HANDLE				MiniportAdapterHandle;
	
	TRACEIN(DataPacketHandler);

	//	Initialize

	RetainIt = FALSE;			// default is not to keep packet
	pNewNdisPacket = NULL;

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pFirstNdisBuffer, 
				&pBuffer,
				&TempLength,
				&TotalLength);

		DBGP((3, "DataPacketHandler: Pkt %x Length %d\n",
			pNdisPacket, TotalLength));
		//DbgPrintNdisPacket(pNdisPacket);

		//
		//	Filter out flush request and ready query frames
		//
		if (TempLength < 6)
		{
			DBGP((0, "DataPacketHandler: pVc %x First fragment"
			         " < 6, discarding\n", pVc));

			break;
		}
		
		pCf = (PLANE_CONTROL_FRAME)pBuffer;
		
		if (pCf->Marker == LANE_CONTROL_MARKER 	&&
			pCf->Protocol == LANE_PROTOCOL 		&&
			pCf->Version == LANE_VERSION)
		{
			switch (pCf->OpCode)
			{
				case LANE_FLUSH_REQUEST:
					DBGP((2, "DataPacketHandler: pVc %x FLUSH REQUEST\n", pVc));
					AtmLaneFlushRequestHandler(pElan, pNdisPacket);
					break;
				case LANE_READY_QUERY:
					DBGP((2, "DataPacketHandler: pVc %x READY QUERY\n", pVc));
					AtmLaneReadyQueryHandler(pElan, pVc, pNdisPacket);
					break;
				case LANE_READY_IND:
					DBGP((2, "DataPacketHandler: pVc %x READY INDICATION\n", pVc));
					AtmLaneReadyIndicationHandler(pElan, pVc, pNdisPacket);
					break;
				default:
					DBGP((2, 
						"DataPacketHandler: pVc %x Unexpected control"
						" packet, opcode %x\n",
						pVc, pCf->OpCode));
					break;
			}
			break;
		}

		//
		//	If miniport is not operational - discard
		//
		if ((pElan->Flags & ELAN_MINIPORT_OPERATIONAL) == 0)
		{
			DBGP((2, "%d Dropping pkt %x, cuz Elan %x Flags are %x\n",
						pElan->ElanNumber, pNdisPacket, pElan, pElan->Flags));
			break;
		}

		//
		//  If no filters are set, discard.
		//
		if (pElan->CurPacketFilter == 0)
		{
			DBGP((2, "%d Dropping pkt %x, cuz Elan %x Filter is zero\n",
						pElan->ElanNumber, pNdisPacket, pElan));
			break;
		}

		MiniportAdapterHandle = pElan->MiniportAdapterHandle;
		if (NULL == MiniportAdapterHandle)
		{
			DBGP((0, "%d Dropping pkt %x cuz ELAN %x has Null handle!\n",
					pElan->ElanNumber, pNdisPacket, pElan));
			break;
		}

		//
		//	Mark VC with fact that it has had data packet receive activity
		//
		//	To avoid slowing down the receive path, MP issues with
		//	setting this flag are ignored.  This flag is a VC aging
		//  optimization and not critical.  
		//
		pVc->ReceiveActivity = 1;

		//
		//	Repackage it and learn some stuff about it.
		//
		pNewNdisPacket = AtmLaneWrapRecvPacket(
								pElan, 
								pNdisPacket, 
								&MacHdrSize,
								&DestAddrType,
								&DestAddr,
								&DestIsMulticast);

		//
		//	If wrap failed just discard packet
		//	
		if (pNewNdisPacket == (PNDIS_PACKET)NULL)
		{
			DBGP((2, "%d Dropping pkt %x, len %d, VC %x, wrap failed\n",
					pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
			break;
		}

		//
		//	Branch on Ethernet v.s. Token Ring
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			//
			//	Filter out BUS reflections that we originated.
			//
			if (pCf->Marker == pElan->LecId)  
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, BUS reflection\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}

			//
			//	Filter out Unicasts not addressed to us
			//
			if ((!DestIsMulticast) &&
				(!MAC_ADDR_EQUAL(&DestAddr, &pElan->MacAddressEth)))
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, unicast not for us\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}
		}
		else
		{
			ASSERT(pElan->LanType == LANE_LANTYPE_TR);
			
			//
			//	Filter out Non-Multicast BUS reflections that we originated
			//
			if ((pCf->Marker == pElan->LecId) && (!DestIsMulticast))  
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, TR Bus refln\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}

			//
			//	Filter out Unicasts not addressed to us
			//
			if ((!DestIsMulticast) &&
				(!MAC_ADDR_EQUAL(&DestAddr, &pElan->MacAddressTr)))
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, TR unicast not for us\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}
		}

		//
		//  Filter out multicast/broadcast if we don't have these enabled.
		//
		if (DestIsMulticast)
		{
			if ((pElan->CurPacketFilter &
					(NDIS_PACKET_TYPE_MULTICAST|
					 NDIS_PACKET_TYPE_BROADCAST|
					 NDIS_PACKET_TYPE_ALL_MULTICAST)) == 0)
			{
				DBGP((2, "%d Dropping multicast pkt %x, cuz CurPacketFilter is %x\n",
						pElan->ElanNumber, pNdisPacket, pElan->CurPacketFilter));
				break;
			}

			if (((pElan->CurPacketFilter & NDIS_PACKET_TYPE_BROADCAST) == 0) &&
				 MAC_ADDR_EQUAL(&DestAddr, &gMacBroadcastAddress))
			{
				DBGP((2, "%d Dropping broadcast pkt %x, cuz CurPacketFilter is %x\n",
						pElan->ElanNumber, pNdisPacket, pElan->CurPacketFilter));
				break;
			}

		}

		//
		//	Count it
		//
		NdisInterlockedIncrement(&pElan->FramesRecvGood);

		//
		//	Indicate it up to protocols and other interested parties
		//	
		NDIS_SET_PACKET_HEADER_SIZE(pNewNdisPacket, MacHdrSize);

		TRACELOGWRITE((&TraceLog, 
					TL_MINDPACKET,	
					pNewNdisPacket));
		
		//
		//  Set the packet status according to what we received from the miniport.
		//
		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		NDIS_SET_PACKET_STATUS(pNewNdisPacket, Status);
		
		NdisMIndicateReceivePacket(
				MiniportAdapterHandle,
				&pNewNdisPacket,
				1
				);

		if (Status != NDIS_STATUS_RESOURCES)
		{
			RetainIt = TRUE;
			DBGP((2, "DataPacketHandler: Packet Retained!\n"));
		}
		//
		//  else our ReturnPackets handler is guaranteed to be called.
		//
		
	}	
	while (FALSE);

	//
	//	Unwrap the packet if it was wrapped and we don't have to keep it.
	//
	if (pNewNdisPacket && !RetainIt)
	{
		(VOID)AtmLaneUnwrapRecvPacket(pElan, pNewNdisPacket);
	}

	TRACEOUT(DataPacketHandler);
	
	return (RetainIt);
}


VOID
AtmLaneSendPacketOnVc(
	IN	PATMLANE_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	BOOLEAN						Refresh
)
/*++

Routine Description:

	Send a packet on the specified VC. 
	Assumes caller has lock on VC structure.
	Assumes caller has checked VC state for validity.
	If requested, refresh the aging timer.
	Sends the packet.
	Returns the send status

Arguments:

	pVc					- Pointer to ATMLANE VC
	pNdisPacket			- Pointer to packet to be sent.
	Refresh				- If TRUE refresh the Aging Timer.

Return Value:

	NDIS_STATUS value set on the packet by the miniport.

--*/
{
	NDIS_HANDLE				NdisVcHandle;
	PATMLANE_ELAN			pElan;
	
	TRACEIN(SendPacketOnVc);

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//	If requested, refresh the aging timer
	//
	if (Refresh)
	{
		AtmLaneRefreshTimer(&pVc->AgingTimer);
	}	

#if SENDLIST

	//
	//	Check list for duplicate send
	//
	NdisAcquireSpinLock(&pElan->SendListLock);
	{
		PNDIS_PACKET pDbgPkt;

		pDbgPkt = pElan->pSendList;

		while (pDbgPkt != (PNDIS_PACKET)NULL)
		{
			if (pNdisPacket == pDbgPkt)
			{
				DBGP((0, "SendPacketOnVc: Duplicate Send!\n"));
				// DbgBreakPoint();
			}
			pDbgPkt = PSEND_RSVD(pDbgPkt)->pNextInSendList;
		}
	}

	//
	//	Queue packet on list of outstanding sends
	//
	PSEND_RSVD(pNdisPacket)->pNextInSendList = pElan->pSendList;
	pElan->pSendList = pNdisPacket;

	NdisReleaseSpinLock(&pElan->SendListLock);
#endif // SENDLIST

	//
	//	Reference the VC with the outstanding send
	//
	AtmLaneReferenceVc(pVc, "sendpkt");

	//
	//  Note this outstanding send.
	//
	pVc->OutstandingSends++;

	//
	//	Get the Ndis handle
	//
	NdisVcHandle = pVc->NdisVcHandle;

	//
	//	Send it
	//
	DBGP((3, "SendPacketOnVc: pVc %x, Pkt %x, VcHandle %x\n",
			pVc, pNdisPacket, NdisVcHandle));


	TRACELOGWRITE((&TraceLog, TL_COSENDPACKET, pNdisPacket));
	TRACELOGWRITEPKT((&TraceLog, pNdisPacket));
			
	RELEASE_VC_LOCK(pVc);

	NdisCoSendPackets(NdisVcHandle,	&pNdisPacket, 1);

#if PROTECT_PACKETS
	//
	//	Lock the packet
	//
	ACQUIRE_SENDPACKET_LOCK(pNdisPacket);

	//
	//	Mark it with NdisCoSendPackets having returned
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) == 0);
	PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;

	//
	//	Complete the packet only if it is marked as having been completed
	//	by miniport.
	//
	if ((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) != 0)
	{
		AtmLaneCompleteSendPacket(pElan, pNdisPacket, 
			PSEND_RSVD(pNdisPacket)->CompletionStatus);
		//
		//	packet lock released in above
		//
	}
	else
	{
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
	}
#endif	// PROTECT_PACKETS

	TRACEOUT(SendPacketOnVc);
	
	return;
}


VOID
AtmLaneQueuePacketOnHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet at the head of the MAC Entry 
	packet queue for later transmit.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	TRACEIN(QueuePacketOnHead);

	SET_NEXT_PACKET(pNdisPacket, pMacEntry->PacketList);
	pMacEntry->PacketList =  pNdisPacket;

	pMacEntry->PacketListCount++;

	DBGP((2, "%d QueueHead Count %d on %s\n", 
		pMacEntry->pElan->ElanNumber, 
		pMacEntry->PacketListCount,
		MacAddrToString(&pMacEntry->MacAddress)));

	TRACEOUT(QueuePacketOnHead);
	
	return;
}


VOID
AtmLaneQueuePacketOnTail(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet at the tail of the MAC Entry 
	packet queue for later transmit.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	TRACEIN(QueuePacketOnTail);


	if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
	{
		//
		//  Currently empty.
		//
		pMacEntry->PacketList = pNdisPacket;
	}
	else
	{
		//
		//  Go to the end of the packet list.
		//
		pPrevPacket = pMacEntry->PacketList;
		while (GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
		{
			pPrevPacket = GET_NEXT_PACKET(pPrevPacket);
		}

		//
		//  Found the last packet in the list. Chain this packet
		//  to it.
		//
		SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
	}

	//
	//	Set tail's next pointer to NULL.
	//
	SET_NEXT_PACKET(pNdisPacket, NULL);

	pMacEntry->PacketListCount++;

	DBGP((2, "%d QueueTail Count %d on %s\n", 
		pMacEntry->pElan->ElanNumber, 
		pMacEntry->PacketListCount,
		MacAddrToString(&pMacEntry->MacAddress)));

	TRACEOUT(QueuePacketOnTail);
	return;
}


PNDIS_PACKET
AtmLaneDequeuePacketFromHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Dequeue a packet from the head of the MAC Entry packet queue.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.

Return Value:

	First packet on the MAC Entry queue or NULL if queue is empty.

--*/
{
	PNDIS_PACKET		pNdisPacket;

	TRACEIN(DequeuePacketFromHead);

	do
	{
	
		//
		//  If queue is empty, setup to return NULL
		//
		if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			ASSERT(pMacEntry->PacketListCount == 0);
		
			pNdisPacket = (PNDIS_PACKET)NULL;
			break;
		}

		//
		//	Queue is not empty - remove head 
		//
		ASSERT(pMacEntry->PacketListCount > 0);

		pNdisPacket = pMacEntry->PacketList;
		
		pMacEntry->PacketList = GET_NEXT_PACKET(pNdisPacket);
		
		SET_NEXT_PACKET(pNdisPacket, NULL);
		
		pMacEntry->PacketListCount--;

		DBGP((2, "%d DequeueHead Count %d on %s\n", 
			pMacEntry->pElan->ElanNumber, 
			pMacEntry->PacketListCount,
			MacAddrToString(&pMacEntry->MacAddress)));

		break;
	}
	while (FALSE);

	TRACEOUT(DequeuePacketFromHead);
	
	return pNdisPacket;
}

NDIS_STATUS
AtmLaneSendUnicastPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						DestAddrType,
	IN	PMAC_ADDRESS				pDestAddress,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send a unicast packet.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	DestAddrType			- Either LANE_MACADDRTYPE_MACADDR or 
									 LANE_MACADDRTYPE_ROUTEDESCR.
	pDestAddress			- Pointer to Destination MAC Address
	pNdisPacket				- Pointer to packet to be sent.

Return Value:

	NDIS_STATUS_PENDING		- if packet queued or sent
	NDIS_STATUS_FAILURE		- if some error

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	NDIS_STATUS				Status;
	ULONG					rc;

	TRACEIN(SendUnicastPacket);
	
	//
	//	Initialize
	//
	pMacEntry = NULL_PATMLANE_MAC_ENTRY;
	Status = NDIS_STATUS_PENDING;
	
	do
	{
		//
		//	Find a MAC entry for this destination address
		//
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		pMacEntry = AtmLaneSearchForMacAddress(
							pElan,
							DestAddrType,
							pDestAddress,
							TRUE		// Create new entry if not found
							);

		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{
			Status = NDIS_STATUS_RESOURCES;
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
			break;
		}

		//
		//  Add a temp ref so that this won't go away when we release
		//  the MAC table lock (#303602).
		//
		ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);
		AtmLaneReferenceMacEntry(pMacEntry, "tempunicast");
		RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);

		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

		//
		//	Lock the MAC Entry
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//  Check if it has been deref'ed away.
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "tempunicast");
		if (rc == 0)
		{
			//
			//  The MAC entry is gone! Fail this send.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	MAC Entry State - NEW
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW))
		{
			DBGP((2, "SendUnicastPacket: NEW Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Transition to ARPING State
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING);

			ASSERT(pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY);
			
			//
			//	Start the BUS sends.
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//

			//
			//	Reacquire the lock
			//
			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
			
			//
			//	Start the ARP protocol
			//
			pMacEntry->RetriesLeft = pElan->MaxRetryCount;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneArpTimeout,
					pElan->ArpResponseTime,
					(PVOID)pMacEntry
					);

			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//

			break;
		}

		//
		//	MAC Entry State - ARPING
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING))
		{
			DBGP((2, "SendUnicastPacket: ARPING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
				
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Start the BUS sends
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//
			break;
		}

		//
		//	MAC Entry State - RESOLVED
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_RESOLVED))
		{
			DBGP((2, "SendUnicastPacket: RESOLVED Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Start the BUS sends
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//
			break;
		}

		//
		//	MAC Entry State - FLUSHING
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_FLUSHING))
		{
			DBGP((2, "SendUnicastPacket: FLUSHING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			break;
		}

		//
		//	MAC Entry State - ACTIVE
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ACTIVE))
		{
			DBGP((2, "SendUnicastPacket: ACTIVE Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			//
			//	Mark MAC Entry as having been used to send a packet.
			//  Will cause revalidation at aging time instead of deletion.
			//
			pMacEntry->Flags |= MAC_ENTRY_USED_FOR_SEND;

			ASSERT(pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);

			pVc = pMacEntry->pAtmEntry->pVcList;

			if (pVc == NULL_PATMLANE_VC)
			{
				RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneReferenceVc(pVc, "unicast");
			RELEASE_VC_LOCK(pVc);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			ACQUIRE_VC_LOCK(pVc);

			rc = AtmLaneDereferenceVc(pVc, "unicast");

			if (rc == 0)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);
				//
				//	Vc lock released in above
				//
				NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count packet
			}
			else
			{
				//
				//  The VC is being torn down. Fail/complete this send.
				//
				RELEASE_VC_LOCK(pVc);
				Status = NDIS_STATUS_FAILURE;
				break;
			}
		
			break;
		}

		//
		//	MAC Entry State - AGED
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED))
		{
			DBGP((2, "SendUnicastPacket: AGED Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			ASSERT(pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);
			ASSERT(pMacEntry->pAtmEntry->pVcList != NULL_PATMLANE_VC);

			pVc = pMacEntry->pAtmEntry->pVcList;

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneReferenceVc(pVc, "unicast");
			RELEASE_VC_LOCK(pVc);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ACQUIRE_VC_LOCK(pVc);

			rc = AtmLaneDereferenceVc(pVc, "unicast");

			if (rc == 0)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);
			//
			//	Vc lock released in above
			//
			NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count packet
			break;
		}

		//
		//	MAC Entry State - ABORTING
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ABORTING))
		{
			DBGP((2, "SendUnicastPacket: ABORTING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			Status = NDIS_STATUS_FAILURE;
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

	}
	while (FALSE);

	TRACEOUT(SendUnicastPacket);

	return Status;
}

VOID
AtmLaneStartBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Starts up the bus send process.
		
Arguments:

	pMacEntry			- A pointer to an ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	TRACEIN(StartBusSends);

	do
	{
		//
		//	If timer set, just wait for it to go off
		//
		if (pMacEntry->Flags & MAC_ENTRY_BUS_TIMER)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		//
		//	Otherwise do the sends
		//
		AtmLaneDoBusSends(pMacEntry);
		//
		//	lock released in above
		//
	}
	while (FALSE);

	TRACEOUT(StartBusSends);
	return;
}

VOID
AtmLaneDoBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Attempt to send the packets on the MAC Entry's queue.
	Schedule a timer to send later if we exceed the BUS send limits.

	The caller is assumed to have acquired the MAC entry lock,
	which will be released here.
		
Arguments:

	pMacEntry			- A pointer to an ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PATMLANE_ELAN			pElan;
	PNDIS_PACKET			pNdisPacket;
	ULONG					rc;

	TRACEIN(DoBusSends);

	pElan = pMacEntry->pElan;
	
	//
	//	Initialize
	//
	pVc = NULL_PATMLANE_VC;

	//
	//  Place a temp ref on this MAC entry so that it won't go away.
	//
	AtmLaneReferenceMacEntry(pMacEntry, "DoBusSends");

	do
	{
		//
		//	If Elan state not operational then done
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState ||
			ELAN_STATE_OPERATIONAL != pElan->State)
		{
			break;
		}
		
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pBusAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//	loop until no more packets or send limit reached
		//
		do
		{
			//
			//	If no more packets to send then done
			//
			if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
			{
				break;
			}

			//
			//	Check if ok to send a packet now
			//
			if (!AtmLaneOKToBusSend(pMacEntry))
			{
				// 
				//  Not OK to send now, try later
				//
				//	Reference the MAC Entry
				//
				AtmLaneReferenceMacEntry(pMacEntry, "bus timer");
				
				//
				//	Reschedule the timer routine
				//
				pMacEntry->Flags |= MAC_ENTRY_BUS_TIMER;
				NdisSetTimer(&pMacEntry->BusTimer, pMacEntry->IncrTime);	

				break;
			}

			//
			// 	Dequeue a packet
			//
			pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ASSERT(pNdisPacket != (PNDIS_PACKET)NULL);

			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "DoBusSends: pVc %x Pkt %x Sending to BUS\n",
					pVc, pNdisPacket));
				AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
				NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count it

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
			}
			else
			{
				//
				//	Not sent, release lock, requeue packet, abort
				//
				DBGP((2, "DoBusSend: pVc %x, Flags %x not good, pkt %x\n",
						pVc, pVc->Flags, pNdisPacket));
				RELEASE_VC_LOCK(pVc);

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);
				break;
			}

		}
		while (FALSE);

		//
		//	Remove temp VC reference
		//
		if (pVc != NULL_PATMLANE_VC)
		{
			DBGP((2, "DoBusSends: Vc %p, ref %d, removing temp ref\n",
					pVc, pVc->RefCount));

			ACQUIRE_VC_LOCK(pVc);
			rc = AtmLaneDereferenceVc(pVc, "temp");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			//
			//	else VC is gone
			//
		}

	}
	while (FALSE);

	//
	//  Remove the temp ref we had added to the MAC entry on entering
	//  this function.
	//
	rc = AtmLaneDereferenceMacEntry(pMacEntry, "DoBusSends");
	if (rc != 0)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}
	//
	//  else the MAC entry is gone.
	//
	
	TRACEOUT(DoBusSends);
	return;
}

VOID
AtmLaneBusSendTimer(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						pContext,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	ULONG						rc;
	
	TRACEIN(BusSendTimer);

	pMacEntry = (PATMLANE_MAC_ENTRY)pContext;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	do
	{
		//
		// 	Grab the Mac Entry's lock
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//	Clear the bus timer flag
		//
		pMacEntry->Flags &= ~ MAC_ENTRY_BUS_TIMER;
		
		//
		//	Dereference the Mac Entry
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "bus timer");
		if (rc == 0)
		{
			break;
		}
		
		//
		//	Mac Entry still here, try to send more
		//
		AtmLaneDoBusSends(pMacEntry);
		//
		//	lock released in above
		//

		break;
		
	}
	while (FALSE);

	TRACEOUT(BusSendTimer);
	return;
}


BOOLEAN
AtmLaneOKToBusSend(
	IN	PATMLANE_MAC_ENTRY		pMacEntry
)
/*++

Routine Description:

	Determines if, at the current time, it is OK to send
	a packet to the BUS.  Additionally, if it is OK to send
	a packet, it updates the state variables in the MAC Entry
	in preparation for another attempt to send a packet to
	the Bus.

	The LANE spec requires a LANE client to restrict the
	sending of packets over the BUS to a specific LAN
	destination address	by using two parameters:
		Maximum Unknown Packet Count
		Maximum Unknown Packet Time
	A LANE client can only send "Maximum Unknown Packet Count"
	packets within the period of time "Maximum Unknown Packet 
	Time".  

	This function expects the MAC Entry to contain three
	variables:
    	BusyTime
    	LimitTime
    	IncrTime
			
Arguments:

	pMacEntry			- Pointer to an ATMLANE MAC Entry.

Return Value:

	TRUE				- if ok to send packet on BUS
	FALSE				- if exceeded traffic to the BUS

--*/
{
    ULONG	Now;
    ULONG	BusyTime;
    LONG	TimeUntilIdle;

    Now = AtmLaneSystemTimeMs();
    BusyTime = pMacEntry->BusyTime;
    TimeUntilIdle = BusyTime - Now;

	//
    // bring busy until time up to current; also handles
    // wrapping.  Under normal circumstances, TimeUntilIdle
    // is either < 0 or no more than limitTime + incrtime.
    // The value of limitTime * 8 is a little more conservative and
    // cheaper to compute.
    //
    if (TimeUntilIdle < 0 || 
    	TimeUntilIdle > (LONG)(pMacEntry->LimitTime << 3))
    {
		BusyTime = Now;
    }
    else 
    {
    	if (TimeUntilIdle > (LONG)pMacEntry->LimitTime) 
    	{
    		//
			// channel is already estimated to be busy until past
			// the burst time, so we can't overload it by sending
	 		// more now.
	 		//
		return FALSE;
    	}
    }
    
	//
    // mark channel as busy for another inter-packet arrival
    // time, and return OK to send the new packet.
    //
    pMacEntry->BusyTime = BusyTime + pMacEntry->IncrTime;
    return TRUE;
}



VOID
AtmLaneFreePacketQueue(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Frees the list of packets queued on a MAC Entry.
	Assumes caller holds lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to MAC Entry.
	Status				- The status to use if the packet is
						  protocol packet.

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;

	TRACEIN(FreePacketQueue);
	
	while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) != (PNDIS_PACKET)NULL)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);

#if PROTECT_PACKETS		
		ACQUIRE_SENDPACKET_LOCK(pNdisPacket);
		PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;
		PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
#endif	// PROTECT_PACKETS
		AtmLaneCompleteSendPacket(pMacEntry->pElan, pNdisPacket, Status);
		//
		//	packet lock released in above
		//
	
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	}

	TRACEOUT(FreePacketQueue);
	return;
}

VOID
AtmLaneCompleteSendPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket 	LOCKIN NOLOCKOUT,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Complete a send packet. The packet is one of the following types:
	(a) Belonging to a protocol (b) Belonging to the ATMLANE module. 
	In the case	of a protocol packet we unwrap it and complete it.
	In the case of an ATMLANE packet we just free it.

Arguments:

	pElan				- Pointer to ATMLANE Elan.
	pNdisPacket			- Pointer to the packet
	Status				- The status to use if the packet is
						  protocol packet.

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	PNDIS_PACKET			pProtNdisPacket;

	TRACEIN(CompleteSendPacket);

#if PROTECT_PACKETS
	//
	//	Assert that we can release and/or complete all resources for this packet
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & 
			(PACKET_RESERVED_COMPLETED | PACKET_RESERVED_COSENDRETURNED)) 
			== (PACKET_RESERVED_COMPLETED | PACKET_RESERVED_COSENDRETURNED));
#endif	// PROTECT_PACKETS

	//
	//	Determine originator of packet
	//
	if (IS_FLAG_SET(
				PSEND_RSVD(pNdisPacket)->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_ATMLANE
				))
	{
		//
		//  Packet originated by ATMLANE.  Free the buffer.
		//
		NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
		ASSERT(NULL != pNdisBuffer);
		AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		
		//
		//	Free the packet header.
		//
		DBGP((3, "CompleteSendPkt: Freeing AtmLane owned pkt %x\n", pNdisPacket));
#if PROTECT_PACKETS
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
		FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
		NdisFreePacket(pNdisPacket);

#if PKT_HDR_COUNTS
		InterlockedIncrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0 && 
			pElan->ProtPktCount != pElan->MaxProtocolBufs)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}
	else
	{
		//
		//	Packet orignated by a protocol. 
		//	Unwrap it.
		//	Complete it to the protocol.
		//	

		pProtNdisPacket = AtmLaneUnwrapSendPacket(pElan, pNdisPacket);
		//
		//	packet lock released in above
		//

		TRACELOGWRITE((&TraceLog, TL_MSENDCOMPL, pProtNdisPacket, Status));
		TRACELOGWRITEPKT((&TraceLog, pProtNdisPacket));

		// DBGP((0, "NdisMSendComplete: Pkt %x Stat %x\n", pProtNdisPacket, Status));

		NdisMSendComplete(
					pElan->MiniportAdapterHandle, 
					pProtNdisPacket, 
					Status);
	}

	TRACEOUT(CompleteSendPacket);
	return;
}


PWSTR
AtmLaneMacAddrToString(
	IN	VOID * pIn
)
{
    static PWSTR 	WHexChars = L"0123456789abcdef";
	PWSTR 			StrBuf;
	ULONG			Index;
	PWSTR			pWStr;
	PUCHAR			pMacAddr;
	PWSTR			punicodeMacAddrBuffer = ((PWSTR)0);

	UNICODE_STRING	unicodeString;
	ANSI_STRING 	ansiString;
	
	TRACEIN(MacAddrToString);

	//	alloc space for output unicode string

	ALLOC_MEM(&punicodeMacAddrBuffer, (((sizeof(MAC_ADDRESS) * 2) + 1) * sizeof(WCHAR)));

	if (((PWSTR)0) != punicodeMacAddrBuffer)
	{
    	for (Index = 0, pWStr = punicodeMacAddrBuffer, pMacAddr = pIn; 
    		Index < sizeof(MAC_ADDRESS); 
    		Index++, pMacAddr++)
        {
        	*pWStr++ = WHexChars[(*pMacAddr)>>4];
	        *pWStr++ = WHexChars[(*pMacAddr)&0xf];
	    }

	    *pWStr = L'\0';
	}

	TRACEOUT(MacAddrToString);
	
	return punicodeMacAddrBuffer;
}


PWSTR
AtmLaneAtmAddrToString(
	IN	PATM_ADDRESS pIn
)
{
    static PWSTR 	WHexChars = L"0123456789abcdef";
	PWSTR 			StrBuf;
	ULONG			Index;
	PWSTR			pWStr;
	PUCHAR			pAtmAddr;
	PWSTR			punicodeAtmAddrBuffer = ((PWSTR)0);

	UNICODE_STRING	unicodeString;
	ANSI_STRING 	ansiString;
	
	TRACEIN(AtmAddrToString);

	//	alloc space for output unicode string
	
	ALLOC_MEM(&punicodeAtmAddrBuffer, (((ATM_ADDRESS_LENGTH * 2) + 1) * sizeof(WCHAR)));

	if (((PWSTR)0) != punicodeAtmAddrBuffer)
	{
		//	format ATM addr into Unicode string buffer

    	for (Index = 0, pWStr = punicodeAtmAddrBuffer, pAtmAddr = pIn->Address; 
    		Index < pIn->NumberOfDigits;
    		Index++, pAtmAddr++)
        {
        	*pWStr++ = WHexChars[(*pAtmAddr)>>4];
	        *pWStr++ = WHexChars[(*pAtmAddr)&0xf];
	    }

	    *pWStr = L'\0';
	}

	TRACEOUT(AtmAddrToString);
	
	return punicodeAtmAddrBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\debug.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	debug.h

Abstract:

	This file contains debugging support declarations.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef __ATMLANE_DEBUG_H
#define __ATMLANE_DEBUG_H

#if DBG

#define DBG_OUTBUF_SIZE 128

extern ULONG 		DbgVerbosity;
extern ULONG 		DbgLogSize;

#if	DBG_TRACE
extern TRACELOG		TraceLog;
extern PUCHAR		pTraceLogSpace;
#endif

struct _string_table {
	PUCHAR string;
	ULONG value;
	};

extern struct _string_table oid_string_table[];

extern struct _string_table irp_string_table[];

#define DBGP(x) DbgOut x

extern
VOID
DbgOut(ULONG Level, PUCHAR Message, ...);

extern
PUCHAR
UnicodeToString(PUNICODE_STRING unicodeString);

extern
PUCHAR
MacAddrToString(PVOID In);

extern
PUCHAR
AtmAddrToString(PVOID In);

extern
PUCHAR
OidToString(ULONG Oid);

extern
PUCHAR
IrpToString(ULONG Irp);

VOID
DbgPrintHexDump(
	IN	ULONG			Level,
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
);

#define STRUCT_ASSERT(s, t)												\
		if ((s)->t##_sig != t##_signature) 								\
		{																\
			DbgPrint("Structure assertion failure at %p for type " #t 	\
					   " in file %s, line %d\n", s, __FILE__, __LINE__);\
			DbgBreakPoint();											\
		}
		
#if	DBG_TRACE

#define TRACELOGWRITE(x) TraceLogWrite x
#define TRACELOGWRITEPKT(x) TraceLogWritePkt x

extern
VOID
TraceLogWritePkt(
	IN	PTRACELOG		pTraceLog,
	IN	PNDIS_PACKET	pNdisPacket
);

#else

#define TRACELOGWRITE(x)

#define TRACELOGWRITEPKT(x)
#endif

#if MYASSERT

#undef ASSERT

#define ASSERT( exp ) \
    if (!(exp)) \
    { \
    	DbgPrint("Assertion Failed ("#exp") in file %s line %d\n", __FILE__, __LINE__); \
    	DbgBreakPoint(); \
	}
	
#endif


#else

#define DBGP(x)

#define MacAddrToString(x)

#define AtmAddrToString(x)

#define OidToString(x)

#define DbgPrintHexDump(x)

#define STRUCT_ASSERT(s, t)

#define TRACELOGWRITE(x)

#define TRACELOGWRITEPKT(x)

#endif


#ifdef TRACE

#define TRACEIN(x)  DBGP((5, "--> "#x"\n"))
#define TRACEOUT(x) DBGP((5, "<-- "#x"\n"))

#else

#define TRACEIN(x)  {}
#define TRACEOUT(x)	{}

#endif


#if DEBUG_IRQL

#define GET_ENTRY_IRQL(_Irql)			\
			_Irql = KeGetCurrentIrql()
			
#define CHECK_EXIT_IRQL(_EntryIrql)											\
		{																	\
			KIRQL _ExitIrql;												\
			_ExitIrql = KeGetCurrentIrql();									\
			if (_ExitIrql != _EntryIrql)									\
			{																\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, _ExitIrql, _EntryIrql);			\
				DbgBreakPoint();											\
			}																\
		}
#else

#define GET_ENTRY_IRQL(x)
#define CHECK_EXIT_IRQL(x)

#endif // DEBUG_IRQL


#if DEBUG_SPIN_LOCK

#define LOCK_FILE_NAME_LEN		48

typedef struct _ATMLANE_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	UCHAR					TouchedByFileName[LOCK_FILE_NAME_LEN];
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} ATMLANE_LOCK, *PATMLANE_LOCK;

#define ATMLANE_LOCK_SIG	'KCOL'

extern ULONG				SpinLockInitDone;
extern NDIS_SPIN_LOCK		LockLock;

extern
VOID
AtmLaneAllocateSpinLock(
    IN  PATMLANE_LOCK       pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneAcquireSpinLock(
    IN  PATMLANE_LOCK		pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneReleaseSpinLock(
    IN  PATMLANE_LOCK       pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneFreeSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
);

#else

#define ATMLANE_LOCK	NDIS_SPIN_LOCK
#define PATMLANE_LOCK	PNDIS_SPIN_LOCK

#endif	// DEBUG_SPIN_LOCK

#endif  //  __ATMLANE_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\elanproc.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	elanproc.c

Abstract:

Revision History:

Notes:

--*/


#include <precomp.h>
#pragma	hdrstop

VOID
AtmLaneEventHandler(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						pContext
)
/*++

Routine Description:

	Elan state machine event handler.

Arguments:

	pContext	- should be pointer to ATMLANE Elan 
	
Return Value:

	None

--*/
{
	PATMLANE_ELAN		pElan;
	PATMLANE_MAC_ENTRY	pMacEntry;
	PATMLANE_EVENT		pEvent;
	ULONG				Event;
	NDIS_STATUS			EventStatus;
	NDIS_STATUS			Status;
	NDIS_HANDLE			AdapterHandle;
	ULONG				rc;
	BOOLEAN				WasCancelled;
	PLIST_ENTRY			p;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	
#if DEBUG_IRQL
	GET_ENTRY_IRQL(EntryIrql);
	ASSERT(EntryIrql == PASSIVE_LEVEL);
#endif

	TRACEIN(EventHandler);

	//	Get the pointer to the Elan

	pElan = (PATMLANE_ELAN)pContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//	Lock the Elan

	ACQUIRE_ELAN_LOCK(pElan);

	//	Release the timer reference

	rc = AtmLaneDereferenceElan(pElan, "eventtimer");
	ASSERT(rc > 0);
	pElan->Flags &= ~ ELAN_EVENT_WORK_ITEM_SET;

	//	Remove the event at the head of the queue

	pEvent = AtmLaneDequeueElanEvent(pElan);

	if (pEvent == NULL)
	{
		RELEASE_ELAN_LOCK(pElan);
		CHECK_EXIT_IRQL(EntryIrql);
		return;
	}

	//	Save locally the important stuff
	
	Event = pEvent->Event;
	EventStatus = pEvent->EventStatus;

	// 	Free the event struct

	FREE_MEM(pEvent);

	//  Check if the ELAN is gone.
	if (rc == 1)
	{
		DBGP((0, "EventHandler: ELAN %x is gone!\n", pElan));
		CHECK_EXIT_IRQL(EntryIrql);
		return;
	}

	// 	If queue isn't empty schedule next event handler
	
	if (!IsListEmpty(&pElan->EventQueue))
	{
		NDIS_STATUS		NdisStatus;
		

		AtmLaneReferenceElan(pElan, "workitemevent");
		pElan->Flags |= ELAN_EVENT_WORK_ITEM_SET;

		p = pElan->EventQueue.Flink;
		pEvent = CONTAINING_RECORD(p, ATMLANE_EVENT, Link);
		NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);

		DBGP((0, " %d EventHandler: Multiple events queued, pElan %x, State %d, Flags %x, Ref %d, processing %d, queued event %d!\n",
				pElan->ElanNumber, pElan, pElan->State, pElan->Flags, pElan->RefCount, Event, pEvent->Event));
		NdisStatus = NdisScheduleWorkItem(&pElan->EventWorkItem);
		ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
	}
	
	switch (pElan->State)
	{
		//
		//	INIT STATE ---------------------------------------------------
		//
		case ELAN_STATE_INIT:

			switch (Event)
			{
				case ELAN_EVENT_START:

				
					DBGP((1, "%d INIT - START\n", pElan->ElanNumber));

					//
					//  Open Call Manager and get ATM address
					//

					//
					//  Make sure that ShutdownElan does not
					//  pre-empt us here.
					//
					pElan->Flags |= ELAN_OPENING_AF;
					AtmLaneReferenceElan(pElan, "openaf");
					INIT_BLOCK_STRUCT(&pElan->AfBlock);
					RELEASE_ELAN_LOCK(pElan);

					Status = AtmLaneOpenCallMgr(pElan);
					if (NDIS_STATUS_SUCCESS == Status)
					{
						AtmLaneGetAtmAddress(pElan);
					}

					ACQUIRE_ELAN_LOCK(pElan);
					rc = AtmLaneDereferenceElan(pElan, "openaf");
					if (rc != 0)
					{
						pElan->Flags &= ~ELAN_OPENING_AF;
						SIGNAL_BLOCK_STRUCT(&pElan->AfBlock, NDIS_STATUS_SUCCESS);
						RELEASE_ELAN_LOCK(pElan);
					}

					break;
				    
				case ELAN_EVENT_NEW_ATM_ADDRESS:

					DBGP((1, "%d INIT - NEW ATM ADDRESS\n", pElan->ElanNumber));

					if (!pElan->CfgUseLecs)
					{
						//
						//	If configured to NOT use an LECS then
						//  set ELAN vars from registry config vars 
						//  (normally established in ConfigResponseHandler)
						//  and advance to the LES CONNECT Phase.

						pElan->LanType = (UCHAR)pElan->CfgLanType;
						if (pElan->LanType == LANE_LANTYPE_UNSPEC)
						{
							pElan->LanType = LANE_LANTYPE_ETH;
						}
						pElan->MaxFrameSizeCode = (UCHAR)pElan->CfgMaxFrameSizeCode;
						if (pElan->MaxFrameSizeCode == LANE_MAXFRAMESIZE_CODE_UNSPEC)
						{
							pElan->MaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_1516;
						}
						switch (pElan->MaxFrameSizeCode)
						{
							case LANE_MAXFRAMESIZE_CODE_18190:
								pElan->MaxFrameSize = 18190;
								break;
							case LANE_MAXFRAMESIZE_CODE_9234:
								pElan->MaxFrameSize = 9234;
								break;
							case LANE_MAXFRAMESIZE_CODE_4544:
								pElan->MaxFrameSize = 4544;
								break;
							case LANE_MAXFRAMESIZE_CODE_1516:
							case LANE_MAXFRAMESIZE_CODE_UNSPEC:
							default:
								pElan->MaxFrameSize = 1516;
								break;
						}				

						if (pElan->LanType == LANE_LANTYPE_ETH)
						{
							pElan->MinFrameSize = LANE_MIN_ETHPACKET;
						}
						else
						{
							pElan->MinFrameSize = LANE_MIN_TRPACKET;
						}

						NdisMoveMemory(
								&pElan->LesAddress, 
								&pElan->CfgLesAddress,
								sizeof(ATM_ADDRESS));

						pElan->State = ELAN_STATE_LES_CONNECT;

						pElan->RetriesLeft = 4;

						AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
						RELEASE_ELAN_LOCK(pElan);
					}
					else
					{
						//
						// If configured to NOT discover the LECS then
						// advance to the LECS CONNECT CFG state.
						//
						if (!pElan->CfgDiscoverLecs)
						{
							pElan->State = ELAN_STATE_LECS_CONNECT_CFG;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);
						}
						else
						{
							//
							//	Otherwise, advance to LECS CONNECT ILMI state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_ILMI;
							
							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);
						}
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d INIT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d INIT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d INIT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));

					RELEASE_ELAN_LOCK(pElan);

					break;

			}

			break;

		//
		//	LECS CONNECT ILMI STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_ILMI:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT ILMI - START\n", pElan->ElanNumber));

					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_ILMI
							);

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneGetLecsIlmi(pElan);

					break;

				case ELAN_EVENT_GOT_ILMI_LECS_ADDR:

					DBGP((1, "%d LECS CONNECT ILMI - GOT ILMI LECS ADDR (%x)\n", 
						pElan->ElanNumber, EventStatus));

					if (EventStatus == NDIS_STATUS_SUCCESS)
					{
						RELEASE_ELAN_LOCK(pElan);
						//
						//	Attempt to connect to the LECS
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);
					}
					else
					{
						if (EventStatus == NDIS_STATUS_INTERFACE_DOWN)
						{
							//
							//  Wait for a while for the interface to come up.
							//
							DBGP((0, "%d LECS CONNECT ILMI - Interface down\n",
									pElan->ElanNumber));

							AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, NDIS_STATUS_SUCCESS, 2*1000);
						}
						else
						{
							//
							//	Otherwise advance to LECS CONNECT WKA state
							//

							pElan->State = ELAN_STATE_LECS_CONNECT_WKA;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						}

						RELEASE_ELAN_LOCK(pElan);

					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:
				
					DBGP((1, "%d LECS CONNECT ILMI - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_GOT_ILMI_LECS_ADDR, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Restart the Elan
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, advance to LECS CONNECT WKA state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_WKA;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT ILMI - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT ILMI - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LECS CONNECT ILMI - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT WKA STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_WKA:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT WKA - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS with Well-Known Address
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_WKA);
	
					NdisMoveMemory(
							&pElan->LecsAddress, 
							&gWellKnownLecsAddress,
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LECS CONNECT WKA - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							

							break;

						default: 

							//
							//	Call failed, advance to LECS CONNECT PVC state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_PVC;

							pElan->RetriesLeft = 2;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT WKA - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT WKA - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d LECS CONNECT WKA - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT PVC STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_PVC:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT PVC - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS using PVC (0,17)
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_PVC);
	
					NdisZeroMemory(
							&pElan->LecsAddress, 
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, TRUE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LECS CONNECT PVC - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 2;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							

							break;

						default: 

							//
							//	Call failed, Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT PVC - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT PVC - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d LECS CONNECT PVC - UNEXPECTED %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT CFG STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_CFG:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT CFG - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS with configured Address
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_CFG);
	
					NdisMoveMemory(
							&pElan->LecsAddress, 
							&pElan->CfgLecsAddress,
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:
				
					DBGP((1, "%d LECS CONNECT CFG - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, XXX What to do ??  Shutdown ?? Log ??
							//

							RELEASE_ELAN_LOCK(pElan);

							break;
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT CFG - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT CFG - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LECS CONNECT CFG - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
		
		//
		//	CONFIGURE STATE -------------------------------------------
		//
		case ELAN_STATE_CONFIGURE:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d CONFIGURE - START\n", pElan->ElanNumber));

					//
					//	Start configure request timer
					//
					AtmLaneReferenceElan(pElan, "timer"); // timer reference
					AtmLaneStartTimer(
							pElan, 
							&pElan->Timer, 
							AtmLaneConfigureResponseTimeout,
							pElan->ControlTimeout,
							pElan);
							
					RELEASE_ELAN_LOCK(pElan);
							
					//
					//	Send a configure request
					//
					AtmLaneSendConfigureRequest(pElan);
					
					break;

				case ELAN_EVENT_CONFIGURE_RESPONSE:

					DBGP((1, "%d CONFIGURE - CONFIGURE RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:
							//
							//	Stop configure request timer
							//
							if (AtmLaneStopTimer(&pElan->Timer, pElan))
							{
								rc = AtmLaneDereferenceElan(pElan, "timer");
								ASSERT(rc > 0);
							}								
					
							//
							//	Close the LECS Connection
							//
							RELEASE_ELAN_LOCK(pElan);
							ACQUIRE_ATM_ENTRY_LOCK(pElan->pLecsAtmEntry);
							AtmLaneInvalidateAtmEntry(pElan->pLecsAtmEntry);

							//
							//	Advance to LES CONNECT phase.
							//
							ACQUIRE_ELAN_LOCK(pElan);
						
							pElan->State = ELAN_STATE_LES_CONNECT;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
	
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_TIMEOUT:

							//
							//	Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
						
						case NDIS_STATUS_FAILURE:

							//
							//	Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
					} // switch (EventStatus)

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d CONFIGURE - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d CONFIGURE - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((1, "%d CONFIGURE - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));

					RELEASE_ELAN_LOCK(pElan);

					break;
			}

			break;

		//
		//	LES CONNECT STATE --------------------------------------------
		//
		case ELAN_STATE_LES_CONNECT:

			switch (Event)
			{
				case ELAN_EVENT_START:
				
					DBGP((1, "%d LES CONNECT - START\n", pElan->ElanNumber));
			
					//
					//	Register our SAPs
					//
					AtmLaneRegisterSaps(pElan);
					//
					//	Elan lock is released in above.
					//
					break;

				case ELAN_EVENT_SAPS_REGISTERED:
				
					DBGP((1, "%d LES CONNECT - SAPS REGISTERED (%x)\n",
						pElan->ElanNumber, EventStatus));

					if (NDIS_STATUS_SUCCESS == EventStatus)
					{
						pElan->RetriesLeft = 4;
						RELEASE_ELAN_LOCK(pElan);
						//
						//	Connect to the LES
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LES, FALSE);
						//
						//	Elan lock is released in above.
						//
					}
					else
					{
						// XXX - What to do?

						RELEASE_ELAN_LOCK(pElan);
					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LES CONNECT - LES CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	Advance to Join state
							//
							pElan->State = ELAN_STATE_JOIN;

							pElan->RetriesLeft = 4;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
					
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_SAPS_REGISTERED, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LES CONNECT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LES CONNECT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LES CONNECT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	JOIN STATE ---------------------------------------------------
		//
		case ELAN_STATE_JOIN:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d JOIN - START\n", pElan->ElanNumber));

					//
					//	Start join request timer
					//
					AtmLaneReferenceElan(pElan, "timer"); // timer reference
					AtmLaneStartTimer(
							pElan, 
							&pElan->Timer, 
							AtmLaneJoinResponseTimeout,
							pElan->ControlTimeout,
							pElan);

					RELEASE_ELAN_LOCK(pElan);
			
					//
					//	Send a Join request
					//
					AtmLaneSendJoinRequest(pElan);
					break;

				case ELAN_EVENT_JOIN_RESPONSE:

					DBGP((1, "%d JOIN - JOIN RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:
							//
							//	Stop join request timer
							//
							if (AtmLaneStopTimer(&pElan->Timer, pElan))
							{
								rc = AtmLaneDereferenceElan(pElan, "timer");
								ASSERT(rc > 0);
							}								
					
							//
							//	Advance to BUS CONNECT phase.
							//
							pElan->State = ELAN_STATE_BUS_CONNECT;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
	
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_TIMEOUT:
							//
							//	restart the Elan
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
						
						case NDIS_STATUS_FAILURE:
							//
							//	restart the Elan
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
					}
					
					break;
					
				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d JOIN - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	restart the Elan
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d JOIN - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d JOIN - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d JOIN - UNEXPECTED %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
		
			}
			break;
			
		//
		//	BUS CONNECT STATE ---------------------------------------------------
		//
		case ELAN_STATE_BUS_CONNECT:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d BUS CONNECT - START\n", pElan->ElanNumber));

					RELEASE_ELAN_LOCK(pElan);
			
					//
					//	Find or create a MAC entry for the Broadcast MAC Addr
					//
					ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
					pMacEntry = AtmLaneSearchForMacAddress(
											pElan, 
											LANE_MACADDRTYPE_MACADDR,
											&gMacBroadcastAddress, 
											TRUE);
					RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

					if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
					{
						break;
					}

					ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

					SET_FLAG(
							pMacEntry->Flags,
							MAC_ENTRY_STATE_MASK,
							MAC_ENTRY_ARPING);
							
					pMacEntry->Flags |= MAC_ENTRY_BROADCAST;
					

					//
					// Send ARP Request
					//
					AtmLaneStartTimer(
							pElan,
							&pMacEntry->Timer,
							AtmLaneArpTimeout,
							pElan->ArpResponseTime,
							(PVOID)pMacEntry
							);

					pMacEntry->RetriesLeft = pElan->MaxRetryCount;
					AtmLaneReferenceMacEntry(pMacEntry, "timer");
					pMacEntry->Flags |= MAC_ENTRY_ARPING;

					AtmLaneSendArpRequest(pElan, pMacEntry);
					//
					//	MAC Entry lock released in above
					//
							
					break;

				case ELAN_EVENT_ARP_RESPONSE:

					DBGP((1, "%d BUS CONNECT - ARP RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));
				
					if (NDIS_STATUS_SUCCESS == EventStatus)
					{
						pElan->RetriesLeft = 4;
						RELEASE_ELAN_LOCK(pElan);
						
						//
						//	Connect to the BUS
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_BUS, FALSE);
					}
					else
					{
						DBGP((2, "ELAN %d: NO ARP RESPONSE for BUS, restarting\n"));
						
						//
						//	restart the Elan
						//
						AtmLaneShutdownElan(pElan, TRUE);
						//
						//	lock released in above
						//
					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d BUS CONNECT - BUS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	Now connected to BUS, start the Operational phase
							//
							pElan->State = ELAN_STATE_OPERATIONAL;

							pElan->RetriesLeft = 4;

							AdapterHandle = pElan->MiniportAdapterHandle;
							
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							//
							//  Indicate media connect status if our miniport is up:
							//
							if (AdapterHandle != NULL)
							{
								NdisMIndicateStatus(
									AdapterHandle,
									NDIS_STATUS_MEDIA_CONNECT,
									(PVOID)NULL,
									0);
								
								NdisMIndicateStatusComplete(AdapterHandle);
							}

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_ARP_RESPONSE, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	return to the Init State in a little while
								//
				