c readonly Guid Table_Privileges            = new Guid(0xc8b52222,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Usage_Privileges"]/*' />
        static public readonly Guid Usage_Privileges            = new Guid(0xc8b52223,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Procedures"]/*' />
        static public readonly Guid Procedures                  = new Guid(0xc8b52224,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Schemata"]/*' />
        static public readonly Guid Schemata                    = new Guid(0xc8b52225,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Sql_Languages"]/*' />
        static public readonly Guid Sql_Languages               = new Guid(0xc8b52226,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Statistics"]/*' />
        static public readonly Guid Statistics                  = new Guid(0xc8b52227,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Tables"]/*' />
        static public readonly Guid Tables                      = new Guid(0xc8b52229,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Translations"]/*' />
        static public readonly Guid Translations                = new Guid(0xc8b5222a,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Provider_Types"]/*' />
        static public readonly Guid Provider_Types              = new Guid(0xc8b5222c,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Views"]/*' />
        static public readonly Guid Views                       = new Guid(0xc8b5222d,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.View_Column_Usage"]/*' />
        static public readonly Guid View_Column_Usage           = new Guid(0xc8b5222e,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.View_Table_Usage"]/*' />
        static public readonly Guid View_Table_Usage            = new Guid(0xc8b5222f,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Procedure_Parameters"]/*' />
        static public readonly Guid Procedure_Parameters        = new Guid(0xc8b522b8,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Foreign_Keys"]/*' />
        static public readonly Guid Foreign_Keys                = new Guid(0xc8b522c4,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Primary_Keys"]/*' />
        static public readonly Guid Primary_Keys                = new Guid(0xc8b522c5,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Procedure_Columns"]/*' />
        static public readonly Guid Procedure_Columns           = new Guid(0xc8b522c9,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        // MDAC 2.6
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Table_Statistics"]/*' />
        static public readonly Guid Table_Statistics            = new Guid(0xc8b522ff,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        
        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.Check_Constraints_By_Table"]/*' />
        static public readonly Guid Check_Constraints_By_Table  = new Guid(0xc8b52301,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#if SCHEMAINFO
        // <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.SchemaGuids"]/*' />
        //static public readonly Guid SchemaGuids                 = new Guid(0xf3264c9b,0x1860,0x4dfe,0xb7,0x1b,0x29,0x61,0xb2,0xea,0x91,0xbd);
        
        // <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.DbInfoKeywords"]/*' />
        //static public readonly Guid DbInfoKeywords              = new Guid(0xf3264c9c,0x1860,0x4dfe,0xb7,0x1b,0x29,0x61,0xb2,0xea,0x91,0xbd);
#endif

        /// <include file='doc\OleDbSchemaGuid.uex' path='docs/doc[@for="OleDbSchemaGuid.DbInfoLiterals"]/*' />
        static public readonly Guid DbInfoLiterals              = new Guid(0xf3264c9d,0x1860,0x4dfe,0xb7,0x1b,0x29,0x61,0xb2,0xea,0x91,0xbd);

        static internal string GetTextFromValue(Guid guid) { // UNDONE MDAC 74085
            // it is correct that SchemaGuids, DbInfoKeywords, DbInfoLiterals don't appear below
            // those are manufactured guids for calling methods other than IDBSchemaRowset.GetRowset
            // when the user calls OleDbConnection.GetOleDbSchemaTable

            if (guid == Primary_Keys) { return "Primary_Keys"; }
            if (guid == Indexes) { return "Indexes"; }
            if (guid == Procedure_Parameters) { return "Procedure_Parameters"; }
            if (guid == Procedures) { return "Procedures"; }

            if (guid == Tables_Info) { return "Tables_Info"; }

            if (guid == Trustee) { return "Trustee"; }
            if (guid == Assertions) { return "Assertions"; }
            if (guid == Catalogs) { return "Catalogs"; }
            if (guid == Character_Sets) { return "Character_Sets"; }
            if (guid == Collations) { return "Collations"; }
            if (guid == Columns) { return "Columns"; }
            if (guid == Check_Constraints) { return "Check_Constraints"; }
            if (guid == Constraint_Column_Usage) { return "Constraint_Column_Usage"; }
            if (guid == Constraint_Table_Usage) { return "Constraint_Table_Usage"; }
            if (guid == Key_Column_Usage) { return "Key_Column_Usage"; }
            if (guid == Referential_Constraints) { return "Referential_Constraints"; }
            if (guid == Table_Constraints) { return "Table_Constraints"; }
            if (guid == Column_Domain_Usage) { return "Column_Domain_Usage"; }
            if (guid == Column_Privileges) { return "Column_Privileges"; }
            if (guid == Table_Privileges) { return "Table_Privileges"; }
            if (guid == Usage_Privileges) { return "Usage_Privileges"; }
            if (guid == Schemata) { return "Schemata"; }
            if (guid == Sql_Languages) { return "Sql_Languages"; }
            if (guid == Statistics) { return "Statistics"; }
            if (guid == Tables) { return "Tables"; }
            if (guid == Translations) { return "Translations"; }
            if (guid == Provider_Types) { return "Provider_Types"; }
            if (guid == Views) { return "Views"; }
            if (guid == View_Column_Usage) { return "View_Column_Usage"; }
            if (guid == View_Table_Usage) { return "View_Table_Usage"; }
            if (guid == Foreign_Keys) { return "Foreign_Keys"; }
            if (guid == Procedure_Columns) { return "Procedure_Columns"; }

            if (guid == Table_Statistics) { return "Table_Statistics"; }
            if (guid == Check_Constraints_By_Table) { return "Check_Constraints_By_Table"; }

            return "{" + guid.ToString() + ")";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\poolmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="PoolManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal sealed class PoolManager {
        private Hashtable _map;     // Hashtable used for SQL Authenticated connections
        private Hashtable _mapSSPI; // Hashtable used for Integrated Security connections

        public PoolManager() {
            _map     = new Hashtable();
            _mapSSPI = new Hashtable();
        }

        public ConnectionPool FindOrCreatePool(DefaultPoolControl ctrl) {
            Debug.Assert(ctrl != null,             "Unexpected DefaultPoolControl null!");
            // Should not be calling this FindOrCreatePool if using integrated security.
            Debug.Assert(!ctrl.IntegratedSecurity, "Using integrated security and wrong FindOrCreatePool called");
            
            String         poolKey = ctrl.Key;
            ConnectionPool pool    = FindPool(poolKey);

            if (pool == null) {
                try {
                    lock (_map.SyncRoot) {
                        // Did somebody else created it while we were waiting?
                        pool = FindPool(poolKey);

                        if (pool == null) {
                            // Create a new pool, shove it into the map:
                            pool = new ConnectionPool(ctrl);
                            _map[poolKey] = pool;
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }

            return(pool);
        }

        public ConnectionPool FindOrCreatePool(DefaultPoolControl ctrl, IntPtr SID) {
            Debug.Assert(ctrl != null,            "Unexpected DefaultPoolControl null!");
            Debug.Assert(ctrl.IntegratedSecurity, "DefaultPoolControl unexpectedly not using integrated security");
            Debug.Assert(!SQL.IsPlatformWin9x(),  "FindOrCreatePool that expects not 9x called on 9x!");
            Debug.Assert(SID  != IntPtr.Zero,     "Unexpected SID == IntPtr.Zero!");
            
            String         poolKey = ctrl.Key;
            ConnectionPool pool    = FindPool(poolKey, SID);

            if (pool == null) {
                try {
                    lock (_mapSSPI.SyncRoot) {
                        // Did somebody else created it while we were waiting?
                        pool = FindPool(poolKey, SID);

                        if (pool == null) {
                            // Create a new pool, shove it into the map:
                            pool = new ConnectionPool(ctrl);
                            ArrayList items = (ArrayList) _mapSSPI[poolKey];
                            if (null == items) {
                                items             = new ArrayList();
                                _mapSSPI[poolKey] = items;
                            }

                            items.Add(pool);
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }

            return pool;
        }


        public ConnectionPool FindPool(String key) {
            // Returns null if the pool does not exist.
            return (ConnectionPool)(_map[key]);
        }

        public ConnectionPool FindPool(String key, IntPtr SID) {
            // Returns null if the pool does not exist.
            ArrayList items = (ArrayList)(_mapSSPI[key]);

            if (null != items) {
                object[]       pools  = items.ToArray();
                int            length = pools.Length;
                ConnectionPool pool   = null;
                
                for (int i=0; i<length; i++) {
                    pool = (ConnectionPool) pools[i];
                    if (pool.Control.EqualSid(SID)) {
                        return pool;
                    }
                }
            }

            return null;
        }

        /*
        This is the previous implementation that has pool shutdown and requires a reader-
        writer lock.  Move to this implementation when pools do shutdown and go away.

        private ReaderWriterLock _rwlock; // instantiate in constructor

        public ConnectionPool FindOrCreatePool(DefaultPoolControl ctrl)
        {
            String poolKey      = ctrl.Key;
            ConnectionPool pool = FindPool(poolKey);
            if(pool != null) return(pool);
            
            try
            {
                _rwlock.AcquireWriterLock(-1);

                // Did somebody else created it while we were waiting?
                pool = (ConnectionPool)(_map[poolKey]);
                if(pool == null)
                {
                    // Create a new pool, shove it into the map:
                    pool = new ConnectionPool(ctrl);
                    _map[poolKey] = pool;
                }
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }
            }
            return(pool);
        }

        public ConnectionPool FindPool(String key)
        {
            ConnectionPool pool = null;

            // Returns null if the pool does not exist.
            try
            {
                _rwlock.AcquireReaderLock(-1);

                pool = (ConnectionPool)(_map[key]);
            }
            finally
            {
                try {
                    _rwlock.ReleaseReaderLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }
            }
            return(pool);
        }


        // Currently this is never called - since pools do not go away!
        public void ShutdownPool(String poolKey)
        {
            try {
                _rwlock.AcquireWriterLock(-1);

                ConnectionPool p = (ConnectionPool)(_map[poolKey]);
                if(p != null)
                {
                    p.Shutdown();
                    _map[poolKey] = null;
                    _map.Remove(poolKey);
                }
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }            
            }
        }

        // Currently this is never called - since pools do not go away!
        public void Shutdown()
        {
            try {
                _rwlock.AcquireWriterLock(-1);

                foreach(DictionaryEntry e in _map)
                {
                    ConnectionPool p = (ConnectionPool)(e.Value);
                    if(p != null)
                    {
                        p.Shutdown();
                    }
                }
                _map.Clear();
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.                
                }
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlcommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Configuration.Assemblies;
    using System.Data;
    using System.Data.Common;
    using System.Data.OleDb;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.Serialization.Formatters;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using System.Xml;
    using System.Globalization;
    
    /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand"]/*' />
    [
    ToolboxItem(true),
    Designer("Microsoft.VSDesigner.Data.VS.SqlCommandDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    sealed public class SqlCommand : Component, IDbCommand, ICloneable {

        // execution types
        private const byte xtEXECSQL = 0;  // both 7.0 and 7.x, not sharing a connection
        private const byte xtEXEC = 1;     // 7.0 only sharing connection
        private const byte xtPREPEXEC = 2; // 7.x only, sharing connection

        private string cmdText = string.Empty;
        private System.Data.CommandType cmdType = System.Data.CommandType.Text;
        private int _timeout = ADP.DefaultCommandTimeout;
        private UpdateRowSource _updatedRowSource = UpdateRowSource.Both;
        
        private bool _inPrepare = false;
        private int _handle = -1; // prepared handle (used only in 7.5)

        private SqlParameterCollection _parameters;
        private SqlConnection _activeConnection;
        private bool _dirty = false; // true if the user changes the commandtext or number of parameters after the command is already prepared
        private byte _execType = xtEXECSQL; // by default, assume the user is not sharing a connection so the command has not been prepared

        // cut down on object creation and cache all these
        // cached metadata
        private _SqlMetaData[] _cachedMetaData;
//        private string[] _cachedTableNames;
        // private DataTable _cachedSchemaTable;
        
        
        // sql reader will pull this value out for each NextResult call.  It is not cumulative
        internal int _rowsAffected = -1; // rows affected by the command

        // internal autogen for fixup, only manipulated by SqlDataAdapter::AutoGen* and SqlDataAdapter::Fixup*
        bool designTimeVisible;

        // transaction support
        private SqlTransaction _transaction;

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.SqlCommand"]/*' />
        public SqlCommand() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.SqlCommand1"]/*' />
        public SqlCommand(string cmdText) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.SqlCommand2"]/*' />
        public SqlCommand(string cmdText, SqlConnection connection) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection = connection;
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.SqlCommand3"]/*' />
        public SqlCommand(string cmdText, SqlConnection connection, SqlTransaction transaction) : base() {
            GC.SuppressFinalize(this);
            CommandText = cmdText;
            Connection = connection;
            Transaction = transaction;
        }
        

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.Connection"]/*' />
        [
        DataCategory(Res.DataCategory_Behavior),
        DefaultValue(null),
        DataSysDescription(Res.DbCommand_Connection),
        Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public SqlConnection Connection {
            get {
                return _activeConnection;
            }
            set {
                // Check to see if the currently set transaction has completed.  If so, 
                // null out our local reference.
                if (null != _transaction && _transaction._sqlConnection == null)
                    _transaction = null;

                if (_activeConnection != null && _activeConnection.Reader != null) {
                    throw ADP.CommandIsActive(this, ConnectionState.Open | ConnectionState.Fetching);
                }

                _activeConnection = value; // UNDONE: Designers need this setter.  Should we block other scenarios?
            }
        }

#if V2
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.Connection"]/*' />
        /// <internalonly/>
        ISqlConnection ISqlCommand.Connection {
            get {
                return _activeConnection;
            }
            set {
                Connection = (SqlConnection) value;
            }
        }
#endif 

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbCommand.Connection {
            get {
                return _activeConnection;
            }
            set {
                Connection = (SqlConnection) value;
            }
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.Transaction"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DbCommand_Transaction)
        ]
        public SqlTransaction Transaction {
            get {
                // if the transaction object has been zombied, just return null
                if ((null != _transaction) && (null == _transaction.Connection)) { // MDAC 72720
                    _transaction = null;
                }
                return _transaction;
            }
            set {
                if (_activeConnection != null && _activeConnection.Reader != null) {
                    throw ADP.CommandIsActive(this, ConnectionState.Open | ConnectionState.Fetching);
                }
                
                _transaction = value;
            }
        }

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.Transaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbCommand.Transaction {
            get {
                return _transaction;
            }
            set {
                Transaction = (SqlTransaction) value;
            }
        }

#if V2        
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.Transaction"]/*' />
        /// <internalonly/>
        ISqlTransaction ISqlCommand.Transaction {
            get {
                return _transaction;
            }
            set {
                Transaction = (SqlTransaction) value;
            }
        }
#endif
        

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.CommandText"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DbCommand_CommandText),
        Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlCommandTextEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
        RefreshProperties(RefreshProperties.All) // MDAC 67707
        ]
        public string CommandText {
            get {
                return this.cmdText;
            }
            set {
                if (value != this.cmdText) {
                    OnSchemaChanging(); // fire event before validation
                    this.cmdText = (null != value) ? value : ADP.StrEmpty;
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.CommandType"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(System.Data.CommandType.Text),
        DataSysDescription(Res.DbCommand_CommandType),
        RefreshProperties(RefreshProperties.All)
        ]
        public CommandType CommandType {
            get {
                return cmdType;
            }
            set {
                if (this.cmdType != value) {
                    OnSchemaChanging(); // fire event before validation

                    // bug 48565, don't allow TableDirect as a command type
                    if (System.Data.CommandType.TableDirect == value) {
                        throw SQL.TableDirectNotSupported();
                    }
                    // prior check used Enum.IsDefined below, but changed to the following since perf was poor
                    if (value != CommandType.Text && value != CommandType.StoredProcedure) {
                        throw ADP.InvalidCommandType(value);
                    }
                    this.cmdType = value;
                    //OnSchemaChanged();
                }
            }
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.CommandTimeout"]/*' />
        [
        DefaultValue(ADP.DefaultCommandTimeout),
        DataSysDescription(Res.DbCommand_CommandTimeout)
        ]
        public int CommandTimeout {
            get {
                return _timeout;
            }
            set {
                if (value < 0)
                    throw ADP.InvalidCommandTimeout(value);
                _timeout = value;
            }
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.DesignTimeVisible"]/*' />
        [
        DefaultValue(true),
        DesignOnly(true),
        Browsable(false),
        ]
        public bool DesignTimeVisible {
            get {
                return !this.designTimeVisible;
            }
            set {
                    this.designTimeVisible = !value;
                    // vs 208845
                    TypeDescriptor.Refresh(this);
            }
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.Parameters"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataSysDescription(Res.DbCommand_Parameters)
        ]
        public SqlParameterCollection Parameters {
            get {
                if (null == this._parameters) {
                    // delay the creation of the SqlParameterCollection
                    // until user actually uses the Parameters property
                    this._parameters = new SqlParameterCollection(this);
                }
                return this._parameters;
            }
        }

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.Parameters"]/*' />
        /// <internalonly/>
        IDataParameterCollection IDbCommand.Parameters {
            get {
                if (null == this._parameters) {
                    this._parameters = new SqlParameterCollection(this);
                }
                return this._parameters;
            }
        }

#if V2        
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.Parameters"]/*' />
        /// <internalonly/>
        ISqlParameterCollection ISqlCommand.Parameters {
            get {
                if (null == this._parameters) {
                    this._parameters = new SqlParameterCollection(this);
                }
                return this._parameters;
            }
        }
#endif
        
        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ResetCommandTimeout"]/*' />
        public void ResetCommandTimeout() {
            _timeout = ADP.DefaultCommandTimeout;
        }
        

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.UpdatedRowSource"]/*' />
        [
        DataCategory(Res.DataCategory_Behavior),
        DefaultValue(System.Data.UpdateRowSource.Both),
        DataSysDescription(Res.DbCommand_UpdatedRowSource)
        ]
        public UpdateRowSource UpdatedRowSource {
            get {
                return _updatedRowSource;
            }
            set {
                // prior check used Enum.IsDefined below, but changed to the following since perf was poor
                if (value < UpdateRowSource.None || value > UpdateRowSource.Both) {
                    throw ADP.InvalidUpdateRowSource((int) value);
                }
                _updatedRowSource = value;
            }
        }

        //internal void OnSchemaChanged() {
        //}

        internal void OnSchemaChanging() { // also called from SqlParameterCollection
            this.IsDirty = true;
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.Prepare"]/*' />
        public void Prepare() {
            SqlConnection.SqlClientPermission.Demand();

            // only prepare if batch with parameters
            // MDAC BUG #'s 73776 & 72101
            if (this.IsPrepared || (this.CommandType == CommandType.StoredProcedure) ||
               ((System.Data.CommandType.Text == this.CommandType) && (0 == GetParameterCount())))
                return; 

            ValidateCommand(ADP.Prepare, true);

            // Loop through parameters ensuring that we do not have unspecified types, sizes, scales, or precisions
            if (null != _parameters) {
                int count = _parameters.Count;
                for (int i = 0; i < count; ++i) {
                    _parameters[i].Prepare(this); // MDAC 67063
                }
            }

            SqlDataReader r = Prepare(0);
            if (r != null) {
                _cachedMetaData = r.MetaData;
                r.Close();
            }
        }

        private SqlDataReader Prepare(CommandBehavior behavior) {
        	SqlDataReader r = null;

            if (this.IsDirty) {
                Debug.Assert(_cachedMetaData == null, "dirty query should not have cached metadata!");
                //
                // someone changed the command text or the parameter schema so we must unprepare the command
                //
                this.Unprepare();
                this.IsDirty = false;
            }

            Debug.Assert(_execType != xtEXEC, "Invalid attempt to Prepare already Prepared command!");
            Debug.Assert(_activeConnection != null, "must have an open connection to Prepare");
            Debug.Assert(null != _activeConnection.Parser, "TdsParser class should not be null in Command.Execute!");
            Debug.Assert(false == _inPrepare, "Already in Prepare cycle, this.inPrepare should be false!");

            if (_activeConnection.IsShiloh) {
                // In Shiloh, remember that the user wants to do a prepare
                // but don't actually do an rpc
                _execType = xtPREPEXEC;

                // return null results
            }
            else {
                _SqlRPC rpc = BuildPrepare(behavior);
                _inPrepare = true;
                Debug.Assert(_activeConnection.State == ConnectionState.Open, "activeConnection must be open!");
                r = new SqlDataReader(this);
                try {
                    _activeConnection.Parser.TdsExecuteRPC(rpc, this.CommandTimeout, false);
                    _activeConnection.Parser.Run(RunBehavior.UntilDone, this, r);
                }
                catch (Exception e) {
                    // In case Prepare fails, cleanup and then throw.
                    _inPrepare = false;
                    throw e;
                }

                r.Bind(_activeConnection.Parser);
                Debug.Assert(-1 != _handle, "Handle was not filled in!");
                _execType = xtEXEC;
            }

            // let the connection know that it needs to unprepare the command on close
            _activeConnection.AddPreparedCommand(this);
            return r;
        }

        internal void Unprepare() {
            Debug.Assert(true == IsPrepared, "Invalid attempt to Unprepare a non-prepared command!");
            Debug.Assert(_activeConnection != null, "must have an open connection to UnPrepare");
            Debug.Assert(null != _activeConnection.Parser, "TdsParser class should not be null in Command.Unprepare!");
            Debug.Assert(false == _inPrepare, "_inPrepare should be false!");

            // In 7.0, unprepare always.  In 7.x, only unprepare if the connection is closing since sp_prepexec will
            // unprepare the last used handle
            if (_activeConnection.IsShiloh && !_activeConnection.IsClosing) {
                _execType = xtPREPEXEC;
                // @devnote:  Don't zero out the handle because we'll pass it in to sp_prepexec on the
                // @devnote:  next prepare
            }
            else {
                if (_handle != -1) {
                    if (_activeConnection.Parser.State != TdsParserState.Broken &&
                        _activeConnection.Parser.State != TdsParserState.Closed) {
                        // This can be called in the case of close, so check to ensure that parser
                        // is in a good state before using it.
                        _SqlRPC rpc = BuildUnprepare();
                        _activeConnection.Parser.TdsExecuteRPC(rpc, this.CommandTimeout, false);
                        _activeConnection.Parser.Run(RunBehavior.UntilDone, this);
                    }
                    // reset our handle
                    _handle = -1;
                }
                // reset our execType since nothing is prepared
                _execType = xtEXECSQL;
            }

            _cachedMetaData = null;
            _activeConnection.RemovePreparedCommand(this);
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.Cancel"]/*' />
        public void Cancel() {
			// see if we have a connection
            if (null == _activeConnection) {
                throw ADP.ConnectionRequired(ADP.Cancel);
            }

            // must have an open and available connection
            if (ConnectionState.Open != _activeConnection.State)
                throw ADP.OpenConnectionRequired("Cancel", _activeConnection.State);

            // the pending data flag means that we are awaiting a response or are in the middle of proccessing a response
            // if we have no pending data, then there is nothing to cancel
            // if we have pending data, but it is not a result of this command, then we don't cancel either.  Note that
            // this model is implementable because we only allow one active command at any one time.  This code 
            // will have to change we allow multiple outstanding batches
            if ( (this == _activeConnection.Parser.PendingCommand) &&
            	_activeConnection.Parser.PendingData ) {
            	_activeConnection.Parser.SendAttention();
            }
        }

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.CreateParameter"]/*' />
        /// <internalonly/>
        IDbDataParameter IDbCommand.CreateParameter() { // MDAC 68310
            return new SqlParameter();
        }

#if V2       
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.CreateParameter"]/*' />
        /// <internalonly/>
        ISqlParameter ISqlCommand.CreateParameter() {
            return new SqlParameter();
        }
#endif
        
        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.CreateParameter"]/*' />
        public SqlParameter CreateParameter() {
            return new SqlParameter();
        }

#if V2        
        // UNDONE: when this is implemented, return a SqlResultset
        // and hide the ISqlResultset method by explicit interface implementation
        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteResultset"]/*' />

        public ISqlResultset ExecuteResultset(int options) {
            throw ADP.NotSupported();
        }
#endif
        
        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteScalar"]/*' />
        public object ExecuteScalar() {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961

            object retResult = null;

            // ValidateCommand(ADP.ExecuteScalar, true); // UNDONE: validate for ExecuteScalar not ExecuteReader
            try {
                using(SqlDataReader ds = this.ExecuteReader(0, RunBehavior.ReturnImmediately, true)) {
                    if (ds.Read()) {
                        if (ds.FieldCount > 0)
                            retResult = ds.GetValue(0);
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
            return retResult;
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteNonQuery"]/*' />
        public int ExecuteNonQuery() {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961

            // only send over SQL Batch command if we are not a stored proc and have no parameters
            if ((System.Data.CommandType.Text == this.CommandType) && (0 == GetParameterCount())) {
                _rowsAffected = -1;

                // @devnote: this function may throw for an invalid connection
                // @devnote: returns false for empty command text
                ValidateCommand(ADP.ExecuteNonQuery, true);

                try {
                    // we just send over the raw text with no annotation
                    // no parameters are sent over
                    // no data reader is returned
                    // use this overload for "batch SQL" tds token type
                    _activeConnection.Parser.TdsExecuteSQLBatch(this.CommandText, this.CommandTimeout);
                    _activeConnection.Parser.Run(RunBehavior.UntilDone, this, null);
                }
                catch (Exception e) {
                    SQL.IncrementFailedCommandCount();
                
                    throw e;
                }        
            }
            else  { // otherwise, use full-blown execute which can handle params and stored procs
                SqlDataReader reader = this.ExecuteReader(0, RunBehavior.UntilDone, false);
                if (null != reader) {
                    reader.Close();
                    GC.SuppressFinalize(reader);
                }
            }
            return _rowsAffected;
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteXmlReader"]/*' />
        public XmlReader ExecuteXmlReader() {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961

            // use the reader to consume metadata
            SqlDataReader r = this.ExecuteReader(CommandBehavior.SequentialAccess, RunBehavior.ReturnImmediately, true);
            XmlReader xr = null;
            _SqlMetaData[] md = r.MetaData;

            if (md.Length == 1 && md[0].type == SqlDbType.NText) {
                try {
                    SqlStream fragment = new SqlStream(r, true /* add unicode byte order mark */);
                    xr = new XmlTextReader(fragment, XmlNodeType.Element, null); 
                }
                catch (Exception e) {
                    r.Close();
                    throw e;
                }
            }
            else {
                r.Close();
                throw SQL.NonXmlResult();
            }

            return xr;
        }
        
        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteReader"]/*' />
        public SqlDataReader ExecuteReader() {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961
            return this.ExecuteReader(0, RunBehavior.ReturnImmediately, true);
        }

#if V2
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.ExecuteReader"]/*' />
        /// <internalonly/>
        ISqlReader ISqlCommand.ExecuteReader() {
            return ExecuteReader();
        }
#endif

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.ExecuteReader"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader() {
            return ExecuteReader();
        }

#if V2
        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.ISqlCommand.ExecuteReader1"]/*' />
        /// <internalonly/>
        ISqlReader ISqlCommand.ExecuteReader(CommandBehavior behavior) {
            return ExecuteReader(behavior);
        }
#endif

        /// <include file='doc\SqlCommand.uex' path='docs/doc[@for="SqlCommand.IDbCommand.ExecuteReader1"]/*' />
        /// <internalonly/>
        IDataReader IDbCommand.ExecuteReader(CommandBehavior behavior) {
            return ExecuteReader(behavior);
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ExecuteReader1"]/*' />
        public SqlDataReader ExecuteReader(CommandBehavior behavior) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961
            return this.ExecuteReader(behavior, RunBehavior.ReturnImmediately, true);
        }

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ResetParameters"]/*' />
        internal void DeriveParameters() {
            switch (this.CommandType) {
                case System.Data.CommandType.Text:
                    throw ADP.DeriveParametersNotSupported(this);
                case System.Data.CommandType.StoredProcedure:
                    break;
                case System.Data.CommandType.TableDirect:
                    // CommandType.TableDirect - do nothing, parameters are not supported
                    throw ADP.DeriveParametersNotSupported(this);
                default:
                    throw ADP.InvalidCommandType(this.CommandType);
            }

            // validate that we have a valid connection
            ValidateCommand(ADP.DeriveParameters, false);

            // Use common parser for SqlClient and OleDb - parse into 3 parts - Catalog, Schema, ProcedureName
            string[] parsedSProc = ADP.ParseProcedureName(this.CommandText);

            Debug.Assert(parsedSProc.Length == 4, "Invalid array length result from ADP.ParseProcedureName");

            SqlCommand paramsCmd = null;

            // To enable fully qualified names, we must call the stored proc as [Catalog]..ProcedureName, if given
            // a Catalog.  Schema is ignored for StoredProcs.
            if (parsedSProc[1] != null) {
                // Catalog is 2nd element in parsed array
                cmdText = "[" + parsedSProc[1] + "].." + TdsEnums.SP_PARAMS;

                // Server is 1st element in parsed array
                if (parsedSProc[0] != null) {
                    cmdText = parsedSProc[0] + "." + cmdText;
                }
                
                paramsCmd = new SqlCommand(cmdText, this.Connection);
            }
            else {
                paramsCmd = new SqlCommand(TdsEnums.SP_PARAMS, this.Connection);
            }
                
            paramsCmd.CommandType = CommandType.StoredProcedure;
            paramsCmd.Parameters.Add(new SqlParameter("@procedure_name", SqlDbType.NVarChar, 255));
            paramsCmd.Parameters[0].Value = parsedSProc[3]; // ProcedureName is 4rd element in parsed array
            ArrayList parameters = new ArrayList();

            try {
                try {
                    using(SqlDataReader r = paramsCmd.ExecuteReader()) {
                        SqlParameter p = null;

                        while (r.Read()) {
                            // each row corresponds to a parameter of the stored proc.  Fill in all the info

                            // fill in name and type
                            p = new SqlParameter();
                            p.ParameterName = (string) r[ODB.PARAMETER_NAME];
                            p.SqlDbType = MetaType.GetSqlDbTypeFromOleDbType((short)r[ODB.DATA_TYPE], (string) r[ODB.TYPE_NAME]);

                            // size
                            object a = r[ODB.CHARACTER_MAXIMUM_LENGTH];
                            if (a is int) {
                                p.Size = (int)a;
                            }

                            // direction
                            p.Direction = ParameterDirectionFromOleDbDirection((short)r[ODB.PARAMETER_TYPE]);

                            if (p.SqlDbType == SqlDbType.Decimal) {
                                p.Scale = (byte) ((short)r[ODB.NUMERIC_SCALE] & 0xff);
                                p.Precision = (byte) ((short)r[ODB.NUMERIC_PRECISION] & 0xff);
                            }

                            parameters.Add(p);
                        }
                    }
                }
                finally { // Connection=
                    // always unhook the user's connection
                    paramsCmd.Connection = null;
                }
            }
            catch { // MDAC 80973, 82425
                throw;
            }

            if (parameters.Count == 0) {
                throw ADP.NoStoredProcedureExists(this.CommandText);
            }

            this.Parameters.Clear();

            foreach (object temp in parameters) {
                this._parameters.Add(temp);
            }
        }

        private ParameterDirection ParameterDirectionFromOleDbDirection(short oledbDirection) {
            Debug.Assert(oledbDirection >= 1 && oledbDirection <= 4, "invalid parameter direction from params_rowset!");

            switch (oledbDirection) {
                case 2:
                    return ParameterDirection.InputOutput;
                case 3:
                    return ParameterDirection.Output;
                case 4:
                    return ParameterDirection.ReturnValue;
                default:
                    return ParameterDirection.Input;
            }
            
        }

        // get cached metadata
        internal _SqlMetaData[] MetaData {
            get {
                return _cachedMetaData;
            }
        }
        
        internal SqlDataReader ExecuteReader(CommandBehavior cmdBehavior, RunBehavior runBehavior, bool returnStream) {
            SqlDataReader ds = null;
            _rowsAffected = -1;
            bool inSchema =  (0 != (cmdBehavior & CommandBehavior.SchemaOnly));

            if (0 != (CommandBehavior.SingleRow & cmdBehavior)) {
                // CommandBehavior.SingleRow implies CommandBehavior.SingleResult
                cmdBehavior |= CommandBehavior.SingleResult;
            }

            // @devnote: this function may throw for an invalid connection
            // @devnote: returns false for empty command text
            ValidateCommand(ADP.ExecuteReader, true);

            // make sure we have good parameter information
            // prepare the command
            // execute
            Debug.Assert(null != _activeConnection.Parser, "TdsParser class should not be null in Command.Execute!");

            // create a new RPC
            _SqlRPC rpc;

            string setOptions = null;

            try {
                if ((System.Data.CommandType.Text == this.CommandType) && (0 == GetParameterCount())) {
                    // Send over SQL Batch command if we are not a stored proc and have no parameters
                    // MDAC BUG #'s 73776 & 72101
                    Debug.Assert(this.IsPrepared == false, "CommandType.Text with no params should not be prepared!");
                    string text = GetCommandText(cmdBehavior) + GetSetOptionsOFF(cmdBehavior);
                    _activeConnection.Parser.TdsExecuteSQLBatch(text, this.CommandTimeout);
                }
                else if (System.Data.CommandType.Text == this.CommandType) {
                    if (this.IsDirty) {
                        Debug.Assert(_cachedMetaData == null, "dirty query should not have cached metadata!");
                        //
                        // someone changed the command text or the parameter schema so we must unprepare the command
                        //
                        Unprepare();
                        IsDirty = false;
                    }

                    if (_execType == xtEXEC) {
                        Debug.Assert(this.IsPrepared && (_handle != -1), "invalid attempt to call sp_execute without a handle!");
                        rpc = BuildExecute();
                    }
                    else
                        if (_execType == xtPREPEXEC) {
                        Debug.Assert(_activeConnection.IsShiloh, "Invalid attempt to call sp_prepexec on non 7.x server");
                        rpc = BuildPrepExec(cmdBehavior);
                        // next time through, only do an exec
                        _execType = xtEXEC;
                        // mark ourselves as preparing the command
                        _inPrepare = true;
                    }
                    else {
                        Debug.Assert(_execType == xtEXECSQL, "Invalid execType!");
                        rpc = BuildExecuteSql(cmdBehavior);
                    }

                    // if shiloh, then set NOMETADATA_UNLESSCHANGED flag
                    if (_activeConnection.IsShiloh)
                        rpc.options = TdsEnums.RPC_NOMETADATA;

                    _activeConnection.Parser.TdsExecuteRPC(rpc, this.CommandTimeout, inSchema);
                }
                else {
                    Debug.Assert(this.CommandType == System.Data.CommandType.StoredProcedure, "unknown command type!");
                    Debug.Assert(this.IsPrepared == false, "RPC should not be prepared!");
                    Debug.Assert(this.IsDirty == false, "RPC should not be marked as dirty!");

                    rpc = BuildRPC();

                    // if we need to augment the command because a user has changed the command behavior (e.g. FillSchema)
                    // then batch sql them over.  This is inefficient (3 round trips) but the only way we can get metadata only from
                    // a stored proc
                    setOptions = GetSetOptionsON(cmdBehavior);

                    // turn set options ON
                    if (null != setOptions) {
                        _activeConnection.Parser.TdsExecuteSQLBatch(setOptions, this.CommandTimeout);
                        _activeConnection.Parser.Run(RunBehavior.UntilDone, this, null);
                        // and turn OFF when the reader exhausts the stream on Close()
                        setOptions = GetSetOptionsOFF(cmdBehavior);
                    }

                    // turn debugging on
                    _activeConnection.CheckSQLDebug();
                    // execute sp
                    _activeConnection.Parser.TdsExecuteRPC(rpc, this.CommandTimeout, inSchema);
                }

                if (true == returnStream) {
        	    	ds = new SqlDataReader(this);
                }    	    	
        	        
    	        // if we aren't doing this async, then read the data off the wire
        	    if (runBehavior == RunBehavior.UntilDone) {
            		_activeConnection.Parser.Run(RunBehavior.UntilDone, this, ds);
        	    }        	        

                // bind the parser to the reader if we get this far
                if (ds != null) {
                    ds.Bind(_activeConnection.Parser);
                    ds.Behavior = cmdBehavior;
                    ds.SetOptionsOFF = setOptions;
                    // UNDONE UNDONE BUGBUG
                    // In the future, with Mars, at this point we may have to turn the
                    // set options off, I am not sure how that is going to work as of yet.

                    // bind this reader to this connection now
                    _activeConnection.Reader = ds;

                    // force this command to start reading data off the wire.
                    // this will cause an error to be reported at Execute() time instead of Read() time
                    // if the command is not set.
                    try {
                        _cachedMetaData = ds.MetaData;
                    }
                    catch (Exception e) {
                        ds.Close();
                        throw e;
                    }
                }
            }
            catch (Exception e) {
                SQL.IncrementFailedCommandCount();

                throw e;
            }
                
            return ds;
        }

        //
        // ICloneable
        //

        /// <include file='doc\SQLCommand.uex' path='docs/doc[@for="SqlCommand.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            SqlCommand clone = new SqlCommand(); // MDAC 81448
            clone.CommandText = CommandText;
            clone.CommandType = CommandType;
            clone.UpdatedRowSource = UpdatedRowSource;
            IDataParameterCollection parameters = clone.Parameters;
            foreach(ICloneable parameter in Parameters) {
                parameters.Add(parameter.Clone());
            }
            clone.Connection = this.Connection;
            clone.Transaction = this.Transaction;
            clone.CommandTimeout = this.CommandTimeout;
            return clone;
        }

        // validates that a command has commandText and a non-busy open connection
        // throws exception for error case, returns false if the commandText is empty
        private void ValidateCommand(string method, bool executing) {
            if (null == _activeConnection) {
                throw ADP.ConnectionRequired(method);
            }

            // must have an open and available connection
            if (ConnectionState.Open != _activeConnection.State) {
                throw ADP.OpenConnectionRequired(method, _activeConnection.State);
            }

            // close any dead readers, if applicable
            _activeConnection.CloseDeadReader();

            if (_activeConnection.Reader != null || _activeConnection.Parser.PendingData) {
                Debug.Assert(_activeConnection.Reader != null || (_activeConnection.Reader == null &&
                             !_activeConnection.Parser.PendingData), "There was pending data on the wire but no attached datareader!");
                throw ADP.OpenReaderExists(); // MDAC 66411
            }

            // if we are actually executing a command, then make sure we have a valid transaction (or none),
            // and command text
            if (executing) {
                // Check for dead transactions, and roll them back so that this command
                // will not be executed under a dead transaction.
                _activeConnection.RollbackDeadTransaction();
 
                // Check to see if the currently set transaction has completed.  If so, 
                // null out our local reference.
                if (null != _transaction && _transaction._sqlConnection == null)
                    _transaction = null;

                // throw if the connection is in a transaction but there is no
                // locally assigned transaction object
                if ((null != _activeConnection.LocalTransaction) && (null == _transaction))
                    throw ADP.TransactionRequired();                

                // if we have a transaction, check to ensure that the active
                // connection property matches the connection associated with
                // the transaction
                if (null != _transaction && _activeConnection != _transaction._sqlConnection)
                    throw ADP.TransactionConnectionMismatch();

                if (ADP.IsEmpty(this.CommandText))
                    throw ADP.CommandTextRequired(method);
            }                
        }

        //
        // UNDONE: want to inherit, but hide from the user
        // ICommandHandler
        //
        internal void OnReturnStatus(int status) {
            if (_inPrepare)
                return;

            // see if a return value is bound
            int count = GetParameterCount();
            for (int i = 0; i < count; i++) {
                SqlParameter parameter = _parameters[i];
                if (parameter.Direction == ParameterDirection.ReturnValue) {
                    object v = parameter.Value;
                    
                    // if the user bound a sqlint32 (the only valid one for status, use it)
                    if ( (null != v) && (v.GetType() == typeof(SqlInt32)) ) {
                        parameter.Value = new SqlInt32(status); // value type
                    }
                    else {
                        parameter.Value = status;

                    }
                    break;
                }
            }
        }

        //
        // Move the return value to the corresponding output parameter.
        // Return parameters are sent in the order in which they were defined in the procedure.
        // If named, match the parameter name, otherwise fill in based on ordinal position.
        // If the parameter is not bound, then ignore the return value.
        //
        internal void OnReturnValue(SqlReturnValue rec) {
            if (_inPrepare) {
                SqlInt32 h = (SqlInt32)(rec.value);
                if (!h.IsNull) {
                    _handle = h.Value;
                }
                _inPrepare = false;
                return;
            }

            SqlParameter thisParam  = null;
            int          count      = GetParameterCount();
            bool         foundParam = false;

            if (null == rec.parameter) {
                // rec.parameter should only be null for a return value from a function
                for (int i = 0; i < count; i++) {
                    thisParam = _parameters[i];

                    // searching for ReturnValue
                    if (thisParam.Direction == ParameterDirection.ReturnValue) {
                        foundParam = true;
                        break; // found it
                    }
                }
           	}
            else {
                for (int i = 0; i < count; i++) {
                    thisParam = _parameters[i];

                    // searching for Output or InputOutput or ReturnValue with matching name
                    if (thisParam.Direction != ParameterDirection.Input && rec.parameter == thisParam.ParameterName) {
                        foundParam = true;
                        break; // found it
                    }
                }
            }

            if (foundParam) {
                // copy over data

                // if the value user has supplied a SqlType class, then just copy over the SqlType, otherwise convert
                // to the com type
                object val = thisParam.Value;

                if (val is INullable) {
                    thisParam.Value = rec.value;
                }
                else {
                    thisParam.Value = MetaType.GetComValue(rec.type, rec.value);
                }
                
                MetaType mt = MetaType.GetMetaType(rec.type);

                if (rec.type == SqlDbType.Decimal) {
                    thisParam.Scale = rec.scale;
                    thisParam.Precision = rec.precision;
                }

                if (rec.collation != null) {
                    Debug.Assert(MetaType.IsCharType(rec.type), "Invalid collation structure for non-char type");
                    thisParam.Collation = rec.collation;
                }
            }

            return;
        }

        //
        // 7.5
        // prototype for sp_prepexec is:
        // sp_prepexec(@handle int IN/OUT, @batch_params ntext, @batch_text ntext, param1value,param2value...)
        //
        private _SqlRPC BuildPrepExec(CommandBehavior behavior) {
            Debug.Assert(System.Data.CommandType.Text == this.CommandType, "invalid use of sp_prepexec for stored proc invocation!");
            SqlParameter sqlParam;
            int i = 0;
            int j = 3;

            _SqlRPC rpc = new _SqlRPC();
            rpc.rpcName = TdsEnums.SP_PREPEXEC;
            rpc.parameters = new SqlParameter[CountParameters() + j]; // don't send options

            //@handle
            sqlParam = new SqlParameter(null, SqlDbType.Int);
            sqlParam.Direction = ParameterDirection.InputOutput;
            sqlParam.Value = _handle;
            rpc.parameters[0] = sqlParam;

            //@batch_params
            string paramList = BuildParamList();
            sqlParam = new SqlParameter(null, ((paramList.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, paramList.Length);
            sqlParam.Value = paramList;
            rpc.parameters[1] = sqlParam;

            //@batch_text
            string text = GetCommandText(behavior);
            sqlParam = new SqlParameter(null, ((text.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, text.Length);
            sqlParam.Value = text;
            rpc.parameters[2] = sqlParam;

            //@param1value, @param2value, ...
            int count = GetParameterCount();
            for (; i < count; i++) {
                SqlParameter parameter = _parameters[i];
                if (ShouldSendParameter(parameter))
                    rpc.parameters[j++] = parameter;
            }

            return rpc;
        }


        //
        // returns true if the parameter is not a return value
        // and it's value is not DBNull (for a nullable parameter)
        //
        private bool ShouldSendParameter(SqlParameter p) {

            switch (p.Direction) {
                case ParameterDirection.ReturnValue:
                    // return value parameters are never sent
                    return false;
                case ParameterDirection.Output:
                case ParameterDirection.InputOutput:
                    // InputOutput/Output parameters are aways sent
                    return true;
                case ParameterDirection.Input:
                    // Input parameters are only sent if not suppressed
                    return(!p.Suppress);
                default:
                    Debug.Assert(false, "Invalid ParameterDirection!");
		    break;
            }

            // should never get here without firing the assert
            return false;
        }

        private int CountParameters() {
            int cParams = 0;

            int count = GetParameterCount();
            for (int i = 0; i < count; i++) {
                if (ShouldSendParameter(_parameters[i]))
                    cParams++;
            }
            return cParams;
        }

        private int GetParameterCount() {
            return ((null != _parameters) ? _parameters.Count : 0);
        }

        //
        // build the RPC record header for this stored proc and add parameters
        //
        private _SqlRPC BuildRPC() {
            int i = 0;
            int j = 0;

            Debug.Assert(this.CommandType == System.Data.CommandType.StoredProcedure, "Command must be a stored proc to execute an RPC");
            _SqlRPC rpc = new _SqlRPC();

            rpc.rpcName = this.CommandText; // just get the raw command text
            rpc.parameters = new SqlParameter[CountParameters()];

            int count = GetParameterCount();
            for (; i < count; i++) {
                SqlParameter parameter =  _parameters[i];

                MetaType mt = parameter.GetMetaType();

                // func will change type to that with a 4 byte length if the type has a two
                // byte length and a parameter length > than that expressable in 2 bytes
                ValidateTypeLengths(parameter, ref mt);

                if (ShouldSendParameter(parameter))
                    rpc.parameters[j++] = parameter;
            }

            return rpc;
        }

        //
        // build the RPC record header for sp_unprepare
        //
        // prototype for sp_unprepare is:
        // sp_unprepare(@handle)
        //
        // CONSIDER:  instead of creating each time, define at load time and then put the new value in
        private _SqlRPC BuildUnprepare() {
            Debug.Assert(_handle != 0, "Invalid call to sp_unprepare without a valid handle!");

            _SqlRPC rpc = new _SqlRPC();
            SqlParameter sqlParam;

            rpc.rpcName = TdsEnums.SP_UNPREPARE;
            rpc.parameters = new SqlParameter[1/*for handle*/];

            //@handle
            sqlParam = new SqlParameter(null, SqlDbType.Int);
            sqlParam.Value = _handle;
            rpc.parameters[0] = sqlParam;

            return rpc;
        }

        //
        // build the RPC record header for sp_execute
        //
        // prototype for sp_execute is:
        // sp_execute(@handle int,param1value,param2value...)
        //
        private _SqlRPC BuildExecute() {
            Debug.Assert(_handle != -1, "Invalid call to sp_execute without a valid handle!");
            int i = 0;
            int j = 1;

            _SqlRPC rpc = new _SqlRPC();
            SqlParameter sqlParam;

            rpc.rpcName = TdsEnums.SP_EXECUTE;
            rpc.parameters = new SqlParameter[CountParameters() + j/*for handle*/];

            //@handle
            sqlParam = new SqlParameter(null, SqlDbType.Int);
            sqlParam.Value = _handle;
            rpc.parameters[0] = sqlParam;

            int count = GetParameterCount();
            for (; i < count; i++) {
                SqlParameter parameter = _parameters[i];

                MetaType mt = parameter.GetMetaType();

                // func will change type to that with a 4 byte length if the type has a two
                // byte length and a parameter length > than that expressable in 2 bytes
                ValidateTypeLengths(parameter, ref mt);
                
                if (ShouldSendParameter(parameter))
                    rpc.parameters[j++] = parameter;                    
            }

            return rpc;
        }

        //
        // build the RPC record header for sp_executesql and add the parameters
        //
        // prototype for sp_executesql is:
        // sp_executesql(@batch_text nvarchar(4000),@batch_params nvarchar(4000), param1,.. paramN)
        private _SqlRPC BuildExecuteSql(CommandBehavior behavior) {
            Debug.Assert(_handle == -1, "This command has an existing handle, use sp_execute!");
            Debug.Assert(System.Data.CommandType.Text == this.CommandType, "invalid use of sp_executesql for stored proc invocation!");

            _SqlRPC rpc = new _SqlRPC();
            SqlParameter sqlParam;

            rpc.rpcName = TdsEnums.SP_EXECUTESQL;
            int cParams = CountParameters();

            if (cParams > 0) {
                int i = 0;
                int j = 2;
                // make room for the @sql and @param parameters in addition to the parameter value parameters
                rpc.parameters = new SqlParameter[CountParameters() + j];

                // @paramList
                string paramList = BuildParamList();
                sqlParam = new SqlParameter(null, ((paramList.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, paramList.Length);
                sqlParam.Value = paramList;
                rpc.parameters[1] = sqlParam;

                // @parameter values
                int count = GetParameterCount();
                for (; i < count; i++) {
                    SqlParameter parameter = _parameters[i];
                    if (ShouldSendParameter(parameter))
                        rpc.parameters[j++] = parameter;
                }
            }
            else
                // otherwise, we just have the @sql parameter
                rpc.parameters = new SqlParameter[1];

            // @sql
            string text = GetCommandText(behavior);
            sqlParam = new SqlParameter(null, ((text.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, text.Length);
            sqlParam.Value = text;
            rpc.parameters[0] = sqlParam;

            return rpc;
        }

        // paramList parameter for sp_executesql, sp_prepare, and sp_prepexec
        private string BuildParamList() {
            StringBuilder paramList = new StringBuilder();
            bool fAddSeperator = false;

            int count = GetParameterCount();
            for (int i = 0; i < count; i++) {
                SqlParameter sqlParam = _parameters[i];

                // skip ReturnValue parameters; we never send them to the server
                if (!ShouldSendParameter(sqlParam))
                    continue;

                // add our separator for the ith parmeter
                if (fAddSeperator)
                    paramList.Append(',');

                paramList.Append(sqlParam.ParameterName);

                MetaType mt = sqlParam.GetMetaType();

                // func will change type to that with a 4 byte length if the type has a two
                // byte length and a parameter length > than that expressable in 2 bytes
                ValidateTypeLengths(sqlParam, ref mt);

                paramList.Append(" " + mt.TypeName);
                fAddSeperator = true;

                if (sqlParam.SqlDbType == SqlDbType.Decimal) {

                    byte precision = sqlParam.Precision;
                    byte scale = sqlParam.Scale;

                    paramList.Append('(');

                    if (0 == precision)
                        precision = TdsEnums.DEFAULT_NUMERIC_PRECISION;

                    paramList.Append(precision);
                    paramList.Append(',');
                    paramList.Append(scale);
                    paramList.Append(')');
                }
                else if (false == mt.IsFixed && false == mt.IsLong && mt.SqlDbType != SqlDbType.Timestamp) {
                    int size = sqlParam.Size;

                    paramList.Append('(');

                    // if using non unicode types, obtain the actual byte length from the parser, with it's associated code page
                    if (MetaType.IsAnsiType(sqlParam.SqlDbType)) {
                        object val = sqlParam.CoercedValue;
                        string s = null;
                        
                        // deal with the sql types
                        if (val is INullable) {
                            if (!((INullable)val).IsNull)
                                s = ((SqlString)val).Value;
                        }
                        else
                        if (null != val && !Convert.IsDBNull(val)) {
                            s = (string)val;
                        }

                        if (null != s) {
                            int actualBytes = _activeConnection.Parser.GetEncodingCharLength(s, sqlParam.ActualSize, sqlParam.Offset, null);
                            // if actual number of bytes is greater than the user given number of chars, use actual bytes
                            if (actualBytes > size)
                                size = actualBytes;
                        }
                    }

                    // bug 49497, if the user specifies a 0-sized parameter for a variable len field
                    // pass over max size (8000 bytes or 4000 characters for wide types)
                    if (0 == size)
                        size = MetaType.IsSizeInCharacters(mt.SqlDbType) ? (TdsEnums.MAXSIZE >> 1) : TdsEnums.MAXSIZE;

                    paramList.Append(size);
                    paramList.Append(')');
                }

                // set the output bit for Output or InputOutput parameters
                if (sqlParam.Direction != ParameterDirection.Input)
                    paramList.Append(" " + TdsEnums.PARAM_OUTPUT);
            }

            return paramList.ToString();
        }

        private void ValidateTypeLengths(SqlParameter sqlParam, ref MetaType mt) {
            // MDAC bug #50839 + #52829 : Since the server will automatically reject any
            // char, varchar, binary, varbinary, nchar, or nvarchar parameter that has a
            // byte size > 8000 bytes, we promote the parameter to image, text, or ntext.  This
            // allows the user to specify a parameter type using a COM+ datatype and be able to
            // use that parameter against a BLOB column.
            if (false == mt.IsFixed && false == mt.IsLong) { // if type has 2 byte length
                int actualSize = sqlParam.ActualSize;
                int size = sqlParam.Size;

                int maxSize = (size > actualSize) ? size : actualSize;
                if (maxSize > TdsEnums.TYPE_SIZE_LIMIT) { // is size > size able to be described by 2 bytes
                    switch (mt.SqlDbType) {
                        case SqlDbType.Binary:
                        case SqlDbType.VarBinary:
                            {
                                sqlParam.SqlDbType = SqlDbType.Image;
                                mt = sqlParam.GetMetaType();
                                break;
                            }
                        case SqlDbType.Char:
                        case SqlDbType.VarChar:
                            {
                                sqlParam.SqlDbType = SqlDbType.Text;
                                mt = sqlParam.GetMetaType();
                                break;
                            }
                        case SqlDbType.NChar:
                        case SqlDbType.NVarChar:
                            {
                                sqlParam.SqlDbType = SqlDbType.NText;
                                mt = sqlParam.GetMetaType();
                                break;
                            }
                        default:
                            {
                                Debug.Assert(false, "Missed metatype in SqlCommand.BuildParamList()");
                                break;
                            }
                    }
                }
            }
        }

        // returns set option text to turn on format only and key info on and off
        // @devnote:  When we are executing as a text command, then we never need
        // to turn off the options since they command text is executed in the scope of sp_executesql.
        // For a stored proc command, however, we must send over batch sql and then turn off
        // the set options after we read the data.  See the code in Command.Execute()
        private string GetSetOptionsON(CommandBehavior behavior) {
            string s = null;

            if ((System.Data.CommandBehavior.SchemaOnly == (behavior & CommandBehavior.SchemaOnly)) ||
               (System.Data.CommandBehavior.KeyInfo == (behavior & CommandBehavior.KeyInfo))) {
               
                // MDAC 56898 - SET FMTONLY ON will cause the server to ignore other SET OPTIONS, so turn
                // it off before we ask for browse mode metadata
                s = TdsEnums.FMTONLY_OFF;
         
                if (System.Data.CommandBehavior.KeyInfo == (behavior & CommandBehavior.KeyInfo)) {
                    s = s + TdsEnums.BROWSE_ON;
                }

                if (System.Data.CommandBehavior.SchemaOnly == (behavior & CommandBehavior.SchemaOnly)) {
                    s = s + TdsEnums.FMTONLY_ON;
                }
            }	           	

            return s;
        }

        private string GetSetOptionsOFF(CommandBehavior behavior) {
            string s = null;

            // SET FMTONLY ON OFF
            if (System.Data.CommandBehavior.SchemaOnly == (behavior & CommandBehavior.SchemaOnly)) {
                s = s + TdsEnums.FMTONLY_OFF;
            }

            // SET NO_BROWSETABLE OFF
            if (System.Data.CommandBehavior.KeyInfo == (behavior & CommandBehavior.KeyInfo)) {
                s = s + TdsEnums.BROWSE_OFF;
            }

            return s;
        }

        private String GetCommandText(CommandBehavior behavior) {
            // build the batch string we send over, since we execute within a stored proc (sp_executesql), the SET options never need to be
            // turned off since they are scoped to the sproc
            Debug.Assert(System.Data.CommandType.Text == this.CommandType, "invalid call to GetCommandText for stored proc!");
            return GetSetOptionsON(behavior) + this.CommandText;
        }

// sp calling to exec
// UNUSED:
/*
              else {
                    int i;
                    SqlParameter p = null;

                    for (i = 0; i < this.Parameters.Count; i++) {
                        if (this.Parameters[i].Direction == ParameterDirection.ReturnValue) {
                            p = this.Parameters[i];
                            break;
                        }
                    }

                    if (p != null)
                        text = prefix + "declare " + p.ParameterName + " int exec " + p.ParameterName + "=" + text + " ";
                    else
                        text = prefix + "exec " + text + " ";
                    // convert stored proc syntax to exec synta
                    // exec <sp name> @p1, @p2, etc
                    for (i = 0; i < this.Parameters.Count; i++) {
                        p = this.Parameters[i];
                        if (ShouldSendParameter(p)) {
                            if (i > 0)
                                text += ", ";
                            text += p.ParameterName;
                            if (p.Direction != ParameterDirection.Input)
                                text += " " + TdsEnums.PARAM_OUTPUT;
                        }
                    }
                    text += postfix;
                }

*/

        //
        // build the RPC record header for sp_executesql and add the parameters
        //
        // the prototype for sp_prepare is:
        // sp_prepare(@handle int OUTPUT, @batch_params ntext, @batch_text ntext, @options int default 0x1)
        private _SqlRPC BuildPrepare(CommandBehavior behavior) {
            Debug.Assert(System.Data.CommandType.Text == this.CommandType, "invalid use of sp_prepare for stored proc invocation!");
            _SqlRPC rpc = new _SqlRPC();
            SqlParameter sqlParam;

            rpc.rpcName = TdsEnums.SP_PREPARE;
            rpc.parameters = new SqlParameter[3]; // don't send options

            //@handle
            sqlParam = new SqlParameter(null, SqlDbType.Int);
            sqlParam.Direction = ParameterDirection.Output;
            rpc.parameters[0] = sqlParam;

            //@batch_params
            string paramList = BuildParamList();
            sqlParam = new SqlParameter(null, ((paramList.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, paramList.Length);
            sqlParam.Value = paramList;
            rpc.parameters[1] = sqlParam;

            //@batch_text
            string text = GetCommandText(behavior);
            sqlParam = new SqlParameter(null, ((text.Length<<1)<=TdsEnums.TYPE_SIZE_LIMIT)?SqlDbType.NVarChar:SqlDbType.NText, text.Length);
            sqlParam.Value = text;
            rpc.parameters[2] = sqlParam;

/*
            //@options
            sqlParam = new SqlParameter(null, SqlDbType.Int);
            rpc.Parameters[3] = sqlParam;
*/
            return rpc;
        }

        internal bool IsPrepared {
            get { return(_execType != xtEXECSQL);}
        }

        internal bool IsDirty {
            get { return _dirty;}
            set {
                // only mark the command as dirty if it is already prepared
                // but always clear the value if it we are clearing the dirty flag
                _dirty = value ? IsPrepared : false;
                _cachedMetaData = null;
            }
        }

        internal int RecordsAffected {
            get { return _rowsAffected; }
            set { 
                if (-1 == _rowsAffected)
                    _rowsAffected = value;
                else
                    _rowsAffected += value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledb_util.cs ===
//------------------------------------------------------------------------------
// <copyright file="OLEDB_Util.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;

    sealed internal class ODB : ADP {

        // OleDbCommand
        static internal void CommandParameterStatus(StringBuilder builder, string parametername, int index, DBStatus status) {
            switch (status) {
            case DBStatus.S_OK:
            case DBStatus.S_ISNULL:
            case DBStatus.S_IGNORE:
                break;

            case DBStatus.E_BADACCESSOR:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterBadAccessor,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            case DBStatus.E_CANTCONVERTVALUE:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterCantConvertValue,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            case DBStatus.E_SIGNMISMATCH:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterSignMismatch,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            case DBStatus.E_DATAOVERFLOW:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterDataOverflow,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            case DBStatus.E_CANTCREATE:
                Debug.Assert(false, "CommandParameterStatus: unexpected E_CANTCREATE");
                goto default;

            case DBStatus.E_UNAVAILABLE:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterUnavailable,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            case DBStatus.E_PERMISSIONDENIED:
                Debug.Assert(false, "CommandParameterStatus: unexpected E_PERMISSIONDENIED");
                goto default;

            case DBStatus.E_INTEGRITYVIOLATION:
                Debug.Assert(false, "CommandParameterStatus: unexpected E_INTEGRITYVIOLATION");
                goto default;

            case DBStatus.E_SCHEMAVIOLATION:
                Debug.Assert(false, "CommandParameterStatus: unexpected E_SCHEMAVIOLATION");
                goto default;

            case DBStatus.E_BADSTATUS:
                Debug.Assert(false, "CommandParameterStatus: unexpected E_BADSTATUS");
                goto default;

            case DBStatus.S_DEFAULT: // MDAC 66626
                builder.Append(Res.GetString(Res.OleDb_CommandParameterDefault,index.ToString(), parametername));
                builder.Append("\r\n");
                break;

            default:
                builder.Append(Res.GetString(Res.OleDb_CommandParameterError,index.ToString(), parametername, status.ToString("G")));
                builder.Append("\r\n");
		break;
            }
        }
        static internal Exception CommandParameterStatus(string value, Exception inner) {
            return InvalidOperation(value, inner);
        }
        static internal Exception UninitializedParameters(int index, string name, OleDbType dbtype) {
            return InvalidOperation(Res.GetString(Res.OleDb_UninitializedParameters, index.ToString(), name, dbtype.ToString("G")));
        }
        static internal Exception BadStatus_ParamAcc(int index, UnsafeNativeMethods.DBBindStatus status) {
            return DataProvider(Res.GetString(Res.OleDb_BadStatus_ParamAcc, index.ToString(), status.ToString("G")));
        }
        static internal Exception NoProviderSupportForParameters(string provider, Exception inner) {
            return DataProvider(Res.GetString(Res.OleDb_NoProviderSupportForParameters, provider), inner);
        }
        static internal Exception NoProviderSupportForSProcResetParameters(string provider) {
            return DataProvider(Res.GetString(Res.OleDb_NoProviderSupportForSProcResetParameters, provider));
        }
        static internal Exception ExecutionDuringWrongContext() {
            return InvalidOperation(Res.GetString(Res.ODB_ExecutionDuringWrongContext));
        }

        // OleDbConnection
        static internal Exception PropsetSetFailure(int status, string propertyName, string provider, Exception inner) {
            switch (status) {
            case ODB.DBPROPSTATUS_OK:
                return inner; // MDAC 69023

            case ODB.DBPROPSTATUS_NOTSUPPORTED:
                return InvalidOperation(Res.GetString(Res.OleDb_PropertyNotSupported, propertyName, provider), inner);

            case ODB.DBPROPSTATUS_BADVALUE:
                return InvalidOperation(Res.GetString(Res.OleDb_PropertyBadValue, propertyName, provider), inner);

            case ODB.DBPROPSTATUS_BADOPTION:
                Debug.Assert(false, "PropsetSetFailure: BadOption");
                goto default;

            case ODB.DBPROPSTATUS_BADCOLUMN:
                Debug.Assert(false, "PropsetSetFailure: BadColumn");
                goto default;

            case ODB.DBPROPSTATUS_NOTALLSETTABLE:
                Debug.Assert(false, "PropsetSetFailure: NotAllSettable");
                goto default;

            case ODB.DBPROPSTATUS_NOTSETTABLE:
                return InvalidOperation(Res.GetString(Res.OleDb_PropertyNotSettable, propertyName, provider), inner);

            case ODB.DBPROPSTATUS_NOTSET:
                return inner; // MDAC 69023

            case ODB.DBPROPSTATUS_CONFLICTING:
                return InvalidOperation(Res.GetString(Res.OleDb_PropertyConflicting, propertyName, provider), inner);

            case ODB.DBPROPSTATUS_NOTAVAILABLE:
                Debug.Assert(false, "PropsetSetFailure: NotAvailable");
                goto default;

            default:
                return InvalidOperation(Res.GetString(Res.OleDb_PropertySetError, propertyName, provider, status.ToString()), inner);
            }
        }
        static internal Exception SchemaRowsetsNotSupported(string provider) {
            return Argument(Res.GetString(Res.OleDb_SchemaRowsetsNotSupported, provider));
        }
        static internal Exception NoErrorInformation(int hr, Exception inner) {
            return ADP.TraceException(new OleDbException(Res.GetString(Res.OleDb_NoErrorInformation, ELookup(hr)), hr, inner));
        }
        static internal Exception MDACSecurityDeny(Exception inner) {
            return Security(Res.GetString(Res.OleDb_MDACSecurityDeny), inner);
        }
        static internal Exception MDACSecurityHive(Exception inner) {
            return Security(Res.GetString(Res.OleDb_MDACSecurityHive), inner);
        }
        static internal Exception MDACSecurityFile(Exception inner) {
            return Security(Res.GetString(Res.OleDb_MDACSecurityFile), inner);
        }
        static internal Exception MDACNotAvailable(Exception inner) {
            return DataProvider(Res.GetString(Res.OleDb_MDACNotAvailable), inner);
        }
        static internal Exception MDACWrongVersion(string currentVersion) {
            return DataProvider(Res.GetString(Res.OleDb_MDACWrongVersion, currentVersion));
        }
        static internal Exception MSDASQLNotSupported() {
            return Argument(Res.GetString(Res.OleDb_MSDASQLNotSupported)); // MDAC 69975
        }
        static internal Exception CommandTextNotSupported(string provider, Exception inner) {
            return DataProvider(Res.GetString(Res.OleDb_CommandTextNotSupported, provider), inner); // 72632
        }
        static internal Exception ProviderUnavailable(string connectionString, Exception inner) {
            return DataProvider(Res.GetString(Res.OleDb_ProviderUnavailable, connectionString), inner);
        }
        //static internal Exception ConnectionPropertyErrors(string propertyString, Exception inner) {
        //    return DataProvider(Res.GetString(Res.OleDb_ConnectionPropertyErrors, propertyString), inner);
        //}
        //static internal Exception CommandPropertyErrors(string propertyString, Exception inner) {
        //    return DataProvider(Res.GetString(Res.OleDb_CommandPropertyErrors, propertyString), inner);
        //}
        static internal Exception TransactionsNotSupported(string provider, Exception inner) {
            return DataProvider(Res.GetString(Res.OleDb_TransactionsNotSupported, provider), inner); // 72632
        }

        static internal Exception AsynchronousNotSupported() {
            return Argument(Res.GetString(Res.OleDb_AsynchronousNotSupported));
        }
        static internal Exception NoProviderSpecified() {
            return Argument(Res.GetString(Res.OleDb_NoProviderSpecified));
        }
        static internal Exception InvalidProviderSpecified() {
            return Argument(Res.GetString(Res.OleDb_InvalidProviderSpecified));
        }
        static internal Exception InvalidDbInfoLiteralRestrictions(string parameter) {
            return Argument(Res.GetString(Res.OleDb_InvalidDbInfoLiteralRestrictions), parameter);
        }
#if SCHEMAINFO
        static internal Exception InvalidRestrictionsSchemaGuids(string parameter) {
            return Argument(Res.GetString(Res.OleDb_InvalidDbInfoLiteralRestrictions), parameter);
        }
        static internal Exception InvalidRestrictionsInfoKeywords(string parameter) {
            return Argument(Res.GetString(Res.OleDb_InvalidDbInfoLiteralRestrictions), parameter);
        }
#endif
        static internal Exception NotSupportedSchemaTable(Guid schema, OleDbConnection connection) {
            return Argument(Res.GetString(Res.OleDb_NotSupportedSchemaTable, OleDbSchemaGuid.GetTextFromValue(schema), connection.Provider));
        }

        // OleDbParameter
        static internal Exception InvalidOleDbType(int value) {
            return ArgumentOutOfRange(Res.GetString(Res.OleDb_InvalidOleDbType, value.ToString()));
        }

        // Getting Data
        static internal Exception BadAccessor() {
            return DataProvider(Res.GetString(Res.OleDb_BadAccessor));
        }
        static internal Exception CantConvertValue() {
            return InvalidCast(Res.GetString(Res.OleDb_CantConvertValue));
        }
        static internal Exception SignMismatch(Type type) {
            return DataProvider(Res.GetString(Res.OleDb_SignMismatch, type.Name));
        }
        static internal Exception DataOverflow(Type type) {
            return DataProvider(Res.GetString(Res.OleDb_DataOverflow, type.Name));
        }
        static internal Exception CantCreate(Type type) {
            return DataProvider(Res.GetString(Res.OleDb_CantCreate, type.Name));
        }
        static internal Exception Unavailable(Type type) {
            return DataProvider(Res.GetString(Res.OleDb_Unavailable, type.Name));
        }
        static internal Exception UnexpectedStatusValue(DBStatus status) {
            return DataProvider(Res.GetString(Res.OleDb_UnexpectedStatusValue, status.ToString("G")));
        }
        static internal Exception GVtUnknown(int wType) {
            return DataProvider(Res.GetString(Res.OleDb_GVtUnknown, wType.ToString("X4"), wType.ToString()));
        }
        static internal Exception SVtUnknown(int wType) {
            return DataProvider(Res.GetString(Res.OleDb_SVtUnknown, wType.ToString("X4")));
        }
        static internal Exception NumericToDecimalOverflow(/* UNDONE: convert value to string*/) {
            return InvalidCast(Res.GetString(Res.OleDb_NumericToDecimalOverflow));
        }

        // OleDbDataReader
        static internal Exception BadStatusRowAccessor(int i, UnsafeNativeMethods.DBBindStatus rowStatus) {
            return DataProvider(Res.GetString(Res.OleDb_BadStatusRowAccessor, i.ToString(), rowStatus.ToString("G")));
        }
        static internal Exception ThreadApartmentState(Exception innerException) {
            return InvalidOperation(Res.GetString(Res.OleDb_ThreadApartmentState), innerException);
        }

        // OleDbDataAdapter
        static internal Exception Fill_NotADODB(string parameter, Exception innerException) {
            return Argument(Res.GetString(Res.OleDb_Fill_NotADODB), parameter, innerException);
        }
        static internal Exception Fill_EmptyRecordSet(string parameter, Exception innerException) {
            return Argument(Res.GetString(Res.OleDb_Fill_EmptyRecordSet), parameter, innerException);
        }
        static internal Exception Fill_EmptyRecord(string parameter, Exception innerException) {
            return Argument(Res.GetString(Res.OleDb_Fill_EmptyRecord), parameter, innerException);
        }

        static internal string NoErrorMessage(int errorcode) {
            return Res.GetString(Res.OleDb_NoErrorMessage, ELookup(errorcode));
        }
        static internal string FailedGetDescription(int errorcode) {
            return Res.GetString(Res.OleDb_FailedGetDescription, ELookup(errorcode));
        }
        static internal string FailedGetSource(int errorcode) {
            return Res.GetString(Res.OleDb_FailedGetSource, ELookup(errorcode));
        }

        // UNDONE:
        static internal Exception DBBindingGetVector() {
            return InvalidOperation(Res.GetString(Res.OleDb_DBBindingGetVector));
        }

        // explictly used error codes
        internal const int E_NOINTERFACE = unchecked((int)0x80004002);

        internal const int DB_E_ALREADYINITIALIZED = unchecked((int)0x80040E52);
        internal const int DB_E_BADBINDINFO        = unchecked((int)0x80040E08);
        internal const int DB_E_BADCOLUMNID        = unchecked((int)0x80040E11);
        internal const int DB_E_ERRORSOCCURRED     = unchecked((int)0x80040E21);
        internal const int DB_E_NOLOCALE           = unchecked((int)0x80040E41);
        internal const int DB_E_NOTFOUND           = unchecked((int)0x80040E19);
        internal const int DB_E_CANTCANCEL         = unchecked((int)0x80040E15);
        internal const int XACT_E_NOTRANSACTION    = unchecked((int)0x8004d00e);

        internal const int DB_S_ENDOFROWSET        = 0x00040EC6;
        internal const int DB_S_NORESULT           = 0x00040EC9;

        internal const int REGDB_E_CLASSNOTREG = unchecked((int)0x80040154);
        
        internal const int ADODB_AlreadyClosedError = unchecked((int)0x800A0E78);
        internal const int ADODB_NextResultError    = unchecked((int)0x800A0CB3);

        // internal command states
        internal const int InternalStateExecuting = (int) (ConnectionState.Open | ConnectionState.Executing);
        internal const int InternalStateFetching = (int) (ConnectionState.Open | ConnectionState.Fetching);
        internal const int InternalStateClosed = (int) (ConnectionState.Closed);

        internal const int ExecutedIMultipleResults = 0;
        internal const int ExecutedIRowset          = 1;
        internal const int ExecutedIRow             = 2;
        internal const int PrepareICommandText      = 3;

        // internal connection states, a superset of the command states
        internal const int InternalStateExecutingNot = (int) ~(ConnectionState.Executing);
        internal const int InternalStateFetchingNot = (int) ~(ConnectionState.Fetching);
        internal const int InternalStateConnecting = (int) (ConnectionState.Connecting);
        internal const int InternalStateOpen = (int) (ConnectionState.Open);

        // constants used to trigger from binding as WSTR to BYREF|WSTR
        // used by OleDbCommand, OleDbDataReader
        internal const int LargeDataSize = (1 << 13); // 8K
        internal const int CacheIncrement = 10;

        // constants used by OleDbDataReader
        internal const int DBRESULTFLAG_DEFAULT = 0;

        internal const short VARIANT_TRUE = -1;
        internal const short VARIANT_FALSE = 0;

        // OleDbConnection constants
        internal const int CLSCTX_ALL = /*CLSCTX_INPROC_SERVER*/1 | /*CLSCTX_INPROC_HANDLER*/2 | /*CLSCTX_LOCAL_SERVER*/4 | /*CLSCTX_REMOTE_SERVER*/16;
        internal const int MaxProgIdLength = 255;

        // Init property group
        internal const int DBPROP_INIT_CATALOG = 0xe9;
        internal const int DBPROP_INIT_DATASOURCE = 0x3b;
        internal const int DBPROP_INIT_OLEDBSERVICES = 0xf8;
        internal const int DBPROP_INIT_TIMEOUT = 0x42;

        // DataSource property group
        internal const int DBPROP_CURRENTCATALOG = 0x25;
        /*internal const int DBPROP_MULTIPLECONNECTIONS = 0xed;*/

        // DataSourceInfo property group
        internal const int DBPROP_CONNECTIONSTATUS = 0xf4;
        internal const int DBPROP_DBMSNAME = 0x28;
        internal const int DBPROP_DBMSVER = 0x29;
        internal const int DBPROP_MULTIPLERESULTS = 0xc4;
        internal const int DBPROP_QUOTEDIDENTIFIERCASE = 0x64;
        internal const int DBPROP_SQLSUPPORT = 0x6d;

        // Rowset property group
        internal const int DBPROP_ACCESSORDER = 0xe7;
        internal const int DBPROP_COMMANDTIMEOUT = 0x22;
        internal const int DBPROP_IColumnsRowset = 0x7b;
        internal const int DBPROP_IRow = 0x107;
        internal const int DBPROP_UNIQUEROWS = 0xee;
        internal const int DBPROP_HIDDENCOLUMNS	= 0x102;
        internal const int DBPROP_MAXROWS = 0x49;

        // property status
        internal const int DBPROPSTATUS_OK             = 0;
        internal const int DBPROPSTATUS_NOTSUPPORTED   = 1;
        internal const int DBPROPSTATUS_BADVALUE       = 2;
        internal const int DBPROPSTATUS_BADOPTION      = 3;
        internal const int DBPROPSTATUS_BADCOLUMN      = 4;
        internal const int DBPROPSTATUS_NOTALLSETTABLE = 5;
        internal const int DBPROPSTATUS_NOTSETTABLE    = 6;
        internal const int DBPROPSTATUS_NOTSET         = 7;
        internal const int DBPROPSTATUS_CONFLICTING    = 8;
        internal const int DBPROPSTATUS_NOTAVAILABLE   = 9;

        internal const int DBPROPOPTIONS_OPTIONAL = 1;

        // misc. property values
        internal const int DBPROPVAL_AO_RANDOM = 2;
        internal const int DBPROPVAL_CS_COMMUNICATIONFAILURE = 2;
        internal const int DBPROPVAL_CS_INITIALIZED          = 1;
        internal const int DBPROPVAL_CS_UNINITIALIZED        = 0;
        internal const int DBPROPVAL_IC_SENSITIVE            = 4;
        /*internal const int DBPROPVAL_IC_MIXED                = 8;*/
        internal const int DBPROPVAL_IN_ALLOWNULL     = 0x00000000;
        /*internal const int DBPROPVAL_IN_DISALLOWNULL  = 0x00000001;
        internal const int DBPROPVAL_IN_IGNORENULL    = 0x00000002;
        internal const int DBPROPVAL_IN_IGNOREANYNULL = 0x00000004;*/

        internal const int DBPROPVAL_OS_RESOURCEPOOLING  = 0x00000001;
        internal const int DBPROPVAL_OS_TXNENLISTMENT    = 0x00000002;
        internal const int DBPROPVAL_OS_CLIENTCURSOR     = 0x00000004;
        internal const int DBPROPVAL_OS_AGR_AFTERSESSION = 0x00000008;
        internal const int DBPROPVAL_SQL_ODBC_MINIMUM = 1;

        // OLE DB providers never return pGuid-style bindings.
        // They are provided as a convenient shortcut for consumers supplying bindings all covered by the same GUID (for example, when creating bindings to access data).
        internal const int DBKIND_GUID_NAME = 0;
        internal const int DBKIND_GUID_PROPID = 1;
        internal const int DBKIND_NAME = 2;
        internal const int DBKIND_PGUID_NAME = 3;
        internal const int DBKIND_PGUID_PROPID = 4;
        internal const int DBKIND_PROPID = 5;
        internal const int DBKIND_GUID = 6;

        internal const int DBCOLUMNFLAGS_ISBOOKMARK    = 0x01;
        internal const int DBCOLUMNFLAGS_ISLONG        = 0x80;
        internal const int DBCOLUMNFLAGS_ISFIXEDLENGTH = 0x10;
        internal const int DBCOLUMNFLAGS_ISNULLABLE    = 0x20;
        internal const int DBCOLUMNFLAGS_ISROWSET      = 0x100000;
        internal const int DBCOLUMNFLAGS_ISROW         = 0x200000;
        internal const int DBCOLUMNFLAGS_ISROWSET_DBCOLUMNFLAGS_ISROW = /*DBCOLUMNFLAGS_ISROWSET*/0x100000 | /*DBCOLUMNFLAGS_ISROW*/0x200000;
        internal const int DBCOLUMNFLAGS_ISLONG_DBCOLUMNFLAGS_ISSTREAM = /*DBCOLUMNFLAGS_ISLONG*/0x80 | /*DBCOLUMNFLAGS_ISSTREAM*/0x80000;
        internal const int DBCOLUMNFLAGS_ISROWID_DBCOLUMNFLAGS_ISROWVER = /*DBCOLUMNFLAGS_ISROWID*/0x100 | /*DBCOLUMNFLAGS_ISROWVER*/0x200;
        internal const int DBCOLUMNFLAGS_WRITE_DBCOLUMNFLAGS_WRITEUNKNOWN  = /*DBCOLUMNFLAGS_WRITE*/0x4 | /*DBCOLUMNFLAGS_WRITEUNKNOWN*/0x8;
        internal const int DBCOLUMNFLAGS_ISNULLABLE_DBCOLUMNFLAGS_MAYBENULL = /*DBCOLUMNFLAGS_ISNULLABLE*/0x20 | /*DBCOLUMNFLAGS_MAYBENULL*/0x40;

        // accessor constants
        internal const int DBACCESSOR_ROWDATA = 0x2;
        internal const int DBACCESSOR_PARAMETERDATA = 0x4;

        // commandbuilder constants
        internal const int DBPARAMTYPE_INPUT = 0x01;
        internal const int DBPARAMTYPE_INPUTOUTPUT = 0x02;
        internal const int DBPARAMTYPE_OUTPUT = 0x03;
        internal const int DBPARAMTYPE_RETURNVALUE = 0x04;

        // parameter constants
        /*internal const int DBPARAMIO_NOTPARAM = 0;
        internal const int DBPARAMIO_INPUT = 0x1;
        internal const int DBPARAMIO_OUTPUT = 0x2;*/

        /*internal const int DBPARAMFLAGS_ISINPUT = 0x1;
        internal const int DBPARAMFLAGS_ISOUTPUT = 0x2;
        internal const int DBPARAMFLAGS_ISSIGNED = 0x10;
        internal const int DBPARAMFLAGS_ISNULLABLE = 0x40;
        internal const int DBPARAMFLAGS_ISLONG = 0x80;*/

        internal const int ParameterDirectionFlag = 3;

        static internal readonly IntPtr DB_INVALID_HACCESSOR = IntPtr.Zero;
        static internal readonly IntPtr DB_NULL_HCHAPTER = IntPtr.Zero;
        static internal readonly IntPtr DB_NULL_HROW = IntPtr.Zero;

        /*static internal readonly int SizeOf_tagDBPARAMINFO = Marshal.SizeOf(typeof(tagDBPARAMINFO));*/
        static internal readonly int SizeOf_tagDBCOLUMNINFO = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBCOLUMNINFO));
        static internal readonly int SizeOf_tagDBLITERALINFO = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBLITERALINFO));
        static internal readonly int SizeOf_tagDBPROPINFOSET = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBPROPINFOSET));
        static internal readonly int SizeOf_tagDBPROPIDSET = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBPROPIDSET));
        static internal readonly int SizeOf_tagDBPROPINFO = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBPROPINFO));
        static internal readonly int SizeOf_tagDBPROPSET = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBPROPSET));
        static internal readonly int SizeOf_tagDBPROP = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagDBPROP));
        internal const int SizeOf_Variant = 16;
        internal const int SizeOf_Guid = 16;

        static internal readonly Guid IID_NULL               = Guid.Empty;
        static internal readonly Guid IID_IDataInitialize    = new Guid(0x2206CCB1,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);
        static internal readonly Guid IID_IDBInitialize      = new Guid(0x0C733A8B,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_ICommandText       = new Guid(0x0C733A27,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_IMultipleResults   = new Guid(0x0C733A90,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_IRow               = new Guid(0x0C733AB4,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_IRowset            = new Guid(0x0C733A7C,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_ISessionProperties = new Guid(0x0C733A85,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);
        static internal readonly Guid IID_ISQLErrorInfo      = new Guid(0x0C733A74,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);

        static internal readonly Guid CLSID_DataLinks        = new Guid(0x2206CDB2,0x19C1,0x11D1,0x89,0xE0,0x00,0xC0,0x4F,0xD7,0xA8,0x29);

        static internal readonly Guid DBGUID_DEFAULT = new Guid(0xc8b521fb,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DBGUID_ROWSET  = new Guid(0xc8b522f6,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);
        static internal readonly Guid DBGUID_ROW     = new Guid(0xc8b522f7,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        static internal readonly Guid DBGUID_ROWDEFAULTSTREAM = new Guid(0x0C733AB7,0x2A1C,0x11CE,0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D);

        static internal readonly Guid CLSID_MSDASQL  = new Guid(0xc8b522cb,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        static internal readonly Guid DBCOL_SPECIALCOL = new Guid(0xc8b52232,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

        static internal readonly char[] ErrorTrimCharacters = new char[] { '\r', '\n', '\0' }; // MDAC 73707
        static internal readonly char[] ParseTrimCharacters = new char[] { ' ', '\t', '\r', '\n', ';', '\0' }; // MDAC 70727
        static internal readonly char[] ProviderSeparatorChar = new char[1] { ';' };
#if SCHEMAINFO
        static internal readonly char[] KeywordSeparatorChar = ProviderSeparatorChar;
#endif

        // used by ConnectionString hashtable, must be all lowercase
        internal const string Asynchronous_Processing = "asynchronous processing";
        internal const string AttachDBFileName = "attachdbfilename";
        internal const string Connect_Timeout = "connect timeout";
        internal const string Data_Source = "data source";
        internal const string File_Name = "file name";
        internal const string Initial_Catalog = "initial catalog";
        internal const string Password = "password";
        internal const string Persist_Security_Info = "persist security info";
        internal const string Provider = "provider";
        internal const string Pwd = "pwd";
        internal const string Ole_DB_Services = "ole db services";

        // used by OleDbConnection as property names
        internal const string Current_Catalog = "current catalog";
        internal const string DBMS_Version = "dbms version";

        // used by OleDbConnection to create and verify OLE DB Services
        internal const string DataLinks_CLSID = "CLSID\\{2206CDB2-19C1-11D1-89E0-00C04FD7A829}\\InprocServer32";
        internal const string OLEDB_SERVICES = "OLEDB_SERVICES";

        // used by OleDbConnection to eliminate post-open detection of 'Microsoft OLE DB Provider for ODBC Drivers'
        internal const string DefaultDescription_MSDASQL = "microsoft ole db provider for odbc drivers";
        internal const string MSDASQL = "msdasql";
        internal const string MSDASQLdot = "msdasql.";

        // used by OleDbPermission
        internal const string Data_Provider = "data provider";
        internal const string _Add = "add";
        internal const string _Keyword = "keyword";
        internal const string _Name = "name";
        internal const string _Value = "value";

        // IColumnsRowset column names
        internal const string DBCOLUMN_BASECATALOGNAME = "DBCOLUMN_BASECATALOGNAME";
        internal const string DBCOLUMN_BASECOLUMNNAME  = "DBCOLUMN_BASECOLUMNNAME";
        internal const string DBCOLUMN_BASESCHEMANAME  = "DBCOLUMN_BASESCHEMANAME";
        internal const string DBCOLUMN_BASETABLENAME   = "DBCOLUMN_BASETABLENAME";
        internal const string DBCOLUMN_COLUMNSIZE      = "DBCOLUMN_COLUMNSIZE";
        internal const string DBCOLUMN_FLAGS           = "DBCOLUMN_FLAGS";
        internal const string DBCOLUMN_GUID            = "DBCOLUMN_GUID";
        internal const string DBCOLUMN_IDNAME          = "DBCOLUMN_IDNAME";
        internal const string DBCOLUMN_ISAUTOINCREMENT = "DBCOLUMN_ISAUTOINCREMENT";
        internal const string DBCOLUMN_ISUNIQUE        = "DBCOLUMN_ISUNIQUE";
        internal const string DBCOLUMN_KEYCOLUMN       = "DBCOLUMN_KEYCOLUMN";
        internal const string DBCOLUMN_NAME            = "DBCOLUMN_NAME";
        internal const string DBCOLUMN_NUMBER          = "DBCOLUMN_NUMBER";
        internal const string DBCOLUMN_PRECISION       = "DBCOLUMN_PRECISION";
        internal const string DBCOLUMN_PROPID          = "DBCOLUMN_PROPID";
        internal const string DBCOLUMN_SCALE           = "DBCOLUMN_SCALE";
        internal const string DBCOLUMN_TYPE            = "DBCOLUMN_TYPE";
        internal const string DBCOLUMN_TYPEINFO        = "DBCOLUMN_TYPEINFO";

        // ISchemaRowset.GetRowset(OleDbSchemaGuid.Indexes) column names
        internal const string PRIMARY_KEY  = "PRIMARY_KEY";
        internal const string UNIQUE       = "UNIQUE";
        internal const string COLUMN_NAME  = "COLUMN_NAME";
        internal const string NULLS        = "NULLS";
        internal const string INDEX_NAME   = "INDEX_NAME";

        // ISchemaRowset.GetSchemaRowset(OleDbSchemaGuid.Procedure_Parameters) column names
        internal const string PARAMETER_NAME           = "PARAMETER_NAME";
        internal const string ORDINAL_POSITION         = "ORDINAL_POSITION";
        internal const string PARAMETER_TYPE           = "PARAMETER_TYPE";
        internal const string IS_NULLABLE              = "IS_NULLABLE";
        internal const string DATA_TYPE                = "DATA_TYPE";
        internal const string CHARACTER_MAXIMUM_LENGTH = "CHARACTER_MAXIMUM_LENGTH";
        internal const string NUMERIC_PRECISION        = "NUMERIC_PRECISION";
        internal const string NUMERIC_SCALE            = "NUMERIC_SCALE";
        internal const string TYPE_NAME                = "TYPE_NAME";

        // DataTable.Select to sort on ordinal position for OleDbSchemaGuid.Procedure_Parameters
        internal const string ORDINAL_POSITION_ASC     = "ORDINAL_POSITION ASC";

#if DEBUG
        internal const string DebugPrefix = "OleDb: ";

        // OleDbMemory
        static internal void TraceData_Alloc(IntPtr pointer, string reason) {
            if (AdapterSwitches.OleDbMemory.Enabled) {
                Debug.WriteLine(DebugPrefix + "AllocCoTaskMem: 0x" + pointer.ToInt32().ToString("X8") + " for " + reason);
            }
        }
        static internal void TraceData_Free(IntPtr pointer, string reason) {
            if (AdapterSwitches.OleDbMemory.Enabled) {
                Debug.WriteLine(DebugPrefix + "FreeCoTaskMem: 0x" + pointer.ToInt32().ToString("X8") + " for " + reason);
            }
        }

        // OleDbTrace
        static internal void Trace_Cast(string from, string result, string reason) {
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                Debug.WriteLine(DebugPrefix + "CAST: " + from + " to " + result + " for " + reason);
            }
        }
        static internal void Trace_Release(string reason) {
            if (AdapterSwitches.OleDbTrace.TraceInfo) {
                Debug.WriteLine(DebugPrefix + "ReleaseComObject: " + reason);
            }
        }

        static private bool TraceLevel(int level) {
            switch(level) {
            case 1:
                return AdapterSwitches.OleDbTrace.TraceError;
            case 2:
                return AdapterSwitches.OleDbTrace.TraceWarning;
            case 3:
                return AdapterSwitches.OleDbTrace.TraceInfo;
            case 4:
                return AdapterSwitches.OleDbTrace.TraceVerbose;
            default:
                Debug.Assert(false, "Level="+level);
                return false;
            }
        }


        static internal void Trace_Begin(int level, string interfaceName, string methodName, params string[] values) {
            InternalTrace_Begin(level, interfaceName, methodName, values);
        }
        static internal void Trace_Begin(string interfaceName, string methodName, params string[] values) {
            InternalTrace_Begin(3, interfaceName, methodName, values);
        }
        static private void InternalTrace_Begin(int level, string interfaceName, string methodName, string[] values) {
            if (TraceLevel(level)) {
                ADP.DebugWrite(DebugPrefix + "BEGIN: " + interfaceName + "." + methodName);
                if (null != values) {
                    int count = values.Length;
                    for (int i = 0; i < count; ++i) {
                        ADP.DebugWrite(" <" + values[i] + "> ");
                    }
                }
                Debug.WriteLine("");
            }
        }

        static internal void Trace_End(int level, string interfaceName, string methodName, int hr, params string[] values) {
            InternalTrace_End(level, interfaceName, methodName, hr, values);
        }
        static internal void Trace_End(string interfaceName, string methodName, int hr, params string[] values) {
            InternalTrace_End(3, interfaceName, methodName, hr, values);
        }
        static private void InternalTrace_End(int level, string interfaceName, string methodName, int hr, string[] values) {
            if (TraceLevel(level) || ((0 != hr) && (DB_S_ENDOFROWSET != hr) && (DB_S_NORESULT != hr) && ((int)OLEDB_Error.DB_S_TYPEINFOOVERRIDDEN != hr) && AdapterSwitches.OleDbTrace.TraceError)) {
                ADP.DebugWrite(DebugPrefix + "END: " + interfaceName + "." + methodName + " = " + ODB.ELookup(hr));
                if (null != values) {
                    int count = values.Length;
                    for (int i = 0; i < count; ++i) {
                        ADP.DebugWrite(" <" + values[i] + "> ");
                    }
                }
                Debug.WriteLine("");
            }
        }
        static internal void  Trace_Binding(int index, DBBindings bindings, string name) {
            StringBuilder builder = new StringBuilder(512);
            builder.Append(index); builder.Append(" tagDBBINDING <"); builder.Append(name); builder.Append(">");
            builder.Append("\r\n\tiOrdinal   = ");   builder.Append(bindings.Ordinal);
            builder.Append("\r\n\tobValue    = ");   builder.Append(bindings.ValueOffset);
            builder.Append("\r\n\tobLength   = ");   builder.Append(bindings.LengthOffset);
            builder.Append("\r\n\tobStatus   = ");   builder.Append(bindings.StatusOffset);
          //builder.Append("\r\n\tpTypeInfo  = 0x"); builder.Append(bindings.TypeInfoPtr.ToString("X8"));
          //builder.Append("\r\n\tpObject    = 0x"); builder.Append(bindings.ObjectPtr.ToString("X8"));
          //builder.Append("\r\n\tpBindExt   = 0x"); builder.Append(bindings.BindExtPtr.ToString("X8"));
          //builder.Append("\r\n\tdwPart     = 0x"); builder.Append(bindings.Part.ToString("X8") + " " + bindings.Part.ToString());
          //builder.Append("\r\n\tdwMemOwner = 0x"); builder.Append((bindings.MemOwner).ToString("X8") + " " + bindings.MemOwner.ToString());
          //builder.Append("\r\n\teParamIO   = 0x"); builder.Append(bindings.ParamIO.ToString("X8") + " " + bindings.ParamIO.ToString());
            builder.Append("\r\n\tcbMaxLen   = ");   builder.Append(bindings.MaxLen);
          //builder.Append("\r\n\tdwFlags    = 0x"); builder.Append((bindings.Flags).ToString("X8") + " " + (bindings.Flags).ToString());
            builder.Append("\r\n\twType      = ");   builder.Append(ODB.WLookup(unchecked(bindings.DbType)));
            builder.Append("\r\n\tbPrecision = ");   builder.Append(bindings.Precision);
            builder.Append("\r\n\tbScale     = ");   builder.Append(bindings.Scale);
            Debug.WriteLine(builder.ToString());
        }

        /*static internal void  Trace_ParameterInfo(string prefix, tagDBPARAMINFO paraminfo) {
            Debug.WriteLine(prefix + " tagDBPARAMINFO");
            Debug.WriteLine("\tdwFlags     = 0x" + paraminfo.dwFlags.ToString("X8") + " " + paraminfo.dwFlags.ToString());
            Debug.WriteLine("\tiOrdinal    = "   + paraminfo.iOrdinal.ToString());
            Debug.WriteLine("\tpwszName    = "   + paraminfo.pwszName);
            Debug.WriteLine("\tulParamSize = "   + paraminfo.ulParamSize.ToString());
            Debug.WriteLine("\twType       = "   + ODB.WLookup(unchecked(paraminfo.wType)));
            Debug.WriteLine("\tbPrecision  = "   + paraminfo.bPrecision.ToString());
            Debug.WriteLine("\tbScale      = "   + paraminfo.bScale.ToString());
        }*/
#endif

        // Debug error string writeline
        static internal string ELookup(int hr) {
            if (Enum.IsDefined(typeof(OLEDB_Error), hr)) {
                return ((OLEDB_Error) hr).ToString("G") + "(0x" + hr.ToString("X8") + ")";
            }
            return "0x" + (hr).ToString("X8");
        }

#if DEBUG
        static internal string PLookup(int id) {
            if (Enum.IsDefined(typeof(PropertyEnum), id)) {
                return ((PropertyEnum) id).ToString("G") + "(0x" + id.ToString("X8") + ")";
            }
            return "0x" + (id).ToString("X8");
        }

        static internal string WLookup(int id) {
            string value = "0x" + ((short) id).ToString("X4") + " " + ((short) id);
            value += " " + ((DBTypeEnum) id).ToString("G");
            return value;
        }
#endif
        private enum OLEDB_Error { // OLEDB Error codes
            REGDB_E_CLASSNOTREG = unchecked((int)0x80040154),
            CO_E_NOTINITIALIZED = unchecked((int)0x800401F0),

            S_OK = 0x00000000,
            S_FALSE = 0x00000001,

            E_UNEXPECTED = unchecked((int)0x8000FFFF),
            E_NOTIMPL = unchecked((int)0x80004001),
            E_OUTOFMEMORY = unchecked((int)0x8007000E),
            E_INVALIDARG = unchecked((int)0x80070057),
            E_NOINTERFACE = unchecked((int)0x80004002),
            E_POINTER = unchecked((int)0x80004003),
            E_HANDLE = unchecked((int)0x80070006),
            E_ABORT = unchecked((int)0x80004004),
            E_FAIL = unchecked((int)0x80004005),
            E_ACCESSDENIED = unchecked((int)0x80070005),

            // MessageId: DB_E_BADACCESSORHANDLE
            // MessageText:
            //  Accessor is invalid.
            DB_E_BADACCESSORHANDLE           = unchecked((int)0x80040E00),

            // MessageId: DB_E_ROWLIMITEXCEEDED
            // MessageText:
            //  Row could not be inserted into the rowset without exceeding provider's maximum number of active rows.
            DB_E_ROWLIMITEXCEEDED            = unchecked((int)0x80040E01),

            // MessageId: DB_E_REOleDbNLYACCESSOR
            // MessageText:
            //  Accessor is read-only. Operation failed.
            DB_E_REOleDbNLYACCESSOR            = unchecked((int)0x80040E02),

            // MessageId: DB_E_SCHEMAVIOLATION
            // MessageText:
            //  Values violate the database schema.
            DB_E_SCHEMAVIOLATION             = unchecked((int)0x80040E03),

            // MessageId: DB_E_BADROWHANDLE
            // MessageText:
            //  Row handle is invalid.
            DB_E_BADROWHANDLE                = unchecked((int)0x80040E04),

            // MessageId: DB_E_OBJECTOPEN
            // MessageText:
            //  Object was open.
            DB_E_OBJECTOPEN                  = unchecked((int)0x80040E05),

            // MessageId: DB_E_BADCHAPTER
            // MessageText:
            //  Chapter is invalid.
            DB_E_BADCHAPTER                  = unchecked((int)0x80040E06),

            // MessageId: DB_E_CANTCONVERTVALUE
            // MessageText:
            //  Data or literal value could not be converted to the type of the column in the data source, and the provider was unable to determine which columns could not be converted.  Data overflow or sign mismatch was not the cause.
            DB_E_CANTCONVERTVALUE            = unchecked((int)0x80040E07),

            // MessageId: DB_E_BADBINDINFO
            // MessageText:
            //  Binding information is invalid.
            DB_E_BADBINDINFO                 = unchecked((int)0x80040E08),

            // MessageId: DB_SEC_E_PERMISSIONDENIED
            // MessageText:
            //  Permission denied.
            DB_SEC_E_PERMISSIONDENIED        = unchecked((int)0x80040E09),

            // MessageId: DB_E_NOTAREFERENCECOLUMN
            // MessageText:
            //  Column does not contain bookmarks or chapters.
            DB_E_NOTAREFERENCECOLUMN         = unchecked((int)0x80040E0A),

            // MessageId: DB_E_LIMITREJECTED
            // MessageText:
            //  Cost limits were rejected.
            DB_E_LIMITREJECTED               = unchecked((int)0x80040E0B),

            // MessageId: DB_E_NOCOMMAND
            // MessageText:
            //  Command text was not set for the command object.
            DB_E_NOCOMMAND                   = unchecked((int)0x80040E0C),

            // MessageId: DB_E_COSTLIMIT
            // MessageText:
            //  Query plan within the cost limit cannot be found.
            DB_E_COSTLIMIT                   = unchecked((int)0x80040E0D),

            // MessageId: DB_E_BADBOOKMARK
            // MessageText:
            //  Bookmark is invalid.
            DB_E_BADBOOKMARK                 = unchecked((int)0x80040E0E),

            // MessageId: DB_E_BADLOCKMODE
            // MessageText:
            //  Lock mode is invalid.
            DB_E_BADLOCKMODE                 = unchecked((int)0x80040E0F),

            // MessageId: DB_E_PARAMNOTOPTIONAL
            // MessageText:
            //  No value given for one or more required parameters.
            DB_E_PARAMNOTOPTIONAL            = unchecked((int)0x80040E10),

            // MessageId: DB_E_BADCOLUMNID
            // MessageText:
            //  Column ID is invalid.
            DB_E_BADCOLUMNID                 = unchecked((int)0x80040E11),

            // MessageId: DB_E_BADRATIO
            // MessageText:
            //  Numerator was greater than denominator. Values must express ratio between zero and 1.
            DB_E_BADRATIO                    = unchecked((int)0x80040E12),

            // MessageId: DB_E_BADVALUES
            // MessageText:
            //  Value is invalid.
            DB_E_BADVALUES                   = unchecked((int)0x80040E13),

            // MessageId: DB_E_ERRORSINCOMMAND
            // MessageText:
            //  One or more errors occurred during processing of command.
            DB_E_ERRORSINCOMMAND             = unchecked((int)0x80040E14),

            // MessageId: DB_E_CANTCANCEL
            // MessageText:
            //  Command cannot be canceled.
            DB_E_CANTCANCEL                  = unchecked((int)0x80040E15),

            // MessageId: DB_E_DIALECTNOTSUPPORTED
            // MessageText:
            //  Command dialect is not supported by this provider.
            DB_E_DIALECTNOTSUPPORTED         = unchecked((int)0x80040E16),

            // MessageId: DB_E_DUPLICATEDATASOURCE
            // MessageText:
            //  Data source object could not be created because the named data source already exists.
            DB_E_DUPLICATEDATASOURCE         = unchecked((int)0x80040E17),

            // MessageId: DB_E_CANNOTRESTART
            // MessageText:
            //  Rowset position cannot be restarted.
            DB_E_CANNOTRESTART               = unchecked((int)0x80040E18),

            // MessageId: DB_E_NOTFOUND
            // MessageText:
            //  Object or data matching the name, range, or selection criteria was not found within the scope of this operation.
            DB_E_NOTFOUND                    = unchecked((int)0x80040E19),

            // MessageId: DB_E_NEWLYINSERTED
            // MessageText:
            //  Identity cannot be determined for newly inserted rows.
            DB_E_NEWLYINSERTED               = unchecked((int)0x80040E1B),

            // MessageId: DB_E_CANNOTFREE
            // MessageText:
            //  Provider has ownership of this tree.
            DB_E_CANNOTFREE                  = unchecked((int)0x80040E1A),

            // MessageId: DB_E_GOALREJECTED
            // MessageText:
            //  Goal was rejected because no nonzero weights were specified for any goals supported. Current goal was not changed.
            DB_E_GOALREJECTED                = unchecked((int)0x80040E1C),

            // MessageId: DB_E_UNSUPPORTEDCONVERSION
            // MessageText:
            //  Requested conversion is not supported.
            DB_E_UNSUPPORTEDCONVERSION       = unchecked((int)0x80040E1D),

            // MessageId: DB_E_BADSTARTPOSITION
            // MessageText:
            //  No rows were returned because the offset value moves the position before the beginning or after the end of the rowset.
            DB_E_BADSTARTPOSITION            = unchecked((int)0x80040E1E),

            // MessageId: DB_E_NOQUERY
            // MessageText:
            //  Information was requested for a query and the query was not set.
            DB_E_NOQUERY                     = unchecked((int)0x80040E1F),

            // MessageId: DB_E_NOTREENTRANT
            // MessageText:
            //  Consumer's event handler called a non-reentrant method in the provider.
            DB_E_NOTREENTRANT                = unchecked((int)0x80040E20),

            // MessageId: DB_E_ERRORSOCCURRED
            // MessageText:
            //  Multiple-step operation generated errors. Check each status value. No work was done.
            DB_E_ERRORSOCCURRED              = unchecked((int)0x80040E21),

            // MessageId: DB_E_NOAGGREGATION
            // MessageText:
            //  Non-NULL controlling IUnknown was specified, and either the requested interface was not
            //  IUnknown, or the provider does not support COM aggregation.
            DB_E_NOAGGREGATION               = unchecked((int)0x80040E22),

            // MessageId: DB_E_DELETEDROW
            // MessageText:
            //  Row handle referred to a deleted row or a row marked for deletion.
            DB_E_DELETEDROW                  = unchecked((int)0x80040E23),

            // MessageId: DB_E_CANTFETCHBACKWARDS
            // MessageText:
            //  Rowset does not support fetching backward.
            DB_E_CANTFETCHBACKWARDS          = unchecked((int)0x80040E24),

            // MessageId: DB_E_ROWSNOTRELEASED
            // MessageText:
            //  Row handles must all be released before new ones can be obtained.
            DB_E_ROWSNOTRELEASED             = unchecked((int)0x80040E25),

            // MessageId: DB_E_BADSTORAGEFLAG
            // MessageText:
            //  One or more storage flags are not supported.
            DB_E_BADSTORAGEFLAG              = unchecked((int)0x80040E26),

            // MessageId: DB_E_BADCOMPAREOP
            // MessageText:
            //  Comparison operator is invalid.
            DB_E_BADCOMPAREOP                = unchecked((int)0x80040E27),

            // MessageId: DB_E_BADSTATUSVALUE
            // MessageText:
            //  Status flag was neither DBCOLUMNSTATUS_OK nor
            //  DBCOLUMNSTATUS_ISNULL.
            DB_E_BADSTATUSVALUE              = unchecked((int)0x80040E28),

            // MessageId: DB_E_CANTSCROLLBACKWARDS
            // MessageText:
            //  Rowset does not support scrolling backward.
            DB_E_CANTSCROLLBACKWARDS         = unchecked((int)0x80040E29),

            // MessageId: DB_E_BADREGIONHANDLE
            // MessageText:
            //  Region handle is invalid.
            DB_E_BADREGIONHANDLE             = unchecked((int)0x80040E2A),

            // MessageId: DB_E_NONCONTIGUOUSRANGE
            // MessageText:
            //  Set of rows is not contiguous to, or does not overlap, the rows in the watch region.
            DB_E_NONCONTIGUOUSRANGE          = unchecked((int)0x80040E2B),

            // MessageId: DB_E_INVALIDTRANSITION
            // MessageText:
            //  Transition from ALL* to MOVE* or EXTEND* was specified.
            DB_E_INVALIDTRANSITION           = unchecked((int)0x80040E2C),

            // MessageId: DB_E_NOTASUBREGION
            // MessageText:
            //  Region is not a proper subregion of the region identified by the watch region handle.
            DB_E_NOTASUBREGION               = unchecked((int)0x80040E2D),

            // MessageId: DB_E_MULTIPLESTATEMENTS
            // MessageText:
            //  Multiple-statement commands are not supported by this provider.
            DB_E_MULTIPLESTATEMENTS          = unchecked((int)0x80040E2E),

            // MessageId: DB_E_INTEGRITYVIOLATION
            // MessageText:
            //  Value violated the integrity constraints for a column or table.
            DB_E_INTEGRITYVIOLATION          = unchecked((int)0x80040E2F),

            // MessageId: DB_E_BADTYPENAME
            // MessageText:
            //  Type name is invalid.
            DB_E_BADTYPENAME                 = unchecked((int)0x80040E30),

            // MessageId: DB_E_ABORTLIMITREACHED
            // MessageText:
            //  Execution stopped because a resource limit was reached. No results were returned.
            DB_E_ABORTLIMITREACHED           = unchecked((int)0x80040E31),

            // MessageId: DB_E_ROWSETINCOMMAND
            // MessageText:
            //  Command object whose command tree contains a rowset or rowsets cannot be cloned.
            DB_E_ROWSETINCOMMAND             = unchecked((int)0x80040E32),

            // MessageId: DB_E_CANTTRANSLATE
            // MessageText:
            //  Current tree cannot be represented as text.
            DB_E_CANTTRANSLATE               = unchecked((int)0x80040E33),

            // MessageId: DB_E_DUPLICATEINDEXID
            // MessageText:
            //  Index already exists.
            DB_E_DUPLICATEINDEXID            = unchecked((int)0x80040E34),

            // MessageId: DB_E_NOINDEX
            // MessageText:
            //  Index does not exist.
            DB_E_NOINDEX                     = unchecked((int)0x80040E35),

            // MessageId: DB_E_INDEXINUSE
            // MessageText:
            //  Index is in use.
            DB_E_INDEXINUSE                  = unchecked((int)0x80040E36),

            // MessageId: DB_E_NOTABLE
            // MessageText:
            //  Table does not exist.
            DB_E_NOTABLE                     = unchecked((int)0x80040E37),

            // MessageId: DB_E_CONCURRENCYVIOLATION
            // MessageText:
            //  Rowset used optimistic concurrency and the value of a column has changed since it was last read.
            DB_E_CONCURRENCYVIOLATION        = unchecked((int)0x80040E38),

            // MessageId: DB_E_BADCOPY
            // MessageText:
            //  Errors detected during the copy.
            DB_E_BADCOPY                     = unchecked((int)0x80040E39),

            // MessageId: DB_E_BADPRECISION
            // MessageText:
            //  Precision is invalid.
            DB_E_BADPRECISION                = unchecked((int)0x80040E3A),

            // MessageId: DB_E_BADSCALE
            // MessageText:
            //  Scale is invalid.
            DB_E_BADSCALE                    = unchecked((int)0x80040E3B),

            // MessageId: DB_E_BADTABLEID
            // MessageText:
            //  Table ID is invalid.
            DB_E_BADTABLEID                  = unchecked((int)0x80040E3C),

            // MessageId: DB_E_BADTYPE
            // MessageText:
            //  Type is invalid.
            DB_E_BADTYPE                     = unchecked((int)0x80040E3D),

            // MessageId: DB_E_DUPLICATECOLUMNID
            // MessageText:
            //  Column ID already exists or occurred more than once in the array of columns.
            DB_E_DUPLICATECOLUMNID           = unchecked((int)0x80040E3E),

            // MessageId: DB_E_DUPLICATETABLEID
            // MessageText:
            //  Table already exists.
            DB_E_DUPLICATETABLEID            = unchecked((int)0x80040E3F),

            // MessageId: DB_E_TABLEINUSE
            // MessageText:
            //  Table is in use.
            DB_E_TABLEINUSE                  = unchecked((int)0x80040E40),

            // MessageId: DB_E_NOLOCALE
            // MessageText:
            //  Locale ID is not supported.
            DB_E_NOLOCALE                    = unchecked((int)0x80040E41),

            // MessageId: DB_E_BADRECORDNUM
            // MessageText:
            //  Record number is invalid.
            DB_E_BADRECORDNUM                = unchecked((int)0x80040E42),

            // MessageId: DB_E_BOOKMARKSKIPPED
            // MessageText:
            //  Form of bookmark is valid, but no row was found to match it.
            DB_E_BOOKMARKSKIPPED             = unchecked((int)0x80040E43),


            // MessageId: DB_E_BADPROPERTYVALUE
            // MessageText:
            //  Property value is invalid.
            DB_E_BADPROPERTYVALUE            = unchecked((int)0x80040E44),

            // MessageId: DB_E_INVALID
            // MessageText:
            //  Rowset is not chaptered.
            DB_E_INVALID                     = unchecked((int)0x80040E45),

            // MessageId: DB_E_BADACCESSORFLAGS
            // MessageText:
            //  One or more accessor flags were invalid.
            DB_E_BADACCESSORFLAGS            = unchecked((int)0x80040E46),

            // MessageId: DB_E_BADSTORAGEFLAGS
            // MessageText:
            //  One or more storage flags are invalid.
            DB_E_BADSTORAGEFLAGS             = unchecked((int)0x80040E47),

            // MessageId: DB_E_BYREFACCESSORNOTSUPPORTED
            // MessageText:
            //  Reference accessors are not supported by this provider.
            DB_E_BYREFACCESSORNOTSUPPORTED   = unchecked((int)0x80040E48),

            // MessageId: DB_E_NULLACCESSORNOTSUPPORTED
            // MessageText:
            //  Null accessors are not supported by this provider.
            DB_E_NULLACCESSORNOTSUPPORTED    = unchecked((int)0x80040E49),

            // MessageId: DB_E_NOTPREPARED
            // MessageText:
            //  Command was not prepared.
            DB_E_NOTPREPARED                 = unchecked((int)0x80040E4A),

            // MessageId: DB_E_BADACCESSORTYPE
            // MessageText:
            //  Accessor is not a parameter accessor.
            DB_E_BADACCESSORTYPE             = unchecked((int)0x80040E4B),

            // MessageId: DB_E_WRITEONLYACCESSOR
            // MessageText:
            //  Accessor is write-only.
            DB_E_WRITEONLYACCESSOR           = unchecked((int)0x80040E4C),

            // MessageId: DB_SEC_E_AUTH_FAILED
            // MessageText:
            //  Authentication failed.
            DB_SEC_E_AUTH_FAILED             = unchecked((int)0x80040E4D),

            // MessageId: DB_E_CANCELED
            // MessageText:
            //  Operation was canceled.
            DB_E_CANCELED                    = unchecked((int)0x80040E4E),

            // MessageId: DB_E_CHAPTERNOTRELEASED
            // MessageText:
            //  Rowset is single-chaptered. The chapter was not released.
            DB_E_CHAPTERNOTRELEASED          = unchecked((int)0x80040E4F),

            // MessageId: DB_E_BADSOURCEHANDLE
            // MessageText:
            //  Source handle is invalid.
            DB_E_BADSOURCEHANDLE             = unchecked((int)0x80040E50),

            // MessageId: DB_E_PARAMUNAVAILABLE
            // MessageText:
            //  Provider cannot derive parameter information and SetParameterInfo has not been called.
            DB_E_PARAMUNAVAILABLE            = unchecked((int)0x80040E51),

            // MessageId: DB_E_ALREADYINITIALIZED
            // MessageText:
            //  Data source object is already initialized.
            DB_E_ALREADYINITIALIZED          = unchecked((int)0x80040E52),

            // MessageId: DB_E_NOTSUPPORTED
            // MessageText:
            //  Method is not supported by this provider.
            DB_E_NOTSUPPORTED                = unchecked((int)0x80040E53),

            // MessageId: DB_E_MAXPENDCHANGESEXCEEDED
            // MessageText:
            //  Number of rows with pending changes exceeded the limit.
            DB_E_MAXPENDCHANGESEXCEEDED      = unchecked((int)0x80040E54),

            // MessageId: DB_E_BADORDINAL
            // MessageText:
            //  Column does not exist.
            DB_E_BADORDINAL                  = unchecked((int)0x80040E55),

            // MessageId: DB_E_PENDINGCHANGES
            // MessageText:
            //  Pending changes exist on a row with a reference count of zero.
            DB_E_PENDINGCHANGES              = unchecked((int)0x80040E56),

            // MessageId: DB_E_DATAOVERFLOW
            // MessageText:
            //  Literal value in the command exceeded the range of the type of the associated column.
            DB_E_DATAOVERFLOW                = unchecked((int)0x80040E57),

            // MessageId: DB_E_BADHRESULT
            // MessageText:
            //  HRESULT is invalid.
            DB_E_BADHRESULT                  = unchecked((int)0x80040E58),

            // MessageId: DB_E_BADLOOKUPID
            // MessageText:
            //  Lookup ID is invalid.
            DB_E_BADLOOKUPID                 = unchecked((int)0x80040E59),

            // MessageId: DB_E_BADDYNAMICERRORID
            // MessageText:
            //  DynamicError ID is invalid.
            DB_E_BADDYNAMICERRORID           = unchecked((int)0x80040E5A),

            // MessageId: DB_E_PENDINGINSERT
            // MessageText:
            //  Most recent data for a newly inserted row could not be retrieved because the insert is pending.
            DB_E_PENDINGINSERT               = unchecked((int)0x80040E5B),

            // MessageId: DB_E_BADCONVERTFLAG
            // MessageText:
            //  Conversion flag is invalid.
            DB_E_BADCONVERTFLAG              = unchecked((int)0x80040E5C),

            // MessageId: DB_E_BADPARAMETERNAME
            // MessageText:
            //  Parameter name is unrecognized.
            DB_E_BADPARAMETERNAME            = unchecked((int)0x80040E5D),

            // MessageId: DB_E_MULTIPLESTORAGE
            // MessageText:
            //  Multiple storage objects cannot be open simultaneously.
            DB_E_MULTIPLESTORAGE             = unchecked((int)0x80040E5E),

            // MessageId: DB_E_CANTFILTER
            // MessageText:
            //  Filter cannot be opened.
            DB_E_CANTFILTER                  = unchecked((int)0x80040E5F),

            // MessageId: DB_E_CANTORDER
            // MessageText:
            //  Order cannot be opened.
            DB_E_CANTORDER                   = unchecked((int)0x80040E60),

            // MessageId: MD_E_BADTUPLE
            // MessageText:
            //  Tuple is invalid.
            MD_E_BADTUPLE                    = unchecked((int)0x80040E61),

            // MessageId: MD_E_BADCOORDINATE
            // MessageText:
            //  Coordinate is invalid.
            MD_E_BADCOORDINATE               = unchecked((int)0x80040E62),


            // MessageId: MD_E_INVALIDAXIS
            // MessageText:
            //  Axis is invalid.
            MD_E_INVALIDAXIS                 = unchecked((int)0x80040E63),

            // MessageId: MD_E_INVALIDCELLRANGE
            // MessageText:
            //  One or more cell ordinals is invalid.
            MD_E_INVALIDCELLRANGE            = unchecked((int)0x80040E64),

            // MessageId: DB_E_NOCOLUMN
            // MessageText:
            //  Column ID is invalid.
            DB_E_NOCOLUMN                    = unchecked((int)0x80040E65),

            // MessageId: DB_E_COMMANDNOTPERSISTED
            // MessageText:
            //  Command does not have a DBID.
            DB_E_COMMANDNOTPERSISTED         = unchecked((int)0x80040E67),

            // MessageId: DB_E_DUPLICATEID
            // MessageText:
            //  DBID already exists.
            DB_E_DUPLICATEID                 = unchecked((int)0x80040E68),

            // MessageId: DB_E_OBJECTCREATIONLIMITREACHED
            // MessageText:
            //  Session cannot be created because maximum number of active sessions was already reached. Consumer must release one or more sessions before creating a new session object.
            DB_E_OBJECTCREATIONLIMITREACHED  = unchecked((int)0x80040E69),

            // MessageId: DB_E_BADINDEXID
            // MessageText:
            //  Index ID is invalid.
            DB_E_BADINDEXID                  = unchecked((int)0x80040E72),

            // MessageId: DB_E_BADINITSTRING
            // MessageText:
            //  Format of the initialization string does not conform to the OLE DB specification.
            DB_E_BADINITSTRING               = unchecked((int)0x80040E73),

            // MessageId: DB_E_NOPROVIDERSREGISTERED
            // MessageText:
            //  No OLE DB providers of this source type are registered.
            DB_E_NOPROVIDERSREGISTERED       = unchecked((int)0x80040E74),

            // MessageId: DB_E_MISMATCHEDPROVIDER
            // MessageText:
            //  Initialization string specifies a provider that does not match the active provider.
            DB_E_MISMATCHEDPROVIDER          = unchecked((int)0x80040E75),

            // MessageId: DB_E_BADCOMMANDID
            // MessageText:
            //  DBID is invalid.
            DB_E_BADCOMMANDID                = unchecked((int)0x80040E76),

            // MessageId: SEC_E_BADTRUSTEEID
            // MessageText:
            //  Trustee is invalid.
            SEC_E_BADTRUSTEEID               = unchecked((int)0x80040E6A),

            // MessageId: SEC_E_NOTRUSTEEID
            // MessageText:
            //  Trustee was not recognized for this data source.
            SEC_E_NOTRUSTEEID                = unchecked((int)0x80040E6B),

            // MessageId: SEC_E_NOMEMBERSHIPSUPPORT
            // MessageText:
            //  Trustee does not support memberships or collections.
            SEC_E_NOMEMBERSHIPSUPPORT        = unchecked((int)0x80040E6C),

            // MessageId: SEC_E_INVALIDOBJECT
            // MessageText:
            //  Object is invalid or unknown to the provider.
            SEC_E_INVALIDOBJECT              = unchecked((int)0x80040E6D),

            // MessageId: SEC_E_NOOWNER
            // MessageText:
            //  Object does not have an owner.
            SEC_E_NOOWNER                    = unchecked((int)0x80040E6E),

            // MessageId: SEC_E_INVALIDACCESSENTRYLIST
            // MessageText:
            //  Access entry list is invalid.
            SEC_E_INVALIDACCESSENTRYLIST     = unchecked((int)0x80040E6F),

            // MessageId: SEC_E_INVALIDOWNER
            // MessageText:
            //  Trustee supplied as owner is invalid or unknown to the provider.
            SEC_E_INVALIDOWNER               = unchecked((int)0x80040E70),

            // MessageId: SEC_E_INVALIDACCESSENTRY
            // MessageText:
            //  Permission in the access entry list is invalid.
            SEC_E_INVALIDACCESSENTRY         = unchecked((int)0x80040E71),

            // MessageId: DB_E_BADCONSTRAINTTYPE
            // MessageText:
            //  ConstraintType is invalid or not supported by the provider.
            DB_E_BADCONSTRAINTTYPE           = unchecked((int)0x80040E77),

            // MessageId: DB_E_BADCONSTRAINTFORM
            // MessageText:
            //  ConstraintType is not DBCONSTRAINTTYPE_FOREIGNKEY and cForeignKeyColumns is not zero.
            DB_E_BADCONSTRAINTFORM           = unchecked((int)0x80040E78),

            // MessageId: DB_E_BADDEFERRABILITY
            // MessageText:
            //  Specified deferrability flag is invalid or not supported by the provider.
            DB_E_BADDEFERRABILITY            = unchecked((int)0x80040E79),

            // MessageId: DB_E_BADMATCHTYPE
            // MessageText:
            //  MatchType is invalid or the value is not supported by the provider.
            DB_E_BADMATCHTYPE                = unchecked((int)0x80040E80),

            // MessageId: DB_E_BADUPDATEDELETERULE
            // MessageText:
            //  Constraint update rule or delete rule is invalid.
            DB_E_BADUPDATEDELETERULE         = unchecked((int)0x80040E8A),

            // MessageId: DB_E_BADCONSTRAINTID
            // MessageText:
            //  Constraint does not exist.
            DB_E_BADCONSTRAINTID             = unchecked((int)0x80040E8B),

            // MessageId: DB_E_BADCOMMANDFLAGS
            // MessageText:
            //  Command persistence flag is invalid.
            DB_E_BADCOMMANDFLAGS             = unchecked((int)0x80040E8C),

            // MessageId: DB_E_OBJECTMISMATCH
            // MessageText:
            //  rguidColumnType points to a GUID that does not match the object type of this column, or this column was not set.
            DB_E_OBJECTMISMATCH              = unchecked((int)0x80040E8D),

            // MessageId: DB_E_NOSOURCEOBJECT
            // MessageText:
            //  Source row does not exist.
            DB_E_NOSOURCEOBJECT              = unchecked((int)0x80040E91),

            // MessageId: DB_E_RESOURCELOCKED
            // MessageText:
            //  OLE DB object represented by this URL is locked by one or more other processes.
            DB_E_RESOURCELOCKED              = unchecked((int)0x80040E92),

            // MessageId: DB_E_NOTCOLLECTION
            // MessageText:
            //  Client requested an object type that is valid only for a collection.
            DB_E_NOTCOLLECTION               = unchecked((int)0x80040E93),

            // MessageId: DB_E_REOleDbNLY
            // MessageText:
            //  Caller requested write access to a read-only object.
            DB_E_REOleDbNLY                    = unchecked((int)0x80040E94),

            // MessageId: DB_E_ASYNCNOTSUPPORTED
            // MessageText:
            //  Asynchronous binding is not supported by this provider.
            DB_E_ASYNCNOTSUPPORTED           = unchecked((int)0x80040E95),

            // MessageId: DB_E_CANNOTCONNECT
            // MessageText:
            //  Connection to the server for this URL cannot be established.
            DB_E_CANNOTCONNECT               = unchecked((int)0x80040E96),

            // MessageId: DB_E_TIMEOUT
            // MessageText:
            //  Timeout occurred when attempting to bind to the object.
            DB_E_TIMEOUT                     = unchecked((int)0x80040E97),

            // MessageId: DB_E_RESOURCEEXISTS
            // MessageText:
            //  Object cannot be created at this URL because an object named by this URL already exists.
            DB_E_RESOURCEEXISTS              = unchecked((int)0x80040E98),

            // MessageId: DB_E_RESOURCEOUTOFSCOPE
            // MessageText:
            //  URL is outside of scope.
            DB_E_RESOURCEOUTOFSCOPE          = unchecked((int)0x80040E8E),

            // MessageId: DB_E_DROPRESTRICTED
            // MessageText:
            //  Column or constraint could not be dropped because it is referenced by a dependent view or constraint.
            DB_E_DROPRESTRICTED              = unchecked((int)0x80040E90),

            // MessageId: DB_E_DUPLICATECONSTRAINTID
            // MessageText:
            //  Constraint already exists.
            DB_E_DUPLICATECONSTRAINTID       = unchecked((int)0x80040E99),

            // MessageId: DB_E_OUTOFSPACE
            // MessageText:
            //  Object cannot be created at this URL because the server is out of physical storage.
            DB_E_OUTOFSPACE                  = unchecked((int)0x80040E9A),

            // MessageId: DB_SEC_E_SAFEMODE_DENIED
            // MessageText:
            //  Safety settings on this computer prohibit accessing a data source on another domain.
            DB_SEC_E_SAFEMODE_DENIED         = unchecked((int)0x80040E9B),

            // MessageId: DB_S_ROWLIMITEXCEEDED
            // MessageText:
            //  Fetching requested number of rows will exceed total number of active rows supported by the rowset.
            DB_S_ROWLIMITEXCEEDED            = 0x00040EC0,

            // MessageId: DB_S_COLUMNTYPEMISMATCH
            // MessageText:
            //  One or more column types are incompatible. Conversion errors will occur during copying.
            DB_S_COLUMNTYPEMISMATCH          = 0x00040EC1,

            // MessageId: DB_S_TYPEINFOOVERRIDDEN
            // MessageText:
            //  Parameter type information was overridden by caller.
            DB_S_TYPEINFOOVERRIDDEN          = 0x00040EC2,

            // MessageId: DB_S_BOOKMARKSKIPPED
            // MessageText:
            //  Bookmark was skipped for deleted or nonmember row.
            DB_S_BOOKMARKSKIPPED             = 0x00040EC3,

            // MessageId: DB_S_NONEXTROWSET
            // MessageText:
            //  No more rowsets.
            DB_S_NONEXTROWSET                = 0x00040EC5,

            // MessageId: DB_S_ENDOFROWSET
            // MessageText:
            //  Start or end of rowset or chapter was reached.
            DB_S_ENDOFROWSET                 = 0x00040EC6,

            // MessageId: DB_S_COMMANDREEXECUTED
            // MessageText:
            //  Command was reexecuted.
            DB_S_COMMANDREEXECUTED           = 0x00040EC7,

            // MessageId: DB_S_BUFFERFULL
            // MessageText:
            //  Operation succeeded, but status array or string buffer could not be allocated.
            DB_S_BUFFERFULL                  = 0x00040EC8,

            // MessageId: DB_S_NORESULT
            // MessageText:
            //  No more results.
            DB_S_NORESULT                    = 0x00040EC9,

            // MessageId: DB_S_CANTRELEASE
            // MessageText:
            //  Server cannot release or downgrade a lock until the end of the transaction.
            DB_S_CANTRELEASE                 = 0x00040ECA,

            // MessageId: DB_S_GOALCHANGED
            // MessageText:
            //  Weight is not supported or exceeded the supported limit, and was set to 0 or the supported limit.
            DB_S_GOALCHANGED                 = 0x00040ECB,

            // MessageId: DB_S_UNWANTEDOPERATION
            // MessageText:
            //  Consumer does not want to receive further notification calls for this operation.
            DB_S_UNWANTEDOPERATION           = 0x00040ECC,

            // MessageId: DB_S_DIALECTIGNORED
            // MessageText:
            //  Input dialect was ignored and command was processed using default dialect.
            DB_S_DIALECTIGNORED              = 0x00040ECD,

            // MessageId: DB_S_UNWANTEDPHASE
            // MessageText:
            //  Consumer does not want to receive further notification calls for this phase.
            DB_S_UNWANTEDPHASE               = 0x00040ECE,

            // MessageId: DB_S_UNWANTEDREASON
            // MessageText:
            //  Consumer does not want to receive further notification calls for this reason.
            DB_S_UNWANTEDREASON              = 0x00040ECF,

            // MessageId: DB_S_ASYNCHRONOUS
            // MessageText:
            //  Operation is being processed asynchronously.
            DB_S_ASYNCHRONOUS                = 0x00040ED0,

            // MessageId: DB_S_COLUMNSCHANGED
            // MessageText:
            //  Command was executed to reposition to the start of the rowset. Either the order of the columns changed, or columns were added to or removed from the rowset.
            DB_S_COLUMNSCHANGED              = 0x00040ED1,

            // MessageId: DB_S_ERRORSRETURNED
            // MessageText:
            //  Method had some errors, which were returned in the error array.
            DB_S_ERRORSRETURNED              = 0x00040ED2,

            // MessageId: DB_S_BADROWHANDLE
            // MessageText:
            //  Row handle is invalid.
            DB_S_BADROWHANDLE                = 0x00040ED3,

            // MessageId: DB_S_DELETEDROW
            // MessageText:
            //  Row handle referred to a deleted row.
            DB_S_DELETEDROW                  = 0x00040ED4,

            // MessageId: DB_S_TOOMANYCHANGES
            // MessageText:
            //  Provider cannot keep track of all the changes. Client must refetch the data associated with the watch region by using another method.
            DB_S_TOOMANYCHANGES              = 0x00040ED5,

            // MessageId: DB_S_STOPLIMITREACHED
            // MessageText:
            //  Execution stopped because a resource limit was reached. Results obtained so far were returned, but execution cannot resume.
            DB_S_STOPLIMITREACHED            = 0x00040ED6,

            // MessageId: DB_S_LOCKUPGRADED
            // MessageText:
            //  Lock was upgraded from the value specified.
            DB_S_LOCKUPGRADED                = 0x00040ED8,

            // MessageId: DB_S_PROPERTIESCHANGED
            // MessageText:
            //  One or more properties were changed as allowed by provider.
            DB_S_PROPERTIESCHANGED           = 0x00040ED9,

            // MessageId: DB_S_ERRORSOCCURRED
            // MessageText:
            //  Multiple-step operation completed with one or more errors. Check each status value.
            DB_S_ERRORSOCCURRED              = 0x00040EDA,

            // MessageId: DB_S_PARAMUNAVAILABLE
            // MessageText:
            //  Parameter is invalid.
            DB_S_PARAMUNAVAILABLE            = 0x00040EDB,

            // MessageId: DB_S_MULTIPLECHANGES
            // MessageText:
            //  Updating a row caused more than one row to be updated in the data source.
            DB_S_MULTIPLECHANGES             = 0x00040EDC,

            // MessageId: DB_S_NOTSINGLETON
            // MessageText:
            //  Row object was requested on a non-singleton result. First row was returned.
            DB_S_NOTSINGLETON                = 0x00040ED7,

            // MessageId: DB_S_NOROWSPECIFICCOLUMNS
            // MessageText:
            //  Row has no row-specific columns.
            DB_S_NOROWSPECIFICCOLUMNS        = 0x00040EDD,

            XACT_E_FIRST    = unchecked((int)0x8004d000),
            XACT_E_LAST = unchecked((int)0x8004d022),
            XACT_S_FIRST    = 0x4d000,
            XACT_S_LAST = 0x4d009,
            XACT_E_ALREADYOTHERSINGLEPHASE  = unchecked((int)0x8004d000),
            XACT_E_CANTRETAIN   = unchecked((int)0x8004d001),
            XACT_E_COMMITFAILED = unchecked((int)0x8004d002),
            XACT_E_COMMITPREVENTED  = unchecked((int)0x8004d003),
            XACT_E_HEURISTICABORT   = unchecked((int)0x8004d004),
            XACT_E_HEURISTICCOMMIT  = unchecked((int)0x8004d005),
            XACT_E_HEURISTICDAMAGE  = unchecked((int)0x8004d006),
            XACT_E_HEURISTICDANGER  = unchecked((int)0x8004d007),
            XACT_E_ISOLATIONLEVEL   = unchecked((int)0x8004d008),
            XACT_E_NOASYNC  = unchecked((int)0x8004d009),
            XACT_E_NOENLIST = unchecked((int)0x8004d00a),
            XACT_E_NOISORETAIN  = unchecked((int)0x8004d00b),
            XACT_E_NORESOURCE   = unchecked((int)0x8004d00c),
            XACT_E_NOTCURRENT   = unchecked((int)0x8004d00d),
            XACT_E_NOTRANSACTION    = unchecked((int)0x8004d00e),
            XACT_E_NOTSUPPORTED = unchecked((int)0x8004d00f),
            XACT_E_UNKNOWNRMGRID    = unchecked((int)0x8004d010),
            XACT_E_WRONGSTATE   = unchecked((int)0x8004d011),
            XACT_E_WRONGUOW = unchecked((int)0x8004d012),
            XACT_E_XTIONEXISTS  = unchecked((int)0x8004d013),
            XACT_E_NOIMPORTOBJECT   = unchecked((int)0x8004d014),
            XACT_E_INVALIDCOOKIE    = unchecked((int)0x8004d015),
            XACT_E_INDOUBT  = unchecked((int)0x8004d016),
            XACT_E_NOTIMEOUT    = unchecked((int)0x8004d017),
            XACT_E_ALREADYINPROGRESS    = unchecked((int)0x8004d018),
            XACT_E_ABORTED  = unchecked((int)0x8004d019),
            XACT_E_LOGFULL  = unchecked((int)0x8004d01a),
            XACT_E_TMNOTAVAILABLE   = unchecked((int)0x8004d01b),
            XACT_E_CONNECTION_DOWN  = unchecked((int)0x8004d01c),
            XACT_E_CONNECTION_DENIED    = unchecked((int)0x8004d01d),
            XACT_E_REENLISTTIMEOUT  = unchecked((int)0x8004d01e),
            XACT_E_TIP_CONNECT_FAILED   = unchecked((int)0x8004d01f),
            XACT_E_TIP_PROTOCOL_ERROR   = unchecked((int)0x8004d020),
            XACT_E_TIP_PULL_FAILED  = unchecked((int)0x8004d021),
            XACT_E_DEST_TMNOTAVAILABLE  = unchecked((int)0x8004d022),
            XACT_E_CLERKNOTFOUND    = unchecked((int)0x8004d080),
            XACT_E_CLERKEXISTS  = unchecked((int)0x8004d081),
            XACT_E_RECOVERYINPROGRESS   = unchecked((int)0x8004d082),
            XACT_E_TRANSACTIONCLOSED    = unchecked((int)0x8004d083),
            XACT_E_INVALIDLSN   = unchecked((int)0x8004d084),
            XACT_E_REPLAYREQUEST    = unchecked((int)0x8004d085),
            XACT_S_ASYNC    = 0x4d000,
            XACT_S_DEFECT   = 0x4d001,
            XACT_S_REOleDbNLY   = 0x4d002,
            XACT_S_SOMENORETAIN = 0x4d003,
            XACT_S_OKINFORM = 0x4d004,
            XACT_S_MADECHANGESCONTENT   = 0x4d005,
            XACT_S_MADECHANGESINFORM    = 0x4d006,
            XACT_S_ALLNORETAIN  = 0x4d007,
            XACT_S_ABORTING = 0x4d008,
            XACT_S_SINGLEPHASE  = 0x4d009,

            STG_E_INVALIDFUNCTION = unchecked((int)0x80030001),
            STG_E_FILENOTFOUND = unchecked((int)0x80030002),
            STG_E_PATHNOTFOUND = unchecked((int)0x80030003),
            STG_E_TOOMANYOPENFILES = unchecked((int)0x80030004),
            STG_E_ACCESSDENIED = unchecked((int)0x80030005),
            STG_E_INVALIDHANDLE = unchecked((int)0x80030006),
            STG_E_INSUFFICIENTMEMORY = unchecked((int)0x80030008),
            STG_E_INVALIDPOINTER = unchecked((int)0x80030009),
            STG_E_NOMOREFILES = unchecked((int)0x80030012),
            STG_E_DISKISWRITEPROTECTED = unchecked((int)0x80030013),
            STG_E_SEEKERROR = unchecked((int)0x80030019),
            STG_E_WRITEFAULT = unchecked((int)0x8003001D),
            STG_E_READFAULT = unchecked((int)0x8003001E),
            STG_E_SHAREVIOLATION = unchecked((int)0x80030020),
            STG_E_LOCKVIOLATION = unchecked((int)0x80030021),
            STG_E_FILEALREADYEXISTS = unchecked((int)0x80030050),
            STG_E_INVALIDPARAMETER = unchecked((int)0x80030057),
            STG_E_MEDIUMFULL = unchecked((int)0x80030070),
            STG_E_PROPSETMISMATCHED = unchecked((int)0x800300F0),
            STG_E_ABNORMALAPIEXIT = unchecked((int)0x800300FA),
            STG_E_INVALIDHEADER = unchecked((int)0x800300FB),
            STG_E_INVALIDNAME = unchecked((int)0x800300FC),
            STG_E_UNKNOWN = unchecked((int)0x800300FD),
            STG_E_UNIMPLEMENTEDFUNCTION = unchecked((int)0x800300FE),
            STG_E_INVALIDFLAG = unchecked((int)0x800300FF),
            STG_E_INUSE = unchecked((int)0x80030100),
            STG_E_NOTCURRENT = unchecked((int)0x80030101),
            STG_E_REVERTED = unchecked((int)0x80030102),
            STG_E_CANTSAVE = unchecked((int)0x80030103),
            STG_E_OLDFORMAT = unchecked((int)0x80030104),
            STG_E_OLDDLL = unchecked((int)0x80030105),
            STG_E_SHAREREQUIRED = unchecked((int)0x80030106),
            STG_E_NOTFILEBASEDSTORAGE = unchecked((int)0x80030107),
            STG_E_EXTANTMARSHALLINGS = unchecked((int)0x80030108),
            STG_E_DOCFILECORRUPT = unchecked((int)0x80030109),
            STG_E_BADBASEADDRESS = unchecked((int)0x80030110),
            STG_E_INCOMPLETE = unchecked((int)0x80030201),
            STG_E_TERMINATED = unchecked((int)0x80030202),
            STG_S_CONVERTED = 0x00030200,
            STG_S_BLOCK = 0x00030201,
            STG_S_RETRYNOW = 0x00030202,
            STG_S_MONITORING = 0x00030203,
        }

#if DEBUG
        private enum PropertyEnum {
            ABORTPRESERVE    = 0x2,
            ACCESSORDER  = 0xe7,
            ACTIVESESSIONS   = 0x3,
            ALTERCOLUMN  = 0xf5,
            APPENDONLY   = 0xbb,
            ASYNCTXNABORT    = 0xa8,
            ASYNCTXNCOMMIT   = 0x4,
            AUTH_CACHE_AUTHINFO  = 0x5,
            AUTH_ENCRYPT_PASSWORD    = 0x6,
            AUTH_INTEGRATED  = 0x7,
            AUTH_MASK_PASSWORD   = 0x8,
            AUTH_PASSWORD    = 0x9,
            AUTH_PERSIST_ENCRYPTED   = 0xa,
            AUTH_PERSIST_SENSITIVE_AUTHINFO  = 0xb,
            AUTH_USERID  = 0xc,
            BLOCKINGSTORAGEOBJECTS   = 0xd,
            BOOKMARKINFO = 0xe8,
            BOOKMARKS    = 0xe,
            BOOKMARKSKIPPED  = 0xf,
            BOOKMARKTYPE = 0x10,
            BYREFACCESSORS   = 0x78,
            CACHEDEFERRED    = 0x11,
            CANFETCHBACKWARDS    = 0x12,
            CANHOLDROWS  = 0x13,
            CANSCROLLBACKWARDS   = 0x15,
            CATALOGLOCATION  = 0x16,
            CATALOGTERM  = 0x17,
            CATALOGUSAGE = 0x18,
            CHANGEINSERTEDROWS   = 0xbc,
            CLIENTCURSOR = 0x104,
            COL_AUTOINCREMENT    = 0x1a,
            COL_DEFAULT  = 0x1b,
            COL_DESCRIPTION  = 0x1c,
            COL_FIXEDLENGTH  = 0xa7,
            COL_INCREMENT    = 0x11b,
            COL_ISLONG   = 0x119,
            COL_NULLABLE = 0x1d,
            COL_PRIMARYKEY   = 0x1e,
            COL_SEED = 0x11a,
            COL_UNIQUE   = 0x1f,
            COLUMNDEFINITION = 0x20,
            COLUMNLCID   = 0xf6,
            COLUMNRESTRICT   = 0x21,
            COMMANDTIMEOUT   = 0x22,
            COMMITPRESERVE   = 0x23,
            COMSERVICES  = 0x11d,
            CONCATNULLBEHAVIOR   = 0x24,
            CONNECTIONSTATUS = 0xf4,
            CURRENTCATALOG   = 0x25,
            DATASOURCE_TYPE  = 0xfb,
            DATASOURCENAME   = 0x26,
            DATASOURCEREOleDbNLY   = 0x27,
            DBMSNAME = 0x28,
            DBMSVER  = 0x29,
            DEFERRED = 0x2a,
            DELAYSTORAGEOBJECTS  = 0x2b,
            DSOTHREADMODEL   = 0xa9,
            FILTERCOMPAREOPS = 0xd1,
            FINDCOMPAREOPS   = 0xd2,
            GENERATEURL  = 0x111,
            GROUPBY  = 0x2c,
            HETEROGENEOUSTABLES  = 0x2d,
            HIDDENCOLUMNS    = 0x102,
            IAccessor    = 0x79,
            IBindResource    = 0x10c,
            IChapteredRowset = 0xca,
            IColumnsInfo = 0x7a,
            IColumnsInfo2    = 0x113,
            IColumnsRowset   = 0x7b,
            IConnectionPointContainer    = 0x7c,
            IConvertType = 0xc2,
            ICreateRow   = 0x10d,
            IDBAsynchStatus  = 0xcb,
            IDBBinderProperties  = 0x112,
            IDENTIFIERCASE   = 0x2e,
            IGetRow  = 0x10a,
            IGetSession  = 0x115,
            IGetSourceRow    = 0x116,
            ILockBytes   = 0x88,
            IMMOBILEROWS = 0x2f,
            IMultipleResults = 0xd9,
            INDEX_AUTOUPDATE = 0x30,
            INDEX_CLUSTERED  = 0x31,
            INDEX_FILLFACTOR = 0x32,
            INDEX_INITIALSIZE    = 0x33,
            INDEX_NULLCOLLATION  = 0x34,
            INDEX_NULLS  = 0x35,
            INDEX_PRIMARYKEY = 0x36,
            INDEX_SORTBOOKMARKS  = 0x37,
            INDEX_TEMPINDEX  = 0xa3,
            INDEX_TYPE   = 0x38,
            INDEX_UNIQUE = 0x39,
            INIT_ASYNCH  = 0xc8,
            INIT_BINDFLAGS   = 0x10e,
            INIT_CATALOG = 0xe9,
            INIT_DATASOURCE  = 0x3b,
            INIT_GENERALTIMEOUT  = 0x11c,
            INIT_HWND    = 0x3c,
            INIT_IMPERSONATION_LEVEL = 0x3d,
            INIT_LCID    = 0xba,
            INIT_LOCATION    = 0x3e,
            INIT_LOCKOWNER   = 0x10f,
            INIT_MODE    = 0x3f,
            INIT_OLEDBSERVICES   = 0xf8,
            INIT_PROMPT  = 0x40,
            INIT_PROTECTION_LEVEL    = 0x41,
            INIT_PROVIDERSTRING  = 0xa0,
            INIT_TIMEOUT = 0x42,
            IParentRowset    = 0x101,
            IRegisterProvider    = 0x114,
            IRow = 0x107,
            IRowChange   = 0x108,
            IRowSchemaChange = 0x109,
            IRowset  = 0x7e,
            IRowsetChange    = 0x7f,
            IRowsetCurrentIndex  = 0x117,
            IRowsetFind  = 0xcc,
            IRowsetIdentity  = 0x80,
            IRowsetIndex = 0x9f,
            IRowsetInfo  = 0x81,
            IRowsetLocate    = 0x82,
            IRowsetRefresh   = 0xf9,
            IRowsetResynch   = 0x84,
            IRowsetScroll    = 0x85,
            IRowsetUpdate    = 0x86,
            IRowsetView  = 0xd4,
            IScopedOperations    = 0x10b,
            ISequentialStream    = 0x89,
            IStorage = 0x8a,
            IStream  = 0x8b,
            ISupportErrorInfo    = 0x87,
            IViewChapter = 0xd5,
            IViewFilter  = 0xd6,
            IViewRowset  = 0xd7,
            IViewSort    = 0xd8,
            LITERALBOOKMARKS = 0x43,
            LITERALIDENTITY  = 0x44,
            LOCKMODE = 0xec,
            MARSHALLABLE = 0xc5,
            MAXINDEXSIZE = 0x46,
            MAXOPENCHAPTERS  = 0xc7,
            MAXOPENROWS  = 0x47,
            MAXORSINFILTER   = 0xcd,
            MAXPENDINGROWS   = 0x48,
            MAXROWS  = 0x49,
            MAXROWSIZE   = 0x4a,
            MAXROWSIZEINCLUDESBLOB   = 0x4b,
            MAXSORTCOLUMNS   = 0xce,
            MAXTABLESINSELECT    = 0x4c,
            MAYWRITECOLUMN   = 0x4d,
            MEMORYUSAGE  = 0x4e,
            MULTIPLECONNECTIONS  = 0xed,
            MULTIPLEPARAMSETS    = 0xbf,
            MULTIPLERESULTS  = 0xc4,
            MULTIPLESTORAGEOBJECTS   = 0x50,
            MULTITABLEUPDATE = 0x51,
            NOTIFICATIONGRANULARITY  = 0xc6,
            NOTIFICATIONPHASES   = 0x52,
            NOTIFYCOLUMNSET  = 0xab,
            NOTIFYROWDELETE  = 0xad,
            NOTIFYROWFIRSTCHANGE = 0xae,
            NOTIFYROWINSERT  = 0xaf,
            NOTIFYROWRESYNCH = 0xb1,
            NOTIFYROWSETCHANGED  = 0xd3,
            NOTIFYROWSETFETCHPOSITIONCHANGE  = 0xb3,
            NOTIFYROWSETRELEASE  = 0xb2,
            NOTIFYROWUNDOCHANGE  = 0xb4,
            NOTIFYROWUNDODELETE  = 0xb5,
            NOTIFYROWUNDOINSERT  = 0xb6,
            NOTIFYROWUPDATE  = 0xb7,
            NULLCOLLATION    = 0x53,
            OLEOBJECTS   = 0x54,
            OPENROWSETSUPPORT    = 0x118,
            ORDERBYCOLUMNSINSELECT   = 0x55,
            ORDEREDBOOKMARKS = 0x56,
            OTHERINSERT  = 0x57,
            OTHERUPDATEDELETE    = 0x58,
            OUTPUTPARAMETERAVAILABILITY  = 0xb8,
            OWNINSERT    = 0x59,
            OWNUPDATEDELETE  = 0x5a,
            PERSISTENTIDTYPE = 0xb9,
            PREPAREABORTBEHAVIOR = 0x5b,
            PREPARECOMMITBEHAVIOR    = 0x5c,
            PROCEDURETERM    = 0x5d,
            PROVIDERFRIENDLYNAME = 0xeb,
            PROVIDERMEMORY   = 0x103,
            PROVIDERNAME = 0x60,
            PROVIDEROLEDBVER = 0x61,
            PROVIDERVER  = 0x62,
            QUICKRESTART = 0x63,
            QUOTEDIDENTIFIERCASE = 0x64,
            REENTRANTEVENTS  = 0x65,
            REMOVEDELETED    = 0x66,
            REPORTMULTIPLECHANGES    = 0x67,
            RESETDATASOURCE  = 0xf7,
            RETURNPENDINGINSERTS = 0xbd,
            ROW_BULKOPS  = 0xea,
            ROWRESTRICT  = 0x68,
            ROWSET_ASYNCH    = 0xc9,
            ROWSETCONVERSIONSONCOMMAND   = 0xc0,
            ROWTHREADMODEL   = 0x69,
            SCHEMATERM   = 0x6a,
            SCHEMAUSAGE  = 0x6b,
            SERVERCURSOR = 0x6c,
            SERVERDATAONINSERT   = 0xef,
            SERVERNAME   = 0xfa,
            SESS_AUTOCOMMITISOLEVELS = 0xbe,
            SORTONINDEX  = 0xcf,
            SQLSUPPORT   = 0x6d,
            STORAGEFLAGS = 0xf0,
            STRONGIDENTITY   = 0x77,
            STRUCTUREDSTORAGE    = 0x6f,
            SUBQUERIES   = 0x70,
            SUPPORTEDTXNDDL  = 0xa1,
            SUPPORTEDTXNISOLEVELS    = 0x71,
            SUPPORTEDTXNISORETAIN    = 0x72,
            TABLETERM    = 0x73,
            TBL_TEMPTABLE    = 0x8c,
            TRANSACTEDOBJECT = 0x74,
            TRUSTEE_AUTHENTICATION   = 0xf2,
            TRUSTEE_NEWAUTHENTICATION    = 0xf3,
            TRUSTEE_USERNAME = 0xf1,
            UNIQUEROWS   = 0xee,
            UPDATABILITY = 0x75,
            USERNAME = 0x76
        }

        private enum DBTypeEnum {
            EMPTY       = 0,       //
            NULL        = 1,       //
            I2          = 2,       //
            I4          = 3,       //
            R4          = 4,       //
            R8          = 5,       //
            CY          = 6,       //
            DATE        = 7,       //
            BSTR        = 8,       //
            IDISPATCH   = 9,       //
            ERROR       = 10,      //
            BOOL        = 11,      //
            VARIANT     = 12,      //
            IUNKNOWN    = 13,      //
            DECIMAL     = 14,      //
            I1          = 16,      //
            UI1         = 17,      //
            UI2         = 18,      //
            UI4         = 19,      //
            I8          = 20,      //
            UI8         = 21,      //
            FILETIME    = 64,      // 2.0
            GUID        = 72,      //
            BYTES       = 128,     //
            STR         = 129,     //
            WSTR        = 130,     //
            NUMERIC     = 131,     // with potential overflow
            UDT         = 132,     // should never be encountered
            DBDATE      = 133,     //
            DBTIME      = 134,     //
            DBTIMESTAMP = 135,     // granularity reduced from 1ns to 100ns (sql is 3.33 milli seconds)
            HCHAPTER    = 136,     // 1.5
            PROPVARIANT = 138,     // 2.0 - as variant
            VARNUMERIC  = 139,     // 2.0 - as string else ConversionException

            BYREF_I2          = 0x4002,
            BYREF_I4          = 0x4003,
            BYREF_R4          = 0x4004,
            BYREF_R8          = 0x4005,
            BYREF_CY          = 0x4006,
            BYREF_DATE        = 0x4007,
            BYREF_BSTR        = 0x4008,
            BYREF_IDISPATCH   = 0x4009,
            BYREF_ERROR       = 0x400a,
            BYREF_BOOL        = 0x400b,
            BYREF_VARIANT     = 0x400c,
            BYREF_IUNKNOWN    = 0x400d,
            BYREF_DECIMAL     = 0x400e,
            BYREF_I1          = 0x4010,
            BYREF_UI1         = 0x4011,
            BYREF_UI2         = 0x4012,
            BYREF_UI4         = 0x4013,
            BYREF_I8          = 0x4014,
            BYREF_UI8         = 0x4015,
            BYREF_FILETIME    = 0x4040,
            BYREF_GUID        = 0x4048,
            BYREF_BYTES       = 0x4080,
            BYREF_STR         = 0x4081,
            BYREF_WSTR        = 0x4082,
            BYREF_NUMERIC     = 0x4083,
            BYREF_UDT         = 0x4084,
            BYREF_DBDATE      = 0x4085,
            BYREF_DBTIME      = 0x4086,
            BYREF_DBTIMESTAMP = 0x4087,
            BYREF_HCHAPTER    = 0x4088,
            BYREF_PROPVARIANT = 0x408a,
            BYREF_VARNUMERIC  = 0x408b,

            VECTOR      = 0x1000,
            ARRAY       = 0x2000,
            BYREF       = 0x4000,  //
            RESERVED    = 0x8000,  // SystemException
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\objectpool.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectPool.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Threading;

    internal class ObjectPoolWaitHandle : WaitHandle {
        // Mutex class finalizer will call CloseHandle, so we do not WaitHandle
        // finalizer to call CloseHandle on the same handle
        bool fCreatedForMutex = false;

        public ObjectPoolWaitHandle(bool fMutex) : base() {
            fCreatedForMutex = fMutex;
        }

        protected override void Dispose(bool disposing)
        {
            // In the case where we have created this for a Mutex, we
            // have created one Mutex that will "own" the handle and close
            // it when it gets cleaned up.  We must make sure that this object
            // never does the cleanup on that mutex.  
            if (!fCreatedForMutex)
                base.Dispose(disposing);
        }
    }

    // Class used to listen to transaction outcome events in the case of a manually enlisted
    // connection.  In this scenario, we cannot put the connection immediately back into the pool.
    // Instead, it must wait until TransactionOutcomeEvent is fired, and then we can put back into
    // the general population of the pool.

    // From Jagan Peri:
    // There will be a subtle difference between using voters and using outcome events. If you have 
    // registered as a voter, you will get the notification from msdtc as soon as the 2PC process has 
    // started. If you have registered for outcome events, you will get a notification from msdtc only 
    // after the 1st stage of the 2PC process is over (ie when msdtc has decided on the outcome of the
    // transaction).
    // In practical terms, this means there can be a delay of around 25msec or so, if you are using 
    // outcome events rather than voters, before the connection can be released to the main pool. 
    // I dont think this will have an impact on the systems overall performance (thruput, response 
    // time etc). There arent any correctness issues either. Just thought you should know about this.

    // I included the above to doc the fact that the transaction has been decided prior to our callback -
    // so we don't hand out this connection and try to re-enlist the connection prior to the first
    // one finishing.
    internal class TransactionOutcomeEvents : UnsafeNativeMethods.ITransactionOutcomeEvents {
        private ConnectionPool        _pool;
        private SqlInternalConnection _connection;
        private UCOMIConnectionPoint  _point;
        private Int32                 _cookie;
        private bool                  _signaled; // Bool in case signal occurs before Cookie is set.

        public TransactionOutcomeEvents(ConnectionPool pool, SqlInternalConnection connection, UCOMIConnectionPoint point) {
            _pool       = pool;
            _connection = connection;
            _point      = point;
        }

        public void SetCookie(Int32 cookie) {
            // Lock object to prevent race conditions between SetCookie and the OutcomeEvent calls
            lock (this) {
                _cookie = cookie;
                ReturnToPool(); // Call reset in case event signaled before cookie set.
            }
        }

        /*
        We do not care about the arguments to Committed, Aborted, or HeuristicDecision.
        The outcome of the transaction can be in-doubt if the connection between the MSDTC proxy 
        and the MSDTC TM was broken after the proxy asked the transaction manager to commit or 
        abort a transaction but before the transaction manager's response to the commit or abort 
        was received by the proxy. Note: Receiving this method call is not the same as the state 
        of the transaction being in-doubt.
        */

        public void Committed(bool fRetaining, IntPtr pNewUOW, Int32 hResutl) {
            this.TransactionCompleted();
        }
        public void Aborted(IntPtr pBoidReason, bool fRetaining, IntPtr pNewUOW, Int32 hResult) {
            this.TransactionCompleted();
        }
        public void HeuristicDecision(UInt32 decision, IntPtr pBoidReason, Int32 hResult) {
            this.TransactionCompleted();
        }
        public void Indoubt() {
            this.TransactionCompleted();
        }

        private void TransactionCompleted() {
            // Lock object to prevent race conditions between SetCookie and the OutcomeEvent calls
            lock (this) {
                _signaled = true;
                this.ReturnToPool();
            }
        }

        private void ReturnToPool() {
            if (_signaled) {
                if (null != _connection && null != _pool) {
                    _pool.PutNewConnection(_connection);
                    _pool       = null;
                    _connection = null;                    
                }

                if (0 != _cookie && null != _point) {
                    _point.Unadvise(_cookie);
                    _point  = null;
                    _cookie = 0;
                }
            }
        }
    }

    internal abstract class DefaultPoolControl {
        private static Random _random;
        private static bool   _initialized;
        private static UInt32 TOKEN_QUERY = 0x0008; // from winnt.h - #define TOKEN_QUERY (0x0008)

        private static void Initialize() {
            if (!_initialized) {
                try {
                    lock(typeof(DefaultPoolControl)) {
                        if (!_initialized) {
                            // This random number is only used to vary the cleanup time of the pool.
                            _random       = new Random(5101977); // Value obtained from Dave Driver
                            _initialized  = true;
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        private int    _cleanupWait;
        private int    _creationTimeout;
        private bool   _integratedSecurity;
        private String _key;
        private int    _maxPool;
        private int    _minPool;
        private IntPtr _SID;
        private IntPtr _tokenStruct;
        private bool   _transactionAffinity;

        public DefaultPoolControl(String key) {
            Initialize();
            SetupMembers();
            _key = key;
        }

        public DefaultPoolControl(String key, bool integratedSecurity, IntPtr SID, IntPtr tokenStruct) {
            Initialize();
            SetupMembers();
            _integratedSecurity = integratedSecurity;
            _key                = key;
            _SID                = SID;
            _tokenStruct        = tokenStruct;
        }

        ~DefaultPoolControl() {
            this.Dispose(false);
        }

        virtual protected void Dispose (bool disposing) {
            Marshal.FreeHGlobal(_tokenStruct);
            _tokenStruct = IntPtr.Zero;
        }

        private void SetupMembers() {
            // setup private members
            _cleanupWait         = _random.Next(12)+12;              // 2-4 minutes in 10 sec intervals:
            _cleanupWait        *= 10*1000;
            _creationTimeout     = 30000;                            // 30 seconds;
            _integratedSecurity  = false;
            _key                 = "";
            _maxPool             = 65536;
            _minPool             = 0;
            _SID                 = IntPtr.Zero;
            _tokenStruct         = IntPtr.Zero;
            _transactionAffinity = false;                            // No affinity            
        }

        public int CleanupTimeout { 
            get { 
                return _cleanupWait; 
            } 
            set { 
                _cleanupWait = value; 
            }
        }
        
        public int CreationTimeout { 
            get { 
                return _creationTimeout; 
            } 
            set { 
                _creationTimeout = value; 
            }
        }

        public bool IntegratedSecurity {
            get {
                return _integratedSecurity;
            }
            set {
                _integratedSecurity = value;
            }
        }

        public String Key {
            get { 
                return _key; 
            }
            set {
                _key = value;
            }
        }

        public int MaxPool { 
            get { 
                return _maxPool; 
            } 
            set { 
                _maxPool = value; 
            }
        }
        
        public int MinPool { 
            get { 
                return _minPool; 
            } 
            set { 
                _minPool = value; 
            }
        }

        public IntPtr SID { 
            get { 
                return _SID; 
            }
            set {
                _SID = value;
            }
        }

        public IntPtr TokenStruct {
            get {
                return _tokenStruct;
            }
            set {
                _tokenStruct = value;
            }
        }

        public bool TransactionAffinity { 
            get { 
                return _transactionAffinity; 
            } 
            set { 
                _transactionAffinity = value; 
            }
        }

        public abstract SqlInternalConnection CreateConnection(ConnectionPool p);
        public abstract void                  DestroyConnection(ConnectionPool p, SqlInternalConnection con);

        public virtual  bool                  EqualSid(IntPtr SID) {
            Debug.Assert(!SQL.IsPlatformWin9x(), "EqualSid called on Win9x!");
            return UnsafeNativeMethods.Advapi32.EqualSid(_SID, SID);
        }

        static private WindowsIdentity GetCurrentWindowsIdentity() { // MDAC 86807
            (new SecurityPermission(SecurityPermissionFlag.ControlPrincipal)).Assert();
            try {
                return WindowsIdentity.GetCurrent();
            }
            finally {
               CodeAccessPermission.RevertAssert();
            }
        }

        public static void ObtainSidInfo(out IntPtr SID, out IntPtr tokenStruct) {
            Debug.Assert(!SQL.IsPlatformWin9x(), "ObtainSidInfo called on Win9x!");

            WindowsIdentity identity = null;
            IntPtr token = IntPtr.Zero; // token handle - Free'd by WindowsIdentity if opened that way

            try {
                IntPtr threadHandle  = SafeNativeMethods.GetCurrentThread();
                bool returnValue = UnsafeNativeMethods.Advapi32.OpenThreadToken(threadHandle, TOKEN_QUERY, true, out token);

                if (!returnValue) {
                    returnValue = UnsafeNativeMethods.Advapi32.OpenThreadToken(threadHandle, TOKEN_QUERY, false, out token);
                    if (!returnValue) {
                        IntPtr processHandle = SafeNativeMethods.GetCurrentProcess();
                        returnValue = UnsafeNativeMethods.Advapi32.OpenProcessToken(processHandle, TOKEN_QUERY, out token);

                        if (!returnValue) {
                            // If we fail all three calls, fall back to previous method of getting token from 
                            // WindowsIdentity and let it throw the exception.  That way, this change will not
                            // result in a different exception for the failure case.
                            identity     = GetCurrentWindowsIdentity(); // obtain through WindowsIdentity
                            token        = identity.Token; // Free'd by WindowsIdentity.
                        }
                    }
                }
                 
                int             bufferLength = 2048;           // Suggested default given by Greg Fee.
                int             lengthNeeded = 0;

                tokenStruct = IntPtr.Zero;    // Zero it.

                try {
                    tokenStruct  = Marshal.AllocHGlobal(bufferLength);
                    
                    if (!UnsafeNativeMethods.Advapi32.GetTokenInformation(token, 1, tokenStruct, bufferLength, ref lengthNeeded)) {
                        if (lengthNeeded > bufferLength) {
                            bufferLength = lengthNeeded;
                            Marshal.FreeHGlobal(tokenStruct);
                            tokenStruct = Marshal.AllocHGlobal(bufferLength);

                            if (!UnsafeNativeMethods.Advapi32.GetTokenInformation(token, 1, tokenStruct, bufferLength, ref lengthNeeded)) {
                                throw SQL.IntegratedSecurityError(Marshal.GetLastWin32Error().ToString());
                            }
                        }
                        else {
                            throw SQL.IntegratedSecurityError(Marshal.GetLastWin32Error().ToString());
                        }
                    }
                }
                catch {
                    Marshal.FreeHGlobal(tokenStruct); // If an exception occurs - free tokenStruct
                    tokenStruct = IntPtr.Zero;
                    throw;
                }

                SID = Marshal.ReadIntPtr(tokenStruct, 0);
            }
            finally {
                if (token != IntPtr.Zero && identity == null) { // If token handle obtained by us, close it!
                    SafeNativeMethods.CloseHandle(token);
                }
            }

            GC.KeepAlive(identity); // Keep identity variable alive until after GetTokenInfo calls.
        }
    }

    internal sealed class ConnectionPool {
        private enum State {
            Initializing, 
            Running, 
            ShuttingDown,
        }

        //
        // Counter values:
        //
        private const long  cQon        =  unchecked((long)0x8000000000000000);
        private const long  cErrorFlag  =  (long)0x4000000000000000;
        private const long  cAddWait    =  (long)0x0000010000000000;
        private const long  cAddFree    =  (long)0x0000000000100000;
        private const long  cAddTotal   =  (long)0x0000000000000001;
        
        private const long Q_MASK       =  unchecked((long)0x8000000000000000);
        private const long ERROR_MASK   =  (long)0x4000000000000000;
        //                              =  0x3000000000000000; unused bits
        private const long WAIT_MASK    =  (long)0x0FFFFF0000000000;
        private const long FREE_MASK    =  (long)0x000000FFFFF00000;
        private const long TOTAL_MASK   =  (long)0x00000000000FFFFF;

        private class Counter {
            private Object _value;
            
            private Counter(Object value) {
                _value = value;
            }
            
            public Counter() {
                _value = (Object)((long)0);
            }
            
            public void Modify(long add) {
                while (true) {
                    Object oldval = _value;
                    Object newval = ((long)oldval) + add;

                    if(Interlocked.CompareExchange(ref _value, newval, oldval) == oldval) {
                        break;
                    }
                }
            }
            
            public bool TryUpdate(long newval, Counter clone) {
                Object onewval = (Object)newval;
                return(Interlocked.CompareExchange(ref _value, onewval, clone._value) == clone._value);
            }
            
            public long Value {
                get { 
                    return((long)_value); 
                }
            }
            
            public Counter Clone() {
                return (new Counter(_value));
            }
            
            public bool IsQueued     { get { return (Value < 0); } }
            public bool IsInError    { get { return ((int)((Value & ERROR_MASK) >> 60)) != 0; } }
            public int  WaitCount  { get { return (int)(( Value & WAIT_MASK) >> 40); } }
            public int  FreeCount  { get { return (int)((Value & FREE_MASK) >> 20); } }
            public int  TotalCount { get { return (int)(Value & TOTAL_MASK); } }
        }

        private const int MAX_Q_SIZE    = (int)0x00100000;

        private const int SEMAPHORE_HANDLE = (int)0x0;
        private const int ERROR_HANDLE     = (int)0x1;
        private const int CREATION_HANDLE  = (int)0x2;

        private const int WAIT_TIMEOUT   = (int)0x102;
        private const int WAIT_ABANDONED = (int)0x80;

        private const int ERROR_WAIT_DEFAULT = 5 * 1000; // 5 seconds

        private DefaultPoolControl     _ctrl;
        private State                  _state;
        private Counter                _poolCounter;
        private InterlockedStack       _stackOld;
        private InterlockedStack       _stackNew;
        private ObjectPoolWaitHandle[] _waitHandles;
        private Mutex                  _creationMutex;
        private Exception              _resError;
        private int                    _errorWait;
        private Timer                  _errorTimer;
        private int                    _cleanupWait;
        private Timer                  _cleanupTimer;
        private ResourcePool           _txPool;
        private ArrayList              _connections;

        public ConnectionPool(DefaultPoolControl ctrl) {
            _state       = State.Initializing;
            _ctrl        = ctrl;
            _poolCounter = new Counter();
            _stackOld    = new InterlockedStack();
            _stackNew    = new InterlockedStack();
            _waitHandles = new ObjectPoolWaitHandle[3];
            _waitHandles[SEMAPHORE_HANDLE] = CreateWaitHandle(SafeNativeMethods.CreateSemaphore(ADP.PtrZero, 0, MAX_Q_SIZE, ADP.PtrZero), false);
            _waitHandles[ERROR_HANDLE]     = CreateWaitHandle(SafeNativeMethods.CreateEvent(ADP.PtrZero, 1, 0, ADP.PtrZero), false);
            _creationMutex = new Mutex();
            _waitHandles[CREATION_HANDLE]  = CreateWaitHandle(_creationMutex.Handle, true);
            _errorWait   = ERROR_WAIT_DEFAULT;
            _cleanupWait = 0; // Set in CreateCleanupTimer
            _errorTimer  = null;  // No error yet.
            _connections = new ArrayList(_ctrl.MaxPool);

            if(ctrl.TransactionAffinity) {
                if (SQL.IsPlatformNT5()) {
                    _txPool = CreateResourcePool();
                }
            }

            _cleanupTimer = CreateCleanupTimer();
            _state = State.Running;

            // PerfCounters - this counter will never be decremented!
            SQL.IncrementPoolCount();

            // Make sure we're at quota by posting a callback to the threadpool.
            ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
        }

        private ResourcePool CreateResourcePool() {
            ResourcePool.TransactionEndDelegate enddelegate =  new ResourcePool.TransactionEndDelegate(this.PutEndTxConnection);
#if DEBUG
            try {
                (new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\COM3\\System.EnterpriseServices")).Assert(); // MDAC 84045
                try {
#endif
                    return new ResourcePool(enddelegate);
#if DEBUG
                }
                finally {
                    RegistryPermission.RevertAssert();
                }
            }
            catch {
                throw;
            }
#endif
        }

        //
        // Create/Destroy Object methods
        //

        private SqlInternalConnection CreateConnection() {
            SqlInternalConnection newCon = null;

            try {
                newCon = _ctrl.CreateConnection(this);

                Debug.Assert(newCon != null, "CreateConnection succeeded, but object null");

                newCon.InPool = true; // Mark as InPool prior to adding to list.

                lock (_connections.SyncRoot) {
                    _connections.Add(newCon);
                }

                _poolCounter.Modify(cAddTotal);

                // Reset the error wait:
                _errorWait = ERROR_WAIT_DEFAULT;
            }
            catch(Exception e)  {
                ADP.TraceException(e);

                newCon = null; // set to null, so we do not return bad new connection
                // Failed to create instance
                _resError = e;
                SafeNativeMethods.SetEvent(_waitHandles[ERROR_HANDLE].Handle);
                _poolCounter.Modify(cErrorFlag);
                _errorTimer = new Timer(new TimerCallback(this.ErrorCallback), null, _errorWait, _errorWait);
                _errorWait *= 2;
            }

            return newCon;
        }

        private void DestroyConnection(SqlInternalConnection con) {
            try {
                lock (_connections.SyncRoot) {
                    _connections.Remove(con);
                }
            }
            catch { // MDAC 80973
                throw;
            }
            _poolCounter.Modify(-cAddTotal);
            _ctrl.DestroyConnection(this, con);
        }

        //
        // CreateRequest methods
        //

        private SqlInternalConnection UserCreateRequest() {
            // called by user when they were not able to obtain a free connection but
            // instead obtained creation mutex

            Counter comp = _poolCounter.Clone();

            if (comp.IsInError) {
                return null;
            }

            if (comp.TotalCount < _ctrl.MaxPool) {
                // If we have an odd number of total connections, reclaim any dead connections.
                // If we did not find any connections to reclaim, create a new one.
                if ((comp.TotalCount & 0x1) == 0x1) {
                    if (!CheckForDeadConnections()) {
                        return (CreateConnection());
                    }
                }
                else {
                    return (CreateConnection());
                }
            }

            return null;
        }

        private void PoolCreateRequest(object state) {
            // called by pooler to ensure pool requests are currently being satisfied -
            // creation mutex has not been obtained

            // Before creating any new connections, reclaim any released connections that
            // were not closed.
            CheckForDeadConnections();

            Counter comp = _poolCounter.Clone();

            if (comp.IsInError) {
                return;
            }

            int nFree  = comp.FreeCount;
            int nWait  = comp.WaitCount;
            int nTotal = comp.TotalCount;
            
            if ((nTotal < _ctrl.MaxPool) && ( ((nFree == nWait) && (nTotal > 0)) || (nFree < nWait) || (nTotal < _ctrl.MinPool))) {
                // Check to see if pool was created using integrated security.  If so, check to make
                // sure identity of current user matches that of user that created pool.  If it doesn't match,
                // do not create any connections on the ThreadPool thread, since either Open will fail or we
                // will open a connection for this pool that does not belong in this pool.  The side effect of this
                // is that if using integrated security min pool size cannot be guaranteed.

                // Also - GetTokenInfo and EqualSID do not work on 9x.  WindowsIdentity does not work
                // either on 9x.  In fact, after checking with native there is no way to validate the
                // user on 9x, so simply don't.  It is a known issue in native, and we will handle
                // this the same way.
                if (_ctrl.IntegratedSecurity && !SQL.IsPlatformWin9x()) {
                    IntPtr SID         = IntPtr.Zero;
                    IntPtr tokenStruct = IntPtr.Zero;
                    try {
                        DefaultPoolControl.ObtainSidInfo(out SID, out tokenStruct);
                        if (!_ctrl.EqualSid(SID)) {
                            return;
                        }
                    }
                    finally {
                        Marshal.FreeHGlobal(tokenStruct);
                    }
                }
                
                try {
                    try {
                        // obtain creation mutex
                        _creationMutex.WaitOne();
                        
                        SqlInternalConnection newCon;

                        comp   = _poolCounter.Clone();
                        nFree  = comp.FreeCount;
                        nWait  = comp.WaitCount;
                        nTotal = comp.TotalCount;

                        // Check IsInError again after obtaining mutex
                        if (!comp.IsInError) {
                            while ((nTotal < _ctrl.MaxPool) && ( ((nFree == nWait) && (nTotal > 0)) || (nFree < nWait) || (nTotal < _ctrl.MinPool))) {
                                newCon = CreateConnection();
        
                                // We do not need to check error flag here, since we know if 
                                // CreateConnection returned null, we are in error case.
                                if (null != newCon) {
                                    PutNewConnection(newCon);
            
                                    comp   = _poolCounter.Clone();
                                    nFree  = comp.FreeCount;
                                    nWait  = comp.WaitCount;
                                    nTotal = comp.TotalCount;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                    finally { // ReleaseMutex
                        // always release
                        _creationMutex.ReleaseMutex();
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        // 
        // Cleanup and Error methods
        //

        private bool CheckForDeadConnections() {
            bool deadConnectionFound = false;

            try {
                lock(_connections.SyncRoot) {
                    object[] connections = _connections.ToArray();

                    int length = connections.Length;

                    for (int i=0; i<length; i++) {
                        SqlInternalConnection con = (SqlInternalConnection) connections[i];
                        
                        if (null != con && !con.InPool && null != con.ConnectionWeakRef && !con.ConnectionWeakRef.IsAlive) {
                            PutConnection(con);
                            deadConnectionFound = true;
                        }
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }

            return deadConnectionFound;
        }
        
        private Timer CreateCleanupTimer() {
            _cleanupWait = _ctrl.CleanupTimeout;
            return (new Timer(new TimerCallback(this.CleanupCallback), null, _cleanupWait, _cleanupWait));
        }
        
        // Called when the cleanup-timer ticks over.
        private void CleanupCallback(Object state) {
            // This is the automatic prunning method.  Every period, we will perform a two-step
            // process.  First, for the connections above MinPool, we will obtain the semaphore for
            // the connection and then destroy it if it was on the old stack.  We will
            // continue this until we either reach MinPool size, or we are unable to obtain a free
            // connection, or until we have exhausted all the connections on the old stack.  After
            // that, push all connections on the new stack to the old stack.  So, every period
            // the connections on the old stack are destroyed and the connections on the new stack
            // are pushed to the old stack.  All connections that are currently out and in use are
            // not on either stack.  With this logic, a connection is prunned if unused for at least
            // one period but not more than two periods.

            // Destroy free connections above MinPool size from old stack.
            while(_poolCounter.TotalCount > _ctrl.MinPool)
            {
                // While above MinPoolSize...

                if (_waitHandles[SEMAPHORE_HANDLE].WaitOne(0, false) /* != WAIT_TIMEOUT */) {
                    // We obtained a connection from the semaphore.
                    SqlInternalConnection con = (SqlInternalConnection) _stackOld.Pop();

                    if (con != null) {
                        // If we obtained one from the old stack, destroy it.
                        _poolCounter.Modify(-cAddFree);
                        DestroyConnection(con);
                    }
                    else {
                        // Else we exhausted the old stack, so break.
                        SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, 0);
                        break;
                    }
                }
                else break;
            }
            
            // Push to the old-stack.  For each free connection, move connection from new stack
            // to old stack.
            if(_waitHandles[SEMAPHORE_HANDLE].WaitOne(0, false) /* != WAIT_TIMEOUT */) { 
                for(;;) {
                    SqlInternalConnection con = (SqlInternalConnection) _stackNew.Pop();
                    if (con == null) {
                        break;
                    }

                    _stackOld.Push(con);
                }
                SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, 0);
            }

            // Make sure we're at quota by posting a callback to the threadpool.
            ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
        }

        private void ErrorCallback(Object state) {
            _poolCounter.Modify(-cErrorFlag);
            SafeNativeMethods.ResetEvent(_waitHandles[ERROR_HANDLE].Handle);
            Timer t     = _errorTimer;
            _errorTimer = null;
            if (t != null) {
                t.Dispose(); // Cancel timer request.
            }
        }

        private ObjectPoolWaitHandle CreateWaitHandle(IntPtr handle, bool fMutex) {
            ObjectPoolWaitHandle whandle = new ObjectPoolWaitHandle(fMutex);
            whandle.Handle = handle;
            return(whandle);
        }

        //
        // Pool Insert/Delete methods
        //

        public void PutNewConnection(SqlInternalConnection con) {
            con.InPool = true; // mark as back in pool
            _stackNew.Push(con);
            _poolCounter.Modify(cAddFree);
            SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, 0);
        }

        private void PutDeactivatedConnection(SqlInternalConnection con) {
            if (_state != State.ShuttingDown) {
                bool isInTransaction = con.Deactivate();

                if (con.CanBePooled()) {
                    // If manually enlisted, handle that case first!
                    if (null != con.ManualEnlistedTransaction) {
                        PutConnectionManualEnlisted(con);
                        return;
                    }

                    // Try shoving it in the tx context.  If that succeeds,
                    // we're done.
                    if (isInTransaction && TryPutResourceInContext(con)) {
                        con.InPool = true; // mark as back in pool 
                        return;
                    }

                    // If the above failed, we just shove it into our current
                    // store:        
                    PutNewConnection(con);
                }
                else {
                    DestroyConnection(con);
                    // Make sure we're at quota by posting a callback to the threadpool.
                    ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
                }
            }
            else {
                // If we're shutting down, we destroy the object.
                DestroyConnection(con);
            }
        }

        // Method called when the connection is put back into the pool while it is manually
        // enlisted in a distributed transaction.  We must create an outcome event and let the 
        // connection wait until the distributed transaction has finished.  Once it does, we then
        // put it back into the general population of the pool.
        private void PutConnectionManualEnlisted(SqlInternalConnection con) {
            ITransaction transaction = con.ManualEnlistedTransaction;

            con.ResetCachedTransaction(); // Null out con internal transaction reference
            con.InPool = true;            // Mark as in pool so it will not be reclaimed by CheckForDeadConnections

            // Create IConnectionPoint object - from ITransaction
            UCOMIConnectionPoint point = (UCOMIConnectionPoint) transaction;

            // Create outcome event - passing pool, connection, and the IConnectionPoint object
            TransactionOutcomeEvents outcomeEvent = new TransactionOutcomeEvents(this, con, point);
            
            Int32 cookie = 0;
            point.Advise(outcomeEvent, out cookie); // Register for callbacks, obtain cookie

            outcomeEvent.SetCookie(cookie); // Set the cookie on the event
        }

        // Internal, because it's called from the TxResourcePool as a callback.
        internal void PutEndTxConnection(object con)
        {
            if(_state == State.ShuttingDown) {
                DestroyConnection((SqlInternalConnection) con);
                return;
            }

            if(!(((SqlInternalConnection) con).CanBePooled())) {
                DestroyConnection((SqlInternalConnection) con);
                // Make sure we're at quota by posting a callback to the threadpool.
                ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
                return;
            }
            
            PutNewConnection((SqlInternalConnection) con);
        }

        private SqlInternalConnection TryGetResourceFromContext(out bool isInTransaction)
        {
            isInTransaction = false;

            SqlInternalConnection con = null;
            try {
                if(_ctrl.TransactionAffinity && ContextUtil.IsInTransaction) {
                    isInTransaction = true;
                    if (null != _txPool)
                        con = (SqlInternalConnection) _txPool.GetResource();
                }
                else {
                    isInTransaction = false;
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
            return(con);
        }

        private bool TryPutResourceInContext(SqlInternalConnection con) {
            try {
                if(_ctrl.TransactionAffinity && ContextUtil.IsInTransaction) {
                    if (null != _txPool) {
                        if(_txPool.PutResource(con)) {
                            return(true);
                        }
                    }
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
            return(false);
        }

        public DefaultPoolControl Control { 
            get { 
                return(_ctrl); 
            } 
        }

        public SqlInternalConnection GetConnection(out bool isInTransaction) {
            SqlInternalConnection con = null;

            isInTransaction = false;

            if(_state != State.Running) {
                return null;
            }
            
            // Try to get from the context if we're context specific:
            con = TryGetResourceFromContext(out isInTransaction);
            
            if (null == con) {
                _poolCounter.Modify(cAddWait);
            }
            
            ObjectPoolWaitHandle[] localWaitHandles = _waitHandles;

            while (con == null) {
                int r = WaitHandle.WaitAny(localWaitHandles, _ctrl.CreationTimeout, false);
                // From the WaitAny docs: "If more than one object became signaled during 
                // the call, this is the array index of the signaled object with the 
                // smallest index value of all the signaled objects."  This is important
                // so that the free object signal will be returned before a creation 
                // signal.

                if (r == WAIT_TIMEOUT) {
                    _poolCounter.Modify(-cAddWait);

                    return null;
                }
                else if (r == ERROR_HANDLE) {
                    // Throw the error that PoolCreateRequest stashed.
                    _poolCounter.Modify(-cAddWait);
                    throw _resError;
                }
                else if (r == CREATION_HANDLE) {
                    try {
                        try {
                            con = UserCreateRequest();

                            if (null != con) {
                                _poolCounter.Modify(-cAddWait);
                            }
                            else {
                                // If we were not able to create a connection, check to see if
                                // we reached MaxPool.  If so, we will no longer wait on the
                                // CreationHandle, but instead wait for a free connection or 
                                // the timeout.
                                // BUG - if we receive the CreationHandle midway into the wait
                                // period and re-wait, we will be waiting on the full period
                                if (_poolCounter.TotalCount == _ctrl.MaxPool) {
                                    if (!CheckForDeadConnections()) {
                                        // modify handle array not to wait on creation mutex anymore
                                        localWaitHandles    = new ObjectPoolWaitHandle[2];
                                        localWaitHandles[0] = _waitHandles[0];
                                        localWaitHandles[1] = _waitHandles[1];
                                    }
                                }
                            }
                        }
                        finally { // ReleaseMutex
                            _creationMutex.ReleaseMutex();
                        }
                    }
                    catch { // MDAC 80973
                        throw;
                    }
                }
                else {
                    //
                    //	guaranteed available inventory
                    //
                    _poolCounter.Modify(-cAddWait - cAddFree);
                    con = GetFromPool();
                }
            }

            Debug.Assert(con != null, "Failed to create pooled object, resulted in null instance.");

            return(con);
        }

        private SqlInternalConnection GetFromPool() {
            SqlInternalConnection res = null;
            
            res = (SqlInternalConnection) _stackNew.Pop();
            if(res == null) {
                res = (SqlInternalConnection) _stackOld.Pop();
            }
            
            // Shouldn't be null, we could assert here.
            Debug.Assert(res != null, "GetFromPool called with nothing in the pool!");

            return(res);
        }

        public void PutConnection(SqlInternalConnection con) {
            if (con == null) {
                throw ADP.ArgumentNull("con");
            }
            PutDeactivatedConnection(con);
        }

        /*

        These methods not called in V1.
        
        private void EmptyPool() {
            // This method only works properly when called by a finalizer, which 
            // is the only time it is currently called.

            // Since this is called by the GC there is only thread with a reference and so
            // the semaphore is not needed - simply empty both stacks.
            SqlInternalConnection con = (SqlInternalConnection) _stackOld.Pop();

            while(con != null) {
                _poolCounter.Modify(-cAddFree);
                DestroyConnection(con);
                con = (SqlInternalConnection) _stackOld.Pop();
            }

            con = (SqlInternalConnection) _stackNew.Pop();

            while(con != null) {
                _poolCounter.Modify(-cAddFree);
                DestroyConnection(con);
                con = (SqlInternalConnection) _stackNew.Pop();
            }            
        }

        public void Shutdown() {
            _state = State.ShuttingDown;
            if (_cleanupTimer != null) {
                ((IDisposable)_cleanupTimer).Dispose();
            }
            EmptyPool();
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\oledb\oledb_enum.cs ===
//------------------------------------------------------------------------------
// <copyright file="OLEDB_Enum.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OleDb {

    using System;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <include file='doc\OLEDB_Enum.uex' path='docs/doc[@for="DBStatus"]/*' />
    internal enum DBStatus { // from 4214.0
        S_OK                 = 0,
        E_BADACCESSOR        = 1,
        E_CANTCONVERTVALUE   = 2,
        S_ISNULL             = 3,
        S_TRUNCATED          = 4,
        E_SIGNMISMATCH       = 5,
        E_DATAOVERFLOW       = 6,
        E_CANTCREATE         = 7,
        E_UNAVAILABLE        = 8,
        E_PERMISSIONDENIED   = 9,
        E_INTEGRITYVIOLATION = 10,
        E_SCHEMAVIOLATION    = 11,
        E_BADSTATUS          = 12,
        S_DEFAULT            = 13,
        S_CELLEMPTY          = 14, // 2.0
        S_IGNORE             = 15, // 2.0
        E_DOESNOTEXIST       = 16, // 2.1
        E_INVALIDURL         = 17, // 2.1
        E_RESOURCELOCKED     = 18, // 2.1
        E_RESOURCEEXISTS     = 19, // 2.1
        E_CANNOTCOMPLETE     = 20, // 2.1
        E_VOLUMENOTFOUND     = 21, // 2.1
        E_OUTOFSPACE         = 22, // 2.1
        S_CANNOTDELETESOURCE = 23, // 2.1
        E_READONLY           = 24, // 2.1
        E_RESOURCEOUTOFSCOPE = 25, // 2.1
        S_ALREADYEXISTS      = 26, // 2.1
        E_CANCELED           = 27, // 2.5
        E_NOTCOLLECTION      = 28, // 2.5
        S_ROWSETCOLUMN       = 29, // 2.6
    }

    /// <include file='doc\OLEDB_Enum.uex' path='docs/doc[@for="NativeDBType"]/*' />
    sealed internal class NativeDBType { // from 4214.0
        // Variant compatible
        internal const int EMPTY       = 0;       //
        internal const int NULL        = 1;       //
        internal const int I2          = 2;       //
        internal const int I4          = 3;       //
        internal const int R4          = 4;       //
        internal const int R8          = 5;       //
        internal const int CY          = 6;       //
        internal const int DATE        = 7;       //
        internal const int BSTR        = 8;       //
        internal const int IDISPATCH   = 9;       //
        internal const int ERROR       = 10;      //
        internal const int BOOL        = 11;      //
        internal const int VARIANT     = 12;      //
        internal const int IUNKNOWN    = 13;      //
        internal const int DECIMAL     = 14;      //
        internal const int I1          = 16;      //
        internal const int UI1         = 17;      //
        internal const int UI2         = 18;      //
        internal const int UI4         = 19;      //
        internal const int I8          = 20;      //
        internal const int UI8         = 21;      //
        internal const int FILETIME    = 64;      // 2.0
        internal const int GUID        = 72;      //
        internal const int BYTES       = 128;     //
        internal const int STR         = 129;     //
        internal const int WSTR        = 130;     //
        internal const int NUMERIC     = 131;     // with potential overflow
        internal const int UDT         = 132;     // should never be encountered
        internal const int DBDATE      = 133;     //
        internal const int DBTIME      = 134;     //
        internal const int DBTIMESTAMP = 135;     // granularity reduced from 1ns to 100ns (sql is 3.33 milli seconds)
        internal const int HCHAPTER    = 136;     // 1.5
        internal const int PROPVARIANT = 138;     // 2.0 - as variant
        internal const int VARNUMERIC  = 139;     // 2.0 - as string else ConversionException
        internal const int VECTOR      = 0x1000;
        internal const int ARRAY       = 0x2000;
        internal const int BYREF       = 0x4000;  //
        internal const int RESERVED    = 0x8000;  // SystemException
        // high mask
        internal const int HighMask  = 0xf000;
#if DEBUG
        internal static bool HasHighBit(int value) {
            return (0 != (HighMask & value));
        }
        internal static bool IsArray(int value) {
            return (ARRAY == (HighMask & value));
        }
#endif
        internal static bool IsByRef(int value) {
            return (BYREF == (HighMask & value));
        }
#if DEBUG
        internal static bool IsReserved(int value) {
            return (RESERVED == (HighMask & value));
        }
        internal static bool IsVector(int value) {
            return (VECTOR == (HighMask & value));
        }
        internal static int GetLowBits(int value) {
            return (value & ~HighMask);
        }
#endif
        private const string S_BINARY        = "DBTYPE_BINARY"; // DBTYPE_BYTES
        private const string S_BOOL          = "DBTYPE_BOOL";
        private const string S_BSTR          = "DBTYPE_BSTR";
        private const string S_CHAR          = "DBTYPE_CHAR";  // DBTYPE_STR
        private const string S_CY            = "DBTYPE_CY";
        private const string S_DATE          = "DBTYPE_DATE";
        private const string S_DBDATE        = "DBTYPE_DBDATE";
        private const string S_DBTIME        = "DBTYPE_DBTIME";
        private const string S_DBTIMESTAMP   = "DBTYPE_DBTIMESTAMP";
        private const string S_DECIMAL       = "DBTYPE_DECIMAL";
        private const string S_ERROR         = "DBTYPE_ERROR";
        private const string S_FILETIME      = "DBTYPE_FILETIME";
        private const string S_GUID          = "DBTYPE_GUID";
        private const string S_I1            = "DBTYPE_I1";
        private const string S_I2            = "DBTYPE_I2";
        private const string S_I4            = "DBTYPE_I4";
        private const string S_I8            = "DBTYPE_I8";
        private const string S_IDISPATCH     = "DBTYPE_IDISPATCH";
        private const string S_IUNKNOWN      = "DBTYPE_IUNKNOWN";
        private const string S_LONGVARBINARY = "DBTYPE_LONGVARBINARY"; // DBTYPE_BYTES
        private const string S_LONGVARCHAR   = "DBTYPE_LONGVARCHAR"; // DBTYPE_STR
        private const string S_NUMERIC       = "DBTYPE_NUMERIC";
        private const string S_PROPVARIANT   = "DBTYPE_PROPVARIANT";
        private const string S_R4            = "DBTYPE_R4";
        private const string S_R8            = "DBTYPE_R8";
        private const string S_UDT           = "DBTYPE_UDT";
        private const string S_UI1           = "DBTYPE_UI1";
        private const string S_UI2           = "DBTYPE_UI2";
        private const string S_UI4           = "DBTYPE_UI4";
        private const string S_UI8           = "DBTYPE_UI8";
        private const string S_VARBINARY     = "DBTYPE_VARBINARY"; // DBTYPE_BYTES
        private const string S_VARCHAR       = "DBTYPE_VARCHAR"; // DBTYPE_STR
        private const string S_VARIANT       = "DBTYPE_VARIANT";
        private const string S_VARNUMERIC    = "DBTYPE_VARNUMERIC";
        private const string S_WCHAR         = "DBTYPE_WCHAR"; // DBTYPE_WSTR
        private const string S_WVARCHAR      = "DBTYPE_WVARCHAR"; // DBTYPE_WSTR
        private const string S_WLONGVARCHAR  = "DBTYPE_WLONGVARCHAR"; // DBTYPE_WSTR

        static private readonly NativeDBType D_Binary           = new NativeDBType(0xff, -1,          true,  false, OleDbType.Binary,           NativeDBType.BYTES,       S_BINARY,        typeof(System.Byte[]),   NativeDBType.BYTES,       DbType.Binary    ); //  0
        static private readonly NativeDBType D_Boolean          = new NativeDBType(0xff,  2,          true,  false, OleDbType.Boolean,          NativeDBType.BOOL,        S_BOOL,          typeof(System.Boolean),  NativeDBType.BOOL,        DbType.Boolean   ); //  1 - integer2 (variant_bool)
        static private readonly NativeDBType D_BSTR             = new NativeDBType(0xff, IntPtr.Size, false, false, OleDbType.BSTR,             NativeDBType.BSTR,        S_BSTR,          typeof(System.String),   NativeDBType.BSTR,        DbType.String    ); //  2 - integer4 (pointer)
        static private readonly NativeDBType D_Char             = new NativeDBType(0xff, -1,          true,  false, OleDbType.Char,             NativeDBType.STR,         S_CHAR,          typeof(System.String),   NativeDBType.WSTR/*STR*/, DbType.AnsiStringFixedLength); //  3 - (ansi pointer)
        static private readonly NativeDBType D_Currency         = new NativeDBType(  19,  8,          true,  false, OleDbType.Currency,         NativeDBType.CY,          S_CY,            typeof(System.Decimal),  NativeDBType.CY,          DbType.Currency  ); //  4 - integer8
        static private readonly NativeDBType D_Date             = new NativeDBType(0xff,  8,          true,  false, OleDbType.Date,             NativeDBType.DATE,        S_DATE,          typeof(System.DateTime), NativeDBType.DATE,        DbType.DateTime  ); //  5 - double
        static private readonly NativeDBType D_DBDate           = new NativeDBType(0xff,  6,          true,  false, OleDbType.DBDate,           NativeDBType.DBDATE,      S_DBDATE,        typeof(System.DateTime), NativeDBType.DBDATE,      DbType.Date      ); //  6 - (tagDBDate)
        static private readonly NativeDBType D_DBTime           = new NativeDBType(0xff,  6,          true,  false, OleDbType.DBTime,           NativeDBType.DBTIME,      S_DBTIME,        typeof(System.TimeSpan), NativeDBType.DBTIME,      DbType.Time      ); //  7 - (tagDBTime)
        static private readonly NativeDBType D_DBTimeStamp      = new NativeDBType(0xff, 16,          true,  false, OleDbType.DBTimeStamp,      NativeDBType.DBTIMESTAMP, S_DBTIMESTAMP,   typeof(System.DateTime), NativeDBType.DBTIMESTAMP, DbType.DateTime  ); //  8 - (tagDBTIMESTAMP)
        static private readonly NativeDBType D_Decimal          = new NativeDBType(  28, 16,          true,  false, OleDbType.Decimal,          NativeDBType.DECIMAL,     S_DECIMAL,       typeof(System.Decimal),  NativeDBType.DECIMAL,     DbType.Decimal   ); //  9 - (tagDec) // MDAC 68447
        static private readonly NativeDBType D_Error            = new NativeDBType(0xff,  4,          true,  false, OleDbType.Error,            NativeDBType.ERROR,       S_ERROR,         typeof(System.Int32),    NativeDBType.ERROR,       DbType.Int32     ); // 10 - integer4
        static private readonly NativeDBType D_Filetime         = new NativeDBType(0xff,  8,          true,  false, OleDbType.Filetime,         NativeDBType.FILETIME,    S_FILETIME,      typeof(System.DateTime), NativeDBType.FILETIME,    DbType.DateTime  ); // 11 - integer8 // MDAC 59504
        static private readonly NativeDBType D_Guid             = new NativeDBType(0xff, 16,          true,  false, OleDbType.Guid,             NativeDBType.GUID,        S_GUID,          typeof(System.Guid),     NativeDBType.GUID,        DbType.Guid      ); // 12 - ubyte[16]
        static private readonly NativeDBType D_TinyInt          = new NativeDBType(   3,  1,          true,  false, OleDbType.TinyInt,          NativeDBType.I1,          S_I1,            typeof(System.Int16),    NativeDBType.I1,          DbType.SByte     ); // 13 - integer1 // MDAC 59492
        static private readonly NativeDBType D_SmallInt         = new NativeDBType(   5,  2,          true,  false, OleDbType.SmallInt,         NativeDBType.I2,          S_I2,            typeof(System.Int16),    NativeDBType.I2,          DbType.Int16     ); // 14 - integer2
        static private readonly NativeDBType D_Integer          = new NativeDBType(  10,  4,          true,  false, OleDbType.Integer,          NativeDBType.I4,          S_I4,            typeof(System.Int32),    NativeDBType.I4,          DbType.Int32     ); // 15 - integer4
        static private readonly NativeDBType D_BigInt           = new NativeDBType(  19,  8,          true,  false, OleDbType.BigInt,           NativeDBType.I8,          S_I8,            typeof(System.Int64),    NativeDBType.I8,          DbType.Int64     ); // 16 - integer8
        static private readonly NativeDBType D_IDispatch        = new NativeDBType(0xff, IntPtr.Size, true,  false, OleDbType.IDispatch,        NativeDBType.IDISPATCH,   S_IDISPATCH,     typeof(System.Object),   NativeDBType.IDISPATCH,   DbType.Object    ); // 17 - integer4 (pointer)
        static private readonly NativeDBType D_IUnknown         = new NativeDBType(0xff, IntPtr.Size, true,  false, OleDbType.IUnknown,         NativeDBType.IUNKNOWN,    S_IUNKNOWN,      typeof(System.Object),   NativeDBType.IUNKNOWN,    DbType.Object    ); // 18 - integer4 (pointer) // MDAC 64040
        static private readonly NativeDBType D_LongVarBinary    = new NativeDBType(0xff, -1,          false, true,  OleDbType.LongVarBinary,    NativeDBType.BYTES,       S_LONGVARBINARY, typeof(System.Byte[]),   NativeDBType.BYTES,       DbType.Binary    ); // 19
        static private readonly NativeDBType D_LongVarChar      = new NativeDBType(0xff, -1,          false, true,  OleDbType.LongVarChar,      NativeDBType.STR,         S_LONGVARCHAR,   typeof(System.String),   NativeDBType.WSTR/*STR*/, DbType.AnsiString); // 20 - (ansi pointer)
        static private readonly NativeDBType D_Numeric          = new NativeDBType(  28, 19,          true,  false, OleDbType.Numeric,          NativeDBType.NUMERIC,     S_NUMERIC,       typeof(System.Decimal),  NativeDBType.NUMERIC,     DbType.Decimal   ); // 21 - (tagDB_Numeric)
        static private readonly NativeDBType D_PropVariant      = new NativeDBType(0xff, 16,          true,  false, OleDbType.PropVariant,      NativeDBType.PROPVARIANT, S_PROPVARIANT,   typeof(System.Object),   NativeDBType.VARIANT,     DbType.Object    ); // 22
        static private readonly NativeDBType D_Single           = new NativeDBType(   7,  4,          true,  false, OleDbType.Single,           NativeDBType.R4,          S_R4,            typeof(System.Single),   NativeDBType.R4,          DbType.Single    ); // 23 - single
        static private readonly NativeDBType D_Double           = new NativeDBType(  15,  8,          true,  false, OleDbType.Double,           NativeDBType.R8,          S_R8,            typeof(System.Double),   NativeDBType.R8,          DbType.Double    ); // 24 - double
        static private readonly NativeDBType D_UnsignedTinyInt  = new NativeDBType(   3,  1,          true,  false, OleDbType.UnsignedTinyInt,  NativeDBType.UI1,         S_UI1,           typeof(System.Byte),     NativeDBType.UI1,         DbType.Byte      ); // 25 - byte7
        static private readonly NativeDBType D_UnsignedSmallInt = new NativeDBType(   5,  2,          true,  false, OleDbType.UnsignedSmallInt, NativeDBType.UI2,         S_UI2,           typeof(System.Int32),    NativeDBType.UI2,         DbType.UInt16    ); // 26 - unsigned integer2
        static private readonly NativeDBType D_UnsignedInt      = new NativeDBType(  10,  4,          true,  false, OleDbType.UnsignedInt,      NativeDBType.UI4,         S_UI4,           typeof(System.Int64),    NativeDBType.UI4,         DbType.UInt32    ); // 27 - unsigned integer4
        static private readonly NativeDBType D_UnsignedBigInt   = new NativeDBType(  20,  8,          true,  false, OleDbType.UnsignedBigInt,   NativeDBType.UI8,         S_UI8,           typeof(System.Decimal),  NativeDBType.UI8,         DbType.UInt64    ); // 28 - unsigned integer8
        static private readonly NativeDBType D_VarBinary        = new NativeDBType(0xff, -1,          false, false, OleDbType.VarBinary,        NativeDBType.BYTES,       S_VARBINARY,     typeof(System.Byte[]),   NativeDBType.BYTES,       DbType.Binary    ); // 29
        static private readonly NativeDBType D_VarChar          = new NativeDBType(0xff, -1,          false, false, OleDbType.VarChar,          NativeDBType.STR,         S_VARCHAR,       typeof(System.String),   NativeDBType.WSTR/*STR*/, DbType.AnsiString); // 30 - (ansi pointer)
        static private readonly NativeDBType D_Variant          = new NativeDBType(0xff, 16,          true,  false, OleDbType.Variant,          NativeDBType.VARIANT,     S_VARIANT,       typeof(System.Object),   NativeDBType.VARIANT,     DbType.Object    ); // 31 - ubyte[16] (variant)
        static private readonly NativeDBType D_VarNumeric       = new NativeDBType( 255, 16,          true,  false, OleDbType.VarNumeric,       NativeDBType.VARNUMERIC,  S_VARNUMERIC,    typeof(System.Decimal),  NativeDBType.DECIMAL,     DbType.VarNumeric); // 32 - (unicode pointer)
        static private readonly NativeDBType D_WChar            = new NativeDBType(0xff, -1,          true,  false, OleDbType.WChar,            NativeDBType.WSTR,        S_WCHAR,         typeof(System.String),   NativeDBType.WSTR,        DbType.StringFixedLength); // 33 - (unicode pointer)
        static private readonly NativeDBType D_VarWChar         = new NativeDBType(0xff, -1,          false, false, OleDbType.VarWChar,         NativeDBType.WSTR,        S_WVARCHAR,      typeof(System.String),   NativeDBType.WSTR,        DbType.String    ); // 34 - (unicode pointer)
        static private readonly NativeDBType D_LongVarWChar     = new NativeDBType(0xff, -1,          false, true,  OleDbType.LongVarWChar,     NativeDBType.WSTR,        S_WLONGVARCHAR,  typeof(System.String),   NativeDBType.WSTR,        DbType.String    ); // 35 - (unicode pointer)
        static private readonly NativeDBType D_Chapter          = new NativeDBType(0xff, IntPtr.Size, false, false, OleDbType.Empty,            NativeDBType.HCHAPTER,    S_UDT,           typeof(IDataReader),     NativeDBType.HCHAPTER,    DbType.Object    ); // 36 - (hierarchical chaper)
        static private readonly NativeDBType D_Empty            = new NativeDBType(0xff,  0,          false, false, OleDbType.Empty,            NativeDBType.EMPTY,       "",              null,                    NativeDBType.EMPTY,       DbType.Object    ); // 37 - invalid param default

        static internal readonly NativeDBType Default = D_VarWChar; // MDAC 65324
        static internal readonly Byte MaximumDecimalPrecision = D_Decimal.maxpre;

        private const int FixedDbPart = /*DBPART_VALUE*/0x1 | /*DBPART_STATUS*/0x4;
        private const int VarblDbPart = /*DBPART_VALUE*/0x1 | /*DBPART_LENGTH*/0x2 | /*DBPART_STATUS*/0x4;


        // OLEDB is required to support BYREF on variable length data types
        // please leave dbTypeTable in same sort order as DBSTRING
        // store 8-bytes for the fixed size of pointers for the eventual 64-bitness
        static private readonly NativeDBType[] dbTypeTable = new NativeDBType[38] {
             D_Binary
            ,D_Boolean
            ,D_BSTR
            ,D_Char
            ,D_Currency
            ,D_Date
            ,D_DBDate
            ,D_DBTime
            ,D_DBTimeStamp
            ,D_Decimal
            ,D_Error
            ,D_Filetime
            ,D_Guid
            ,D_TinyInt
            ,D_SmallInt
            ,D_Integer
            ,D_BigInt
            ,D_IDispatch
            ,D_IUnknown
            ,D_LongVarBinary
            ,D_LongVarChar
            ,D_Numeric
            ,D_PropVariant
            ,D_Single
            ,D_Double
            ,D_UnsignedTinyInt
            ,D_UnsignedSmallInt
            ,D_UnsignedInt
            ,D_UnsignedBigInt
            ,D_VarBinary
            ,D_VarChar
            ,D_Variant
            ,D_VarNumeric
            ,D_WChar
            ,D_VarWChar
            ,D_LongVarWChar
            ,D_Chapter
            ,D_Empty
        };

        internal readonly OleDbType enumOleDbType; // enum System.Data.OleDb.OleDbType
        internal readonly DbType    enumDbType;    // enum System.Data.DbType
        internal readonly int       dbType;        // OLE DB DBTYPE_
        internal readonly int       wType;         // OLE DB DBTYPE_ we ask OleDB Provider to bind as
        internal readonly Type      dataType;      // CLR Type

        internal readonly int       dbPart;    // the DBPart w or w/out length
        internal readonly bool      isfixed;   // IsFixedLength
        internal readonly bool      islong;    // IsLongLength
        internal readonly Byte      maxpre;    // maxium precision for numeric types // $CONSIDER - are we going to use this?
        internal readonly int       fixlen;    // fixed length size in bytes (-1 for variable)

        internal readonly String    dataSourceType; // ICommandWithParameters.SetParameterInfo standard type name 
        internal          IntPtr    dbString;       // ptr to native allocated memory for dataSourceType string

        private NativeDBType(Byte maxpre, int fixlen, bool isfixed, bool islong, OleDbType enumOleDbType, int dbType, string dbstring, Type dataType, int wType, DbType enumDbType) {
            this.enumOleDbType  = enumOleDbType;
            this.dbType    = dbType;
            this.dbPart    = (-1 == fixlen) ? VarblDbPart : FixedDbPart;
            this.isfixed   = isfixed;
            this.islong    = islong;
            this.maxpre    = maxpre;
            this.fixlen    = fixlen;
            this.wType     = wType;
            this.dataSourceType = dbstring;
            this.dbString  = Marshal.StringToCoTaskMemUni(dbstring);
            this.dataType  = dataType;
            this.enumDbType = enumDbType;
        }

        ~NativeDBType() {
            Marshal.FreeCoTaskMem(this.dbString); // FreeCoTaskMem protects itself from IntPtr.Zero
            this.dbString = IntPtr.Zero;
        }

        override public string ToString() {
            return enumOleDbType.ToString("G");
        }

        static internal NativeDBType FromDataType(OleDbType enumOleDbType) {
            switch(enumOleDbType) { // @perfnote: Enum.IsDefined
            case OleDbType.Empty:            return D_Empty;            //   0
            case OleDbType.SmallInt:         return D_SmallInt;         //   2
            case OleDbType.Integer:          return D_Integer;          //   3
            case OleDbType.Single:           return D_Single;           //   4
            case OleDbType.Double:           return D_Double;           //   5
            case OleDbType.Currency:         return D_Currency;         //   6
            case OleDbType.Date:             return D_Date;             //   7 
            case OleDbType.BSTR:             return D_BSTR;             //   8
            case OleDbType.IDispatch:        return D_IDispatch;        //   9
            case OleDbType.Error:            return D_Error;            //  10
            case OleDbType.Boolean:          return D_Boolean;          //  11
            case OleDbType.Variant:          return D_Variant;          //  12
            case OleDbType.IUnknown:         return D_IUnknown;         //  13
            case OleDbType.Decimal:          return D_Decimal;          //  14
            case OleDbType.TinyInt:          return D_TinyInt;          //  16
            case OleDbType.UnsignedTinyInt:  return D_UnsignedTinyInt;  //  17
            case OleDbType.UnsignedSmallInt: return D_UnsignedSmallInt; //  18
            case OleDbType.UnsignedInt:      return D_UnsignedInt;      //  19
            case OleDbType.BigInt:           return D_BigInt;           //  20
            case OleDbType.UnsignedBigInt:   return D_UnsignedBigInt;   //  21
            case OleDbType.Filetime:         return D_Filetime;         //  64
            case OleDbType.Guid:             return D_Guid;             //  72
            case OleDbType.Binary:           return D_Binary;           // 128
            case OleDbType.Char:             return D_Char;             // 129
            case OleDbType.WChar:            return D_WChar;            // 130
            case OleDbType.Numeric:          return D_Numeric;          // 131
            case OleDbType.DBDate:           return D_DBDate;           // 133
            case OleDbType.DBTime:           return D_DBTime;           // 134
            case OleDbType.DBTimeStamp:      return D_DBTimeStamp;      // 135
            case OleDbType.PropVariant:      return D_PropVariant;      // 138
            case OleDbType.VarNumeric:       return D_VarNumeric;       // 139
            case OleDbType.VarChar:          return D_VarChar;          // 200
            case OleDbType.LongVarChar:      return D_LongVarChar;      // 201
            case OleDbType.VarWChar:         return D_VarWChar;         // 202 // MDAC 64983: ORA-12704: character set mismatch
            case OleDbType.LongVarWChar:     return D_LongVarWChar;     // 203
            case OleDbType.VarBinary:        return D_VarBinary;        // 204
            case OleDbType.LongVarBinary:    return D_LongVarBinary;    // 205
            default:
                throw ODB.InvalidOleDbType((int) enumOleDbType);
            }
        }

        static internal NativeDBType FromSystemType(Type dataType) {
            switch(Type.GetTypeCode(dataType)) {
                case TypeCode.Empty:     return NativeDBType.D_Empty;
                case TypeCode.Object:
                    if (dataType == typeof(System.Byte[])) {
                        return NativeDBType.D_VarBinary;
                    }
                    else if (dataType == typeof(System.Guid)) {
                        return NativeDBType.D_Guid;
                    }
                    else if (dataType == typeof(System.TimeSpan)) {
                        return NativeDBType.D_DBTime;
                    }
                    else if (dataType == typeof(System.Object)) {
                        return NativeDBType.D_Variant;
                    }
                    throw ADP.UnknownDataType(dataType);

                case TypeCode.DBNull:    throw ADP.InvalidDataType(TypeCode.DBNull);
                case TypeCode.Boolean:   return NativeDBType.D_Boolean;
                case TypeCode.Char:      return NativeDBType.D_Char;
                case TypeCode.SByte:     return NativeDBType.D_TinyInt;
                case TypeCode.Byte:      return NativeDBType.D_UnsignedTinyInt;
                case TypeCode.Int16:     return NativeDBType.D_SmallInt;
                case TypeCode.UInt16:    return NativeDBType.D_UnsignedSmallInt;
                case TypeCode.Int32:     return NativeDBType.D_Integer;
                case TypeCode.UInt32:    return NativeDBType.D_UnsignedInt;
                case TypeCode.Int64:     return NativeDBType.D_BigInt;
                case TypeCode.UInt64:    return NativeDBType.D_UnsignedBigInt;
                case TypeCode.Single:    return NativeDBType.D_Single;
                case TypeCode.Double:    return NativeDBType.D_Double;
                case TypeCode.Decimal:   return NativeDBType.D_Decimal;
                case TypeCode.DateTime:  return NativeDBType.D_DBTimeStamp;
                case TypeCode.String:    return NativeDBType.D_VarWChar;
                default:                 throw ADP.UnknownDataTypeCode(dataType, Type.GetTypeCode(dataType));
            }
        }

        static internal NativeDBType FromDbType(DbType dbType) {
            switch(dbType) {
            case DbType.AnsiString: return D_VarChar;
            case DbType.AnsiStringFixedLength: return D_Char;
            case DbType.Binary:     return D_VarBinary;
            case DbType.Byte:       return D_UnsignedTinyInt;
            case DbType.Boolean:    return D_Boolean;
            case DbType.Currency:   return D_Currency;
            case DbType.Date:       return D_DBDate;
            case DbType.DateTime:   return D_DBTimeStamp;
            case DbType.Decimal:    return D_Decimal;
            case DbType.Double:     return D_Double;
            case DbType.Guid:       return D_Guid;
            case DbType.Int16:      return D_SmallInt;
            case DbType.Int32:      return D_Integer;
            case DbType.Int64:      return D_BigInt;
            case DbType.Object:     return D_Variant;
            case DbType.SByte:      return D_TinyInt;
            case DbType.Single:     return D_Single;
            case DbType.String:     return D_VarWChar;
            case DbType.StringFixedLength: return D_WChar;
            case DbType.Time:       return D_DBTime;
            case DbType.UInt16:     return D_UnsignedSmallInt;
            case DbType.UInt32:     return D_UnsignedInt;
            case DbType.UInt64:     return D_UnsignedBigInt;
            case DbType.VarNumeric: return D_VarNumeric;
            default:
                throw ADP.DbTypeNotSupported(dbType, typeof(OleDbType)); // MDAC 66009
            }
        }        

        static internal NativeDBType FromDBType(int dbType, bool isLong, bool isFixed) {
            switch(dbType) {
          //case EMPTY:
          //case NULL:
            case I2:            return D_SmallInt;
            case I4:            return D_Integer;
            case R4:            return D_Single;
            case R8:            return D_Double;
            case CY:            return D_Currency;
            case DATE:          return D_Date;
            case BSTR:          return D_BSTR;
            case IDISPATCH:     return D_IDispatch;
            case ERROR:         return D_Error;
            case BOOL:          return D_Boolean;
            case VARIANT:       return D_Variant;
            case IUNKNOWN:      return D_IUnknown;
            case DECIMAL:       return D_Decimal;
            case I1:            return D_TinyInt;
            case UI1:           return D_UnsignedTinyInt;
            case UI2:           return D_UnsignedSmallInt;
            case UI4:           return D_UnsignedInt;
            case I8:            return D_BigInt;
            case UI8:           return D_UnsignedBigInt;
            case FILETIME:      return D_Filetime;
            case GUID:          return D_Guid;
            case BYTES:         return (isLong) ? D_LongVarBinary : (isFixed) ? D_Binary : D_VarBinary;
            case STR:           return (isLong) ? D_LongVarChar : (isFixed) ? D_Char : D_VarChar;
            case WSTR:          return (isLong) ? D_LongVarWChar : (isFixed) ? D_WChar : D_VarWChar;
            case NUMERIC:       return D_Numeric;
          //case UDT:
            case DBDATE:        return D_DBDate;
            case DBTIME:        return D_DBTime;
            case DBTIMESTAMP:   return D_DBTimeStamp;
            case HCHAPTER:      return D_Chapter;
            case PROPVARIANT:   return D_PropVariant;
            case VARNUMERIC:    return D_VarNumeric;
          //case VECTOR:
          //case ARRAY:
          //case BYREF:
          //case RESERVED:
            default:
                if (0 != (NativeDBType.VECTOR & dbType)) {
                    throw ODB.DBBindingGetVector();
                }
                return D_Variant; // MDAC 72067
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlclientpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlClientPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Collections;
    using System.Data.Common;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission"]/*' />
    [Serializable] sealed public class SqlClientPermission :  DBDataPermission {

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission.SqlClientPermission"]/*' />
        [ Obsolete("use SqlClientPermission(PermissionState.None)", true) ]
        public SqlClientPermission() {
        }

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission.SqlClientPermission1"]/*' />
        public SqlClientPermission(PermissionState state) : base(state) {
        }

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission.SqlClientPermission2"]/*' />
        [ Obsolete("use SqlClientPermission(PermissionState.None)", true) ]
        public SqlClientPermission(PermissionState state, bool allowBlankPassword) : base(state, allowBlankPassword) {
        }

        private SqlClientPermission(SqlClientPermission permission) : base(permission) { // for Copy
        }

        internal SqlClientPermission(SqlClientPermissionAttribute permissionAttribute) : base(permissionAttribute) { // for CreatePermission
        }

        internal SqlClientPermission(SqlConnectionString constr) : base(constr) { // for Open
        }

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission.Add"]/*' />
        override public void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior) {
            switch(behavior) {
            case KeyRestrictionBehavior.PreventUsage:
            case KeyRestrictionBehavior.AllowOnly:
                break;
            default:
                throw ADP.Argument("value");
            }
            DBConnectionString entry = new SqlConnectionString(connectionString, restrictions, behavior); // MDAC 85142
            base.AddPermissionEntry(entry);
        }

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermission.Copy"]/*' />
        override public IPermission Copy () {
            return new SqlClientPermission(this);
        }
    }

    /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )] 
    [Serializable()] sealed public class SqlClientPermissionAttribute : DBDataPermissionAttribute {

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermissionAttribute.SqlClientPermissionAttribute"]/*' />
        public SqlClientPermissionAttribute(SecurityAction action) : base(action) {
        }

        /// <include file='doc\SqlClientPermission.uex' path='docs/doc[@for="SqlClientPermissionAttribute.CreatePermission"]/*' />
        override public IPermission CreatePermission() {
            return new SqlClientPermission(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\dataloader.cs ===
#if OBJECT_BINDING
//------------------------------------------------------------------------------
// <copyright file="DataLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System.Text;
    using System.Threading;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.ComponentModel;
    using System.Data;
    using System.Runtime.InteropServices;
    using System.Globalization;

    // signature of function to read data off the wire (this never changes)
    /// <include file='doc\DataLoader.uex' path='docs/doc[@for="DataLoader"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public delegate void DataLoader (object dataObject, TdsParser recordStream);

    // note that since we use the method rental stuff, we can't use the stock ILGenerator since it doesn't
    // give us back a byte array with the header.  (actually, the BakeByteArray method defined in com+ isn't
    // accessible either and there weren't plans to do so).  If com+ does make ILGenerator.BakeByteArray() public
    // and this array contains the method header, then this code should be removed.
    sealed internal class ILByteGenerator {
        // internal class vars
        private int _ip = 0; // index into instruction array
        private ModuleBuilder _mod;
        private byte[] _rgil;
        private SignatureHelper _sigHelper;

        // sizes
        private const byte _size = 0xff;
        private const byte _header = 0xc; // IMAGE_COR_ILMETHOD_FAT header is always 12 bytes
        private const byte _stack = 0x8; // max stack size (increment if you generate code with > 8 items on the stack)
        private const byte _locals = 0x4; // max number of locals we allow

        // cor method header constants
        private const byte CorILMethod_Fat = 0x3;
        private const byte CorILMethod_InitLocals = 0x10;

        // lookup tables that map local tokens to the appropriate optimized IL instructions
        internal OpCode[] _localsLoad = new OpCode[] {
            OpCodes.Ldloc_0,
            OpCodes.Ldloc_1,
            OpCodes.Ldloc_2,
            OpCodes.Ldloc_3
        };
        internal OpCode[] _localsStore = new OpCode[] {
            OpCodes.Stloc_0,
            OpCodes.Stloc_1,
            OpCodes.Stloc_2,
            OpCodes.Stloc_3
        };      

        int _lp; // local pointer

        internal bool IsBigOp(Int16 op) {
            return( (op > 0xff) || (op < 0));
        }

        private void Grow() {
            Debug.Assert(_rgil != null, "ILByteGenerator.Init() was not called!");

            // realloc and grow
            byte[] temp = new byte[_rgil.Length + _size];
            Array.Copy(_rgil, temp, _rgil.Length);
            _rgil = temp;
        }

        public void Init(ModuleBuilder module) {
            _mod = module;
            _rgil = new byte[_size + _header];
            _ip = _header;
            _lp = 0; // no locals yet
        }

        // debug only
        public string GetLabelValue(int label) {
            return _rgil[label].ToString();
        }

        // warning: jumps must not exceed 0xff bytes (that is, only short branches and jumps are currently
        // warning: supported by this generator)
        public void MarkLabel(int label) {
            Debug.Assert(label < _rgil.Length && label < _ip, "invalid label!");
            Debug.Assert( ( (_ip-1) - label) <= 0xff, "invalid label: target must be less than 0xff instructions");
            _rgil[label] = (byte) ((_ip-1) - label);
        }

        // emit il branch instruction and reserve a 1 byte space for the branch offset
        public int EmitLabel(OpCode code) {
            short op = code.Value;
            int label;

            if (_ip+3 >= _rgil.Length)
                Grow();

            _rgil[_ip++] = (byte)op;

            if (IsBigOp(op))
                _rgil[_ip++] = (byte) (op>>0x8);

            label = _ip;
            _ip++; // we'll patch this offset at MarkLabel() time
            return label;       
        }

        public void Emit(OpCode code, Type t) {
            Emit(code, _mod.GetTypeToken(t).Token);
        }

        // emit il instruction with no argument
        // ex: ret
        public void Emit(OpCode code) {
            short op = code.Value;
            if (_ip+2 >= _rgil.Length)
                Grow();

            _rgil[_ip++] = (byte)op;

            // two byte instruction
            if (IsBigOp(op))
                _rgil[_ip++] = (byte) (op>>0x8);
        }

        // emit il instruction with 4 byte argument
        // ex: call
        public void Emit(OpCode code, int token) {
            short op = code.Value;
            if (_ip+6 >= _rgil.Length)
                Grow();

            _rgil[_ip++] = (byte)op;                            

            // two byte instruction
            if (IsBigOp(op))
                _rgil[_ip++] = (byte) (op>>0x8);

            _rgil[_ip++] = (byte) token;                            
            _rgil[_ip++] = (byte) (token>>0x8);                         
            _rgil[_ip++] = (byte) (token>>0x10);
            _rgil[_ip++] = (byte) (token>>0x18);
        }

        public void EmitLoadLocal(int token) {
            Debug.Assert(token < _locals, "invalid local token");
            Emit(_localsLoad[token]);           
        }

        public void EmitStoreLocal(int token) {
            Debug.Assert(token < _locals, "invalid local token");
            Emit(_localsStore[token]);          
        }

        // warning:  Max 4 locals must be used since the generator uses ldloc.n and stloc.n instead of ldloc.s and stloc.s (where 0 <= n < 3)
        public int AddLocalVariable(Type t) {
            Debug.Assert(_mod != null, "ILByteGenerator.Init() was not called!");
            Debug.Assert(_lp < _locals, "invalid attempt to add more than 4 locals to function");
            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("adding local variable of type:  " + t.ToString());
            //}

            int token = _lp;

            if (_sigHelper == null) {
                _sigHelper = SignatureHelper.GetLocalVarSigHelper(_mod);
            }

            // removed second argument, modifier not needed anymore and is obsolete
            _sigHelper.AddArgument(t);              
            _lp++;
            return token;
        }

        public byte[] BakeByteArray() {
            Debug.Assert(_mod != null && _rgil != null, "ILByteGenerator.Init() was not called!");

            // 1st byte is type of header (FAT == 0x3) and flags CorILMethod_InitLocals
            byte bHeader = CorILMethod_Fat;

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("generated method stats");
            //    Debug.WriteLine("max stack:  " + _stack.ToString());
            //    Debug.WriteLine("code size:  " + _ip.ToString());
            //}

            if (_sigHelper != null)
                bHeader |= CorILMethod_InitLocals;

            // CorILMethod_FAT
            _rgil[0] = bHeader;

            // flags and size of CorILMethod_FAT header structure in dwords (3)
            _rgil[1] = 0x30;            

            // stack size
            _rgil[2] = _stack;
            _rgil[3] = 0x0;

            // size of the method body is the value of the instruction pointer - the header
            // it is not the length of _rgil since the array is most likely over allocated
            _ip = _ip - _header;
            _rgil[4] = (byte)_ip;
            _rgil[5] = (byte)(_ip >> 0x8);
            _rgil[6] = (byte)(_ip >> 0x10);
            _rgil[7] = (byte)(_ip >> 0x18);

            // LocalVarSigTok
            if (_sigHelper != null) {
                int token = _mod.GetSignatureToken(_sigHelper).Token;
                _rgil[8] = (byte)token;
                _rgil[9] = (byte)(token >> 0x8);
                _rgil[10] = (byte)(token >> 0x10);
                _rgil[11] = (byte)(token >> 0x18);
            }
            else {
                _rgil[8] = 0x0;
                _rgil[9] = 0x0;
                _rgil[10] = 0x0;
                _rgil[11] = 0x0;
            }

            return _rgil;
        }
    } // ILByteGenerator

    // this helper class generates dynamic il for the data loader function
    // it also is a helper to generate the strongly typed objects and their corresponding field infos.
    // an instance of this class is only instantiated if a user is going through the recordstream interface
    // when loading a cache, this class is never used.
    sealed internal class DataLoaderHelper {
        public const byte ltNil = 0x0;
        public const byte ltBool = 0x1; // holds flags (null and positive)
        public const byte ltInt = 0x2;      // holds length (textPtrLen or length)
        public const byte ltIntArr = 0x4;   // holds decimal bits
        public const byte ltByteArr = 0x8;  // holds bytes for binary

        // field tokens for the SQLType null values
        int _tokSqlDoubleNull;
        int _tokSqlSingleNull;
        int _tokSqlGuidNull;
        int _tokSqlByteNull;
        int _tokSqlInt32Null;
        int _tokSqlInt16Null;
        int _tokSqlInt64Null;
        int _tokSqlDateTimeNull;
        int _tokSqlMoneyNull;
        int _tokSqlBitNull;
        int _tokSqlDecimalNull;
        int _tokSqlStringNull;

        // method tokens for the SQLType constructors
        int _tokSqlString;
        int _tokSqlDouble;
        int _tokSqlSingle;
        int _tokSqlByte;
        int _tokSqlInt16;
        int _tokSqlInt32;
        int _tokSqlInt64;
        int _tokSqlGuid;
        int _tokSqlDecimal;
        int _tokSqlBit;
        int _tokSqlDateTime;
        int _tokSQLSmallDateTime;
        int _tokSqlMoney;

        // method tokens for reading data off the wire
        int _tokReadByte;
        int _tokSkipBytes;
        int _tokReadInt;
        int _tokReadUnsignedInt;
        int _tokReadShort;
        int _tokReadUnsignedShort;
        int _tokReadByteArray;
        int _tokGetTokenLength;
        int _tokReadDouble;
        int _tokReadFloat;
        int _tokReadEncodingChar;
        int _tokReadString;
        int _tokReadSqlVariant;
        int _tokReadLong;


        // cached method (for now we only have one) and we rent it
        static int _tokM0;


        // only define the dataloader class once
        string _className = "DataLoaderClass";
        string _methodName = "M0";
        string _delegateName = "System.Data.SqlClient.DataLoader"; // fully qualified name

        static ModuleBuilder _mod = null;
        static MethodBuilder _meth = null;
        static Type _delegateType = null;
        static Type _classMethod = null;
        static object _instanceMethod = null;

        // field token for current column
        FieldInfo _fiCol; // public only for debugging
        int _tokCol;
        // label token for current next label
        int _toklblNext;
        // label token for 0th label
        int _toklbl0;
        // label token for 1st label
        int _toklbl1;
        // flag is true if we are on the last column and we should generate a return instead of a jump to the
        // next column
        bool _fRet;

        // local tokens
        int _tokInt;    // used to store length of variable length columns (including blobs)
        int _tokIntArr; // used for decimal columns
        int _tokBool;   // used to store whether column is null; also stores positive bit for numerics
        int _tokByteArr;   // used for binary columns

        private void AddLocalVariables(ILByteGenerator il, byte localsFlag) {
            if (ltBool == (localsFlag & ltBool))
                _tokBool = il.AddLocalVariable(typeof(bool));
            if (ltInt == (localsFlag & ltInt))
                _tokInt = il.AddLocalVariable(typeof(int));
            if (ltByteArr == (localsFlag & ltByteArr))
                _tokByteArr = il.AddLocalVariable(typeof(byte[]));
            if (ltIntArr == (localsFlag & ltIntArr))
                _tokIntArr = il.AddLocalVariable(typeof(int[]));
        }

        // setup the method signature, prototype, and class.
        // get the delegate type
        // create the class and save off an instance
        private void InitMethod() {
            // we shouldn't have any prior state
            Debug.Assert(_mod == null && _meth == null && _delegateType == null && _classMethod == null && _instanceMethod == null,
                         "Invalid second call to InitMethod()!");

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose)
            //    Debug.WriteLine("DataLoader.InitMethod() called");

            AppDomain _appdom = Thread.GetDomain();
            AssemblyName an = new AssemblyName();
            an.Name = "SqlDataAdapter.DataLoader"; // UNDONE : Other assembly attributes... not really needed : , "", "this is the description", "default_alias");
            AssemblyBuilder ab = _appdom.DefineDynamicAssembly(an, AssemblyBuilderAccess.Run);
            _mod = ab.DefineDynamicModule("ModuleM0");
            TypeBuilder tb = _mod.DefineType(_className);

            // UNDONE:  Are unrestricted permissions okay here?
            Type[] ti = new Type[2];
            ti[0] = typeof(object);
            ti[1] = typeof(TdsParser);
            _meth = tb.DefineMethod(_methodName,
                                    MethodAttributes.Public | MethodAttributes.Static,
                                    typeof(Void), // return type
                                    ti); // arg types

            // define a stub method body
            ILGenerator il = _meth.GetILGenerator();
            il.Emit(OpCodes.Ret);
            // TODO(sreeramn): Looks like tb.CreateType() will automatically call MethodBuilder.CreateMethodBody.
            //_meth.CreateMethodBody(il);
            _tokM0 = _meth.GetToken().Token;

            // create the class that houses the method
            // and instantiate
            _classMethod = tb.CreateType();
            _instanceMethod = Activator.CreateInstance(_classMethod);

            // cache our delegate type
            _delegateType = Type.GetType(_delegateName);
        }

        // UNDONE:  we look for an exact match.  Consider making this much more flexible
        // so that the user can pass in an object that doesn't match the schema exactly.
        internal void ValidateObject(object record, _SqlMetaData[] metaData) {
            Debug.Assert(record != null && metaData != null, "null record or metaData passed to VerifyUserObject");

            FieldInfo[] info = record.GetType().GetFields();
            int i, j;
            bool isValid = true;

            if (info.Length != metaData.Length)
                throw SQL.InvalidObjectSize(metaData.Length);

            for (i = 0; i < metaData.Length; i++) {
                //if (AdapterSwitches.SqlDebugIL.TraceVerbose)
                //    Debug.WriteLine("searching for table field:  " + metaData[i].column);

                for (j = 0; j < info.Length; j++) {
                    //if (AdapterSwitches.SqlDebugIL.TraceVerbose)
                    //    Debug.WriteLine("object field:  " + info[j].Name);

                    // match member name
                    if (0 == String.Compare(info[j].Name.ToLower(CultureInfo.InvariantCulture), metaData[i].column.ToLower(CultureInfo.InvariantCulture), false, CultureInfo.InvariantCulture)) {
                        // match type
                        Type source = info[j].FieldType;
                        Type target = metaData[i].metaType.SQLType;

                        if (!source.IsAssignableFrom(target)) {
                            throw SQL.InvalidObjectNotAssignable(info[j].Name, metaData[i].column); 
                        }

                        break;
                    }
                }

                // if j == info.Length then we didn't find our field
                if (j == info.Length)
                    throw SQL.InvalidObjectColumnNotFound(metaData[i].column);

                if (!isValid)
                    break;
            }
        }

        // validates the passed in object against the metadata
        // builds the strongly typed data loader function
        internal DataLoader BindToObject(object record, _SqlMetaData[] metaData) {
            Debug.Assert(metaData != null, "Invalid call to BindToObject without meta data!");
            Debug.Assert(record != null, "invalid call to BindToObject with null record object!");

            // create the method for our pool
            // and init the ModuleBuilder
            if (_instanceMethod == null)
                InitMethod();

            // assemble the field info, we actually need a temp one for now because we are going to reorder the fieldinfo to match
            // the order the columns come off the wire
            FieldInfo[] fiTemp = record.GetType().GetFields();
            FieldInfo[] fiOrdered = new FieldInfo[fiTemp.Length];
            Debug.Assert(fiTemp.Length == metaData.Length, "fieldinfo and metaData arrays should be the same size!");

            // do the field info fixup, since the user may have provided us with an object with fields in a differnt order
            // than they come off the wire
            for (int i = 0; i < metaData.Length; i++) {
                // search for the correct FieldInfo and put into the structure
                for (int j = 0; j < fiTemp.Length; j++)
                    if (0 == String.Compare(fiTemp[j].Name.ToLower(CultureInfo.InvariantCulture), metaData[i].column.ToLower(CultureInfo.InvariantCulture), false, CultureInfo.InvariantCulture)) {
                        fiOrdered[i] = fiTemp[j];
                        break;
                    }
            }

            // generate the data loader function now
            return(DataLoader) GenLoadFunction(fiOrdered, metaData);
        }

        // generates the LoadData method body.  Note that the method takes two arguments.  Arg_0 is the dataObject
        // and Arg_1 is an instance of the TdsParser.  The function works by calling methods of the record stream to
        // load the data off the wire and copy it into the dataObject.
        // The function looks like:
        // public static void LoadData(object dataObject, TdsParser tds)
        // {
        //       ReadColumn0;
        //   Label1:
        //       ReadColumn1;
        //   Label2:
        //       ReadColumn2;
        //   LabelN-1:
        //       ReadColumnN-1;
        //       ret;
        // }
        //
        // Each ReadColumn has the form: (note that ReadColumnN is not a separate function)
        // if (column is long)
        // {
        //      ReadTextPtr;
        //      if null, jump to LabelN+1, or return if we are on the last column
        // }
        //
        // read the length of data off wire and store in ltLength
        // check length for null and store in ltNull
        // if nullable and null goto LabelN+1 or return
        // read data
        // if last column return, otherwise fall through to next ReadColumn
        internal Delegate GenLoadFunction(FieldInfo[] fields, _SqlMetaData[] metaData) {
            _SqlMetaData md; // current column
            int i;
            byte ltFlags = 0; // start off with no local tokens
            _fRet = false;

            // pass 1: gather information about the locals we'll need for our function
            for (i = 0; i < metaData.Length; i++) {
                md = metaData[i];

                if (md.metaType.IsLong) {
                    // need a byte array and a length
                    ltFlags |= (ltInt | ltByteArr);
                }

                if (md.isNullable) {
                    // need a bool for nullability and length
                    ltFlags |= (ltBool | ltInt);
                }

                if (md.type == SqlDbType.Decimal) {
                    // need an int array for the decimal bits
                    // as well as a bool for the positive flag
                    ltFlags |= (ltBool | ltIntArr);
                }

                if (MetaType.IsCharType(md.type) || MetaType.IsBinType(md.type)) {
                    // need a length
                    ltFlags |= ltInt;
                }
            }

            ILByteGenerator il = new ILByteGenerator();
            il.Init(_mod);
            AddLocalVariables(il, ltFlags);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("--------------------function begin");
            //}

            // pass 2: generate function
            for (i = 0; i < metaData.Length; i++) {
                md = metaData[i];
                _fiCol = fields[i];
                _tokCol = _mod.GetFieldToken(_fiCol).Token;
                byte tdsType = md.isNullable ? md.metaType.NullableType : md.metaType.TDSType;

                // on fields 1 -> length -1 create a label.  The previous field will jump to this label
                // if it is null.  The last field will simply exit the routine
                if (_toklblNext != 0) {
                    il.MarkLabel(_toklblNext);

                    //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                    //    Debug.WriteLine("<fixup " + _toklblNext.ToString() + "=" + il.GetLabelValue(_toklblNext) +">");
                    //}

                    _toklblNext = 0;
                }

                // if we are on the last column return from the function, otherwise branch to the
                // next column
                if (i == metaData.Length -1)
                    _fRet = true;

                // if this is a long field then generate the code to read past the TextPtr and timestamp
                if (md.metaType.IsLong) {
                    GenReadTextPtr(il); // store
                }

                // now treat the column as usual
                tdsType = md.isNullable ? md.metaType.NullableType : md.metaType.TDSType;

                if (MetaType.IsCharType(md.type) || MetaType.IsBinType(md.type) || md.isNullable)
                    GenReadLength(il, tdsType); // store length in local ltLength

                if (md.isNullable)
                    GenReadNull(il); // store null in local ltNull


                switch (tdsType) {
                    case TdsEnums.SQLFLTN:
                    case TdsEnums.SQLFLT4:
                    case TdsEnums.SQLFLT8:
                        GenReadFloat(il, tdsType, md.length);
                        break;
                    case TdsEnums.SQLBINARY:
                    case TdsEnums.SQLBIGBINARY:
                    case TdsEnums.SQLBIGVARBINARY:
                    case TdsEnums.SQLVARBINARY:
                    case TdsEnums.SQLIMAGE:
                    case TdsEnums.SQLUNIQUEID:
                        GenReadBinary(il, (tdsType == TdsEnums.SQLUNIQUEID), md.isNullable);
                        break;
                    case TdsEnums.SQLBIT:
                    case TdsEnums.SQLBITN:
                        GenReadBit(il, tdsType);
                        break;
                    case TdsEnums.SQLINT1:
                    case TdsEnums.SQLINT2:
                    case TdsEnums.SQLINT4:
                    case TdsEnums.SQLINT8:
                    case TdsEnums.SQLINTN:
                        GenReadInt(il, tdsType, md.length);
                        break;
                    case TdsEnums.SQLCHAR:
                    case TdsEnums.SQLBIGCHAR:
                    case TdsEnums.SQLVARCHAR:
                    case TdsEnums.SQLBIGVARCHAR:
                    case TdsEnums.SQLTEXT:
                    case TdsEnums.SQLNCHAR:
                    case TdsEnums.SQLNVARCHAR:
                    case TdsEnums.SQLNTEXT:
                        GenReadString(il, MetaType.IsSizeInCharacters(md.type), md.isNullable);
                        break;
                    case TdsEnums.SQLDECIMALN:
                    case TdsEnums.SQLNUMERICN:
                        GenReadNumeric(il, md.precision, md.scale, md.isNullable);
                        break;
                    case TdsEnums.SQLDATETIMN:
                    case TdsEnums.SQLDATETIME:
                    case TdsEnums.SQLDATETIM4:
                        GenReadDateTime(il, tdsType, md.length);
                        break;
                    case TdsEnums.SQLMONEYN:
                    case TdsEnums.SQLMONEY:
                    case TdsEnums.SQLMONEY4:
                        GenReadMoney(il, tdsType, md.length);
                        break;
                    case TdsEnums.SQLVARIANT:
                        GenReadSqlVariant(il);
                        break;
                    default:
                        Debug.Assert(false, "Unknown tdsType!" + tdsType.ToString());
                        break;
                } // switch

                if (_fRet) {
                    il.Emit(OpCodes.Ret);
                    //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                    //    Debug.WriteLine("Ret");
                    //}
                }
            } // for

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("--------------------function end");
            //}

            byte[]   rgIL = il.BakeByteArray();
            GCHandle hmem = new GCHandle();
            try {
                hmem = GCHandle.Alloc((Object) rgIL, GCHandleType.Pinned);
                IntPtr addr = hmem.AddrOfPinnedObject();
                MethodRental.SwapMethodBody(_classMethod, _tokM0, addr, rgIL.Length, MethodRental.JitImmediate);
            }
            finally {
                if (hmem.IsAllocated) {
                    hmem.Free();
                }
            }       

            return Delegate.CreateDelegate(_delegateType, _classMethod, _methodName);
        }

        // code gen helpr functions
        private void GenBranchLabel(ILByteGenerator il) {
            if (_fRet)
                il.Emit(OpCodes.Ret);
            else
                _toklblNext = il.EmitLabel(OpCodes.Br_S);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    if (_fRet)
            //        Debug.WriteLine("Ret");
            //    else
            //        Debug.WriteLine("Br_S <see fixup for " + _toklblNext.ToString() + ">");
            //}
        }

        // Generates code to check the value of the ltNull and pushes the dataObject onto the stack
        private void GenNullCheck(ILByteGenerator il) {
            il.EmitLoadLocal(_tokBool);
            _toklbl0 = il.EmitLabel(OpCodes.Brfalse_S);
            il.Emit(OpCodes.Ldarg_0);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldloc.N " +  _tokBool.ToString());
            //    Debug.WriteLine("Brfalse_S <see fixup for " + _toklbl0.ToString() + ">");
            //    Debug.WriteLine("Ldarg_0");
            //}
        }

        // Generates code to read length of the data off the wire and store in ltLength
        // the dataObject field is set to null and a branch to the next column is generated
        //
        // length = TdsParser.GetTokenLength(tdsType)
        private void GenReadLength(ILByteGenerator il, byte tdsType) {
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Ldc_I4_S, tdsType);
            il.Emit(OpCodes.Call, this.GetTokenLength);
            il.EmitStoreLocal(_tokInt);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Ldc_I4_S <tdstype:  " + byte.Format(tdsType, "x2") + ">");
            //    Debug.WriteLine("Call GetTokenLength(byte)");
            //    Debug.WriteLine("Stloc.N " + _tokInt.ToString());
            //}
        }


        // Generates code to store whether the column is null in the ltNull local
        //
        // fNull = false;
        // if (length == TdsEnums.VARNULL || length == TdsEnums.FIXEDNULL)
        //    fNull = true;
        private void GenReadNull(ILByteGenerator il) {
            il.Emit(OpCodes.Ldc_I4_0);
            il.EmitStoreLocal(_tokBool);
            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Ldc_I4_0);
            _toklbl0 = il.EmitLabel(OpCodes.Beq_S);
            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Ldc_I4, TdsEnums.VARNULL);
            _toklbl1 = il.EmitLabel(OpCodes.Bne_Un_S);
            il.MarkLabel(_toklbl0);
            il.Emit(OpCodes.Ldc_I4_1);
            il.EmitStoreLocal(_tokBool);
            il.MarkLabel(_toklbl1);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldc_I4_0");
            //    Debug.WriteLine("Stloc.N " + _tokBool.ToString());
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Ldc_I4_0");
            //    Debug.WriteLine("Beq_S " + il.GetLabelValue(_toklbl0));
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Ldc_I4 " + (TdsEnums.VARNULL).ToString());
            //    Debug.WriteLine("Bne_Un_S " + il.GetLabelValue(_toklbl1));
            //    Debug.WriteLine("Ldc_I4_1");
            //    Debug.WriteLine("Stloc.N " + _tokBool.ToString());
            //}

        }

        // Generates code to read the text pointer and store in ltTextPtr.  If TextPtr has length 0 then
        // the dataObject field is set to null and a branch to the next column is generated
        //
        // byte textPtrLen = ReadByte();
        // if (textPtrLen == 0)
        // {
        //    dataObject.field_0 = null;
        // }
        // else
        //     TdsParser.SkipBytes(textPtrLen + TdsEnums.TEXT_TIME_STAMP_LEN)
        private void GenReadTextPtr(ILByteGenerator il) {
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadByte);
            il.EmitStoreLocal(_tokInt);
            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Ldc_I4_0);
            _toklbl0 = il.EmitLabel(OpCodes.Bne_Un_S);
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldnull);
            il.Emit(OpCodes.Stfld, _tokCol);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadByte()");
            //    Debug.WriteLine("Stloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Ldc_I4_0");
            //    Debug.WriteLine("Bne_Un_S" + il.GetLabelValue(_toklbl0));
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldnull");
            //    Debug.WriteLine("Stfld " + _fiCol.Name);
            //}

            GenBranchLabel(il);

            il.MarkLabel(_toklbl0);
            il.Emit(OpCodes.Ldarg_1);
            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Ldc_I4_S, TdsEnums.TEXT_TIME_STAMP_LEN);
            il.Emit(OpCodes.Add);
            il.Emit(OpCodes.Call, this.SkipBytes);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Ldc_I4_S " + (TdsEnums.TEXT_TIME_STAMP_LEN).ToString());
            //    Debug.WriteLine("Add");
            //    Debug.WriteLine("Call SkipBytes()");
            //}
        }

        // Generates code to read a 4 or 8 byte float off the wire into the
        // field of the data object.  If the value is nullable, it stores the SqlDouble.Null static
        // member into the field data
        //
        // Note that non-nullable floats need not even check the null flag
        //
        // nullable float:
        //  if (fNull)
        //      data = SqlSingle.Null || SqlDouble.Null;
        // 4-byte float:
        //  data = new SqlSingle(ReadFloat())
        // 8-byte float:
        //  data = new SqlDouble(ReadDouble())
        private void GenReadFloat(ILByteGenerator il, byte tdsType, int length) {
            if (tdsType == TdsEnums.SQLFLTN) {
                GenNullCheck(il);
                if (length == 4)
                    il.Emit(OpCodes.Ldsfld, this.SqlSingle_Null);
                else {
                    Debug.Assert(8 == length, "invalid size for float");
                    il.Emit(OpCodes.Ldsfld, this.SqlDouble_Null);
                }

                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    if (length == 1)
                //        Debug.WriteLine("Ldsfld SqlSingle.Null");
                //    else
                //        Debug.WriteLine("Ldsfld SqlDouble.Null");

                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }

            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldarg_1);

            if (length == 4) {
                il.Emit(OpCodes.Call, this.ReadFloat);
                il.Emit(OpCodes.Call, this.SqlSingle_Ctor);
            }
            else {
                il.Emit(OpCodes.Call, this.ReadDouble);
                il.Emit(OpCodes.Call, this.SqlDouble_Ctor);
            }

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldarg_1");
            //    if (length == 4) {
            //        Debug.WriteLine("Call ReadFloat()");
            //        Debug.WriteLine("Call SqlSingle()");
            //    }
            //    else {
            //        Debug.WriteLine("Call ReadDouble()");
            //        Debug.WriteLine("Call SqlDouble()");
            //    }                   
            //}
        }

        // stores an object into the field data for now.
        // data = ReadSqlVariant(length);
        private void GenReadSqlVariant(ILByteGenerator il) {
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldarg_1);
            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Call, this.ReadSqlVariant);
            il.Emit(OpCodes.Stfld, _tokCol);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Call ReadSqlVariant()");
            //    Debug.WriteLine("Stfld " + _fiCol.Name);
            //}
        }

        // Generates code to read a 1, 2, 4 or 8 byte int off the wire into the
        // field of the data object.  If the value is nullable, it stores the appropriate SqlIntN.Null static
        // member into the field data
        //
        // Note that non-nullable ints need not even check the null flag
        //
        // nullable int:
        //  if (fNull)
        //      data = SqlByte.Null || SqlInt16.Null || SqlInt32.Null || SqlInt64.Null;
        // 1-byte int:
        //  data = new SqlByte(ReadByte());
        // 2-byte int:
        //  data = new SqlInt16(ReadShort());
        // 4-byte int:
        //  data = new SqlInt32(ReadInt());
        // 8-byte int:
        //  data = new SqlInt64(ReadLong())
        private void GenReadInt(ILByteGenerator il, byte tdsType, int length) {
            if (tdsType == TdsEnums.SQLINTN) {
                GenNullCheck(il);
                if (length == 1)
                    il.Emit(OpCodes.Ldsfld, this.SqlByte_Null);
                else
                    if (length == 2)
                    il.Emit(OpCodes.Ldsfld, this.SqlInt16_Null);
                else
                    if (length == 4)
                    il.Emit(OpCodes.Ldsfld, this.SqlInt32_Null);
                else
                    il.Emit(OpCodes.Ldsfld, this.SqlInt64_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    if (length == 1)
                //        Debug.WriteLine("Ldsfld SqlByte.Null");
                //    else
                //        if (length == 2)
                //        Debug.WriteLine("Ldsfld SqlInt16.Null");
                //    else
                //        if (length == 4)
                //        Debug.WriteLine("Ldsfld SqlInt32.Null");
                //    else
                //        Debug.WriteLine("Ldsfld SqlInt64.Null");

                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }

            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldarg_1);

            if (length == 1) {
                il.Emit(OpCodes.Call, this.ReadByte);
                il.Emit(OpCodes.Call, this.SqlByte_Ctor);
            }
            else
                if (length == 2) {
                il.Emit(OpCodes.Call, this.ReadShort);
                il.Emit(OpCodes.Call, this.SqlInt16_Ctor);
            }
            if (length == 4) {
                il.Emit(OpCodes.Call, this.ReadInt);
                il.Emit(OpCodes.Call, this.SqlInt32_Ctor);
            }
            else {
                il.Emit(OpCodes.Call, this.ReadLong);
                il.Emit(OpCodes.Call, this.SqlInt64_Ctor);
            }

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldarg_1");
            //    if (length == 1) {
            //        Debug.WriteLine("Call ReadByte()");
            //        Debug.WriteLine("Call SqlByte()");
            //    }
            //    else
            //        if (length == 2) {
            //        Debug.WriteLine("Call ReadShort()");
            //        Debug.WriteLine("Call SqlInt16()");
            //    }
            //    else
            //        if (length == 4) {
            //        Debug.WriteLine("Call ReadInt()");
            //        Debug.WriteLine("Call SqlInt32()");
            //    }
            //    else {
            //        Debug.WriteLine("Call ReadLong()");
            //        Debug.WriteLine("Call SqlInt64()");
            //    }
            //}
        }

        // Generates code to read binary data off the wire, build an array, and set array object
        // into data field.  If the type is a guid, then the SqlGuid object is used.  If the type is null,
        // the the data field is set to null.
        //
        // if (fNull)
        //    data = null; || data = SqlGuid.Null;
        // else
        // {
        //    byte[] b = new byte[length];
        //    ReadByteArray(b, 0, length);
        //    data = b; || data = new SqlGuid(b);
        // }
        private void GenReadBinary(ILByteGenerator il, bool isGuid, bool isNullable) {
            if (isNullable) {
                GenNullCheck(il);
                if (isGuid) {
                    il.Emit(OpCodes.Ldsfld, this.SqlGuid_Null);
                }
                else {
                    il.Emit(OpCodes.Ldnull);
                }

                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    if (isGuid)
                //        Debug.WriteLine("Ldsfld SqlGuid.Null");
                //    else
                //        Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }

            il.EmitLoadLocal(_tokInt);
            il.Emit(OpCodes.Newarr, typeof(byte));
            il.EmitStoreLocal(_tokByteArr);
            il.Emit(OpCodes.Ldarg_1);
            il.EmitLoadLocal(_tokByteArr);
            il.Emit(OpCodes.Ldc_I4_0);
            il.EmitLoadLocal(_tokByteArr);
            il.Emit(OpCodes.Ldlen);
            il.Emit(OpCodes.Call, this.ReadByteArray);
            il.Emit(OpCodes.Ldarg_0);
            il.EmitLoadLocal(_tokByteArr);
            if (isGuid) {
                il.Emit(OpCodes.Newobj, this.SqlGuid_Ctor);
            }
            il.Emit(OpCodes.Stfld, _tokCol);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    Debug.WriteLine("Newarr typeof(byte)");
            //    Debug.WriteLine("Stloc.N " + _tokByteArr.ToString());
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Ldloc.N " + _tokByteArr.ToString());
            //    Debug.WriteLine("Ldc_I4_0");
            //    Debug.WriteLine("Ldloc.N " + _tokByteArr.ToString());
            //    Debug.WriteLine("Ldlen");
            //    Debug.WriteLine("Call ReadByteArray(byte[], int, int)");
            //    Debug.WriteLine("Ldarg_0");
            //    if (isGuid)
            //        Debug.WriteLine("Newobj SqlGuid()");
            //    Debug.WriteLine("Stfld " + _fiCol.Name);                    
            //}
        }

        // Generates code to read string data off the wire into the object.  Since the read string function
        // takes a count of characters we have to divide the length (which is number of bytes) by 2 in
        // the case of wide strings (ntext, ncar, nvarchar).  If the string is null, a null value is stored in the
        // data field
        // into data field.  If the type is a guid, then the SqlGuid object is used.  If the type is null,
        // the the data field is set to null.
        //
        // if (fNull)
        //    data = SqlString.Null;
        // else
        // {
        //    data = ReadString(length); || ReadEncodingChar(length>>2);
        // }
        private void GenReadString(ILByteGenerator il, bool isWide, bool isNullable) {
            if (isNullable) {
                GenNullCheck(il);
                il.Emit(OpCodes.Ldsfld, this.SqlString_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("Ldsfld SqlString.Null");
                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }

            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldarg_1);
            il.EmitLoadLocal(_tokInt);

            if (isWide) {
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Shr);
                il.Emit(OpCodes.Call, this.ReadString);
            }
            else {
                il.Emit(OpCodes.Call, this.ReadEncodingChar);
            }

            il.Emit(OpCodes.Newobj, this.SqlString_Ctor);
            il.Emit(OpCodes.Stfld, _tokCol);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Ldloc.N " + _tokInt.ToString());
            //    if (isWide) {
            //        Debug.WriteLine("Ldc_I4_1");
            //        Debug.WriteLine("Shr");
            //        Debug.WriteLine("Call ReadString(int)");
            //    }
            //    else
            //        Debug.WriteLine("Call ReadEncodingChar(int)");
            //    Debug.WriteLine("Newobj SqlString()");                  
            //}
        }

        // Generates code to read a 4 or 8 byte datetime off the wire and store in a SqlDateTime object.
        // If the type is nullable and null then a SqlDateTime.Null value is stored in the field data
        //
        // nullable datetime:
        //  if (fNull)
        //      data = SqlDateTime.Null;
        // 4-byte datetime:
        //  data = new SqlDateTime(ReadUnsignedShort(), ReadUnsignedShort())
        // 8-byte datetime:
        //  data = new SqlDateTime(ReadLong())
        private void GenReadDateTime(ILByteGenerator il, byte tdsType, int length) {
            if (tdsType == TdsEnums.SQLDATETIMN) {
                GenNullCheck(il);
                il.Emit(OpCodes.Ldsfld, this.SqlDateTime_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("Ldsfld SqlDateTime.Null");
                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}

            }
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldarg_1);
            if (length == 4) {
                il.Emit(OpCodes.Call, this.ReadUnsignedShort);
                il.Emit(OpCodes.Conv_U2);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Call, this.ReadUnsignedShort);
                il.Emit(OpCodes.Conv_U2);
                il.Emit(OpCodes.Call, this.SqlDateTime_CtorSmall);
            }
            else {
                il.Emit(OpCodes.Call, this.ReadInt);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Call, this.ReadUnsignedInt);
                il.Emit(OpCodes.Call, this.SqlDateTime_Ctor);
            }

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldarg_1");
            //    if (length == 4) {
            //        Debug.WriteLine("Call ReadUnsignedShort()");
            //        Debug.WriteLine("Conv_U2");
            //        Debug.WriteLine("Ldarg_1");
            //        Debug.WriteLine("Call ReadUnsignedShort()");
            //        Debug.WriteLine("Conv_U2");
            //        Debug.WriteLine("Call SqlDateTime(uint16, uint16)");
            //    }
            //    else {
            //        Debug.WriteLine("Call ReadInt");
            //        Debug.WriteLine("Ldarg_1");
            //        Debug.WriteLine("Call ReadUnsignedInt");
            //        Debug.WriteLine("Call SqlDateTime(int, int)");
            //    }                   
            //}
        }

        // Generates code to read a 4 or 8 byte currency off the wire and store in a SqlMoney object.
        // If the type is nullable and null then a SqlMoney.Null value is stored in the field data
        //
        // nullable money:
        //  if (fNull)
        //      data = SqlMoney.Null;
        // 4-byte money:
        //  data = new SqlMoney(ReadInt())
        // 8-byte money:
        //  data = new SqlMoney(ReadLong())
        private void GenReadMoney(ILByteGenerator il, byte tdsType, int length) {
            if (tdsType == TdsEnums.SQLMONEYN) {
                GenNullCheck(il);
                il.Emit(OpCodes.Ldsfld, this.SqlMoney_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("Ldsfld SqlMoney.Null");
                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}

            }
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldarg_1);
            if (length == 4) {
                il.Emit(OpCodes.Call, this.ReadInt);
                il.Emit(OpCodes.Conv_I8);
                il.Emit(OpCodes.Call, this.SqlMoney_Ctor);
            }
            else {
                il.Emit(OpCodes.Call, this.ReadInt);
                il.Emit(OpCodes.Ldc_I4_S, 0x20);
                il.Emit(OpCodes.Shl);
                il.Emit(OpCodes.Conv_I8);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Call, this.ReadUnsignedInt);
                il.Emit(OpCodes.Conv_U8);
                il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Call, this.SqlMoney_Ctor);
            }

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldarg_1");
            //    if (length == 4) {
            //        Debug.WriteLine("Call ReadInt()");
            //        Debug.WriteLine("Conv_I8");
            //        Debug.WriteLine("Call SqlMoney(int)");
            //    }
            //    else {
            //        Debug.WriteLine("Call ReadInt()");
            //        Debug.WriteLine("Ldc_I4_S 0x20");
            //        Debug.WriteLine("Shl");
            //        Debug.WriteLine("Conv_I8");
            //        Debug.WriteLine("Ldarg_1");
            //        Debug.WriteLine("Call ReadUnsignedInt");
            //        Debug.WriteLine("Conv_U8");
            //        Debug.WriteLine("Add");
            //        Debug.WriteLine("Call SqlMoney(long)");
            //    }                   
            //}
        }

        // Generates code to read numeric data off the wire into the object.  If the numeric is null,
        // a SqlDecimal.Null value is placed in the field data.  This function uses the ltPositive and ltIntArr local
        // variables as well as two passed in values (precision and scale) to create the decimal data
        //
        // if (fNull)
        //    data = SqlDecimal.Null;
        // else
        // {
        //     bool fPositive = (1 == ReadByte());
        //     int[] bits = new int[4];
        //     bits[0] = ReadInt();
        //     bits[1] = ReadInt();
        //     bits[2] = ReadInt();
        //     bits[3] = ReadInt();
        //     data = new SqlDecimal(precision, scale, fPositive, bits);
        // }
        private void GenReadNumeric(ILByteGenerator il, byte precision, byte scale, bool isNullable) {
            if (isNullable) {
                GenNullCheck(il);
                il.Emit(OpCodes.Ldsfld, this.SqlDecimal_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("Ldsfld SqlDecimal.Null");
                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }
            il.Emit(OpCodes.Ldc_I4_1);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadByte);
            il.Emit(OpCodes.Ceq);
            il.EmitStoreLocal(_tokBool);
            il.Emit(OpCodes.Ldc_I4_4);
            il.Emit(OpCodes.Newarr, typeof(int));
            il.EmitStoreLocal(_tokIntArr);
            il.EmitLoadLocal(_tokIntArr);
            il.Emit(OpCodes.Ldc_I4_0);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadInt);
            il.Emit(OpCodes.Stelem_I4);
            il.EmitLoadLocal(_tokIntArr);
            il.Emit(OpCodes.Ldc_I4_1);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadInt);
            il.Emit(OpCodes.Stelem_I4);
            il.EmitLoadLocal(_tokIntArr);
            il.Emit(OpCodes.Ldc_I4_2);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadInt);
            il.Emit(OpCodes.Stelem_I4);
            il.EmitLoadLocal(_tokIntArr);
            il.Emit(OpCodes.Ldc_I4_3);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadInt);
            il.Emit(OpCodes.Stelem_I4);
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldc_I4_S, precision);
            il.Emit(OpCodes.Ldc_I4_S, scale);
            il.EmitLoadLocal(_tokBool);
            il.EmitLoadLocal(_tokIntArr);
            il.Emit(OpCodes.Call, this.SqlDecimal_Ctor);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldc_I4_1");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadByte()");
            //    Debug.WriteLine("Ceq");
            //    Debug.WriteLine("Stloc.N " + _tokBool.ToString());
            //    Debug.WriteLine("Ldc_I4_4");
            //    Debug.WriteLine("Newarr typeof(int)");
            //    Debug.WriteLine("Stloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Ldloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Ldc_I4_0");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadInt()");
            //    Debug.WriteLine("Stelem_I4");
            //    Debug.WriteLine("Ldloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Ldc_I4_1");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadInt()");
            //    Debug.WriteLine("Stelem_I4");
            //    Debug.WriteLine("Ldloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Ldc_I4_2");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadInt()");
            //    Debug.WriteLine("Stelem_I4");
            //    Debug.WriteLine("Ldloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Ldc_I4_3");
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadInt()");
            //    Debug.WriteLine("Stelem_I4");
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldc_I4_S " + precision.ToString());
            //    Debug.WriteLine("Ldc_I4_S " + scale.ToString());
            //    Debug.WriteLine("Ldloc.N " + _tokBool.ToString());
            //    Debug.WriteLine("Ldloc.N " + _tokIntArr.ToString());
            //    Debug.WriteLine("Call SqlDecimal(byte, byte, bool, int[]");
            //}
        }


        // Generates code to read bit data off the wire.  If the bit type is nullable, set to SqlBit.Null,
        // otherwise set to a SqlBit object
        //
        // if (fNull)
        //    data = SqlBit.Null;
        // else
        // {
        //    data = new SqlBit(ReadByte());
        // }
        private void GenReadBit(ILByteGenerator il, byte tdsType) {
            if (tdsType == TdsEnums.SQLBITN) {
                GenNullCheck(il);
                il.Emit(OpCodes.Ldsfld, this.SqlBit_Null);
                il.Emit(OpCodes.Stfld, _tokCol);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("Ldsfld SqlBit.Null");
                //    Debug.WriteLine("Stfld " + _fiCol.Name);
                //}

                GenBranchLabel(il);
                il.MarkLabel(_toklbl0);

                //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
                //    Debug.WriteLine("<fixup " + _toklbl0.ToString() + "=" + il.GetLabelValue(_toklbl0) +">");
                //}
            }
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldflda, _tokCol);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Call, this.ReadByte);
            il.Emit(OpCodes.Call, this.SqlBit_Ctor);

            //if (AdapterSwitches.SqlDebugIL.TraceVerbose) {
            //    Debug.WriteLine("Ldarg_0");
            //    Debug.WriteLine("Ldflda " + _fiCol.Name);
            //    Debug.WriteLine("Ldarg_1");
            //    Debug.WriteLine("Call ReadByte()");
            //    Debug.WriteLine("Call SqlBit(byte)");
            //}
        }


        // Accessors for the above infos.  The info is retrieved once and then cached
        private int SqlString_Null {
            get {
                if (_tokSqlStringNull == 0) {
                    _tokSqlStringNull = _mod.GetFieldToken(typeof(SqlString).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlStringNull, "Failed to get static SqlString::Null field");
                }

                return _tokSqlStringNull;
            }
        }

        private int SqlSingle_Null {
            get {
                if (_tokSqlSingleNull == 0) {
                    _tokSqlSingleNull = _mod.GetFieldToken(typeof(SqlSingle).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlSingleNull, "Failed to get static SqlSingle::Null field");
                }

                return _tokSqlSingleNull;
            }
        }

        private int SqlDouble_Null {
            get {
                if (_tokSqlDoubleNull == 0) {
                    _tokSqlDoubleNull = _mod.GetFieldToken(typeof(SqlDouble).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlDoubleNull, "Failed to get static SqlDouble::Null field");
                }

                return _tokSqlDoubleNull;
            }
        }

        private int SqlGuid_Null {
            get {
                if (_tokSqlGuidNull == 0) {
                    _tokSqlGuidNull = _mod.GetFieldToken(typeof(SqlGuid).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlGuidNull, "Failed to get static SqlGuid::Null field");
                }

                return _tokSqlGuidNull;
            }
        }

        private int SqlByte_Null {
            get {
                if (_tokSqlByteNull == 0) {
                    _tokSqlByteNull = _mod.GetFieldToken(typeof(SqlByte).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlByteNull, "Failed to get static SqlByte::Null field");
                }

                return _tokSqlByteNull;
            }
        }

        private int SqlMoney_Null {
            get {
                if (_tokSqlMoneyNull == 0) {
                    _tokSqlMoneyNull = _mod.GetFieldToken(typeof(SqlMoney).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlMoneyNull, "Failed to get static SqlMoney::Null field");
                }

                return _tokSqlMoneyNull;
            }
        }

        private int SqlDateTime_Null {
            get {
                if (_tokSqlDateTimeNull == 0) {
                    _tokSqlDateTimeNull = _mod.GetFieldToken(typeof(SqlDateTime).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlDateTimeNull, "Failed to get static SqlDateTime::Null field");
                }

                return _tokSqlDateTimeNull;
            }
        }

        private int SqlInt16_Null {
            get {
                if (_tokSqlInt16Null == 0) {
                    _tokSqlInt16Null = _mod.GetFieldToken(typeof(SqlInt16).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlInt16Null, "Failed to get static SqlInt16::Null field");
                }

                return _tokSqlInt16Null;
            }
        }

        private int SqlInt32_Null {
            get {
                if (_tokSqlInt32Null == 0) {
                    _tokSqlInt32Null = _mod.GetFieldToken(typeof(SqlInt32).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlInt32Null, "Failed to get static SqlInt32::Null field");
                }
                return _tokSqlInt32Null;
            }
        }

        private int SqlInt64_Null {
            get {
                if (_tokSqlInt64Null == 0) {
                    _tokSqlInt64Null = _mod.GetFieldToken(typeof(SqlInt64).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlInt64Null, "Failed to get static SqlInt64::Null field");
                }

                return _tokSqlInt64Null;
            }
        }

        private int SqlDecimal_Null {
            get {
                if (_tokSqlDecimalNull == 0) {
                    _tokSqlDecimalNull = _mod.GetFieldToken(typeof(SqlDecimal).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlDecimalNull, "Failed to get static SqlDecimal::Null field");
                }

                return _tokSqlDecimalNull;
            }
        }

        private int SqlBit_Null {
            get {
                if (_tokSqlBitNull == 0) {
                    _tokSqlBitNull = _mod.GetFieldToken(typeof(SqlBit).GetField("Null")).Token;
                    Debug.Assert(0 != _tokSqlBitNull, "Failed to get static SqlBit::Null field");
                }

                return _tokSqlBitNull;
            }
        }

        private int SqlString_Ctor {
            get {
                if (_tokSqlString == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(string);
                    _tokSqlString = _mod.GetConstructorToken(typeof(SqlString).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlString, "Failed to get SqlString constructor");
                }

                return _tokSqlString;
            }
        }

        private int SqlSingle_Ctor {
            get {
                if (_tokSqlSingle == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(float);
                    _tokSqlSingle = _mod.GetConstructorToken(typeof(SqlSingle).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlSingle, "Failed to get SqlSingle constructor");
                }

                return _tokSqlSingle;
            }
        }

        private int SqlDouble_Ctor {
            get {
                if (_tokSqlDouble == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(double);
                    _tokSqlDouble = _mod.GetConstructorToken(typeof(SqlDouble).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlDouble, "Failed to get SqlDouble constructor");
                }

                return _tokSqlDouble;
            }
        }

        // SqlDateTime(int, int)
        private int SqlDateTime_Ctor {
            get {
                if (_tokSqlDateTime == 0) {
                    Type[] args = new Type[2];
                    args[0] = typeof(int);
                    args[1] = typeof(int);
                    _tokSqlDateTime = _mod.GetConstructorToken(typeof(SqlDateTime).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlDateTime, "Failed to get SqlDateTime0 constructor");
                }

                return _tokSqlDateTime;
            }
        }

        // SqlDateTime(uint, uint)
        private int SqlDateTime_CtorSmall {
            get {
                if (_tokSQLSmallDateTime == 0) {
                    Type[] args = new Type[2];
                    args[0] = typeof(UInt16);
                    args[1] = typeof(UInt16);
                    _tokSQLSmallDateTime = _mod.GetConstructorToken(typeof(SqlDateTime).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSQLSmallDateTime, "Failed to get SQLSmallDateTime constructor");
                }
                return _tokSQLSmallDateTime;
            }
        }


/*
        // SqlMoney(int)
        private int SqlMoney_Ctor0
        {
            get {
                if (_tokSqlMoney0 == 0)
                {
                    Type[] args = new Type[1];
                    args[0] = typeof(int);
                    _tokSqlMoney0 = _mod.GetConstructorToken(typeof(SqlMoney).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlMoney0, "Failed to get SqlMoney0 constructor");
                }

                return _tokSqlMoney0;
            }
        }
*/
        // in the case of SmallMoney, just use this ctor and cast int value off wire to long
        // SqlMoney(long)
        private int SqlMoney_Ctor {
            get {
                if (_tokSqlMoney == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(long);
                    _tokSqlMoney = _mod.GetConstructorToken(typeof(SqlMoney).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlMoney, "Failed to get SqlMoney constructor");
                }
                return _tokSqlMoney;
            }
        }

        private int SqlDecimal_Ctor {
            get {
                if (_tokSqlDecimal == 0) {
                    Type[] args = new Type[4];
                    args[0] = typeof(byte);
                    args[1] = typeof(byte);
                    args[2] = typeof(bool);
                    args[3] = typeof(int[]);
                    _tokSqlDecimal = _mod.GetConstructorToken(typeof(SqlDecimal).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlDecimal, "Failed to get SqlDecimal constructor");
                }

                return _tokSqlDecimal;
            }
        }

        private int SqlInt16_Ctor {
            get {
                if (_tokSqlInt16 == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(short);
                    _tokSqlInt16 = _mod.GetConstructorToken(typeof(SqlInt16).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlInt16, "Failed to get SqlInt16 constructor");
                }

                return _tokSqlInt16;
            }
        }

        private int SqlInt32_Ctor {
            get {
                if (_tokSqlInt32 == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(int);
                    _tokSqlInt32 = _mod.GetConstructorToken(typeof(SqlInt32).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlInt32, "Failed to get SqlInt32 constructor");
                }

                return _tokSqlInt32;
            }
        }

        private int SqlInt64_Ctor {
            get {
                if (_tokSqlInt64 == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(long);
                    _tokSqlInt64 = _mod.GetConstructorToken(typeof(SqlInt64).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlInt64, "Failed to get SqlInt64 constructor");
                }

                return _tokSqlInt64;
            }
        }


        private int SqlByte_Ctor {
            get {
                if (_tokSqlByte == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(byte);
                    _tokSqlByte = _mod.GetConstructorToken(typeof(SqlByte).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlByte, "Failed to get SqlByte constructor");
                }

                return _tokSqlByte;
            }
        }

        private int SqlGuid_Ctor {
            get {
                if (_tokSqlGuid == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(byte[]);
                    _tokSqlGuid = _mod.GetConstructorToken(typeof(SqlGuid).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlGuid, "Failed to get SqlGuid constructor");
                }

                return _tokSqlGuid;
            }
        }

        private int SqlBit_Ctor {
            get {
                if (_tokSqlBit == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(int);
                    _tokSqlBit = _mod.GetConstructorToken(typeof(SqlBit).GetConstructor(args)).Token;
                    Debug.Assert(0 != _tokSqlBit, "Failed to get SqlBit constructor");
                }

                return _tokSqlBit;
            }
        }
        // cache and return methodInfo for the functions that read data off the wire
        // ReadByte0 has zero args
        private int ReadByte {
            get {
                if (_tokReadByte == 0) {
                    MethodInfo miReadByte = typeof(TdsParser).GetMethod("ReadByte");
                    _tokReadByte = _mod.GetMethodToken(miReadByte).Token;
                    Debug.Assert(0 != _tokReadByte, "Failed to get ReadByte method!");
                }

                return _tokReadByte;
            }
        }

        private int ReadShort {
            get {
                if (_tokReadShort == 0) {
                    MethodInfo miReadShort = typeof(TdsParser).GetMethod("ReadShort");
                    _tokReadShort = _mod.GetMethodToken(miReadShort).Token;
                    Debug.Assert(0 != _tokReadShort, "Failed to get ReadShort method!");
                }

                return _tokReadShort;
            }
        }

        private int ReadSqlVariant {
            get {
                if (_tokReadSqlVariant == 0) {
                    MethodInfo miReadSqlVariant = typeof(TdsParser).GetMethod("ReadSqlVariant");
                    _tokReadSqlVariant = _mod.GetMethodToken(miReadSqlVariant).Token;
                    Debug.Assert(0 != _tokReadSqlVariant, "Failed to get ReadSqlVariant method!");
                }

                return _tokReadSqlVariant;
            }
        }

        private int ReadInt {
            get {
                if (_tokReadInt == 0) {
                    MethodInfo miReadInt = typeof(TdsParser).GetMethod("ReadInt");
                    _tokReadInt = _mod.GetMethodToken(miReadInt).Token;

                    Debug.Assert(0 != _tokReadInt, "Failed to get ReadInt method!");
                }

                return _tokReadInt;
            }
        }

        private int ReadUnsignedInt {
            get {
                if (_tokReadUnsignedInt == 0) {
                    MethodInfo miReadUnsignedInt = typeof(TdsParser).GetMethod("ReadUnsignedInt");
                    _tokReadUnsignedInt = _mod.GetMethodToken(miReadUnsignedInt).Token;

                    Debug.Assert(0 != _tokReadUnsignedInt, "Failed to get ReadInt method!");
                }

                return _tokReadUnsignedInt;
            }
        }


        private int ReadLong {
            get {
                if (_tokReadLong == 0) {
                    MethodInfo miReadLong = typeof(TdsParser).GetMethod("ReadLong");
                    _tokReadLong = _mod.GetMethodToken(miReadLong).Token;
                    Debug.Assert(0 != _tokReadLong, "Failed to get ReadLong method!");
                }

                return _tokReadLong;
            }
        }

        private int ReadFloat {
            get {
                if (_tokReadFloat == 0) {
                    MethodInfo miReadFloat = typeof(TdsParser).GetMethod("ReadFloat");
                    _tokReadFloat = _mod.GetMethodToken(miReadFloat).Token;
                    Debug.Assert(0 != _tokReadFloat, "Failed to get ReadFloat method!");
                }

                return _tokReadFloat;
            }
        }

        private int ReadByteArray {
            get {
                if (_tokReadByteArray == 0) {
                    MethodInfo miReadByteArray = typeof(TdsParser).GetMethod("ReadByteArray");
                    _tokReadByteArray = _mod.GetMethodToken(miReadByteArray).Token;
                    Debug.Assert(0 != _tokReadByteArray, "Failed to get ReadByteArray method!");
                }

                return _tokReadByteArray;
            }
        }

        private int ReadDouble {
            get {
                if (_tokReadDouble == 0l) {
                    MethodInfo miReadDouble = typeof(TdsParser).GetMethod("ReadDouble");
                    _tokReadDouble = _mod.GetMethodToken(miReadDouble).Token;
                    Debug.Assert(0 != _tokReadDouble, "Failed to get ReadDouble method!");
                }

                return _tokReadDouble;
            }
        }

        private int ReadUnsignedShort {
            get {
                if (_tokReadUnsignedShort == 0) {
                    MethodInfo miReadUnsignedShort = typeof(TdsParser).GetMethod("ReadUnsignedShort");
                    _tokReadUnsignedShort = _mod.GetMethodToken(miReadUnsignedShort).Token;
                    Debug.Assert(0 != _tokReadUnsignedShort, "Failed to get ReadUnsignedShort method!");
                }

                return _tokReadUnsignedShort;
            }
        }

        private int SkipBytes {
            get {
                if (_tokSkipBytes == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(int);
                    MethodInfo miSkipBytes = typeof(TdsParser).GetMethod("SkipBytes", args);
                    _tokSkipBytes = _mod.GetMethodToken(miSkipBytes).Token;
                    Debug.Assert(0 != _tokSkipBytes, "Failed to get SkipBytes method!");
                }

                return _tokSkipBytes;
            }
        }

        private int ReadString {
            get {
                if (_tokReadString == 0) {
                    MethodInfo miReadString = typeof(TdsParser).GetMethod("ReadString");
                    _tokReadString = _mod.GetMethodToken(miReadString).Token;
                    Debug.Assert(0 != _tokReadString, "Failed to get ReadString method!");
                }

                return _tokReadString;
            }
        }

        private int ReadEncodingChar {
            get {
                if (_tokReadEncodingChar == 0) {
                    MethodInfo miReadEncodingChar = typeof(TdsParser).GetMethod("ReadEncodingChar");
                    _tokReadEncodingChar = _mod.GetMethodToken(miReadEncodingChar).Token;
                    Debug.Assert(0 != _tokReadEncodingChar, "Failed to get ReadEncodingChar method!");
                }

                return _tokReadEncodingChar;
            }
        }

        private int GetTokenLength {
            get {
                if (_tokGetTokenLength == 0) {
                    Type[] args = new Type[1];
                    args[0] = typeof(byte);
                    MethodInfo miGetTokenLength = typeof(TdsParser).GetMethod("GetTokenLength", args);
                    _tokGetTokenLength = _mod.GetMethodToken(miGetTokenLength).Token;
                    Debug.Assert(0 != _tokGetTokenLength, "Failed to get GetTokenLength method!");
                }

                return _tokGetTokenLength;
            }
        }
    }//DataLoaderHelper
}//namespace
#endif // OBJECT_BINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlconnectionstring.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlConnectionString.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;

    sealed internal class SqlConnectionString : DBConnectionString {

        sealed internal class DEFAULT {
            internal const  string Application_Name      = TdsEnums.SQL_PROVIDER_NAME;
            internal const  string AttachDBFilename      = "";
            internal const  int    Connection_Lifetime   = 0; // default of 0 means don't use
            internal const  int    Connect_Timeout       = ADP.DefaultConnectionTimeout;
            internal const  bool   Connection_Reset      = true;
            internal const  string Current_Language      = "";
            internal const  string Data_Source           = "";
            internal const  bool   Encrypt               = false;
            internal const  bool   Enlist                = true;
            internal const  string Initial_Catalog       = "";
            internal const  bool   Integrated_Security   = false;
            internal const  int    Max_Pool_Size         = 100;
            internal const  int    Min_Pool_Size         = 0;
            internal const  string Network_Library       = "";
            internal const  int    Packet_Size           = 8192;
            internal const  string Password              = "";
            internal const  bool   Persist_Security_Info = false;
            internal const  bool   Pooling               = true;
            internal const  string User_ID               = "";

            internal const  int    MIN_PACKET_SIZE       = 512;
            internal const  int    MAX_PACKET_SIZE       = 32767;
        }

        // SqlConnection ConnectionString Options
        sealed internal class KEY {
            internal const string Application_Name      = "application name";
            internal const string AttachDBFilename      = "attachdbfilename";
            internal const string Connection_Lifetime   = "connection lifetime";
            internal const string Connect_Timeout       = "connect timeout";
            internal const string Connection_Reset      = "connection reset";
            internal const string Current_Language      = "current language";
            internal const string Data_Source           = "data source";
            internal const string Encrypt               = "encrypt";
            internal const string Enlist                = "enlist";
            internal const string Initial_Catalog       = "initial catalog";
            internal const string Integrated_Security   = "integrated security";
            internal const string Max_Pool_Size         = "max pool size";
            internal const string Min_Pool_Size         = "min pool size";
            internal const string Network_Library       = "network library";
            internal const string Packet_Size           = "packet size";
            internal const string Password              = "password";
            internal const string Persist_Security_Info = "persist security info";
            internal const string Pooling               = "pooling";
            internal const string User_ID               = "user id";
            internal const string Workstation_Id        = "workstation id";
        }

        // Constant for the number of duplicate options in the connnection string

        sealed private class SYNONYM {
            // application name
            internal const string APP                 = "app";
            // attachDBFilename
            internal const string EXTENDED_PROPERTIES = "extended properties";
            internal const string INITIAL_FILE_NAME   = "initial file name";
            // connect timeout
            internal const string CONNECTION_TIMEOUT  = "connection timeout";
            internal const string TIMEOUT             = "timeout";
            // current language
            internal const string LANGUAGE            = "language";
            // data source
            internal const string ADDR                = "addr";
            internal const string ADDRESS             = "address";
            internal const string SERVER              = "server";
            internal const string NETWORK_ADDRESS     = "network address";
            // initial catalog
            internal const string DATABASE            = "database";
            // integrated security
            internal const string TRUSTED_CONNECTION  = "trusted_connection";
            // network library
            internal const string NET                 = "net";
            internal const string NETWORK             = "network";
            // password
            internal const string Pwd                 = "pwd";
            // persist security info
            internal const string PERSISTSECURITYINFO = "persistsecurityinfo";
            // user id
            internal const string UID                 = "uid";
            internal const string User                = "user";
            // workstation id
            internal const string WSID                = "wsid";
        }

        // the following are all inserted as keys into the _netlibMapping hash
        sealed private class NETLIB {
            internal const string DBMSSOCN = "dbmssocn";
            internal const string DBNMPNTW = "dbnmpntw";
            internal const string DBMSRPCN = "dbmsrpcn";
            internal const string DBMSVINN = "dbmsvinn";
            internal const string DBMSADSN = "dbmsadsn";
            internal const string DBMSSPXN = "dbmsspxn";
            internal const string DBMSGNET = "dbmsgnet";
            internal const string DBMSLPCN = "dbmslpcn";
        }

        sealed private class MISC {
            // accepted values for localhost that will be compared against to specify shared memory
            internal const string LOCAL_VALUE_1 = ".";
            internal const string LOCAL_VALUE_2 = "(local)";
            internal const char BACKSLASH    = '\\';

            internal const int KeyCount_SqlClient = 20;
            internal const int SynonymCount_SqlClient = 19;
            internal const int NetLibCount = 8;
        }

        static private Hashtable _sqlClientSynonyms;
        static private Hashtable _sqlClientParseCache;
        static private Hashtable _netlibMapping;

        static private string _workstation_ID = null; // default of null - unset

#if USECRYPTO
        static internal readonly SqlConnectionString Default = new SqlConnectionString("", "");
#else
        static internal readonly SqlConnectionString Default = new SqlConnectionString("");
#endif

        private readonly SqlClientPermission _permission;

        bool _integratedSecurity;
        bool _connectionReset;
        bool _encrypt;
        bool _enlist;
        bool _persistSecurityInfo;
        bool _pooling;

        int _connectionLifeTime;
        int _connectTimeout;
        int _maxPoolSize;
        int _minPoolSize;
        int _packetSize;

        string _applicationName;
        string _attachDBFileName;
        string _currentLanguage;
        string _dataSource;
        string _initialCatalog;
        string _networkLibrary;
        string _userID;
        string _password;
        string _workstationId;

        static internal SqlConnectionString ParseString(string connectionString) {
            SqlConnectionString constr = null;
            if (!ADP.IsEmpty(connectionString)) {

                constr = (DBConnectionString.CacheQuery(connectionString, _sqlClientParseCache) as SqlConnectionString);
                if (null == constr) {
#if USECRYPTO
                    string encrypted = null/*Crypto.EncryptString(connectionString)*/;
                    string hashvalue = (null == encrypted) ? Crypto.ComputeHash(connectionString) : encrypted;
                    constr = (DBConnectionString.CacheQuery(hashvalue, _sqlClientParseCache) as SqlConnectionString);
                    if (null == constr) {
                        constr = new SqlConnectionString(connectionString, encrypted);
#else
                        constr = new SqlConnectionString(connectionString);
#endif
                        if (constr.ShouldCache()) {
#if USECRYPTO
                            if (!constr.IsEncrypted) {
                                hashvalue = connectionString;
                            }
                            CacheAdd(hashvalue, constr, ref _sqlClientParseCache);
#else
                            CacheAdd(connectionString, constr, ref _sqlClientParseCache);
#endif
                        }
#if USECRYPTO
                    }
#endif
                }
            }
            return constr;
        }

#if USECRYPTO
        private SqlConnectionString(string connectionString, string encyrypted) : base(connectionString, encyrypted, UdlSupport.ThrowIfFound) {
#else
        private SqlConnectionString(string connectionString) : base(connectionString, UdlSupport.ThrowIfFound) {
#endif
            if (base.IsEmpty()) {
                _integratedSecurity  = DEFAULT.Integrated_Security;
                _connectionReset     = DEFAULT.Connection_Reset;
                _enlist              = DEFAULT.Enlist;
                _encrypt             = DEFAULT.Encrypt;
                _persistSecurityInfo = DEFAULT.Persist_Security_Info;
                _pooling             = DEFAULT.Pooling;

                _connectionLifeTime = DEFAULT.Connection_Lifetime;
                _connectTimeout     = DEFAULT.Connect_Timeout;
                _maxPoolSize        = DEFAULT.Max_Pool_Size;
                _minPoolSize        = DEFAULT.Min_Pool_Size;
                _packetSize         = DEFAULT.Packet_Size;

                _applicationName  = DEFAULT.Application_Name;
                _attachDBFileName = DEFAULT.AttachDBFilename;
                _currentLanguage  = DEFAULT.Current_Language;
                _dataSource       = DEFAULT.Data_Source;
                _initialCatalog   = DEFAULT.Initial_Catalog;
                _networkLibrary   = DEFAULT.Network_Library;
                _userID           = DEFAULT.User_ID;
                _password         = DEFAULT.Password;
                _workstationId    = _workstation_ID;
            }
            _permission = new SqlClientPermission(this);
        }

        internal SqlConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : base(connectionString, restrictions, behavior, UdlSupport.ThrowIfFound) {
        }

        private SqlConnectionString(SqlConnectionString value) : base(value, false) { // Clone
            _permission = value._permission;

            _integratedSecurity = value._integratedSecurity;
            _connectionReset = value._connectionReset;
            _enlist = value._enlist;
            _encrypt = value._encrypt;
            _persistSecurityInfo = value._persistSecurityInfo;
            _pooling = value._pooling;

            _connectionLifeTime = value._connectionLifeTime;
            _connectTimeout = value._connectTimeout;
            _maxPoolSize = value._maxPoolSize;
            _minPoolSize = value._minPoolSize;
            _packetSize = value._packetSize;

            _applicationName = value._applicationName;
            _attachDBFileName = value._attachDBFileName;
            _currentLanguage = value._currentLanguage;
            _dataSource = value._dataSource;
            _initialCatalog = value._initialCatalog;
            _networkLibrary = value._networkLibrary;
            _userID = value._userID;
            _password = value._password;
            _workstationId = value._workstationId;
        }

        static internal void Demand(SqlConnectionString constr) {
            SqlClientPermission permission = ((null != constr) ? constr._permission : SqlConnection.SqlClientPermission);
            permission.Demand();
        }

        internal bool IntegratedSecurity { get { return _integratedSecurity; } }
        internal bool ConnectionReset { get { return _connectionReset; } }
        internal bool Enlist { get { return _enlist; } }
        internal bool Encrypt { get { return _encrypt; } }
      //internal bool PersistSecurityInfo { get { return _persistSecurityInfo; } }
        internal bool Pooling { get { return _pooling; } }

        internal int ConnectionLifeTime { get { return _connectionLifeTime; } }
        internal int ConnectTimeout { get { return _connectTimeout; } }
        internal int MaxPoolSize { get { return _maxPoolSize; } }
        internal int MinPoolSize { get { return _minPoolSize; } }
        internal int PacketSize { get { return _packetSize; } set { _packetSize = value; } }

        internal string ApplicationName { get { return _applicationName; } }
        internal string AttachDBFilename { get { return _attachDBFileName; } }
        internal string CurrentLanguage { get { return _currentLanguage; } set { _currentLanguage = value; } }
        internal string DataSource { get { return _dataSource; } }
        internal string InitialCatalog { get { return _initialCatalog; } set { _initialCatalog = value; } }
        internal string NetworkLibrary { get { return _networkLibrary; } }
        internal string UserID { get { return _userID; } }
        internal string Password { get { return _password; } }
        internal string WorkstationId { get { return _workstationId; } }

        internal SqlConnectionString Clone() {
            return new SqlConnectionString(this);
        }

        // no real danger if user modifies this hashtable
        // at worst they add synonms to keys that doesn't exist - adding dead key/values
        // or add/remove a synonm mappings
        static private Hashtable GetParseSynonyms() {
            Hashtable hash = _sqlClientSynonyms;
            if (null == hash) {
                hash = new Hashtable(MISC.KeyCount_SqlClient + MISC.SynonymCount_SqlClient);
                hash.Add(KEY.Application_Name,      KEY.Application_Name);
                hash.Add(KEY.AttachDBFilename,      KEY.AttachDBFilename);
                hash.Add(KEY.Connection_Lifetime,   KEY.Connection_Lifetime);
                hash.Add(KEY.Connect_Timeout,       KEY.Connect_Timeout);
                hash.Add(KEY.Connection_Reset,      KEY.Connection_Reset);
                hash.Add(KEY.Current_Language,      KEY.Current_Language);
                hash.Add(KEY.Data_Source,           KEY.Data_Source);
                hash.Add(KEY.Encrypt,               KEY.Encrypt);
                hash.Add(KEY.Enlist,                KEY.Enlist);
                hash.Add(KEY.Initial_Catalog,       KEY.Initial_Catalog);
                hash.Add(KEY.Integrated_Security,   KEY.Integrated_Security);
                hash.Add(KEY.Max_Pool_Size,         KEY.Max_Pool_Size);
                hash.Add(KEY.Min_Pool_Size,         KEY.Min_Pool_Size);
                hash.Add(KEY.Network_Library,       KEY.Network_Library);
                hash.Add(KEY.Packet_Size,           KEY.Packet_Size);
                hash.Add(KEY.Password,              KEY.Password);
                hash.Add(KEY.Persist_Security_Info, KEY.Persist_Security_Info);
                hash.Add(KEY.Pooling,               KEY.Pooling);
                hash.Add(KEY.User_ID,               KEY.User_ID);
                hash.Add(KEY.Workstation_Id,        KEY.Workstation_Id);

                hash.Add(SYNONYM.APP,                 KEY.Application_Name);
                hash.Add(SYNONYM.EXTENDED_PROPERTIES, KEY.AttachDBFilename);
                hash.Add(SYNONYM.INITIAL_FILE_NAME,   KEY.AttachDBFilename);
                hash.Add(SYNONYM.CONNECTION_TIMEOUT,  KEY.Connect_Timeout);
                hash.Add(SYNONYM.TIMEOUT,             KEY.Connect_Timeout);
                hash.Add(SYNONYM.LANGUAGE,            KEY.Current_Language);
                hash.Add(SYNONYM.ADDR,                KEY.Data_Source);
                hash.Add(SYNONYM.ADDRESS,             KEY.Data_Source);
                hash.Add(SYNONYM.NETWORK_ADDRESS,     KEY.Data_Source);
                hash.Add(SYNONYM.SERVER,              KEY.Data_Source);
                hash.Add(SYNONYM.DATABASE,            KEY.Initial_Catalog);
                hash.Add(SYNONYM.TRUSTED_CONNECTION,  KEY.Integrated_Security);
                hash.Add(SYNONYM.NET,                 KEY.Network_Library);
                hash.Add(SYNONYM.NETWORK,             KEY.Network_Library);
                hash.Add(SYNONYM.Pwd,                 KEY.Password);
                hash.Add(SYNONYM.PERSISTSECURITYINFO, KEY.Persist_Security_Info);
                hash.Add(SYNONYM.UID,                 KEY.User_ID);
                hash.Add(SYNONYM.User,                KEY.User_ID);
                hash.Add(SYNONYM.WSID,                KEY.Workstation_Id);
#if DEBUG
                hash = ADP.ProtectHashtable(hash);
#endif
                _sqlClientSynonyms = hash;
            }
            return hash;
        }

        override protected string KeywordLookup(string keyname) {
            try {
                Hashtable lookup = GetParseSynonyms();
                return (string) lookup[keyname];
            }
            catch(Exception e) {
                ADP.TraceException(e);
                throw ADP.KeywordNotSupported(keyname);
            }
        }

        override protected bool IsSensitiveOption(string keyname) {
            Debug.Assert(SYNONYM.Pwd != keyname, "why was pwd not converted to password?");
            return (KEY.Password == keyname);
        }

        override protected string ValidateParse() {
            _integratedSecurity = CheckConvertIntegratedSecurity();

            _connectionReset     = CheckConvertToBoolean(KEY.Connection_Reset,      DEFAULT.Connection_Reset);
            _encrypt             = CheckConvertToBoolean(KEY.Encrypt,               DEFAULT.Encrypt);
            _enlist              = CheckConvertToBoolean(KEY.Enlist,                DEFAULT.Enlist);
            _persistSecurityInfo = CheckConvertToBoolean(KEY.Persist_Security_Info, DEFAULT.Persist_Security_Info);
            _pooling             = CheckConvertToBoolean(KEY.Pooling,               DEFAULT.Pooling);

            _connectionLifeTime = CheckConvertToInt32(KEY.Connection_Lifetime,   DEFAULT.Connection_Lifetime);
            _connectTimeout     = CheckConvertToInt32(KEY.Connect_Timeout,       DEFAULT.Connect_Timeout);
            _maxPoolSize        = CheckConvertToInt32(KEY.Max_Pool_Size,         DEFAULT.Max_Pool_Size);
            _minPoolSize        = CheckConvertToInt32(KEY.Min_Pool_Size,         DEFAULT.Min_Pool_Size);
            _packetSize         = CheckConvertToInt32(KEY.Packet_Size,           DEFAULT.Packet_Size);

            _applicationName  = CheckConvertToString(KEY.Application_Name, DEFAULT.Application_Name);
            _attachDBFileName = CheckConvertToString(KEY.AttachDBFilename, DEFAULT.AttachDBFilename);
            _currentLanguage   = CheckConvertToString(KEY.Current_Language, DEFAULT.Current_Language);
            _dataSource       = CheckConvertToString(KEY.Data_Source,      DEFAULT.Data_Source);
            _initialCatalog   = CheckConvertToString(KEY.Initial_Catalog,  DEFAULT.Initial_Catalog);
            _networkLibrary   = CheckConvertToString(KEY.Network_Library,  null);
            _userID           = CheckConvertToString(KEY.User_ID,          DEFAULT.User_ID);
            _password         = CheckConvertToString(KEY.Password,         DEFAULT.Password);
            _workstationId    = CheckConvertToString(KEY.Workstation_Id,   _workstation_ID);

            if (_connectionLifeTime < 0) {
                throw ADP.InvalidConnectionOptionValue(KEY.Connection_Lifetime);
            }

            if (_connectTimeout < 0) {
                throw ADP.InvalidConnectionOptionValue(KEY.Connection_Lifetime);
            }

            if (_maxPoolSize < 1) {
                throw ADP.InvalidConnectionOptionValue(KEY.Connection_Lifetime);
            }

            if (_minPoolSize < 0) {
                throw ADP.InvalidConnectionOptionValue(KEY.Connection_Lifetime);
            }
            if (_maxPoolSize < _minPoolSize) {
                throw SQL.InvalidMinMaxPoolSizeValues();
            }

            if ((_packetSize < DEFAULT.MIN_PACKET_SIZE) || (DEFAULT.MAX_PACKET_SIZE < _packetSize)) {
                throw SQL.InvalidPacketSizeValue();
            }

            if (null != _networkLibrary) { // MDAC 83525
                string networkLibrary = _networkLibrary.Trim().ToLower(CultureInfo.InvariantCulture);
                Hashtable netlib = NetlibMapping();
                if (!netlib.ContainsKey(networkLibrary)) {
                    throw ADP.InvalidConnectionOptionValue(KEY.Network_Library);
                }
                _networkLibrary = (string) netlib[networkLibrary];
            }
            else {
                CheckSetNetwork();
                if (null == _networkLibrary) {
                    _networkLibrary = DEFAULT.Network_Library;
                }
            }

            CheckObtainWorkstationId(false);
            return EncryptedActualConnectionString;
        }

        internal string CheckObtainWorkstationId(bool potentialDefault) {
            if (null == _workstationId) {
                _workstationId = WorkStationId();

                if (potentialDefault) {
                    _workstation_ID = _workstationId;
                }
            }
            return ((null != _workstationId) ? _workstationId : ADP.StrEmpty);
        }

        private void CheckSetNetwork() {
            // If the user has not specified a network protocol and the server is specified
            // as ".", "(local)", or the current machine name, force the use of shared memory.
            // This is consistent with luxor.

            // Default will be "" for server.
            string server = _dataSource.Trim();

            // Check to see if they are connecting to a named instance, and if so parse.  ie, "foo\bar"
            int index = server.IndexOf(MISC.BACKSLASH, 0);
            if (index != -1) {
                server = server.Substring(0, index);
            }
            if ((MISC.LOCAL_VALUE_1 == server) || (MISC.LOCAL_VALUE_2 == server) || (WorkStationId().ToLower(CultureInfo.InvariantCulture) == server.ToLower(CultureInfo.InvariantCulture))) {
                _networkLibrary = TdsEnums.LPC;
            }
        }

        static internal Hashtable NetlibMapping() {
            Hashtable hash = _netlibMapping;
            if (null == hash) {
                hash = new Hashtable(MISC.NetLibCount);
                hash.Add(NETLIB.DBMSSOCN, TdsEnums.TCP);
                hash.Add(NETLIB.DBNMPNTW, TdsEnums.NP);
                hash.Add(NETLIB.DBMSRPCN, TdsEnums.RPC);
                hash.Add(NETLIB.DBMSVINN, TdsEnums.BV);
                hash.Add(NETLIB.DBMSADSN, TdsEnums.ADSP);
                hash.Add(NETLIB.DBMSSPXN, TdsEnums.SPX);
                hash.Add(NETLIB.DBMSGNET, TdsEnums.VIA);
                hash.Add(NETLIB.DBMSLPCN, TdsEnums.LPC);
#if DEBUG
                hash = ADP.ProtectHashtable(hash);
#endif
                _netlibMapping = hash;
            }
            return hash;
        }

        static private string MachineName() {
            try { // try-filter-finally so and catch-throw
                PermissionSet ps = new PermissionSet(PermissionState.None);
                ps.AddPermission(new EnvironmentPermission(PermissionState.Unrestricted));
                ps.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
                ps.Assert(); // MDAC 62038
                try {
                    return Environment.MachineName;
                }
                finally { // RevertAssert w/ catch-throw
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        static private string WorkStationId() {
            string value = _workstation_ID;
            if (null == value) {
                value = MachineName(); // MDAC 67860

                if (null == value) {
                    value = "";
                }
                _workstation_ID = value;
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqldataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Data.Common;

namespace System.Data.SqlClient {

    /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter"]/*' />
    [
    DefaultEvent("RowUpdated"),
    ToolboxItem("Microsoft.VSDesigner.Data.VS.SqlDataAdapterToolboxItem, " + AssemblyRef.MicrosoftVSDesigner),
    Designer("Microsoft.VSDesigner.Data.VS.SqlDataAdapterDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    sealed public class SqlDataAdapter : DbDataAdapter, IDbDataAdapter, ICloneable {

        private SqlCommand cmdSelect;
        private SqlCommand cmdInsert;
        private SqlCommand cmdUpdate;
        private SqlCommand cmdDelete;
        private SqlCommand internalCmdSelect; // MDAC 82556

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.SqlDataAdapter"]/*' />
        public SqlDataAdapter() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.SqlDataAdapter1"]/*' />
        public SqlDataAdapter(SqlCommand selectCommand) : base() {
            GC.SuppressFinalize(this);
            SelectCommand = selectCommand;
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.SqlDataAdapter2"]/*' />
        public SqlDataAdapter(string selectCommandText, string selectConnectionString) : base() {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new SqlCommand(selectCommandText, new SqlConnection(selectConnectionString));
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.SqlDataAdapter3"]/*' />
        public SqlDataAdapter(string selectCommandText, SqlConnection selectConnection) : base() {
            GC.SuppressFinalize(this);
            internalCmdSelect = SelectCommand = new SqlCommand(selectCommandText, selectConnection);
        }

        private SqlDataAdapter(SqlDataAdapter adapter) : base(adapter) { // MDAC 81448
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.DeleteCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_DeleteCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public SqlCommand DeleteCommand {
            get {
                return this.cmdDelete;
            }
            set {
                this.cmdDelete = value;
            }
        }
        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.IDbDataAdapter.DeleteCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.DeleteCommand {
            get {
                return this.cmdDelete;
            }
            set {
                DeleteCommand = (SqlCommand)value;
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.InsertCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_InsertCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public SqlCommand InsertCommand {
            get {
                return this.cmdInsert;
            }
            set {
                this.cmdInsert = value;
            }
        }
        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.IDbDataAdapter.InsertCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.InsertCommand {
            get {
                return this.cmdInsert;
            }
            set {
                InsertCommand = (SqlCommand)value;
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.SelectCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Fill),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_SelectCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public SqlCommand SelectCommand {
            get {
                return this.cmdSelect;
            }
            set {
                if (this.cmdSelect != value) {
                    this.cmdSelect = value;
                    ADP.SafeDispose(internalCmdSelect);
                    internalCmdSelect = null;
                }
            }
        }
        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.IDbDataAdapter.SelectCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.SelectCommand {
            get {
                return this.cmdSelect;
            }
            set {
                SelectCommand = (SqlCommand)value;
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.UpdateCommand"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DefaultValue(null),
        DataSysDescription(Res.DbDataAdapter_UpdateCommand),
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public SqlCommand UpdateCommand {
            get {
                return this.cmdUpdate;
            }
            set {
                this.cmdUpdate = value;
            }
        }
        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.IDbDataAdapter.UpdateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbDataAdapter.UpdateCommand {
            get {
                return this.cmdUpdate;
            }
            set {
                UpdateCommand = (SqlCommand)value;
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.RowUpdated"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DataSysDescription(Res.DbDataAdapter_RowUpdated)
        ]
        public event SqlRowUpdatedEventHandler RowUpdated {
            add {
                Events.AddHandler(ADP.EventRowUpdated, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventRowUpdated, value);
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.RowUpdating"]/*' />
        [
        DataCategory(Res.DataCategory_Update),
        DataSysDescription(Res.DbDataAdapter_RowUpdating)
        ]
        public event SqlRowUpdatingEventHandler RowUpdating {
            add {
                SqlRowUpdatingEventHandler handler = (SqlRowUpdatingEventHandler) Events[ADP.EventRowUpdating];

	           	// MDAC 58177, 64513
    		  	// prevent someone from registering two different command builders on the adapter by
    		  	// silently removing the old one
            	if ((null != handler) && (value.Target is CommandBuilder)) {
    	       		SqlRowUpdatingEventHandler d = (SqlRowUpdatingEventHandler) CommandBuilder.FindBuilder(handler);
              		if (null != d) {
                        Events.RemoveHandler(ADP.EventRowUpdating, d);
              		}	   					
            	}
                Events.AddHandler(ADP.EventRowUpdating, value);
            }
            remove {
                Events.RemoveHandler(ADP.EventRowUpdating, value);
            }
        }

        object ICloneable.Clone() { // MDAC 81448
            return new SqlDataAdapter(this);
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.CreateRowUpdatedEvent"]/*' />
        /// <internalonly/>
        override protected RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new SqlRowUpdatedEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.CreateRowUpdatingEvent"]/*' />
        /// <internalonly/>
        override protected RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) {
            return new SqlRowUpdatingEventArgs(dataRow, command, statementType, tableMapping);
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 82556
            if (disposing) {
                if (null != internalCmdSelect) {
                    internalCmdSelect.Dispose();
                    internalCmdSelect = null;
                }
            }
            base.Dispose(disposing); // notify base classes 
        }
        
        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.OnRowUpdated1"]/*' />
        override protected void OnRowUpdated(RowUpdatedEventArgs value) {
            SqlRowUpdatedEventHandler handler = (SqlRowUpdatedEventHandler) Events[ADP.EventRowUpdated];
            if ((null != handler) && (value is SqlRowUpdatedEventArgs)) {
                handler(this, (SqlRowUpdatedEventArgs) value);
            }
        }

        /// <include file='doc\SqlDataAdapter.uex' path='docs/doc[@for="SqlDataAdapter.OnRowUpdating1"]/*' />
        override protected void OnRowUpdating(RowUpdatingEventArgs value) {
            SqlRowUpdatingEventHandler handler = (SqlRowUpdatingEventHandler) Events[ADP.EventRowUpdating];
            if ((null != handler) && (value is SqlRowUpdatingEventArgs)) {
                handler(this, (SqlRowUpdatingEventArgs) value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlconnectionpoolmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlConnectionPoolManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;

    sealed internal class SqlConnectionPoolManager {
        private static PoolManager _manager     = null;
        private static bool        _isWindows9x = false;

        private static void Init() {
            try {
                lock(typeof(SqlConnectionPoolManager)) {
                    if (null == _manager) {
                        _manager     = new PoolManager();
                        _isWindows9x = SQL.IsPlatformWin9x();
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        public static SqlInternalConnection GetPooledConnection(SqlConnectionString options, out bool isInTransaction) {
            // If Init() has not been called, call it and set up the cached members
            if (null == _manager)
                Init();

            ConnectionPool           pool                      = null;
            SqlConnectionPoolControl poolControl               = null;
            SqlInternalConnection    con                       = null;
            IntPtr                   SID                       = IntPtr.Zero; // Actual SID
            IntPtr                   tokenStruct               = IntPtr.Zero; // Struct in memory containing SID
            string                   encryptedConnectionString = options.EncryptedActualConnectionString;

            try {
                // GetTokenInfo and EqualSID do not work on 9x.  WindowsIdentity does not work
                // either on 9x.  In fact, after checking with native there is no way to validate the
                // user on 9x, so simply don't.  It is a known issue in native, and we will handle
                // this the same way.  _txPool is not created on 9x, so if that is not null then we
                // know we are not on 9x so go ahead do security check.
                if (options.IntegratedSecurity && !_isWindows9x) {
                    // If using integrated security, find the pool based on the connection string.  Then,
                    // compare the SIDs of all pools to find a match.  If no match found, create a new pool.
                    // This will guarantee anyone using integrated security will always be sent to the 
                    // appropriate pool.
                    DefaultPoolControl.ObtainSidInfo(out SID, out tokenStruct);
                    pool = _manager.FindPool(encryptedConnectionString, SID);

                    // If we found a pool, then we no longer need this SID - free it's token struct!
                    // However, if we did not find a pool then we will create a new one and it will be up
                    // to that pool to free the tokenStruct memory.
                    if (null != pool) {
                        Marshal.FreeHGlobal(tokenStruct);
                    }
                }
                else {
                    pool = _manager.FindPool(encryptedConnectionString);
                }

                if (pool == null) {
                    // If pool is null, then we need to create a new pool - based on the connection string
                    // and userid.  SID and tokenStruct are included for integrated security connections.
                    if (options.IntegratedSecurity && !_isWindows9x) {
                        poolControl = new SqlConnectionPoolControl(encryptedConnectionString, true, SID, tokenStruct, options);
                        pool = _manager.FindOrCreatePool(poolControl, SID); // MDAC 81288
                    }
                    else {
                        poolControl = new SqlConnectionPoolControl(encryptedConnectionString, false, IntPtr.Zero, IntPtr.Zero, options);
                        pool = _manager.FindOrCreatePool(poolControl); // MDAC 81288
                    }
                }
            }
            catch {
                // If an exception is thrown and the pool was not created or found, then we need to free the memory for
                // the token struct.
                if (null == poolControl) {
                    Marshal.FreeHGlobal(tokenStruct);
                }

                throw;
            }
            
            con = pool.GetConnection(out isInTransaction);

            // If GetObject() failed, the pool timeout occurred.
            if (con == null) {
                throw SQL.PooledOpenTimeout();
            }
            
            return con;
        }

        public static void ReturnPooledConnection(SqlInternalConnection pooledConnection) {
            pooledConnection.Pool.PutConnection(pooledConnection);
        }
    }

    sealed internal class SqlConnectionPoolControl : DefaultPoolControl {
        // connection options hashtable
        private SqlConnectionString _connectionOptions;

        // lifetime variables
        private bool     _fCheckLifetime;
        private TimeSpan _lifetime;

        // connection reset variables
        private bool   _fResetConnection;
        private string _originalDatabase;
        private string _originalLanguage;
        
        public SqlConnectionPoolControl(String key, bool integratedSecurity, IntPtr SID, IntPtr tokenStruct, SqlConnectionString connectionOptions) : base(key, integratedSecurity, SID, tokenStruct) {
            // CreationTimeout is in milliseconds, Connection Timeout is in seconds, but don't set it to > MaxValue
            CreationTimeout     = connectionOptions.ConnectTimeout;
            if ((0 < CreationTimeout) && (CreationTimeout < Int32.MaxValue/1000))
                CreationTimeout *= 1000;
            else if (CreationTimeout >= Int32.MaxValue/1000)
                CreationTimeout = Int32.MaxValue;
            MaxPool             = connectionOptions.MaxPoolSize;
            MinPool             = connectionOptions.MinPoolSize;
            TransactionAffinity = connectionOptions.Enlist;
    
            _connectionOptions  = connectionOptions.Clone();

            int lifetime        = connectionOptions.ConnectionLifeTime;

            // Initialize the timespan class for the pool control, if it's not zero.
            // If it was zero - that means infinite lifetime.
            if (lifetime != 0) {
                _fCheckLifetime = true;
                _lifetime       = new TimeSpan(0, 0, lifetime);
            }

            // if reset is specified, obtain variables
            if (_connectionOptions.ConnectionReset) {
               _fResetConnection = true;
               _originalDatabase = _connectionOptions.InitialCatalog;
               _originalLanguage = _connectionOptions.CurrentLanguage;
            }
        }

        public override SqlInternalConnection CreateConnection(ConnectionPool pool) {
            return (new SqlInternalConnection(_connectionOptions, pool, _fCheckLifetime, 
                    _lifetime, _fResetConnection, _originalDatabase, _originalLanguage));
        }

        public override void DestroyConnection(ConnectionPool pool, SqlInternalConnection con) {
            con.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlcommandbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlCommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder"]/*' />
    sealed public class SqlCommandBuilder : Component {
        private CommandBuilder cmdBuilder;

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.SqlCommandBuilder"]/*' />
        public SqlCommandBuilder() : base() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.SqlCommandBuilder1"]/*' />
        public SqlCommandBuilder(SqlDataAdapter adapter) : base() {
            GC.SuppressFinalize(this);
            DataAdapter = adapter;
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.DataAdapter"]/*' />
        [
        DefaultValue(null),
        DataSysDescription(Res.SqlCommandBuilder_DataAdapter) // MDAC 60524
        ]
        public SqlDataAdapter DataAdapter {
            get {
                return (SqlDataAdapter) GetBuilder().DataAdapter;
            }
            set {
                GetBuilder().DataAdapter = value;
            }
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.QuotePrefix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlCommandBuilder_QuotePrefix)
        ]
        public string QuotePrefix {
            get {
                return GetBuilder().QuotePrefix;
            }
            set {
                GetBuilder().QuotePrefix = value;
            }
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.QuoteSuffix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlCommandBuilder_QuoteSuffix)
        ]
        public string QuoteSuffix {
            get {
                return GetBuilder().QuoteSuffix;
            }
            set {
                GetBuilder().QuoteSuffix = value;
            }
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.Dispose"]/*' />
        override protected void Dispose(bool disposing) { // MDAC 65459
            if (disposing) { // release mananged objects
                if (null != this.cmdBuilder) {
                    this.cmdBuilder.Dispose();
                    this.cmdBuilder = null;
                }
            }
            // release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        // method instead of property because VS7 debugger will evaluate
        // properties and we don't want the object created just for that
        private CommandBuilder GetBuilder() {
            if (null == this.cmdBuilder) {
                this.cmdBuilder = new CommandBuilder();
            }
            return this.cmdBuilder;
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.DeriveParameters"]/*' />
        static public void DeriveParameters(SqlCommand command) { // MDAC 65927\
            SqlConnection.SqlClientPermission.Demand();

            if (null == command) {
                throw ADP.ArgumentNull("command");
            }

            command.DeriveParameters();
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.GetInsertCommand"]/*' />
        public SqlCommand GetInsertCommand() {
            return (SqlCommand) GetBuilder().GetInsertCommand();
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.GetUpdateCommand"]/*' />
        public SqlCommand GetUpdateCommand() {
            return (SqlCommand) GetBuilder().GetUpdateCommand();
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.GetDeleteCommand"]/*' />
        public SqlCommand GetDeleteCommand() {
            return (SqlCommand) GetBuilder().GetDeleteCommand();
        }

        /// <include file='doc\SqlCommandBuilder.uex' path='docs/doc[@for="SqlCommandBuilder.RefreshSchema"]/*' />
        public void RefreshSchema() {
            GetBuilder().RefreshSchema();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqldatareader.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlDataReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System.Threading;
    using System.Diagnostics;

    /*
     * IDataStream implementation for the SQL Server adapter
     */

    using System;
    using System.Data;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Data.SqlTypes;
    using System.Data.Common;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader"]/*' />
    sealed public class SqlDataReader : MarshalByRefObject, IEnumerable, IDataReader {
        private TdsParser _parser;
        private SqlCommand _command;
        private int _defaultLCID;
#if OBJECT_BINDING  
        private DataLoaderHelper _dataHelper;
        private object _objBuffer;
        private DataLoader _pfnDataLoader = null;
#endif  
        private bool _dataReady;  // ready to ProcessRow

        private bool _metaDataConsumed;
        private bool _browseModeInfoConsumed;
        private bool _isClosed;
        private bool _hasRows;
        private int  _recordsAffected = -1;

        // row buffer (filled in @ .Read())
        private object[] _comBuf; // row buffer for com types, never held across reads
        private object[] _sqlBuf; // row buffer for sql types, never held across reads
        private int[] _indexMap; // maps visible columns to contiguous slots in the array
        private int _visibleColumns; // number of non-hidden columns

        // buffers and metadata
        private _SqlMetaData[] _metaData; // current metaData for the stream, it is lazily loaded
        private FieldNameLookup _fieldNameLookup;

        // context
        // undone: we may still want to do this...it's nice to pass in an lpvoid (essentially) and just have the reader keep the state
        // private object _context = null; // this is never looked at by the stream object.  It is used by upper layers who wish
        // to remain stateless

        // metadata (no explicit table, use 'Table')
        private string[] _tableNames = null;
        private string[][] _tableNamesShilohSP1 = null;
        private string _setOptions;
        private CommandBehavior _behavior;
        private bool _haltRead; // bool to denote whether we have read first row for single row behavior

        // sequential behavior reader
        private int _currCol;
        private long _seqBytesRead; // last byte read by user
        private long _seqBytesLeft; // total bytes available in column
        private int  _peekLength = -1; // we have a one column value peek for null handling
        private bool _peekIsNull = false; // need to cache peek isNull too

        // handle exceptions that occur when reading a value mid-row
        private Exception _rowException;

        DataTable _schemaTable;
#if INDEXINFO        
        DataTable _indexTable;
#endif

        internal SqlDataReader(SqlCommand command) {
            _command = command;
            _dataReady = false;
            _metaDataConsumed = false;
            _hasRows = false;
            _browseModeInfoConsumed = false;
        }

        internal void Bind(TdsParser parser) {
            _parser = parser;
            _defaultLCID = _parser.DefaultLCID;
        }

        //================================================================
        // IEnumerable
        //================================================================

        // hidden interface for IEnumerable
        /// <include file='doc\SqlDataReader.uex' path='docs/doc[@for="SqlDataReader.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return new DbEnumerator((IDataReader)this,  (0 != (CommandBehavior.CloseConnection & _behavior))); // MDAC 68670
        }

        //================================================================
        // IDisposable
        //================================================================
        /// <include file='doc\SqlDataReader.uex' path='docs/doc[@for="SqlDataReader.IDisposable.Dispose"]/*' />
        void IDisposable.Dispose() {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private /*protected override*/ void Dispose(bool disposing) {
            if (disposing) {
                try {
                    this.Close();
                }
                catch (Exception e) {
                    ADP.TraceException(e);
                }
            }
        }

        //================================================================
        // IDataRecord
        //================================================================

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.Depth"]/*' />
        public int Depth {
            get {
                if (this.IsClosed) {
                    throw ADP.DataReaderClosed("Depth");
                }
                
                return 0;
            }
        }

        // fields/attributes collection
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.FieldCount"]/*' />
        public int FieldCount {
            get {
                if (this.IsClosed) {
                    throw ADP.DataReaderClosed("FieldCount");
                }

                if (MetaData == null) {
                    return 0;
                }
                
                return _metaData.Length;
            }
        }

        // field/attributes collection
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetValues"]/*' />
        public int GetValues(object[] values) {
            if (MetaData == null || !_dataReady)
                throw SQL.InvalidRead();
                
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            
            int copyLen = (values.Length < _visibleColumns) ? values.Length : _visibleColumns;

            if (0 != (_behavior & CommandBehavior.SequentialAccess)) {
                for (int i = 0; i < copyLen; i++) {
                    values[_indexMap[i]] = SeqRead(i, false /*useSQLTypes*/, false /*byteAccess*/);
                }
            }
            else {
                PrepareRecord(0);
                for (int i = 0; i < copyLen; i++) {
                	values[i] = _comBuf[i]; // indexMap already calculated in _comBuf
            	}
            }                

            if (null != _rowException)
            	throw _rowException;
            
            return copyLen;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetName"]/*' />
        public string GetName(int i) {
            if (MetaData == null) {
                throw SQL.InvalidRead();
            }
            Debug.Assert(null != _metaData[i].column, "MDAC 66681");
            return _metaData[i].column;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetValue"]/*' />
        public object GetValue(int i) {
            if (MetaData == null)
                throw SQL.InvalidRead();

            return PrepareRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetDataTypeName"]/*' />
        public string GetDataTypeName(int i) {
            if (MetaData == null)
                throw SQL.InvalidRead();

            return _metaData[i].metaType.TypeName;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetFieldType"]/*' />
        public Type GetFieldType(int i) {
            if (MetaData == null)
                throw SQL.InvalidRead();

            return _metaData[i].metaType.ClassType;
        }

        // named field access

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetOrdinal"]/*' />
        public int GetOrdinal(string name) {
            if (null == _fieldNameLookup) {
                if (null == MetaData) {
                    throw SQL.InvalidRead();
                }
                _fieldNameLookup = new FieldNameLookup(this, _defaultLCID);
            }
            return _fieldNameLookup.GetOrdinal(name); // MDAC 71470
        }

        // this operator
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.this"]/*' />
        public object this[int i]
        {
            get {
                return GetValue(i);
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.this1"]/*' />
        public object this[string name]
        {
            get {
                return GetValue(GetOrdinal(name));
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetBoolean"]/*' />
        public bool GetBoolean(int i) {
            return(GetSqlBoolean(i).Value);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetByte"]/*' />
        public byte GetByte(int i) {
            return GetSqlByte(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetBytes"]/*' />
        public long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length) {
            int cbytes = 0;

            if (MetaData == null || !_dataReady)
                throw SQL.InvalidRead();

            // don't allow get bytes on non-long or non-binary columns
            if (!(_metaData[i].metaType.IsLong || MetaType.IsBinType(_metaData[i].metaType.SqlDbType)))
                throw SQL.NonBlobColumn(_metaData[i].column);
                
            // sequential reading
            if (0 != (_behavior & CommandBehavior.SequentialAccess)) {
            
                // reads are non-repeatable.  
                // GetInt32(n);
                // GetInt32(n); // error, already read column 'n'
                // However, the user may call:
                // GetBytes(n); 
                // GetBytes(n); 
                // if the dataIndex is increasing since we haven't read all the bytes.  The index must therefore
                // be exactly (_currCol -1).  If it is not, then we need to move off the column
                if (i != (_currCol - 1)) {
                    _seqBytesLeft = (int) SeqRead(i, true /*SQLTypes*/, true /*bytesAccess*/);
                }
                else if (_peekLength != -1) {
                    _seqBytesLeft = _peekLength;
                    _peekLength = -1;
                }
                
                // if no buffer is passed in, return the number of bytes we have
                if (null == buffer)
                    return _seqBytesLeft;
                
                if (dataIndex < _seqBytesRead) {
                    throw SQL.NonSeqByteAccess(dataIndex, _seqBytesRead, ADP.GetBytes);
                }

                // if the dataIndex is not equal to bytes read, then we have to skip bytes
                long cb = dataIndex - _seqBytesRead;

                // if dataIndex is outside of the data range, return 0
                if (cb > _seqBytesLeft)
                    return 0;

                if (cb > 0) {
                    _parser.SkipBytes(cb);
                    _seqBytesRead += cb;
                    _seqBytesLeft -= cb;
                }

                // read the min(bytesLeft, length) into the user's buffer
                cb = (_seqBytesLeft < length) ? _seqBytesLeft : length;
                _parser.ReadByteArray(buffer, bufferIndex, (int)cb);
                _seqBytesRead += cb;
                _seqBytesLeft -= cb;
                return cb;
            }                

            // random access now!
            // note that since we are caching in an array, and arrays aren't 64 bit ready yet, 
            // we need can cast to int if the dataIndex is in range
            if (dataIndex > Int32.MaxValue) {
            	throw ADP.InvalidSourceBufferIndex(cbytes, dataIndex);
            }

            byte[] data = GetSqlBinary(i).Value;
            int ndataIndex = (int)dataIndex;

            cbytes = data.Length;

            // if no buffer is passed in, return the number of characters we have
            if (null == buffer)
                return cbytes;

            // if dataIndex is outside of data range, return 0
            if (ndataIndex < 0 || ndataIndex >= cbytes)
                return 0;

            try {
                if (ndataIndex < cbytes) {
                    // help the user out in the case where there's less data than requested
                    if ((ndataIndex + length) > cbytes)
                        cbytes = cbytes - ndataIndex;
                    else
                        cbytes = length;
                }

                Array.Copy(data, ndataIndex, buffer, bufferIndex, cbytes);
            }
            catch (Exception e) {
                cbytes = data.Length;

                if (length < 0)
                    throw ADP.InvalidDataLength(length);

                // if bad buffer index, throw
                if (bufferIndex < 0 || bufferIndex >= buffer.Length)
                    throw ADP.InvalidDestinationBufferIndex(buffer.Length, bufferIndex);

                // if there is not enough room in the buffer for data
                if (cbytes + bufferIndex > buffer.Length)
                    throw ADP.InvalidBufferSizeOrIndex(cbytes, bufferIndex);

                throw e;
            }

            return cbytes;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetChar"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Never) ] // MDAC 69508
        public char GetChar(int i) {
            throw ADP.NotSupported();
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetChars"]/*' />
        public long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length) {
            int cchars = 0;
            string s;

            // if the object doesn't contain a char[] then the user will get an exception
            s = GetSqlString(i).Value;

            char[] data = s.ToCharArray();

            cchars = data.Length;

            // note that since we are caching in an array, and arrays aren't 64 bit ready yet, 
            // we need can cast to int if the dataIndex is in range
            if (dataIndex > Int32.MaxValue) {
            	throw ADP.InvalidSourceBufferIndex(cchars, dataIndex);
            }
            int ndataIndex = (int)dataIndex;

            // if no buffer is passed in, return the number of characters we have
            if (null == buffer)
                return cchars;

            // if dataIndex outside of data range, return 0
            if (ndataIndex < 0 || ndataIndex >= cchars)
                return 0;

            try {
                if (ndataIndex < cchars) {
                    // help the user out in the case where there's less data than requested
                    if ((ndataIndex + length) > cchars)
                        cchars = cchars - ndataIndex;
                    else
                        cchars = length;
                }

                Array.Copy(data, ndataIndex, buffer, bufferIndex, cchars);
            }
            catch (Exception e) {
                cchars = data.Length;

                if (length < 0)
                   throw ADP.InvalidDataLength(length);

                // if bad buffer index, throw
                if (bufferIndex < 0 || bufferIndex >= buffer.Length)
                    throw ADP.InvalidDestinationBufferIndex(buffer.Length, bufferIndex);

                // if there is not enough room in the buffer for data
                if (cchars + bufferIndex > buffer.Length)
                    throw ADP.InvalidBufferSizeOrIndex(cchars, bufferIndex);

                throw e;
            }

            return cchars;
        }
        
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetGuid"]/*' />
        public Guid GetGuid(int i) {
            return GetSqlGuid(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetInt16"]/*' />
        public Int16 GetInt16(int i) {
            return GetSqlInt16(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetInt32"]/*' />
        public Int32 GetInt32(int i) {
            return GetSqlInt32(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetInt64"]/*' />
        public Int64 GetInt64(int i) {
            return GetSqlInt64(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetFloat"]/*' />
        public float GetFloat(int i) {
            return GetSqlSingle(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetDouble"]/*' />
        public double GetDouble(int i) {
            return GetSqlDouble(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetString"]/*' />
        public string GetString(int i) {
            return GetSqlString(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetDecimal"]/*' />
        public Decimal GetDecimal(int i) {
            if (MetaData == null)
                throw SQL.InvalidRead();

            SqlDbType t = _metaData[i].type;
            if (t == SqlDbType.Money || t == SqlDbType.SmallMoney)
                return GetSqlMoney(i).Value;
            else
                return GetSqlDecimal(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetDateTime"]/*' />
        public DateTime GetDateTime(int i) {
            return GetSqlDateTime(i).Value;
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetData"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Never) ] // MDAC 69508
        public IDataReader GetData(int i) {
            throw ADP.NotSupported();
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.IsDBNull"]/*' />
        public bool IsDBNull(int i) {
            if (CommandBehavior.SequentialAccess == (_behavior & CommandBehavior.SequentialAccess)) {
                if (!_dataReady)
                    throw SQL.InvalidRead();

                _peekLength = (int) SeqRead(i, true/*useSQLTypes*/, true /*byteAccess*/, out _peekIsNull);
 
                return _peekIsNull;
            }
            else {
                object o = PrepareSQLRecord(i);

                // UNDONE UNDONE - can o ever really equal null?  Is this valid?
                return (o == null) || (o == System.DBNull.Value) || ((INullable)o).IsNull;
            }
        }

        //================================================================
        // ISqlDataRecord
        //================================================================

        //
        // strongly-typed SQLType getters
        //
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlBoolean"]/*' />
        public SqlBoolean GetSqlBoolean(int i) {
            return (SqlBoolean) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlBinary"]/*' />
        public SqlBinary GetSqlBinary(int i) {
            return (SqlBinary) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlByte"]/*' />
        public SqlByte GetSqlByte(int i) {
            return (SqlByte) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlInt16"]/*' />
        public SqlInt16 GetSqlInt16(int i) {
            return (SqlInt16) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlInt32"]/*' />
        public SqlInt32 GetSqlInt32(int i) {
            return (SqlInt32) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlInt64"]/*' />
        public SqlInt64 GetSqlInt64(int i) {
            return (SqlInt64) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlSingle"]/*' />
        public SqlSingle GetSqlSingle(int i) {
            return (SqlSingle) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlDouble"]/*' />
        public SqlDouble GetSqlDouble(int i) {
            return (SqlDouble) PrepareSQLRecord(i);
        }

        // UNDONE: need non-unicode SqlString support
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlString"]/*' />
        public SqlString GetSqlString(int i) {
             return (SqlString) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlMoney"]/*' />
        public SqlMoney GetSqlMoney(int i) {
            return (SqlMoney) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlDecimal"]/*' />
        public SqlDecimal GetSqlDecimal(int i) {
            return (SqlDecimal) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlDateTime"]/*' />
        public SqlDateTime GetSqlDateTime(int i) {
            return (SqlDateTime) PrepareSQLRecord(i);
        }


        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlGuid"]/*' />
        public SqlGuid GetSqlGuid(int i) {
            return (SqlGuid) PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlValue"]/*' />
        public object GetSqlValue(int i) {
            return PrepareSQLRecord(i);
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSqlValues"]/*' />
        public int GetSqlValues(object[] values)
        {
            if (MetaData == null || !_dataReady)
                throw SQL.InvalidRead();
                
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            
            int copyLen = (values.Length < _visibleColumns) ? values.Length : _visibleColumns;
            
            if (0 != (_behavior & CommandBehavior.SequentialAccess)) {
                for (int i = 0; i < copyLen; i++) {
                    values[_indexMap[i]] = SeqRead(i, true /*useSQLTypes*/, false /*byteAccess*/);
                }
            }
            else {
                PrepareSQLRecord(0);
                for (int i = 0; i < copyLen; i++) {
		              values[i] = _sqlBuf[i];
                }
            }
            return copyLen;
        }

        /// <include file='doc\SqlDataReader.uex' path='docs/doc[@for="SqlDataReader.HasRows"]/*' />
        public bool HasRows {
            get {
                if (this.IsClosed) {
                    throw ADP.DataReaderClosed("HasRows");
                }
                    
                return _hasRows;
            }
        }

        //================================================================
        // IDataReader
        //================================================================
        
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.HasMoreRows"]/*' />
        private bool HasMoreRows
        {
            get
            {
                if (null != _parser) {
                    if (_dataReady) {
                        return true;
                    }               
                    if (_parser.PendingData) {
                        byte b = _parser.PeekByte();

                        // simply rip the order token off the wire
                        if (b == TdsEnums.SQLORDER) {
                            _parser.Run(RunBehavior.ReturnImmediately, null, null);
                            b = _parser.PeekByte();
                        }

                        // If row, info, or error return true.  Second case is important so that
                        // error is processed on Read().  Previous bug where Read() would return
                        // false with error on the wire in the case of metadata and error 
                        // immediately following.  See MDAC 78285 and 75225.
                        if (TdsEnums.SQLROW == b || TdsEnums.SQLERROR == b || TdsEnums.SQLINFO == b)
                            return true;

                        // consume dones on HasMoreRows, so user obtains error on Read
                        // UNDONE - re-investigate the need for this while loop
                        // BUGBUG - currently in V1 the if (_parser.PendingData) does not
                        // exist, so under certain conditions HasMoreRows can timeout.  However,
                        // this should only occur when executing as SqlBatch and returning a reader.
                        while (b == TdsEnums.SQLDONE ||
                               b == TdsEnums.SQLDONEPROC ||
                               b == TdsEnums.SQLDONEINPROC) {
                            _parser.Run(RunBehavior.ReturnImmediately, _command, this);
                            if (_parser.PendingData) {
                                b = _parser.PeekByte();
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
                return false;       
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.HasMoreResults"]/*' />
        private bool HasMoreResults
        {
            get
            {
                if (null != _parser) {
                    if (this.HasMoreRows)
                        return true;
        
                    Debug.Assert(null != _command, "unexpected null command from the data reader!");
        
                    while (_parser.PendingData) {
                        byte b = _parser.PeekByte();

                        Debug.Assert(b != TdsEnums.SQLROW, "invalid row token, all rows should have been read off the wire!");

                        if (TdsEnums.SQLCOLMETADATA == b)
                            return true;

                        _parser.Run(RunBehavior.ReturnImmediately, _command);
                    }
                }

                return false;
            }
        }
        
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.IsClosed"]/*' />
        public bool IsClosed {
            get {
                return _isClosed;
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.RecordsAffected"]/*' />
        public int RecordsAffected {
            get {
                if (null != _command)
                    return _command.RecordsAffected;

                // cached locally for after Close() when command is nulled out
                return _recordsAffected;
            }
        }

        // user must call Read() to position on the first row
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.Read"]/*' />
        public bool Read() {
            bool success = false;

            if (null != _parser) {
                if (_dataReady) {
                    CleanPartialRead(_parser);
                }
                // clear out our buffers
                _dataReady = false;
                _sqlBuf = _comBuf = null;
                _currCol = -1;

                if (this.HasMoreRows && !_haltRead) {
                    try {
                        // read the row from the backend
                        while (_parser.PendingData && !_dataReady && this.HasMoreRows) { // MDAC 86750
                            _dataReady = _parser.Run(RunBehavior.ReturnImmediately, _command, this);
                        }
                    }
                    catch (Exception e) {
                        //if (AdapterSwitches.SqlExceptionStack.TraceVerbose)
                        //    Debug.WriteLine(e.StackTrace);
                        throw e;
                    }                   
                    success = _dataReady;

                    if (_dataReady && (CommandBehavior.SingleRow == (_behavior & CommandBehavior.SingleRow))) {
                        _haltRead = true;
                    }
                }

                if ((!success && !_parser.PendingData) && !_haltRead) {
                    InternalClose(false /*closeReader*/);
                }

                // if we did not get a row and halt is true, clean off rows of result
                // success must be false - or else we could have just read off row and set
                // halt to true
                if (!success && _haltRead) {
                    while (this.HasMoreRows) {
                        // if we are in SingleRow mode, and we've read the first row,
                        // read the rest of the rows, if any
                        while (_parser.PendingData && !_dataReady && this.HasMoreRows) { // MDAC 86750
                            _dataReady = _parser.Run(RunBehavior.ReturnImmediately, _command, this);
                        }

                        if (_dataReady) {
                            CleanPartialRead(_parser);
                        }

                        // clear out our buffers
                        _dataReady = false;
                        _sqlBuf = _comBuf = null;
                        _currCol = -1;
                    }

                    // reset haltRead
                    _haltRead = false;
                 }       
            }
            else if (IsClosed) {
                throw SQL.DataReaderClosed("Read");
            }

            return success;             
        }
        
        // recordset is automatically positioned on the first result set
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.NextResult"]/*' />
        public bool NextResult() {
            if (IsClosed) {
                throw ADP.DataReaderClosed("NextResult");
            }

            bool success = false;
            _hasRows = false; // reset HasRows

            // if we are specifically only processing a single result, then read all the results off the wire and detach
            if (CommandBehavior.SingleResult == (_behavior & CommandBehavior.SingleResult)) {
                InternalClose(false /*closeReader*/);

                // In the case of not closing the reader, null out the metadata AFTER
                // InternalClose finishes - since InternalClose may go to the wire
                // and use the metadata.
                SetMetaData(null, false);

                return success;
            }

            if (null != _parser) {
                // if there are more rows, then skip them, the user wants the next result
                while (Read()) {
                    ; // intentional
                }
            }

            // we may be done, so continue only if we have not detached ourselves from the parser
            if (null != _parser) {
                if (this.HasMoreResults) {
                    _metaDataConsumed = false;
                    _browseModeInfoConsumed = false;
                    ConsumeMetaData();
                    success = true;
                }
                else {
                    // detach the parser from this reader now
                    InternalClose(false /*closeReader*/);

                    // In the case of not closing the reader, null out the metadata AFTER
                    // InternalClose finishes - since InternalClose may go to the wire
                    // and use the metadata.
                    SetMetaData(null, false);
                }
            }
            else {
                // Clear state in case of Read calling InternalClose() then user calls NextResult()
                // MDAC 81986.  Or, also the case where the Read() above will do essentially the same
                // thing.
                SetMetaData(null, false);
            }

            return success;
        }

        private void RestoreServerSettings(TdsParser parser) {
            // turn off any set options
            if (null != parser && null != _setOptions) {
                // It is possible for this to be called during connection close on a 
                // broken connection, so check state first.
                if (parser.State == TdsParserState.OpenLoggedIn) {
                    parser.TdsExecuteSQLBatch(_setOptions, (_command != null) ? _command.CommandTimeout : 0);
                    parser.Run(RunBehavior.UntilDone, _command, this);
                }
                _setOptions = null;
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.Close"]/*' />
        public void Close() {
            if (IsClosed)
                return;

            InternalClose(true /*closeReader*/);
        }

#if OBJECT_BINDING
        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.SetObjectBuffer"]/*' />
        public void SetObjectBuffer(object buffer) {
            if (_dataHelper == null)
                _dataHelper = new DataLoaderHelper();

            // warning: ValididateObject throws
            _dataHelper.ValidateObject(buffer, this.MetaData);
            _pfnDataLoader = _dataHelper.BindToObject(buffer, _metaData);
            _objBuffer = buffer;
            _parser.ReadBehavior = ReadBehavior.AsObject;
        }
#endif		

        // clean remainder bytes for the column off the wire
        private void ResetBlobState(TdsParser parser) {
            if (_seqBytesLeft > 0) {
                parser.SkipBytes(_seqBytesLeft);
                _seqBytesLeft = 0;
            }

            _seqBytesRead = 0;
        }

        // wipe any data off the wire from a partial read
        // and reset all pointers for sequential access
        private void CleanPartialRead(TdsParser parser) {
            Debug.Assert(true == _dataReady, "invalid call to CleanPartialRead");

            if (0 == (_behavior & CommandBehavior.SequentialAccess)) {
                if ( (null == _sqlBuf) && (null == _comBuf) ){
                    parser.SkipRow(_metaData);
                }
            }
            else {
                // following cases for sequential read
                // i. user called read but didn't fetch anything
                // iia. user called read and fetched a subset of the columns
                // iib. user called read and fetched a subset of the column data

                // i. user didn't fetch any columns
                if (-1 == _currCol) {
                    parser.SkipRow(_metaData);
                }                        
                else {
                    // iia.  if we still have bytes left from a partially read column, skip
                    ResetBlobState(parser);
                    
                    // iib.
                    // now read the remaining values off the wire for this row
                    parser.SkipRow(_metaData, _currCol);
                }
            }
        }
        
        private void InternalClose(bool closeReader) {
            TdsParser parser = _parser;
            bool closeConnection = (CommandBehavior.CloseConnection == (_behavior & CommandBehavior.CloseConnection));
            _parser = null;

            Exception exception = null;

            try {
                if (parser != null && parser.PendingData) {
                    // It is possible for this to be called during connection close on a 
                    // broken connection, so check state first.
                    if (parser.State == TdsParserState.OpenLoggedIn) {
            	        // if user called read but didn't fetch any values, skip the row
                        if (_dataReady) {
                            CleanPartialRead(parser);
                        }

                        parser.Run(RunBehavior.Clean, _command, this);                    
                    }
                }

                RestoreServerSettings(parser);
            }
            catch (Exception e) {
                ADP.TraceException(e);
                exception = e;
            }

            if (closeReader) {
                if (null != _command && null != _command.Connection) {
                    // cut the reference to the connection
                    _command.Connection.Reader = null;
                }

                SetMetaData(null, false);
                _dataReady = false;
                _isClosed = true;

                // if the user calls ExecuteReader(CommandBehavior.CloseConnection)
                // then we close down the connection when we are done reading results
                if (closeConnection) {
                    if (null != _command && _command.Connection != null) {
                        try {
                            _command.Connection.Close();
                        }
                        catch (Exception e) {
                            ADP.TraceException(e);
                            if (null == exception) {
                                exception = e;
                            }
                        }
                    }
                }

                if (_command != null) {
                    // cache recordsaffected to be returnable after DataReader.Close();
                    _recordsAffected = _command.RecordsAffected;
                }
                
                _command = null; // we are done at this point, don't allow navigation to the connection
            }

            if (null != exception) {
                throw exception;
            } 
        }

        internal void SetMetaData(_SqlMetaData[] metaData, bool moreInfo) {
            _metaData = metaData;

            // get rid of cached metadata info as well
            _tableNames = null;
            _tableNamesShilohSP1 = null;
            _schemaTable = null;
            _sqlBuf = _comBuf = null;
            _fieldNameLookup = null;

#if OBJECT_BINDING          
            _objBuffer = null;
            _pfnDataLoader = null;
#endif          

            if (null != metaData) {
                // we are done consuming metadata only if there is no moreInfo
                if (!moreInfo) {
                    _metaDataConsumed = true;

                    // There is a valid case where parser is null.
                    if (_parser != null) { 
                        // Peek, and if row token present, set _hasRows true since there is a 
                        // row in the result.
                        byte b = _parser.PeekByte();

                        // SQLORDER token can occur between ColMetaData stream and Row stream.
                        // SQLORDER tokens are fully ignored.  If we find one we need to skip it
                        // so that we may appropriately set the HasRows field, prior to any Reads().
                        // There are not any other tokens of concern.  MDAC 84450.
                        if (b == TdsEnums.SQLORDER) {
                            _parser.Run(RunBehavior.ReturnImmediately, null, null);
                            b = _parser.PeekByte(); // Peek another byte.
                        }    

                        _hasRows = (TdsEnums.SQLROW == b);
                    }
                }
            }
            else {
                _metaDataConsumed = false;
            }

            _browseModeInfoConsumed = false;
        }

        internal bool BrowseModeInfoConsumed {
            set {
                _browseModeInfoConsumed = value;
            }
        }

        internal _SqlMetaData[] MetaData {
            get {
                if (IsClosed) {
                    throw ADP.DataReaderClosed("read data");
                }
                // metaData comes in pieces: colmetadata, tabname, colinfo, etc
                // if we have any metaData, return it.  If we have none,
                // then fetch it
                if (_metaData == null && !_metaDataConsumed) {
                    ConsumeMetaData();
                }

                return _metaData;
            }
        }

#if OBJECT_BINDING
        internal DataLoader DataLoader {
            get {
                return _pfnDataLoader;
            }
            set {
                _pfnDataLoader = value;
            }
        }

        internal object RawObjectBuffer {
            get {
                return _objBuffer;
            }
        }
#endif


        private void ConsumeMetaData() {
            // warning:  Don't check the MetaData property within this function
            // warning:  as it will be a reentrant call
            if (_parser != null) {
                while (_parser.PendingData && (!_metaDataConsumed)) {
                    _parser.Run(RunBehavior.ReturnImmediately, _command, this);
                }
            }

            // we hide hidden columns from the user so build an internal map
            // that compacts all hidden columns from the array
            if (null != _metaData) {
                _visibleColumns = 0;
                _indexMap = new int[_metaData.Length];
                for (int i = 0; i < _metaData.Length; i++) {
                    _indexMap[i] = _visibleColumns;

                    if (!(_metaData[i].isHidden)) {
                    	_visibleColumns++;
                    }
                }
            }
        }

        internal string[] TableNames {
            get {
                return _tableNames;
            }
            set {
                _tableNames = value;
            }
        }

        internal string[][] TableNamesShilohSP1 {
            get {
                return _tableNamesShilohSP1;
            }
            set {
                _tableNamesShilohSP1 = value;
            }
        }

        /// <include file='doc\SQLDataReader.uex' path='docs/doc[@for="SqlDataReader.GetSchemaTable"]/*' />
        public DataTable GetSchemaTable() {
            if (null == _schemaTable) {
                if (null != this.MetaData) {
                    _schemaTable = BuildSchemaTable();
                    Debug.Assert(null != _schemaTable, "No schema information yet!");
                    // filter table?
                }
            }
            return _schemaTable;
        }
        
#if INDEXINFO
		// UNDONE: how do we handle multipe results with FillSchema?
        /// <include file='doc\SqlDataReader.uex' path='docs/doc[@for="SqlDataReader.GetIndexTable"]/*' />
        public DataTable GetIndexTable() {
            if (null == _indexTable) {
                if (null != this.MetaData) {
                    if (this.TableNames != null) {
                        _indexTable = BuildIndexTable(this.TableNames[0]);
                    }
                    else if (this.TableNamesShilohSP1 != null) {
                        // have to rebuild full table name
                        string tableName = this.TableNamesShilohSP1[0][0];

                        for (int i=1; i<this.TableNames[0].Length; i++) {
                            tableName = tableName + "." + this.TableNames[0][i];
                        }

                        _indexTable = BuildIndexTable(tableName);
                    }
                    Debug.Assert(null != _schemaTable, "No index information yet!");        			
        	}

        	return _indexTable;
        }

        internal DataTable BuildIndexTable(string table) {
        	SqlDataReader r = null;
        	DataTable indexTable = null;
        	SqlConnection clone = (SqlConnection) ((ICloneable)(_command.Connection)).Clone();
        	SqlCommand cmd = new SqlCommand(TdsEnums.SP_INDEXES, clone);
        	cmd.CommandType = CommandType.StoredProcedure;
        	SqlParameter p = cmd.Parameters.Add("@table_name", SqlDbType.NVarChar, 255);
        	p.Value = table;
        	
        	try {
        		clone.Open();
        		r = cmd.ExecuteReader();

        		
			    indexTable = new DataTable("IndexTable");
			    DataColumnCollection columns    = indexTable.Columns;
            
        	    columns.Add(new DataColumn("IndexName", typeof(System.String))); // 0
            	columns.Add(new DataColumn("Primary", typeof(System.Boolean)));// 1
	            columns.Add(new DataColumn("Unique", typeof(System.Boolean)));// 2
    	        columns.Add(new DataColumn("ColumnName", typeof(System.String))); // 3

        		while (r.Read()) {
        			// we only care about unique or primary indexes
        			bool primary = (bool) r["PRIMARY_KEY"];
        			bool unique = (bool) r["UNIQUE"];

        			if (primary || unique) {
        				DataRow row = indexTable.NewRow();
						row[0] = (string) r["INDEX_NAME"];
						row[1] = primary;
						row[2] = unique;
						row[3] = (string) r["COLUMN_NAME"];
						indexTable.Rows.Add(row);
						row.AcceptChanges();
        			}
        		}
        	}
        	finally {
				if (r != null)
					r.Close();

				if (clone != null)
					clone.Close();
        	}

        	return indexTable;
        }
#endif
        // Fills in a schema table with meta data information.  This function should only really be called by
        // UNDONE: need a way to refresh the table with more information as more data comes online for browse info like
        // table names and key information
        internal DataTable BuildSchemaTable() {
            _SqlMetaData[] md = this.MetaData;
            Debug.Assert(null != md, "BuildSchemaTable - unexpected null metadata information");
            DataTable schemaTable = ADP.CreateSchemaTable(null, md.Length);
            DBSchemaTable dbSchemaTable = new DBSchemaTable(schemaTable);

            for (int i = 0; i < md.Length; i++) {
                _SqlMetaData col = md[i];

                DBSchemaRow schemaRow = dbSchemaTable.NewRow();

                schemaRow.ColumnName = col.column;
                schemaRow.Ordinal = col.ordinal;
                //
                // be sure to return character count for string types, byte count otherwise
                // col.length is always byte count so for unicode types, half the length
                //
                schemaRow.Size = (MetaType.IsSizeInCharacters(col.type)) ? (col.length / 2) : col.length;
                schemaRow.ProviderType = (int) col.type; // SqlDbType
                schemaRow.DataType = col.metaType.ClassType; // com+ type

                if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.precision) {
                    schemaRow.Precision = col.precision;
                }
                else {
                    schemaRow.Precision = col.metaType.Precision;
                }
                
                if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale) {
                    schemaRow.Scale = col.scale;
                }
                else {
                    schemaRow.Scale = col.metaType.Scale;
                }
                
                schemaRow.AllowDBNull = col.isNullable;

                // If no ColInfo token received, do not set value, leave as null.  
                if (_browseModeInfoConsumed) {
                    schemaRow.IsAliased    = col.isDifferentName;
                    schemaRow.IsKey        = col.isKey;
                    schemaRow.IsHidden     = col.isHidden;
                    schemaRow.IsExpression = col.isExpression;
                }

                schemaRow.IsIdentity = col.isIdentity;
                schemaRow.IsAutoIncrement = col.isIdentity;
                schemaRow.IsLong = col.metaType.IsLong;

                // mark unique for timestamp columns
                if (SqlDbType.Timestamp == col.type) {
                    schemaRow.IsUnique = true;
                    schemaRow.IsRowVersion = true;
                }
                else {
                    schemaRow.IsUnique = false;
                    schemaRow.IsRowVersion = false;
                }                    

                schemaRow.IsReadOnly = (0 == col.updatability);

                if (!ADP.IsEmpty(col.serverName)) {
                    schemaRow.BaseServerName = col.serverName;
                }
                if (!ADP.IsEmpty(col.catalogName)) {
                    schemaRow.BaseCatalogName = col.catalogName;
                }
                if (!ADP.IsEmpty(col.schemaName)) {
                    schemaRow.BaseSchemaName = col.schemaName;
                }
                if (!ADP.IsEmpty(col.tableName)) {
                    schemaRow.BaseTableName = col.tableName;
                }
                if (!ADP.IsEmpty(col.baseColumn)) {
                    schemaRow.BaseColumnName = col.baseColumn;
                }
                else if (!ADP.IsEmpty(col.column)) {
                    schemaRow.BaseColumnName = col.column;
                }
                dbSchemaTable.AddRow(schemaRow);
            }

            DataColumnCollection columns = schemaTable.Columns;
            for (int i=0; i < columns.Count; i++) {
                columns[i].ReadOnly = true;
            }

            return schemaTable;
        }

        private object PrepareRecord(int i) {
            if (!_dataReady)
                throw SQL.InvalidRead();

            // fastest case:  random access, data already fetched for the row 
            if (null != _comBuf) // data is already buffered as the user likes it
                return _comBuf[i];

            // check for sequential access
            if (0 != (_behavior & CommandBehavior.SequentialAccess)) {
                return SeqRead(i, false/*useSQLtypes*/, false /*byteAccess*/);
            }

            // user fetched as com type and now wants a sql type
            if (null != _sqlBuf) {
                SqlBufferToComBuffer();
                return _comBuf[i];
            }

            // no buffer exists
            _comBuf = new Object[_metaData.Length];
            _parser.ProcessRow(_metaData, _comBuf, _indexMap, false /* don't use sql types */);
            return _comBuf[i];
        }

        private object SeqRead(int i, bool useSQLTypes, bool byteAccess) {
            bool isNull;
            return SeqRead(i, useSQLTypes, byteAccess, out isNull);
        }

        private object SeqRead(int i, bool useSQLTypes, bool byteAccess, out bool isNull) {
            object val;
            isNull = false;
            int len = 0;
            bool cached = false;
            
            _SqlMetaData mdCol = _metaData[i];
            
            // sequential access order: allow sequential, non-repeatable reads
            // if we specify a column that we've already read, error
            if (i < _currCol) {
                if (_peekLength != -1 && (i == _currCol - 1)) {
                    // null out peek value on second access, so as to not allow further access
                    len = _peekLength;
                    isNull = _peekIsNull;
                    cached = true;
                }
                else {
                    throw SQL.NonSequentialColumnAccess(i, _currCol); 
                }
            }

            _peekLength = -1;

            // if we still have bytes left from the previous blob read, clear the wire
            // and reset
            ResetBlobState(_parser);

            while (i > _currCol) {
                if (_currCol > -1) {
                    _parser.SkipBytes(_parser.ProcessColumnHeader(_metaData[_currCol], ref isNull));
                }                        
                _currCol++;
            }

            if (!cached) {
                Debug.Assert(i == _currCol, "current column read is invalid");
                len = _parser.ProcessColumnHeader(mdCol, ref isNull);
            }

            // if we are reading as bytes (GetBytes() access) then return the length instead of the value 
            // this will allow the user to stream the contents over the wire, without caching in the reader
            if (byteAccess) {
                // undone: 64 bit -> when TDS puts in 8 byte lengths, we need to return an Int64 value here
                val = len;
            }
            else {
                if (isNull) {
                    val = useSQLTypes ? _parser.GetNullSqlValue(mdCol) : DBNull.Value;
                }
                else {
                    try {
                        val = useSQLTypes ? _parser.ReadSqlValue(mdCol, len) : _parser.ReadValue(mdCol, len);
                    }
                    catch(_ValueException ve) {
                        // put ths truncated value into val
                        val = ve.value;
                        // remember this exception, this may be overwritten
                        _rowException = ve.exception;
                    }
                }
            }

            if (!cached) {
                // remember reads are non-repeatable, so prevent the user from accessing this column ordinal twice in a row
                _currCol++;
            }
            
            return val;
        }
        
        private object PrepareSQLRecord(int i) {
            if (!_dataReady)
                throw SQL.InvalidRead();

            // fastest case: random access, data already fetched for the row
            if (null != _sqlBuf) {
                // data is already buffered as the user likes it, simply return the value
                return _sqlBuf[i];
            }
            
            // now check for sequential read    
            if (0 != (_behavior & CommandBehavior.SequentialAccess)) {
                return SeqRead(i, true/*useSQLTypes*/, false /*byteAccess*/);
            }

            // user fetched as a com type, and now wants a sql type
            if (null != _comBuf) {
                // data is buffered as com types, copy over to sql types
                ComBufferToSqlBuffer();
                return _sqlBuf[i];
            }
            
            // first read on this row
            _sqlBuf = new object[_metaData.Length];
            _parser.ProcessRow(_metaData, _sqlBuf, _indexMap, true /* use sql types */);
            return _sqlBuf[i];
        }

        private void ComBufferToSqlBuffer() {
            Debug.Assert(_sqlBuf == null && _comBuf != null, "invalid call to ComBufferToSqlBuffer");
            Debug.Assert(_comBuf.Length == _metaData.Length, "invalid buffer length!");
            object[] buffer = new object[_comBuf.Length];
            for (int i = 0; i < _metaData.Length; i++) {
                buffer[i] = MetaType.GetSqlValue(_metaData[i], _comBuf[i]);
            }
            _sqlBuf = buffer;

        }

        private void SqlBufferToComBuffer() {
            Debug.Assert(_sqlBuf != null && _comBuf == null, "invalid call to SqlBufferToComBuffer");
            Debug.Assert(_sqlBuf.Length == _metaData.Length, "invalid buffer length!");
            object[] buffer = new object[_sqlBuf.Length];
            for (int i = 0; i < _metaData.Length; i++) {
                buffer[i] = MetaType.GetComValue(_metaData[i].type, _sqlBuf[i]);
            }
            _comBuf= buffer;
        }

        internal string SetOptionsOFF {
            set {
                _setOptions = value;
            }
        }

        internal CommandBehavior Behavior{
            set {
                _behavior = value;
            }
        }
    }// SqlDataReader
}// namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
#if SQL_RECORD
namespace System.Data.Common {
    using System;
    using System.Data;
    using System.Data.SqlClient;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    

    /// <include file='doc\SqlEnumerator.uex' path='docs/doc[@for="SqlEnumerator"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    sealed public class SqlEnumerator : DbEnumerator {
        private object[] _sqlValues;

        internal SqlEnumerator(IDataReader reader) : base(reader) {
        }
        
        override internal IDataRecord NewRecord(SchemaInfo[] si, object[] comValues, PropertyDescriptorCollection descriptors) {
            Debug.Assert(_sqlValues != null && comValues != null, "invalid call to NewRecord() with null buffers!");
            return new SqlRecord(si, _sqlValues, comValues, descriptors);
        }            

        override internal void GetValues(object[] values) {
            // this is totally gross, but we are going to keep two copies of the data here: com and sql types
            // consider: defer doing this until someone asks for non-sql data
            // consider: problem is that XSP binds to this using com+ types
            _sqlValues = new object[values.Length];
            ((SqlDataReader)_reader).GetSqlValues(_sqlValues);
            base.GetValues(values);
        }
    }
}
#endif //SQL_RECORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlerror.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    using System;
    using System.Globalization;

    /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Collects information relevant to a warning or error returned by SQL Server.
    ///    </para>
    /// </devdoc>
    [Serializable]
    sealed public class SqlError {

        // bug fix - MDAC 48965 - missing source of exception
        // fixed by BlaineD
        private string source = TdsEnums.SQL_PROVIDER_NAME;
        private int    number;
        private byte   state;
        private byte   errorClass;
        private string message;
        private string procedure;
        private int    lineNumber;

        internal SqlError(int infoNumber, byte errorState, byte errorClass, string errorMessage, string procedure, int lineNumber) {
            this.number = infoNumber;
            this.state = errorState;
            this.errorClass = errorClass;
            this.message = errorMessage;
            this.procedure = procedure;
            this.lineNumber = lineNumber;
        }

        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the entire text of the <see cref='System.Data.SqlClient.SqlError'/>.
        ///    </para>
        /// </devdoc>
        // bug fix - MDAC #49280 - SqlError does not implement ToString();
        // I did not include an exception stack because the correct exception stack is only available 
        // on SqlException, and to obtain that the SqlError would have to have backpointers all the
        // way back to SqlException.  If the user needs a call stack, they can obtain it on SqlException.
        public override string ToString() {
            //return this.GetType().ToString() + ": " + this.message;
            return typeof(SqlError).ToString() + ": " + this.message; // since this is sealed so we can change GetType to typeof
        }

        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Source"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the line of source code that generated the error.
        ///    </para>
        /// </devdoc>
        // bug fix - MDAC #48965 - missing source of exception
        // fixed by BlaineD
        public string Source {
            get { return this.source;}
        }

        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Number"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the error code
        ///       returned from the SQL Server adapter.
        ///    </para>
        /// </devdoc>
        public int Number {
            get { return this.number;}
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.State"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       error state number returned from the SQL Server adapter.
        ///    </para>
        /// </devdoc>
        public byte State {
            get { return this.state;}
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Class"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the severity level of
        ///       the error returned from the SQL Server adapter.
        ///    </para>
        /// </devdoc>
        public byte Class {
            get { return this.errorClass;}
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of
        ///       the database server the error occurred on.
        ///    </para>
        /// </devdoc>
        public string Server {
            get { return ""; }
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Message"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the error message
        ///       that was
        ///       generated from the SQL Server adapter.
        ///    </para>
        /// </devdoc>
        public string Message {
            get { return this.message;}
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.Procedure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the
        ///       name
        ///       of the procedure that the SQL Server error occurred in.
        ///    </para>
        /// </devdoc>
        public string Procedure {
            get { return this.procedure;}
        }
        /// <include file='doc\SQLError.uex' path='docs/doc[@for="SqlError.LineNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the line number that the SQL Server error occurred on.
        ///    </para>
        /// </devdoc>
        public int LineNumber {
            get { return this.lineNumber;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Runtime.Serialization;
    using System.Text; // StringBuilder

    /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException"]/*' />
    [Serializable]
    sealed public class SqlException : SystemException {
        private SqlErrorCollection _errors;

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.SqlException"]/*' />
        internal SqlException() : base () {
                HResult = HResults.Sql;
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private SqlException(SerializationInfo si, StreamingContext sc) : base() {
            _errors = (SqlErrorCollection) si.GetValue("Errors", typeof(SqlErrorCollection));
            HResult = HResults.Sql;
        }

        /// <include file='doc\SqlException.uex' path='docs/doc[@for="SqlException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        override public void GetObjectData(SerializationInfo si, StreamingContext context) {
            if (null == si) {
                throw new ArgumentNullException("si");
            }
            si.AddValue("Errors", _errors, typeof(SqlErrorCollection));
            base.GetObjectData(si, context);
        }
        
        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Errors"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content)
        ]
        public SqlErrorCollection Errors {
            get {
                if (_errors == null) {
                    _errors = new SqlErrorCollection();
                }
                return _errors;
            }
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SQLException.ShouldSerializeErrors"]/*' />
        /*virtual protected*/private bool ShouldSerializeErrors() { // MDAC 65548
            return ((null != _errors) && (0 < _errors.Count));
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Class"]/*' />
        public byte Class {
            get { return this.Errors[0].Class;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.LineNumber"]/*' />
        public int LineNumber {
            get { return this.Errors[0].LineNumber;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Message"]/*' />
        override public string Message {
        	get {
	        	// concat all messages together MDAC 65533
    	       	StringBuilder message = new StringBuilder(); 
        		for (int i = 0; i < this.Errors.Count; i++) {
	        		if (i > 0) {
    	    			message.Append("\r\n");
        			}        			
        			message.Append(this.Errors[i].Message);
        		}
        		return message.ToString();
        	}        		
        }
        
        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Number"]/*' />
        public int Number {
            get { return this.Errors[0].Number;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Procedure"]/*' />
        public string Procedure {
            get { return this.Errors[0].Procedure;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Server"]/*' />
        public string Server {
            get { return this.Errors[0].Server;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.State"]/*' />
        public byte State {
            get { return this.Errors[0].State;}
        }

        /// <include file='doc\SQLException.uex' path='docs/doc[@for="SqlException.Source"]/*' />
        override public string Source {
            get { return this.Errors[0].Source;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlerrorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlErrorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection"]/*' />
    [Serializable, ListBindable(false)]
    sealed public class SqlErrorCollection : ICollection {

        private ArrayList errors = new ArrayList();

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.SqlErrorCollection"]/*' />
        internal SqlErrorCollection() {
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.CopyTo"]/*' />
        public void CopyTo (Array array, int index) {
            this.errors.CopyTo(array, index);
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.Count"]/*' />
        public int Count {
            get { return this.errors.Count;}
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.SyncRoot"]/*' />
        object System.Collections.ICollection.SyncRoot { // MDAC 68481
            get { return this;}
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.IsSynchronized"]/*' />
        bool System.Collections.ICollection.IsSynchronized { // MDAC 68481
            get { return false;}
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.this"]/*' />
        public SqlError this[int index] {
            get {
                return (SqlError) this.errors[index];
            }
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return errors.GetEnumerator();
        }

        /// <include file='doc\SqlErrorCollection.uex' path='docs/doc[@for="SqlErrorCollection.Add"]/*' />
        internal void Add(SqlError error) {
            this.errors.Add(error);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration.Assemblies;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection"]/*' />
    [
    DefaultEvent("InfoMessage")
    ]
    sealed public class SqlConnection : Component, IDbConnection, ICloneable {

        // execpt for SqlConnection.Open ConnectionString, only demand for the existance of SqlClientPermission
        // during SqlCommand.ExecuteXXX and SqlConnection.ChangeDatabase
        static internal System.Data.SqlClient.SqlClientPermission _SqlClientPermission;

        internal static System.Data.SqlClient.SqlClientPermission SqlClientPermission {
            get {
                SqlClientPermission permission = _SqlClientPermission;
                if (null == permission) {
                    permission = new SqlClientPermission(PermissionState.None);
                    permission.Add("", "", KeyRestrictionBehavior.AllowOnly); // ExecuteOnly permission
                    _SqlClientPermission = permission;
                }
                return permission;
            }
        }

        // STRINGS AND CONNECTION OPTIONS
        private SqlConnectionString _constr;
        private bool                _hidePasswordPwd;

        // FLAGS
        private  bool                       _fIsClosing;       // the con is closing

        // OTHER STATE VARIABLES AND REFERENCES
        private  SqlInternalConnection      _internalConnection;
        private  WeakReference              _reader;
        private  WeakReference              _localTransaction;
        private  ConnectionState            _objectState;
        private  StateChangeEventHandler    _stateChangeEventHandler;
        internal SqlInfoMessageEventHandler _infoMessageEventHandler;

        // don't use a SqlCommands collection because this is an internal tracking list.  That is, we don't want
        // the command to "know" it's in a collection.
        private ArrayList _preparedCommands;

        // SQL Debugging support
        private SqlDebugContext _sdc;

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.SqlConnection"]/*' />
        public SqlConnection() {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.SqlConnection1"]/*' />
        public SqlConnection(string connectionString) {
            GC.SuppressFinalize(this);
            ConnectionString = connectionString;
        }

        private SqlConnection(SqlConnection connection) : base() { // Clone
            GC.SuppressFinalize(this);
            _hidePasswordPwd = connection._hidePasswordPwd;
            _constr = connection._constr;
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ConnectionString"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        RefreshProperties(RefreshProperties.All),
        RecommendedAsConfigurable(true),
        DataSysDescription(Res.SqlConnection_ConnectionString),
        Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlConnectionStringEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public string ConnectionString {
            get {
                bool hidePasswordPwd = _hidePasswordPwd;
                SqlConnectionString constr = _constr;
                return ((null != constr) ? constr.GetConnectionString(hidePasswordPwd) : ADP.StrEmpty);
            }
            set {
                SqlConnectionString constr = SqlConnectionString.ParseString(value);
                switch (_objectState) {
                case ConnectionState.Closed:
                    _constr = constr;
                    _hidePasswordPwd = false;
                    break;
                case ConnectionState.Open:
                    throw ADP.OpenConnectionPropertySet(ADP.ConnectionString, State);
                default:
                    Debug.Assert(false, "Invalid Connection State in SqlConnection.ConnectionString Get/Set");
                    break;
                }
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ConnectionTimeout"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_ConnectionTimeout)
        ]
        public int ConnectionTimeout {
            get {
                return GetOptions().ConnectTimeout;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.Database"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_Database)
        ]
        public string Database {
            get {
                // if the connection is open, we need to send a message to the server to change databases!
                return GetOptions().InitialCatalog;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.DataSource"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_DataSource)
        ]
        public string DataSource {
            get {
                return GetOptions().DataSource;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.PacketSize"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_PacketSize)
        ]
        public int PacketSize {
            get {
                return GetOptions().PacketSize;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.WorkstationId"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_WorkstationId)
        ]
        public string WorkstationId {
            get {
                (new EnvironmentPermission(PermissionState.Unrestricted)).Demand();

                // Check to see if we've obtained the value yet.  If not, we'll obtain it.
                // We do this because if the connection is constructed with the default
                // constructor the workstation id is not obtained (workstation id normally
                // obtained at parse time).  However, we want to have the value for this
                // property if the user calls it before setting the string.  So, we will
                // delay obtaining the workstation until this property is obtained or the
                // string is parsed.
                return GetOptions().CheckObtainWorkstationId(true);
            }
        }

        //
        // OTHER PUBLIC PROPERTIES
        //

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.InfoMessage"]/*' />
        [
        DataCategory(Res.DataCategory_InfoMessage),
        DataSysDescription(Res.DbConnection_InfoMessage)
        ]
        public event SqlInfoMessageEventHandler InfoMessage {
            add {
                _infoMessageEventHandler += value;
            }
            remove {
                _infoMessageEventHandler -= value;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ServerVersion"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.SqlConnection_ServerVersion)
        ]
        public string ServerVersion {
            get {
                switch (_objectState) {
                    case ConnectionState.Open:
                        return _internalConnection.ServerVersion;
                    case ConnectionState.Closed:
                        throw ADP.ClosedConnectionError();
                    default:
                        Debug.Assert(false, "Invalid Connection State in SqlConnection.Open()");
                        return null;
                }
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.State"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DbConnection_State)
        ]
        public ConnectionState State {
            get {
                return _objectState;
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.StateChange"]/*' />
        [
        DataCategory(Res.DataCategory_StateChange),
        DataSysDescription(Res.DbConnection_StateChange)
        ]
        public event StateChangeEventHandler StateChange {
            add {
                _stateChangeEventHandler += value;
            }
            remove {
                _stateChangeEventHandler -= value;
            }
        }

        //
        // INTERNAL PROPERTIES
        //

        internal bool IsClosing {
            get { return _fIsClosing;}
        }

        internal bool IsShiloh {
            get {
                Debug.Assert(_internalConnection != null, "Invalid call to IsShiloh before login!");
                return _internalConnection.IsShiloh;
            }
        }

        internal SqlTransaction LocalTransaction {
            get {
                if (null != _localTransaction) {
                    SqlTransaction transaction = (SqlTransaction) _localTransaction.Target;
                    if (null != transaction && _localTransaction.IsAlive) {
                        return transaction;
                    }
                }
                return null;
             }
            set {
                _localTransaction = null;

                if (null != value) {
                    // Can _internalConnection ever be null at this point?
                    Debug.Assert(_internalConnection != null, "internalConnection was unexpectedly null!");
                    if (_internalConnection != null) {
                        _internalConnection.InLocalTransaction = true;
                    }

                    _localTransaction = new WeakReference(value);
                }
                else {
                    // Can _internalConnection ever be null at this point?
                    Debug.Assert(_internalConnection != null, "internalConnection was unexpectedly null!");
                    if (_internalConnection != null) {
                        _internalConnection.InLocalTransaction = false;
                    }
                }
            }
        }

        internal TdsParser Parser {
            get {
                if (null != _internalConnection) {
                    return _internalConnection.Parser;
                }
                else {
                    return null;
                }
            }
        }

        internal SqlDataReader Reader {
            get {
                if (null != _reader) {
                    SqlDataReader reader = (SqlDataReader) _reader.Target;
                    if (null != reader && _reader.IsAlive) {
                        return reader;
                    }
                }
                return null;
            }
            set {
                _reader = null;
                if (null != value) {
                    _reader = new WeakReference(value);
                }
            }
        }

        private SqlConnectionString GetOptions() {
            SqlInternalConnection cnc = _internalConnection;
            if (null != cnc) {
                return cnc.ConnectionOptions;
            }

            SqlConnectionString constr = _constr;
            if (null == constr) {
                constr = SqlConnectionString.Default;
                _constr = constr;
            }
            return constr;
        }

        //
        // PUBLIC METHODS
        //
        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.Open"]/*' />
        public void Open() {
            SqlConnectionString constr = _constr;
            SqlConnectionString.Demand(constr); // MDAC 62038

            switch (_objectState) {
            case ConnectionState.Closed:
                if ((null == constr) || constr.IsEmpty()) {
                    throw ADP.NoConnectionString();
                }

                // used for pooling only
                bool isInTransaction = false;
                bool pooled          = constr.Pooling;
                bool isopened        = false;

                try {
                    try {
                        if (pooled) {
                            // use HiddenConnectionString, if UDL pooling is off - ConnectionString may always be the same while HiddenConnectionString varies
                            _internalConnection = SqlConnectionPoolManager.GetPooledConnection(constr, out isInTransaction);

                            // set backpointer for parser callbacks
                            if (_internalConnection.ConnectionWeakRef != null) {
                                _internalConnection.ConnectionWeakRef.Target = this;
                            }
                            else {
                                _internalConnection.ConnectionWeakRef = new WeakReference(this);
                            }

                            // only set InPool to true after WeakReference is properly set
                            _internalConnection.InPool = false;
                        }
                        else {
                            constr = constr.Clone();

                            // cache a clone of pre-login connection options - since internal connection simply points at SqlConnection's
                            // hashtable
                            _internalConnection = new SqlInternalConnection(this, constr);
                        }
                        Debug.Assert(null != _internalConnection, "InternalConnection null on Open");

                        _objectState = ConnectionState.Open; // be sure to mark as open so SqlDebugCheck can issue Query

                        // check to see if we need to hook up sql-debugging if a debugger is attached
                        if (System.Diagnostics.Debugger.IsAttached) {
                            OpenWithDebugger();
                        }

                        if (pooled) {
                            _internalConnection.Activate(isInTransaction);
                        }
                        _hidePasswordPwd = true;
                        isopened = true;
                    }
                    finally {
                        if (!isopened) {
                            OpenFailure(constr);
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }

                // fire after try/catch - since user code can throw
                FireObjectState(ConnectionState.Closed, ConnectionState.Open);
                break;
            case ConnectionState.Open:
                throw ADP.ConnectionAlreadyOpen(_objectState);
            default:
                Debug.Assert(false, "Invalid Connection State in SqlConnection.Open()");
                break;
            }
        }

        private void OpenWithDebugger() {
            bool debugCheck = false;
            try {
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand(); // MDAC 66682, 69017
                //NamedPermissionSet fulltrust = new NamedPermissionSet("FullTrust"); // M84404
                //fulltrust.Demand();
                debugCheck = true;
            }
            catch(SecurityException e) {
                ADP.TraceException(e);
            }
            if (debugCheck) {
                // if we don't have Unmanaged code permission, don't check for debugging
                // but let the connection be opened while under the debugger
                CheckSQLDebugOnConnect();
            }
        }

        private void OpenFailure(SqlConnectionString constr) {
            // PerfCounters
            SQL.IncrementFailedConnectCount();

            SqlInternalConnection inco = _internalConnection;
            _internalConnection = null;
            _objectState = ConnectionState.Closed;

            if (inco != null) {
                // if pooled, return to pool for destruction - it will be
                // destroyed since if an error occurred it will be marked
                // as unusable
                if (constr.Pooling) { // MDAC 69009
                    SqlConnectionPoolManager.ReturnPooledConnection(inco);
                }
                else {
                    inco.Close();
                }
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.Close"]/*' />
        public void Close() {
            switch (_objectState) {
                case ConnectionState.Closed:
                    break;
                case ConnectionState.Open:
                    // bug fix - MDAC #49219 - this assert was outside of the switch and firing in cases
                    // which it was not intended to fire.  It also included a check that the state was
                    // not closed - which is bogus.  This is the proper location and content of the assert
                    Debug.Assert(_internalConnection != null, "Cannot close connection when InternalConnection is null!");

                    // Can close the connection if it is open - this is possible re-entrant call!
                    // Clean off the wire before going back to pool, and close a pending reader if we have one.
                    CloseReader();

                    // CloseReader may have called close, so check ConnectionState again.
                    if (ConnectionState.Open == _objectState) {
                        try {
                            try {
                                _fIsClosing = true;

                                //
                                // be sure to unprepare all prepared commands
                                //
                                if (null != _preparedCommands) {
                                    // note that unpreparing a command will cause the command object to call RemovePreparedCommand
                                    // on this connection.  This means that the array will be compacted as you iterate through it!
                                    while (_preparedCommands.Count > 0) {
                                        SqlCommand cmd = (SqlCommand) _preparedCommands[0];
                                        if (cmd.IsPrepared) {
                                            // Unprepare will not go to parser if it is broken or closed.
                                            cmd.Unprepare();
                                        }
                                    }

                                    Debug.Assert(0 == _preparedCommands.Count, "should have no prepared commands left!");
                                    _preparedCommands = null;
                                }

                                if (_internalConnection.IsPooled ) {
                                    Debug.Assert(_internalConnection.Pool != null, "Pool null on Close()");
                                    try {
                                        if (_internalConnection.Parser.State != TdsParserState.Broken &&
                                            _internalConnection.Parser.State != TdsParserState.Closed) {
                                            if (null != this.LocalTransaction) {
                                                this.LocalTransaction.Rollback();
                                            }
                                            else {
                                                this.RollbackDeadTransaction();
                                            }
                                        }
                                        else if (null != this.LocalTransaction) {
                                            // Zombie transaction object in the case where connection is
                                            // closed on Open but there is an ongoing transaction.
                                            this.LocalTransaction.Zombie();
                                        }
                                    }
                                    catch (Exception) {
                                        // if an exception occurred, the inner connection will be
                                        // marked as unusable and destroyed upon returning to the
                                        // pool
                                    }
                                    try {
                                        if (_sdc != null) {
                                            try {
                                                _internalConnection.Close();
                                            } finally {
                                                _sdc.Dispose();
                                            }
                                        }
                                    } 
                                    finally {
                                        if (_sdc == null) {  //MDAC 84497
                                            Debug.Assert(this == _internalConnection.ConnectionWeakRef.Target, "Upon Close SqlInternalConnection's parent doesn't match the current SqlConnection!");
                                            if (this != _internalConnection.ConnectionWeakRef.Target) {
                                                throw SQL.ConnectionPoolingError();
                                            }
                                            SqlConnectionPoolManager.ReturnPooledConnection(_internalConnection);
                                         }
                                        _sdc = null;
                                        _internalConnection = null;
                                        _fIsClosing = false;
                                    }
                                }
                                else {
                                    try {
                                        if (_sdc != null) {
                                            _sdc.Dispose();
                                            _sdc = null;
                                        }

                                        if (null != this.LocalTransaction) {
                                            this.LocalTransaction.Zombie();
                                        }
                                        _internalConnection.Close(); // this and state fire should be only possible failures
                                        _internalConnection = null;
                                        _fIsClosing = false;
                                    }
                                    catch {
                                        // In case we received an exception from the close - we have a bad connection so we had
                                        // better reset the variables to a closed connection.
                                        _internalConnection = null;
                                        _fIsClosing = false;
                                        throw;
                                    }
                                }
                            }
                            finally { // _objectState=
                                _objectState = ConnectionState.Closed;
                            }
                        }
                        catch { // MDAC 80973
                            throw;
                        }
                        FireObjectState(ConnectionState.Open, ConnectionState.Closed);
                    }

                    break;
                default:
                    Debug.Assert(false, "Invalid Connection State in SqlConnection.Close(ConnectionReset)");
                    break;
            }
        }

        //
        // PUBLIC TRANSACTION METHODS
        //

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.BeginTransaction"]/*' />
        public SqlTransaction BeginTransaction() {
            return this.BeginTransaction(IsolationLevel.ReadCommitted);
        }

        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.IDbConnection.BeginTransaction"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction() {
            return this.BeginTransaction();
        }

#if V2
        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.ISqlConnection.BeginTransaction"]/*' />
        /// <internalonly/>
        ISqlTransaction ISqlConnection.BeginTransaction() {
            return this.BeginTransaction();
        }
#endif


        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.BeginTransaction1"]/*' />
        public SqlTransaction BeginTransaction(IsolationLevel iso) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476

            if (ConnectionState.Closed == this._objectState)
                throw ADP.ClosedConnectionError();

            Debug.Assert(this._objectState == ConnectionState.Open, "Invalid ConnectionState in BeginTransaction");

            this.CloseDeadReader();
            this.RollbackDeadTransaction();

            // The LocalTransaction check will also rollback a released transaction.
            if (this.LocalTransaction != null)
                throw ADP.ParallelTransactionsNotSupported(this);

            string sqlBatch = null;
            switch (iso) {
                case IsolationLevel.ReadCommitted:
                    sqlBatch = TdsEnums.TRANS_READ_COMMITTED;
                    break;
                case IsolationLevel.ReadUncommitted:
                    sqlBatch = TdsEnums.TRANS_READ_UNCOMMITTED;
                    break;
                case IsolationLevel.RepeatableRead:
                    sqlBatch = TdsEnums.TRANS_REPEATABLE_READ;
                    break;
                case IsolationLevel.Serializable:
                    sqlBatch = TdsEnums.TRANS_SERIALIZABLE;
                    break;
                default:
                    throw SQL.InvalidIsolationLevelPropertyArg();
            }
            _internalConnection.ExecuteTransaction(sqlBatch + ";" + TdsEnums.TRANS_BEGIN, ADP.BeginTransaction);

            return new SqlTransaction(this, iso);
        }

        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.IDbConnection.BeginTransaction1"]/*' />
        /// <internalonly/>
        IDbTransaction IDbConnection.BeginTransaction(IsolationLevel iso) {
            return this.BeginTransaction(iso);
        }

#if V2
        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.ISqlConnection.BeginTransaction1"]/*' />
        /// <internalonly/>
        ISqlTransaction ISqlConnection.BeginTransaction(IsolationLevel iso) {
            return this.BeginTransaction(iso);
        }
#endif


        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.BeginTransaction2"]/*' />
        public SqlTransaction BeginTransaction(string transactionName) {
            // Use transaction names only on the outermost pair of nested BEGIN...COMMIT or BEGIN...ROLLBACK
            // statements.  Transaction names are ignored for nested BEGIN's.  The only way to rollback a
            // nested transaction is to have a save point from a SAVE TRANSACTION call.

            return this.BeginTransaction(IsolationLevel.ReadCommitted, transactionName);
        }

#if V2
        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.ISqlConnection.BeginTransaction2"]/*' />
        /// <internalonly/>
        ISqlTransaction ISqlConnection.BeginTransaction(string transactionName) {
            return BeginTransaction(transactionName);
        }
#endif

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.BeginTransaction3"]/*' />
        public SqlTransaction BeginTransaction(IsolationLevel iso, string transactionName) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476

            if (ConnectionState.Closed == this._objectState)
                throw ADP.ClosedConnectionError();

            Debug.Assert(this._objectState == ConnectionState.Open, "Invalid ConnectionState in BeginTransaction");

            this.CloseDeadReader();
            this.RollbackDeadTransaction();

            // The LocalTransaction check will also rollback a released transaction.
            if (this.LocalTransaction != null)
                throw ADP.ParallelTransactionsNotSupported(this);

            // bug fix - MDAC #50292: if the user passes a null or empty string, throw an exception
            if (ADP.IsEmpty(transactionName))
                throw SQL.NullEmptyTransactionName();

            string sqlBatch = null;
            switch (iso) {
                case IsolationLevel.ReadCommitted:
                    sqlBatch = TdsEnums.TRANS_READ_COMMITTED;
                    break;
                case IsolationLevel.ReadUncommitted:
                    sqlBatch = TdsEnums.TRANS_READ_UNCOMMITTED;
                    break;
                case IsolationLevel.RepeatableRead:
                    sqlBatch = TdsEnums.TRANS_REPEATABLE_READ;
                    break;
                case IsolationLevel.Serializable:
                    sqlBatch = TdsEnums.TRANS_SERIALIZABLE;
                    break;
                default:
                    throw SQL.InvalidIsolationLevelPropertyArg();
            }

            transactionName = SqlConnection.FixupDatabaseTransactionName(transactionName);
            _internalConnection.ExecuteTransaction(sqlBatch + ";" + TdsEnums.TRANS_BEGIN + " " + transactionName, ADP.BeginTransaction);

            return new SqlTransaction(this, iso);
        }

#if V2
        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.ISqlConnection.BeginTransaction3"]/*' />
        /// <internalonly/>
        ISqlTransaction ISqlConnection.BeginTransaction(IsolationLevel iso, string transactionName) {
            return BeginTransaction(iso, transactionName);
        }
#endif

        //
        // OTHER PUBLIC METHODS
        //

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ChangeDatabase"]/*' />
        public void ChangeDatabase(string database) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 80961

            if (ConnectionState.Open != this.State) {
                throw ADP.OpenConnectionRequired(ADP.ChangeDatabase, State);
            }
            if ((null == database) || (0 == database.Trim().Length)) {
                throw ADP.EmptyDatabaseName();
            }
            this.CloseDeadReader();
            this.RollbackDeadTransaction();

            _internalConnection.ChangeDatabase(database);
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            return new SqlConnection(this);
        }

        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.IDbConnection.CreateCommand"]/*' />
        /// <internalonly/>
        IDbCommand IDbConnection.CreateCommand() {
            return new SqlCommand(null, this);
        }

#if V2
        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.ISqlConnection.CreateCommand"]/*' />
        /// <internalonly/>
        ISqlCommand ISqlConnection.CreateCommand() {
            return new SqlCommand(null, this);
        }
#endif

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.CreateCommand"]/*' />
        public SqlCommand CreateCommand() {
            return new SqlCommand(null, this);
        }

        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.Dispose"]/*' />
        override protected void Dispose(bool disposing) {
            if (disposing) {
                switch (_objectState) {
                case ConnectionState.Closed:
                    break;
                case ConnectionState.Open:
                    Close();
                    break;
                default:
                    Debug.Assert(false, "Invalid Connection State in SqlConnection.Close(ConnectionReset)");
                    break;
                }
                _constr = null;
            }
            base.Dispose(disposing);  // notify base classes
        }


        /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SqlConnection.EnlistDistributedTransaction"]/*' />
        public void EnlistDistributedTransaction(ITransaction transaction) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476
            (new NamedPermissionSet("FullTrust")).Demand(); // MDAC 80681, 81288, 83980

            switch (_objectState) {
                case ConnectionState.Closed:
                    throw ADP.ClosedConnectionError();
                case ConnectionState.Open:
                    this.CloseDeadReader();
                    this.RollbackDeadTransaction();

                    if (this.Reader != null || this.Parser.PendingData) {
                        throw ADP.OpenReaderExists(); // MDAC 66411
                    }

                    // If a connection has a local transaction outstanding and you try to enlist in
                    // a DTC transaction, SQL Server will rollback the local transaction and then do
                    // the enlist (7.0 and 2000).  So, if the user tries to do this, throw.
                    if (null != LocalTransaction) {
                        throw ADP.LocalTransactionPresent();
                    }

                    // If a connection is already enlisted in a DTC transaction and you try to
                    // enlist in another one, in 7.0 the existing DTC transaction would roll
                    // back and then the connection would enlist in the new one. In SQL 2000 &
                    // Yukon, when you enlist in a DTC transaction while the connection is
                    // already enlisted in a DTC transaction, the connection simply switches
                    // enlistments.  Regardless, simply enlist in the user specified
                    // distributed transaction.  This behavior matches OLEDB and ODBC.

                    // No way to validate ITransaction at this point, go ahead and try to enlist.
                    _internalConnection.ManualEnlistDistributedTransaction(transaction);

                    break;
                default:
                    Debug.Assert(false, "Invalid Connection State in SqlConnection.EnlistDistributedTransaction)");
                    break;
            }
        }

        //
        // INTERNAL METHODS
        //

        //
        // PREPARED COMMAND METHODS
        //

        internal void AddPreparedCommand(SqlCommand cmd) {
            if (_preparedCommands == null)
                _preparedCommands = new ArrayList(5);

            _preparedCommands.Add(cmd);
        }

        internal void RemovePreparedCommand(SqlCommand cmd) {
            if (_preparedCommands == null || _preparedCommands.Count == 0)
                return;

            for (int i = 0; i < _preparedCommands.Count; i++)
                if (_preparedCommands[i] == cmd) {
                    _preparedCommands.RemoveAt(i);
                    break;
                }
        }

        //
        // OTHER INTERNAL METHODS
        //

        internal void CloseDeadReader() {
            if (null != _reader && !_reader.IsAlive) {
                if (Parser.PendingData) {
                    _internalConnection.Parser.CleanWire();
                }
                
                _reader = null;
            }
        }

        internal void RollbackDeadTransaction() {
            if (null != _localTransaction && !_localTransaction.IsAlive) {
                this.InternalRollback();
            }
        }

        /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SqlConnection.ExecuteTransaction"]/*' />
        internal void ExecuteTransaction(string sqlBatch, string method) {
            if (ConnectionState.Closed == this._objectState)
                throw ADP.ClosedConnectionError();

            Debug.Assert(this._objectState == ConnectionState.Open, "Invalid ConnectionState in BeginTransaction");

            this.CloseDeadReader();
            this.RollbackDeadTransaction();

            _internalConnection.ExecuteTransaction(sqlBatch, method);
        }

        internal void InternalRollback() {
            // If no arg is given to ROLLBACK it will rollback to the outermost begin - rolling back
            // all nested transactions as well as the outermost transaction.
            _internalConnection.ExecuteTransaction(TdsEnums.TRANS_IF_ROLLBACK, ADP.RollbackTransaction);

            LocalTransaction = null;
        }

        internal void OnError(SqlException exception, TdsParserState state) {
            Debug.Assert(exception != null && exception.Errors.Count != 0, "SqlConnection: OnError called with null or empty exception!");

            // Bug fix - MDAC 49022 - connection open after failure...  Problem was parser was passing
            // Open as a state - because the parser's connection to the netlib was open.  We would
            // then set the connection state to the parser's state - which is not correct.  The only
            // time the connection state should change to what is passed in to this function is if
            // the parser is broken, then we should be closed.  Changed to passing in
            // TdsParserState, not ConnectionState.
            // fixed by BlaineD

            if (state == TdsParserState.Broken && _objectState == ConnectionState.Open)
                this.Close();

            if (exception.Class >= TdsEnums.MIN_ERROR_CLASS) {
                // It is an error, and should be thrown.  Class of TdsEnums.MINERRORCLASS or above is an error,
                // below TdsEnums.MINERRORCLASS denotes an info message.
                throw exception;
            }
            else {
                // If it is a class < TdsEnums.MIN_ERROR_CLASS, it is a warning collection - so pass to handler
                this.OnInfoMessage(new SqlInfoMessageEventArgs(exception));
            }
        }

        // Surround name in brackets and then escape any end bracket to protect against SQL Injection.
        // NOTE: if the user escapes it themselves it will not work, but this was the case in V1 as well
        // as native OleDb and Odbc.
        internal static string FixupDatabaseTransactionName(string name) {
            if (!ADP.IsEmpty(name)) {
                return "[" + name.Replace("]", "]]") + "]";
            }
            else {
                return name;
            }
        }

        //
        // PRIVATE METHODS
        //

        private void CloseReader() {
            // Only called by Close() when connection is Open().
            if (null != _reader) {
                SqlDataReader reader = (SqlDataReader) _reader.Target;
                if (null != reader && _reader.IsAlive) {
                    if (!reader.IsClosed) {
                        reader.Close();
                    }
                }
                else if (_internalConnection.Parser.State != TdsParserState.Broken &&
                         _internalConnection.Parser.State != TdsParserState.Closed) {
                    _internalConnection.Parser.CleanWire();
                }
                _reader = null;
            }
        }

        private void FireObjectState(ConnectionState original, ConnectionState current) {
            // caution: user has full control to change the state again
            this.OnStateChange(new StateChangeEventArgs(original, current));
        }

        private void OnInfoMessage(SqlInfoMessageEventArgs imevent) {
            if (_infoMessageEventHandler != null) {
                try {
                    _infoMessageEventHandler(this, imevent);
                }
                catch (Exception e) { // MDAC 53175
                    ADP.TraceException(e);
                }
            }
        }

        private void OnStateChange(StateChangeEventArgs scevent) {
            if (null != _stateChangeEventHandler) {
                _stateChangeEventHandler(this, scevent);
            }
        }

        // this only happens once per connection
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)] // MDAC 66682, 69017
        private void CheckSQLDebugOnConnect() {
            IntPtr hFileMap;
            uint pid = (uint) NativeMethods.GetCurrentProcessId();

            string mapFileName;

            // If Win2k or later, prepend "Global\\" to enable this to work through TerminalServices.
            if (SQL.IsPlatformNT5()) {
                mapFileName = "Global\\" + TdsEnums.SDCI_MAPFILENAME;
            }
            else {
                mapFileName = TdsEnums.SDCI_MAPFILENAME;
            }

            mapFileName = mapFileName + pid.ToString();

            hFileMap = NativeMethods.OpenFileMappingA(0x4/*FILE_MAP_READ*/, false, mapFileName);

            if (IntPtr.Zero != hFileMap) {
                IntPtr pMemMap = NativeMethods.MapViewOfFile(hFileMap,  0x4/*FILE_MAP_READ*/, 0, 0, 0);
                if (IntPtr.Zero != pMemMap) {
                    SqlDebugContext sdc = new SqlDebugContext();
                    sdc.hMemMap = hFileMap;
                    sdc.pMemMap = pMemMap;
                    sdc.pid = pid;

                    // optimization: if we only have to refresh memory-mapped data at connection open time
                    // optimization: then call here instead of in CheckSQLDebug() which gets called
                    // optimization: at command execution time
                    // RefreshMemoryMappedData(sdc);

                    // delaying setting out global state until after we issue this first SQLDebug command so that
                    // we don't reentrantly call into CheckSQLDebug
                    CheckSQLDebug(sdc);
                    // now set our global state
                    _sdc = sdc;
                }
            }
        }

        // This overload is called by the Command object when executing stored procedures.  Note that
        // if SQLDebug has never been called, it is a noop.
        internal void CheckSQLDebug() {
            if (null != _sdc)
                CheckSQLDebug(_sdc);
        }

        private void CheckSQLDebug(SqlDebugContext sdc) {
            // check to see if debugging has been activated
            Debug.Assert(null != sdc, "SQL Debug: invalid null debugging context!");

            uint tid = (uint) AppDomain.GetCurrentThreadId();
            RefreshMemoryMappedData(sdc);

            // UNDONE: do I need to remap the contents of pMemMap each time I call into here?
            // UNDONE: current behavior is to only marshal the contents of the memory-mapped file
            // UNDONE: at connection open time.

            // If we get here, the debugger must be hooked up.
            if (!sdc.active) {
                if (sdc.fOption/*TdsEnums.SQLDEBUG_ON*/) {
                    // turn on
                    sdc.active = true;
                    sdc.tid = tid;
                    try {
                        IssueSQLDebug(TdsEnums.SQLDEBUG_ON, sdc.machineName, sdc.pid, sdc.dbgpid, sdc.sdiDllName, sdc.data);
                        sdc.tid = 0; // reset so that the first successful time through, we notify the server of the context switch
                    }
                    catch {
                        sdc.active = false;
                        throw;
                    }
                }
            }

            // be sure to pick up thread context switch, especially the first time through
            if (sdc.active) {
                if (!sdc.fOption/*TdsEnums.SQLDEBUG_OFF*/) {
                    // turn off and free the memory
                    sdc.Dispose();
                    // okay if we throw out here, no state to clean up
                    IssueSQLDebug(TdsEnums.SQLDEBUG_OFF, null, 0, 0, null, null);
                }
                else {
                    // notify server of context change
                    if (sdc.tid != tid) {
                        sdc.tid = tid;
                        try {
                            IssueSQLDebug(TdsEnums.SQLDEBUG_CONTEXT, null, sdc.pid, sdc.tid, null, null);
                        }
                        catch(Exception e) {
                            sdc.tid = 0;
                            throw e;
                        }
                    }
                }
            }
        }

        private void IssueSQLDebug(uint option, string machineName, uint pid, uint id, string sdiDllName, byte[] data) {
            // CONSIDER: we could cache three commands, one for each mode {on, off, context switch}
            // CONSIDER: but debugging is not the performant case so save space instead amd rebuild each time
            SqlCommand c = new SqlCommand(TdsEnums.SP_SDIDEBUG, this);
            c.CommandType = CommandType.StoredProcedure;

            // context param
            SqlParameter p = new SqlParameter(null, SqlDbType.VarChar, TdsEnums.SQLDEBUG_MODE_NAMES[option].Length);
            p.Value = TdsEnums.SQLDEBUG_MODE_NAMES[option];
            c.Parameters.Add(p);

            if (option == TdsEnums.SQLDEBUG_ON) {
                // debug dll name
                p = new SqlParameter(null, SqlDbType.VarChar, sdiDllName.Length);
                p.Value = sdiDllName;
                c.Parameters.Add(p);
                // debug machine name
                p = new SqlParameter(null, SqlDbType.VarChar, machineName.Length);
                p.Value = machineName;
                c.Parameters.Add(p);
            }

            if (option != TdsEnums.SQLDEBUG_OFF) {
                // client pid
                p = new SqlParameter(null, SqlDbType.Int);
                p.Value = pid;
                c.Parameters.Add(p);
                // dbgpid or tid
                p = new SqlParameter(null, SqlDbType.Int);
                p.Value = id;
                c.Parameters.Add(p);
            }

            if (option == TdsEnums.SQLDEBUG_ON) {
                // debug data
                p = new SqlParameter(null, SqlDbType.VarBinary, (null != data) ? data.Length : 0);
                p.Value = data;
                c.Parameters.Add(p);
            }

            c.ExecuteNonQuery();
        }

        // updates our context with any changes made to the memory-mapped data by an external process
        private static void RefreshMemoryMappedData(SqlDebugContext sdc) {
            Debug.Assert(IntPtr.Zero != sdc.pMemMap, "SQL Debug: invalid null value for pMemMap!");
            // copy memory mapped file contents into managed types
            MEMMAP memMap = (MEMMAP) Marshal.PtrToStructure(sdc.pMemMap, typeof(MEMMAP));
            sdc.dbgpid = memMap.dbgpid;
            sdc.fOption = (memMap.fOption == 1) ? true : false;
            // xlate ansi byte[] -> managed strings
            Encoding cp = System.Text.Encoding.GetEncoding(TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE);
            sdc.machineName = cp.GetString(memMap.rgbMachineName, 0, memMap.rgbMachineName.Length);
            sdc.sdiDllName = cp.GetString(memMap.rgbDllName, 0, memMap.rgbDllName.Length);
            // just get data reference
            sdc.data = memMap.rgbData;
        }
    } // SqlConnection


    //
    // This is a private interface for the SQL Debugger
    // You must not change the guid for this coclass
    // or the iid for the ISQLDebug interface
    //
    /// <include file='doc\SQLConnection.uex' path='docs/doc[@for="SQLDebugging"]/*' />
    /// <internalonly/>
    [
    ComVisible(true),
    ClassInterface(ClassInterfaceType.None),
    Guid("afef65ad-4577-447a-a148-83acadd3d4b9"),
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class SQLDebugging : ISQLDebug {

        // Security stuff
            const int STANDARD_RIGHTS_REQUIRED = (0x000F0000);
            const int DELETE = (0x00010000);
            const int READ_CONTROL = (0x00020000);
            const int WRITE_DAC = (0x00040000);
            const int WRITE_OWNER = (0x00080000);
            const int SYNCHRONIZE = (0x00100000);
            const int FILE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x000001FF);
            const uint GENERIC_READ = (0x80000000);
            const uint GENERIC_WRITE = (0x40000000);
            const uint GENERIC_EXECUTE = (0x20000000);
            const uint GENERIC_ALL = (0x10000000);

            const int SECURITY_DESCRIPTOR_REVISION = (1);
            const int ACL_REVISION = (2);

            const int SECURITY_AUTHENTICATED_USER_RID = (0x0000000B);
            const int SECURITY_LOCAL_SYSTEM_RID = (0x00000012);
            const int SECURITY_BUILTIN_DOMAIN_RID = (0x00000020);
            const int SECURITY_WORLD_RID = (0x00000000);
            const byte SECURITY_NT_AUTHORITY = 5;
            const int DOMAIN_GROUP_RID_ADMINS= (0x00000200);
            const int DOMAIN_ALIAS_RID_ADMINS = (0x00000220);

            const int sizeofSECURITY_ATTRIBUTES = 12; // sizeof(SECURITY_ATTRIBUTES);
            const int sizeofSECURITY_DESCRIPTOR = 20; // sizeof(SECURITY_DESCRIPTOR);
            const int sizeofACCESS_ALLOWED_ACE = 12; // sizeof(ACCESS_ALLOWED_ACE);
            const int sizeofACCESS_DENIED_ACE = 12; // sizeof(ACCESS_DENIED_ACE);
            const int sizeofSID_IDENTIFIER_AUTHORITY = 6; // sizeof(SID_IDENTIFIER_AUTHORITY)
            const int sizeofACL = 8; // sizeof(ACL);
            // const uint ERROR_ALREADY_EXISTS = 183;


       private IntPtr CreateSD(ref IntPtr pDacl) {
              IntPtr pSecurityDescriptor = IntPtr.Zero;
              IntPtr pUserSid = IntPtr.Zero;
              IntPtr pAdminSid = IntPtr.Zero;
              IntPtr pNtAuthority = IntPtr.Zero;
              int cbAcl = 0;
              bool status = false;

              pNtAuthority = Marshal.AllocHGlobal( sizeofSID_IDENTIFIER_AUTHORITY );
              if (pNtAuthority == IntPtr.Zero)
                goto cleanup;
              Marshal.WriteInt32( pNtAuthority, 0, 0 );
              Marshal.WriteByte( pNtAuthority, 4, 0 );
              Marshal.WriteByte( pNtAuthority, 5, SECURITY_NT_AUTHORITY);

              status =
                NativeMethods.AllocateAndInitializeSid(
                                    pNtAuthority,
                                    (byte)1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    ref pUserSid );

            if (!status || pUserSid==IntPtr.Zero) {
                goto cleanup;
            }
            status =
                NativeMethods.AllocateAndInitializeSid(
                                    pNtAuthority,
                                    (byte)2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    ref pAdminSid );

            if (!status || pAdminSid==IntPtr.Zero) {
                goto cleanup;
            }
            status = false;
            pSecurityDescriptor = Marshal.AllocHGlobal( sizeofSECURITY_DESCRIPTOR );
            if (pSecurityDescriptor==IntPtr.Zero) {
                goto cleanup;
            }
            for (int i=0;i< sizeofSECURITY_DESCRIPTOR ;i++)
                        Marshal.WriteByte( pSecurityDescriptor ,i,(byte)0);
            cbAcl = sizeofACL
              + (2 * (sizeofACCESS_ALLOWED_ACE))
              + sizeofACCESS_DENIED_ACE
              + NativeMethods.GetLengthSid( pUserSid )
              + NativeMethods.GetLengthSid( pAdminSid ) ;

            pDacl = Marshal.AllocHGlobal( cbAcl );
            if (pDacl == IntPtr.Zero) {
                goto cleanup;
            }
            // rights must be added in a certain order.  Namely, deny access first, then add access
	     if (NativeMethods.InitializeAcl(pDacl, cbAcl, ACL_REVISION))
			if (NativeMethods.AddAccessDeniedAce(pDacl, ACL_REVISION, WRITE_DAC, pUserSid))
				if (NativeMethods.AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_READ, pUserSid))
					if (NativeMethods.AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_ALL, pAdminSid))
						if (NativeMethods.InitializeSecurityDescriptor(pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
							if(NativeMethods.SetSecurityDescriptorDacl(pSecurityDescriptor, true, pDacl, false))
							{
							    status = true;
							}

    cleanup:
            if (pNtAuthority != IntPtr.Zero)
                 Marshal.FreeHGlobal( pNtAuthority );
            if (pAdminSid != IntPtr.Zero)
                 NativeMethods.FreeSid( pAdminSid );
            if (pUserSid != IntPtr.Zero)
                 NativeMethods.FreeSid( pUserSid );
            if (status)
                return pSecurityDescriptor;
            else {
                if (pSecurityDescriptor != IntPtr.Zero)
                     Marshal.FreeHGlobal( pSecurityDescriptor );
                }
            return IntPtr.Zero;
        }
       /// <include file='doc\SqlConnection.uex' path='docs/doc[@for="SQLDebugging.dwpidDebuggee,"]/*' />
       /// <internalonly/>
       bool ISQLDebug.SQLDebug(int dwpidDebugger, int dwpidDebuggee, [MarshalAs(UnmanagedType.LPStr)] string pszMachineName,
                               [MarshalAs(UnmanagedType.LPStr)] string pszSDIDLLName, int dwOption, int cbData, byte[] rgbData)  {
            bool result = false;
            IntPtr hFileMap = IntPtr.Zero;
            IntPtr pMemMap = IntPtr.Zero;
            IntPtr pSecurityDescriptor = IntPtr.Zero;
            IntPtr pSecurityAttributes = IntPtr.Zero;
            IntPtr pDacl = IntPtr.Zero;

            // validate the structure
            if (null == pszMachineName || null == pszSDIDLLName)
                return false;

            if (pszMachineName.Length > TdsEnums.SDCI_MAX_MACHINENAME ||
               pszSDIDLLName.Length > TdsEnums.SDCI_MAX_DLLNAME)
                return false;

            // note that these are ansi strings
            Encoding cp = System.Text.Encoding.GetEncoding(TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE);
            byte[] rgbMachineName = cp.GetBytes(pszMachineName);
            byte[] rgbSDIDLLName = cp.GetBytes(pszSDIDLLName);

            if (null != rgbData && cbData > TdsEnums.SDCI_MAX_DATA)
                return false;

            string mapFileName;

            // If Win2k or later, prepend "Global\\" to enable this to work through TerminalServices.
            if (SQL.IsPlatformNT5()) {
                mapFileName = "Global\\" + TdsEnums.SDCI_MAPFILENAME;
            }
            else {
                mapFileName = TdsEnums.SDCI_MAPFILENAME;
            }

            mapFileName = mapFileName + dwpidDebuggee.ToString();

            // Create Security Descriptor
            pSecurityDescriptor = CreateSD(ref pDacl);
            pSecurityAttributes = Marshal.AllocHGlobal( sizeofSECURITY_ATTRIBUTES );
            if ((pSecurityDescriptor == IntPtr.Zero) || (pSecurityAttributes == IntPtr.Zero))
                return false;
            Marshal.WriteInt32( pSecurityAttributes, 0, sizeofSECURITY_ATTRIBUTES ); // nLength = sizeof(SECURITY_ATTRIBUTES)
            Marshal.WriteIntPtr( pSecurityAttributes, 4, pSecurityDescriptor ); // lpSecurityDescriptor = pSecurityDescriptor
            Marshal.WriteInt32( pSecurityAttributes, 8, 0 ); // bInheritHandle = FALSE
            hFileMap = NativeMethods.CreateFileMappingA(
                ADP.InvalidIntPtr/*INVALID_HANDLE_VALUE*/,
                pSecurityAttributes,
                0x4/*PAGE_READWRITE*/,
                0,
                Marshal.SizeOf(typeof(MEMMAP)),
                mapFileName);

            if (IntPtr.Zero == hFileMap) {
                goto cleanup;
            }
            // Can't do this, since the debuggee needs to send spidebug("off") message to sql server,
            // and we have no control over when that will happen.  The shared memory needs to remain open until then.
            // Prevent spoofing! Don't use an already existing memory mapped file.
            //if ((dwOption == TdsEnums.SQLDEBUG_ON) && 
            //    (NativeMethods.GetLastError() & 0xffff) == ERROR_ALREADY_EXISTS) {
            //    goto cleanup;
            //}
            pMemMap = NativeMethods.MapViewOfFile(hFileMap,  0x6/*FILE_MAP_READ|FILE_MAP_WRITE*/, 0, 0, 0);

            if (IntPtr.Zero == pMemMap) {
                goto cleanup;
            }

            // copy data to memory-mapped file
            // layout of MEMMAP structure is:
            // uint dbgpid
            // uint fOption
            // byte[32] machineName
            // byte[16] sdiDllName
            // uint dbData
            // byte[255] vData
            int offset = 0;
            Marshal.WriteInt32(pMemMap, offset, (int)dwpidDebugger);
            offset += 4;
            Marshal.WriteInt32(pMemMap, offset, (int)dwOption);
            offset += 4;
            Marshal.Copy(rgbMachineName, 0, ADP.IntPtrOffset(pMemMap, offset), rgbMachineName.Length);
            offset += TdsEnums.SDCI_MAX_MACHINENAME;
            Marshal.Copy(rgbSDIDLLName, 0, ADP.IntPtrOffset(pMemMap, offset), rgbSDIDLLName.Length);
            offset += TdsEnums.SDCI_MAX_DLLNAME;
            Marshal.WriteInt32(pMemMap, offset, (int)cbData);
            offset += 4;
            if (null != rgbData)
                Marshal.Copy(rgbData, 0, ADP.IntPtrOffset(pMemMap, offset), (int)cbData);
            
            NativeMethods.UnmapViewOfFile(pMemMap);
            result = true;
    cleanup:
            if (result == false) {
                if (hFileMap != IntPtr.Zero)
                        NativeMethods.CloseHandle(hFileMap);
            }
            if (pSecurityAttributes != IntPtr.Zero)
                    Marshal.FreeHGlobal( pSecurityAttributes );
            if (pSecurityDescriptor != IntPtr.Zero)
                    Marshal.FreeHGlobal( pSecurityDescriptor );
            if (pDacl != IntPtr.Zero)
                 Marshal.FreeHGlobal( pDacl );
            return result;
        }
    }

    // this is a private interface to com+ users
    // do not change this guid
    [
    ComImport,
    ComVisible(true),
    Guid("6cb925bf-c3c0-45b3-9f44-5dd67c7b7fe8"),
    InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
    BestFitMapping(false, ThrowOnUnmappableChar=true)
    ]
    interface ISQLDebug {
        bool SQLDebug(
            int dwpidDebugger,
            int dwpidDebuggee,
            [MarshalAs(UnmanagedType.LPStr)] string pszMachineName,
            [MarshalAs(UnmanagedType.LPStr)] string pszSDIDLLName,
            int dwOption,
            int cbData,
            byte[] rgbData);
    }

    sealed class SqlDebugContext : IDisposable {
        // context data
        internal uint pid = 0;
        internal uint tid = 0;
        internal bool active = false;
        // memory-mapped data
        internal IntPtr pMemMap = IntPtr.Zero;
        internal IntPtr hMemMap = IntPtr.Zero;
        internal uint dbgpid = 0;
        internal bool fOption = false;
        internal string machineName = null;
        internal string sdiDllName = null;
        internal byte[] data = null;

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        private void Dispose (bool disposing) {
            if (disposing) {
                // Nothing to do here
                ;
            }
            if (pMemMap != IntPtr.Zero) {
                NativeMethods.UnmapViewOfFile(pMemMap);
                pMemMap = IntPtr.Zero;
            }
            if (hMemMap != IntPtr.Zero) {
                NativeMethods.CloseHandle(hMemMap);
                hMemMap = IntPtr.Zero;
            }
            active = false;
        }
        
        ~SqlDebugContext() {
                Dispose(false);
        }
    }   
                

    // native interop memory mapped structure for sdi debugging
    [StructLayoutAttribute(LayoutKind.Sequential, Pack=1)]
    internal struct MEMMAP {
        [MarshalAs(UnmanagedType.U4)]
        internal uint dbgpid; // id of debugger
        [MarshalAs(UnmanagedType.U4)]
        internal uint fOption; // 1 - start debugging, 0 - stop debugging
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
        internal byte[] rgbMachineName;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=16)]
        internal byte[] rgbDllName;
        [MarshalAs(UnmanagedType.U4)]
        internal uint cbData;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=255)]
        internal byte[] rgbData;
    }
} // System.Data.SqlClient namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlinfomessageevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlInfoMessageEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;

    /// <include file='doc\SQLInfoMessageEvent.uex' path='docs/doc[@for="SqlInfoMessageEventArgs"]/*' />
    sealed public class SqlInfoMessageEventArgs : System.EventArgs {
        private SqlException exception;

        internal SqlInfoMessageEventArgs(SqlException exception) {
            this.exception = exception;
        }

        /// <include file='doc\SQLInfoMessageEvent.uex' path='docs/doc[@for="SqlInfoMessageEventArgs.Errors"]/*' />
        public SqlErrorCollection Errors {
            get { return exception.Errors;}
        }

        /// <include file='doc\SQLInfoMessageEvent.uex' path='docs/doc[@for="SQLInfoMessageEvent.ShouldSerializeErrors"]/*' />
        /*virtual protected*/private bool ShouldSerializeErrors() { // MDAC 65548
            return (null != exception) && (0 < exception.Errors.Count);
        }

        /// <include file='doc\SqlInfoMessageEvent.uex' path='docs/doc[@for="SqlInfoMessageEventArgs.Message"]/*' />
        public string Message { // MDAC 68482
            get { return exception.Message; }
        }

        /// <include file='doc\SqlInfoMessageEvent.uex' path='docs/doc[@for="SqlInfoMessageEventArgs.Source"]/*' />
        public string Source { // MDAC 68482
            get { return exception.Source;}
        }

        /// <include file='doc\SqlInfoMessageEvent.uex' path='docs/doc[@for="SqlInfoMessageEventArgs.ToString"]/*' />
        override public string ToString() { // MDAC 68482
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlinfomessageeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlInfoMessageEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    using System;

    /// <include file='doc\SQLInfoMessageEventHandler.uex' path='docs/doc[@for="SqlInfoMessageEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.SqlClient.SqlConnection.InfoMessage'/> event of a <see cref='System.Data.SqlClient.SqlConnection'/>.
    ///    </para>
    /// </devdoc>
    public delegate void SqlInfoMessageEventHandler(object sender, SqlInfoMessageEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Data;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Globalization;
    
    /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter"]/*' />
    // UNDONE: don't inherit from IDataAdapter until it returns the IDataFOO interfaces
    // see http://vx/vx7/TheBox/Dependencies/DisplayActiveByVSTeam.asp?Team=1#448
    // for status on explicit interface implementations
    [
    TypeConverterAttribute(typeof(SqlParameterConverter))
    ]
    sealed public class SqlParameter : MarshalByRefObject, IDbDataParameter, ICloneable {
        //
        // internal members
        //
        private SqlParameterCollection _parent;
        private object _value = null; // Convert.Empty; // parameter value
        internal MetaType _metaType = MetaType.GetDefaultMetaType();
        private string _sourceColumn; // name of the data set column
        private string _name;       // name of the parameter
        private Byte _precision;
        private Byte _scale;
        private ParameterDirection _direction = ParameterDirection.Input;
        private int _size = -1; // means that we haven't set the size yet
        private DataRowVersion _version = DataRowVersion.Current;
        private bool _isNullable; // a design-time code generation property
        private SqlCollation _collation;
        private bool _forceSize = false; // if true, user has specified the size.  use this instead of the actualSize
        private int _offset = 0;
        private bool _suppress = false;
        private bool _inferType = true; // true until the user sets the SqlDbType or DataType property explicitly

        // default ctor is mandatory for clone
        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter"]/*' />
        public SqlParameter() {
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter3"]/*' />
        public SqlParameter(string parameterName, object value) {
            this.ParameterName = parameterName;
            this.Value = value;
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter2"]/*' />
        public SqlParameter(string parameterName, SqlDbType dbType) {
            this.ParameterName = parameterName;
            this.SqlDbType = dbType;
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter4"]/*' />
        public SqlParameter(string parameterName, SqlDbType dbType, int size) {
            this.ParameterName = parameterName;
            this.SqlDbType = dbType;
            this.Size = size;
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter5"]/*' />
        public SqlParameter(string parameterName, SqlDbType dbType, int size, string sourceColumn) {
            this.ParameterName = parameterName;
            this.SqlDbType = dbType;
            this.Size = size;
            this.SourceColumn = sourceColumn;
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SqlParameter1"]/*' />
        [ EditorBrowsableAttribute(EditorBrowsableState.Advanced) ] // MDAC 69508
        public SqlParameter(string parameterName, SqlDbType dbType, int size, ParameterDirection direction,
                            bool isNullable, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, object value) {
            this.ParameterName = parameterName;
            this.SqlDbType = dbType;
            this.Size = size;
            this.Direction = direction;
            this.IsNullable = isNullable;
            this.Precision = precision;
            this.Scale = scale;
            this.SourceColumn = sourceColumn;
            this.SourceVersion = sourceVersion;
            this.Value = value;
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.ToString"]/*' />
        public override string ToString() {
            return ParameterName;
        }

        /// <include file='doc\SqlParameter.uex' path='docs/doc[@for="SqlParameter.DbType1"]/*' />
        [
        Browsable(false),
        DataCategory(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataParameter_DbType),
        ]
        public DbType DbType {
            get {
                return _metaType.DbType;
            }
            set {
                SetTypeInfoFromDbType(value);
                _inferType = false;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.DbType"]/*' />
        [
        DefaultValue(SqlDbType.NVarChar), // MDAC 65862
        DataCategory(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DataSysDescription(Res.SqlParameter_SqlDbType)
        ]
        public SqlDbType SqlDbType {
            get {
                return _metaType.SqlDbType;
            }
            set {
                try {
                    _metaType = MetaType.GetMetaType(value);
                }
                catch (IndexOutOfRangeException) {
                    throw SQL.InvalidSqlDbType(ParameterName, (int) value);
                }
                
                _inferType = false;
            }
        }


        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Direction"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(ParameterDirection.Input),
        DataSysDescription(Res.DataParameter_Direction)
        ]
        public ParameterDirection Direction {
            get {
                return(_direction);
            }
            set {
                int intValue = (int) value;

                // prior check used Enum.IsDefined below, but changed to the following since perf was poor
                if (value != ParameterDirection.Input       && value != ParameterDirection.Output &&
                    value != ParameterDirection.InputOutput && value != ParameterDirection.ReturnValue) {
                    throw ADP.InvalidParameterDirection(intValue, ParameterName);
                }
                _direction = (ParameterDirection)intValue;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.IsNullable"]/*' />
        [
        Browsable(false), // MDAC 70780
        DefaultValue(false),
        DesignOnly(true),
        DataSysDescription(Res.DataParameter_IsNullable),
        EditorBrowsableAttribute(EditorBrowsableState.Advanced) // MDAC 69508
        ]
        public bool IsNullable {
            get {
                return _isNullable;
            }
            set {
                _isNullable = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Offset"]/*' />
        [
        Browsable(false),
        DataCategory(Res.DataCategory_Data),
        DefaultValue(0),
        DataSysDescription(Res.SqlParameter_Offset)
        ]
        public int Offset {
            get {
                return _offset;
            }
            set {
                // @devnote: only use the property for interface size sets.  If the user sets this then only this many bytes
                // @devnote: is sent over the wire regardless of how many bytes may be in the byte array
                _offset = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.ParameterName"]/*' />
        [
        DefaultValue(""),
        DataSysDescription(Res.SqlParameter_ParameterName)
        ]
        public string ParameterName {
            get {
                return ((null != _name) ? _name : String.Empty);
            }
            set {
                if (_name != value) {
                    if ((null != value) && (value.Length > TdsEnums.MAX_PARAMETER_NAME_LENGTH)) {
                        throw SQL.InvalidParameterNameLength();
                    }
                    _name = value;
                }
            }
        }

        internal SqlParameterCollection Parent {
            get {
                return _parent;
            }
            set {
                _parent = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Precision"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        DataSysDescription(Res.DbDataParameter_Precision)
        ]
        public byte Precision {
            get {
                byte precision = _precision;

                // infer precision if not set for SqlDecimal
                if (0 == precision && this.SqlDbType == SqlDbType.Decimal) {
                    object val = this.Value;
                    if (val is SqlDecimal) {
                        precision = ((SqlDecimal)val).Precision;
                    }
                }

                return precision;
            }
            set {
                if (value > TdsEnums.MAX_NUMERIC_PRECISION) {
                    throw SQL.PrecisionValueOutOfRange(value);
                }
                _precision = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Scale"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        DataSysDescription(Res.DbDataParameter_Scale)
        ]
        public byte Scale {
            get {
                byte scale = _scale;

                if (0 == scale && this.SqlDbType == SqlDbType.Decimal) {
                    object val = this.Value;
                    if (_value != null && !Convert.IsDBNull(_value)) {
                        if (val is SqlDecimal) {
                            scale = ((SqlDecimal)val).Scale;
                        }
                        else {
                            if (val.GetType() != typeof(decimal)) {
                                val = Convert.ChangeType(val, typeof(decimal));
                            }
                            scale = (byte) ((Decimal.GetBits((Decimal)val)[3] & 0x00ff0000) >> 0x10);
                        }
                    }
                }

                return scale;
            }
            set {
                _scale = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Size"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(0),
        DataSysDescription(Res.DbDataParameter_Size)
        ]
        public int Size {
            get {
                // mdac 54812:  we only return the size if the user has set the size
                if (_forceSize) {
                    return _size;
                }

                return 0;
            }
            set {
                if (value < 0) {
                    throw ADP.InvalidSizeValue(value);
                }
                // @devnote: only use the property for interface size sets.  If the user sets this then only this many bytes/chars
                // @devnote: is sent over the wire regardless of how many bytes/chars may be in the byte array
                if (0 != value) {
                    _forceSize = true;
                    _size = value;
                }
                else {
                    _forceSize = false;
                    _size = -1;
                }
            }
        }


        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SourceColumn"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataParameter_SourceColumn)
        ]
        public string SourceColumn {
            get {
                return (null != _sourceColumn) ? _sourceColumn : String.Empty;
            }
            set {
                _sourceColumn = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.SourceVersion"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(DataRowVersion.Current),
        DataSysDescription(Res.DataParameter_SourceVersion)
        ]
        public DataRowVersion SourceVersion {
            get {
                return _version;
            }
            set {
                int intValue = (int) value;

                // prior check used Enum.IsDefined below, but changed to the following since perf was poor
                if (value != DataRowVersion.Original && value != DataRowVersion.Current &&
                    value != DataRowVersion.Proposed && value != DataRowVersion.Default) {
                    throw ADP.InvalidDataRowVersion(ParameterName, intValue);
                }
                _version = value;
            }
        }

        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.Value"]/*' />
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(null),
        DataSysDescription(Res.DataParameter_Value),
        TypeConverter(typeof(StringConverter))
        ]
        public object Value {
            get {
                return _value;
            }
            set {
                _value = value;
                if (_inferType && !Convert.IsDBNull(_value) && (null != _value) ) {
                    // don't call the DataType property setter here because
                    // it will clear _inferType!
                    SetTypeInfoFromComType(value);
                }
            }
        }

        internal void Prepare(SqlCommand cmd) { // MDAC 67063
            if (_inferType) {
                throw ADP.PrepareParameterType(cmd);
            }
            else if ((0 == Size) && !_metaType.IsFixed) {
                throw ADP.PrepareParameterSize(cmd);
            }
            else if ( ((0 == Precision) && (0 == Scale)) &&  (_metaType.SqlDbType == SqlDbType.Decimal) ) {
                throw ADP.PrepareParameterScale(cmd, SqlDbType.ToString("G"));
            }
        }

        internal void SetTypeInfoFromDbType(DbType type) {
           _metaType = MetaType.GetMetaType(type);
        }

        internal void SetTypeInfoFromComType(object value) {
            _metaType = MetaType.GetMetaType(value);
        }

        // This may not be a good thing to do in case someone overloads the parameter type but I
        // don't want to go from SqlDbType -> metaType -> TDSType
        internal MetaType GetMetaType() {
            return _metaType;
        }

        /*internal byte TdsType {
            get {
                return _metaType.TDSType;
            }
        }*/

        //
        // currently the user can't set this value.  it gets set by the returnvalue from tds
        //
        internal SqlCollation Collation {
            get { return _collation;}
            set { _collation = value;}
        }

        internal int GetBinSize(object val) {
            Type t = val.GetType();

            if (t == typeof(byte[]))
                return ((byte[])val).Length;
            else
            if (t == typeof(SqlBinary))
                return ((SqlBinary)val).Value.Length;
            else
                Debug.Assert(false, "invalid binary data type!");

            return 0;
        }

        // returns the number of characters
        internal int GetStringSize(object val) {
            Type t = val.GetType();

            if (t == typeof(string))
                return ((string)val).Length;
            else
            if (t == typeof(SqlString))
                return (((SqlString)val).Value.Length);
            else
            if (t == typeof(char[]))
                return ((char[])val).Length;
            else
            if (t == typeof(byte[]))
                return ((byte[])val).Length;
            else
            if (t == typeof(byte) || t == typeof(char))
                return 1;
            else
                Debug.Assert(false, "invalid string data type!");

            return 0;
        }

        //
        // always returns data in bytes - except for non-unicode chars, which will be in number of chars
        //
        internal int ActualSize {
            get {
                int size = 0;
                SqlDbType actualType = _metaType.SqlDbType;
                MetaType mt = _metaType;
                object val = this.Value;
                bool isSqlVariant = false;

                // UNDONE: SqlTypes should work correctly with Convert.IsDBNull
                if ( (null == val) || Convert.IsDBNull(val))
                    return 0;

                if ( (val is INullable) && ((INullable)val).IsNull)
                    return 0;

                // if this is a backend SQLVariant type, then infer the TDS type from the SQLVariant type
                if (actualType == SqlDbType.Variant) {
                    mt = MetaType.GetMetaType(val);
                    actualType = MetaType.GetSqlDataType(mt.TDSType, 0 /*no user type*/, 0 /*non-nullable type*/);
                    isSqlVariant = true;
                }
                else if (val.GetType() != mt.ClassType && val.GetType() != mt.SqlType) {
                    val = Convert.ChangeType(val, mt.ClassType);
                }

                if (mt.IsFixed)
                    return mt.FixedLength;

                // @hack: until we have ForceOffset behavior we have the following semantics:
                // @hack: if the user supplies a Size through the Size propeprty or constructor,
                // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size, then
                // @hack: we send over actualSize
                int actualSize = 0;

                // get the actual length of the data, in bytes
                switch (actualType) {
                    case SqlDbType.NChar:
                    case SqlDbType.NVarChar:
                    case SqlDbType.NText:
                        actualSize = GetStringSize(val);
                        size = (_forceSize == true && _size <= actualSize) ? _size : actualSize;
                        size <<= 1;
                        break;
                    case SqlDbType.Char:
                    case SqlDbType.VarChar:
                    case SqlDbType.Text:
                        // for these types, ActualSize is the num of chars, not actual bytes - since non-unicode chars are not always uniform size
                        actualSize = GetStringSize(val);
                        size = (_forceSize == true && _size <= actualSize) ? _size : actualSize;
                        break;
                    case SqlDbType.Binary:
                    case SqlDbType.VarBinary:
                    case SqlDbType.Image:
                    case SqlDbType.Timestamp:
                        actualSize = GetBinSize(val);
                        size = (_forceSize == true && _size <= actualSize) ? _size : actualSize;
                        break;
                    default:
                        Debug.Assert(false, "Unknown variable length type!");
                        break;
                } // switch

                // don't even send big values over to the variant
                if (isSqlVariant && (actualSize > TdsEnums.TYPE_SIZE_LIMIT))
                    throw SQL.ParameterInvalidVariant(this.ParameterName);

                return size;
            } //get
        }//ActualSize

        // In the autogen case, suppresses the parameter from being sent
        // to the server.  This could happen in the following cases:
        // 1) NULL value in where clause of DELETE or UPDATE statements
        // 2) default value should be sent over in INSERT clause
        internal bool Suppress {
            get {return _suppress;}
            set { _suppress = value;}
        }

        internal object CoercedValue {
            get {
                    // UNDONE: optimization, cache _coercedValue on the parameter
                    if ((null != _value) && !Convert.IsDBNull(_value)) {
                        Type t = _value.GetType();
                        // if we don't have the correct sql type or com type, coerce
                        if (t != _metaType.SqlType && t != _metaType.ClassType) {
                            // UNDONE: add a coercion routine for SqlType coercion
                            return Convert.ChangeType(_value, _metaType.ClassType);
                        }
                        else {
                            return _value;
                        }
                    }
                    return null;
            }
        }

        // used by Clone() and static CreateParameter()
        internal void SetProperties(string name, string column, DataRowVersion version, byte precision, byte scale, int size, bool forceSize, 
                                               int offset, ParameterDirection direction, object value, SqlDbType type, bool suppress, bool inferType) {
            // do limited validation here
            this.ParameterName = name;
            _sourceColumn = column;
            SourceVersion = version;
            Precision = precision;
            _scale = scale;
            _size = size;
            _forceSize = forceSize;
            _offset = offset;
            Direction = direction;

            // be sure to ssync up our metaType information
            _metaType = MetaType.GetMetaType(type);

            // bug 49322, do a deep copy of object values
            if (value is ICloneable) {
                value = ((ICloneable) value).Clone();
            }
            _value = value;
            Suppress = suppress;
            _inferType = inferType;
        }

        // ICloneable
        /// <include file='doc\SQLParameter.uex' path='docs/doc[@for="SqlParameter.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            SqlParameter clone = new SqlParameter(); // MDAC 81448
            // don't go through property accessors and infer types, values, etc
            // just make an exact copy of the original parameter
            clone.SetProperties( _name,
                                 _sourceColumn,
                                 _version,
                                 _precision,
                                 _scale,
                                 _size,
                                 _forceSize,
                                 _offset,
                                 _direction,
                                 _value,
                                 SqlDbType,
                                 _suppress,
                                 _inferType);
            return clone;
        }

        internal void Validate() {
            // Throw if param is output or inputoutput, size has not been set, and value has not been set (or is null).
            // Also, ensure it is not a Timestamp - while timestamp is a bigbinary and non-fixed for wire representation,
            // from the user's perspective it is fixed.
            // Output=2, InputOutput=3

            object val = this.Value;
            
            if ((0 != (Direction & ParameterDirection.Output)) && (!_metaType.IsFixed) && (!_forceSize) && ((null == val) || Convert.IsDBNull(val)) && (SqlDbType != SqlDbType.Timestamp)) {
                throw ADP.UninitializedParameterSize(_parent.IndexOf(this), this.ParameterName, _metaType.ClassType, this.Size);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlparametercollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlParameterCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection"]/*' />
    [
    Editor("Microsoft.VSDesigner.Data.Design.DBParametersEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
    ListBindable(false)
    ]
    sealed public class SqlParameterCollection : MarshalByRefObject, IDataParameterCollection {
        private SqlCommand parent;
        private ArrayList items; // delay creation until AddWithoutEvents, Insert, CopyTo, GetEnumerator

        internal SqlParameterCollection(SqlCommand parent) {
            this.parent = parent;
        }

        // explicit ICollection implementation
        bool System.Collections.ICollection.IsSynchronized {
            get { return false;}
        }
        object System.Collections.ICollection.SyncRoot {
            get { return this;}
        }

        // explicit IList implementation
        bool System.Collections.IList.IsReadOnly {
            get { return false;}
        }
        bool System.Collections.IList.IsFixedSize {
            get { return false;}
        }
        object System.Collections.IList.this[int index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (SqlParameter) value;
            }
        }

        // explicit IDataParameterCollection implementation
        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.IDataParameterCollection.this"]/*' />
        /// <internalonly/>
        object IDataParameterCollection.this[string index] {
            get {
                return this[index];
            }
            set {
                ValidateType(value);
                this[index] = (SqlParameter) value;
            }
        }

#if V2
        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.ISqlParameterCollection.Add"]/*' />
        /// <internalonly/>
        ISqlParameter ISqlParameterCollection.Add(ISqlParameter value) {
            return this.Add(value);
        }
#endif

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Count"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Count {
            get {
                return ((null != items) ? items.Count : 0);
            }
        }

        private Type ItemType {
            get { return typeof(SqlParameter); }
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.this"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public SqlParameter this[int index] {
            get {
                RangeCheck(index);
                return(SqlParameter) items[index];
            }
            set {
                OnSchemaChanging();  // fire event before value is validated
                RangeCheck(index);
                Replace(index, value);
            }
        }

#if V2
        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.ISqlParameterCollection.this"]/*' />
        /// <internalonly/>
        ISqlParameter ISqlParameterCollection.this[int index] {
            get {
                return (ISqlParameter) (this[index]);
            }
            set {
                this[index] = (SqlParameter) value;
            }
        }
#endif

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.this1"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public SqlParameter this[string parameterName] {
            get {
                int index = RangeCheck(parameterName);
                return(SqlParameter) items[index];
            }

            set {
                OnSchemaChanging();  // fire event before value is validated
                int index = RangeCheck(parameterName);
                Replace(index, value);
            }
        }

#if V2
        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.ISqlParameterCollection.this1"]/*' />
        /// <internalonly/>
        ISqlParameter ISqlParameterCollection.this[string parameterName] {
            get {
                return this[parameterName];
            }
            set {
                this[parameterName] = (SqlParameter) value;
            }
        }
#endif

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add"]/*' />
        public int Add(Object value) {
            ValidateType(value);
            Add((SqlParameter)value);
            return Count-1; // appended index
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add1"]/*' />
        public SqlParameter Add(SqlParameter value) {
            OnSchemaChanging();  // fire event before validation
            AddWithoutEvents((SqlParameter)value);
            //OnSchemaChanged();
            return value;
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add5"]/*' />
        public SqlParameter Add(string parameterName, object value) {
            return Add(new SqlParameter(parameterName, value));
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add2"]/*' />
        public SqlParameter Add(string parameterName, SqlDbType sqlDbType) {
            return Add(new SqlParameter(parameterName, sqlDbType));
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add3"]/*' />
        public SqlParameter Add(string parameterName, SqlDbType sqlDbType, int size) {
            return Add(new SqlParameter(parameterName, sqlDbType, size));
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Add4"]/*' />
        public SqlParameter Add(string parameterName, SqlDbType sqlDbType, int size, string sourceColumn) {
            return Add(new SqlParameter(parameterName, sqlDbType, size, sourceColumn));
        }

        /*public void AddRange(SqlParameter[] values) {
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }
            int length = values.Length;
            for (int i = 0; i < length; ++i) {
                ValidateType(values[i]);
            }
            for (int i = 0; i < length; ++i) {
                AddWithoutEvents(values[i]);
            }
        }*/

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.AddWithoutEvents"]/*' />
        private void AddWithoutEvents(SqlParameter value) {
            Validate(-1, value);
            value.Parent = this;
            ArrayList().Add(value);
        }

        // implemented as a method, not as a property because the VS7 debugger 
        // object browser calls properties to display their value, and we want this delayed
        private ArrayList ArrayList() {
            if (null == this.items) {
                this.items = new ArrayList();
            }
            return this.items;
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Contains"]/*' />
        public bool Contains(string value) {
            return (-1 != IndexOf(value));
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Contains1"]/*' />
        public bool Contains(object value) {
            return(-1 != IndexOf(value));
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Clear"]/*' />
        public void Clear() {
            if (0 < Count) {
                OnSchemaChanging();  // fire event before value is validated
                ClearWithoutEvents();
                //OnSchemaChanged();
            }
        }

        private void ClearWithoutEvents() { // also called by OleDbCommand.ResetParameters
            if (null != items) {
                int count = items.Count;
                for(int i = 0; i < count; ++i) {
                    ((SqlParameter) items[i]).Parent = null;
                }
                items.Clear();
            }
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            ArrayList().CopyTo(array, index);
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return  ArrayList().GetEnumerator();
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.IndexOf"]/*' />
        public int IndexOf(string parameterName) {
            if (null != items) {
                int count = items.Count;

                // We must search twice, first straight then insensitive, since parameter add no longer validates
                // uniqueness.  MDAC 66522
                
                // first case, kana, width sensitive search
                for (int i = 0; i < count; ++i) {
                    if (0 == ADP.SrcCompare(parameterName, ((SqlParameter) items[i]).ParameterName)) {
                        return i;
                    }
                }

                // then insensitive search
                for (int i = 0; i < count; ++i) {
                    if (0 == ADP.DstCompare(parameterName, ((SqlParameter) items[i]).ParameterName)) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.IndexOf1"]/*' />
        public int IndexOf(object value) {
            if (null != value) {
                ValidateType(value);
                if (null != items) {
                    int count = items.Count;
                    for (int i = 0; i < count; ++i) {
                        if (value == items[i]) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Insert"]/*' />
        public void Insert(int index, object value) {
            OnSchemaChanging();  // fire event before value is validated
            ValidateType(value);
            Validate(-1, (SqlParameter) value);
            ((SqlParameter) value).Parent = this;
            ArrayList().Insert(index, value);
            //OnSchemaChanged();
        }

        //internal void OnSchemaChanged() { // commented out because SqlCommand does nothing
        //    if (null != this.parent) {
        //        this.parent.OnSchemaChangedInternal(this);
        //    }
        //}

        internal void OnSchemaChanging() { // also called by SqlParameter.OnSchemaChanging
            if (null != this.parent) {
                this.parent.OnSchemaChanging();
            }
        }

        private void RangeCheck(int index) {
            if ((index < 0) || (Count <= index)) {
                throw ADP.ParametersMappingIndex(index, this);
            }
        }

        private int RangeCheck(string parameterName) {
            int index = IndexOf(parameterName);
            if (index < 0) {
                throw ADP.ParametersSourceIndex(parameterName, this, ItemType);
            }
            return index;
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            OnSchemaChanging(); // fire event before value is validated
            RangeCheck(index);
            RemoveIndex(index);
        }

        private void RemoveIndex(int index) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ((SqlParameter) items[index]).Parent = null;
            items.RemoveAt(index);
            //OnSchemaChangedInternal();
        }


        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.RemoveAt1"]/*' />
        public void RemoveAt(string parameterName) {
            OnSchemaChanging(); // fire event before value is validated
            int index = RangeCheck(parameterName);
            RemoveIndex(index);
        }

        /// <include file='doc\SqlParameterCollection.uex' path='docs/doc[@for="SqlParameterCollection.Remove"]/*' />
        public void Remove(object value) {
            OnSchemaChanging(); // fire event before value is validated
            ValidateType(value);
            int index = IndexOf((SqlParameter) value);
            if (-1 != index) {
                RemoveIndex(index);
            }
            else {
                throw ADP.CollectionRemoveInvalidObject(ItemType, this);
            }
        }

        private void Replace(int index, SqlParameter newValue) {
            Debug.Assert((null != items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            Validate(index, newValue);
            ((SqlParameter) items[index]).Parent = null;
            newValue.Parent = this;
            items[index] = newValue;
            //OnSchemaChanged();
        }

        private void ValidateType(object value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            else if (!ItemType.IsInstanceOfType(value)) {
                throw ADP.InvalidParameterType(this, ItemType, value);
            }
        }

        internal void Validate(int index, SqlParameter value) {
            if (null == value) {
                throw ADP.ParameterNull("value", this, ItemType);
            }
            if (null != value.Parent) {
                if (this != value.Parent) {
                    throw ADP.ParametersIsNotParent(ItemType, value.ParameterName, this);
                }
                else if (index != IndexOf(value)) {
                    throw ADP.ParametersIsParent(ItemType, value.ParameterName, this);
                }
            }
            String name = value.ParameterName;
            if (ADP.IsEmpty(name)) { // generate a ParameterName
                index = 1;
                do {
                    name = ADP.Parameter + index.ToString();
                    index++;
                } while (-1 != IndexOf(name));
                value.ParameterName = name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlparameterconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlParameterConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Data.Common;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\SQLParameterConverter.uex' path='docs/doc[@for="SqlParameterConverter"]/*' />
    /// <internalonly/>
    sealed internal class SqlParameterConverter : ExpandableObjectConverter {

        /// <include file='doc\SQLParameterConverter.uex' path='docs/doc[@for="SqlParameterConverter.CanConvertTo"]/*' />
        /// <internalonly/>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\SQLParameterConverter.uex' path='docs/doc[@for="SqlParameterConverter.ConvertTo"]/*' />
        /// <internalonly/>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw ADP.ArgumentNull("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is SqlParameter) {
                SqlParameter p = (SqlParameter)value;

                // MDAC 67321 - reducing parameter generated code
                int flags = 0; // if part of the collection - the parametername can't be empty

                if (SqlDbType.NVarChar != p.SqlDbType) {
                    flags |= 1;
                }
                if (0 != p.Size) {
                    flags |= 2;
                }
                if (!ADP.IsEmpty(p.SourceColumn)) {
                    flags |= 4;
                }
                if (null != p.Value) {
                    flags |= 8;
                }
                if ((ParameterDirection.Input != p.Direction) || p.IsNullable
                    || (0 != p.Precision) || (0 != p.Scale) || (DataRowVersion.Current != p.SourceVersion)) {
                    flags |= 16;
                }

                Type[] ctorParams;
                object[] ctorValues;
                switch(flags) {
                case  0: // ParameterName
                case  1: // SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(SqlDbType) };
                    ctorValues = new object[] { p.ParameterName, p.SqlDbType };
                    break;
                case  2: // Size
                case  3: // Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(SqlDbType), typeof(int) };
                    ctorValues = new object[] { p.ParameterName, p.SqlDbType, p.Size };
                    break;
                case  4: // SourceColumn
                case  5: // SourceColumn, SqlDbType
                case  6: // SourceColumn, Size
                case  7: // SourceColumn, Size, SqlDbType
                    ctorParams = new Type[] { typeof(string), typeof(SqlDbType), typeof(int), typeof(string) };
                    ctorValues = new object[] { p.ParameterName, p.SqlDbType, p.Size, p.SourceColumn };
                    break;
                case  8: // Value
                    ctorParams = new Type[] { typeof(string), typeof(object) };
                    ctorValues = new object[] { p.ParameterName, p.Value };
                    break;
                default:
                    ctorParams = new Type[] {
                        typeof(string), typeof(SqlDbType), typeof(int), typeof(ParameterDirection),
                        typeof(bool), typeof(byte), typeof(byte), typeof(string), 
                        typeof(DataRowVersion), typeof(object) };
                    ctorValues = new object[] {
                        p.ParameterName, p.SqlDbType,  p.Size, p.Direction,
                        p.IsNullable, p.Precision, p.Scale, p.SourceColumn,
                        p.SourceVersion, p.Value };
                    break;
                }
                ConstructorInfo ctor = typeof(SqlParameter).GetConstructor(ctorParams);
                if (null != ctor) {
                    return new InstanceDescriptor(ctor, ctorValues);
                }
            }            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlrecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
#if V2

namespace System.Data.SqlClient {

    using System.Data.SqlTypes;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Data.Common;

    /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    // IDataReader common functionality
    sealed public class SqlRecord : DbDataRecord, ISqlRecord {
        object[] _sqlValues;

        // copy all runtime data information
        internal SqlRecord(SchemaInfo[] schemaInfo, object[] sqlValues, object[] comValues, PropertyDescriptorCollection descriptors) 
            : base(schemaInfo, comValues, descriptors) {
            Debug.Assert(null != schemaInfo, "invalid attempt to instantiate DbDataRecord with null schema information");
            Debug.Assert(null != sqlValues, "invalid attempt to instantiate DbDataRecord with null value[]");
            _sqlValues = sqlValues;
        }
        
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlBit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlBit GetSqlBit(int i) {
            return (SqlBit) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlBinary"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlBinary GetSqlBinary(int i) {
            return (SqlBinary) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlByte"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlByte GetSqlByte(int i) {
            return (SqlByte) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlInt16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt16 GetSqlInt16(int i) {
            return (SqlInt16) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlInt32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt32 GetSqlInt32(int i) {
            return (SqlInt32) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlInt64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt64 GetSqlInt64(int i) {
            return (SqlInt64) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlSingle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlSingle GetSqlSingle(int i) {
            return (SqlSingle) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlDouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDouble GetSqlDouble(int i) {
            return (SqlDouble) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlString GetSqlString(int i) {
            return (SqlString) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlMoney"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlMoney GetSqlMoney(int i) {
            return (SqlMoney) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal GetSqlDecimal(int i) {
            return (SqlDecimal) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlDateTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime GetSqlDateTime(int i) {
            return (SqlDateTime) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlGuid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlGuid GetSqlGuid(int i) {
            return (SqlGuid) _sqlValues[i];
        }
        /// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object GetSqlValue(int i) {
            return _sqlValues[i];
        }
		/// <include file='doc\sqlrecord.uex' path='docs/doc[@for="SqlRecord.GetSqlValues"]/*' />
		/// <devdoc>
		///    <para>[To be supplied.]</para>
		/// </devdoc>
		public int GetSqlValues(object[] values)
		{
            if (null == values) {
                throw ADP.ArgumentNull("values");
            }

            int copyLen = (values.Length < _schemaInfo.Length) ? values.Length : _schemaInfo.Length;
            
            for (int i = 0; i < copyLen; i++) {                
                values[i] = _sqlValues[i];
            }                
            return copyLen;
		}
    }
}
#endif // V2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlenums.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlEnums.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Data.OleDb;

    internal class MetaType {
        private Type      classType;   // com+ type
        private int       fixedLength; // fixed length size in bytes (-1 for variable)
        private bool      isFixed;     // true if fixed length, note that sqlchar and sqlbinary are not considered fixed length
        private bool      isLong;      // true if long
        private byte      precision;   // maxium precision for numeric types // $CONSIDER - are we going to use this?
        private byte      scale; 
        private byte      tdsType;
        private string    typeName;    // string name of this type
        private SqlDbType sqlType;
        private DbType    dbType;

        public MetaType(byte precision, byte scale, int fixedLength, bool isFixed, bool isLong, byte tdsType, string typeName, Type classType, SqlDbType sqlType, DbType dbType) {
            this.Precision   = precision;
            this.Scale       = scale;
            this.FixedLength = fixedLength;
            this.IsFixed     = isFixed;
            this.IsLong      = isLong;
            // can we get rid of this (?just have a mapping?)
            this.TDSType     = tdsType;
            this.TypeName    = typeName;
            this.ClassType   = classType;
            this.SqlDbType   = sqlType;
            this.DbType      = dbType;
        }

        public SqlDbType SqlDbType {
            get {return this.sqlType;}
            set { this.sqlType = value;}
        }

        // properties should be inlined so there should be no perf penalty for using these accessor functions
        public Type ClassType {
            get { return this.classType;}
            set { this.classType = value;}
        }

        public DbType DbType {
            get { return this.dbType; }
            set { this.dbType = value; }
        }

        public int FixedLength {
            get { return this.fixedLength;}
            set { this.fixedLength = value;}
        }
        // properties should be inlined so there should be no perf penalty for using these accessor functions
        public bool IsFixed {
            get { return this.isFixed;}
            set { this.isFixed = value;}
        }
        // properties should be inlined so there should be no perf penalty for using these accessor functions
        public bool IsLong {
            get { return this.isLong;}
            set { this.isLong = value;}
        }

        public static bool IsAnsiType(SqlDbType type) {
            return(type == SqlDbType.Char ||
                   type == SqlDbType.VarChar ||
                   type == SqlDbType.Text);
        }

        // is this type size expressed as count of characters or bytes?
        public static bool IsSizeInCharacters(SqlDbType type) {
            return(type == SqlDbType.NChar ||
                   type == SqlDbType.NVarChar ||
                   type == SqlDbType.NText);
        }                   

        public static bool IsCharType(SqlDbType type) {
            return(type == SqlDbType.NChar ||
                   type == SqlDbType.NVarChar ||
                   type == SqlDbType.NText ||
                   type == SqlDbType.Char ||
                   type == SqlDbType.VarChar ||
                   type == SqlDbType.Text);
        }                   

        public static bool IsBinType(SqlDbType type) {
            return(type == SqlDbType.Image ||
                   type == SqlDbType.Binary ||
                   type == SqlDbType.VarBinary ||
                   type == SqlDbType.Timestamp ||
                   (int) type == 24 /*SqlSmallVarBinary*/);
        }

        // properties should be inlined so there should be no perf penalty for using these accessor functions
        public byte Precision {
            get { return this.precision;}
            set { this.precision = value;}
        }

        public byte Scale {
            get { return this.scale;}
            set { this.scale = value;}
        }

        public byte TDSType {
            get {return this.tdsType;}
            set {this.tdsType = value;}
        }

        public string TypeName {
            get { return this.typeName;}
            set { this.typeName = value;}
        }

        virtual public byte NullableType {
            get { return this.tdsType;}
        }

        //
        //  returns count of property bytes expected for this in
        //  a SQLVariant structure
        //
        virtual public byte PropBytes {
            get { return 0;}
        }

        //
        // UNDONE: rename to something more useful
        //
        virtual public Type SqlType {
            get { return this.ClassType;}
        }            

        // please leave grid in same sort order as SqlDataTypeEnum
        // the enum and this array must be in ssync
        // and same order of enum
        internal static readonly MetaType[] metaTypeMap = new MetaType[] {
            new MetaBigInt(),        // 0
            new MetaBinary(),        // 1        
            new MetaBit(),           // 2
            new MetaChar(),          // 3
            new MetaDateTime(),      // 4
            new MetaDecimal(),       // 5
            new MetaFloat(),         // 6
            new MetaImage(),         // 7
            new MetaInt(),           // 8
            new MetaMoney(),         // 9
            new MetaNChar(),         // 10
            new MetaNText(),         // 11
            new MetaNVarChar(),      // 12
            new MetaReal(),          // 13
            new MetaUniqueId(),      // 14
            new MetaSmallDateTime(), // 15
            new MetaSmallInt(),      // 16
            new MetaSmallMoney(),    // 17
            new MetaText(),          // 18
            new MetaTimestamp(),     // 19
            new MetaTinyInt(),       // 20
            new MetaVarBinary(),     // 21
            new MetaVarChar(),       // 22
            new MetaVariant(),       // 23
            new MetaSmallVarBinary() // 24
        };

        //
        // map SqlDbType to MetaType class
        //
        internal static MetaType GetMetaType(SqlDbType target) {
            return metaTypeMap[(int)target];
        }

        //
        // map DbType to MetaType class
        //
        internal static MetaType GetMetaType(DbType target) {
            // if we can't map it, we need to throw
            MetaType mt = null;
            
            switch (target) {
                case DbType.AnsiString:
                    mt = metaTypeMap[(int)SqlDbType.VarChar];
                    break;
                case DbType.AnsiStringFixedLength:
                    mt = metaTypeMap[(int)SqlDbType.Char];
                    break;
                case DbType.Binary:
                    mt = metaTypeMap[(int)SqlDbType.VarBinary];
                    break;
                case DbType.Byte:
                    mt = metaTypeMap[(int)SqlDbType.TinyInt];
                    break;
                case DbType.Boolean:
                    mt = metaTypeMap[(int)SqlDbType.Bit];
                    break;
                case DbType.Currency:
                    mt = metaTypeMap[(int)SqlDbType.Money];
                    break;
                case DbType.Date:
                case DbType.DateTime:
                    mt = metaTypeMap[(int)SqlDbType.DateTime];
                    break;
                case DbType.Decimal:
                    mt = metaTypeMap[(int)SqlDbType.Decimal];
                    break;
                case DbType.Double:
                    mt = metaTypeMap[(int)SqlDbType.Float];
                    break;
                case DbType.Guid:
                    mt = metaTypeMap[(int)SqlDbType.UniqueIdentifier];
                    break;
                case DbType.Int16:
                    mt = metaTypeMap[(int)SqlDbType.SmallInt];
                    break;
                case DbType.Int32:
                    mt = metaTypeMap[(int)SqlDbType.Int];
                    break;
                case DbType.Int64:
                    mt = metaTypeMap[(int)SqlDbType.BigInt];
                    break;
                case DbType.Object:
                    mt = metaTypeMap[(int)SqlDbType.Variant];
                    break;
                case DbType.SByte:
                    // unsupported
                    break;
                case DbType.Single:
                    mt = metaTypeMap[(int)SqlDbType.Real];
                    break;
                case DbType.String:
                    mt = metaTypeMap[(int)SqlDbType.NVarChar];
                    break;
                case DbType.StringFixedLength:
                    mt = metaTypeMap[(int)SqlDbType.NChar];
                    break;
                case DbType.Time:
                    mt = metaTypeMap[(int)SqlDbType.DateTime];
                    break;
                case DbType.UInt16:
                case DbType.UInt32:
                case DbType.UInt64:
                case DbType.VarNumeric:
                    // unsupported
                    break;
                default:
                    break; // no direct mapping, error out
            } // switch

            // if there is no SqlDbType for this DbType, then let error
            if (null == mt)
               throw ADP.DbTypeNotSupported(target, typeof(SqlDbType));

            return mt;
        }            

        //
        // map COM+ Type to MetaType class
        //
        static internal MetaType GetMetaType(object value) {
            Type dataType;
            bool inferLen = false;

            if (value is Type) {
                dataType = (Type)value;                
            }
            else {
                dataType = value.GetType();
                inferLen = true;
            }
            
            switch (Type.GetTypeCode(dataType)) {
                case TypeCode.Empty:     throw ADP.InvalidDataType(TypeCode.Empty);
                case TypeCode.Object:
                    if (dataType == typeof(System.Byte[])) {
                        if (inferLen && ((byte[]) value).Length <= TdsEnums.TYPE_SIZE_LIMIT) {
                            return metaTypeMap[(int)SqlDbType.VarBinary];
                        }
                        else {
                            return metaTypeMap[(int)SqlDbType.Image];
                        }
                    }
                    else if (dataType == typeof(System.Guid)) {
                        return metaTypeMap[(int)SqlDbType.UniqueIdentifier];
                    }
                    else if (dataType == typeof(System.Object)) {
                        return metaTypeMap[(int)SqlDbType.Variant];
                    } // check sql types now
                    else if (dataType == typeof(SqlBinary))
                        return metaTypeMap[(int)SqlDbType.VarBinary];
                    else if (dataType == typeof(SqlBoolean))
                        return metaTypeMap[(int)SqlDbType.Bit];
                    else if (dataType == typeof(SqlBoolean))
                        return metaTypeMap[(int)SqlDbType.Bit];
                    else if (dataType == typeof(SqlByte))
                        return metaTypeMap[(int)SqlDbType.TinyInt];
                    else if (dataType == typeof(SqlDateTime))
                        return metaTypeMap[(int)SqlDbType.DateTime];
                    else if (dataType == typeof(SqlDouble))
                        return metaTypeMap[(int)SqlDbType.Float];
                    else if (dataType == typeof(SqlGuid))
                        return metaTypeMap[(int)SqlDbType.UniqueIdentifier];
                    else if (dataType == typeof(SqlInt16))
                        return metaTypeMap[(int)SqlDbType.SmallInt];
                    else if (dataType == typeof(SqlInt32))
                        return metaTypeMap[(int)SqlDbType.Int];
                    else if (dataType == typeof(SqlInt64))
                        return metaTypeMap[(int)SqlDbType.BigInt];
                    else if (dataType == typeof(SqlMoney))
                        return metaTypeMap[(int)SqlDbType.Money];
                    else if (dataType == typeof(SqlDecimal))
                        return metaTypeMap[(int)SqlDbType.Decimal];
                    else if (dataType == typeof(SqlSingle))
                        return metaTypeMap[(int)SqlDbType.Real];
                    else if (dataType == typeof(SqlString)) {
                        if (((SqlString) value).IsNull) {
                            // If null, set type to NVarChar and do not call .Value for PromoteStringType
                            return metaTypeMap[(int)SqlDbType.NVarChar];
                        }
                        return (inferLen ? PromoteStringType(((SqlString)value).Value) : metaTypeMap[(int)SqlDbType.NVarChar]);
                    }
                       
                    throw ADP.UnknownDataType(dataType);

                case TypeCode.DBNull:    throw ADP.InvalidDataType(TypeCode.DBNull);
                case TypeCode.Boolean:   return metaTypeMap[(int)SqlDbType.Bit];
                case TypeCode.Char:      throw ADP.InvalidDataType(TypeCode.Char);
                case TypeCode.SByte:     throw ADP.InvalidDataType(TypeCode.SByte);
                case TypeCode.Byte:      return metaTypeMap[(int)SqlDbType.TinyInt];
                case TypeCode.Int16:     return metaTypeMap[(int)SqlDbType.SmallInt];
                case TypeCode.UInt16:    throw ADP.InvalidDataType(TypeCode.UInt16);
                case TypeCode.Int32:     return metaTypeMap[(int)SqlDbType.Int];
                case TypeCode.UInt32:    throw ADP.InvalidDataType(TypeCode.UInt32);
                case TypeCode.Int64:     return metaTypeMap[(int)SqlDbType.BigInt];
                case TypeCode.UInt64:    throw ADP.InvalidDataType(TypeCode.UInt64);
                case TypeCode.Single:    return metaTypeMap[(int)SqlDbType.Real];
                case TypeCode.Double:    return metaTypeMap[(int)SqlDbType.Float];
                case TypeCode.Decimal:   return metaTypeMap[(int)SqlDbType.Decimal];
                case TypeCode.DateTime:  return metaTypeMap[(int)SqlDbType.DateTime];
                case TypeCode.String:  return (inferLen ? PromoteStringType((string)value) : metaTypeMap[(int)SqlDbType.NVarChar]);
                default:              throw ADP.UnknownDataTypeCode(dataType, Type.GetTypeCode(dataType));
            }
        }

        internal static MetaType PromoteStringType(string s) {
            int len = s.Length;
            
            if ((len << 1) > TdsEnums.TYPE_SIZE_LIMIT) {
                return metaTypeMap[(int)SqlDbType.VarChar]; // try as var char since we can send a 8K characters
            }                
                
            return metaTypeMap[(int)SqlDbType.NVarChar]; // send 4k chars, but send as unicode
        }
        internal static object GetComValue(SqlDbType type, object sqlVal) {
            object comVal = DBNull.Value;
            
            // check nullable (remember the sql_variant null will be DBNull.Value)
            Debug.Assert(null != sqlVal, "invalid <null>, should be DBNull.Value");
            if (Convert.IsDBNull(sqlVal) || ((INullable)sqlVal).IsNull) 
                return comVal;
                
            switch (type) {
                case SqlDbType.BigInt:
                    comVal = ((SqlInt64)sqlVal).Value;
                    break;
                case SqlDbType.Binary:
                case SqlDbType.Timestamp:
                case SqlDbType.Image:
                case SqlDbType.VarBinary:
                    // HACK!!!  We have an internal type for smallvarbinarys stored on TdsEnums.  We
                    // store on TdsEnums instead of SqlDbType because we do not want to expose 
                    // this type to the user!
                case TdsEnums.SmallVarBinary:
                    comVal = ((SqlBinary)sqlVal).Value;
                    break;
                case SqlDbType.Bit:
                    comVal = ((SqlBoolean)sqlVal).Value;
                    break;
                case SqlDbType.Char:
                case SqlDbType.VarChar:
                case SqlDbType.Text:
                case SqlDbType.NChar:
                case SqlDbType.NVarChar:
                case SqlDbType.NText:
                    comVal = ((SqlString)sqlVal).Value;
                    break;
                case SqlDbType.DateTime:
                case SqlDbType.SmallDateTime:
                    comVal = ((SqlDateTime)sqlVal).Value;
                    break;
                case SqlDbType.Money:
                case SqlDbType.SmallMoney:
                    comVal = ((SqlMoney)sqlVal).Value;
                    break;
                case SqlDbType.Real:
                    comVal = ((SqlSingle)sqlVal).Value;
                    break;
                case SqlDbType.Float:
                    comVal = ((SqlDouble)sqlVal).Value;
                    break;
                case SqlDbType.Decimal:
                    comVal = ((SqlDecimal)sqlVal).Value;
                    break;
                case SqlDbType.Int:
                    comVal = ((SqlInt32)sqlVal).Value;
                    break;
                case SqlDbType.SmallInt:
                    comVal = ((SqlInt16)sqlVal).Value;
                    break;
                case SqlDbType.TinyInt:
                    comVal = ((SqlByte)sqlVal).Value;
                    break;
                case SqlDbType.UniqueIdentifier:
                    comVal = ((SqlGuid)sqlVal).Value;
                    break;
                case SqlDbType.Variant:
                    comVal = MetaType.GetComValueFromSqlVariant(sqlVal);
                    break;
                default:
                    Debug.Assert(false, "unknown SqlDbType!  Can't create SQL type");
                    break;
            }       

            return comVal;
        }
        
        internal static object GetSqlValue(_SqlMetaData metaData, object comVal) {
            SqlDbType type = metaData.type;
            object sqlVal = null;
            bool isNull = (comVal == null) || (Convert.IsDBNull(comVal));
            switch (type) {
                case SqlDbType.BigInt:
                    sqlVal = isNull ? SqlInt64.Null : new SqlInt64((Int64)comVal);
                    break;
                case SqlDbType.Binary:
                case SqlDbType.Timestamp:
                case SqlDbType.Image:
                case SqlDbType.VarBinary:
                    // HACK!!!  We have an internal type for smallvarbinarys stored on TdsEnums.  We
                    // store on TdsEnums instead of SqlDbType because we do not want to expose 
                    // this type to the user!
                case TdsEnums.SmallVarBinary:
                    sqlVal = isNull ? SqlBinary.Null : new SqlBinary((byte[])comVal);
                    break;
                case SqlDbType.Bit:
                    sqlVal = isNull ? SqlBoolean.Null : new SqlBoolean((bool)comVal);
                    break;
                case SqlDbType.Char:
                case SqlDbType.VarChar:
                case SqlDbType.Text:
                case SqlDbType.NChar:
                case SqlDbType.NVarChar:
                case SqlDbType.NText:
                    if (isNull) {
                        sqlVal = SqlString.Null;
                    }
                    else {
                        if (null != metaData.collation) {
                            int lcid = TdsParser.Getlcid(metaData.collation);
                            SqlCompareOptions options = TdsParser.GetSqlCompareOptions(metaData.collation);                
                            sqlVal = new SqlString((string)comVal, lcid, options);
                        }
                        else {
                            sqlVal = new SqlString((string)comVal);
                        }
                    }
                    break;
                case SqlDbType.DateTime:
                case SqlDbType.SmallDateTime:
                    sqlVal = isNull ? SqlDateTime.Null : new SqlDateTime((DateTime)comVal);
                    break;
                case SqlDbType.Money:
                case SqlDbType.SmallMoney:
                    sqlVal = isNull ? SqlMoney.Null : new SqlMoney((Decimal)comVal);
                    break;
                case SqlDbType.Real:
                    sqlVal = isNull ? SqlSingle.Null : new SqlSingle((float)comVal);                    
                    break;
                case SqlDbType.Float:
                    sqlVal = isNull ? SqlDouble.Null : new SqlDouble((double)comVal);                    
                    break;
                case SqlDbType.Decimal:
                    sqlVal = isNull ? SqlDecimal.Null : new SqlDecimal((decimal)comVal);                    
                    break;
                case SqlDbType.Int:
                    sqlVal = isNull ? SqlInt32.Null : new SqlInt32((int)comVal);                    
                    break;
                case SqlDbType.SmallInt:
                    sqlVal = isNull ? SqlInt16.Null : new SqlInt16((Int16)comVal);                    
                    break;
                case SqlDbType.TinyInt:
                    sqlVal = isNull ? SqlByte.Null : new SqlByte((byte)comVal);                    
                    break;
                case SqlDbType.UniqueIdentifier:
                    sqlVal = isNull ? SqlGuid.Null : new SqlGuid((Guid)comVal);                    
                    break;
                case SqlDbType.Variant:
                    sqlVal = isNull ? DBNull.Value : MetaType.GetSqlValueFromComVariant(comVal);
                    break;
                default:
                    Debug.Assert(false, "unknown SqlDbType!  Can't create SQL type");
                    break;
            }       

            return sqlVal;
        }
        
        
        internal static object GetComValueFromSqlVariant(object sqlVal) {
            object comVal = null;

            if (sqlVal is SqlSingle)
                comVal = ((SqlSingle)sqlVal).Value;
            else if (sqlVal is SqlString)
                comVal = ((SqlString)sqlVal).Value;
            else if (sqlVal is SqlDouble)
                comVal = ((SqlDouble)sqlVal).Value;
            else if (sqlVal is SqlBinary)
                comVal = ((SqlBinary)sqlVal).Value;
            else if (sqlVal is SqlGuid)
                comVal = ((SqlGuid)sqlVal).Value;
            else if (sqlVal is SqlBoolean)
                comVal = ((SqlBoolean)sqlVal).Value;
            else if (sqlVal is SqlByte)
                comVal = ((SqlByte)sqlVal).Value;
            else if (sqlVal is SqlInt16)
                comVal = ((SqlInt16)sqlVal).Value;
            else if (sqlVal is SqlInt32)
                comVal = ((SqlInt32)sqlVal).Value;
            else if (sqlVal is SqlInt64)
                comVal = ((SqlInt64)sqlVal).Value;
            else if (sqlVal is SqlDecimal)
                comVal = ((SqlDecimal)sqlVal).Value;
            else if (sqlVal is SqlDateTime)
                comVal = ((SqlDateTime)sqlVal).Value;
            else if (sqlVal is SqlMoney)
                comVal = ((SqlMoney)sqlVal).Value;
            else
                Debug.Assert(false, "unknown SqlType class stored in sqlVal");

            return comVal;
        }            
        
        internal static object GetSqlValueFromComVariant(object comVal) {
            object sqlVal = null;

            if (comVal is float)
                sqlVal = new SqlSingle((float)comVal);
            else if (comVal is string)
                sqlVal = new SqlString((string)comVal);
            else if (comVal is double)
                sqlVal = new SqlDouble((double)comVal);
            else if (comVal is System.Byte[])
                sqlVal = new SqlBinary((byte[])comVal);
            else if (comVal is System.Guid)
                sqlVal = new SqlGuid((Guid)comVal);
            else if (comVal is bool)
                sqlVal = new SqlBoolean((bool)comVal);
            else if (comVal is byte)
                sqlVal = new SqlByte((byte)comVal);
            else if (comVal is Int16)
                sqlVal = new SqlInt16((Int16)comVal);
            else if (comVal is Int32)
                sqlVal = new SqlInt32((Int32)comVal);
            else if (comVal is Int64)
                sqlVal = new SqlInt64((Int64)comVal);
            else if (comVal is Decimal)
                sqlVal = new SqlDecimal((Decimal)comVal);
            else if (comVal is DateTime)
                sqlVal = new SqlDateTime((DateTime)comVal);
            else
                Debug.Assert(false, "unknown SqlType class stored in sqlVal");

            return sqlVal;
        }            

        internal static SqlDbType GetSqlDbTypeFromOleDbType(short dbType, string typeName) {
            SqlDbType sqlType = SqlDbType.Variant;
            switch ((OleDbType)dbType) {
                case OleDbType.BigInt:
                    sqlType = SqlDbType.BigInt;
                    break;
                case OleDbType.Boolean:
                    sqlType = SqlDbType.Bit;
                    break;
                case OleDbType.Char:
                case OleDbType.VarChar:
                    // these guys are ambiguous - server sends over DBTYPE_STR in both cases
                    sqlType = (typeName == MetaTypeName.CHAR) ? SqlDbType.Char : SqlDbType.VarChar;
                    break;
                case OleDbType.Currency:
                    sqlType = (typeName == MetaTypeName.MONEY) ? SqlDbType.Money : SqlDbType.SmallMoney;
                    break;
                case OleDbType.Date:
                case OleDbType.DBTime:
                case OleDbType.DBDate:
                case OleDbType.DBTimeStamp:
                case OleDbType.Filetime:
                    sqlType = (typeName == MetaTypeName.DATETIME) ? SqlDbType.DateTime : SqlDbType.SmallDateTime;
                    break;
                case OleDbType.Decimal:
                case OleDbType.Numeric:
                    sqlType = SqlDbType.Decimal;
                    break;
                case OleDbType.Double:
                    sqlType = SqlDbType.Float;
                    break;
                case OleDbType.Guid:
                    sqlType = SqlDbType.UniqueIdentifier;
                    break;
                case OleDbType.Integer:
                    sqlType = SqlDbType.Int;
                    break;
                case OleDbType.LongVarBinary:
                    sqlType = SqlDbType.Image;
                    break;
                case OleDbType.LongVarChar:
                    sqlType = SqlDbType.Text;
                    break;
                case OleDbType.LongVarWChar:
                    sqlType = SqlDbType.NText;
                    break;
                case OleDbType.Single:
                    sqlType = SqlDbType.Real;
                    break;
                case OleDbType.SmallInt:
                case OleDbType.UnsignedSmallInt:
                    sqlType = SqlDbType.SmallInt;
                    break;
                case OleDbType.TinyInt:
                case OleDbType.UnsignedTinyInt:
                    sqlType = SqlDbType.TinyInt;
                    break;
                case OleDbType.VarBinary:
                case OleDbType.Binary:
                    sqlType = (typeName == MetaTypeName.BINARY) ? SqlDbType.Binary : SqlDbType.VarBinary;
                    break;
                case OleDbType.Variant:
                    sqlType = SqlDbType.Variant;
                    break;
                case OleDbType.VarWChar:
                case OleDbType.WChar:
                case OleDbType.BSTR:
                    // these guys are ambiguous - server sends over DBTYPE_WSTR in both cases
                    // BSTR is always assumed to be NVARCHAR
                    sqlType = (typeName == MetaTypeName.NCHAR) ? SqlDbType.NChar : SqlDbType.NVarChar;
                    break;
                default:
                    break; // no direct mapping, just use SqlDbType.Variant;
                }

                return sqlType;
        }

        internal static SqlDbType GetSqlDataType(int tdsType, int userType, int length) {
           SqlDbType type = SqlDbType.Variant;

            // deal with nullable types
            switch (tdsType) {
                case TdsEnums.SQLMONEYN:
                    tdsType = (length == 4 ? TdsEnums.SQLMONEY4 : TdsEnums.SQLMONEY);
                    break;
                case TdsEnums.SQLDATETIMN:
                    tdsType = (length == 4 ? TdsEnums.SQLDATETIM4 : TdsEnums.SQLDATETIME);
                    break;
                case TdsEnums.SQLINTN:
                    if (length == 1)
                        tdsType = TdsEnums.SQLINT1;
                    else
                        if (length == 2)
                        tdsType = TdsEnums.SQLINT2;
                    else
                        if (length == 4)
                        tdsType = TdsEnums.SQLINT4;
                    else {
                        Debug.Assert(8 == length, "invalid length for SQLINTN");
                        tdsType = TdsEnums.SQLINT8;
                    }
                    break;
                case TdsEnums.SQLFLTN:
                    tdsType = (length == 4 ? TdsEnums.SQLFLT4 : TdsEnums.SQLFLT8);
                    break;
            }

            // since we dealt with var-len types, drop down into realy worker
            switch (tdsType) {
                case TdsEnums.SQLVOID:
                    Debug.Assert(false, "Unexpected SQLVOID type");
                    break;
                case TdsEnums.SQLTEXT:
                    type = SqlDbType.Text;
                    break;
                case TdsEnums.SQLVARBINARY:
                    // HACK!!!  We have an internal type for smallvarbinarys stored on TdsEnums.  We
                    // store on TdsEnums instead of SqlDbType because we do not want to expose 
                    // this type to the user!
                    type = TdsEnums.SmallVarBinary;
                    break;
                case TdsEnums.SQLBIGVARBINARY:
                    type = SqlDbType.VarBinary;
                    break;
                case TdsEnums.SQLVARCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                    type = SqlDbType.VarChar;
                    break;
                case TdsEnums.SQLBINARY:
                case TdsEnums.SQLBIGBINARY:
                    if (userType == TdsEnums.SQLTIMESTAMP)
                        type = SqlDbType.Timestamp;
                    else                        
                        type = SqlDbType.Binary;
                    break;
                case TdsEnums.SQLIMAGE:
                    type = SqlDbType.Image;
                    break;
                case TdsEnums.SQLCHAR:
                case TdsEnums.SQLBIGCHAR:
                    type = SqlDbType.Char;
                    break;
                case TdsEnums.SQLINT1:
                    type = SqlDbType.TinyInt;
                    break;
                case TdsEnums.SQLBIT:
                case TdsEnums.SQLBITN:
                    type = SqlDbType.Bit;
                    break;
                case TdsEnums.SQLINT2:
                    type = SqlDbType.SmallInt;
                    break;
                case TdsEnums.SQLINT4:
                    type = SqlDbType.Int;
                    break;
                case TdsEnums.SQLINT8:
                    type = SqlDbType.BigInt;
                    break;
                case TdsEnums.SQLMONEY:
                    type = SqlDbType.Money;
                    break;
                case TdsEnums.SQLDATETIME:
                    type = SqlDbType.DateTime;
                    break;
                case TdsEnums.SQLFLT8:
                    type = SqlDbType.Float;
                    break;
                case TdsEnums.SQLFLT4:
                    type = SqlDbType.Real;
                    break;
                case TdsEnums.SQLMONEY4:
                    type = SqlDbType.SmallMoney;
                    break;
                case TdsEnums.SQLDATETIM4:
                    type = SqlDbType.SmallDateTime;
                    break;
                case TdsEnums.SQLDECIMALN:
                case TdsEnums.SQLNUMERICN:
                    type = SqlDbType.Decimal;
                    break;
                case TdsEnums.SQLUNIQUEID:
                    type = SqlDbType.UniqueIdentifier;
                    break;
                case TdsEnums.SQLNCHAR:
                    type = SqlDbType.NChar;
                    break;
                case TdsEnums.SQLNVARCHAR:
                    type = SqlDbType.NVarChar;
                    break;
                case TdsEnums.SQLNTEXT:
                    type = SqlDbType.NText;
                    break;
                case TdsEnums.SQLVARIANT:
                    type = SqlDbType.Variant;
                    break;
                default:
                    Debug.Assert(false, "Unknown type " + tdsType.ToString());
                    break;
            }// case

            return type;
        } // GetSqlDataType

        internal static MetaType GetDefaultMetaType() {
            return metaTypeMap[(int)SqlDbType.NVarChar];
        }
    }//MetaType

    sealed internal class MetaBigInt : MetaType {
        public MetaBigInt()
        :base(19, 255, 8, true, false, TdsEnums.SQLINT8, MetaTypeName.BIGINT, typeof(System.Int64), SqlDbType.BigInt, DbType.Int64) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLINTN;}
        }

        override public Type SqlType {
            get { return typeof(SqlInt64);}
        }            

    }

    sealed internal class MetaFloat : MetaType {
        public MetaFloat()
        :base(15, 255, 8, true, false, TdsEnums.SQLFLT8, MetaTypeName.FLOAT, typeof(System.Double), SqlDbType.Float, DbType.Double) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLFLTN;}
        }

        override public Type SqlType {
            get { return typeof(SqlDouble);}
        }            

    }

    sealed internal class MetaReal : MetaType {
        public MetaReal()
        :base(7, 255, 4, true, false, TdsEnums.SQLFLT4, MetaTypeName.REAL, typeof(System.Single), SqlDbType.Real, DbType.Single) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLFLTN;}
        }
        override public Type SqlType {
            get { return typeof(SqlSingle);}
        }            
    }

    internal class MetaBinary : MetaType {
        public MetaBinary()
        : base (255, 255, -1, false, false, TdsEnums.SQLBIGBINARY, MetaTypeName.BINARY, typeof(System.Byte[]), SqlDbType.Binary, DbType.Binary) {
        }

        // MetaVariant has two bytes of properties for binary and varbinary
        // 2 byte maxlen
        override public byte PropBytes {
            get { return 2;}
        }
        
        override public Type SqlType {
            get { return typeof(SqlBinary);}
        }            
        
    }

    // syntatic sugar for the user...timestamps are 8-byte fixed length binary columns
    sealed internal class MetaTimestamp : MetaBinary {
        public MetaTimestamp() {
            // same as Binary except ...
            SqlDbType = SqlDbType.Timestamp;
            TypeName = MetaTypeName.TIMESTAMP;
        }
    }

    sealed internal class MetaVarBinary : MetaBinary {
        public MetaVarBinary() {
            // same as Binary except ...
            TDSType = TdsEnums.SQLBIGVARBINARY;
            TypeName = MetaTypeName.VARBINARY;
            SqlDbType = SqlDbType.VarBinary;
            DbType = DbType.Binary;
        }
    }

    sealed internal class MetaSmallVarBinary : MetaBinary {
        public MetaSmallVarBinary() {
            // same as Binary except ...
            TDSType = TdsEnums.SQLVARBINARY;
            TypeName = String.Empty;
            // HACK!!!  We have an internal type for smallvarbinarys stored on TdsEnums.  We
            // store on TdsEnums instead of SqlDbType because we do not want to expose 
            // this type to the user!
            SqlDbType = TdsEnums.SmallVarBinary;
        }
    }

    sealed internal class MetaImage : MetaType {
        public MetaImage()
        : base (255, 255, -1, false, true, TdsEnums.SQLIMAGE, MetaTypeName.IMAGE, typeof(System.Byte[]), SqlDbType.Image, DbType.Binary) {
        }
        
        override public Type SqlType {
            get { return typeof(SqlBinary);}
        }            
    }

    sealed internal class MetaBit : MetaType {
        public MetaBit()
        : base (255, 255, 1, true, false, TdsEnums.SQLBIT, MetaTypeName.BIT, typeof(System.Boolean), SqlDbType.Bit, DbType.Boolean) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLBITN;}
        }

        override public Type SqlType {
            get { return typeof(SqlBoolean);}
        }            
    }

    sealed internal class MetaTinyInt : MetaType {
        public MetaTinyInt()
        : base (3, 255, 1, true, false, TdsEnums.SQLINT1, MetaTypeName.TINYINT, typeof(System.Byte), SqlDbType.TinyInt, DbType.Byte) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLINTN;}
        }

        override public Type SqlType {
            get { return typeof(SqlByte);}
        }            
    }

    sealed internal class MetaSmallInt : MetaType {
        public MetaSmallInt()
        : base (5, 255, 2, true, false, TdsEnums.SQLINT2, MetaTypeName.SMALLINT, typeof(System.Int16), SqlDbType.SmallInt, DbType.Int16) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLINTN;}
        }

        override public Type SqlType {
            get { return typeof(SqlInt16);}
        }            

    }

    sealed internal class MetaInt : MetaType {
        public MetaInt()
        : base (10, 255, 4, true, false, TdsEnums.SQLINT4, MetaTypeName.INT, typeof(System.Int32), SqlDbType.Int, DbType.Int32) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLINTN;}
        }

        override public Type SqlType {
            get { return typeof(SqlInt32);}
        }            

    }

    internal class MetaChar : MetaType {
        public MetaChar()
        : base(255, 255, -1, false, false, TdsEnums.SQLBIGCHAR, MetaTypeName.CHAR, typeof(System.String), SqlDbType.Char, DbType.AnsiStringFixedLength) {
        }

        // MetaVariant has seven bytes of properties for MetaChar and MetaVarChar
        // 5 byte tds collation
        // 2 byte maxlen
        override public byte PropBytes {
            get { return 7;}
        }

        override public Type SqlType {
            get { return typeof(SqlString);}
        }            
    }

    sealed internal class MetaVarChar : MetaChar {
        public MetaVarChar() {
            // same as char except
            TDSType = TdsEnums.SQLBIGVARCHAR;
            TypeName = MetaTypeName.VARCHAR;
            SqlDbType = SqlDbType.VarChar;
            DbType = DbType.AnsiString;
        }

    }

    internal class MetaText : MetaType {
        public MetaText()
        : base(255, 255, -1, false, true, TdsEnums.SQLTEXT, MetaTypeName.TEXT, typeof(System.String), SqlDbType.Text, DbType.AnsiString) {
        }

        override public Type SqlType {
            get { return typeof(SqlString);}
        }            

    }

    internal class MetaNChar : MetaType {
        public MetaNChar()
        : base(255, 255, -1, false, false, TdsEnums.SQLNCHAR, MetaTypeName.NCHAR, typeof(System.String), SqlDbType.NChar, DbType.StringFixedLength) {
        }

        // MetaVariant has seven bytes of properties for MetaNChar and MetaNVarChar
        // 5 byte tds collation
        // 2 byte maxlen
        override public byte PropBytes {
            get { return 7;}
        }

        override public Type SqlType {
            get { return typeof(SqlString);}
        }            
    }

    sealed internal class MetaNVarChar : MetaNChar {
        public MetaNVarChar() {
            // same as NChar except...
            TDSType = TdsEnums.SQLNVARCHAR;
            TypeName = MetaTypeName.NVARCHAR;
            SqlDbType = SqlDbType.NVarChar;
            DbType = DbType.String;
        }
    }

    sealed internal class MetaNText : MetaNChar {
        public MetaNText() {
            // same as NChar except...
            IsLong = true;
            TDSType = TdsEnums.SQLNTEXT;
            TypeName = MetaTypeName.NTEXT;
            SqlDbType = SqlDbType.NText;            
            DbType = DbType.String;
        }
    }

    internal class MetaDecimal : MetaType {
        public MetaDecimal()
        : base(38, 4, 17, true, false, TdsEnums.SQLNUMERICN, MetaTypeName.DECIMAL, typeof(System.Decimal), SqlDbType.Decimal, DbType.Decimal) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLNUMERICN;}
        }

        // MetaVariant has two bytes of properties for numeric/decimal types
        // 1 byte precision
        // 1 byte scale
        override public byte PropBytes {
            get { return 2;}
        }

        override public Type SqlType {
            get { return typeof(SqlDecimal);}
        }            


    }

    /*
    // Why expose both decimal and numeric?
    sealed internal class MetaNumeric : MetaDecimal {
        public MetaNumeric() {
            // same as Decimal except...
            TDSType = TdsEnums.SQLNUMERICN;
            TypeName = MetaTypeName.NUMERIC;
            Precision = 9;
            Scale = 0;
        }
    }
    */

    //
    // note: it is the client's responsibility to know what size date time he is working with
    //
    internal struct TdsDateTime {
        public int days;  // offset in days from 1/1/1900
        //     private UInt32 time;  // if smalldatetime, this is # of minutes since midnight
        // otherwise: # of 1/300th of a second since midnight
        public int time; // UNDONE, use UInt32 when available! (0716 compiler??)
    }

    internal class MetaDateTime : MetaType {

        public MetaDateTime()
        : base(23, 3, 8, true, false, TdsEnums.SQLDATETIME, MetaTypeName.DATETIME, typeof(System.DateTime), SqlDbType.DateTime, DbType.DateTime) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLDATETIMN;}
        }

        override public Type SqlType {
            get { return typeof(SqlDateTime);}
        }            

        public static TdsDateTime FromDateTime(DateTime comDateTime, byte cb) {
            SqlDateTime sqlDateTime = new SqlDateTime(comDateTime);
            TdsDateTime tds = new TdsDateTime();

            Debug.Assert(cb == 8 || cb == 4, "Invalid date time size!");
            tds.days = sqlDateTime.DayTicks;

            if (cb == 8)
                tds.time = sqlDateTime.TimeTicks;
            else
                tds.time = sqlDateTime.TimeTicks / SqlDateTime.SQLTicksPerMinute;

            return tds; 
        }


        public static DateTime ToDateTime(int sqlDays, int sqlTime, int length) {
            if (length == 4) {
                return new SqlDateTime(sqlDays, sqlTime * SqlDateTime.SQLTicksPerMinute).Value;
            }
            else {
                Debug.Assert(length == 8, "invalid length for DateTime");
                return new SqlDateTime(sqlDays, sqlTime).Value;
            }               
        }

    }

    sealed internal class MetaSmallDateTime : MetaDateTime {
        public MetaSmallDateTime() {
            // same as DateTime except...
            Precision = 16;
            Scale = 0;
            FixedLength = 4;
            TDSType = TdsEnums.SQLDATETIM4;
            TypeName = MetaTypeName.SMALLDATETIME;
            SqlDbType = SqlDbType.SmallDateTime;
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLDATETIMN;}
        }
    }

    sealed internal class MetaMoney : MetaType {
        public MetaMoney()
        : base(19, 255, 8, true, false, TdsEnums.SQLMONEY, MetaTypeName.MONEY, typeof(System.Decimal), SqlDbType.Money, DbType.Currency) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLMONEYN;}
        }

        override public Type SqlType {
            get { return typeof(SqlMoney);}
        }            

    }

    sealed internal class MetaSmallMoney : MetaType {
        public MetaSmallMoney()
        : base(10, 255, 4, true, false, TdsEnums.SQLMONEY4, MetaTypeName.SMALLMONEY, typeof(System.Decimal), SqlDbType.SmallMoney, DbType.Currency) {
        }

        override public byte NullableType {
            get { return(byte) TdsEnums.SQLMONEYN;}
        }

        override public Type SqlType {
            get { return typeof(SqlMoney);}
        }            
    }

    sealed internal class MetaUniqueId : MetaType {
        public MetaUniqueId()
        : base(255, 255, 16, true, false, TdsEnums.SQLUNIQUEID, MetaTypeName.ROWGUID, typeof(System.Guid), SqlDbType.UniqueIdentifier, DbType.Guid) {
        }

        override public Type SqlType {
            get { return typeof(SqlGuid);}
        }            

    }

    sealed internal class MetaVariant : MetaType {
        public MetaVariant()
        : base(255, 255, -1, true, false, TdsEnums.SQLVARIANT, MetaTypeName.VARIANT, typeof(System.Object), SqlDbType.Variant, DbType.Object) {
        }
    }

    //
    // please leave string sorted alphabetically
    // note that these names should only be used in the context of parameters.  We always send over BIG* and nullable types for SQL Server
    //
    sealed internal class MetaTypeName {
        public const string BIGINT         = "bigint";
        public const string BINARY         = "binary";
        public const string BIT            = "bit";
        public const string CHAR           = "char";
        public const string DATETIME       = "datetime";
        public const string DECIMAL        = "decimal";
        public const string FLOAT          = "float";
        public const string IMAGE          = "image";
        public const string INT            = "int";
        public const string MONEY          = "money";
        public const string NCHAR          = "nchar";
        public const string NTEXT          = "ntext";
        // public const string NUMERIC        = "numeric";
        public const string NVARCHAR       = "nvarchar";
        public const string REAL           = "real";
        public const string ROWGUID        = "uniqueidentifier";
        public const string SMALLDATETIME  = "smalldatetime";
        public const string SMALLINT       = "smallint";
        public const string SMALLMONEY     = "smallmoney";
        public const string TEXT           = "text";
        public const string TIMESTAMP      = "timestamp";
        public const string TINYINT        = "tinyint";
        public const string VARBINARY      = "varbinary";
        public const string VARCHAR        = "varchar";
        public const string VARIANT        = "sql_variant";
    }//MetaTypeName

}//namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlrowupdatedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlRowUpdatedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\SQLRowUpdatedEvent.uex' path='docs/doc[@for="SqlRowUpdatedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Data.SqlClient.SqlDataAdapter.RowUpdated'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    sealed public class SqlRowUpdatedEventArgs : RowUpdatedEventArgs {
        /// <include file='doc\SQLRowUpdatedEvent.uex' path='docs/doc[@for="SqlRowUpdatedEventArgs.SqlRowUpdatedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlClient.SqlRowUpdatedEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public SqlRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
        : base(row, command, statementType, tableMapping) {
        }

        /// <include file='doc\SQLRowUpdatedEvent.uex' path='docs/doc[@for="SqlRowUpdatedEventArgs.Command"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Data.SqlClient.SqlCommand'/>
        ///       executed when <see cref='System.Data.Common.DbDataAdapter.Update'/> is called.
        ///    </para>
        /// </devdoc>
        new public SqlCommand Command {
            get {
                return(SqlCommand) base.Command;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlrowupdatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlRowUpdatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    /// <include file='doc\SQLRowUpdatedEventHandler.uex' path='docs/doc[@for="SqlRowUpdatedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.SqlClient.SqlDataAdapter.RowUpdated'/>
    ///       event of a
    ///    <see cref='System.Data.SqlClient.SqlDataAdapter'/>.
    ///    </para>
    /// </devdoc>
    public delegate void SqlRowUpdatedEventHandler(object sender, SqlRowUpdatedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlinternalconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlInternalConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient
{
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Threading;

    sealed internal class SqlInternalConnection {
        // CONNECTION AND STATE VARIABLES
        private WeakReference         _connectionWeakRef;          // parent sqlconnection
        private SqlConnectionString   _connectionOptions;
        private TdsParser             _parser;
        private SqlLoginAck           _loginAck;

        // FOR POOLING
        private bool               _fConnectionOpen  = false;
        private bool               _fIsPooled        = false;
        private bool               _fUsableState     = true;
        private volatile bool      _fInPool          = false;
        private ConnectionPool     _pool;
        private int                _lock = 0; // lock int used for closing

        // FOR CONNECTION RESET MANAGEMENT 
        private bool               _fResetConnection;
        private string             _originalDatabase;
        private string             _originalLanguage;
        private SqlCommand         _resetCommand;

        // FOR POOLING LIFETIME MANAGEMENT
        private bool               _fCheckLifetime;
        private TimeSpan           _lifetime;
        private DateTime           _createTime;

        // FOR LOCAL TRANSACTIONS
        private bool               _fInLocalTransaction;

        // FOR DISTRIBUTED TRANSACTIONS
        private byte[]                   _dtcAddress;         // cache the DTC server address
        private Guid                     _transactionGuid;    // cache the distributed transaction
        private TransactionExportWrapper _transactionExport;  // cache the TransactionExport
        private TransactionWrapper       _transaction;        // cache the ITransaction in the case of manual enlistment

        // this constructor is called by SqlConnection, and is not implicitly pooled
        public SqlInternalConnection(SqlConnection connection, SqlConnectionString connectionOptions)
        {
            _connectionWeakRef = new WeakReference(connection);
            // use the same hashtable reference since non-pooled
            _connectionOptions = connectionOptions; // cloned by SqlConnection
            _fIsPooled  = false;

            this.OpenAndLogin();

            // for non-pooled connections, enlist in a distributed transaction
            // if present - and user specified to enlist
            if (_connectionOptions.Enlist)
                this.EnlistDistributedTransaction();
        }

        // this constructor is called by the implicit object pooler
        public SqlInternalConnection(SqlConnectionString connectionOptions, ConnectionPool pool, bool fCheckLifetime, TimeSpan lifetime,
                                     bool fResetConnection, string originalDatabase, string originalLanguage)
        {
            // clone the hashtable, since this is pooled - should not use same reference
            _connectionOptions = connectionOptions.Clone();

            _fIsPooled        = true;
            _pool             = pool;
            _fCheckLifetime   = fCheckLifetime;
            _lifetime         = lifetime;
            _fResetConnection = fResetConnection;
            _originalDatabase = originalDatabase;
            _originalLanguage = originalLanguage;

            this.OpenAndLogin();

            // PerfCounters
            SQL.IncrementPooledConnectionCount();
            SQL.PossibleIncrementPeakPoolConnectionCount();

            // let activate handle distributed transaction enlistment

            // obtain the time of construction, if fCheckLifetime
            if (_fCheckLifetime)
                _createTime = DateTime.UtcNow;
        }

        //
        // PUBLIC PROPERTIES
        //

        private SqlConnection Connection {
            get {
                if (_connectionWeakRef != null) {
                    SqlConnection con = (SqlConnection) _connectionWeakRef.Target;
                    if (_connectionWeakRef.IsAlive) {
                        return con;
                    }
                }
                return null;
            }
        }

        public WeakReference ConnectionWeakRef {
            get {
                return _connectionWeakRef;
            }
            set {
                _connectionWeakRef = value;
            }
        }
        
        public SqlConnectionString ConnectionOptions {
            get {
                return _connectionOptions;
            }
            /*set {
                _connectionOptions = value;
            }*/
        }

        public bool InLocalTransaction {
            get {
                return _fInLocalTransaction;
            }
            set {
                _fInLocalTransaction = value;
            }
        }

        // Does not mean the object is actually in the connection pool ready to be obtained again.  In
        // the case of a manually enlisted distributed transaction it may be waiting on the outcome
        // events.  Besides that case, it means the connection is in the pool ready to come out again.
        public bool InPool {
            get {
                return _fInPool;
            }
            set {
                _fInPool = value;
            }
        }

        public bool IsPooled {
            get {
                return _fIsPooled;
            }
        }

        public bool IsShiloh {
            get {
                return _loginAck.isVersion8;
            }
        }

        public ITransaction ManualEnlistedTransaction {
            get {
                if (null == _transaction)
                    return null;
                    
                return _transaction.GetITransaction();
            }
        }                

        public TdsParser Parser {
            get {
                return _parser;
            }
        }

        public ConnectionPool Pool {
            get {
                return _pool;
            }
        }

        public string ServerVersion {
            get {
                return(String.Format("{0:00}.{1:00}.{2:0000}", _loginAck.majorVersion,
                       (short) _loginAck.minorVersion, _loginAck.buildNum));
            }
        }

        //
        // PUBLIC METHODS
        //

        public void Activate(bool isInTransaction) {
            Debug.Assert(_fIsPooled, "SqlInternalConnection.Activate should only be called in implicit case");

            Debug.Assert(!_parser.PendingData && !_fInLocalTransaction, "Upon Activate SqlInternalConnection has pending data or a currently ongoing local transaction.");
            this.Cleanup(true); // pass true, so it will throw into Open

            // For implicit pooled connections, if connection reset behavior is specified,
            // reset the database and language properties back to default.  It is important
            // to do this on activate so that the hashtable is correct before SqlConnection
            // obtains a clone.
            if (_fResetConnection) {
                // Ensure we are either going against shiloh, or we are not enlisted in a 
                // distributed transaction - otherwise don't reset!
                if (IsShiloh) {
                    // Reset hashtable values, since calling reset will not send us env_changes.
                    _connectionOptions.InitialCatalog  = _originalDatabase;
                    _connectionOptions.CurrentLanguage = _originalLanguage;

                    // Prepare the parser for the connection reset - the next time a trip
                    // to the server is made.
                    _parser.PrepareResetConnection();
                }
                else if (Guid.Empty == _transactionGuid) {
                    // If not Shiloh, we are going against Sphinx.  On Sphinx, we
                    // may only reset if not enlisted in a distributed transaction.

                    if (null == _resetCommand) {
                        _resetCommand = new SqlCommand("sp_reset_connection");
                        _resetCommand.CommandType = CommandType.StoredProcedure;
                    }

                    // Reset hashtable values, since calling reset will not send us env_changes.
                    _connectionOptions.InitialCatalog  = _originalDatabase;
                    _connectionOptions.CurrentLanguage = _originalLanguage;

                    try {
                        try {
                            // always reset the connection property
                            _resetCommand.Connection = this.Connection;

                            // Execute sp_reset_connection, and consume resulting message
                            // of a return status and done proc.
                            _resetCommand.ExecuteNonQuery();
                        }
                        finally { // Connection=
                            // null out Connection reference
                            _resetCommand.Connection = null;
                        }
                    }
                    catch { // MDAC 80973, 82263
                        throw;
                    }
                }
            }

            // For implicit pooled connections, enlist in a distributed transaction
            // if present - and user specified to enlist and pooler.  Or, if we are not in
            // a distributed transaction, but we used to be, we will need to re-enlist in the
            // null transaction.
            if ( (isInTransaction && _connectionOptions.Enlist) ||
                 (!isInTransaction && Guid.Empty != _transactionGuid) )
                this.EnlistDistributedTransaction();
        }

        public bool Deactivate() {
            Debug.Assert(_fIsPooled, "SqlInternalConnection.Deactivate should only be called in implicit case");

            this.Cleanup(false); // pass false, Deactivate shouldn't throw

            if (_fUsableState && _fCheckLifetime) {
                // check lifetime here - as a side effect it will doom connection if 
                // it's lifetime has elapsed
                this.CheckLifetime();
            }

            // return whether or not the current connection is enlisted in a distributed
            // transaction
            return (Guid.Empty != _transactionGuid);
        }

        public bool CanBePooled() {
            Debug.Assert(_fIsPooled, "SqlInternalConnection.Deactivate should only be called in implicit case");
            return _fUsableState;
        }

        //
        // PARSER CALLBACKS
        //

        public void BreakConnection() {
            this._fUsableState = false; // Mark connection as unusable, so it will be destroyed
            if (null != Connection) {
                Connection.Close();
            }
        }

        public void OnEnvChange(SqlEnvChange rec) {
            switch (rec.type) {
                case TdsEnums.ENV_DATABASE:
                    // If connection is not open, store the server value as the original.
                    if (!_fConnectionOpen)
                        _originalDatabase = rec.newValue;

                    _connectionOptions.InitialCatalog = rec.newValue;
                    break;
                case TdsEnums.ENV_LANG:
                    // If connection is not open, store the server value as the original.
                    if (!_fConnectionOpen)
                        _originalLanguage = rec.newValue;

                    _connectionOptions.CurrentLanguage = rec.newValue;
                    break;
                case TdsEnums.ENV_PACKETSIZE:
                    _connectionOptions.PacketSize = Int32.Parse(rec.newValue, CultureInfo.InvariantCulture);
                    break;
                case TdsEnums.ENV_CHARSET:
                case TdsEnums.ENV_LOCALEID:
                case TdsEnums.ENV_COMPFLAGS:
                case TdsEnums.ENV_COLLATION:
                    // only used on parser
                    break;
                default:
                    Debug.Assert(false, "Missed token in EnvChange!");
                    break;
            }
        }

        public void OnError(SqlException exception, TdsParserState state) {
            if (state == TdsParserState.Broken)
                _fUsableState = false;

            if (null != Connection){
                Connection.OnError(exception, state);
            }
            else if (exception.Class >= TdsEnums.MIN_ERROR_CLASS) {
                // It is an error, and should be thrown.  Class of TdsEnums.MINERRORCLASS 
                // or above is an error, below TdsEnums.MINERRORCLASS denotes an info message.
                throw exception;
            }
        }

        public void OnLoginAck(SqlLoginAck rec) {
            _loginAck = rec;
            // UNDONE:  throw an error if this is not 7.0 or 7.1[5].
        }

        //
        // OTHER PUBLIC METHODS
        //

        public void ChangeDatabase(string database) {
            if (_parser.PendingData)
                throw ADP.OpenConnectionRequired(ADP.ChangeDatabase, Connection.State);

            // MDAC 73598 - add brackets around database
            database = SqlConnection.FixupDatabaseTransactionName(database);
            _parser.TdsExecuteSQLBatch("use " + database, _connectionOptions.ConnectTimeout);
            _parser.Run(RunBehavior.UntilDone);
        }

        // Return whether or not this object has had it's lifetime timed out.
        // True means the object is still good, false if it has timed out.
        public bool CheckLifetime() {
            // obtain current time
            DateTime now = DateTime.UtcNow;

            // obtain timespan
            TimeSpan timeSpan = now.Subtract(_createTime);

            // compare timeSpan with lifetime, if equal or less,
            // designate this object to be killed
            if (TimeSpan.Compare(_lifetime, timeSpan) <= 0) {
                _fUsableState = false;
                return false;
            }
            else {
                return true;
            }
        }

        // Cleanup function called at three different times.
        // 1) SqlConnection released but not closed, and was GC'ed, freeing the internal connection.
        //    Cleanup is called from ObjectPool after reclaiming the connection.
        // 2) Upon Activate, coming out of the pool.
        // 3) Upon Deactivate, prior to going back into the pool.
        // It is called to make sure the connection is in a good state.  The method will clean
        // any results left on the wire, as well as rolling back any ongoing local transaction.
        // If this fails, the connection will be closed and marked as unusable.  This should be
        // unnecessary upon Deactivate and Activate, but I am calling it because of stress bug 
        // MDAC #77441.
        public void Cleanup(bool fThrow) {
            try {
                if (_fConnectionOpen && _parser.State == TdsParserState.OpenLoggedIn) {
                    if (_parser.PendingData) {
                        _parser.CleanWire();
                    }

                    if (_fInLocalTransaction) {
                        _fInLocalTransaction = false;
                        ExecuteTransaction(TdsEnums.TRANS_IF_ROLLBACK, ADP.RollbackTransaction);
                    }
                }
            }
            catch (Exception e) {
                // If anything went wrong, simply mark this connection as unusable so it won't go back to
                // the pool.  It will be closed upon being destructed by the pool, or explicity by the user.
                this._fUsableState = false;

                if (fThrow) {
                    throw e;
                }
            }  
        }

        public void Close() {
            // this method will actually close the internal connection and dipose it, this
            // should only be called by a non-pooled sqlconnection, or by the object pooler
            // when it deems an object should be destroyed

            // it's possible to have a connection finalizer, internal connection finalizer,
            // and the object pool destructor calling this method at the same time, so
            // we need to provide some synchronization
            if (_fConnectionOpen) {
                if (Interlocked.CompareExchange(ref _lock, 1, 0) == 0) {
                    if (_fConnectionOpen) {
                        if (_fIsPooled) {
                            // PerfCounters - on close of pooled connection, decrement count
                            SQL.DecrementPooledConnectionCount();
                        }

                        try {
                            try {
                                _parser.Disconnect();

                                // UNDONE: GC.SuppressFinalize causes a permission demand?
                                //GC.SuppressFinalize(_parser);
                            }
                            finally { // _connectionWeakRef=
                                // close will always close, even if exception is thrown
                                // remember to null out any object references
                                _connectionWeakRef  = null;
                                _connectionOptions  = null;
                                _parser             = null;
                                _loginAck           = null;
                                _fConnectionOpen    = false; // mark internal connection as closed
                                _fUsableState       = false; // mark internal connection as unusable
                                _pool               = null;
                                _dtcAddress         = null;
                                _transactionGuid    = Guid.Empty;
                                _transactionExport  = null;

                                // always release the lock
                                //Interlocked.CompareExchange(ref _lock, 0, 1);
                                _lock = 0;
                            }
                        }
                        catch { // MDAC 80973
                            throw;
                        }
                    }
                    else {
                        // release lock in case where connection already closed
                        //Interlocked.CompareExchange(ref _lock, 0, 1);
                        _lock = 0;
                    }
                }
            }
        }

        public void EnlistDistributedTransaction()
        {
            Guid newTransactionGuid = Guid.Empty;
            ITransaction newTransaction = Transaction.GetTransaction(out newTransactionGuid);
            EnlistDistributedTransaction(newTransaction, newTransactionGuid);
        }

        public void ManualEnlistDistributedTransaction(ITransaction newTransaction) {
            Guid newTransactionGuid = Guid.Empty;

            if (null != newTransaction) {
                // Obtain Guid for TransactionId from ITransaction.
                XACTTRANSINFO info;
                newTransaction.GetTransactionInfo(out info);
                BOID boid = info.uow;
                byte[] bytes = boid.rgb;
                newTransactionGuid = new Guid(bytes);
            }

            EnlistDistributedTransaction(newTransaction, newTransactionGuid);

            if (null != newTransaction) {
                _transaction = new TransactionWrapper(newTransaction); // cache ITransaction
            }
        }

        public void EnlistDistributedTransaction(ITransaction newTransaction, Guid newTransactionGuid) {
            // Enlist (or unenlist) if tx is changing
            if (_transactionGuid != newTransactionGuid) {
                if (Guid.Empty == newTransactionGuid) {
                    EnlistNullDistributedTransaction();
                }
                else {
                    EnlistNonNullDistributedTransaction(newTransaction);
                }

                _transactionGuid = newTransactionGuid;
            }
        }        

        // Internal code for common transaction related work.
        public void ExecuteTransaction(string sqlBatch, string method) {
            if (_parser.PendingData)
                throw ADP.OpenConnectionRequired(method, Connection.State);

            _parser.TdsExecuteSQLBatch(sqlBatch, _connectionOptions.ConnectTimeout);
            _parser.Run(RunBehavior.UntilDone);
        }

        public void ResetCachedTransaction() {
            _transaction = null;
        }

        //
        // PRIVATE METHODS
        //

        private void EnlistNullDistributedTransaction() {
            //if (AdapterSwitches.SqlPooling.TraceVerbose)
            //    Debug.WriteLine("SQLConnetion.EnlistDistributedTransaction(): Enlisting connection in null transaction...");
        
            // We were in a transaction, but now we are not - so send message to server
            // with empty transaction - confirmed proper behavior from Sameet Agarwal
            // The object pooler maintains separate pools for enlisted transactions, and only
            // when that transaction is committed or rolled back will those connections
            // be taken from that separate pool and returned to the general pool of
            // connections that are not affiliated with any transactions.  When
            // this occurs, we will have a new transaction of null and we are required to
            // send an empty transaction payload to the server.
            _parser.PropagateDistributedTransaction(null, 0, _connectionOptions.ConnectTimeout);
        }

        private void EnlistNonNullDistributedTransaction(ITransaction transaction) {
            //if (AdapterSwitches.SqlPooling.TraceVerbose)
            //    Debug.WriteLine("SqlInternalConnection.EnlistDistributedTransaction(): Enlisting connection in distributed transaction...");

            if (null == _dtcAddress)
                _dtcAddress = _parser.GetDTCAddress(_connectionOptions.ConnectTimeout);

            Debug.Assert(_dtcAddress != null, "SqlInternalConnection.EnlistDistributedTransaction(): dtcAddress null, error #1");

            byte[] cookie = null;
            int    length = 0;

            UnsafeNativeMethods.ITransactionExport transactionExport = null;

            if (null != _transactionExport)
                transactionExport = _transactionExport.GetITransactionExport();

            // if the call for the cookie fails, re-obtain the DTCAddress and recall the function
            if (!Transaction.GetTransactionCookie(_dtcAddress, transaction,
                                                  ref transactionExport, ref cookie,
                                                  ref length)) {
                _dtcAddress = _parser.GetDTCAddress(_connectionOptions.ConnectTimeout);

                Debug.Assert(_dtcAddress != null, "SqlInternalConnection.Activate(): dtcAddress null, error #2");

                if (!Transaction.GetTransactionCookie(_dtcAddress, transaction,
                                                      ref transactionExport, ref cookie,
                                                      ref length))
                    throw SQL.TransactionEnlistmentError();
            }

            if (null != transactionExport)
                _transactionExport = new TransactionExportWrapper(transactionExport);
            else
                _transactionExport = null;

            // send cookie to server to finish enlistment
            _parser.PropagateDistributedTransaction(cookie, length, _connectionOptions.ConnectTimeout);
        }

        private void Login(int timeout) {
            // create a new login record
            SqlLogin login = new SqlLogin();

            // gather all the settings the user set in the connection string or properties and
            login.timeout          = timeout;
            login.hostName         = _connectionOptions.WorkstationId;
            login.userName         = _connectionOptions.UserID;
            login.applicationName  = _connectionOptions.ApplicationName;
            login.language         = _connectionOptions.CurrentLanguage;
            login.database         = _connectionOptions.InitialCatalog;
            login.attachDBFilename = _connectionOptions.AttachDBFilename;
            login.serverName       = _connectionOptions.DataSource;
            login.useSSPI          = _connectionOptions.IntegratedSecurity;
            login.packetSize       = _connectionOptions.PacketSize;
#if USECRYPTO
            try {
                login.password = Crypto.DecryptString(_connectionOptions.Password);
                GCHandle textHandle = GCHandle.Alloc(login.password, GCHandleType.Pinned); // MDAC 82615
                try {
                    // do the login
                    _parser.TdsLogin(login);
                }
                finally {
                    Array.Clear(login.password, 0, login.password.Length);
                    if (textHandle.IsAllocated) {
                        textHandle.Free();
                    }
                    login.password = ADP.EmptyByteArray;
                }
            }
            catch {
                throw;
            }
#else
            login.password = System.Text.Encoding.Unicode.GetBytes(_connectionOptions.Password);
            _parser.TdsLogin(login);
#endif
            _parser.Run(RunBehavior.UntilDone);
        }

        private void OpenAndLogin() {
            // Open the connection and Login
            try {
                int timeout = _connectionOptions.ConnectTimeout;

                _parser = new TdsParser();
                timeout = _parser.Connect(_connectionOptions.DataSource,
                                          _connectionOptions.NetworkLibrary,
                                          this,
                                          timeout,
                                          _connectionOptions.Encrypt);

                this.Login(timeout);

                _fConnectionOpen = true; // mark connection as open
            }
            catch (Exception e) {
                ADP.TraceException(e);

                // If the parser was allocated and we failed, then we must have failed on
                // either the Connect or Login, either way we should call Disconnect.
                // Disconnect can be called if the connection is already closed - becomes
                // no-op, so no issues there.
                if (_parser != null)
                    _parser.Disconnect();

                throw e;
            }
        }

        sealed internal class TransactionExportWrapper {
            private IntPtr iunknown;

            ~TransactionExportWrapper() {
                if (IntPtr.Zero != this.iunknown) {
                    Marshal.Release(this.iunknown);
                    this.iunknown = IntPtr.Zero;
                }
            }

            internal TransactionExportWrapper(UnsafeNativeMethods.ITransactionExport transactionExport) {
                this.iunknown = Marshal.GetIUnknownForObject(transactionExport);
            }

            internal UnsafeNativeMethods.ITransactionExport GetITransactionExport() {
                UnsafeNativeMethods.ITransactionExport value = (UnsafeNativeMethods.ITransactionExport) System.Runtime.Remoting.Services.EnterpriseServicesHelper.WrapIUnknownWithComObject(this.iunknown);
                GC.KeepAlive(this);
                return value;
            }
        }

        sealed internal class TransactionWrapper {
            private IntPtr iunknown;

            ~TransactionWrapper() {
                if (IntPtr.Zero != this.iunknown) {
                    Marshal.Release(this.iunknown);
                    this.iunknown = IntPtr.Zero;
                }
            }

            internal TransactionWrapper(ITransaction transaction) {
                this.iunknown = Marshal.GetIUnknownForObject(transaction);
            }

            internal ITransaction GetITransaction() {
                ITransaction value = (ITransaction) System.Runtime.Remoting.Services.EnterpriseServicesHelper.WrapIUnknownWithComObject(this.iunknown);
                GC.KeepAlive(this);
                return value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;

    sealed internal class SqlStream : Stream {
        private SqlDataReader _reader; // reader we will stream off
        private long _bytesCol;
        int _bom;
        
        internal SqlStream(SqlDataReader reader, bool addByteOrderMark) {
            _reader = reader;
            _bom = addByteOrderMark ? 0xfeff : 0;
        }

        override public bool CanRead {
            get {
                return true;
            }
        }

        override public bool CanSeek {
            get {
                return false;
            }
        }

        override public bool CanWrite {
            get {
                return false;
            }
        }

        override public long Length {
            get {
              throw ADP.NotSupported();
            }
        }

        override public long Position {
            get {
                throw ADP.NotSupported();
            }
            set {
                throw ADP.NotSupported();
            }
        }

        override public void Close() {
            if (null != _reader) {
                if (!_reader.IsClosed) {
                    _reader.Close();
                }                    
                _reader = null;
            }
        }

        override public void Flush() {
            throw ADP.NotSupported();
        }

        override public int Read(byte[] buffer, int offset, int count) {
            bool gotData = true;
            long cb = 0;
            int intCount = 0;
            
            if (null == _reader) {
                throw ADP.StreamClosed("Read");
            }
            if (null == buffer) {
                throw ADP.ArgumentNull("buffer");
            }
            if ((offset < 0) || (count < 0)) {
                throw ADP.ArgumentOutOfRange((offset < 0 ? "offset" : "count"));
            }
            if (buffer.Length - offset < count) {
                throw ADP.Argument("count");
            }

            // if we haven't prepended the byte order mark, do so now
            while (count > 0) {
                if (_bom > 0) {
                    buffer[offset] = (byte)_bom;
                    _bom >>= 8;
                    offset++;
                    count--;
                    intCount++;
                }
                else {
                    break;
                }
            }

            while (count > 0) {

                // if I haven't read any bytes, get the next row
                if (0 == _bytesCol) {
                    gotData = false;
                    do {
                        if (_reader.Read()) {
                            gotData = true;
                            break;
                        }
                    } while (_reader.NextResult());                        
                }

                if (gotData) {
                    cb = _reader.GetBytes(0, _bytesCol, buffer, offset, count);

                    if (cb < count) {
                        _bytesCol = 0;
                    }                        
                    else {
                        _bytesCol += cb;
                    } 
                    
                    // we are guaranteed that cb is < Int32.Max since we always pass in count which is of type Int32 to
                    // our getbytes interface
                    count -= (int)cb;
                    offset += (int)cb;
                    intCount += (int)cb;
                }
                else {
                    break; // no more data available, we are done
                }
            }

            return intCount;
        }

        override public long Seek(long offset, SeekOrigin origin) {
            throw ADP.NotSupported();
        }

        override public void SetLength(long value) {
            throw ADP.NotSupported();
        }

        override public void Write(byte[] buffer, int offset, int count) {
            throw ADP.NotSupported();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlrowupdatingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlRowUpdatingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    /// <include file='doc\SQLRowUpdatingEventHandler.uex' path='docs/doc[@for="SqlRowUpdatingEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.SqlClient.SqlDataAdapter.RowUpdating'/>
    ///       event of a
    ///    <see cref='System.Data.SqlClient.SqlDataAdapter'/>.
    ///    </para>
    /// </devdoc>
    public delegate void SqlRowUpdatingEventHandler(object sender, SqlRowUpdatingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlrowupdatingevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlRowUpdatingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\SQLRowUpdatingEvent.uex' path='docs/doc[@for="SqlRowUpdatingEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Data.SqlClient.SqlDataAdapter.RowUpdating'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    sealed public class SqlRowUpdatingEventArgs : RowUpdatingEventArgs {

        /// <include file='doc\SQLRowUpdatingEvent.uex' path='docs/doc[@for="SqlRowUpdatingEventArgs.SqlRowUpdatingEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlClient.SqlRowUpdatingEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public SqlRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping) 
        : base(row, command, statementType, tableMapping) {
        }

        /// <include file='doc\SQLRowUpdatingEvent.uex' path='docs/doc[@for="SqlRowUpdatingEventArgs.Command"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Data.SqlClient.SqlCommand'/>
        ///       to execute when performing the <see cref='System.Data.Common.DbDataAdapter.Update'/>.
        ///    </para>
        /// </devdoc>
        new public SqlCommand Command {
            get {
                return(SqlCommand)base.Command;
            }
            set {
                base.Command = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\tdsenums.cs ===
//------------------------------------------------------------------------------
// <copyright file="TdsEnums.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System.Diagnostics;

    using System;

    /// <include file='doc\TdsEnums.uex' path='docs/doc[@for="TdsEnums"]/*' />
    /// <devdoc> Class of variables for the Tds connection.
    /// </devdoc>
    sealed internal class TdsEnums {

        // internal tdsparser constants

        public const short SQL_SERVER_VERSION_SEVEN = 7;

        public const string SQL_PROVIDER_NAME = ".Net SqlClient Data Provider";

        public static readonly Decimal SQL_SMALL_MONEY_MIN = new Decimal(-214748.3648);
        public static readonly Decimal SQL_SMALL_MONEY_MAX = new Decimal(214748.3647);

        // sql debugging constants, sdci is the structure passed in 
        public const string SDCI_MAPFILENAME = "SqlClientSSDebug";
        public const byte SDCI_MAX_MACHINENAME = 32;
        public const byte SDCI_MAX_DLLNAME = 16;
        public const byte SDCI_MAX_DATA = 255;
        public const int SQLDEBUG_OFF = 0;
        public const int SQLDEBUG_ON = 1;
        public const int SQLDEBUG_CONTEXT = 2;
        public const string SP_SDIDEBUG = "sp_sdidebug";
        public static readonly string[] SQLDEBUG_MODE_NAMES = new string[3] {
            "off",
            "on",
            "context"
        };            
        
        // HACK!!!
        // Constant for SqlDbType.SmallVarBinary... store internal variable here instead of on
        // SqlDbType so that it is not surfaced to the user!!!  Related to dtc and the fact that
        // the TransactionManager TDS stream is the only token left that uses VarBinarys instead of
        // BigVarBinarys.
        public const SqlDbType SmallVarBinary = (SqlDbType) (SqlDbType.Variant)+1;

        // Transaction Manager Request types
        public const short TM_GET_DTC_ADDRESS = 0;
        public const short TM_PROPAGATE_XACT  = 1;

        // network protocol string constants
        public const string TCP  = "tcp";
        public const string NP   = "np";
        public const string RPC  = "rpc";
        public const string BV   = "bv";
        public const string ADSP = "adsp";
        public const string SPX  = "spx";
        public const string VIA  = "via";
        public const string LPC  = "lpc";

        // network function string contants
        public const string INIT_SSPI_PACKAGE       = "InitSSPIPackage";
        public const string INIT_SESSION            = "InitSession";
        public const string CONNECTION_GET_SVR_USER = "ConnectionGetSvrUser";
        public const string GEN_CLIENT_CONTEXT      = "GenClientContext";

        // tdsparser packet handling constants
        public const byte SOFTFLUSH = 0;
        public const byte HARDFLUSH = 1;

        // header constants
        public const int HEADER_LEN = 8;
        public const int HEADER_LEN_FIELD_OFFSET = 2;

        // other various constants
        public const int   SUCCEED              = 1;
        public const int   FAIL                 = 0;
        public const short TYPE_SIZE_LIMIT      = 8000;
        public const int   MAX_IN_BUFFER_SIZE   = 65535;    
        public const int   MAX_SERVER_USER_NAME = 256;  // obtained from luxor
        public const byte  DEFAULT_ERROR_CLASS  = 0x0A;
        public const byte  FATAL_ERROR_CLASS    = 0x14;
        public const int   MIN_ERROR_CLASS      = 10;

        //    Message types
        public const byte MT_SQL    = 1;    // SQL command batch                
        public const byte MT_LOGIN  = 2;    // Login message                    
        public const byte MT_RPC    = 3;    // Remote procedure call            
        public const byte MT_TOKENS = 4;    // Table response data stream        
        public const byte MT_BINARY = 5;    // Unformatted binary response data 
        public const byte MT_ATTN   = 6;    // Attention (break) signal         
        public const byte MT_BULK   = 7;    // Bulk load data                    
        public const byte MT_OPEN   = 8;    // Set up subchannel                
        public const byte MT_CLOSE  = 9;    // Close subchannel                 
        public const byte MT_ERROR  = 10;   // Protocol error detected            
        public const byte MT_ACK    = 11;   // Protocol acknowledgement         
        public const byte MT_ECHO   = 12;   // Echo data                        
        public const byte MT_LOGOUT = 13;   // Logout message                    
        public const byte MT_TRANS  = 14;   // Transaction Manager Interface    
        public const byte MT_OLEDB  = 15;   // ? 
        public const byte MT_LOGIN7 = 16;   // Login message for Sphinx         
        public const byte MT_SSPI   = 17;   // SSPI message                     

        // Message status bits
        public const byte ST_EOM              = 1; // Packet is end-of-message
        public const byte ST_AACK             = 2; // Packet acknowledges attention
        public const byte ST_BATCH            = 4; // Message is part of a batch.
        public const byte ST_RESET_CONNECTION = 8; // Exec sp_reset_connection prior to processing message

        public const byte SQLCOLFMT       = 0xa1;
        public const byte SQLPROCID       = 0x7c;
        public const byte SQLCOLNAME      = 0xa0;
        public const byte SQLTABNAME      = 0xa4;
        public const byte SQLCOLINFO      = 0xa5;
        public const byte SQLALTNAME      = 0xa7;
        public const byte SQLALTFMT       = 0xa8;
        public const byte SQLERROR        = 0xaa;
        public const byte SQLINFO         = 0xab;
        public const byte SQLRETURNVALUE  = 0xac;
        public const byte SQLRETURNSTATUS = 0x79;
        public const byte SQLRETURNTOK    = 0xdb;
        public const byte SQLCONTROL      = 0xae;
        public const byte SQLALTCONTROL   = 0xaf;
        public const byte SQLROW          = 0xd1;
        public const byte SQLALTROW       = 0xd3;
        public const byte SQLDONE         = 0xfd;
        public const byte SQLDONEPROC     = 0xfe;
        public const byte SQLDONEINPROC   = 0xff;
        public const byte SQLOFFSET       = 0x78;
        public const byte SQLORDER        = 0xa9;
        public const byte SQLDEBUG_CMD    = 0x60;
        public const byte SQLLOGINACK     = 0xad;
        public const byte SQLENVCHANGE    = 0xe3;    // Environment change notification
        public const byte SQLSECLEVEL     = 0xed;    // Security level token ???
        public const byte SQLROWCRC       = 0x39;    // ROWCRC datastream???
        public const byte SQLCOLMETADATA  = 0x81;    // Column metadata including name
        public const byte SQLALTMETADATA  = 0x88;    // Alt column metadata including name
        public const byte SQLSSPI         = 0xed;    // SSPI data

        // Environment change notification streams
        public const byte ENV_DATABASE    = 1;    // Database changed
        public const byte ENV_LANG        = 2;    // Language changed
        public const byte ENV_CHARSET     = 3;    // Character set changed
        public const byte ENV_PACKETSIZE  = 4;    // Packet size changed
        public const byte ENV_TRANSACTION = 5;    // Transaction changed
        public const byte ENV_LOCALEID    = 5;    // Unicode data sorting locale id
        public const byte ENV_COMPFLAGS   = 6;    // Unicode data sorting comparison flags
        public const byte ENV_COLLATION   = 7;    // SQL Collation

        // done status stream bit masks
        public const int DONE_MORE       = 0x0001;    // more command results coming
        public const int DONE_ERROR      = 0x0002;    // error in command batch
        public const int DONE_INXACT     = 0x0004;    // transaction in progress 
        public const int DONE_PROC       = 0x0008;    // done from stored proc   
        public const int DONE_COUNT      = 0x0010;    // count in done info      
        public const int DONE_ATTN       = 0x0020;    // oob ack                 
        public const int DONE_INPROC     = 0x0040;    // like DONE_PROC except proc had error 
        public const int DONE_RPCINBATCH = 0x0080;    // Done from RPC in batch
        public const int DONE_SRVERROR   = 0x0100;    // Severe error in which resultset should be discarded
        public const int DONE_FMTSENT    = 0x8000;    // fmt message sent, done_inproc req'd
        public const int DONE_SQLSELECT = 0xc1;        // SQLSELECT stmt type token

        //    Loginrec defines
        public const byte  MAX_LOG_NAME       = 30;            // TDS 4.2 login rec max name length
        public const byte  MAX_PROG_NAME      = 10;            // max length of loginrec progran name
        public const short MAX_LOGIN_FIELD    = 256;           // max length in bytes of loginrec variable fields
        public const byte  SEC_COMP_LEN       = 8;             // length of security compartments
        public const byte  MAX_PK_LEN         = 6;             // max length of TDS packet size
        public const byte  MAX_NIC_SIZE       = 6;             // The size of a MAC or client address
        public const byte  SQLVARIANT_SIZE    = 2;             // size of the fixed portion of a sql variant (type, cbPropBytes)
        public const byte  VERSION_SIZE       = 4;             // size of the tds version (4 unsigned bytes)
        public const int   CLIENT_PROG_VER    = 0x06000000;    // Client interface version
        public const int   LOG_REC_FIXED_LEN  = 0x56;
        // misc
        public const int   TEXT_TIME_STAMP_LEN = 8;
        public const int   COLLATION_INFO_LEN = 4;

/*
        public const byte INT4_LSB_HI   = 0;     // lsb is low byte (eg 68000)
        //    public const byte INT4_LSB_LO   = 1;     // lsb is low byte (eg VAX)
        public const byte INT2_LSB_HI   = 2;     // lsb is low byte (eg 68000)
        //    public const byte INT2_LSB_LO   = 3;     // lsb is low byte (eg VAX)
        public const byte FLT_IEEE_HI   = 4;     // lsb is low byte (eg 68000)
        public const byte CHAR_ASCII    = 6;     // ASCII character set
        public const byte TWO_I4_LSB_HI = 8;     // lsb is low byte (eg 68000
        //    public const byte TWO_I4_LSB_LO = 9;     // lsb is low byte (eg VAX)
        //    public const byte FLT_IEEE_LO   = 10;    // lsb is low byte (eg MSDOS)
        public const byte FLT4_IEEE_HI  = 12;    // IEEE 4-byte floating point -lsb is high byte
        //    public const byte FLT4_IEEE_LO  = 13;    // IEEE 4-byte floating point -lsb is low byte
        public const byte TWO_I2_LSB_HI = 16;    // lsb is high byte 
        //    public const byte TWO_I2_LSB_LO = 17;    // lsb is low byte 

        public const byte LDEFSQL     = 0;    // server sends its default
        public const byte LDEFUSER    = 0;    // regular old user
        public const byte LINTEGRATED = 8;    // integrated security login
*/        

        public const int TDS70 = 0x0700;
        public const int TDS71 = 0x0701;
        public const int SPHINX_MAJOR     = 0X7000;
        public const int SHILOH_MAJOR     = 0x7100;
        public const int DEFAULT_MINOR    = 0X0;
        public const int SHILOH_MINOR_SP1 = 0X1;
        public const int ORDER_68000     = 1;
        public const int USE_DB_ON       = 1;
        public const int INIT_DB_FATAL   = 1;
        public const int SET_LANG_ON     = 1;
        public const int INIT_LANG_FATAL = 1;
        public const int ODBC_ON         = 1;
        public const int SSPI_ON         = 1;

        // Token masks
        public const byte SQLLenMask  = 0x30;    // mask to check for length tokens
        public const byte SQLFixedLen = 0x30;    // Mask to check for fixed token
        public const byte SQLVarLen   = 0x20;    // Value to check for variable length token
        public const byte SQLZeroLen  = 0x10;    // Value to check for zero length token
        public const byte SQLVarCnt   = 0x00;    // Value to check for variable count token

        // Token masks for COLINFO status
        public const byte SQLDifferentName = 0x20; // column name different than select list name
        public const byte SQLExpression = 0x4;     // column was result of an expression
        public const byte SQLKey = 0x8;           // column is part of the key for the table
        public const byte SQLHidden = 0x10;       // column not part of select list but added because part of key

        // Token masks for COLMETADATA flags
        public const byte Nullable = 0x1;
        public const byte Identity = 0x10;
        public const byte Updatability = 0xb; // mask off bits 3 and 4 

        // null values
        public const uint VARLONGNULL = 0xffffffff; // null value for text and image types
        public const int VARNULL = 0xffff;    // null value for character and binary types
        public const int MAXSIZE = 8000; // max size for any column
        public const byte FIXEDNULL  = 0;

        // SQL Server Data Type Tokens.
        public const int SQLVOID         = 0x1f;
        public const int SQLTEXT         = 0x23;
        public const int SQLVARBINARY    = 0x25;
        public const int SQLINTN         = 0x26;
        public const int SQLVARCHAR      = 0x27;
        public const int SQLBINARY       = 0x2d;
        public const int SQLIMAGE        = 0x22;
        public const int SQLCHAR         = 0x2f;
        public const int SQLINT1         = 0x30;
        public const int SQLBIT          = 0x32;
        public const int SQLINT2         = 0x34;
        public const int SQLINT4         = 0x38;
        public const int SQLMONEY        = 0x3c;
        public const int SQLDATETIME     = 0x3d;
        public const int SQLFLT8         = 0x3e;
        public const int SQLFLTN         = 0x6d;
        public const int SQLMONEYN       = 0x6e;
        public const int SQLDATETIMN     = 0x6f;
        public const int SQLFLT4         = 0x3b;
        public const int SQLMONEY4       = 0x7a;
        public const int SQLDATETIM4     = 0x3a;
        public const int SQLDECIMALN     = 0x6a;
        public const int SQLNUMERICN     = 0x6c;
        public const int SQLUNIQUEID     = 0x24;
        public const int SQLBIGCHAR      = 0xaf;
        public const int SQLBIGVARCHAR   = 0xa7;
        public const int SQLBIGBINARY    = 0xad;
        public const int SQLBIGVARBINARY = 0xa5;
        public const int SQLBITN         = 0x68;
        public const int SQLNCHAR        = 0xef;
        public const int SQLNVARCHAR     = 0xe7;    
        public const int SQLNTEXT        = 0x63;

        // SQL Server user-defined type tokens we care about
        public const int SQLTIMESTAMP   = 0x50;
        
        public const int  MAX_NUMERIC_LEN = 0x11; // 17 bytes of data for max numeric/decimal length
        public const int  DEFAULT_NUMERIC_PRECISION = 0x1C; // 28 is the default max numeric precision if not user set
        public const int  MAX_NUMERIC_PRECISION = 0x26; // 38 is max numeric precision;
        public const byte UNKNOWN_PRECISION_SCALE = 0xff; // -1 is value for unknown precision or scale

        // The following datatypes are SHILOH specific.
        public const int SQLINT8    = 0x7f;
        public const int SQLVARIANT = 0x62;

        public const bool Is68K    = false;
        public const bool TraceTDS = false;

        // RPC function names
        public const string SP_EXECUTESQL = "sp_executesql";    // used against 7.0 servers
        public const string SP_PREPEXEC = "sp_prepexec";        // used against 7.5 servers

        public const string SP_PREPARE = "sp_prepare";          // used against 7.0 servers
        public const string SP_EXECUTE = "sp_execute";
        public const string SP_UNPREPARE = "sp_unprepare";
        public const string SP_PARAMS = "sp_procedure_params_rowset";

#if INDEXINFO
		public const string SP_INDEXES = "sp_indexes_rowset";
#endif

        // For Transactions
        public const string TRANS_BEGIN       = "BEGIN TRANSACTION";
        public const string TRANS_COMMIT      = "COMMIT TRANSACTION";
        public const string TRANS_ROLLBACK    = "ROLLBACK TRANSACTION";
        public const string TRANS_IF_ROLLBACK = "IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION";
        public const string TRANS_SAVE        = "SAVE TRANSACTION";

        // For Transactions - isolation levels
        public const string TRANS_READ_COMMITTED   = "SET TRANSACTION ISOLATION LEVEL READ COMMITTED"; 
        public const string TRANS_READ_UNCOMMITTED = "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED";
        public const string TRANS_REPEATABLE_READ  = "SET TRANSACTION ISOLATION LEVEL REPEATABLE READ";
        public const string TRANS_SERIALIZABLE     = "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE";

        // RPC flags
        public const byte RPC_RECOMPILE = 0x1;
        public const byte RPC_NOMETADATA = 0x2;

        // SQL parameter list text
        public const string PARAM_OUTPUT = "output";

        // SQL Parameter constants
        public const int    MAX_PARAMETER_NAME_LENGTH = 127;

        // metadata options (added around an existing sql statement)

        // prefixes
        public const string FMTONLY_ON = " SET FMTONLY ON;";
        public const string FMTONLY_OFF = " SET FMTONLY OFF;";
        // suffixes
        public const string BROWSE_ON  = " SET NO_BROWSETABLE ON;";
        public const string BROWSE_OFF  = " SET NO_BROWSETABLE OFF;";

        // generic table name
        public const string TABLE = "Table";

        public const int EXEC_THRESHOLD = 0x3; // if the number of commands we execute is > than this threshold, than do prep/exec/unprep instead
        // of executesql. 

        // comparison values for switch on error number in tdsparser NetlibException()
        public const short ERRNO_MIN = ZERO_BYTES_READ;
        public const short ERRNO_MAX = UNKNOWN_ERROR;

        // dbnetlib values
        public const short ZERO_BYTES_READ = -3;
        public const short TIMEOUT_EXPIRED = -2;
        public const short UNKNOWN_ERROR = -1;
        public const short NE_E_NOMAP = 0;
        public const short NE_E_NOMEMORY = 1;
        public const short NE_E_NOACCESS = 2;
        public const short NE_E_CONNBUSY = 3;
        public const short NE_E_CONNBROKEN = 4;
        public const short NE_E_TOOMANYCONN = 5;
        public const short NE_E_SERVERNOTFOUND = 6;
        public const short NE_E_NETNOTSTARTED = 7;
        public const short NE_E_NORESOURCE = 8;
        public const short NE_E_NETBUSY = 9;
        public const short NE_E_NONETACCESS = 10;
        public const short NE_E_GENERAL = 11;
        public const short NE_E_CONNMODE = 12;
        public const short NE_E_NAMENOTFOUND = 13;
        public const short NE_E_INVALIDCONN = 14;
        public const short NE_E_NETDATAERR = 15;
        public const short NE_E_TOOMANYFILES = 16;
        public const short NE_E_SERVERERROR = 17;
        public const short NE_E_SSLSECURITYERROR = 18;
        public const short NE_E_ENCRYPTIONON = 19;
        public const short NE_E_ENCRYPTIONNOTSUPPORTED = 20;

        public const string DEFAULT_ENGLISH_CODE_PAGE_STRING = "iso_1";
        public const short  DEFAULT_ENGLISH_CODE_PAGE_VALUE  = 1252;
        public const short  CHARSET_CODE_PAGE_OFFSET         = 2;

        // array copied directly from tdssort.h from luxor
        public static readonly UInt16[] CODE_PAGE_FROM_SORT_ID = {
            0,      /*   0 */
            0,      /*   1 */
            0,      /*   2 */
            0,      /*   3 */
            0,      /*   4 */
            0,      /*   5 */
            0,      /*   6 */
            0,      /*   7 */
            0,      /*   8 */
            0,      /*   9 */
            0,      /*  10 */
            0,      /*  11 */
            0,      /*  12 */
            0,      /*  13 */
            0,      /*  14 */
            0,      /*  15 */
            0,      /*  16 */
            0,      /*  17 */
            0,      /*  18 */
            0,      /*  19 */
            0,      /*  20 */
            0,      /*  21 */
            0,      /*  22 */
            0,      /*  23 */
            0,      /*  24 */
            0,      /*  25 */
            0,      /*  26 */
            0,      /*  27 */
            0,      /*  28 */
            0,      /*  29 */
            437,    /*  30 */
            437,    /*  31 */
            437,    /*  32 */
            437,    /*  33 */
            437,    /*  34 */
            0,      /*  35 */
            0,      /*  36 */
            0,      /*  37 */
            0,      /*  38 */
            0,      /*  39 */
            850,    /*  40 */
            850,    /*  41 */
            850,    /*  42 */
            850,    /*  43 */
            850,    /*  44 */
            0,      /*  45 */
            0,      /*  46 */
            0,      /*  47 */
            0,      /*  48 */
            850,    /*  49 */
            1252,   /*  50 */
            1252,   /*  51 */
            1252,   /*  52 */
            1252,   /*  53 */
            1252,   /*  54 */
            850,    /*  55 */
            850,    /*  56 */
            850,    /*  57 */
            850,    /*  58 */
            850,    /*  59 */
            850,    /*  60 */
            850,    /*  61 */
            0,      /*  62 */
            0,      /*  63 */
            0,      /*  64 */
            0,      /*  65 */
            0,      /*  66 */
            0,      /*  67 */
            0,      /*  68 */
            0,      /*  69 */
            0,      /*  70 */
            1252,   /*  71 */
            1252,   /*  72 */
            1252,   /*  73 */
            1252,   /*  74 */
            1252,   /*  75 */
            0,      /*  76 */
            0,      /*  77 */
            0,      /*  78 */
            0,      /*  79 */
            1250,   /*  80 */
            1250,   /*  81 */
            1250,   /*  82 */
            1250,   /*  83 */
            1250,   /*  84 */
            1250,   /*  85 */
            1250,   /*  86 */
            1250,   /*  87 */
            1250,   /*  88 */
            1250,   /*  89 */
            1250,   /*  90 */
            1250,   /*  91 */
            1250,   /*  92 */
            1250,   /*  93 */
            1250,   /*  94 */
            1250,   /*  95 */
            1250,   /*  96 */
            1250,   /*  97 */
            0,      /*  98 */
            0,      /*  99 */
            0,      /* 100 */
            0,      /* 101 */
            0,      /* 102 */
            0,      /* 103 */
            1251,   /* 104 */
            1251,   /* 105 */
            1251,   /* 106 */
            1251,   /* 107 */
            1251,   /* 108 */
            0,      /* 109 */
            0,      /* 110 */
            0,      /* 111 */
            1253,   /* 112 */
            1253,   /* 113 */
            1253,   /* 114 */
            0,      /* 115 */
            0,      /* 116 */
            0,      /* 117 */
            0,      /* 118 */
            0,      /* 119 */
            1253,   /* 120 */
            1253,   /* 121 */
            0,      /* 122 */
            0,      /* 123 */
            1253,   /* 124 */
            0,      /* 125 */
            0,      /* 126 */
            0,      /* 127 */
            1254,   /* 128 */
            1254,   /* 129 */
            1254,   /* 130 */
            0,      /* 131 */
            0,      /* 132 */
            0,      /* 133 */
            0,      /* 134 */
            0,      /* 135 */
            1255,   /* 136 */
            1255,   /* 137 */
            1255,   /* 138 */
            0,      /* 139 */
            0,      /* 140 */
            0,      /* 141 */
            0,      /* 142 */
            0,      /* 143 */
            1256,   /* 144 */
            1256,   /* 145 */
            1256,   /* 146 */
            0,      /* 147 */
            0,      /* 148 */
            0,      /* 149 */
            0,      /* 150 */
            0,      /* 151 */
            1257,   /* 152 */
            1257,   /* 153 */
            1257,   /* 154 */
            1257,   /* 155 */
            1257,   /* 156 */
            1257,   /* 157 */
            1257,   /* 158 */
            1257,   /* 159 */
            1257,   /* 160 */
            0,      /* 161 */
            0,      /* 162 */
            0,      /* 163 */
            0,      /* 164 */
            0,      /* 165 */
            0,      /* 166 */
            0,      /* 167 */
            0,      /* 168 */
            0,      /* 169 */
            0,      /* 170 */
            0,      /* 171 */
            0,      /* 172 */
            0,      /* 173 */
            0,      /* 174 */
            0,      /* 175 */
            0,      /* 176 */
            0,      /* 177 */
            0,      /* 178 */
            0,      /* 179 */
            0,      /* 180 */
            0,      /* 181 */
            0,      /* 182 */
            1252,   /* 183 */
            1252,   /* 184 */
            1252,   /* 185 */
            1252,   /* 186 */
            0,      /* 187 */
            0,      /* 188 */
            0,      /* 189 */
            0,      /* 190 */
            0,      /* 191 */
            932,    /* 192 */
            932,    /* 193 */
            949,    /* 194 */
            949,    /* 195 */
            950,    /* 196 */
            950,    /* 197 */
            936,    /* 198 */
            936,    /* 199 */
            932,    /* 200 */
            949,    /* 201 */
            950,    /* 202 */
            936,    /* 203 */
            874,    /* 204 */
            874,    /* 205 */
            874,    /* 206 */
            0,      /* 207 */
            0,      /* 208 */
            0,      /* 209 */
            0,      /* 210 */
            0,      /* 211 */
            0,      /* 212 */
            0,      /* 213 */
            0,      /* 214 */
            0,      /* 215 */
            0,      /* 216 */
            0,      /* 217 */
            0,      /* 218 */
            0,      /* 219 */
            0,      /* 220 */
            0,      /* 221 */
            0,      /* 222 */
            0,      /* 223 */
            0,      /* 224 */
            0,      /* 225 */
            0,      /* 226 */
            0,      /* 227 */
            0,      /* 228 */
            0,      /* 229 */
            0,      /* 230 */
            0,      /* 231 */
            0,      /* 232 */
            0,      /* 233 */
            0,      /* 234 */
            0,      /* 235 */
            0,      /* 236 */
            0,      /* 237 */
            0,      /* 238 */
            0,      /* 239 */
            0,      /* 240 */
            0,      /* 241 */
            0,      /* 242 */
            0,      /* 243 */
            0,      /* 244 */
            0,      /* 245 */
            0,      /* 246 */
            0,      /* 247 */
            0,      /* 248 */
            0,      /* 249 */
            0,      /* 250 */
            0,      /* 251 */
            0,      /* 252 */
            0,      /* 253 */
            0,      /* 254 */
            0,      /* 255 */
	    };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqltransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System.Data.Common;
    using System.Diagnostics;
    using System.Data;

    /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction"]/*' />
    sealed public class SqlTransaction : MarshalByRefObject, IDbTransaction {
        private  System.Data.IsolationLevel _isolationLevel          = System.Data.IsolationLevel.ReadCommitted; // default isolation level
        internal SqlConnection              _sqlConnection;
        private  SqlCommand                 _transactionLevelCommand = null;
        private  bool                       _disposing;

        internal SqlTransaction(SqlConnection connection, IsolationLevel isoLevel) {
            Debug.Assert(null != connection && (ConnectionState.Open == connection.State), "invalid connection for transaction");
            _sqlConnection  = connection;
            _sqlConnection.LocalTransaction = this;
            _isolationLevel = isoLevel;
        }

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Connection"]/*' />
        public SqlConnection Connection { // MDAC 66655
            get {
                return _sqlConnection;
            }
        }

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.IDbTransaction.Connection"]/*' />
        /// <internalonly/>
        IDbConnection IDbTransaction.Connection {
            get {
                return Connection;
            }
        }

        internal void Zombie() {
            // Called by SqlConnection.Close() in the case of a broken connection - 
            // transaction needs to be zombied out without a rollback going to the wire.
            _sqlConnection.LocalTransaction = null;
            _sqlConnection = null;            
        }

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.GetServerTransactionLevel"]/*' />
        private int GetServerTransactionLevel() {
            // This function is needed for those times when it is impossible to determine the server's
            // transaction level, unless the user's arguments were parsed - which is something we don't want
            // to do.  An example when it is impossible to determine the level is after a rollback.
            if (_transactionLevelCommand == null) {
                _transactionLevelCommand             = new SqlCommand("set @out = @@trancount", _sqlConnection);
                _transactionLevelCommand.Transaction = this;

                SqlParameter parameter = new SqlParameter("@out", SqlDbType.Int);
                parameter.Direction    = ParameterDirection.Output;
                _transactionLevelCommand.Parameters.Add(parameter);
            }

            Debug.Assert(_transactionLevelCommand.Connection == _sqlConnection, "transaction command has different connection!");

            // UNDONE: use a singleton select here
            _transactionLevelCommand.ExecuteReader(0, RunBehavior.UntilDone, false /* returnDataStream */);

            return(int) _transactionLevelCommand.Parameters[0].Value;
        }        

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Dispose"]/*' />
        public void Dispose() {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private /*protected override*/ void Dispose(bool disposing) {
            if (disposing) {
                if (null != _sqlConnection) {
                    // implicitly rollback if transaction still valid
                    _disposing = true;
                    this.Rollback();
                }                
            }
        }

        //===============================================================
        // IDbTransaction
        //===============================================================
        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.IsolationLevel"]/*' />
        public IsolationLevel IsolationLevel {
            get {
                // If this transaction has been completed, throw exception since it is unusable.
                if (_sqlConnection == null)
                    throw ADP.TransactionZombied(this);

                return _isolationLevel;
            }
        }
        
        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Commit"]/*' />
        public void Commit() {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476

            // If this transaction has been completed, throw exception since it is unusable.
            if (_sqlConnection == null)
                throw ADP.TransactionZombied(this);

            try {
                // COMMIT ignores transaction names, and so there is no reason to pass it anything.  COMMIT
                // simply commits the transaction from the most recent BEGIN, nested or otherwise.
                _sqlConnection.ExecuteTransaction(TdsEnums.TRANS_COMMIT, ADP.CommitTransaction);

                // Since nested transactions are no longer allowed, set flag to false.
                // This transaction has been completed.
                Zombie();
            }
            catch {
                // if not zombied (connection still open) and not in transaction, zombie
                if (null != _sqlConnection && GetServerTransactionLevel() == 0) {
                    Zombie();
                }

                throw;
            }
        }

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Rollback"]/*' />
        public void Rollback() {
            // If this transaction has been completed, throw exception since it is unusable.
            if (_sqlConnection == null)
                throw ADP.TransactionZombied(this);

            try {
                // If no arg is given to ROLLBACK it will rollback to the outermost begin - rolling back
                // all nested transactions as well as the outermost transaction.
                _sqlConnection.ExecuteTransaction(TdsEnums.TRANS_IF_ROLLBACK, ADP.RollbackTransaction);

                // Since Rollback will rollback to outermost begin, no need to check
                // server transaction level.  This transaction has been completed.
                Zombie();
            }
            catch {
                // if not zombied (connection still open) and not in transaction, zombie
                if (null != _sqlConnection && GetServerTransactionLevel() == 0) {
                    Zombie();
                }
                if (!_disposing) {
                    throw;
                }
            }
        }

        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Rollback1"]/*' />
        public void Rollback(string transactionName) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476, 81678, 82093

            // If this transaction has been completed, throw exception since it is unusable.
            if (_sqlConnection == null)
                throw ADP.TransactionZombied(this);

            // ROLLBACK takes either a save point name or a transaction name.  It will rollback the
            // transaction to either the save point with the save point name or begin with the
            // transacttion name.  NOTE: for simplicity it is possible to give all save point names
            // the same name, and ROLLBACK will simply rollback to the most recent save point with the
            // save point name.
            if (ADP.IsEmpty(transactionName))
                throw SQL.NullEmptyTransactionName();

            try {
                transactionName = SqlConnection.FixupDatabaseTransactionName(transactionName);
                _sqlConnection.ExecuteTransaction(TdsEnums.TRANS_ROLLBACK+" "+transactionName, ADP.RollbackTransaction);

                if (0 == GetServerTransactionLevel()) {
            	  // This transaction has been completed.
                    Zombie();
                }
            }
            catch {
                // if not zombied (connection still open) and not in transaction, zombie
                if (null != _sqlConnection && GetServerTransactionLevel() == 0) {
                    Zombie();
                }

                throw;
            }
        }
        
        /// <include file='doc\SqlTransaction.uex' path='docs/doc[@for="SqlTransaction.Save"]/*' />
        public void Save(string savePointName) {
            SqlConnection.SqlClientPermission.Demand(); // MDAC 81476

            // If this transaction has been completed, throw exception since it is unusable.
            if (_sqlConnection == null)
                throw ADP.TransactionZombied(this);
        
            // ROLLBACK takes either a save point name or a transaction name.  It will rollback the
            // transaction to either the save point with the save point name or begin with the
            // transacttion name.  So, to rollback a nested transaction you must have a save point.
            // SAVE TRANSACTION MUST HAVE AN ARGUMENT!!!  Save Transaction without an arg throws an
            // exception from the server.  So, an overload for SaveTransaction without an arg doesn't make
            // sense to have.  Save Transaction does not affect the transaction level.
            if (ADP.IsEmpty(savePointName))
                throw SQL.NullEmptyTransactionName();

            try {
                savePointName = SqlConnection.FixupDatabaseTransactionName(savePointName);
                _sqlConnection.ExecuteTransaction(TdsEnums.TRANS_SAVE+" "+savePointName, ADP.SaveTransaction);
            }
            catch {
                // if not zombied (connection still open) and not in transaction, zombie
                if (null != _sqlConnection && GetServerTransactionLevel() == 0) {
                    Zombie();
                }

                throw;
            }
        }            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\transaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="Transaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;

    sealed internal class Transaction {
        // static GUID for ITransactionExportFactory
        private static readonly Guid s_transactionExportFactoryGuid = new Guid("E1CF9B53-8745-11ce-A9BA-00AA006C3706");

        // Static function that returns an instance of ITransaction that contains the information
        // for the current transaction context.  If null is returned, there is no transaction present.
        public static ITransaction GetTransaction(out Guid transactionGuid) {
            ITransaction transaction = null;

            // determine if we are in a transaction - if false, there is no transaction present
            if (ContextUtil.IsInTransaction) {
//                if (AdapterSwitches.SqlPooling.TraceVerbose)
//                    Debug.WriteLine("Transaction.GetTransaction(): TransactionId: " + ContextUtil.TransactionId);

                transaction = ContextTransaction();
                transactionGuid = ContextUtil.TransactionId;
            }
            else {
                transactionGuid = Guid.Empty;
                //if (AdapterSwitches.SqlPooling.TraceVerbose)
                //    Debug.WriteLine("Transaction.GetTransaction(): not currently in transaction.");
            }

            return transaction;
        }

        static private ITransaction ContextTransaction() { // MDAC 80681, 81288
            try { // try-filter-finally so and catch-throw
                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Assert(); // MDAC 62028
                try {
                    return (ITransaction) ContextUtil.Transaction;
                }
                finally { // RevertAssert w/ catch-throw
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }

        // Private method that creates a TransactionExport for the passed in DTCAddr.
        private static bool CreateTransactionExport(byte[] dtcAddr, UInt32 dtcLength, 
                                                    ITransaction transaction,
                                                    ref UnsafeNativeMethods.ITransactionExport transactionExport) {
            object transactionExportFactory = null;

            // UNDONE - when not using pooling - the below cast to IGetDispenser call seems to fail
            // on the 3rd pooling object.  Investigate when time permits.

            // cast to IGetDispenser, then call GetDispenser to obtain an 
            // ITtransactionExportFactory interface
            ((UnsafeNativeMethods.IGetDispenser) transaction).GetDispenser(s_transactionExportFactoryGuid, 
                                                       ref transactionExportFactory);

            // cast to ITransactionExportFactory, then make call to create a ITransactionExport
            ((UnsafeNativeMethods.ITransactionExportFactory) transactionExportFactory).Create(dtcLength, dtcAddr, 
                                                                          ref transactionExport);

            // if the create call failed, then transactionExport is null and return false!
            return(null != transactionExport);
        }        

        // Static function that obtains the propagation cookie to be given to the SQL Server to which
        // the connection is made to, so that the server will enlist the connection in the 
        // distributed transaction.  Function returns bool indicating whether the cookie was obtained.
        public static bool GetTransactionCookie(byte[] dtcAddr, ITransaction transaction, 
                                                ref UnsafeNativeMethods.ITransactionExport transactionExport,
                                                ref byte[] cookie, ref int length) {
            bool fSuccess = true;

            Debug.Assert(dtcAddr != null, "GetTransactionCookie: dtcAddr null!");
            Debug.Assert(transaction != null, "GetTransactionCookie: transaction null!");

            // local UInt32 variables, since the interfaces expect the UInt32 type
            UInt32 cookieLength = 0;
            UInt32 dtcLength    = (UInt32) dtcAddr.Length;

            // if the user's transactionExport is null, create one for them!
            if (null == transactionExport) {
                // if creation fails, return false so connection will re-obtain DTC and retry
                if (!CreateTransactionExport(dtcAddr, dtcLength, transaction, 
                                             ref transactionExport))
                    fSuccess = false;
            }

            if (fSuccess) {
                // obtain the cookie length
                transactionExport.Export(transaction, ref cookieLength);

                // If export call failed, kill the instance of transactionExport and return false!
                // Checked with ShaiwalS, and this is the correct behavior.
                if (0 == cookieLength) {
                    transactionExport = null;
                    fSuccess = false;
                }
                else {
                    // allocate the cookie to be the appropriate length
                    cookie = new byte[(int) cookieLength];

                    // obtain the cookie
                    transactionExport.GetTransactionCookie(transaction, cookieLength, cookie, ref cookieLength);

                    // set the passed in length - before we were using local UInt32
                    length = (int) cookieLength;

                    //if (AdapterSwitches.SqlPooling.TraceVerbose) {
                    //    Debug.WriteLine("Transaction.GetTransactionCookie(): cookieLength: " + cookieLength.ToString());
                    //    Debug.WriteLine("Transaction.GetTransactionCookie(): cookie: ");
                    //    for (int i=0; i<cookieLength; i++) 
                    //        Debug.Write((cookie[i]).ToString("x2") + " ");

                    //    Debug.WriteLine("");
                    //}
                }
            }

            return fSuccess;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\sqlutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Threading;

    sealed internal class SQL : ADP {
        // instance perfcounters
        private static PerformanceCounter _connectionCount;
        private static PerformanceCounter _pooledConnectionCount;
        private static PerformanceCounter _poolCount;
        private static PerformanceCounter _peakPoolConnectionCount;
        private static PerformanceCounter _failedConnectCount;
        private static PerformanceCounter _failedCommandCount;

        // instance perfcounters
        private static PerformanceCounter _globalConnectionCount;
        private static PerformanceCounter _globalPooledConnectionCount;
        private static PerformanceCounter _globalPoolCount;
        // peakPoolConnectionCount does not apply to global
        private static PerformanceCounter _globalFailedConnectCount;
        private static PerformanceCounter _globalFailedCommandCount;

        private const string SqlPerfCategory = ".NET CLR Data";
        private const string SqlPerfConnections = "SqlClient: Current # pooled and nonpooled connections";
        private const string SqlPerfPooledConnections = "SqlClient: Current # pooled connections";
        private const string SqlPerfConnectionPools = "SqlClient: Current # connection pools";
        private const string SqlPerfPeakPoolConnections = "SqlClient: Peak # pooled connections";
        private const string SqlPerfFailedConnects = "SqlClient: Total # failed connects";
        private const string SqlPerfFailedCommands = "SqlClient: Total # failed commands";

        private const string SqlPerfCategoryHelp = ".Net CLR Data";
        private const string SqlPerfConnectionsHelp = "Current number of connections, pooled or not.";
        private const string SqlPerfPooledConnectionsHelp = "Current number of connections in all pools associated with the process.";
        private const string SqlPerfConnectionPoolsHelp = "Current number of pools associated with the process.";
        private const string SqlPerfPeakPoolConnectionsHelp = "The highest number of connections in all pools since the process started.";
        private const string SqlPerfFailedConnectsHelp = "The total number of connection open attempts that have failed for any reason.";
        private const string SqlPerfFailedCommandsHelp = "The total number of command executes that have failed for any reason.";

        private const string Global = "_Global_";

        private static bool _s_fInit = false;

        private static void Init() {
            if (!_s_fInit) {
                try {
                    lock(typeof(SQL)) {
                        if (!_s_fInit) {
                            _s_fInit = true;

                            // wrap for security failures
                            try {
                                if (SQL.IsPlatformNT5()) {
                                    string instance = null; // instance perfcounter name

                                    // First try GetEntryAssembly name, then AppDomain.FriendlyName.
                                    Assembly assembly = Assembly.GetEntryAssembly();

                                    if (null != assembly) {
                                        instance = assembly.GetName().Name; // MDAC 73469
                                    }

                                    if (ADP.IsEmpty(instance)) {
                                        AppDomain appDomain = AppDomain.CurrentDomain;
                                        if (null != appDomain) {
                                            instance = appDomain.FriendlyName;
                                        }
                                    }
                                    InitCounters(instance);
                                }
                            }
                            catch(Exception e) {
                                ADP.TraceException(e);
                            }
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        static private void InitCounters(string instance) {
            try { // try-filter-finally so and catch-throw
                (new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Instrument, ".", SqlPerfCategory)).Assert();
                try {
                    if (!ADP.IsEmpty(instance)) {
                        _connectionCount = new PerformanceCounter(SqlPerfCategory, SqlPerfConnections, instance, false);
                        _pooledConnectionCount = new PerformanceCounter(SqlPerfCategory, SqlPerfPooledConnections, instance, false);
                        _poolCount = new PerformanceCounter(SqlPerfCategory, SqlPerfConnectionPools, instance, false);
                        _peakPoolConnectionCount = new PerformanceCounter(SqlPerfCategory, SqlPerfPeakPoolConnections, instance, false);
                        _failedConnectCount = new PerformanceCounter(SqlPerfCategory, SqlPerfFailedConnects, instance, false);
                        _failedCommandCount = new PerformanceCounter(SqlPerfCategory, SqlPerfFailedCommands, instance, false);
                    }
                                        
                    // global perfcounters
                    _globalConnectionCount = new PerformanceCounter(SqlPerfCategory, SqlPerfConnections, Global, false);
                    _globalPooledConnectionCount = new PerformanceCounter(SqlPerfCategory, SqlPerfPooledConnections, Global, false);
                    _globalPoolCount = new PerformanceCounter(SqlPerfCategory, SqlPerfConnectionPools, Global, false);

                    // peakPoolConnectionCount does not apply to global
                    _globalFailedConnectCount = new PerformanceCounter(SqlPerfCategory, SqlPerfFailedConnects, Global, false);
                    _globalFailedCommandCount = new PerformanceCounter(SqlPerfCategory, SqlPerfFailedCommands, Global, false);
                }
                finally { // RevertAssert w/ catch-throw
                    PerformanceCounterPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }        
        }

        static internal string GetCurrentName() {
            try { // try-filter-finally so and catch-throw
                (new SecurityPermission(SecurityPermissionFlag.ControlPrincipal)).Assert(); // MDAC 66683
                try {
                    return WindowsIdentity.GetCurrent().Name;
                }
                finally { // RevertAssert w/ catch-throw
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }        
        }
        
        static internal bool IsPlatformNT5() { // MDAC 77693
            OperatingSystem system = Environment.OSVersion;
            return ((PlatformID.Win32NT == system.Platform) && (system.Version.Major >= 5));
        }

        static internal bool IsPlatformWin9x() {
            OperatingSystem system = Environment.OSVersion;
            return !(PlatformID.Win32NT == system.Platform);
        }

        public static void IncrementConnectionCount() {
            Init();
            IncrementCounter(_connectionCount);
            IncrementCounter(_globalConnectionCount);
        }
        public static void DecrementConnectionCount() {
            Init();
            DecrementCounter(_connectionCount);
            DecrementCounter(_globalConnectionCount);
        }

        public static void IncrementPooledConnectionCount() {
            Init();
            IncrementCounter(_pooledConnectionCount);
            IncrementCounter(_globalPooledConnectionCount);            
        }
        public static void DecrementPooledConnectionCount() {
            Init();
            DecrementCounter(_pooledConnectionCount);
            DecrementCounter(_globalPooledConnectionCount);
        }

        public static void IncrementPoolCount() {
            Init();
            IncrementCounter(_poolCount);
            IncrementCounter(_globalPoolCount);            
        }
        public static void DecrementPoolCount() {
            Init();
            DecrementCounter(_poolCount);
            DecrementCounter(_globalPoolCount);
        }

        public static void PossibleIncrementPeakPoolConnectionCount() {
            Init();
            if (null != _pooledConnectionCount) {
                Int64 count = _pooledConnectionCount.RawValue;
                
                if (null != _peakPoolConnectionCount) {
                    if (count > _peakPoolConnectionCount.RawValue) {
                        _peakPoolConnectionCount.RawValue = count;
                    }
                }
            }
        }

        public static void IncrementFailedConnectCount() {
            Init();
            IncrementCounter(_failedConnectCount);
            IncrementCounter(_globalFailedConnectCount);            
        }

        public static void IncrementFailedCommandCount() {
            Init();
            IncrementCounter(_failedCommandCount);
            IncrementCounter(_globalFailedCommandCount);            
        }

        private static void IncrementCounter(PerformanceCounter pfc) {
            if (null != pfc) {
                pfc.Increment(); 
            }
        }
        private static void DecrementCounter(PerformanceCounter pfc) {
            if (null != pfc) {
                pfc.Decrement();
            }
        }
        
        // The class SQL defines the exceptions that are specific to the SQL Adapter.
        // The class contains functions that take the proper informational variables and then construct
        // the appropriate exception with an error string obtained from the resource Framework.txt.
        // The exception is then returned to the caller, so that the caller may then throw from its
        // location so that the catcher of the exception will have the appropriate call stack.
        // This class is used so that there will be compile time checking of error
        // messages.  The resource Framework.txt will ensure proper string text based on the appropriate
        // locale.

        //
        // SQL specific exceptions
        //

        //
        // SQL.Connection
        //

        static internal Exception InvalidConnectionOptionValue(string key, string value) {
            return Argument(Res.GetString(Res.SQL_InvalidConnectionOptionValue, key, value));
        }
        static internal Exception InvalidIsolationLevelPropertyArg() {
            return Argument(Res.GetString(Res.SQL_InvalidIsolationLevelPropertyArg));
        }
        static internal Exception InvalidMinMaxPoolSizeValues() {
            return Argument(Res.GetString(Res.SQL_InvalidMinMaxPoolSizeValues));
        }
        static internal Exception InvalidOptionLength(string key) {
            return Argument(Res.GetString(Res.SQL_InvalidOptionLength, key));
        }
        static internal Exception InvalidPacketSizeValue() {
            return Argument(Res.GetString(Res.SQL_InvalidPacketSizeValue));
        }
        static internal Exception NullEmptyTransactionName() {
            return Argument(Res.GetString(Res.SQL_NullEmptyTransactionName));
        }
        static internal Exception IntegratedSecurityError(string error) {
            return DataProvider(Res.GetString(Res.SQL_IntegratedSecurityError, error));
        }
        static internal Exception InvalidSQLServerVersion(string version) {
            return DataProvider(Res.GetString(Res.SQL_InvalidSQLServerVersion, version));
        }        
        static internal Exception TransactionEnlistmentError() {
            return DataProvider(Res.GetString(Res.SQL_TransactionEnlistmentError));
        }
        static internal Exception ConnectionPoolingError() {
            return InvalidOperation(Res.GetString(Res.SQL_ConnectionPoolingError));
        }
        static internal Exception PooledOpenTimeout() {
            return InvalidOperation(Res.GetString(Res.SQL_PooledOpenTimeout));
        }
        static internal Exception NoSSPI() {
            return TypeLoad(Res.GetString(Res.SQL_NoSSPI));
        }

        //
        // SQL.DataCommand
        //
        static internal Exception TableDirectNotSupported() {
            return Argument(Res.GetString(Res.SQL_TableDirectNotSupported));
        }            
        static internal Exception NonXmlResult() {
            return InvalidOperation(Res.GetString(Res.SQL_NonXmlResult));
        }

        //
        // SQL.DataParameter
        //
        static internal Exception InvalidParameterNameLength() {
            return Argument(Res.GetString(Res.SQL_InvalidParameterNameLength));
        }
        static internal Exception ParameterValueOutOfRange(string value) {
            return Argument(Res.GetString(Res.SQL_ParameterValueOutOfRange, value));
        }
        static internal Exception PrecisionValueOutOfRange(int precision) {
            return Argument(Res.GetString(Res.SQL_PrecisionValueOutOfRange, precision.ToString()));
        }
        static internal Exception InvalidSqlDbType(string pmName, int value) {
            return ArgumentOutOfRange(Res.GetString(Res.SQL_InvalidSqlDbType, pmName, (value).ToString()));
        }
        static internal Exception ParameterInvalidVariant(string paramName) {
            return InvalidOperation(Res.GetString(Res.SQL_ParameterInvalidVariant, paramName));
        }

        //
        // SQL.SqlDataAdapter
        //
        static internal Exception ExecuteRequiresCommand() {
            return Argument(Res.GetString(Res.SQL_ExecuteRequiresCommand));
        }
        static internal Exception NoKeyColumnDefined(string tableName) {
            return InvalidOperation(Res.GetString(Res.SQL_NoKeyColumnDefined, tableName));
        }

        //
        // SQL.TDSParser
        //
        static internal Exception MDAC_WrongVersion() {
            return DataProvider(Res.GetString(Res.SQL_MDAC_WrongVersion));
        }
        static internal Exception ComputeByNotSupported() {
            return InvalidOperation(Res.GetString(Res.SQL_ComputeByNotSupported));
        }
        static internal Exception ParsingError() {
            return InvalidOperation(Res.GetString(Res.SQL_ParsingError));
        }
        static internal Exception MoneyOverflow(string moneyValue) {
            return Overflow(Res.GetString(Res.SQL_MoneyOverflow, moneyValue));
        }
        static internal Exception SmallDateTimeOverflow(string datetime) {
            return Overflow(Res.GetString(Res.SQL_SmallDateTimeOverflow, datetime));
        }

        //
        // SQL.SqlDataReader
        //
        static internal Exception InvalidObjectColumnNotFound(string column) {
            return Argument(Res.GetString(Res.SQL_InvalidObjectColumnNotFound, column));
        }
        static internal Exception InvalidObjectNotAssignable(string field, string column) {
            return Argument(Res.GetString(Res.SQL_InvalidObjectNotAssignable, field, column));
        }
        static internal Exception InvalidObjectSize(int size) {
            return Argument(Res.GetString(Res.SQL_InvalidObjectSize, size.ToString()));
        }
        static internal Exception InvalidRead() {
            return InvalidOperation(Res.GetString(Res.SQL_InvalidRead));
        }
        static internal Exception NonBlobColumn(string columnName) {
            return InvalidCast(Res.GetString(Res.SQL_NonBlobColumn, columnName));
        }        
    }

    sealed internal class SQLMessage {
        // The class SQLMessage defines the error messages that are specific to the SqlDataAdapter
        // that are caused by a netlib error.  The functions will be called and then return the
        // appropriate error message from the resource Framework.txt.  The SqlDataAdapter will then
        // take the error message and then create a SqlError for the message and then place
        // that into a SqlException that is either thrown to the user or cached for throwing at
        // a later time.  This class is used so that there will be compile time checking of error
        // messages.  The resource Framework.txt will ensure proper string text based on the appropriate
        // locale.

        static internal string ZeroBytes() {
            return Res.GetString(Res.SQL_ZeroBytes);
        }
        static internal string Timeout() {
            return Res.GetString(Res.SQL_Timeout);
        }
        static internal string Unknown() {
            return Res.GetString(Res.SQL_Unknown);
        }
        static internal string InsufficientMemory() {
            return Res.GetString(Res.SQL_InsufficientMemory);
        }
        static internal string AccessDenied() {
            return Res.GetString(Res.SQL_AccessDenied);
        }
        static internal string ConnectionBusy() {
            return Res.GetString(Res.SQL_ConnectionBusy);
        }
        static internal string ConnectionBroken() {
            return Res.GetString(Res.SQL_ConnectionBroken);
        }
        static internal string ConnectionLimit() {
            return Res.GetString(Res.SQL_ConnectionLimit);
        }
        static internal string ServerNotFound(string server) {
            return Res.GetString(Res.SQL_ServerNotFound, server);
        }
        static internal string NetworkNotFound() {
            return Res.GetString(Res.SQL_NetworkNotFound);
        }
        static internal string InsufficientResources() {
            return Res.GetString(Res.SQL_InsufficientResources);
        }
        static internal string NetworkBusy() {
            return Res.GetString(Res.SQL_NetworkBusy);
        }
        static internal string NetworkAccessDenied() {
            return Res.GetString(Res.SQL_NetworkAccessDenied);
        }
        static internal string GeneralError() {
            return Res.GetString(Res.SQL_GeneralError);
        }
        static internal string IncorrectMode() {
            return Res.GetString(Res.SQL_IncorrectMode);
        }
        static internal string NameNotFound() {
            return Res.GetString(Res.SQL_NameNotFound);
        }
        static internal string InvalidConnection() {
            return Res.GetString(Res.SQL_InvalidConnection);
        }
        static internal string ReadWriteError() {
            return Res.GetString(Res.SQL_ReadWriteError);
        }
        static internal string TooManyHandles() {
            return Res.GetString(Res.SQL_TooManyHandles);
        }
        static internal string ServerError() {
            return Res.GetString(Res.SQL_ServerError);
        }
        static internal string SSLError() {
            return Res.GetString(Res.SQL_SSLError);
        }
        static internal string EncryptionError() {
            return Res.GetString(Res.SQL_EncryptionError);
        }
        static internal string EncryptionNotSupported() {
            return Res.GetString(Res.SQL_EncryptionNotSupported);
        }
        static internal string SSPIInitializeError() {
            return Res.GetString(Res.SQL_SSPIInitializeError);
        }
        static internal string SSPIGenerateError() {
            return Res.GetString(Res.SQL_SSPIGenerateError);
        }
        static internal string SevereError() {
            return Res.GetString(Res.SQL_SevereError);
        }
        static internal string OperationCancelled() {
            return Res.GetString(Res.SQL_OperationCancelled);
        }
        static internal string CultureIdError() {
            return Res.GetString(Res.SQL_CultureIdError);
        }
    }
}//namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqldatetime.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLDateTime.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlDateTime.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlDateTime which is equivalent to 
//            data type "datetime" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {
    using System.Threading;

    /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the date and time data ranging in value
    ///       from January 1, 1753 to December 31, 9999 to an accuracy of 3.33 milliseconds
    ///       to be stored in or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlDateTime : INullable, IComparable {
        private int m_day;      // Day from 1900/1/1, could be negative. Range: Jan 1 1753 - Dec 31 9999.
        private int m_time;     // Time in the day in term of ticks
        private bool m_fNotNull;    // false if null

        // Constants

        // Number of (100ns) ticks per time unit
        private static readonly double  SQLTicksPerMillisecond = 0.3;
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SQLTicksPerSecond"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly int      SQLTicksPerSecond = 300;
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SQLTicksPerMinute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly int      SQLTicksPerMinute = SQLTicksPerSecond * 60;
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SQLTicksPerHour"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly int      SQLTicksPerHour = SQLTicksPerMinute * 60;
        private static readonly int     SQLTicksPerDay = SQLTicksPerHour * 24;

        private static readonly long    TicksPerSecond = TimeSpan.TicksPerMillisecond * 1000;

        private static readonly DateTime SQLBaseDate = new DateTime(1900, 1, 1);

        private static readonly int MinYear = 1753;                 // Jan 1 1753
        private static readonly int MaxYear = 9999;                 // Dec 31 9999

        private static readonly int MinDay  = -53690;               // Jan 1 1753
        private static readonly int MaxDay  = 2958463;              // Dec 31 9999 is this many days from Jan 1 1900
        private static readonly int MinTime = 0;                    // 00:00:0:000PM
        private static readonly int MaxTime = SQLTicksPerDay - 1;   // = 25919999,  11:59:59:997PM

        private static readonly int DayBase = 693595;               // Jan 1 1900 is this many days from Jan 1 0001


        private static readonly int[] DaysToMonth365 = new int[] {
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
        private static readonly int[] DaysToMonth366 = new int[] {
            0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};

        private static readonly DateTime MinDateTime = new DateTime(1753, 1, 1);
        private static readonly DateTime MaxDateTime = DateTime.MaxValue;
        private static readonly TimeSpan MinTimeSpan = MinDateTime.Subtract(SQLBaseDate);
        private static readonly TimeSpan MaxTimeSpan = MaxDateTime.Subtract(SQLBaseDate);

        // These formats are valid styles in SQL Server (style 9, 12, 13, 14)
        // but couldn't be recognized by the default parse. Needs to call
        // ParseExact in addition to recognize them.
        private static readonly String[] x_DateTimeFormats = {
                "MMM d yyyy hh:mm:ss:ffftt",
                "MMM d yyyy hh:mm:ss:fff",
                "d MMM yyyy hh:mm:ss:ffftt",
                "d MMM yyyy hh:mm:ss:fff",
                "hh:mm:ss:ffftt",
                "hh:mm:ss:fff",
                "yyMMdd",
                "yyyyMMdd"
            };
        private const DateTimeStyles x_DateTimeStyle = DateTimeStyles.AllowWhiteSpaces;

        // construct a Null
        private SqlDateTime(bool fNull) {
            m_fNotNull = false;
            m_day = 0;
            m_time = 0;
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(DateTime value) {
            this = FromDateTime(value);
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(int year, int month, int day) 
            : this(year, month, day, 0, 0, 0, 0.0) {
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(int year, int month, int day, int hour, int minute, int second)
            : this(year, month, day, hour, minute, second, 0.0) {
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(int year, int month, int day, int hour, int minute, int second, double millisecond) {
            if (year >= MinYear && year <= MaxYear && month >= 1 && month <= 12) 
            {
                int[] days = IsLeapYear(year)? DaysToMonth366: DaysToMonth365;
                if (day >= 1 && day <= days[month] - days[month - 1]) 
                {
                    int y = year - 1;
                    int dayticks = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;
                    dayticks -= DayBase;

                    if (dayticks >= MinDay && dayticks <= MaxDay &&
                        millisecond >= 0 && millisecond < 1000.0) 
                    {
                        double ticksForMilisecond = millisecond * SQLTicksPerMillisecond + 0.5;
                        bool fRoundUp = ((int)ticksForMilisecond != (int)(millisecond * SQLTicksPerMillisecond));
                        int timeticks = hour * SQLTicksPerHour + minute * SQLTicksPerMinute + second * SQLTicksPerSecond +
                            (int)ticksForMilisecond;

                        if (fRoundUp && timeticks == MaxTime + 1) 
                        {
                            // If the round up makes the time portion overflow,
                            // Make time to be zero, and increment day.
                            timeticks = 0;
                            dayticks ++;
                        }

                        // Success. Call ctor here which will again check dayticks and timeticks are within range. 
                        // All other cases will throw exception below.
                        this = new SqlDateTime(dayticks, timeticks);
                        return;
                    }
                }
            }

            throw new SqlTypeException(SQLResource.InvalidDateTimeMessage);
        }

        // constructor that take DBTIMESTAMP data members
        // Note: bilisecond is same as 'fraction' in DBTIMESTAMP
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(int year, int month, int day, int hour, int minute, int second, int bilisecond)
        : this (year, month, day, hour, minute, second, (double)bilisecond / 1000.0) {
        }


        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.SqlDateTime5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDateTime(int dayTicks, int timeTicks) {
            if (dayTicks < MinDay || dayTicks > MaxDay || timeTicks < MinTime || timeTicks > MaxTime) {
                m_fNotNull = false;
                throw new OverflowException(SQLResource.DateTimeOverflowMessage);
            }

            m_day = dayTicks;
            m_time = timeTicks;
            m_fNotNull = true;
        }

        internal SqlDateTime(double dblVal) {
            if ((dblVal < MinDay) || (dblVal >= MaxDay + 1))
                throw new OverflowException(SQLResource.DateTimeOverflowMessage);

            int day = (int) dblVal;
            int time = (int)((dblVal - day) * SQLTicksPerDay);

            // Check if we need to borrow a day from the day portion.
            if (time < 0) {
                day --;
                time += SQLTicksPerDay;
            }
            else if (time >= SQLTicksPerDay) {
                // Deal with case where time portion = 24 hrs.
                //
                // ISSUE: Is this code reachable?  For this code to be reached there
                //    must be a value for dblVal such that:
                //        dblVal - (long)dblVal = 1.0
                //    This seems odd, but there was a bug (51261) that resulted because 
                //    there was a negative value for dblVal such that dblVal + 1.0 = 1.0
                //
                day ++;
                time -= SQLTicksPerDay;
            }

            m_day = day;
            m_time = time;
            m_fNotNull = true;
        }


        // INullable
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }


        private static TimeSpan ToTimeSpan(SqlDateTime value) {
			long millisecond = (long)(value.m_time / SQLTicksPerMillisecond + 0.5);
            return new TimeSpan(value.m_day * TimeSpan.TicksPerDay + 
                                millisecond * TimeSpan.TicksPerMillisecond);
        }

        private static DateTime ToDateTime(SqlDateTime value) {
            return SQLBaseDate.Add(ToTimeSpan(value));
        }

        // Convert from TimeSpan, rounded to one three-hundredth second, due to loss of precision
        private static SqlDateTime FromTimeSpan(TimeSpan value) {
			if (value < MinTimeSpan || value > MaxTimeSpan)
                throw new SqlTypeException(SQLResource.DateTimeOverflowMessage);

            int day = value.Days;

            long ticks = value.Ticks - day * TimeSpan.TicksPerDay;

            if (ticks < 0L) {
                day --;
                ticks += TimeSpan.TicksPerDay;
            }

            int time = (int)((double)ticks / TimeSpan.TicksPerMillisecond * SQLTicksPerMillisecond + 0.5);
            if (time > MaxTime) {
                // Only rounding up could cause time to become greater than MaxTime.
                SQLDebug.Check(time == MaxTime + 1);

                // Make time to be zero, and increment day.
                time = 0;
                day ++;
			}

            return new SqlDateTime(day, time);
        }

        private static SqlDateTime FromDateTime(DateTime value) {
            // DevNote: SqlDateTime has smaller precision and range than DateTime.
            // Usually we round the DateTime value to the nearest SqlDateTime value.
            // but for DateTime.MaxValue, if we round it up, it will overflow.
            // Although the overflow would be the correct behavior, we simply
            // returned SqlDateTime.MaxValue in v1. In order not to break exisiting
            // code, we'll keep this logic.
            //
            if (value == DateTime.MaxValue)
                return SqlDateTime.MaxValue;
            return FromTimeSpan(value.Subtract(SQLBaseDate));
        }

        internal static SqlDateTime FromDouble(double dblVal) {
            return new SqlDateTime(dblVal);
        }

        internal static double ToDouble(SqlDateTime x) {
            AssertValidSqlDateTime(x);
            return(double)x.m_day + ((double)x.m_time / (double)SQLTicksPerDay);
        }

        internal static int ToInt(SqlDateTime x) {
            AssertValidSqlDateTime(x);
            return x.m_time >= MaxTime / 2 ? x.m_day + 1 : x.m_day;
        }


        // do we still want to define a property of DateTime? If the user uses it often, it is expensive
        // property: Value
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime Value {
            get {
                if (m_fNotNull)
                    return ToDateTime(this);
                else
                    throw new SqlNullValueException();
            }           
        }

        // Day ticks -- returns number of days since 1/1/1900
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.DayTicks"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int DayTicks {
            get {
                if (m_fNotNull)
                    return m_day;
                else
                    throw new SqlNullValueException();
            }           
        }

        // Time ticks -- return daily time in unit of 1/300 second
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.TimeTicks"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int TimeTicks {
            get {
                if (m_fNotNull)
                    return m_time;
                else
                    throw new SqlNullValueException();
            }           
        }

        // Implicit conversion from DateTime to SqlDateTime
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operatorSqlDateTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDateTime(DateTime value) {
            return new SqlDateTime(value);
        }

        // Explicit conversion from SqlDateTime to int. Returns 0 if x is Null.
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operatorDateTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator DateTime(SqlDateTime x) {
            return ToDateTime(x);
        }

        // Return string representation of SqlDateTime
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            if (IsNull)
                return SQLResource.NullString;

            DateTime dateTime = ToDateTime(this);
            return dateTime.ToString();
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDateTime Parse(String s) {
            DateTime dt;
            
            try {
                dt = DateTime.Parse(s, CultureInfo.InvariantCulture);
            }
            catch (FormatException) {
                DateTimeFormatInfo dtfi = (DateTimeFormatInfo)(Thread.CurrentThread.CurrentCulture.GetFormat(typeof(DateTimeFormatInfo)));
                dt = DateTime.ParseExact(s, x_DateTimeFormats, dtfi, x_DateTimeStyle);
            }

            return new SqlDateTime(dt);
        }


        // Binary operators

        // Arithmetic operators

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDateTime operator +(SqlDateTime x, TimeSpan t) {
            return x.IsNull ? Null : FromDateTime(ToDateTime(x) + t);
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDateTime operator -(SqlDateTime x, TimeSpan t) {
            return x.IsNull ? Null : FromDateTime(ToDateTime(x) - t);
        }



/*
        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlDateTime
        public static implicit operator SqlDateTime(SqlBoolean x)
            {
            return x.IsNull ? Null : new SqlDateTime(x.Value, 0);
            }

        // Implicit conversion from SqlInt32 to SqlDateTime
        public static implicit operator SqlDateTime(SqlInt32 x)
            {
            return x.IsNull ? Null : new SqlDateTime(x.Value, 0);
            }

        // Implicit conversion from SqlMoney to SqlDateTime
        public static implicit operator SqlDateTime(SqlMoney x)
            {
            return x.IsNull ? Null : SqlDateTime.FromDouble(x.ToDouble());
            }


        // Explicit conversions

        // Explicit conversion from SqlDateTime to SqlInt32
        public static explicit operator SqlInt32(SqlDateTime x)
            {
            if (x.IsNull)
                return SqlInt32.Null;

            return new SqlInt32(SqlDateTime.ToInt(x));
            }

        // Explicit conversion from SqlDateTime to SqlBoolean
        public static explicit operator SqlBoolean(SqlDateTime x)
            {
            if (x.IsNull)
                return SqlBoolean.Null;

            return new SqlBoolean(x.m_day != 0 || x.m_time != 0, false);
            }

        // Explicit conversion from SqlDateTime to SqlMoney
        public static explicit operator SqlMoney(SqlDateTime x)
            {
            return x.IsNull ? SqlMoney.Null : new SqlMoney(SqlDateTime.ToDouble(x));
            }

        // Implicit conversion from SqlDouble to SqlDateTime
        public static implicit operator SqlDateTime(SqlDouble x)
            {
            return x.IsNull ? Null : new SqlDateTime(x.Value);
            }

        // Explicit conversion from SqlDateTime to SqlDouble
        public static explicit operator SqlDouble(SqlDateTime x)
            {
            return x.IsNull ? SqlDouble.Null : new SqlDouble(SqlDateTime.ToDouble(x));
            }


        // Implicit conversion from SqlDecimal to SqlDateTime
        public static implicit operator SqlDateTime(SqlDecimal x)
            {
            return x.IsNull ? SqlDateTime.Null : new SqlDateTime(SqlDecimal.ToDouble(x));
            }

        // Explicit conversion from SqlDateTime to SqlDecimal
        public static explicit operator SqlDecimal(SqlDateTime x)
            {
            return x.IsNull ? SqlDecimal.Null : new SqlDecimal(SqlDateTime.ToDouble(x));
            }

*/

        // Explicit conversion from SqlString to SqlDateTime
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operatorSqlDateTime1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDateTime(SqlString x) {
            return x.IsNull ? SqlDateTime.Null : SqlDateTime.Parse(x.Value);
        }



        // Builtin functions


        // utility functions
        private static void AssertValidSqlDateTime(SqlDateTime x) {
            SQLDebug.Check(!x.IsNull, "!x.IsNull", "Datetime: Null");
            SQLDebug.Check(x.m_day >= MinDay && x.m_day <= MaxDay, "day >= MinDay && day <= MaxDay", 
                           "DateTime: Day out of range");
            SQLDebug.Check(x.m_time >= MinTime && x.m_time <= MaxTime, "time >= MinTime && time <= MaxTime", 
                           "DateTime: Time out of range");
        }

        // Checks whether a given year is a leap year. This method returns true if
        // "year" is a leap year, or false if not.
        //
        // @param year The year to check.
        // @return true if "year" is a leap year, false otherwise.
        //
        private static bool IsLeapYear(int year) {
            return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlDateTime x, SqlDateTime y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_day == y.m_day && x.m_time == y.m_time);
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlDateTime x, SqlDateTime y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlDateTime x, SqlDateTime y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : 
                new SqlBoolean(x.m_day < y.m_day || (x.m_day == y.m_day && x.m_time < y.m_time));
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlDateTime x, SqlDateTime y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : 
                new SqlBoolean(x.m_day > y.m_day || (x.m_day == y.m_day && x.m_time > y.m_time));
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlDateTime x, SqlDateTime y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : 
                new SqlBoolean(x.m_day < y.m_day || (x.m_day == y.m_day && x.m_time <= y.m_time));
        }

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlDateTime x, SqlDateTime y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : 
                new SqlBoolean(x.m_day > y.m_day || (x.m_day == y.m_day && x.m_time >= y.m_time));
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ==
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.Equals1"]/*' />
        public static SqlBoolean Equals(SqlDateTime x, SqlDateTime y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlDateTime x, SqlDateTime y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlDateTime x, SqlDateTime y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlDateTime x, SqlDateTime y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlDateTime x, SqlDateTime y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlDateTime x, SqlDateTime y) {
            return (x >= y);
        }

        // Alternative method for conversions.
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlDateTime) {
                SqlDateTime i = (SqlDateTime)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlDateTime)) {
                return false;
            }

            SqlDateTime i = (SqlDateTime)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDateTime MinValue = new SqlDateTime(MinDay, 0);
        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDateTime MaxValue = new SqlDateTime(MaxDay, MaxTime);

        /// <include file='doc\SQLDateTime.uex' path='docs/doc[@for="SqlDateTime.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDateTime Null = new SqlDateTime(true);

    } // SqlDateTime

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlbyte.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLByte.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlByte.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlByte which is equivalent to 
//            data type "smallint" in SQL Server
//
// Notes: 
//    
// History:
//
//   11/1/99  JunFang    Created.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an 8-bit unsigned integer to be stored in
    ///       or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlByte : INullable, IComparable {
        private byte    m_value;
        private bool    m_fNotNull; // false if null

        private static readonly int x_iBitNotByteMax    = ~0xff;

        // constructor
        // construct a Null
        private SqlByte(bool fNull) {
            m_fNotNull = false;
            m_value = 0;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.SqlByte"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlByte(byte value) {
            m_value = value;
            m_fNotNull = true;
        }

        // INullable
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte Value {
            get {
                if (m_fNotNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from byte to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlByte(byte x) {
            return new SqlByte(x);
        }

        // Explicit conversion from SqlByte to byte. Throw exception if x is Null.
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorbyte"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator byte(SqlByte x) {
            return x.Value;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte Parse(String s) {
            return new SqlByte(Byte.Parse(s));
        }


        // Unary operators
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator~"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator ~(SqlByte x) {
            return x.IsNull ? Null : new SqlByte((byte)~x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator +(SqlByte x, SqlByte y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value + (int)y.m_value;
            if ((iResult & x_iBitNotByteMax) != 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlByte((byte)iResult);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator -(SqlByte x, SqlByte y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value - (int)y.m_value;
            if ((iResult & x_iBitNotByteMax) != 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlByte((byte)iResult);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator *(SqlByte x, SqlByte y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value * (int)y.m_value;
            if ((iResult & x_iBitNotByteMax) != 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlByte((byte)iResult);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator /(SqlByte x, SqlByte y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                return new SqlByte((byte)(x.m_value / y.m_value));
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator%"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator %(SqlByte x, SqlByte y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                return new SqlByte((byte)(x.m_value % y.m_value));
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        // Bitwise operators
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorAMP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator &(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlByte((byte)(x.m_value & y.m_value));
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator|"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator |(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlByte((byte)(x.m_value | y.m_value));
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator^"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlByte operator ^(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlByte((byte)(x.m_value ^ y.m_value));
        }



        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlBoolean x) {
            return x.IsNull ? Null : new SqlByte((byte)(x.ByteValue));
        }


        // Explicit conversions

        // Explicit conversion from SqlMoney to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlMoney x) {
            return x.IsNull ? Null : new SqlByte(checked((byte)x.ToInt32()));
        }

        // Explicit conversion from SqlInt16 to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlInt16 x) {
            if (x.IsNull)
                return Null;

            if (x.Value > (short)Byte.MaxValue || x.Value < (short)Byte.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return x.IsNull ? Null : new SqlByte((byte)(x.Value));
        }

        // Explicit conversion from SqlInt32 to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlInt32 x) {
            if (x.IsNull)
                return Null;

            if (x.Value > (int)Byte.MaxValue || x.Value < (int)Byte.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return x.IsNull ? Null : new SqlByte((byte)(x.Value));
        }

        // Explicit conversion from SqlInt64 to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlInt64 x) {
            if (x.IsNull)
                return Null;

            if (x.Value > (long)Byte.MaxValue || x.Value < (long)Byte.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return x.IsNull ? Null : new SqlByte((byte)(x.Value));
        }

        // Explicit conversion from SqlSingle to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlSingle x) {
            if (x.IsNull)
                return Null;

            if (x.Value > (float)Byte.MaxValue || x.Value < (float)Byte.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return x.IsNull ? Null : new SqlByte((byte)(x.Value));
        }

        // Explicit conversion from SqlDouble to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlDouble x) {
            if (x.IsNull)
                return Null;

            if (x.Value > (double)Byte.MaxValue || x.Value < (double)Byte.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return x.IsNull ? Null : new SqlByte((byte)(x.Value));
        }

        // Explicit conversion from SqlDecimal to SqlByte
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlDecimal x) {
            return(SqlByte)(SqlInt32)x;
        }

        // Implicit conversion from SqlString to SqlByte
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorSqlByte9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlByte(SqlString x) {
            return x.IsNull ? Null : new SqlByte(Byte.Parse(x.Value));
        }

        // Builtin functions
        internal static SqlByte Abs(SqlByte x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlByte((byte) - x.m_value);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlByte x, SqlByte y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlByte x, SqlByte y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ~
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.OnesComplement"]/*' />
        public static SqlByte OnesComplement(SqlByte x) {
            return ~x;
        }

        // Alternative method for operator +
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Add"]/*' />
        public static SqlByte Add(SqlByte x, SqlByte y) {
            return x + y;
        }

        // Alternative method for operator -
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Subtract"]/*' />
        public static SqlByte Subtract(SqlByte x, SqlByte y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Multiply"]/*' />
        public static SqlByte Multiply(SqlByte x, SqlByte y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Divide"]/*' />
        public static SqlByte Divide(SqlByte x, SqlByte y) {
            return x / y;
        }

        // Alternative method for operator %
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Mod"]/*' />
        public static SqlByte Mod(SqlByte x, SqlByte y) {
            return x % y;
        }

        // Alternative method for operator &
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.BitwiseAnd"]/*' />
        public static SqlByte BitwiseAnd(SqlByte x, SqlByte y) {
            return x & y;
        }

        // Alternative method for operator |
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.BitwiseOr"]/*' />
        public static SqlByte BitwiseOr(SqlByte x, SqlByte y) {
            return x | y;
        }

        // Alternative method for operator ^
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Xor"]/*' />
        public static SqlByte Xor(SqlByte x, SqlByte y) {
            return x ^ y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Equals1"]/*' />
        public static SqlBoolean Equals(SqlByte x, SqlByte y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlByte x, SqlByte y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlByte x, SqlByte y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlByte x, SqlByte y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlByte x, SqlByte y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlByte x, SqlByte y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }



        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlByte) {
                SqlByte i = (SqlByte)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlByte)) {
                return false;
            }

            SqlByte i = (SqlByte)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }

        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlByte Null     = new SqlByte(true);
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlByte Zero     = new SqlByte(0);
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlByte MinValue = new SqlByte(Byte.MinValue);
        /// <include file='doc\SQLByte.uex' path='docs/doc[@for="SqlByte.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlByte MaxValue = new SqlByte(Byte.MaxValue);

    } // SqlByte

} // namespace System
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqlclient\tdsparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="TdsParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.SqlClient {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Configuration.Assemblies;
    using System.Data;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;

    internal enum TdsParserState {
        Closed,
        OpenNotLoggedIn,
        OpenLoggedIn,
        Broken,
    }

    sealed internal class _ValueException : SystemException {
    	internal Exception exception;
    	internal object value;
    	internal _ValueException(Exception ex, object val) {
    		this.exception = ex;
    		this.value = val;
    	}
    }

    sealed internal class _SqlRPC {
        internal string rpcName;
        // undone:  should be unsigned short
        internal int options;
        //
        // UNDONE: TDS doesn't easily tell us how many parameters exist.
        //
        internal SqlParameter[] parameters;
    }

    internal enum RunBehavior {
        UntilDone,
        ReturnImmediately,
        Clean
    }

#if OBJECT_BINDING
    internal enum ReadBehavior {
        AsObject, // strongly typed object
        AsRow, // object[]
    }
#endif

    // command records
    sealed internal class SqlLogin {
        public int    timeout;                             // login timeout
        public string hostName="";                         // client machine name
        public string userName="";                         // user id
        public byte[] password=ADP.EmptyByteArray;         // password
        public string applicationName="";                  // application name
        public string serverName="";                       // server name
        public string language="";                         // initial language
        public string database="";                         // initial database
        public string attachDBFilename="";                 // DB filename to be attached
        public bool   useSSPI = false;                     // use integrated security
        public int    packetSize = SqlConnectionString.DEFAULT.Packet_Size; // packet size
    }

    sealed internal class SqlLoginAck {
        public string programName;
        public byte majorVersion;
        public byte minorVersion;
        public short buildNum;
        public bool isVersion8;
    }

    sealed internal class SqlEnvChange {
        public byte type;
        public int length;
        public byte newLength;
        public byte oldLength;
        public string newValue;
        public string oldValue;
        public SqlCollation newCollation;
        public SqlCollation oldCollation;
    }

    internal class SqlMetaData {
        public SqlDbType type; // SqlDbType enum value
        public byte tdsType; // underlying tds type
        public int length;
        public byte precision = TdsEnums.UNKNOWN_PRECISION_SCALE; // give default of unknown (-1)
        public byte scale = TdsEnums.UNKNOWN_PRECISION_SCALE; // give default of unknown (-1)
        public string column;
        public SqlCollation collation;
        public int codePage;
        public Encoding encoding;
        public string baseColumn;
        public string serverName;
        public string catalogName;
        public string schemaName;
        public string tableName;
        public int ordinal;
        public byte updatability; // two bit field (0 is read only, 1 is updatable, 2 is updatability unknown)
        public byte tableNum;
        public bool isDifferentName;
        public bool isKey;
        public bool isNullable;
        public bool isHidden;
        public bool isExpression;
        public bool isIdentity;
    }

    sealed internal class SqlReturnValue {
        public SqlDbType type;
        public byte tdsType;
        public bool isNullable;
        public SqlCollation collation;
        public int codePage;
        public Encoding encoding;
        public int length;
        public string parameter;
        public byte precision;
        public byte scale;
        public object value;
    }

    sealed internal class SqlCollation {
        public uint info;
        public byte sortId;
    }

    sealed internal class _SqlMetaData : SqlMetaData {
        public MetaType  metaType;  // cached metaType

        public _SqlMetaData() {
        }

        // convert a return value record to metadata
        internal _SqlMetaData(SqlReturnValue rec, MetaType mt) {
            type = rec.type;
            tdsType = rec.tdsType;
            length = rec.length;
            column = rec.parameter;
            collation = rec.collation;
            codePage = rec.codePage;
            encoding = rec.encoding;
            precision = rec.precision;
            scale = rec.scale;
            isNullable = rec.isNullable;
            metaType = mt;
        }
    }

    // The TdsParser Object controls reading/writing to the netlib, parsing the tds,
    // and surfacing objects to the user.
    sealed internal class TdsParser  /*: ITdsParser*/ {
        // Two buffers exist in tdsparser, an in buffer and an out buffer.  For the out buffer, only
        // one bookkeeping variable is needed, the number of bytes used in the buffer.  For the in buffer,
        // three variables are actually needed.  First, we need to record from the netlib how many bytes it
        // read from the netlib, this variable is inBytesRead.  Then, we need to also keep track of how many
        // bytes we have used as we consume the bytes from the buffer, that variable is inBytesRead.  Third,
        // we need to keep track of how many bytes are left in the packet, so that we know when we have reached
        // the end of the packet and so we need to consume the next header.

        // Out buffer variables
        private byte[] outBuff;                           // internal write buffer - initialize on login
        private int outBytesUsed   = TdsEnums.HEADER_LEN; // number of bytes used in internal write buffer -
                                                          // - initialize past header
        // binary writer
        // DEBUG: saves tds packets to a file
#if DEBUG
        private bool _traceTds = false;
        private BinaryWriter _bwTdsIn = null;
        private BinaryWriter _bwTdsOut = null;
#endif

#if ISOLATE_NETWORK
        private bool _networkOff = true;
        private int _cTds = 0;
#endif

        // In buffer variables
        private byte[] inBuff;           // internal read buffer - initialize on login
        private int  inBytesUsed   = 0;  // number of bytes used in internal read buffer
        private int  inBytesRead   = 0;  // number of bytes read into internal read buffer
        private int  inBytesPacket = 0;  // number of bytes left in packet
        private bool pendingData   = false;
        private WeakReference pendingCommandWeakRef; // identity of last command executed (for which we are awaiting results)

        private byte _status; // tds header status
        private byte _type;  // tds header type

        // connection variables
        private TdsParserState state = TdsParserState.Closed; // status flag for connection
        private byte      msgType           = 0;     // message type
        private byte      packetNumber      = 1;     // number of packets sent to server
                                                     // in message - start at 1 per ramas
        private int       timeout;                   // length of time to wait on read/write before timing out
        private string    server;                    // name of server that the parser connects to
        private TimeSpan  timeRemaining;             // variable used for timeout computations
        private Timer     attentionTimer;            // internal timer for attention processing
        private const int ATTENTION_TIMEOUT = 5000;  // internal attention timeout, in ticks
        private bool      attentionSent     = false; // true if we sent an Attention to the server
        private bool      isShiloh          = false; // set to true if we connect to a 8.0 server
        private bool      isShilohSP1       = false; // set to true if speaking to Shiloh SP1
        private bool      fSSPIInit         = false; // flag for state of SSPI, initialized or not
        private bool      fSendSSPI         = true;  // flag to hold whether to send SSPI based on protocol
        private bool      fResetConnection  = false; // flag to denote whether we are needing to call sp_reset

        // for PerfCounters - need to know if this connection was opened and the count incremented
        private bool      fCounterIncremented = false;

        // static NIC address caching
        private static byte[] s_nicAddress;            // cache the NIC address from the registry

        // sspi static variables
        private static bool   s_fSSPILoaded = false;   // bool to indicate whether library has been loaded
        private static UInt32 MAXSSPILENGTH = 0;       // variable to hold max SSPI data size, keep for token from server

        // netlib variables
        private HandleRef pConObj;     // pointer to connection object in memory - memory not managed!

        // tds stream processing variables
        private Encoding defaultEncoding = null; // for sql character data
        private char[]   charBuffer      = null; // scratch buffer for unicode strings
        private byte[]   byteBuffer      = null; // scratch buffer for unicode strings

        private int[]        decimalBits       = null; // for decimal/numeric data
        private SqlCollation defaultCollation;         // default collation from the server
        private int          defaultCodePage;
        private int          defaultLCID;
        private byte[]       bTmp              = new byte[TdsEnums.HEADER_LEN]; // scratch buffer

        // UNDONE - temporary hack for case where pooled connection is returned to pool with data on wire -
        // need to cache metadata on parser to read off wire
        private _SqlMetaData[] cleanupMetaData = null;

        // various handlers for the parser
        private SqlInternalConnection connHandler;

        // local exceptions to cache warnings and errors
        private SqlException exception; // exception to hold tds & netlib errors
        private SqlException warning;   // exception to hold tds warnings

#if OBJECT_BINDING
        // DataStream prototype
        private ReadBehavior readBehavior = System.Data.SqlClient.ReadBehavior.AsRow;
#endif

        public TdsParser() {
            this.pConObj = new HandleRef(null, IntPtr.Zero);
        }

        ~TdsParser() {
            this.Dispose(false);
        }

        private /*protected override*/ void Dispose(bool disposing) {
            this.InternalDisconnect();
        }

        internal TdsParserState State {
            get {
                return this.state;
            }
        }

        internal static SqlCompareOptions GetSqlCompareOptions(SqlCollation collation) {
            byte info = (byte) ((collation.info >> 20) & 0x1f);

            bool fIgnoreCase   = ((info & 0x1)  != 0);
            bool fIgnoreAccent = ((info & 0x2)  != 0);
            bool fIgnoreWidth  = ((info & 0x4)  != 0);
            bool fIgnoreKana   = ((info & 0x8)  != 0);
            bool fBinary       = ((info & 0x10) != 0);

            SqlCompareOptions options = SqlCompareOptions.None;            

            if (fIgnoreCase)
                options = options | SqlCompareOptions.IgnoreCase;
            if (fIgnoreAccent)
                options = options | SqlCompareOptions.IgnoreNonSpace;
            if (fIgnoreWidth)
                options = options | SqlCompareOptions.IgnoreWidth;
            if (fIgnoreKana)
                options = options | SqlCompareOptions.IgnoreKanaType;
            if (fBinary)
                options = options | SqlCompareOptions.BinarySort;

            return options;
        }

        internal static int Getlcid(SqlCollation collation) {
            return (int) (collation.info & 0xfffff);
        }

        public int Connect(string host, string protocol, SqlInternalConnection connHandler, int timeout, bool encrypt) {
            Debug.Assert(this.state == TdsParserState.Closed, "TdsParser.Connect called when state was not closed");

            if (this.state != TdsParserState.Closed) {
                Debug.Assert(false, "TdsParser.Connect called on non-closed connection!");
                return timeout;
            }
            // Timeout of 0 should map to Maximum
            if (timeout == 0)
                timeout = Int32.MaxValue;
            
            int    objSize = 0;
            int    error   = TdsEnums.FAIL;
            IntPtr errno   = IntPtr.Zero;

            this.server = host;
            this.connHandler = connHandler;

            // if we are using named pipes or rpc for protocol, both of those handle SSPI security
            // authentication under the covers, so we do not need to handle SSPI authentication
            if (String.Compare(protocol, TdsEnums.NP, false, CultureInfo.InvariantCulture) == 0 ||
                String.Compare(protocol, TdsEnums.RPC, false, CultureInfo.InvariantCulture) == 0)
                fSendSSPI = false;

            // following try/catch is for loading appropriate library - Dbnetlib is supersockets, standard netlib is Dbmssocn
            try {
#if ISOLATE_NETWORK
                if (!_networkOff)
#endif
                {
                    objSize = (int) UnsafeNativeMethods.Dbnetlib.ConnectionObjectSize();
                }
            }
            catch (TypeLoadException) {
                // throw nice error explaining SqlClient only supports 2.6 of MDAC and beyond
                throw SQL.MDAC_WrongVersion();
            }

#if ISOLATE_NETWORK
            if (!_networkOff)
#endif
            {
                IntPtr temp = Marshal.AllocHGlobal(objSize);
                this.pConObj = new HandleRef(this, temp);
                // Remember to zero out memory - AllocHGlobal does not do this automatically.
                SafeNativeMethods.ZeroMemory(temp, objSize);
            }

            // Perform registry lookup to see if host is an alias.  It will appropriately set host and protocol, if an Alias.
            AliasRegistryLookup(ref host, ref protocol);

            string serverName;

            // The following concatenates the specified netlib network protocol to the host string, if netlib is not null
            // and the flag is on.  This allows the user to specify the network protocol for the connection - but only
            // when using the Dbnetlib dll.  If the protocol is not specified, the netlib will
            // try all protocols in the order listed in the Client Network Utility.  Connect will
            // then fail if all protocols fail.
            if (!ADP.IsEmpty(protocol)) {
                serverName = protocol + ":" + host;
            }
            else {
                serverName = host;
            }

#if ISOLATE_NETWORK
            if (!_networkOff)
#endif
            {
                if (encrypt) {
                    UnsafeNativeMethods.OptionStruct options = new UnsafeNativeMethods.OptionStruct();

                    options.iSize = Marshal.SizeOf(typeof(UnsafeNativeMethods.OptionStruct));
                    options.fEncrypt = true;
                    options.iRequest = 0; // setting 0 specifies this is a encrypt option set
                    options.dwPacketSize = 0;

                    error = UnsafeNativeMethods.Dbnetlib.ConnectionOption(this.pConObj, options) ? TdsEnums.SUCCEED : TdsEnums.FAIL;
                }
                else {
                    error = TdsEnums.SUCCEED;
                }
            }
#if ISOLATE_NETWORK
            else {
                error = TdsEnums.SUCCEED;
            }
#endif

            // obtain timespan
            TimeSpan timeSpan = new TimeSpan(0, 0, timeout);

            // obtain current time
            DateTime start = DateTime.UtcNow;

#if ISOLATE_NETWORK
            if (!_networkOff)
#endif
            {
                if (error == TdsEnums.SUCCEED) {
                    error = TdsEnums.FAIL;

                    while(TimeSpan.Compare(DateTime.UtcNow.Subtract(start), timeSpan) < 0 &&
                          error == TdsEnums.FAIL) {
                        error = UnsafeNativeMethods.Dbnetlib.ConnectionOpen(this.pConObj, serverName, out errno);
                    }
                }
            }
#if ISOLATE_NETWORK
            else {
                error = TdsEnums.SUCCEED;
            }
#endif

            // compute remaining timeout
            int timeoutRemaining = timeout - (int) DateTime.UtcNow.Subtract(start).TotalSeconds;

            if (error == TdsEnums.FAIL) {
                if (this.exception == null)
                    this.exception = new SqlException();

                this.exception.Errors.Add(ProcessNetlibError(errno));

                // Since connect failed, free the unmanaged connection memory.
                // HOWEVER - only free this after the netlib error was processed - if you
                // don't, the memory for the connection object might not be accurate and thus
                // a bad error could be returned (as it was when it was freed to early for me).
                Marshal.FreeHGlobal(this.pConObj.Handle);
                this.pConObj = new HandleRef(null, IntPtr.Zero);

                ThrowExceptionAndWarning();

                return 0;
            }
            else {
#if ISOLATE_NETWORK
                if (!_networkOff)
#endif
                {
                    // version is 32 bits - 8 bits major, 8 bits minor, 16 bits build
                    UIntPtr version      = UnsafeNativeMethods.Dbnetlib.ConnectionSqlVer(this.pConObj);
                    int majorVersion = (int) version >> 24;
                    int minorVersion = (int) version >> 16 & 0x00ff;

                    // Throw exception for server version pre SQL Server 7.0.
                    if (majorVersion < TdsEnums.SQL_SERVER_VERSION_SEVEN) {
                        // Since connect fails to pre 7.0 server,
                        // free the unmanaged connection memory.
                        Marshal.FreeHGlobal(this.pConObj.Handle);
                        this.pConObj = new HandleRef(null, IntPtr.Zero);
                        throw SQL.InvalidSQLServerVersion(majorVersion + "." + minorVersion);
                    }
                }

                this.state = TdsParserState.OpenNotLoggedIn;

                if (timeoutRemaining < 0)
                    return 0;
                else
                    return timeoutRemaining;
            }
        }

        public void AliasRegistryLookup(ref string host, ref string protocol) {
            if (!ADP.IsEmpty(host)) {
                const String folder = "SOFTWARE\\Microsoft\\MSSQLServer\\Client\\ConnectTo";
                // Put a try...catch... around this so we don't abort ANY connection if we can't read the registry.
                try {
                    string aliasLookup = (string) ADP.LocalMachineRegistryValue(folder, host);
                    if (!ADP.IsEmpty(aliasLookup)) {
                        // Result will be in the form of: "DBNMPNTW,\\blained1\pipe\sql\query".
                        // We must parse into the two component pieces, then map the first protocol piece to the 
                        // appropriate value.
                        int index = aliasLookup.IndexOf(",", 0);
                        // If we found the key, but there was no "," in the string, it is a bad Alias so return.
                        if (-1 != index) {
                            string parsedProtocol = aliasLookup.Substring(0, index).ToLower(CultureInfo.InvariantCulture);
                            // If index+1 >= length, Alias consisted of "FOO," which is a bad alias so return.
                            if (index+1 < aliasLookup.Length) {
                                string parsedAliasName = aliasLookup.Substring(index+1);
                                // _netlibMapping should never be null at this point, if it is that means that a connection
                                // string was not set on the connection.
                                Hashtable netlib = SqlConnectionString.NetlibMapping();
                                if (netlib.Contains(parsedProtocol)) {
                                    protocol = (string) netlib[parsedProtocol];
                                    host = parsedAliasName;
                                }
                            }
                        }
                    }
                }catch {
                    // Ignore the error and continue
                }
            }
        }

        public void Disconnect() {
            // PerfCounters -decrement if this if we successfully logged in
            if (fCounterIncremented) {
                SQL.DecrementConnectionCount();
            }

            lock (this) { // lock to ensure only one user thread will disconnect at a time
                InternalDisconnect();
            }

            GC.KeepAlive(this); // to ensure finalizer will not run before disconnect is finished
        }

        // Used to close the connection and then free the memory allocated for the netlib connection.
        private void InternalDisconnect() {
            // Can close the connection if its open or broken
            if (this.state != TdsParserState.Closed) {
                //benign assert - the user could close the connection before consuming all the data
                //Debug.Assert(this.inBytesUsed == this.inBytesRead && this.outBytesUsed == TdsEnums.HEADER_LEN, "TDSParser closed with data not fully sent or consumed.");

                this.state = TdsParserState.Closed;
                int retcode = 0;
                IntPtr errno = IntPtr.Zero;
                
                try {
                    try {
#if ISOLATE_NETWORK
                        if (!_networkOff) {
#endif
                        retcode = UnsafeNativeMethods.Dbnetlib.ConnectionClose(this.pConObj, out errno);
#if ISOLATE_NETWORK
                        }
                        else {
                            retcode = TdsEnums.SUCCEED;
                        }
#endif

                        // This code is part of the try/finally because it needs to be executed before the
                        // connection object memory is freed.
                        // This will only fail under extreme circumstances. Even if server went down
                        // this will still not fail.
                        if (retcode == TdsEnums.FAIL) {
                            if (this.exception == null)
                                this.exception = new SqlException();

                            this.exception.Errors.Add(ProcessNetlibError(errno));
                        }
                    }
                    finally {// FreeHGlobal
#if ISOLATE_NETWORK
                        if (!_networkOff) { 
#endif
                        // Since the connection is being closed, we can free the memory we allocated for the connection.
                        Marshal.FreeHGlobal(this.pConObj.Handle);
                        this.pConObj = new HandleRef(null, IntPtr.Zero);
#if ISOLATE_NETWORK
                        }
#endif

#if DEBUG
                        lock(this) {
                            if (null != _bwTdsIn){
                                _bwTdsIn.Flush();
                                _bwTdsIn.BaseStream.Close();
                                _bwTdsIn = null;
                            }
                            if (null != _bwTdsOut){
                                _bwTdsOut.Flush();
                                _bwTdsOut.BaseStream.Close();
                                _bwTdsOut = null;
                            }
                        }                    
#endif
                    }

                    //                  // UNDONE: bug found by integration
                    //              // unbind our handler
                    //              this.connHandler = null;
                }
                catch { // MDAC 80973, 82448
                    throw;
                }

                if (retcode == TdsEnums.FAIL)
                    ThrowExceptionAndWarning();
            }
        }

        private void ThrowExceptionAndWarning() {
            // This function should only be called when there was an error or warning.  If there aren't any
            // errors, the handler will be called for the warning(s).  If there was an error, the warning(s) will
            // be copied to the end of the error collection so that the user may see all the errors and also the
            // warnings that occurred.

            SqlException temp;  // temp variable to store that which is being thrown - so that local copies
            // can be deleted

            Debug.Assert(this.warning != null || this.exception != null, "TdsParser::ThrowExceptionAndWarning called with no exceptions or warnings!");
            Debug.Assert(this.connHandler != null, "TdsParser::ThrowExceptionAndWarning called with null connectionHandler!");

            if (this.exception != null) {
                Debug.Assert(this.exception.Errors.Count != 0, "TdsParser::ThrowExceptionAndWarning: 0 errors in collection");

                if (this.warning != null) {
                    int numWarnings   = this.warning.Errors.Count;

                    // Copy all warnings into error collection - when we throw an exception we place all the warnings
                    // that occurred at the end of the collection - after all the errors.  That way the user can see
                    // all the errors AND warnings that occurred for the exception.
                    for (int i = 0; i < numWarnings; i++)
                        this.exception.Errors.Add(this.warning.Errors[i]);
                }

                temp = this.exception;
                this.exception = null;
                this.warning   = null;

                // if we received a fatal error, set parser state to broken!
                if (TdsParserState.Closed != this.state) {
                    for (int i = 0; i < temp.Errors.Count; i ++) {
                        if (temp.Errors[i].Class >= TdsEnums.FATAL_ERROR_CLASS) {
                            this.state = TdsParserState.Broken;
                            break;
                        }
                    }
                }

                // the following handler will throw an exception or generate a warning event
                this.connHandler.OnError(temp, this.state);
            }
            else { // else we must have some warnings
                Debug.Assert(this.warning.Errors.Count != 0, "TdsParser::ThrowExceptionAndWarning: 0 warnings in collection");

                temp = this.warning;
                this.warning = null;

                // the following handler will throw an exception or generate a warning event
                this.connHandler.OnError(temp, this.state);
            }
        }

        // Function that will throw the appropriate exception based on the short passed into it.
        private SqlError ProcessNetlibError(IntPtr errno) {
            // allocate memory for error info
            IntPtr netErr     = IntPtr.Zero;
            IntPtr networkMsg = IntPtr.Zero;
            IntPtr dbErr      = IntPtr.Zero;

            UnsafeNativeMethods.Dbnetlib.ConnectionError(this.pConObj, out netErr, out networkMsg, out dbErr);

            // covert the string the pointer is pointing at to a managed string
            string procedure = Marshal.PtrToStringAnsi(networkMsg);

            // netErr should match errno (it's the network specific error number). ConnectionError
            // should map netErr to a set of general network messages.  The general network error
            // message will be designated by dbErr.  However, if errno is negative, use errno
            // to map to one of the three other errors.  Always make a call to ConnectionError
            // for the procedure that caused the error.

            int            number;
            string         message = String.Empty;
            byte           errorClass;

            if ((int) errno >= TdsEnums.ERRNO_MIN && (int) errno <= TdsEnums.ERRNO_MAX)
                number = (int) errno;
            else
                number = (int) dbErr;

            switch (number) {
                case TdsEnums.ZERO_BYTES_READ:
                    message = SQLMessage.ZeroBytes();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.TIMEOUT_EXPIRED:
                    message = SQLMessage.Timeout();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.UNKNOWN_ERROR:
                    message = SQLMessage.Unknown();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NOMEMORY:
                    message = SQLMessage.InsufficientMemory();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NOACCESS:
                    message = SQLMessage.AccessDenied();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_CONNBUSY:
                    message = SQLMessage.ConnectionBusy();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_CONNBROKEN:
                    message = SQLMessage.ConnectionBroken();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_TOOMANYCONN:
                    message = SQLMessage.ConnectionLimit();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_SERVERNOTFOUND:
                    message = SQLMessage.ServerNotFound(this.server);
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NETNOTSTARTED:
                    message = SQLMessage.NetworkNotFound();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NORESOURCE:
                    message = SQLMessage.InsufficientResources();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NETBUSY:
                    message = SQLMessage.NetworkBusy();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NONETACCESS:
                    message = SQLMessage.NetworkAccessDenied();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_GENERAL:
                    message = SQLMessage.GeneralError();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_CONNMODE:
                    message = SQLMessage.IncorrectMode();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NAMENOTFOUND:
                    message = SQLMessage.NameNotFound();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_INVALIDCONN:
                    message = SQLMessage.InvalidConnection();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NETDATAERR:
                    message = SQLMessage.ReadWriteError();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_TOOMANYFILES:
                    message = SQLMessage.TooManyHandles();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_SERVERERROR:
                    message = SQLMessage.ServerError();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_SSLSECURITYERROR:
                    message = SQLMessage.SSLError();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_ENCRYPTIONON:
                    message = SQLMessage.EncryptionError();
                    errorClass = TdsEnums.DEFAULT_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_ENCRYPTIONNOTSUPPORTED:
                    message = SQLMessage.EncryptionNotSupported();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
                case TdsEnums.NE_E_NOMAP:
                default:
                    number = (int) netErr;
                    message = SQLMessage.Unknown();
                    errorClass = TdsEnums.FATAL_ERROR_CLASS;
                    break;
            }

            return new SqlError(number, (byte) 0x00, errorClass,
                                message, procedure, 0);
        }

        private int PacketSize {
            get { return this.outBuff.Length;}
            set { Debug.Assert(value >= 1, "Cannot set packet size to less than 1.");

                SetOutBufferSize(value);
                SetInBufferSize(value);
            }
        }

        // Takes packet size as argument and then sets the size of the out buffer based on that.
        private void SetOutBufferSize (int size) {
            // don't always realloc
            if (this.outBuff.Length == size)
                return;

            FlushBuffer(TdsEnums.SOFTFLUSH); // flush buffer before reallocating buffer

            this.outBuff = new Byte[size];
            this.outBytesUsed = TdsEnums.HEADER_LEN;
        }

        // Takes packet size as argument and then sets the size of the in buffer based on that.
        private void SetInBufferSize (int size) {
            // If size is greater than the current size of the inbuffer, we increase the inbuffer size to be the
            // size variable passed into this procedure.  If size is less than the size of the inbuffer, then do
            // nothing.  There are no adverse effects to having the inbuffer larger than packet size.  There are
            // adverse effects if the inbuffer is smaller than packet size - we will end up having to split reads
            // of packets that are ready to be read from the netlib.  We always want to be able to read all that
            // is in the netlib buffer, so we always want our buffer size to be at least as big as the netlib
            // packets.

            if (size > this.inBuff.Length) {
                // if new buffer size is greater than current buffer size

                if (this.inBytesRead > this.inBytesUsed) {
                    // if we still have data left in the buffer we must keep that array reference and then copy into new one

                    byte[] temp = this.inBuff;
                    this.inBuff = new byte[size];

                    // copy remainder of unused data
                    Array.Copy(temp, this.inBytesUsed, this.inBuff, 0, (this.inBytesRead - this.inBytesUsed));

                    this.inBytesRead = this.inBytesRead - this.inBytesUsed;
                    this.inBytesUsed = 0;
                }
                else {
                    // buffer is empty - just create the new one that is double the size of the old one

                    this.inBuff = new byte[size];
                    this.inBytesRead = 0;
                    this.inBytesUsed = 0;
                }
            }
        }

        // Dumps contents of buffer to socket.
        private void FlushBuffer (byte status) {
            //if (AdapterSwitches.SqlPacketInfo.TraceVerbose) {
            //    if (status == TdsEnums.HARDFLUSH)
            //        Debug.WriteLine("HARDFLUSH");
            //    else
            //        Debug.WriteLine("SOFTFLUSH");
            //}

            IntPtr errno = IntPtr.Zero;

            Debug.Assert(this.state == TdsParserState.OpenNotLoggedIn ||
                         this.state == TdsParserState.OpenLoggedIn,
                         "Cannot flush buffer when connection is closed!");

            if (this.state == TdsParserState.Closed ||
                this.state == TdsParserState.Broken)
                return;

            if (this.outBytesUsed == TdsEnums.HEADER_LEN  && this.packetNumber == 1) {
                //if (AdapterSwitches.SqlPacketInfo.TraceVerbose)
                //    Debug.WriteLine("Flush called on buffer with only header and packetNumber = 1");
                return;
            }

            this.outBuff[0] = (Byte) this.msgType;              // Message Type
            this.outBuff[2] = (Byte) (this.outBytesUsed >> 8);  // length - upper byte
            this.outBuff[3] = (Byte) this.outBytesUsed;         // length - lower byte
            this.outBuff[4] = 0;                    // channel
            this.outBuff[5] = 0;
            this.outBuff[6] = this.packetNumber;    // packet
            this.outBuff[7] = 0;                    // window

            // Set Status byte based whether this is end of message or not
            if (status == TdsEnums.HARDFLUSH) {
                this.outBuff[1] = (Byte) TdsEnums.ST_EOM;
                this.packetNumber = 1;  // end of message - reset to 1 - per ramas
            }
            else {
                this.outBuff[1] = (Byte) TdsEnums.ST_BATCH;
                this.packetNumber++;
            }

            if (this.fResetConnection) {
                Debug.Assert(isShiloh, "TdsParser.cs: Error!  fResetConnection true when not going against Shiloh!");
                // if we are reseting, set bit in header by or'ing with other value
                this.outBuff[1] = (Byte) (this.outBuff[1] | TdsEnums.ST_RESET_CONNECTION);
                this.fResetConnection = false; // we have sent reset, turn flag off
            }

            int bytesWritten;

#if ISOLATE_NETWORK
            if (!_networkOff)
#endif
            {
                bytesWritten = (int) UnsafeNativeMethods.Dbnetlib.ConnectionWrite(this.pConObj, this.outBuff, (UInt16)this.outBytesUsed, out errno);
            }
#if ISOLATE_NETWORK
            else {
                bytesWritten = this.outBytesUsed;
            }
#endif

#if DEBUG
            if (_traceTds) {
                try {
                    lock(this) {
                        if (null == _bwTdsOut) {
                            FileStream fs = new FileStream("tdsOut_" + AppDomain.GetCurrentThreadId().ToString() + ".log", FileMode.OpenOrCreate, FileAccess.ReadWrite);
                            _bwTdsOut = new BinaryWriter(fs);
                            _bwTdsOut.Seek(0, SeekOrigin.End);
                        }
                        if (bytesWritten > 0)
                            _bwTdsOut.Write(this.outBuff, 0, bytesWritten );
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
#endif

            //if (AdapterSwitches.SqlPacketInfo.TraceVerbose)
            //    Debug.WriteLine("bytesWritten=" + Convert.ToString(bytesWritten) + ", total bytes to write=" + Convert.ToString(this.outBytesUsed));

            if (bytesWritten != this.outBytesUsed) {
                if (this.exception == null)
                    this.exception = new SqlException();

                this.exception.Errors.Add(ProcessNetlibError(errno));
                ThrowExceptionAndWarning();
            }
            else
                ResetBuffer();
        }

        internal void ResetBuffer() {
            this.outBytesUsed = TdsEnums.HEADER_LEN;
        }

        // Wrapper function that calls the function that reads as much as possible from the netlib
        // and inserts it into the in buffer.
        private void ReadBuffer() {
            Debug.Assert(this.inBytesUsed == this.inBytesRead, "buffer should be exhaused!");
            Debug.Assert(this.inBuff != null, "packet buffer should not be null!");

            // if we have exhausted the buffer and we used the entire buffer for the previous read, then
            // lets double the size, to save trips to the unmanaged netlib layer since it is so costly!
            // this is the best place to do this since the buffer has been completely used, no need to
            // copy data to a temp array and then create a new one.
            if (this.inBytesRead == this.inBuff.Length && this.inBuff.Length < TdsEnums.MAX_IN_BUFFER_SIZE) {
                int newLength = this.inBuff.Length * 2;

                if (newLength > TdsEnums.MAX_IN_BUFFER_SIZE)
                    newLength = TdsEnums.MAX_IN_BUFFER_SIZE;

                this.inBuff = new byte[newLength];
                this.inBytesRead = 0;
                this.inBytesUsed = 0;
            }

            // If the inBytesPacket is not zero, then we have data left in the packet, but the data in the packet
            // spans the buffer, so we can read any amount of data possible, and we do not need to call ProcessHeader
            // because there isn't a header at the beginning of the data that we are reading.
            if (this.inBytesPacket > 0) {
                //if (AdapterSwitches.SqlNetlibInfo.TraceVerbose)
                //    Debug.WriteLine("before read, number of bytes requesting: " + Convert.ToString(this.inBuff.Length));

                ReadNetlib(1);
            }
            // Else we have finished the packet and so we must read the next header and then as much data as
            // posssible.
            else if (this.inBytesPacket == 0) {
                //if (AdapterSwitches.SqlNetlibInfo.TraceVerbose)
                //    Debug.WriteLine("before read, number of bytes requesting: " + Convert.ToString(this.inBuff.Length));

                ReadNetlib(TdsEnums.HEADER_LEN);

                ProcessHeader();

                Debug.Assert(this.inBytesPacket != 0, "inBytesPacket cannot be 0 after processing header!");
                Debug.Assert(this.inBytesUsed != this.inBytesRead, "we read a header but didn't get anything else!");
            }
            else {
                Debug.Assert(false, "entered negative inBytesPacket loop");
            }
        }

        private void ReadNetlib(int bytesExpected) {
            DateTime startTime = DateTime.UtcNow;
            IntPtr   errno     = IntPtr.Zero;

#if ISOLATE_NETWORK
            if (_networkOff) {
                this.inBuff =   (byte[]) _rgbTds[_cTds];
                this.inBytesRead = this.inBuff.Length;
                _cTds++;
            }
            else
#endif
            {
                try {
                    this.inBytesRead = (int) UnsafeNativeMethods.Dbnetlib.ConnectionRead(this.pConObj, this.inBuff, (UInt16)bytesExpected,
                                                                                         (UInt16)this.inBuff.Length, (UInt16)this.timeRemaining.TotalSeconds, out errno);
                }
                catch (ThreadAbortException) {
                    this.state = TdsParserState.Broken;
                    this.connHandler.BreakConnection();            
                    throw;
                }
            }                                                                 

#if DEBUG
            if (_traceTds) {
                try {
                    lock(this) {
                        if (null == _bwTdsIn) {
                            FileStream fs = new FileStream("tdsIn_" + AppDomain.GetCurrentThreadId().ToString() + ".log", FileMode.OpenOrCreate, FileAccess.ReadWrite);
                            _bwTdsIn = new BinaryWriter(fs);
                            _bwTdsIn.Seek(0, SeekOrigin.End);
                        }
                        if (inBytesRead > 0)
                            _bwTdsIn.Write(this.inBuff, 0, inBytesRead );
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
#endif

            this.timeRemaining = this.timeRemaining.Subtract(DateTime.UtcNow.Subtract(startTime));

            //if (AdapterSwitches.SqlTimeout.TraceVerbose) {
            //    Debug.WriteLine("TimeRemaining is " + Convert.ToString(timeRemaining.TotalSeconds));
            //}

            // reset inBytesUsed, we have data in the buffer but none of it has been used
            this.inBytesUsed = 0;

            //if (AdapterSwitches.SqlNetlibInfo.TraceVerbose) {
            //    Debug.WriteLine("after ConnectionRead - inBytesRead: " + Convert.ToString(this.inBytesRead));
            //    Debug.WriteLine("bytes expected was: " + Convert.ToString(bytesExpected));
            //}

            if (this.inBytesRead < bytesExpected) {
                // If the timeout has expired, we need to send an attention to the server.  We send TdsEnums.TIMEOUT_EXPIRED
                // to ProcessNetlibError because the SendAttention will overwrite the value in errno with a different value - one
                // that we do not wish to send to ProcessNetlibError.
                if ((int) errno == TdsEnums.TIMEOUT_EXPIRED) {
                    // Add timeout exception to collection first, prior to attention work.
                    // ProcessNetlibError must be called immediately following netlib failure.
                    if (this.exception == null)
                        this.exception = new SqlException();

                    this.exception.Errors.Add(ProcessNetlibError(errno));

                    SendAttention();
                    ProcessAttention();
                    
                    // Throw after attention work.
                    ThrowExceptionAndWarning();
                }
                // Else, we do not have a timeout expired error, and so simply call ProcessNetlibError
                // with the error passed back from the read.
                else {
                    if (this.exception == null)
                        this.exception = new SqlException();

                    this.exception.Errors.Add(ProcessNetlibError(errno));
                    ThrowExceptionAndWarning();
                }
            }
        }

        // Processes the tds header that is present in the buffer
        private void ProcessHeader() {
            Debug.Assert(this.inBytesPacket == 0, "there should not be any bytes left in packet when ReadHeader is called");

            // if the header splits buffer reads - special case!
            if (this.inBytesUsed + TdsEnums.HEADER_LEN > this.inBytesRead) {
                //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                //    Debug.WriteLine("ProcessHeader: this.inBytesUsed + TdsEnums.HEADER_LEN > this.inBytesRead");

                int bytesRemaining = this.inBytesRead - this.inBytesUsed;
                int bytesMissing = TdsEnums.HEADER_LEN - bytesRemaining;

                Debug.Assert(bytesRemaining > 0 && bytesRemaining < TdsEnums.HEADER_LEN &&
                             bytesMissing > 0 && bytesMissing < TdsEnums.HEADER_LEN, "ProcessHeader error, bytesRemaining: " + Convert.ToString(bytesRemaining) + ", bytesMissing: " + Convert.ToString(bytesMissing) + ".");

                byte[] temp = new byte[TdsEnums.HEADER_LEN];

                Array.Copy(this.inBuff, this.inBytesUsed, temp, 0, bytesRemaining);

                this.inBytesUsed = this.inBytesRead;

                ReadNetlib(bytesMissing);

                Array.Copy(this.inBuff, this.inBytesUsed, temp, bytesRemaining, bytesMissing);

                this.inBytesPacket = ((((int)temp[TdsEnums.HEADER_LEN_FIELD_OFFSET])&0xffffff) << 8) +
                                     (((int)temp[TdsEnums.HEADER_LEN_FIELD_OFFSET + 1])&0xffffff) - TdsEnums.HEADER_LEN;

                this.inBytesUsed = bytesMissing;
                _type = temp[0];
                _status = temp[1];
            }
            // normal header processing...
            else {
                _status = this.inBuff[this.inBytesUsed + 1];
                _type = this.inBuff[this.inBytesUsed];
                this.inBytesPacket = ((((int)this.inBuff[this.inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET])&0xffffff) << 8) +
                                     (((int)this.inBuff[this.inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET + 1])&0xffffff) - TdsEnums.HEADER_LEN;
                this.inBytesUsed += TdsEnums.HEADER_LEN;
            }
        }

        // Takes in a single byte and writes it to the buffer.  If the buffer is full, it is flushed
        // and then the buffer is re-initialized in flush() and then the byte is put in the buffer.
        private void WriteByte(byte b) {
            Debug.Assert(this.outBytesUsed <= this.outBuff.Length, "ERROR - TDSParser: outBytesUsed > outBuff.Length");

            // check to make sure we haven't used the full amount of space available in the buffer, if so, flush it
            if (this.outBytesUsed == this.outBuff.Length)
                FlushBuffer(TdsEnums.SOFTFLUSH);

            // set byte in buffer and increment the counter for number of bytes used in the out buffer
            this.outBuff[this.outBytesUsed++] = b;
        }

        // look at the next byte without pulling it off the wire, don't just returun inBytesUsed since we may
        // have to go to the network to get the next byte.
        internal byte PeekByte() {
            byte peek = ReadByte();

            // now do fixup
            this.inBytesPacket++;
            this.inBytesUsed--;

            return peek;
        }


        // Takes no arguments and returns a byte from the buffer.  If the buffer is empty, it is filled
        // before the byte is returned.
        public byte ReadByte() {
            Debug.Assert(this.inBytesUsed >= 0 && this.inBytesUsed <= this.inBytesRead,
                         "ERROR - TDSParser: inBytesUsed < 0 or inBytesUsed > inBytesRead");

            // if we have exhausted the read buffer, we need to call ReadBuffer to get more data
            if (this.inBytesUsed == this.inBytesRead)
                ReadBuffer();
            else if (this.inBytesPacket == 0) {
                ProcessHeader();

                Debug.Assert(this.inBytesPacket != 0, "inBytesPacket cannot be 0 after processing header!");

                if (this.inBytesUsed == this.inBytesRead)
                    ReadBuffer();
            }

            // decrement the number of bytes left in the packet
            this.inBytesPacket--;

            Debug.Assert(this.inBytesPacket >= 0, "ERROR - TDSParser: inBytesPacket < 0");

            // return the byte from the buffer and increment the counter for number of bytes used in the in buffer
            return(this.inBuff[this.inBytesUsed++]);
        }

        // Takes a byte array, an offset, and a len and fills the array from the offset to len number of
        // bytes from the in buffer.
        public void ReadByteArray(byte[] buff, int offset, int len) {

#if DEBUG
			if (buff != null) {
	            Debug.Assert(buff.Length >= len, "Invalid length sent to ReadByteArray()!");
			}
#endif

            // loop through and read up to array length
            while (len > 0) {
                if ((len <= this.inBytesPacket) && ((this.inBytesUsed + len) <= this.inBytesRead)) {
                    //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                    //    Debug.WriteLine("ReadByteArray:  (len <= this.inBytesPacket) && ((this.inBytesUsed + len) <= this.inBytesRead)");


                    // NO STRING PACKET SPAN AND NO STRING SPAN OF BUFFER
                    // If all of string is in the packet and all of the string is in the buffer
                    // then we have the full string available for copying - then take care of counters
                    // and break out of loop

                    if (buff != null) {
	                    Array.Copy(this.inBuff, this.inBytesUsed, buff, offset, len);
                    }
                    this.inBytesUsed += len;
                    this.inBytesPacket -= len;
                    break;
                }
                else if ( ((len <= this.inBytesPacket) && ((this.inBytesUsed + len) > this.inBytesRead)) ||
                          ((len > this.inBytesPacket) && ((this.inBytesUsed + this.inBytesPacket) > this.inBytesRead)) ) {
                    //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                    //    Debug.WriteLine("ReadByteArray: ((len <= this.inBytesPacket) && ((this.inBytesUsed + len) > this.inBytesRead)) || ((len > this.inBytesPacket) && ((this.inBytesUsed + this.inBytesPacket) > this.inBytesRead)) ");

                    // NO PACKET SPAN AND STRING SPANS BUFFER        OR
                    // STRING SPANS PACKET AND PACKET SPANS BUFFER
                    // If all of the string is in the packet and the string spans buffer OR
                    // if the string spans packets and packet spans buffer
                    // then we only have a partial string available to us, with the length being
                    // the rest of the bytes in the buffer.  So, there is no header in the rest of
                    // the buffer.  The remainder of bytes left in the buffer is given by the number
                    // read minus the number used.  Copy that and then take care of the proper counters and
                    // then get the next byte from the new buffer by using the appropriate ReadByte function
                    // which will make a proper read and then take care of the header and all of that business.

                    int remainder = this.inBytesRead - this.inBytesUsed;

                    // read the remainder
                    if (buff != null) {
	                    Array.Copy(this.inBuff, this.inBytesUsed, buff, offset, remainder);
                    }

                    offset += remainder;
                    this.inBytesUsed += remainder;
                    this.inBytesPacket -= remainder;
                    len -= remainder;

                    // and get more data from the wire
                    ReadBuffer();
                }
                else if ((len > this.inBytesPacket) && ((this.inBytesUsed + this.inBytesPacket) <= this.inBytesRead)) {
                    //if (AdapterSwitches.SqlTDSStream.TraceVerbose) {
                    //    Debug.WriteLine("ReadByteArray: (len > this.inBytesPacket) && ((this.inBytesUsed + this.inBytesPacket) <= this.inBytesRead)");
                    //    Debug.WriteLine("len:  " + Convert.ToString(len));
                    //}

                    // STRING SPANS PACKET AND NO PACKET SPAN OF BUFFER
                    // If the string spans packets and all of packet is in buffer
                    // then, all of the packet is in the buffer, but there may be more.  So,
                    // read the rest of the packet, take care of the counters, and reset the number
                    // of bytes in the packet to zero.

                   	if (buff != null) {
	                    Array.Copy(this.inBuff, this.inBytesUsed, buff, offset, this.inBytesPacket);
                   	}
                    this.inBytesUsed += this.inBytesPacket;
                    offset += this.inBytesPacket;
                    len -= this.inBytesPacket;

                    this.inBytesPacket = 0;

                    // Now, check to see if we still have data in the buffer.  If we do, then we must have a
                    // header at the beginning of the data, since we are on a new packet.  So, since we have a
                    // header call ProcessHeader to take care of the header.  If we don't have data in the buffer
                    // then call ReadBuffer to refill the header.  ReadBuffer will take care of the header at the
                    // beginning of the new buffer, so don't worry about that here.
                    if (this.inBytesUsed == this.inBytesRead)
                        ReadBuffer();
                    else {
                        ProcessHeader();

                        Debug.Assert(this.inBytesPacket != 0, "inBytesPacket cannot be 0 after processing header!");

                        if (this.inBytesUsed == this.inBytesRead)
                            ReadBuffer();
                    }
                }
                else {
                    Debug.Assert(false, "Failed to catch condition in ReadByteArray");
                }
            }
        }

        //
        // Takes a byte array and writes it to the buffer.
        //
        private void WriteByteArray(Byte[] b, int len, int offsetBuffer) {
            // Do we have to send out in packet size chunks, or can we rely on netlib layer to break it up?
            // would prefer to to do something like:
            //
            // if (len > what we have room for || len > out buf)
            //   flush buffer
            //   UnsafeNativeMethods.Dbnetlib.Write(b)
            //

            int offset = offsetBuffer;
            Debug.Assert(b.Length >= len, "Invalid length sent to WriteByteArray()!");

            // loop through and write the entire array
            while (len > 0) {
                if ( (this.outBytesUsed + len) > this.outBuff.Length ) {
                    // If the remainder of the string won't fit into the buffer, then we have to put
                    // whatever we can into the buffer, and flush that so we can then put more into
                    // the buffer on the next loop of the while.

                    int remainder = this.outBuff.Length - this.outBytesUsed;
                    // write the remainder
                    Array.Copy(b, offset, this.outBuff, this.outBytesUsed, remainder);

                    // handle counters
                    offset += remainder;
                    this.outBytesUsed += remainder;

                    // Flush the buffer if full.
                    if (this.outBytesUsed == this.outBuff.Length)
                        FlushBuffer(TdsEnums.SOFTFLUSH);

                    len -= remainder;
                }
                else { //((this.outBytesUsed + len) <= this.outBuff.Length )
                    // Else the remainder of the string will fit into the buffer, so copy it into the
                    // buffer and then break out of the loop.

                    Array.Copy(b, offset, this.outBuff, this.outBytesUsed, len);

                    // handle out buffer bytes used counter
                    this.outBytesUsed += len;
                    break;
                }
            }
        }

        private void WriteChar(char ch) {
            uint v = (uint) ch;

            if ( (this.outBytesUsed+2) > this.outBuff.Length) {
                // if all of the char doesn't fit into the buffer

                WriteByte( (byte) (v & 0xff) );
                WriteByte( (byte) ((v >> 8) & 0xff) );
            }
            else {
                // all of the char fits into the buffer

                this.outBuff[this.outBytesUsed++] = (byte) (v & 0xFF);
                this.outBuff[this.outBytesUsed++] = (byte) ((v >> 8) & 0xFF);
            }
        }

        private char ReadChar() {
            byte b1 = ReadByte();
            byte b2 = ReadByte();
            return(char) (((b2 & 0xff) << 8) + (b1 & 0xff));
        }


        //
        // Takes a 16 bit short and writes it.
        //
        private void WriteShort(int v) {
            if ( (this.outBytesUsed+2) > this.outBuff.Length) {
                // if all of the short doesn't fit into the buffer

                WriteByte( (byte) (v & 0xff) );
                WriteByte( (byte) ( (v >> 8) & 0xff) );
            }
            else {
                // all of the short fits into the buffer

                this.outBuff[this.outBytesUsed++] = (byte) (v & 0xFF);
                this.outBuff[this.outBytesUsed++] = (byte) ( (v >> 8) & 0xFF );
            }
        }

        public Int16 ReadShort() {
            byte b1 = ReadByte();
            byte b2 = ReadByte();

            return(Int16) ( (b2 << 8) + b1 );
        }

        [CLSCompliantAttribute(false)]
        public UInt16 ReadUnsignedShort() {
            byte b1 = ReadByte();
            byte b2 = ReadByte();

            return(UInt16) ((b2 << 8) + b1);
        }

        [CLSCompliantAttribute(false)]
        public uint ReadUnsignedInt() {
            if ( ((this.inBytesUsed + 4) > this.inBytesRead) ||
                 (this.inBytesPacket < 4) ) {
                // If the int isn't fully in the buffer, or if it isn't fully in the packet,
                // then use ReadByteArray since the logic is there to take care of that.

                ReadByteArray(bTmp, 0, 4);
                return BitConverter.ToUInt32(bTmp, 0);
            }
            else {
                // The entire int is in the packet and in the buffer, so just return it
                // and take care of the counters.

                uint i = BitConverter.ToUInt32(this.inBuff, this.inBytesUsed);
                this.inBytesUsed +=4;
                this.inBytesPacket -= 4;
                return i;
            }
        }

        //
        // Takes a long and writes out an unsigned int
        //
        private void WriteUnsignedInt(uint i) {
            WriteByteArray(BitConverter.GetBytes(i), 4, 0);
        }

        //
        // Takes an int and writes it as an int.
        //
        private void WriteInt(int v) {
            WriteByteArray(BitConverter.GetBytes(v), 4, 0);
        }

        public int ReadInt() {
            if ( ((this.inBytesUsed + 4) > this.inBytesRead) ||
                 (this.inBytesPacket < 4) ) {
                // If the int isn't fully in the buffer, or if it isn't fully in the packet,
                // then use ReadByteArray since the logic is there to take care of that.

                ReadByteArray(bTmp, 0, 4);
                return BitConverter.ToInt32(bTmp, 0);
            }
            else {
                // The entire int is in the packet and in the buffer, so just return it
                // and take care of the counters.

                int i = BitConverter.ToInt32(this.inBuff, this.inBytesUsed);
                this.inBytesUsed +=4;
                this.inBytesPacket -= 4;
                return i;
            }
        }

        //
        // Takes a float and writes it as a 32 bit float.
        //
        private void WriteFloat(float v) {
            byte[] bytes = BitConverter.GetBytes(v);
            WriteByteArray(bytes, bytes.Length, 0);
        }

        public float ReadFloat() {
            if ( ((this.inBytesUsed + 4) > this.inBytesRead) ||
                 (this.inBytesPacket < 4) ) {
                // If the float isn't fully in the buffer, or if it isn't fully in the packet,
                // then use ReadByteArray since the logic is there to take care of that.

                ReadByteArray(bTmp, 0, 4);
                return BitConverter.ToSingle(bTmp, 0);
            }
            else {
                // The entire float is in the packet and in the buffer, so just return it
                // and take care of the counters.

                float f = BitConverter.ToSingle(this.inBuff, this.inBytesUsed);
                this.inBytesUsed +=4;
                this.inBytesPacket -= 4;
                return f;
            }
        }

        //
        // Takes a long and writes it as a long.
        //
        private void WriteLong(long v) {
            byte[] bytes = BitConverter.GetBytes(v);
            WriteByteArray(bytes, bytes.Length, 0);
        }

        public long ReadLong() {
            if ( ((this.inBytesUsed + 8) > this.inBytesRead) ||
                 (this.inBytesPacket < 8) ) {
                // If the long isn't fully in the buffer, or if it isn't fully in the packet,
                // then use ReadByteArray since the logic is there to take care of that.

                ReadByteArray(bTmp, 0, 8);
                return BitConverter.ToInt64(bTmp, 0);
            }
            else {
                // The entire long is in the packet and in the buffer, so just return it
                // and take care of the counters.

                long l = BitConverter.ToInt64(this.inBuff, this.inBytesUsed);
                this.inBytesUsed +=8;
                this.inBytesPacket -= 8;
                return l;
            }
        }

        //
        // Takes a double and writes it as a 64 bit double.
        //
        private void WriteDouble(double v) {
            byte[] bytes = BitConverter.GetBytes(v);
            WriteByteArray(bytes, bytes.Length, 0);
        }

        public double ReadDouble() {
            if ( ((this.inBytesUsed + 8) > this.inBytesRead) ||
                 (this.inBytesPacket < 8) ) {
                // If the double isn't fully in the buffer, or if it isn't fully in the packet,
                // then use ReadByteArray since the logic is there to take care of that.

                ReadByteArray(bTmp, 0, 8);
                return BitConverter.ToDouble(bTmp, 0);
            }
            else {
                // The entire double is in the packet and in the buffer, so just return it
                // and take care of the counters.

                double d = BitConverter.ToDouble(this.inBuff, this.inBytesUsed);
                this.inBytesUsed +=8;
                this.inBytesPacket -= 8;
                return d;
            }
        }

        // Reads bytes from the buffer but doesn't return them, in effect simply deleting them.
        public void SkipBytes(long num) {
        	int cbSkip = 0;
			while (num > 0) {
				cbSkip = (num > Int32.MaxValue ? Int32.MaxValue : (int) num);
				ReadByteArray(null, 0, cbSkip);
				num -= cbSkip;
			}
       	}

        public void PrepareResetConnection() {
            // Set flag to reset connection upon next use - only for use on shiloh!
            this.fResetConnection = true;
        }

        internal void Run(RunBehavior run) {
            Run(run, null, null);
        }

        internal void Run(RunBehavior run, SqlCommand cmdHandler) {
            // send in a default object
            Run(run, cmdHandler, null);
        }

        // Main parse loop for the top-level tds tokens, calls back into the I*Handler interfaces
        internal bool Run(RunBehavior run, SqlCommand cmdHandler, SqlDataReader dataStream) {
            bool dataReady     = false;
            bool altTokenError = false;

            _SqlMetaData[] altMetaData = null;

            if (null != cmdHandler) {
                if (this.pendingCommandWeakRef != null) {
                    this.pendingCommandWeakRef.Target = cmdHandler;
                }
                else {
                    this.pendingCommandWeakRef = new WeakReference(cmdHandler);
                }
            }

            do {
                byte token = ReadByte();

                if (false == (
                             token == TdsEnums.SQLERROR ||
                             token == TdsEnums.SQLINFO ||
                             token == TdsEnums.SQLLOGINACK ||
                             token == TdsEnums.SQLENVCHANGE ||
                             token == TdsEnums.SQLRETURNVALUE ||
                             token == TdsEnums.SQLRETURNSTATUS ||
                             token == TdsEnums.SQLCOLNAME ||
                             token == TdsEnums.SQLCOLFMT ||
                             token == TdsEnums.SQLCOLMETADATA ||
                             token == TdsEnums.SQLALTMETADATA ||
                             token == TdsEnums.SQLTABNAME ||
                             token == TdsEnums.SQLCOLINFO ||
                             token == TdsEnums.SQLORDER ||
                             token == TdsEnums.SQLALTROW ||
                             token == TdsEnums.SQLROW ||
                             token == TdsEnums.SQLDONE ||
                             token == TdsEnums.SQLDONEPROC ||
                             token == TdsEnums.SQLDONEINPROC ||
                             token == TdsEnums.SQLROWCRC ||
                             token == TdsEnums.SQLSECLEVEL ||
                             token == TdsEnums.SQLCONTROL ||
                             token == TdsEnums.SQLPROCID ||
                             token == TdsEnums.SQLOFFSET ||
                             token == TdsEnums.SQLSSPI) ) {
#if DEBUG
                    DumpByteArray(this.inBuff);
#endif
                    Debug.Assert(false, "bad token!");

                    this.state = TdsParserState.Broken;
                    this.connHandler.BreakConnection();            
                    throw SQL.ParsingError(); // MDAC 82443
                }

                int tokenLength = GetTokenLength(token);

                //if (CompModSwitches.SqlTDSStream.TraceVerbose)
                //Console.WriteLine(token.ToString("x2"));

                switch (token) {
                    case TdsEnums.SQLERROR:
                    case TdsEnums.SQLINFO:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: error or info");

                            SqlError error = ProcessError(token);

                            if (RunBehavior.Clean != run) {
                                // insert error/info into the appropriate exception - warning if info, exception if error
                                if (error.Class < TdsEnums.MIN_ERROR_CLASS) {
                                    if (this.warning == null)
                                        this.warning = new SqlException();

                                    this.warning.Errors.Add(error);
                                }
                                else {
                                    if (this.exception == null)
                                        this.exception = new SqlException();

                                    this.exception.Errors.Add(error);
                                }
                            }
                            else if (error.Class >= TdsEnums.FATAL_ERROR_CLASS) {
                                if (this.exception == null)
                                    this.exception = new SqlException();

                                this.exception.Errors.Add(error);
                            }

                            break;
                        }
                    case TdsEnums.SQLCOLINFO:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: colinfo");

                            if (null != dataStream){
                                dataStream.SetMetaData(ProcessColInfo(dataStream.MetaData, dataStream), false /*no more metadata coming down the pipe */);
                                dataStream.BrowseModeInfoConsumed = true;
                            }
                            else { // no dataStream
                                SkipBytes(tokenLength);
                            }

                            if (TdsEnums.SQLALTMETADATA == PeekByte()) {
                                // always throw an exception and clean off the wire if we receive
                                // alt tokens - do this before we return from execute to the user
                                altTokenError = true; // set bool to throw ComputeBy error
                                this.CleanWire();
                            }

                            break;
                        }
                    case TdsEnums.SQLDONE:
                    case TdsEnums.SQLDONEPROC:
                    case TdsEnums.SQLDONEINPROC:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: done, doneproc, doneinproc");

                            ProcessDone(cmdHandler, run);
                            break;
                        }
                    case TdsEnums.SQLORDER:
                        //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                        //    Debug.WriteLine("token: order");

                        // don't do anything with the order token so read off the pipe
                        SkipBytes(tokenLength);
                        break;
                    case TdsEnums.SQLALTMETADATA:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: AltMetaData");

                            // skip metadata - only reading the absolute necessary info
                            altMetaData = SkipAltMetaData(tokenLength);
                            break;
                        }
                    case TdsEnums.SQLALTROW:
                        //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                        //    Debug.WriteLine("token: Altrow");

                        SkipBytes(2); // eat the Id value, but only present on an AltRow
                        // skip the rows
                        SkipRow(altMetaData);
                        break;
                    case TdsEnums.SQLENVCHANGE:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: env change");


                            SqlEnvChange env = ProcessEnvChange(tokenLength);
                            this.connHandler.OnEnvChange(env);
                            break;
                        }
                    case TdsEnums.SQLLOGINACK:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: login ack");

                            SqlLoginAck ack = ProcessLoginAck();
                            // connection
                            this.connHandler.OnLoginAck(ack);
                            break;
                        }
                    case TdsEnums.SQLCOLMETADATA:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: colmetadata");

                            if (tokenLength != TdsEnums.VARNULL) {
                                this.cleanupMetaData = ProcessMetaData(tokenLength);
                            }
                            else {
                                if (cmdHandler != null) {
                                    this.cleanupMetaData = cmdHandler.MetaData;
                                }
                            }

                            if (null != dataStream) {
                                byte peekedToken = PeekByte(); // temporarily cache next byte
                                dataStream.SetMetaData(this.cleanupMetaData, (TdsEnums.SQLTABNAME == peekedToken || TdsEnums.SQLCOLINFO == peekedToken));
                            }

                            if (TdsEnums.SQLALTMETADATA == PeekByte()) {
                                // always throw an exception and clean off the wire if we receive
                                // alt tokens - do this before we return from execute to the user
                                altTokenError = true; // set bool to throw ComputeBy error
                                this.CleanWire();
                            }

                            break;
                        }
                    case TdsEnums.SQLROW:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: row");
/*
#if OBJECT_BINDING
                            if (this.readBehavior == System.Data.SqlClient.ReadBehavior.AsObject) {
                                Debug.Assert(dataStream.RawObjectBuffer != null, "user must provide valid object for ReadBehavior.AsObject");
                                dataStream.DataLoader(dataStream.RawObjectBuffer, this);
                            }
                            else // ReadBehavior.AsRow
#endif
*/
                            if (run != RunBehavior.ReturnImmediately)
                                SkipRow(this.cleanupMetaData); // skip rows

                            dataReady = true;
                            break;
                        }
                    case TdsEnums.SQLRETURNSTATUS:
                        //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                        //    Debug.WriteLine("token: return status");

                        int status  = ReadInt();
                        if (cmdHandler != null)
                            cmdHandler.OnReturnStatus(status);
                        break;
                    case TdsEnums.SQLRETURNVALUE:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: return value");

                            Debug.Assert(null != cmdHandler, "unexpected null commandHandler!");
                            cmdHandler.OnReturnValue(ProcessReturnValue(tokenLength));
                            break;
                        }
                    case TdsEnums.SQLSSPI:
                        {
                            // token length is length of SSPI data - call ProcessSSPI with it
                            ProcessSSPI(tokenLength);
                            break;
                        }
                    case TdsEnums.SQLTABNAME:
                        {
                            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                            //    Debug.WriteLine("token: tabname");

                            if (null != dataStream) {
                                if (isShilohSP1) {
                                    dataStream.TableNamesShilohSP1 = ProcessTableNameShilohSP1(tokenLength);
                                }
                                else {
                                    dataStream.TableNames = ProcessTableName(tokenLength);
                                }
                            }
                            else {
                                SkipBytes(tokenLength);
                            }
                            break;
                        }
                    default:
                        Debug.Assert(false, "Unhandled token:  " + token.ToString() );
                        break;
                }// switch
            } while (this.pendingData && (run != RunBehavior.ReturnImmediately));

            if (this.exception != null || this.warning != null)
                ThrowExceptionAndWarning();

            // if we received an alt token - throw the exception for it!
            if (altTokenError)
                throw SQL.ComputeByNotSupported();

            return dataReady;
        }// Run()

        private SqlEnvChange ProcessEnvChange(int tokenLength) {
            SqlEnvChange env = new SqlEnvChange();

            env.length = tokenLength;
            env.type = ReadByte();

            if (env.type == TdsEnums.ENV_COLLATION) {
                env.newLength = ReadByte();
                Debug.Assert(env.newLength == 5 || env.newLength == 0, "Improper length in new collation!");

                if (env.newLength == 5) {
                    env.newCollation = ProcessCollation();

                    // give the parser the new collation values in case parameters don't specify one
                    this.defaultCollation = env.newCollation;
                    this.defaultCodePage  = GetCodePage(env.newCollation);
                    this.defaultEncoding  = System.Text.Encoding.GetEncoding(this.defaultCodePage);
                    this.defaultLCID      = (int)(env.newCollation.info & 0xfffff);
                }

                env.oldLength = ReadByte();
                Debug.Assert(env.oldLength == 5 || env.oldLength == 0, "Improper length in old collation!");

                if (env.oldLength == 5)
                    env.oldCollation = ProcessCollation();
            }
            else {
                env.newLength = ReadByte();
                env.newValue = ReadString(env.newLength);
                env.oldLength = ReadByte();
                env.oldValue = ReadString(env.oldLength);

                if (env.type == TdsEnums.ENV_LOCALEID) {
                    // UNDONE: this LCID may be incorrect for OEM code pages on 7.0
                    // need a way to get lcid from code page
                    this.defaultLCID = Int32.Parse(env.newValue,CultureInfo.InvariantCulture);
                }
                else
                if (env.type == TdsEnums.ENV_CHARSET)
                {
                    // we copied this behavior directly from luxor - see charset envchange
                    // section from sqlctokn.c
                    Debug.Assert(!isShiloh, "Received ENV_CHARSET on non 7.0 server!");

                    if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING) {
                        this.defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;
                        this.defaultEncoding = System.Text.Encoding.GetEncoding(this.defaultCodePage);
                    }
                    else {
                        Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET, "TdsParser.ProcessEnvChange(): charset value received with length <=10");
                        string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);
                        this.defaultCodePage = Int32.Parse(stringCodePage,CultureInfo.InvariantCulture);
                        this.defaultEncoding = System.Text.Encoding.GetEncoding(this.defaultCodePage);
                    }
                }

                // take care of packet size right here
                if (env.type == TdsEnums.ENV_PACKETSIZE) {
                    //if (AdapterSwitches.SqlPacketInfo.TraceVerbose)
                    //    Debug.WriteLine("Server message: packet size changed from :" + Convert.ToString(PacketSize) + " to: " + env.newValue);
                    PacketSize = Int32.Parse(env.newValue);
                }
            }

            return env;
        }

        private void ProcessDone(SqlCommand cmd, RunBehavior run) {
            int status = ReadUnsignedShort();
            int count;

            // current command
            UInt16 info = ReadUnsignedShort();

            // count (rows affected if bit set)
            count = ReadInt();

            // We get a done token with the attention bit set
            if (TdsEnums.DONE_ATTN == (status & TdsEnums.DONE_ATTN)) {
                Debug.Assert(this.attentionSent, "Received attention done without sending one!");
                
                this.attentionSent = this.pendingData = false;

                Debug.Assert(this.inBytesUsed == this.inBytesRead && this.inBytesPacket == 0, "DONE_ATTN received with more data left on wire");

                // if we recieved an attention (but this thread didn't send it) then
                // we throw an Operation Cancelled error
                if (RunBehavior.Clean != run) {
                    ThrowAttentionError();
                }
            }

            if ( (null != cmd) && (TdsEnums.DONE_COUNT == (status & TdsEnums.DONE_COUNT)) && (info != TdsEnums.DONE_SQLSELECT) ) {
                cmd.RecordsAffected = count;
            }

            // Surface exception for DONE_ERROR in the case we did not receive an error token
            // in the stream, but an error occurred.  In these cases, we throw a general server error.  The
            // situations where this can occur are: an invalid buffer received from client, login error
            // and the server refused our connection, and the case where we are trying to log in but
            // the server has reached its max connection limit.  Bottom line, we need to throw general
            // error in the cases where we did not receive a error token along with the DONE_ERROR.
            if ( (TdsEnums.DONE_ERROR == (TdsEnums.DONE_ERROR & status)) && this.exception == null && RunBehavior.Clean != run) {
                this.exception = new SqlException();
                this.exception.Errors.Add(new SqlError(0, 0, TdsEnums.DEFAULT_ERROR_CLASS,
                                          SQLMessage.SevereError(), "", 0));
                this.pendingData = false;
                ThrowExceptionAndWarning();
            }

            // Similar to above, only with a more severe error.  In this case,
            if ( (TdsEnums.DONE_SRVERROR == (TdsEnums.DONE_SRVERROR & status)) && RunBehavior.Clean != run) {
                // if we received the done_srverror, this exception will override all others in this stream
                this.exception = new SqlException();
                this.exception.Errors.Add(new SqlError(0, 0, TdsEnums.DEFAULT_ERROR_CLASS,
                                          SQLMessage.SevereError(), "", 0));
                this.pendingData = false;
                ThrowExceptionAndWarning();
            }

            // stop if the DONE_MORE bit isn't set (see above for attention handling)
            if (0 == (status & TdsEnums.DONE_MORE)) {
                if (this.attentionSent) {
                    if (this.inBytesUsed < this.inBytesRead) {
                        // If more data in buffer and attention sent, then copy next packet of data to beginning of 
                        // inBuff to ease in processing.  FoundAttention is hardcoded, that is why we need to do this.
                        Array.Copy(this.inBuff, this.inBytesUsed, this.inBuff, 0, this.inBytesRead - this.inBytesUsed);
                        this.inBytesRead = this.inBytesRead - this.inBytesUsed;
                        this.inBytesUsed = 0;

                        ProcessHeader();

                        bool foundATN = FoundAttention();

                        this.inBytesPacket = this.inBytesUsed = this.inBytesRead = 0;

                        if (!foundATN) {
                            Debug.Assert(false, "UNEXPECTED CASE!");
                            ProcessAttention();
                        }

                        // if we recieved an attention (but this thread didn't send it) then
                        // we throw an Operation Cancelled error
                        if (RunBehavior.Clean != run) {
                            ThrowAttentionError();
                        }
                    }
                    else {
                        ProcessAttention();

                        // if we recieved an attention (but this thread didn't send it) then
                        // we throw an Operation Cancelled error
                        if (RunBehavior.Clean != run) {
                            ThrowAttentionError();
                        }
                    }
                }
            
                if (this.inBytesUsed >= this.inBytesRead) {
                    this.pendingData = false;
                }
            }
        }

        private void ThrowAttentionError() {
	    	// best case: we got an attention, most likely in a cancel from another thread
	        // no more data is available, we are done
            this.attentionSent = this.pendingData = false;
	        this.inBytesPacket = this.inBytesUsed = this.inBytesRead = 0;
	        this.exception = new SqlException();
	        this.exception.Errors.Add(new SqlError(0, 0, TdsEnums.DEFAULT_ERROR_CLASS,
	                                  SQLMessage.OperationCancelled(), "", 0));
	        ThrowExceptionAndWarning();
        }

        private SqlLoginAck ProcessLoginAck() {
            SqlLoginAck a = new SqlLoginAck();

            // read past interface type and version
            SkipBytes(1);

            // get the version for internal use and remember if we are talking to an 8.0 server or not
            byte[] b = new byte[TdsEnums.VERSION_SIZE];
            ReadByteArray(b, 0, b.Length);

            int major = ((b[0] << 8) | b[1]);
            int minor = ((b[2] << 8) | b[3]);

            a.isVersion8 = this.isShiloh = ((TdsEnums.TDS71 == major && minor == TdsEnums.DEFAULT_MINOR) ||
                                            (major == TdsEnums.SHILOH_MAJOR && minor == TdsEnums.SHILOH_MINOR_SP1));

            if (major == TdsEnums.SHILOH_MAJOR && minor == TdsEnums.SHILOH_MINOR_SP1) {
                Debug.Assert(this.isShiloh, "isShilohSP1 detected without isShiloh detected");
                this.isShilohSP1 = true;
            }

            byte len = ReadByte();
            a.programName = ReadString(len);
            a.majorVersion = ReadByte();
            a.minorVersion = ReadByte();
            a.buildNum = (short)((ReadByte() << 8) + ReadByte());

            Debug.Assert(this.state == TdsParserState.OpenNotLoggedIn, "ProcessLoginAck called with state not TdsParserState.OpenNotLoggedIn");
            this.state = TdsParserState.OpenLoggedIn;

            // PerfCounters
            SQL.IncrementConnectionCount();
            this.fCounterIncremented = true;

            // Terminate the SSPI session.  This is the appropriate place
            // since we need to wait until the login ack is completed and no more
            // SSPI tokens can be received from the server.
            if (fSSPIInit)
                TermSSPISession();

            return a;
        }

        internal SqlError ProcessError(byte token) {
            int len;
            int number = ReadInt();
            byte state = ReadByte();
            byte errorClass = ReadByte();

            Debug.Assert( ((errorClass >= TdsEnums.MIN_ERROR_CLASS) && token == TdsEnums.SQLERROR) ||
                          ((errorClass < TdsEnums.MIN_ERROR_CLASS) && token == TdsEnums.SQLINFO), "class and token don't match!");

            len = ReadUnsignedShort();
            string message =ReadString(len);

            len = (int) ReadByte();
            string server;
            // MDAC bug #49307 - server sometimes does not send over server field! In those cases
            // we will use our locally cached value.
            if (len == 0)
                server = this.server;
            else
                server = ReadString(len);

            len = (int) ReadByte();
            string procedure = ReadString(len);

            int line = ReadUnsignedShort();

            return new SqlError(number, state, errorClass, message, procedure, line);
        }

        internal SqlReturnValue ProcessReturnValue(int length) {
            SqlReturnValue rec = new SqlReturnValue();
            rec.length = length;
            byte len = ReadByte();
            if (len > 0)
                rec.parameter = ReadString(len);

            // read status and ignore
            ReadByte();
            // read user type
            UInt16 userType = ReadUnsignedShort();
            // read off the flags
            ReadUnsignedShort();
            // the tds guys want to make sure that we always send over the nullable types
            rec.isNullable = true;
            // read the type
            int tdsType = (int)ReadByte();
            // read the MaxLen
            int tdsLen = GetTokenLength((byte)tdsType);
            rec.type = MetaType.GetSqlDataType(tdsType, userType, tdsLen);

            MetaType mt = MetaType.GetMetaType(rec.type);

            // always use the nullable type for parameters
            rec.tdsType = mt.NullableType;

            if (rec.type == SqlDbType.Decimal) {
                rec.precision = ReadByte();
                rec.scale = ReadByte();
            }

            // read the collation for 7.x servers
            if (this.isShiloh && MetaType.IsCharType(rec.type)) {
                rec.collation    = ProcessCollation();

                int codePage = GetCodePage(rec.collation);

                // if the column lcid is the same as the default, use the default encoder
                if (codePage == this.defaultCodePage) {
                    rec.codePage = this.defaultCodePage;
                    rec.encoding = this.defaultEncoding;
                }
                else {
                    rec.codePage = codePage;
                    rec.encoding = System.Text.Encoding.GetEncoding(rec.codePage);
                }
            }

            // whip up a meta data object and store for this return value to read it off the wire
            _SqlMetaData md = new _SqlMetaData(rec, mt);
            // for now we coerce return values into a SQLVariant, not good...
            bool isNull = false;
            int valLen = ProcessColumnHeader(md, ref isNull);

            // always read as sql types
            rec.value = (isNull) ? GetNullSqlValue(md) : ReadSqlValue(md, valLen);
            return rec;
        }

        internal SqlCollation ProcessCollation() {
            SqlCollation collation = new SqlCollation();

            collation.info   = ReadUnsignedInt();
            collation.sortId = ReadByte();
            return collation;
        }

        internal int DefaultLCID {
            get {
                return this.defaultLCID;
            }
        }

        internal int GetCodePage(SqlCollation collation) {
            int codePage;

            if (0 != collation.sortId) {
                codePage = TdsEnums.CODE_PAGE_FROM_SORT_ID[collation.sortId];
                Debug.Assert(0 != codePage, "GetCodePage accessed codepage array and produced 0!");
            }
            else {
                int cultureId = (int) (collation.info & 0xfffff);
                CultureInfo ci = null;
                bool success = false;

                try {
                    ci = new CultureInfo(cultureId);
                    success = true;
                }
                catch (ArgumentException) {
                }

                // If we failed, it is quite possible this is because certain culture id's
                // were removed in Win2k and beyond, however Sql Server still supports them.
                // There is a workaround for the culture id's listed below, which is to mask
                // off the sort id (the leading 1). If that fails, or we have a culture id
                // other than the special cases below, we throw an error and throw away the
                // rest of the results. For additional info, see MDAC 65963.
                if (!success) {
                    switch (cultureId) {
                        case 0x10404: // Taiwan
                        case 0x10804: // China
                        case 0x10c04: // Hong Kong
                        case 0x11004: // Singapore
                        case 0x11404: // Macao
                        case 0x10411: // Japan
                        case 0x10412: // Korea
                            // If one of the following special cases, mask out sortId and
                            // retry.
                            cultureId = cultureId & 0x03fff;

                            try {
                                ci = new CultureInfo(cultureId);
                                success = true;
                            }
                            catch (ArgumentException) {
                            }
                            break;
                        default:
                            break;
                    }

                    // I don't believe we should still be in failure case, but just in case.
                    if (!success) {
                        this.CleanWire();

                        this.exception = new SqlException();
                        this.exception.Errors.Add(new SqlError(0, 0, TdsEnums.DEFAULT_ERROR_CLASS,
                                                  SQLMessage.CultureIdError(), "", 0));
                        this.pendingData = false;
                        ThrowExceptionAndWarning();
                    }
                }

                TextInfo ti = ci.TextInfo;
                codePage    = ti.ANSICodePage;
            }

            return codePage;
        }

        internal _SqlMetaData[] ProcessMetaData(int cColumns) {
            Debug.Assert(cColumns > 0, "should have at least 1 column in metadata!");
            _SqlMetaData[] metaData = new _SqlMetaData[cColumns];
            int len = 0;

            // pass 1, read the meta data off the wire
            for (int i = 0; i < cColumns; i++) {
                // internal meta data class
                _SqlMetaData col = new _SqlMetaData();
                UInt16 userType = ReadUnsignedShort();
                col.ordinal = i;
                // read flags and set appropriate flags in structure
                byte flags = ReadByte();
                col.updatability = (byte) ((flags & TdsEnums.Updatability) >> 2);
                col.isNullable = (TdsEnums.Nullable == (flags & TdsEnums.Nullable));
                col.isIdentity = (TdsEnums.Identity == (flags & TdsEnums.Identity));
                // skip second flag (unused)
                ReadByte();

                byte tdsType = ReadByte();

                col.length = GetTokenLength(tdsType);
                col.type = MetaType.GetSqlDataType(tdsType, userType, col.length);
                col.metaType = MetaType.GetMetaType(col.type);
                col.tdsType = (col.isNullable ? col.metaType.NullableType : col.metaType.TDSType);

                if (col.type == SqlDbType.Decimal) {
                    col.precision = ReadByte();
                    col.scale = ReadByte();
                }

                // read the collation for 7.x servers
                if (this.isShiloh && MetaType.IsCharType(col.type)) {
                    col.collation    = ProcessCollation();

                    int codePage = GetCodePage(col.collation);

                    if (codePage == this.defaultCodePage) {
                        col.codePage = this.defaultCodePage;
                        col.encoding = this.defaultEncoding;
                    }
                    else {
                        col.codePage = codePage;
                        col.encoding = System.Text.Encoding.GetEncoding(col.codePage);
                    }
                }

                if (col.metaType.IsLong) {
                    len = ReadUnsignedShort();
                    string tableName = ReadString(len);
                    ParseTableName(col, tableName);
                }

                len = ReadByte();
                col.column = ReadString(len);

                //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                //    Debug.WriteLine("Column:  " + col.column);

                //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
                //    Debug.WriteLine("tdsType:" + (tdsType).ToString("x2"));

                metaData[i] = col;
            }

            return metaData;
        }

        internal string[][] ProcessTableNameShilohSP1(int length) {
            int numParts;
            int tableLen;
            int tablesAdded = 0;

            string[][] tables = new string[1][];
            string[] table;

            while (length > 0) {
                numParts = ReadByte();
                length = length - 1; // subtract numParts byte

                table = new string[numParts];

                for (int i = 0; i < numParts; i++) {
                    tableLen = ReadUnsignedShort();
                    length -= 2;

                    if (tableLen != 0) {
                        table[i] = ReadString(tableLen);
                    }
                    else {
                        table[i] = "";
                    }

                    length -= (tableLen*2); // wide bytes
                }

                if (tablesAdded == 0) {
                    tables[tablesAdded] = table;
                }
                else {
                    string[][] newTables = new string[tables.Length + 1][];
                    Array.Copy(tables, 0, newTables, 0, tables.Length);
                    newTables[tables.Length] = table;
                    tables = newTables;
                }
                tablesAdded++;
            }

            return tables;
        }

        // a table name is returned for each table in the query
        internal string[] ProcessTableName(int length) {
            int tableLen;
            int cNamesAdded = 0;

            // normal case is 1 base table
            string[] tables = new string[1];

            while (length > 0) {
                tableLen = ReadUnsignedShort();
                length -= 2;

                // UNDONE: BUG(?) SQL 8.003 returns two tables sometimes
                // (select orderid from orders where orderid < ?)
                // need to investigate
                string s = ReadString(tableLen);

                if (0 == cNamesAdded) {
                    tables[cNamesAdded] = s;
                }
                else {
                    string[] newTables = new string[tables.Length + 1];
                    Array.Copy(tables, 0, newTables, 0, tables.Length);
                    newTables[tables.Length] = s;
                    tables = newTables;
                }

                cNamesAdded++;

                length -= (tableLen*2); // wide bytes
             }

            Debug.Assert(null != tables[0], "must have at least one table name!");
            return tables;
        }

        // augments current metadata with table and key information
        private _SqlMetaData[] ProcessColInfo(_SqlMetaData[] columns, SqlDataReader reader) {
            Debug.Assert(columns != null && columns.Length > 0, "no metadata available!");

            for (int i = 0; i < columns.Length; i++) {
                _SqlMetaData col = columns[i];
                ReadByte();    // colnum, ignore
                col.tableNum = ReadByte();

                // interpret status
                byte status = ReadByte();

                col.isDifferentName = (TdsEnums.SQLDifferentName == (status & TdsEnums.SQLDifferentName));
                col.isExpression = (TdsEnums.SQLExpression == (status & TdsEnums.SQLExpression));
                col.isKey = (TdsEnums.SQLKey == (status & TdsEnums.SQLKey));
                col.isHidden = (TdsEnums.SQLHidden == (status & TdsEnums.SQLHidden));

                // read off the base table name if it is different than the select list column name
                if (col.isDifferentName) {
                    byte len = ReadByte();
                    col.baseColumn = ReadString(len);
                }

                // Fixup column name - only if result of a table - that is if it it was not the result of
                // an expression.
                if (col.tableNum != 0) {
                    Debug.Assert(false == col.isExpression, "expression column should not have a non-zero tableNum!");
                    if (this.isShilohSP1) {
                        if (reader.TableNamesShilohSP1 != null) {
                            string[] table = reader.TableNamesShilohSP1[col.tableNum - 1];
                            AssignParsedTableName(col, table, table.Length);
                        }
                    }
                    else {
                        if (reader.TableNames != null) {
                            Debug.Assert(reader.TableNames.Length >= 1, "invalid tableNames array!");
                            ParseTableName(col, reader.TableNames[col.tableNum - 1]);
                        }
                    }
                }

                // MDAC 60109: expressions are readonly
                if (col.isExpression) {
                	col.updatability = 0;
                }
            }

            // set the metadata so that the stream knows some metadata info has changed
            return columns;
        }

        private void ParseTableName(_SqlMetaData col, string unparsedTableName) {
            // TableName consists of up to four parts:
            // 1) Server
            // 2) Catalog
            // 3) Schema
            // 4) Table
            // Parse the string into four parts, allowing the last part to contain '.'s.
            // If There are less than four period delimited parts, use the parts from table
            // backwards.  This is the method OleDb uses for parsing.

            if (null == unparsedTableName || unparsedTableName.Length == 0) {
                return;
            }

            string[] parsedTableName = new string[4];
            int offset = 0;
            int periodOffset = 0;

            int i = 0;

            for (; i<4; i++) {
                periodOffset = unparsedTableName.IndexOf('.', offset);
                if (-1 == periodOffset) {
                    parsedTableName[i] = unparsedTableName.Substring(offset);
                    break;
                }

                parsedTableName[i] = unparsedTableName.Substring(offset, periodOffset - offset);
                offset = periodOffset + 1;

                if (offset >= unparsedTableName.Length) {
                    break;
                }
            }

            AssignParsedTableName(col, parsedTableName, i+1);
        }

        private void AssignParsedTableName(_SqlMetaData col, string[] parsedTableName, int length) {
            switch(length) {
                case 4:
                    col.serverName = parsedTableName[0];
                    col.catalogName = parsedTableName[1];
                    col.schemaName = parsedTableName[2];
                    col.tableName = parsedTableName[3];
                    break;
                case 3:
                    col.catalogName = parsedTableName[0];
                    col.schemaName = parsedTableName[1];
                    col.tableName = parsedTableName[2];
                    break;
                case 2:
                    col.schemaName = parsedTableName[0];
                    col.tableName = parsedTableName[1];
                    break;
                case 1:
                    col.tableName = parsedTableName[0];
                    break;
                default:
                    Debug.Assert(false, "SqlClient.TdsParser::ParseTableName: invalid number of table parts: " + length);
                    break;
            }
        }

        // takes care of any per data header information:
        // for long columns, reads off textptrs, reads length, check nullability
        // for other columns, reads length, checks nullability
        // returns length and nullability
        internal int ProcessColumnHeader(_SqlMetaData col, ref bool isNull) {
            int length = 0;
            if (col.metaType.IsLong) {
                //
                // we don't care about TextPtrs, simply go after the data after it
                //
                byte textPtrLen = ReadByte();

                if (0 != textPtrLen) {
                    // read past text pointer
                    SkipBytes(textPtrLen);
                     // read past timestamp
                    SkipBytes(TdsEnums.TEXT_TIME_STAMP_LEN);
                    isNull = false;
                    length = GetTokenLength(col.tdsType);
                }
                else {
                    isNull = true;
                    length = 0;
                }
            }
            else {
                // non-blob columns
                length = GetTokenLength(col.tdsType);
                isNull = IsNull(col, length);
                length = isNull ? 0 : length;
            }
            return length;
        }

        // optimized row process for object access
        internal void ProcessRow(_SqlMetaData[] columns, object[] buffer, int[] map, bool useSQLTypes) {
            _SqlMetaData md;
            bool isNull = false;
            int len;

            for (int i = 0; i < columns.Length; i++) {
                md = columns[i];
                Debug.Assert(md != null, "_SqlMetaData should not be null for column " + i.ToString());
                len = ProcessColumnHeader(md, ref isNull);

                if (isNull) {
                    if (useSQLTypes) {
                        buffer[map[i]] = GetNullSqlValue(md);
                    }
                    else {
                        buffer[map[i]] = DBNull.Value;
                    }
                }
                else {
                	try {
	                    buffer[map[i]] = useSQLTypes ? ReadSqlValue(md, len) : ReadValue(md, len);
                	}
                	catch (_ValueException ve) {
                        ADP.TraceException(ve);
                		buffer[map[i]] = ve.value;
                		throw ve.exception;
                	}
                }
            }

        }

        internal object GetNullSqlValue(_SqlMetaData md) {
            object nullVal = DBNull.Value;;

            switch (md.type) {
                case SqlDbType.Real:
                    nullVal = SqlSingle.Null;
                    break;
                case SqlDbType.Float:
                    nullVal = SqlDouble.Null;
                    break;
                case SqlDbType.Binary:
                case SqlDbType.VarBinary:
                case SqlDbType.Image:
                    nullVal = SqlBinary.Null;
                    break;
                case SqlDbType.UniqueIdentifier:
                    nullVal = SqlGuid.Null;
                    break;
                case SqlDbType.Bit:
                    nullVal = SqlBoolean.Null;
                    break;
                case SqlDbType.TinyInt:
                    nullVal = SqlByte.Null;
                    break;
                case SqlDbType.SmallInt:
                    nullVal = SqlInt16.Null;
                    break;
                case SqlDbType.Int:
                    nullVal = SqlInt32.Null;
                    break;
                case SqlDbType.BigInt:
                    nullVal = SqlInt64.Null;
                    break;
                case SqlDbType.Char:
                case SqlDbType.VarChar:
                case SqlDbType.NChar:
                case SqlDbType.NVarChar:
                case SqlDbType.Text:
                case SqlDbType.NText:
                    nullVal = SqlString.Null;
                    break;
                case SqlDbType.Decimal:
                    nullVal = SqlDecimal.Null;
                    break;
                case SqlDbType.DateTime:
                case SqlDbType.SmallDateTime:
                    nullVal = SqlDateTime.Null;
                    break;
                case SqlDbType.Money:
                case SqlDbType.SmallMoney:
                    nullVal = SqlMoney.Null;
                    break;
                case SqlDbType.Variant:
                    // DBNull.Value will have to work here
                    break;
                default:
                    Debug.Assert(false, "unknown null sqlType!" + md.type.ToString());
                    break;
            }

            return nullVal;
        }

        // UNDONE!  Add SkipMetaData function to skip non altMetaData

        private _SqlMetaData[] SkipAltMetaData(int cColumns) {
            Debug.Assert(cColumns > 0, "should have at least 1 column in alt metadata!");

            _SqlMetaData[] metaData = new _SqlMetaData[cColumns];
            int len = 0;

            SkipBytes(2); // eat the Id field
            SkipBytes( ((int) ReadByte()) * 2); // eat the column numbers - number of columns * 2 (unsigned short)

            for (int i = 0; i < cColumns; i++) {
                _SqlMetaData col = new _SqlMetaData();

                SkipBytes(3); // eat the Op, Operand
                UInt16 userType = ReadUnsignedShort();

                // read flags and set appropriate flags in structure
                byte flags = ReadByte();
                col.isNullable = (TdsEnums.Nullable == (flags & TdsEnums.Nullable));

                // skip second flag (unused)
                SkipBytes(1);

                byte tdsType = ReadByte();

                col.length = GetTokenLength(tdsType);
                col.type = MetaType.GetSqlDataType(tdsType, userType, col.length);
                col.metaType = MetaType.GetMetaType(col.type);
                col.tdsType = (col.isNullable ? col.metaType.NullableType : col.metaType.TDSType);

                if (col.type == SqlDbType.Decimal)
                    SkipBytes(2); // eat precision and scale

                if (this.isShiloh && MetaType.IsCharType(col.type))
                    SkipBytes(5); // eat the collation for 7.x servers

                if (col.metaType.IsLong) {
                    len = ReadUnsignedShort();
                    SkipBytes(len); // eat table name
                }

                len = ReadByte();
                SkipBytes(len << 1); // eat column name

                metaData[i] = col;
            }

            return metaData;
        }

        internal void SkipRow(_SqlMetaData[] columns) {
            SkipRow(columns, 0);
        }

        internal void SkipRow(_SqlMetaData[] columns, int startCol) {
            _SqlMetaData md;

            for (int i = startCol; i < columns.Length; i++) {
                md = columns[i];

                if (md.metaType.IsLong) {
                    byte textPtrLen = ReadByte();

                    if (0 != textPtrLen)
                        SkipBytes(textPtrLen + TdsEnums.TEXT_TIME_STAMP_LEN);
                    else
                        continue;
                }

                SkipValue(md);
            }
        }

        internal void SkipValue(_SqlMetaData md) {
            int length = GetTokenLength(md.tdsType);

            // if false, no value to skip - it's null
            if (!IsNull(md, length))
                SkipBytes(length);

            return;
        }

        private bool IsNull(_SqlMetaData md, int length) {
            // null bin and char types have a length of -1 to represent null
            if (TdsEnums.VARNULL == length)
                return true;

            // other types have a length of 0 to represent null
            if (TdsEnums.FIXEDNULL == length)
                if (!MetaType.IsCharType(md.type) && !MetaType.IsBinType(md.type))
                    return true;

            return false;
        }

        //
        // use to read:
        // VARLEN ActualLen;
        // VARBYTE[ActualLen]
        // off the wire into object, this should change once we have a strongly typed mechanism ourself
        // This function is called for reading values into a parameter
        //
        internal object ReadValue(_SqlMetaData md, int length) {
            byte tdsType = md.tdsType;
            object data = null;

            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
            //    Debug.WriteLine("nullable column:  " + md.isNullable.ToString());
            Debug.Assert(!IsNull(md, length), "null value shound not get here!");

            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
            //    Debug.WriteLine("tdsType:  " + (tdsType).ToString("x2"));

            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
            //    Debug.WriteLine("length:  " + (length).ToString("x8"));

            //
            // now read the data
            //
            switch (tdsType) {
                case TdsEnums.SQLFLT4:
                    Debug.Assert(length == 4, "Invalid length for SqlReal type!");
                    data = ReadFloat();
                    break;
                case TdsEnums.SQLFLTN:
                    if (length == 4)
                        data = ReadFloat();
                    else {
                        Debug.Assert(length == 8, "Invalid length for SqlDouble type!");
                        data = ReadDouble();
                    }
                    break;
                case TdsEnums.SQLFLT8:
                    Debug.Assert(length == 8, "Invalid length for SqlDouble type!");
                    data = ReadDouble();
                    break;
                case TdsEnums.SQLBINARY:
                case TdsEnums.SQLBIGBINARY:
                case TdsEnums.SQLBIGVARBINARY:
                case TdsEnums.SQLVARBINARY:
                case TdsEnums.SQLIMAGE:
                case TdsEnums.SQLUNIQUEID:
                    {
                        Debug.Assert( ((tdsType == TdsEnums.SQLUNIQUEID) &&
                                       (length == 16)) || (tdsType != TdsEnums.SQLUNIQUEID), "invalid length for SqlUniqueId type!");

                        byte[] b = new byte[length];
                        ReadByteArray(b, 0, length);

                        // bug 48623, wrap byte[] as a guid for uniqueidentifier type
                        if (tdsType == TdsEnums.SQLUNIQUEID)
                            data = new Guid(b);
                        else
                            data = b;
                        break;
                    }
                case TdsEnums.SQLBIT:
                case TdsEnums.SQLBITN:
                    {
                        byte b = ReadByte();
                        Debug.Assert(length == 1, "Invalid length for SqlBoolean type");
                        data = (b == 0) ? false : true;
                        break;
                    }
                case TdsEnums.SQLINT1:
                    {
                        Debug.Assert(length == 1, "Invalid length for SqlTinyInt type");
                        data = ReadByte();
                        break;
                    }
                case TdsEnums.SQLINT2:
                    {
                        Debug.Assert(length == 2, "Invalid length for SqlSmallInt type");
                        data = ReadShort();
                        break;
                    }
                case TdsEnums.SQLINT4:
                    {
                        Debug.Assert(length == 4, "Invalid length for SqlInt type:  " + length.ToString());
                        data = ReadInt();
                        break;
                    }
                case TdsEnums.SQLINTN:
                    if (length == 1)
                        data = ReadByte();
                    else
                        if (length == 2)
                        data = ReadShort();
                    else
                        if (length == 4) {
                        data = ReadInt();
                    }
                    else {
                        Debug.Assert(length == 8, "invalid length for SqlIntNtype:  " + length.ToString());
                        data = ReadLong();
                    }
                    break;
                case TdsEnums.SQLINT8:
                    Debug.Assert(length == 8, "Invalid length for SqlBigInt type!");
                    data = ReadLong();
                    break;
                case TdsEnums.SQLCHAR:
                case TdsEnums.SQLBIGCHAR:
                case TdsEnums.SQLVARCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                case TdsEnums.SQLTEXT:
                    // okay to use variants for now for strings since they are already boxed objects
                    // UNDONE: when we use SQLChar, SQLVarChar, etc, we will need to change this
                    data = ReadEncodingChar(length, md.encoding);
                    break;
                case TdsEnums.SQLNCHAR:
                case TdsEnums.SQLNVARCHAR:
                case TdsEnums.SQLNTEXT:
                    data = ReadString(length >> 1);
                    break;
                case TdsEnums.SQLDECIMALN:
                case TdsEnums.SQLNUMERICN:
                     // always read as SqlDecimal
                     SqlDecimal num = ReadSqlDecimal(length, md.precision, md.scale);
                     // if the Sql decimal won't fit into a urt decimal then read it as a string
                     // and throw an exception
                     try {
	                     data = num.Value;
                     }
                     catch(Exception e) {
                         ADP.TraceException(e);
                     	throw new _ValueException(e, num.ToString());
                     }
                     break;
                case TdsEnums.SQLDATETIMN:
                case TdsEnums.SQLDATETIME:
                case TdsEnums.SQLDATETIM4:
                    data = ReadDateTime(length);
                    break;
                case TdsEnums.SQLMONEYN:
                case TdsEnums.SQLMONEY:
                case TdsEnums.SQLMONEY4:
                    data = ReadCurrency(length);
                    break;
                case TdsEnums.SQLVARIANT:
                    data = ReadSqlVariant(length, false);
                    break;
                default:
                    Debug.Assert(false, "Unknown SqlType!" + tdsType.ToString());
                    break;
            } // switch

//            Debug.WriteLine(data);

            return data;
        }
        //
        // use to read:
        // VARLEN ActualLen;
        // VARBYTE[ActualLen]
        // off the wire into the appropriate SQLType
        //
        internal object ReadSqlValue(_SqlMetaData md, int length) {
            byte tdsType = md.tdsType;
            object value = null;

            Debug.Assert(!IsNull(md, length), "null value shound not get here!");

            //if (AdapterSwitches.SqlTDSStream.TraceVerbose)
            //    Debug.WriteLine("tdsType:  " + (tdsType).ToString("x2"));

            //
            // now read the data
            //
            switch (tdsType) {
                case TdsEnums.SQLFLT4:
                    value = new SqlSingle(ReadFloat());
                    break;
                case TdsEnums.SQLFLT8:
                    value =  new SqlDouble(ReadDouble());
                    break;
                case TdsEnums.SQLFLTN:
                    if (md.type == SqlDbType.Real)
                        value =  new SqlSingle(ReadFloat());
                    else {
                        Debug.Assert(md.type == SqlDbType.Float, "must be float type!");
                        value = new SqlDouble(ReadDouble());
                    }
                    break;
                case TdsEnums.SQLBINARY:
                case TdsEnums.SQLBIGBINARY:
                case TdsEnums.SQLBIGVARBINARY:
                case TdsEnums.SQLVARBINARY:
                case TdsEnums.SQLIMAGE:
                    {
                        byte[] b = new byte[length];
                        ReadByteArray(b, 0, length);
                        value = new SqlBinary(b);
                        break;
                    }
                 case TdsEnums.SQLUNIQUEID:
                    {
                        byte[] b = new byte[length];
                        ReadByteArray(b, 0, length);
                        value = new SqlGuid(b);
                        break;
                    }
                case TdsEnums.SQLBIT:
                case TdsEnums.SQLBITN:
                    if (1 == ReadByte())
                        value = SqlBoolean.One;
                    else
                        value = SqlBoolean.Zero;
                    break;
                case TdsEnums.SQLINT1:
                    value = new SqlByte(ReadByte());
                    break;
                case TdsEnums.SQLINT2:
                     value = new SqlInt16(ReadShort());
                    break;
                case TdsEnums.SQLINT4:
                    value = new SqlInt32(ReadInt());
                    break;
                case TdsEnums.SQLINT8:
                    value = new SqlInt64(ReadLong());
                    break;
                case TdsEnums.SQLINTN:
                    if (md.type == SqlDbType.TinyInt) {
                        value = new SqlByte(ReadByte());
                    }
                    else
                    if (md.type == SqlDbType.SmallInt) {
                        value = new SqlInt16(ReadShort());
                    }
                    else
                    if (md.type == SqlDbType.Int) {
                        value = new SqlInt32(ReadInt());
                    }
                    else {
                        value = new SqlInt64(ReadLong());
                    }
                    break;
                case TdsEnums.SQLCHAR:
                case TdsEnums.SQLBIGCHAR:
                case TdsEnums.SQLVARCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                case TdsEnums.SQLTEXT:
                    if (null != md.collation) {
                        int lcid = TdsParser.Getlcid(md.collation);
                        SqlCompareOptions options = TdsParser.GetSqlCompareOptions(md.collation);                
                        value = new SqlString(ReadEncodingChar(length, md.encoding), lcid, options);
                    }
                    else {
                        value = new SqlString(ReadEncodingChar(length, md.encoding));
                    }
                    break;
                case TdsEnums.SQLNCHAR:
                case TdsEnums.SQLNVARCHAR:
                case TdsEnums.SQLNTEXT:
                    if (null != md.collation) {
                        int lcid = TdsParser.Getlcid(md.collation);
                        SqlCompareOptions options = TdsParser.GetSqlCompareOptions(md.collation);                
                        value = new SqlString(ReadString(length >> 1), lcid, options);
                    }
                    else {
                        value = new SqlString(ReadString(length >> 1));
                    }
                    break;
                case TdsEnums.SQLDECIMALN:
                case TdsEnums.SQLNUMERICN:
                    value = ReadSqlDecimal(length, md.precision, md.scale);
                    break;
                case TdsEnums.SQLDATETIMN:
                case TdsEnums.SQLDATETIME:
                case TdsEnums.SQLDATETIM4:
                    value = ReadSqlDateTime(length);
                    break;
                case TdsEnums.SQLMONEYN:
                case TdsEnums.SQLMONEY:
                case TdsEnums.SQLMONEY4:
                    value = ReadSqlMoney(length);
                    break;
                case TdsEnums.SQLVARIANT:
                    value = ReadSqlVariant(length, true);
                    break;
                default:
                    Debug.Assert(false, "Unknown SqlType!" + tdsType.ToString());
                    break;
            } // switch

            return value;
        }

        //
        // Read in a SQLVariant and covert to object
        //
        // SQLVariant looks like:
        // struct
        // {
        //      BYTE TypeTag
        //      BYTE cbPropBytes
        //      BYTE[] Properties
        //      BYTE[] DataVal
        // }
        public object ReadSqlVariant(int lenTotal, bool readAsSQLValue) {
            Debug.Assert(this.isShiloh == true, "Shouldn't be dealing with sql_variaint in non-7x server!");

            // null value by default
            object data = null;

            // get the SQLVariant type
            byte type = ReadByte();
            int lenMax = 0; // maximum length of data inside variant

            // read cbPropBytes
            byte cbPropsActual = ReadByte();
            SqlDbType dt = MetaType.GetSqlDataType(type, 0 /*no user datatype*/, 0 /* no length, non-nullable type */);
            MetaType mt = MetaType.GetMetaType(dt);
            byte cbPropsExpected = mt.PropBytes;

            int lenConsumed = TdsEnums.SQLVARIANT_SIZE + cbPropsActual; // type, count of propBytes, and actual propBytes
            int lenData = lenTotal - lenConsumed; // length of data

            // read known properties and skip unknown properties
            Debug.Assert(cbPropsActual >= cbPropsExpected, "cbPropsActual is less that cbPropsExpected!");

            //
            // now read the data
            //
            switch (type) {
                case TdsEnums.SQLFLT4:
                    data = ReadFloat();
                    if (readAsSQLValue)
                        data = new SqlSingle((float)data);

                    break;
                case TdsEnums.SQLFLT8:
                    data = ReadDouble();
                    if (readAsSQLValue)
                        data = new SqlDouble((double)data);
                    break;
                case TdsEnums.SQLBIGBINARY:
                case TdsEnums.SQLBIGVARBINARY:
                    {
                        Debug.Assert(cbPropsExpected == 2, "SqlVariant:  invalid PropBytes for binary type!");
                        lenMax = ReadUnsignedShort();

                        // skip over unknown properties
                        if (cbPropsActual > cbPropsExpected)
                            SkipBytes(cbPropsActual - cbPropsExpected);

                        // length of data equals (lenTotal - lenConsumed)
                        if (TdsEnums.VARNULL != lenData) {
                            byte[] b = new byte[lenData];
                            ReadByteArray(b, 0, lenData);
                            data = b;
                        }

                        if (readAsSQLValue)
                            data = new SqlBinary((byte[])data);

                        break;
                    }
                case TdsEnums.SQLUNIQUEID:
                    {
                        byte[] b = new byte[16];
                        ReadByteArray(b, 0, 16);

                        if (readAsSQLValue) {
                            data = new SqlGuid(b);
                        }
                        else
                            data = new Guid(b);
                        break;
                    }
                case TdsEnums.SQLBIT:
                    {
                        byte b = ReadByte();

                        if (readAsSQLValue)
                            data = (b == 0) ? SqlBoolean.Zero : SqlBoolean.One;
                        else
                            data = (b == 0) ? false : true;

                        break;
                    }
                case TdsEnums.SQLINT1:
                    {
                        data = ReadByte();
                        if (readAsSQLValue)
                            data = new SqlByte((byte)data);
                        break;
                    }

                case TdsEnums.SQLINT2:
                    {
                        data = ReadShort();
                        if (readAsSQLValue)
                            data = new SqlInt16((short)data);
                        break;
                    }
                case TdsEnums.SQLINT4:
                    {
                        data = ReadInt();
                        if (readAsSQLValue)
                            data = new SqlInt32((int)data);
                        break;
                    }
                case TdsEnums.SQLINT8:
                    data = ReadLong();
                    if (readAsSQLValue)
                        data = new SqlInt64((long)data);
                    break;
                case TdsEnums.SQLBIGCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                case TdsEnums.SQLNCHAR:
                case TdsEnums.SQLNVARCHAR:
                    {
                        Debug.Assert(cbPropsExpected == 7, "SqlVariant:  invalid PropBytes for character type!");
                        // UNDONE: what am I going to do with this info?!!
                        // UNDONE: need to set this on the dataSet for the value?!!
                        SqlCollation collation = ProcessCollation();

                        lenMax = ReadUnsignedShort();

                        if (cbPropsActual > cbPropsExpected)
                            SkipBytes(cbPropsActual - cbPropsExpected);

                        if ( TdsEnums.VARNULL != lenData) {
                            if (type == TdsEnums.SQLBIGCHAR || type == TdsEnums.SQLBIGVARCHAR) {
                                int codePage = GetCodePage(collation);

                                if (codePage == this.defaultCodePage)
                                    data = ReadEncodingChar(lenData, this.defaultEncoding);
                                else {
                                    Encoding encoding = System.Text.Encoding.GetEncoding(codePage);

                                    data = ReadEncodingChar(lenData, encoding);
                                }
                            }
                            else
                                data = ReadString(lenData >> 1);
                        }

                        if (readAsSQLValue) {
                            int lcid = TdsParser.Getlcid(collation);
                            SqlCompareOptions options = TdsParser.GetSqlCompareOptions(collation);                
                            data = new SqlString((string)data, lcid, options);
                        }
                        break;
                    }
                case TdsEnums.SQLDECIMALN:
                case TdsEnums.SQLNUMERICN:
                    {
                        Debug.Assert(cbPropsExpected == 2, "SqlVariant:  invalid PropBytes for decimal/numeric type!");
                        byte precision = ReadByte();
                        byte scale = ReadByte();

                        if (cbPropsActual > cbPropsExpected)
                            SkipBytes(cbPropsActual - cbPropsExpected);

                        // always read as SQLNUmeric
                        SqlDecimal num = ReadSqlDecimal(TdsEnums.MAX_NUMERIC_LEN, precision, scale);
                        if (readAsSQLValue) {
                            data = num;
                        }
                        else
                            data = num.Value;
                        break;
                    }
                case TdsEnums.SQLDATETIME:
                    if (readAsSQLValue) {
                        data = ReadSqlDateTime(8);
                    }
                    else
                        data = ReadDateTime(8);
                    break;
                case TdsEnums.SQLDATETIM4:
                    if (readAsSQLValue) {
                        data = ReadSqlDateTime(4);
                    }
                    else
                        data = ReadDateTime(4);
                    break;
                case TdsEnums.SQLMONEY:
                    if (readAsSQLValue)
                        data = ReadSqlMoney(8);
                    else
                        data = ReadCurrency(8);
                    break;
                case TdsEnums.SQLMONEY4:
                    if (readAsSQLValue)
                        data = ReadSqlMoney(4);
                    else
                        data = ReadCurrency(4);
                    break;
                default:
                    Debug.Assert(false, "Unknown tds type in SqlVariant!" + type.ToString());
                    break;
            } // switch

            return data;
        }

        //
        // Translates a com+ object -> SqlVariant
        // when the type is ambiguous, we always convert to the bigger type
        // note that we also write out the maxlen and actuallen members (4 bytes each)
        // in addition to the SQLVariant structure
        //
        private void WriteSqlVariantValue(object value, int length, int offset) {
            Debug.Assert(this.isShiloh == true, "Shouldn't be dealing with sql_variaint in non-7x server!");
            // handle null values
            if ( (null == value) || Convert.IsDBNull(value) ) {
                WriteInt(TdsEnums.FIXEDNULL); //maxlen
                WriteInt(TdsEnums.FIXEDNULL); //actuallen
                return;
            }

            MetaType mt = MetaType.GetMetaType(value);

            if (MetaType.IsAnsiType(mt.SqlDbType)) {
                length = GetEncodingCharLength((string)value, length, 0, this.defaultEncoding);
            }

            // max and actual len are equal to
            // SQLVARIANTSIZE {type (1 byte) + cbPropBytes (1 byte)} + cbPropBytes + length (actual length of data in bytes)
            WriteInt(TdsEnums.SQLVARIANT_SIZE + mt.PropBytes + length); // maxLen
            WriteInt(TdsEnums.SQLVARIANT_SIZE + mt.PropBytes + length); // actualLen

            // write the SQLVariant header (type and cbPropBytes)
            WriteByte(mt.TDSType);
            WriteByte(mt.PropBytes);

            // now write the actual PropBytes and data
            switch (mt.TDSType) {
                case TdsEnums.SQLFLT4:
                    WriteFloat((Single)value);
                    break;
                case TdsEnums.SQLFLT8:
                    WriteDouble((Double)value);
                    break;
                case TdsEnums.SQLINT8:
                    WriteLong((Int64)value);
                    break;
                case TdsEnums.SQLINT4:
                    WriteInt((Int32)value);
                    break;
                case TdsEnums.SQLINT2:
                    WriteShort((Int16)value);
                    break;
                case TdsEnums.SQLINT1:
                    WriteByte((byte)value);
                    break;
                case TdsEnums.SQLBIT:
                    if ((bool)value == true)
                        WriteByte(1);
                    else
                        WriteByte(0);
                    break;
                case TdsEnums.SQLBIGVARBINARY:
                    {
                        byte[] b = (byte[]) value;
                        WriteShort(length); // propbytes: varlen
                        WriteByteArray(b, length, offset);
                        break;
                    }
                case TdsEnums.SQLBIGVARCHAR:
                    {
                        string s = (string)value;
                        WriteUnsignedInt(defaultCollation.info); // propbytes: collation.Info
                        WriteByte(defaultCollation.sortId); // propbytes: collation.SortId
                        WriteShort(length); // propbyte: varlen
                        WriteEncodingChar(s, this.defaultEncoding);
                        break;
                    }
                case TdsEnums.SQLUNIQUEID:
                    {
                        System.Guid guid = (System.Guid) value;
                        byte[] b = guid.ToByteArray();
                        Debug.Assert( (length == b.Length) && (length == 16), "Invalid length for guid type in com+ object");
                        WriteByteArray(b, length, 0);
                        break;
                    }
                case TdsEnums.SQLNVARCHAR:
                    {
                        string s = (string)value;
                        WriteUnsignedInt(defaultCollation.info); // propbytes: collation.Info
                        WriteByte(defaultCollation.sortId); // propbytes: collation.SortId
                        WriteShort(length); // propbyte: varlen

                        // string takes cchar, not cbyte so convert
                        length >>= 1;
                        WriteString(s, length, offset);
                        break;
                    }
                case TdsEnums.SQLDATETIME:
                    {
                        TdsDateTime dt = MetaDateTime.FromDateTime((DateTime)value, 8);
                        WriteInt(dt.days);
                        WriteInt(dt.time);
                        break;
                    }
                case TdsEnums.SQLMONEY:
                    {
                        WriteCurrency((Decimal)value, 8);
                        break;
                    }
                case TdsEnums.SQLNUMERICN:
                    {
                        WriteByte(mt.Precision); //propbytes: precision
                        WriteByte((byte) ((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale
                        WriteDecimal((Decimal)value);
                        break;
                    }
                default:
                    Debug.Assert(false, "unknown tds type for sqlvariant!");
		    break;
            } // switch
        }

        private void WriteSqlMoney(SqlMoney value, int length) {
            // UNDONE: can I use SqlMoney.ToInt64()?
            int[] bits = Decimal.GetBits(value.Value);

            // this decimal should be scaled by 10000 (regardless of what the incoming decimal was scaled by)
            bool isNeg = (0 != (bits[3] & unchecked((int)0x80000000)));
            long l = ((long)(uint)bits[1]) << 0x20 | (uint)bits[0];

            if (isNeg)
                l = -l;

            if (length == 4) {
                Decimal decimalValue = value.Value;
                // validate the value can be represented as a small money
                if (decimalValue < TdsEnums.SQL_SMALL_MONEY_MIN || decimalValue > TdsEnums.SQL_SMALL_MONEY_MAX) {
                    throw SQL.MoneyOverflow(decimalValue.ToString());
                }
                WriteInt((int)l);
            }
            else {
                WriteInt((int)(l >> 0x20));
                WriteInt((int)l);
            }
        }

        private void WriteCurrency(Decimal value, int length) {
            SqlMoney m = new SqlMoney(value);
            int[] bits = Decimal.GetBits(m.Value);

            // this decimal should be scaled by 10000 (regardless of what the incoming decimal was scaled by)
            bool isNeg = (0 != (bits[3] & unchecked((int)0x80000000)));
            long l = ((long)(uint)bits[1]) << 0x20 | (uint)bits[0];

            if (isNeg)
                l = -l;

            if (length == 4) {
                // validate the value can be represented as a small money
                if (value < TdsEnums.SQL_SMALL_MONEY_MIN || value > TdsEnums.SQL_SMALL_MONEY_MAX) {
                    throw SQL.MoneyOverflow(value.ToString());
                }
                WriteInt((int)l);
            }
            else {
                WriteInt((int)(l >> 0x20));
                WriteInt((int)l);
            }
        }

        private DateTime ReadDateTime(int length) {
            if (length == 4) {
                return MetaDateTime.ToDateTime(ReadUnsignedShort(), ReadUnsignedShort(), 4);
            }

            Debug.Assert(length == 8, "invalid length for SqlDateTime datatype");
            return MetaDateTime.ToDateTime(ReadInt(), (int)ReadUnsignedInt(), 8);
        }

        private SqlDecimal ReadSqlDecimal(int length, byte precision, byte scale) {
            bool fPositive = (1 == ReadByte());
            length--;
            int[] bits = ReadDecimalBits(length);
            return new SqlDecimal(precision, scale, fPositive, bits);
        }

        private SqlDateTime ReadSqlDateTime(int length) {
            if (length == 4)
                return new SqlDateTime(ReadUnsignedShort(), ReadUnsignedShort() * SqlDateTime.SQLTicksPerMinute);
            else
                return new SqlDateTime(ReadInt(), (int)ReadUnsignedInt());
        }

        private Decimal ReadCurrency(int length) {
            Decimal d;
            bool isNeg = false;

            // Currency is going away in beta2.  Decimal ctor takes (lo, mid, hi, sign, scale)
            // where the scale factor for SQL Server Money types is 10,000
            if (length == 4) {
                int lo = ReadInt();

                if (lo < 0) {
                    lo = -lo;
                    isNeg = true;
                }

                d = new Decimal(lo, 0, 0, isNeg, 4);
            }
            else {
                int mid = ReadInt();
                uint lo = ReadUnsignedInt();
                long l = (Convert.ToInt64(mid) << 0x20) + Convert.ToInt64(lo);

                if (mid < 0) {
                    l = -l;
                    isNeg = true;
                }

                d = new Decimal( (int) (l & 0xffffffff), (int) ((l >> 0x20) & 0xffffffff), 0, isNeg, 4);

            }

            return d;
        }

        private SqlMoney ReadSqlMoney(int length) {
            return new SqlMoney(ReadCurrency(length));
        }

        // @devnote: length should be size of decimal without the sign
        // @devnote: sign should have already been read off the wire
        private int[] ReadDecimalBits(int length) {
            int[] bits = this.decimalBits; // used alloc'd array if we have one already
            int i;

            if (null == bits)
                bits = new int[4];
            else {
                for (i = 0; i <  bits.Length; i++)
                    bits[i] = 0;
            }

            Debug.Assert((length > 0) &&
                         (length <= TdsEnums.MAX_NUMERIC_LEN -1) &&
                         (length % 4 == 0), "decimal should have 4, 8, 12, or 16 bytes of data");

            int decLength = length >> 2;
            for (i = 0; i < decLength; i++) {
                // up to 16 bytes of data following the sign byte
                bits[i] = ReadInt();
            }

            return bits;
        }

        private SqlDecimal AdjustSqlDecimalScale(SqlDecimal d, int newScale) {
            if (d.Scale != newScale) {
                return SqlDecimal.AdjustScale(d, newScale - d.Scale, false /* Don't round, truncate.  MDAC 69229 */);
            }

            return d;
        }

        private decimal AdjustDecimalScale(decimal value, int newScale) {
            int oldScale = (Decimal.GetBits(value)[3] & 0x00ff0000) >> 0x10;
            if (newScale != oldScale) {
                SqlDecimal num = new SqlDecimal(value);
                num = SqlDecimal.AdjustScale(num, newScale - oldScale, false /* Don't round, truncate.  MDAC 69229 */);
                return num.Value;
            }

            return value;
        }

        private void WriteSqlDecimal(SqlDecimal d) {
            // sign
            if (d.IsPositive)
               WriteByte (1);
            else
               WriteByte (0);

            // four ints now
            int[] data = d.Data;
            WriteInt(data[0]);
            WriteInt(data[1]);
            WriteInt(data[2]);
            WriteInt(data[3]);
        }

        private void WriteDecimal(decimal value) {
            decimalBits = Decimal.GetBits(value);
            Debug.Assert(null != this.decimalBits, "decimalBits should be filled in at TdsExecuteRPC time");
            /*
             Returns a binary representation of a Decimal. The return value is an integer
             array with four elements. Elements 0, 1, and 2 contain the low, middle, and
             high 32 bits of the 96-bit integer part of the Decimal. Element 3 contains
             the scale factor and sign of the Decimal: bits 0-15 (the lower word) are
             unused; bits 16-23 contain a value between 0 and 28, indicating the power of
             10 to divide the 96-bit integer part by to produce the Decimal value; bits 24-
             30 are unused; and finally bit 31 indicates the sign of the Decimal value, 0
             meaning positive and 1 meaning negative.

             SQLDECIMAL/SQLNUMERIC has a byte stream of:
             struct {
                 BYTE sign; // 1 if positive, 0 if negative
                 BYTE data[];
             }

             For TDS 7.0 and above, there are always 17 bytes of data
            */

            // write the sign (note that COM and SQL are opposite)
            if (0x80000000 == (decimalBits[3] & 0x80000000))
                WriteByte(0);
            else
                WriteByte(1);

            WriteInt(decimalBits[0]);
            WriteInt(decimalBits[1]);
            WriteInt(decimalBits[2]);
            WriteInt(0);
        }

        public string ReadString(int length) {
            int cBytes = length << 1;
            byte[] buf;
            int offset = 0;

            if ( ((this.inBytesUsed + cBytes) > this.inBytesRead) ||
                 (this.inBytesPacket < cBytes) ) {
                if (this.byteBuffer == null || this.byteBuffer.Length < cBytes) {
                    this.byteBuffer = new byte[cBytes];
                }
                ReadByteArray(this.byteBuffer, 0, cBytes);
                // assign local to point to parser scratch buffer
                buf = this.byteBuffer;
            }
            else {
                // assign local to point to inBuff
                buf = this.inBuff;
                offset = this.inBytesUsed;
                this.inBytesUsed += cBytes;
                this.inBytesPacket -= cBytes;
            }
            return System.Text.Encoding.Unicode.GetString(buf, offset, cBytes);
        }

        private void WriteString(string s) {
            WriteString(s, s.Length, 0);
        }

        private void WriteString(string s, int length, int offset) {
            byte[] byteData = new byte[ADP.CharSize*length];
            System.Text.Encoding.Unicode.GetBytes(s, offset, length, byteData, 0);
            WriteByteArray(byteData, byteData.Length, 0);
        }

        public string ReadEncodingChar(int length, Encoding encoding) {
            byte[] buf;
            int offset = 0;

            // if hitting 7.0 server, encoding will be null in metadata for columns or return values since
            // 7.0 has no support for multiple code pages in data - single code page support only
            if (encoding == null)
                encoding = this.defaultEncoding;

            if ( ((this.inBytesUsed + length) > this.inBytesRead) ||
                 (this.inBytesPacket < length) ) {
                if (this.byteBuffer == null || this.byteBuffer.Length < length) {
                    this.byteBuffer = new byte[length];
                }
                ReadByteArray(this.byteBuffer, 0, length);
                // assign local to point to parser scratch buffer
                buf = this.byteBuffer;
            }
            else {
                // assign local to point to inBuff
                buf = this.inBuff;
                offset = this.inBytesUsed;
                this.inBytesUsed += length;
                this.inBytesPacket -= length;
            }
            if ((null == this.charBuffer) || (this.charBuffer.Length < length)) {
                this.charBuffer = new char[length];
            }
            int charCount = encoding.GetChars(buf, offset, length, this.charBuffer, 0);
            return new String(this.charBuffer, 0, charCount);
        }
        
        private void WriteEncodingChar(string s, Encoding encoding) {
            WriteEncodingChar(s, s.Length, 0, encoding);
        }

        private void WriteEncodingChar(string s, int numChars, int offset, Encoding encoding) {
            char[] charData;
            byte[] byteData;

            // if hitting 7.0 server, encoding will be null in metadata for columns or return values since
            // 7.0 has no support for multiple code pages in data - single code page support only
            if (encoding == null)
                encoding = this.defaultEncoding;
            charData = s.ToCharArray(offset, numChars);
            byteData = encoding.GetBytes(charData, 0, numChars);
            Debug.Assert(byteData != null, "no data from encoding");
            WriteByteArray(byteData, byteData.Length, 0);
        }

        internal int GetEncodingCharLength(string value, int numChars, int charOffset, Encoding encoding) {
            // UNDONE: (PERF) this is an expensive way to get the length.  Also, aren't we
            // UNDONE: (PERF) going through these steps twice when we write out a value?
            if (value == null || value == String.Empty)
                return 0;

            // if hitting 7.0 server, encoding will be null in metadata for columns or return values since
            // 7.0 has no support for multiple code pages in data - single code page support only
            if (encoding == null) {
                encoding = this.defaultEncoding;
            }
            char[] charData = value.ToCharArray(charOffset, numChars);
            return encoding.GetByteCount(charData, 0, numChars);
        }

#if DEBUG
        private void DumpTds(int cBytes) {
            int i = this.inBytesUsed;
            int j = 0;
            while ( (i < this.inBytesRead) &&
                    (i < (this.inBytesUsed + cBytes)) ) {
                Debug.Write(this.inBuff[i++].ToString("x2") + "  ");
                j++;
                if ((j % 8) == 0)
                    Debug.WriteLine("");
            }
        }

        internal void DumpByteArray(byte[] bin) {
            int j = 0;

            for (int i = 0; i < bin.Length && i <= this.inBytesRead; i++) {
                Debug.Write(bin[i].ToString("x2") + "  ");

                if (i == this.inBytesUsed)
                    Debug.WriteLine("-->");

                j++;
                if ((j % 32) == 0)
                    Debug.WriteLine("");
            }
            Debug.WriteLine("");
        }
#endif

        //
        // returns the token length of the token or tds type
        //
        public int GetTokenLength(byte token) {
            int tokenLength = 0;
            Debug.Assert(token != 0, "0 length token!");

            switch (token & TdsEnums.SQLLenMask) {
                case TdsEnums.SQLFixedLen:
                    tokenLength =  ( (0x01 << ((token & 0x0c) >> 2)) ) & 0xff;
                    break;
                case TdsEnums.SQLZeroLen:
                    tokenLength = 0;
                    break;
                case TdsEnums.SQLVarLen:
                case TdsEnums.SQLVarCnt:
                    {

                        if ( 0 != (token & 0x80))
                            tokenLength = ReadUnsignedShort();
                        else
                            if ( 0 == (token & 0x0c))
                            // UNDONE: This should be uint
                            tokenLength = unchecked((int)ReadInt());
                        else
                            tokenLength = ReadByte();

                        break;
                    }
                default:
                    Debug.Assert(false, "Unknown token length!");
		    break;
            }
//            Debug.WriteLine("tokenLength:  " + tokenLength.ToString());
            return tokenLength;
        }

        private void AttentionTimerCallback(object state) {
            if (null != attentionTimer) {
                this.attentionTimer.Dispose();
                this.attentionTimer = null;
            }
        }

        internal void CleanWire() {
            while (_status != TdsEnums.ST_EOM) {
                // jump to the next header
                int cb = this.inBytesRead - this.inBytesUsed;

                if (this.inBytesPacket >= cb) {
                    // consume the bytes in our buffer and
                    // decrement the bytes left in the packet
                    this.inBytesPacket -= cb;
                    this.inBytesUsed = this.inBytesRead;
                    ReadBuffer();
                }
                else {
                    this.inBytesUsed += this.inBytesPacket;
                    this.inBytesPacket = 0;
                    ProcessHeader();
                }
            }

            // cleaned the network, now fixup our buffers
            this.inBytesUsed = this.inBytesPacket = this.inBytesRead = 0;
            this.pendingData = false;
        }

        // Processes the attention by walking through packets.
        private void ProcessAttention() {
            Debug.Assert(this.attentionSent, "invalid attempt to ProcessAttention, this.attentionSent == false!");

            // Keep reading until one of the following cases occur:
            // 1) Reach the EOM packet with a status in the header of ST_AACK (attention acknowledgement)
            // 2) Reach EOM packet without ST_AACK but with a
            //    done token with status of DONE_ATTN (attention acknowledgement)
            // 3) No more data on the wire and secondary timeout occurs (no ST_AACK or done with
            //    DONE_ATTN found) - broken connection
            // 4) More data on the wire but secondary timeout occurs - broken connection
            IntPtr bytesAvail = IntPtr.Zero;
            IntPtr dummyErr   = IntPtr.Zero;
            bool   foundATN   = false;
            this.timeRemaining = new TimeSpan(0, 0, 5); // read buffer

            Debug.Assert(null == this.attentionTimer, "invalid call to ProcessAttention with existing attentionTimer!");
            this.attentionTimer = new Timer(new TimerCallback(AttentionTimerCallback), null, ATTENTION_TIMEOUT, 0);

            while (null != this.attentionTimer) {
                this.inBytesPacket = this.inBytesUsed = this.inBytesRead = 0;

                if (0 < UnsafeNativeMethods.Dbnetlib.ConnectionCheckForData(this.pConObj, out bytesAvail, out dummyErr)) {
                    try {
                        ReadBuffer(); // This call assumes that a ReadNetlib will never fail in the
                                      // middle of a packet.  This should be a correct assumption.  The
                                      // netlib always reads full packets, so unless the netlib failed
                                      // to return in a timely manner we will always return a full
                                      // packet.

                        foundATN = FoundAttention();
                        if (foundATN) {
                            break;
                        }
                    }
                    catch {
                        // if we had more data, but couldn't read it, we are in dire straits
                        foundATN = false;
                        // eat any exceptions here, we already are going to throw a timeout
                        break;
                    }
                }
            }

            // cleanup our timer (okay to call without an attentionTimer object)
            AttentionTimerCallback(null);

            // no more data is available, we are done
            this.attentionSent = this.pendingData = false;

            // if our timeout has expired and we still haven't found ST_AACK or
            // done with DONE_ATTN, break the connection
            if (!foundATN) {
                this.state = TdsParserState.Broken;
                this.connHandler.BreakConnection();            
            }
            else {
                // we found attn, clean out buffers
                this.inBytesPacket = this.inBytesUsed = this.inBytesRead = 0;
            }
        }

        private bool FoundAttention() {
            bool foundATN = false;

            if (TdsEnums.ST_AACK == this.inBuff[1]) {
                // if we find header with ST_AACK, stop reading, we're done
                foundATN = true;
            }
            else if (this.inBuff[1] == TdsEnums.ST_EOM) {
                UInt16 status = 0;

                if (this.inBuff[8] == TdsEnums.SQLDONE ||
                    this.inBuff[8] == TdsEnums.SQLDONEPROC) {
                    // if we find an EOM packet with a done token at the beginning
                    // with a status of DONE_ATTN - stop reading - we're done
                    status = (UInt16) ((this.inBuff[10] << 8) + this.inBuff[9]);
                }
                else if (this.inBuff[this.inBytesRead - 9] == TdsEnums.SQLDONE ||
                         this.inBuff[this.inBytesRead - 9] == TdsEnums.SQLDONEPROC) {
                    // if we find an EOM packet with a done token at the end
                    // with a status of DONE_ATTN - stop reading - we're done
                    status = (UInt16) ((this.inBuff[this.inBytesRead - 7] << 8) +
                             this.inBuff[this.inBytesRead - 8]);
                }

                // DONE_ATTN == 0x20
                if (status == TdsEnums.DONE_ATTN) {
                    foundATN = true;
                }
            }

            return foundATN;
        }

        //
        // Sends an attention signal - executing thread will consume attn
        //
        internal void SendAttention() {
            if (!this.attentionSent) {
                this.attentionSent = true;
                this.msgType = TdsEnums.MT_ATTN;
                // send the attention now
                FlushBufferOOB();
            }
        }

        // Dumps contents of buffer to OOB write (currently only used for attentions.  There is no body for this message
        // Doesn't touch this.outBytesUsed
        private void FlushBufferOOB() {
            Debug.Assert(this.state == TdsParserState.OpenNotLoggedIn ||
                         this.state == TdsParserState.OpenLoggedIn,
                         "Cannot flush bufferOOB when connection is closed!");

            // Assert before Flush
            Debug.Assert(this.msgType == TdsEnums.MT_ATTN, "FlushBufferOOB() called for a non-attention message!");

            IntPtr errno = IntPtr.Zero;

            if (this.state == TdsParserState.Closed ||
                this.state == TdsParserState.Broken)
                return;

            int bytesWritten;
            this.outBuff[0] = (Byte) this.msgType;               // Message Type
            this.outBuff[1] = (Byte) TdsEnums.ST_EOM;           // Status
            this.outBuff[2] = (Byte) (TdsEnums.HEADER_LEN / 256);     // length
            this.outBuff[3] = (Byte) TdsEnums.HEADER_LEN;
            this.outBuff[4] = 0;    // channel
            this.outBuff[5] = 0;
            this.outBuff[6] = 0;    // packet
            this.outBuff[7] = 0;    // window

            bytesWritten = (int) UnsafeNativeMethods.Dbnetlib.ConnectionWriteOOB(this.pConObj, this.outBuff, (UInt16) TdsEnums.HEADER_LEN, out errno);

            if (bytesWritten != TdsEnums.HEADER_LEN) {
                if (this.exception == null)
                    this.exception = new SqlException();

                this.exception.Errors.Add(ProcessNetlibError(errno));
                ThrowExceptionAndWarning();
            }

            // Assert after Flush
            Debug.Assert(this.msgType == TdsEnums.MT_ATTN, "FlushBufferOOB() called for a non-attention message!");
        }

        //
        // ITdsParser implementation
        //

        internal void TdsLogin(SqlLogin rec) {
            // initialize buffers on login, with user set values
            this.inBuff  = new byte[rec.packetSize];
            // MDAC #89581
            // Login packet can be no larger than 4k!!!  Use 4k for outbuff default until server responds with acceptance of larger
            // packet size that we request in Login packet.
            this.outBuff = new byte[4096];
            this.timeout = rec.timeout;

            // will throw if variable login fields inside rec are > 256 bytes
            ValidateLengths(rec);

            // get the password up front to use in sspi logic below
            EncryptPassword(rec.password);
            //if (AdapterSwitches.SqlTimeout.TraceVerbose)
            //    Debug.WriteLine("TdsLogin, timeout set to:" + Convert.ToString(this.timeout));

            this.timeRemaining = new TimeSpan(0, 0, this.timeout);

            // set the message type
            this.msgType = TdsEnums.MT_LOGIN7;

            // length in bytes
            int length = TdsEnums.LOG_REC_FIXED_LEN;

            string clientInterfaceName = TdsEnums.SQL_PROVIDER_NAME;

            //
            // add up variable-len portions (multiply by 2 for byte len of char strings)
            //
            length += ( rec.hostName.Length   + rec.applicationName.Length   +
                        rec.serverName.Length /*+ rec.remotePassword.Length */    +
                        clientInterfaceName.Length + rec.language.Length +
                        rec.database.Length) * 2;

            // only add lengths of password and username if not using SSPI
            if (!rec.useSSPI)
                length += rec.password.Length + rec.userName.Length;

            try {
                WriteInt(length);
                WriteInt((TdsEnums.SHILOH_MAJOR << 16) | TdsEnums.SHILOH_MINOR_SP1);
                WriteInt(rec.packetSize);
                WriteInt(TdsEnums.CLIENT_PROG_VER);
                WriteInt(Thread.CurrentContext.ContextID);
                WriteInt(0); // connectionID is unused
                WriteByte(TdsEnums.USE_DB_ON << 5 |
                          TdsEnums.INIT_DB_FATAL << 6 |
                          TdsEnums.SET_LANG_ON << 7);
                if (rec.useSSPI)
                    WriteByte(TdsEnums.INIT_LANG_FATAL |
                              TdsEnums.ODBC_ON << 1 |
                              TdsEnums.SSPI_ON << 7);
                else
                    WriteByte(TdsEnums.INIT_LANG_FATAL |
                              TdsEnums.ODBC_ON << 1);
                WriteByte(0); // SqlType is unused
                WriteByte(0); // fSpare1 is reserved
                WriteInt(0);  // ClientTimeZone is not used
                WriteInt(0);  // LCID is unused by server

                // reset length to start writing offset of variable length portions
                length = TdsEnums.LOG_REC_FIXED_LEN;

                // write offset/length pairs

                // note that you must always set ibHostName since it indicaters the beginning of the variable length section of the login record
                WriteShort(length); // host name offset
                WriteShort(rec.hostName.Length);
                length += rec.hostName.Length *2;

                // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login
                // rec, only SSPI is used.  Confirmed same bahavior as in luxor.
                if (rec.useSSPI == false) {
                    WriteShort(length);  // userName offset
                    WriteShort(rec.userName.Length);
                    length += rec.userName.Length *2;

                    // the encrypted password is a byte array - so length computations different than strings
                    WriteShort(length); // password offset
                    WriteShort(rec.password.Length / 2);
                    length += rec.password.Length;
                }
                else {
                    // case where user/password data is not used, send over zeros
                    WriteShort(0);  // userName offset
                    WriteShort(0);
                    WriteShort(0);  // password offset
                    WriteShort(0);
                }

                WriteShort(length); // app name offset
                WriteShort(rec.applicationName.Length);
                length += rec.applicationName.Length *2;

                WriteShort(length); // server name offset
                WriteShort(rec.serverName.Length);
                length += rec.serverName.Length *2;

                WriteShort(length); // remote password name offset
                WriteShort(0);

                WriteShort(length); // client interface name offset
                WriteShort(clientInterfaceName.Length);
                length += clientInterfaceName.Length *2;

                WriteShort(length); // language name offset
                WriteShort(rec.language.Length);
                length += rec.language.Length *2;

                WriteShort(length); // database name offset
                WriteShort(rec.database.Length);
                length += rec.database.Length *2;

                // UNDONE: NIC address
                // previously we declared the array and simply sent it over - byte[] of 0's
                if (null == s_nicAddress)
                    s_nicAddress = GetNIC();

                WriteByteArray(s_nicAddress, s_nicAddress.Length, 0);

                // allocate memory for SSPI variables
                byte[] outSSPIBuff   = null;
                UInt32 outSSPILength = 0;

                if (rec.useSSPI && this.fSendSSPI) {
                    Debug.Assert(this.fSSPIInit == false, "SSPI is inited before calling InitSSPI in login");

                    // set global variable so that we know max length when we receive SSPI token from server
                    // this variable is only set if the library has not been loaded
                    if (!s_fSSPILoaded)
                        LoadSSPILibrary(ref MAXSSPILENGTH);
                    // initialize the sspi session
                    InitSSPISession();

                    // now allocate proper length of buffer, and set length
                    outSSPIBuff   = new byte[MAXSSPILENGTH];
                    outSSPILength = MAXSSPILENGTH;

                    // Call helper function for SSPI data and actual length.
                    // Since we don't have SSPI data from the server, send null for the
                    // byte[] buffer and 0 for the int length.
                    SSPIData(null, 0, outSSPIBuff, ref outSSPILength);

                    WriteShort(length); // SSPI offset
                    WriteShort((int) outSSPILength);
                    length += (int) outSSPILength;
                }
                else {
                    // either not using sspi, or using NP or RPC so send over zeros
                    WriteShort(0); // sspi offset
                    WriteShort(0); // sspi length
                }


                WriteShort(length); // DB filename offset offset
                WriteShort(rec.attachDBFilename.Length);

                // write variable length portion
                WriteString(rec.hostName);

                // if we are using SSPI, do not send over username/password, since we will use SSPI instead
                // same behavior as Luxor
                if (!rec.useSSPI) {
                    WriteString(rec.userName);
                    WriteByteArray(rec.password, rec.password.Length, 0);
                }

                WriteString(rec.applicationName);
                WriteString(rec.serverName);
                // intentially skip, we never use this field
                // WriteString(rec.remotePassword);
                WriteString(clientInterfaceName);
                WriteString(rec.language);
                WriteString(rec.database);

                // send over SSPI data if we are using SSPI and if we aren't using RPC or NP
                if (rec.useSSPI && this.fSendSSPI)
                    WriteByteArray(outSSPIBuff, (int) outSSPILength, 0);

                WriteString(rec.attachDBFilename);

            } // try
            catch {
#if USECRYPTO
                Array.Clear(this.outBuff, 0, this.outBuff.Length);
#endif
                // be sure to wipe out our buffer if we started sending stuff
                ResetBuffer();
                this.packetNumber = 1;  // end of message - reset to 1 - per ramas
                throw;
            }

#if USECRYPTO
            try {
                try {
#endif
                    FlushBuffer(TdsEnums.HARDFLUSH);
#if USECRYPTO
    	        }
    	        finally {
    	            Array.Clear(this.outBuff, 0, this.outBuff.Length);
                }
            }
            catch {
                throw;
            }
#endif
            this.pendingData = true;
        }// tdsLogin

        private void ValidateLengths(SqlLogin rec) {
            // 7.0 and 8.0 servers have a max length of 256 bytes for the variable fields
            // in the login packet.

            int max = TdsEnums.MAX_LOGIN_FIELD / 2;

            Exception e = null;

            if (rec.serverName.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Data_Source);
            if (rec.userName.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.User_ID);
            if (rec.password.Length/2 > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Password);
            if (rec.database.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Initial_Catalog);
            if (rec.language.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Current_Language);
            if (rec.hostName.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Workstation_Id);
            if (rec.applicationName.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.Application_Name);
            if (rec.attachDBFilename.Length > max)
                e = SQL.InvalidOptionLength(SqlConnectionString.KEY.AttachDBFilename);

            if (null != e)
                throw e;
            else
                return;
        }

        private byte[] GetNIC() {
            // NIC address is stored in NetworkAddress key.  However, if NetworkAddressLocal key
            // has a value that is not zero, then we cannot use the NetworkAddress key and must
            // instead generate a random one.  I do not fully understand why, this is simply what
            // the native providers do.  As for generation, I use a random number generator, which 
            // means that different processes on the same machine will have different NIC address
            // values on the server.  It is not ideal, but native does not have the same value for
            // different processes either.

            const string key        = "NetworkAddress";
            const string localKey   = "NetworkAddressLocal";
            const string folder     = "SOFTWARE\\Description\\Microsoft\\Rpc\\UuidTemporaryData";
            
            int result = 0;
            bool generate = false;
            byte[] nicAddress = null;

            try {
                try {
                    object temp = ADP.LocalMachineRegistryValue(folder, localKey);
                    if (temp != null) {
                        result = (int) temp;
                    }
                }
                catch {
                    // Only exception here should be for NetworkAddress not being an
                    // int, eat it if it occurs and continue.
                }
                
                if (result > 0) {
                    generate = true;
                }
                else {
                    object temp = ADP.LocalMachineRegistryValue(folder, key);
                    if (temp != null) {
                        nicAddress = (byte[]) temp;
                    }
                }
            }
            catch (Exception e) { // eat any exception - generate value
                ADP.TraceException(e);
                generate = true;
            }

            if (generate || null == nicAddress) {
                nicAddress = new byte[TdsEnums.MAX_NIC_SIZE];
                Random random = new Random();
                random.NextBytes(nicAddress);
            }

            return nicAddress;
        }

        private void SSPIData(byte[] receivedBuff, UInt32 receivedLength, byte[] sendBuff, ref UInt32 sendLength) {
            Debug.Assert(this.fSSPIInit == true, "TdsParser.SSPIData called without SSPIInit == true");

            IntPtr pServerUserName = IntPtr.Zero;

            try {
                try {
                    bool fDone      = false;
                    pServerUserName = Marshal.AllocHGlobal(TdsEnums.MAX_SERVER_USER_NAME+1);

                    Marshal.WriteByte(pServerUserName, 0);
                    HandleRef handle = new HandleRef(this, pServerUserName);

                    // Proceed with SSPI calls...
                    UnsafeNativeMethods.Dbnetlib.ConnectionGetSvrUser(this.pConObj, handle);

                    if (receivedBuff == null && receivedLength > 0) {
                        // we do not have SSPI data coming from server, so send over 0's for pointer and length
                        if (!UnsafeNativeMethods.Dbnetlib.GenClientContext(this.pConObj, null, 0, sendBuff,
                            ref sendLength, out fDone, handle)) {
                            TermSSPISession();   // terminate session
                            SSPIError(SQLMessage.SSPIGenerateError(), TdsEnums.GEN_CLIENT_CONTEXT);
                        }
                    }
                    else {
                        // we need to respond to the server's message with SSPI data
                        if (!UnsafeNativeMethods.Dbnetlib.GenClientContext(this.pConObj, receivedBuff, receivedLength, sendBuff,
                            ref sendLength, out fDone, handle)) {
                            TermSSPISession();   // terminate session
                            SSPIError(SQLMessage.SSPIGenerateError(), TdsEnums.GEN_CLIENT_CONTEXT);
                        }
                    }
                }
                finally { // FreeHGlobal
                    Marshal.FreeHGlobal(pServerUserName);
                }
            }
            catch { // MDAC 80973, 82448
                throw;
            }
        }

        private void ProcessSSPI(int receivedLength) {
            // allocate received buffer based on length from SSPI message
            byte[] receivedBuff = new byte[receivedLength];
            // read SSPI data received from server
            ReadByteArray(receivedBuff, 0, receivedLength);

            // allocate send buffer and initialize length
            byte[] sendBuff   = new byte[MAXSSPILENGTH];
            UInt32 sendLength = MAXSSPILENGTH;

            // make call for SSPI data
            SSPIData(receivedBuff, (UInt32) receivedLength, sendBuff, ref sendLength);

            // DO NOT SEND LENGTH - TDS DOC INCORRECT!  JUST SEND SSPI DATA!
            WriteByteArray(sendBuff, (int) sendLength, 0);
            // set message type so server knows its a SSPI response
            this.msgType = TdsEnums.MT_SSPI;

            // send to server
            FlushBuffer(TdsEnums.HARDFLUSH);
        }

        private void SSPIError(string error, string procedure) {
            Debug.Assert(this.fSSPIInit == false, "TdsParser.SSPIError called without SSPIInit == false");
            Debug.Assert(!ADP.IsEmpty(procedure), "TdsParser.SSPIError called with an empty or null procedure string");
            Debug.Assert(!ADP.IsEmpty(error), "TdsParser.SSPIError called with an empty or null error string");

            if (this.exception == null)
                this.exception = new SqlException();

            this.exception.Errors.Add(new SqlError(0, (byte) 0x00, (byte) TdsEnums.DEFAULT_ERROR_CLASS,
                                                   error, procedure, 0));
            ThrowExceptionAndWarning();
        }

        public void LoadSSPILibrary(ref UInt32 maxLength)
        {
            try {
                lock(typeof(TdsParser)) {
                    if (!s_fSSPILoaded) {
                        if (!UnsafeNativeMethods.Dbnetlib.InitSSPIPackage(out maxLength))
                            SSPIError(SQLMessage.SSPIInitializeError(), TdsEnums.INIT_SSPI_PACKAGE);

                        s_fSSPILoaded = true;
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        public void InitSSPISession()
        {
            if (!UnsafeNativeMethods.Dbnetlib.InitSession(this.pConObj))
                SSPIError(SQLMessage.SSPIInitializeError(), TdsEnums.INIT_SESSION);

            // SIDE EFFECT - sets global flag
            this.fSSPIInit = true;  // set flag to true so SSPI is terminated upon close of parser
        }

        private void TermSSPISession()
        {
            Debug.Assert(this.fSSPIInit, "TdsParser.TermSSPI called without SSPIInit == true");

            // Do not throw an exception because a TermSession failure is not
            // fatal.  Besides, TermSSPI is called when other SSPI functions fail.

            bool fTermSession = UnsafeNativeMethods.Dbnetlib.TermSession(this.pConObj);

            Debug.Assert(fTermSession, "TdsParser.TermSSPI: Termination of session failed.");

            // SIDE EFFECT - sets global flag
            this.fSSPIInit = false;
        }

        internal byte[] GetDTCAddress(int timeout) {
            // If this fails, the server will return a server error - Sameet Agarwal confirmed.
            // Success: DTCAddress returned.  Failure: SqlError returned.

            byte[] dtcAddr = null;

            // this is a token-less request stream!
            this.msgType = TdsEnums.MT_TRANS;        // set message type
            this.timeout = timeout;
            WriteShort(TdsEnums.TM_GET_DTC_ADDRESS); // write TransactionManager Request type
            WriteShort(0);                           // payload length - always zero for this type
            FlushBuffer(TdsEnums.HARDFLUSH);
            this.pendingData = true;

            SqlDataReader dtcReader = new SqlDataReader(null);
            dtcReader.Bind(this);

            // force consumption of metadata
            _SqlMetaData[] metaData = dtcReader.MetaData;

            if (dtcReader.Read()) {
                Debug.Assert(dtcReader.GetName(0) == "TM Address", "TdsParser: GetDTCAddress did not return 'TM Address'");

                // DTCAddress is of variable size, and does not have a maximum.  So we call GetBytes
                // to get the length of the dtcAddress, then allocate a byte array of that length,
                // then call GetBytes again on that byte[] with the length
                long dtcLength = dtcReader.GetBytes(0, 0, null, 0, 0);
				//
                if (dtcLength <= Int32.MaxValue) {
                	int cb = (int)dtcLength;
                	dtcAddr = new byte[cb];
                	dtcReader.GetBytes(0, 0, dtcAddr, 0, cb);
                }
#if DEBUG
                else {
	                Debug.Assert(false, "unexpected length (> Int32.MaxValue) returned from dtcReader.GetBytes");
	                // if we hit this case we'll just return a null address so that the user
	                // will get a transcaction enlistment error in the upper layers
                }
#endif
           	}

            dtcReader.Close(); // be sure to clean off the wire

            return dtcAddr;
        }

        // Propagate the dtc cookie to the server, enlisting the connection.  We pass in
        // the length because the buffer size is not always guaranteed to be equal to the
        // length of the actual transaction cookie.
        internal void PropagateDistributedTransaction(byte[] buffer, int length, int timeout) {
            // if this fails, the server will return a server error - Sameet Agarwal confirmed
            // Success: server will return done token.  Failure: SqlError returned.

            this.msgType = TdsEnums.MT_TRANS;       // set message type
            this.timeout = timeout;
            WriteShort(TdsEnums.TM_PROPAGATE_XACT); // write TransactionManager Request type
            WriteShort(length);                     // write payload length
            if (null != buffer)
                WriteByteArray(buffer, length, 0);      // write payload
            FlushBuffer(TdsEnums.HARDFLUSH);

            // UNDONE - may have to rethink this for async!
            // call run with run until done - consuming done tokens

            Run(RunBehavior.UntilDone, null, null);
        }

        internal void TdsExecuteSQLBatch(string text, int timeout) {
            this.timeRemaining = new TimeSpan(0, 0, timeout);

            this.msgType = TdsEnums.MT_SQL;
            this.timeout = timeout;
            try {
                WriteString(text);
            }
            catch {
                Debug.Assert(this.state == TdsParserState.Broken, "Caught exception in TdsExecuteSqlBatch but connection was not broken!");

                // be sure to wipe out our buffer if we started sending stuff
                ResetBuffer();
                this.packetNumber = 1;  // end of message - reset to 1 - per ramas
                throw;
            }

            FlushBuffer(TdsEnums.HARDFLUSH);
            this.pendingData = true;
        }

        internal void TdsExecuteRPC(_SqlRPC rec, int timeout, bool inSchema) {
            //if (AdapterSwitches.SqlTimeout.TraceVerbose)
            //    Debug.WriteLine("TdsExecuteRPC, timeout set to:" + Convert.ToString(timeout));

            this.timeRemaining = new TimeSpan(0, 0, timeout);

            this.timeout = timeout;
            this.msgType = TdsEnums.MT_RPC;

            Debug.Assert( (rec.rpcName != null) && (rec.rpcName.Length > 0), "must have an RPC name");

            WriteShort(rec.rpcName.Length);
            WriteString(rec.rpcName);

            // Options
            WriteShort( (short)rec.options);

            // Stream out parameters
            SqlParameter[] parameters = rec.parameters;

            try {
                for (int i = 0; i < parameters.Length; i++) {
                    //                Debug.WriteLine("i:  " + i.ToString());
                    // parameters can be unnamed
                    SqlParameter param = parameters[i];

                    // Validate parameters are not variable length without size and with null value.  MDAC 66522
                    param.Validate();

                    SqlDbType type = param.SqlDbType;

                    // if we have an output param, set the value to null so we do not send it across to the server
                    if (param.Direction == ParameterDirection.Output ) {
                        param.Value = null;
                    }

                    // Check for empty or null value before we write out meta info about the actual data (size, scale, etc)
                    bool isNull = false;
                    bool isSqlVal = false;

                    if (null == param.Value || Convert.IsDBNull(param.Value))
                        isNull = true;

                    if (param.Value is INullable) {
                        isSqlVal = true;
                        if (((INullable)param.Value).IsNull)
                            isNull = true;
                    }

                    // paramLen
                    // paramName
                    if (param.ParameterName != null &&
                        param.ParameterName.Length > 0) {
                        Debug.Assert(param.ParameterName.Length <= 0xff, "parameter name can only be 255 bytes, shouldn't get to TdsParser!");
                        WriteByte((byte) (param.ParameterName.Length & 0xff));
                        WriteString(param.ParameterName);
                    }
                    else
                        WriteByte(0);

                    // status
                    byte status = 0;
                    // data value
                    object value = param.Value;

                    // set output bit
                    if (param.Direction == ParameterDirection.InputOutput ||
                        param.Direction == ParameterDirection.Output)
                        status = 0x1;

                    // set default value bit
                    if (param.Direction != ParameterDirection.Output ) {
                        // remember that null == Convert.IsEmpty, DBNull.Value is a database null!

                        // MDAC 62117, don't assume a default value exists for parameters in the case when
                        // the user is simply requesting schema
                        if (null == value && !inSchema) {
                            status |= 0x2;
                        }
                    }

                    WriteByte(status);

                    // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)

                    //
                    // fixup the types by using the NullableType property of the MetaType class
                    //
                    // following rules should be followed based on feedback from the M-SQL team
                    // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)
                    // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)
                    // 3) DECIMALN should always be sent as NUMERICN
                    //
                    MetaType mt = param.GetMetaType();
                    WriteByte(mt.NullableType);

                    // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns
                    if (mt.TDSType == TdsEnums.SQLVARIANT) {
                        WriteSqlVariantValue(value, param.ActualSize, param.Offset);
                        continue;
                    }

                    // if it's not a sql_variant, make sure the parameter value is of the expecte type
                    if (!isNull) {
                        value = param.CoercedValue;
                    }

                    // MaxLen field is only written out for non-fixed length data types
                    // use the greater of the two sizes for maxLen

                    int size = (MetaType.IsSizeInCharacters(param.SqlDbType)) ? param.Size * 2 : param.Size;
                    // getting the actualSize is expensive, cache here and use below
                    int actualSize = param.ActualSize;

                    int codePageByteSize = 0;

                    if (MetaType.IsAnsiType(param.SqlDbType)) {
                        if (!isNull) {
                            string s = (isSqlVal ? ((SqlString)value).Value : (string) value);
                            codePageByteSize = GetEncodingCharLength(s, actualSize, param.Offset, this.defaultEncoding);
                        }
                        WriteParameterVarLen(mt, (size > codePageByteSize) ? size : codePageByteSize, false/*IsNull*/);
                    }
                    else {
                        // If type timestamp - treat as fixed type and always send over timestamp length, which is 8.
                        // For fixed types, we either send null or fixed length for type length.  We want to match that
                        // behavior for timestamps.  However, in the case of null, we still must send 8 because if we
                        // send null we will not receive a output val.  You can send null for fixed types and still
                        // receive a output value, but not for variable types.  So, always send 8 for timestamp because
                        // while the user sees it as a fixed type, we are actually representing it as a bigbinary which
                        // is variable.
                        if (param.SqlDbType == SqlDbType.Timestamp) {
                            WriteParameterVarLen(mt, TdsEnums.TEXT_TIME_STAMP_LEN, false);
                        }
                        else {
                            WriteParameterVarLen(mt, (size > actualSize) ? size : actualSize, false/*IsNull*/);
                        }
                    }

                    // scale and precision are only relevant for numeric and decimal types
                    if (type == SqlDbType.Decimal) {
                        // bug 49512, make sure the value matches the scale the user enters
                        if (!isNull) {
                            if (isSqlVal) {
                                value = AdjustSqlDecimalScale((SqlDecimal)value, param.Scale);

                                // If Precision is specified, verify value precision vs param precision
                                if (param.Precision != 0) {
                                    if (param.Precision < ((SqlDecimal) value).Precision) {
                                        throw SQL.ParameterValueOutOfRange(value.ToString());
                                    }
                                }
                            }
                            else {
                                value = AdjustDecimalScale((Decimal)value, param.Scale);

                                SqlDecimal sqlValue = new SqlDecimal ((Decimal) value);

                                // If Precision is specified, verify value precision vs param precision
                                if (param.Precision != 0) {
                                    if (param.Precision < sqlValue.Precision) {
                                        throw SQL.ParameterValueOutOfRange(value.ToString());
                                    }
                                }
                            }
                        }

                        if (0 == param.Precision)
                            WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);
                        else
                            WriteByte(param.Precision);

                        WriteByte(param.Scale);
                    }

                    // write out collation
                    if (this.isShiloh && MetaType.IsCharType(type)) {
                        // if it is not supplied, simply write out our default collation, otherwise, write out the one attached to the parameter
                        SqlCollation outCollation = (param.Collation != null) ? param.Collation : defaultCollation;
                        Debug.Assert(defaultCollation != null, "defaultCollation is null!");
                        WriteUnsignedInt(outCollation.info);
                        WriteByte(outCollation.sortId);
                    }

                    if (0 == codePageByteSize)
                        WriteParameterVarLen(mt, actualSize, isNull);
                    else
                        WriteParameterVarLen(mt, codePageByteSize, isNull);

                    // write the value now
                    if (!isNull) {
                        if (isSqlVal) {
                            WriteSqlValue(value, mt, actualSize, param.Offset);
                        }
                        else {
                            // for codePageEncoded types, WriteValue simply expects the number of characters
                            WriteValue(value, mt, actualSize, param.Offset);
                        }
                    }
                } // for
            } // catch
            catch {
                int oldPacketNumber = this.packetNumber;
            
                // be sure to wipe out our buffer if we started sending stuff
                ResetBuffer();
                this.packetNumber = 1;  // end of message - reset to 1 - per ramas

                if (oldPacketNumber != 1 && this.state == TdsParserState.OpenLoggedIn) {
                    // If packetNumber prior to ResetBuffer was not equal to 1, a packet was already
                    // sent to the server and so we need to send an attention and process the attention ack.
                    SendAttention();
                    ProcessAttention();
                }
                
                throw;
            }

            FlushBuffer(TdsEnums.HARDFLUSH);
            pendingData = true;
        }

        internal void WriteSqlValue(object value, MetaType type, int actualLength, int offset) {
            Debug.Assert(value is INullable &&
                       (!((INullable)value).IsNull), "unexpected null SqlType!");

            // parameters are always sent over as BIG or N types
            switch (type.NullableType) {
                case TdsEnums.SQLFLTN:
                    if (type.FixedLength == 4)
                        WriteFloat(((SqlSingle)value).Value);
                    else {
                        Debug.Assert(type.FixedLength == 8, "Invalid length for SqlDouble type!");
                        WriteDouble(((SqlDouble)value).Value);
                    }
                    break;
                case TdsEnums.SQLBIGBINARY:
                case TdsEnums.SQLBIGVARBINARY:
                case TdsEnums.SQLIMAGE:
                    {
                        WriteByteArray( ((SqlBinary)value).Value, actualLength, offset);
                        break;
                    }
                case TdsEnums.SQLUNIQUEID:
                    {
                        byte[] b = ((SqlGuid)value).ToByteArray();
                        Debug.Assert( (actualLength == b.Length) && (actualLength == 16), "Invalid length for guid type in com+ object");
                        WriteByteArray(b, actualLength, 0);
                        break;
                    }
                case TdsEnums.SQLBITN:
                    {
                        Debug.Assert(type.FixedLength == 1, "Invalid length for SqlBoolean type");
                        if ( ((SqlBoolean)value).Value == true)
                            WriteByte(1);
                        else
                            WriteByte(0);
                        break;
                    }
                case TdsEnums.SQLINTN:
                    if (type.FixedLength == 1)
                        WriteByte(((SqlByte)value).Value);
                    else
                    if (type.FixedLength == 2)
                        WriteShort(((SqlInt16)value).Value);
                    else
                        if (type.FixedLength == 4)
                        WriteInt(((SqlInt32)value).Value);
                    else {
                        Debug.Assert(type.FixedLength == 8, "invalid length for SqlIntN type:  " + type.FixedLength.ToString());
                        WriteLong(((SqlInt64)value).Value);
                    }
                    break;
                case TdsEnums.SQLBIGCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                case TdsEnums.SQLTEXT:
                    WriteEncodingChar(((SqlString)value).Value, actualLength, offset, this.defaultEncoding);
                    break;
                case TdsEnums.SQLNCHAR:
                case TdsEnums.SQLNVARCHAR:
                case TdsEnums.SQLNTEXT:
                    // convert to cchars instead of cbytes
                    if (actualLength != 0)
                        actualLength >>=1;
                    WriteString(((SqlString)value).Value, actualLength, offset);
                    break;
                case TdsEnums.SQLNUMERICN:
                    Debug.Assert(type.FixedLength <= 17, "Decimal length cannot be greater than 17 bytes");
                    WriteSqlDecimal((SqlDecimal)value);
                    break;
                case TdsEnums.SQLDATETIMN:
                    SqlDateTime dt = (SqlDateTime)value;
                    if (type.FixedLength == 4) {
                        if (0 > dt.DayTicks || dt.DayTicks > UInt16.MaxValue)
                            throw SQL.SmallDateTimeOverflow(dt.ToString());
                        WriteShort(dt.DayTicks);
                        WriteShort(dt.TimeTicks/SqlDateTime.SQLTicksPerMinute);
                    }
                    else {
                        WriteInt(dt.DayTicks);
                        WriteInt(dt.TimeTicks);
                    }
                    break;
                case TdsEnums.SQLMONEYN:
                    {
                        WriteSqlMoney((SqlMoney)value, type.FixedLength);
                        break;
                    }
                default:
                    Debug.Assert(false, "Unknown TdsType!" + type.NullableType.ToString("x2"));
                    break;
            } // switch

//           Debug.WriteLine("value:  " + value.ToString());
        }

        internal void WriteValue(object value, MetaType type, int actualLength, int offset) {
            Debug.Assert((value != null) && (!Convert.IsDBNull(value)) /*&& (!Convert.IsMissing(value))*/, "unexpected missing or empty object");

            // parameters are always sent over as BIG or N types
            switch (type.NullableType) {
                case TdsEnums.SQLFLTN:
                    if (type.FixedLength == 4)
                        WriteFloat((Single)value);
                    else {
                        Debug.Assert(type.FixedLength == 8, "Invalid length for SqlDouble type!");
                        WriteDouble((Double)value);
                    }
                    break;
                case TdsEnums.SQLBIGBINARY:
                case TdsEnums.SQLBIGVARBINARY:
                case TdsEnums.SQLIMAGE:
                    {
                        // An array should be in the object
                        Debug.Assert(value.GetType() == typeof(byte[]), "Value should be an array of bytes");
                        Byte[] b = (byte[]) value;
                        WriteByteArray(b, actualLength, offset);
                        break;
                    }
                case TdsEnums.SQLUNIQUEID:
                    {
                        System.Guid guid = (System.Guid) value;
                        byte[] b = guid.ToByteArray();
                        Debug.Assert( (actualLength == b.Length) && (actualLength == 16), "Invalid length for guid type in com+ object");
                        WriteByteArray(b, actualLength, 0);
                        break;
                    }
                case TdsEnums.SQLBITN:
                    {
                        Debug.Assert(type.FixedLength == 1, "Invalid length for SqlBoolean type");

                        if ((bool)value == true)
                            WriteByte(1);
                        else
                            WriteByte(0);
                        break;
                    }
                case TdsEnums.SQLINTN:
                    if (type.FixedLength == 1)
                        WriteByte((byte)value);
                    else
                        if (type.FixedLength == 2)
                        WriteShort((Int16)value);
                    else
                        if (type.FixedLength == 4)
                        WriteInt((Int32)value);
                    else {
                        Debug.Assert(type.FixedLength == 8, "invalid length for SqlIntN type:  " + type.FixedLength.ToString());
                        WriteLong((Int64)value);
                    }
                    break;
                case TdsEnums.SQLBIGCHAR:
                case TdsEnums.SQLBIGVARCHAR:
                case TdsEnums.SQLTEXT:
                    WriteEncodingChar((string)value, actualLength, offset, this.defaultEncoding);
                    break;
                case TdsEnums.SQLNCHAR:
                case TdsEnums.SQLNVARCHAR:
                case TdsEnums.SQLNTEXT:
                    // convert to cchars instead of cbytes
                    if (actualLength != 0)
                        actualLength >>=1;
                    WriteString((string)value, actualLength, offset);
                    break;
                case TdsEnums.SQLNUMERICN:
                    Debug.Assert(type.FixedLength <= 17, "Decimal length cannot be greater than 17 bytes");
                    WriteDecimal((Decimal)value);
                    break;
                case TdsEnums.SQLDATETIMN:
                    Debug.Assert(type.FixedLength <= 0xff, "Invalid Fixed Length");
                    TdsDateTime dt = MetaDateTime.FromDateTime((DateTime)value, (byte) type.FixedLength);
                    if (type.FixedLength == 4) {
                        if (0 > dt.days || dt.days > UInt16.MaxValue)
                            throw SQL.SmallDateTimeOverflow(MetaDateTime.ToDateTime(dt.days, dt.time, 4).ToString());
                        WriteShort(dt.days);
                        WriteShort(dt.time);
                    }
                    else {
                        WriteInt(dt.days);
                        WriteInt(dt.time);
                    }
                    break;
                case TdsEnums.SQLMONEYN:
                    {
                        WriteCurrency((Decimal)value, type.FixedLength);
                        break;
                    }
                default:
                    Debug.Assert(false, "Unknown TdsType!" + type.NullableType.ToString("x2"));
                    break;
            } // switch

//           Debug.WriteLine("value:  " + value.ToString());
        }

        //
        // we always send over nullable types for parameters so we always write the varlen fields
        //

        internal void WriteParameterVarLen(MetaType type, int size, bool isNull) {
            if (type.IsLong) { // text/image/SQLVariant have a 4 byte length
                if (isNull) {
                    WriteInt(unchecked((int)TdsEnums.VARLONGNULL));
                }
                else {
                    WriteInt(size);
                }
            }
            else if (false == type.IsFixed) { // non-long but variable length column, must be a BIG* type: 2 byte length
                if (isNull) {
                    WriteShort(TdsEnums.VARNULL);
                }
                else {
                    WriteShort(size);
                }
            }
            else {
                if (isNull) {
                    WriteByte(TdsEnums.FIXEDNULL);
                }
                else {
                    Debug.Assert(type.FixedLength <= 0xff, "WriteParameterVarLen: invalid one byte length!");
                    WriteByte((byte) (type.FixedLength & 0xff)); // 1 byte for everything else
                }
            }
        }

        internal void EncryptPassword(byte[] password) {
            for (int i = 0; i < password.Length; i ++) {
                byte temp = password[i];
                password[i] = (byte) ( (((temp & 0x0f) << 4) | (temp >> 4)) ^ 0xa5);
            }
        }

/*
        internal Byte[] EncryptPassword(string password) {
            Byte[] bEnc = new Byte[password.Length << 1];
            int s;
            byte bLo;
            byte bHi;

            for (int i = 0; i < password.Length; i ++) {
                s = (int) password[i];
                bLo = (byte) (s & 0xff);
                bHi = (byte) ((s >> 8) & 0xff);
                bEnc[i<<1] = (Byte) ( (((bLo & 0x0f) << 4) | (bLo >> 4)) ^  0xa5 );
                bEnc[(i<<1)+1] = (Byte) ( (((bHi & 0x0f) << 4) | (bHi >> 4)) ^  0xa5);
            }
            return bEnc;
        }
*/

        internal SqlCommand PendingCommand {
            get {
                if (null != this.pendingCommandWeakRef) {
                    SqlCommand com = (SqlCommand) this.pendingCommandWeakRef.Target;
                    if (this.pendingCommandWeakRef.IsAlive) {
                        return com;
                    }
                }

                return null;
            }
        }

        internal bool PendingData {
            get { return this.pendingData;}
        }
#if OBJECT_BINDING
        internal ReadBehavior ReadBehavior {
            get { return this.readBehavior;}
            set { this.readBehavior = value;}
        }
#endif

#if ISOLATE_NETWORK
        private object[] _rgbTds = new object[] {
            new byte[] {0x04, 0x01, 0x01, 0x8c, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x17, 0x00, 0x01, 0x04, 0x70, 0x00,
                0x75, 0x00, 0x62, 0x00, 0x73, 0x00, 0x06, 0x6d, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
                0x65, 0x00, 0x72, 0x00, 0xab, 0x5c, 0x00, 0x45, 0x16, 0x00, 0x00, 0x02, 0x00, 0x23, 0x00, 0x43,
                0x00, 0x68, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x64,
                0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00, 0x62, 0x00, 0x61, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20,
                0x00, 0x63, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20,
                0x00, 0x74, 0x00, 0x6f, 0x00, 0x20, 0x00, 0x27, 0x00, 0x70, 0x00, 0x75, 0x00, 0x62, 0x00, 0x73,
                0x00, 0x27, 0x00, 0x2e, 0x00, 0x05, 0x44, 0x00, 0x41, 0x00, 0x58, 0x00, 0x48, 0x00, 0x31, 0x00,
                0x00, 0x00, 0x00, 0xe3, 0x17, 0x00, 0x02, 0x0a, 0x75, 0x00, 0x73, 0x00, 0x5f, 0x00, 0x65, 0x00,
                0x6e, 0x00, 0x67, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x73, 0x00, 0x68, 0x00, 0x00, 0xab, 0x64, 0x00,
                0x47, 0x16, 0x00, 0x00, 0x01, 0x00, 0x27, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6e, 0x00,
                0x67, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x67, 0x00,
                0x75, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x73, 0x00, 0x65, 0x00, 0x74, 0x00,
                0x74, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x20, 0x00,
                0x75, 0x00, 0x73, 0x00, 0x5f, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x6c, 0x00, 0x69, 0x00,
                0x73, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x05, 0x44, 0x00, 0x41, 0x00, 0x58, 0x00, 0x48, 0x00, 0x31,
                0x00, 0x00, 0x00, 0x00, 0xe3, 0x0f, 0x00, 0x03, 0x05, 0x69, 0x00, 0x73, 0x00, 0x6f, 0x00, 0x5f,
                0x00, 0x31, 0x00, 0x01, 0x00, 0x00, 0xe3, 0x0b, 0x00, 0x05, 0x04, 0x31, 0x00, 0x30, 0x00, 0x33,
                0x00, 0x33, 0x00, 0x00, 0xe3, 0x0f, 0x00, 0x06, 0x06, 0x31, 0x00, 0x39, 0x00, 0x36, 0x00, 0x36,
                0x00, 0x30, 0x00, 0x39, 0x00, 0x00, 0xad, 0x36, 0x00, 0x01, 0x07, 0x00, 0x00, 0x00, 0x16, 0x4d,
                0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x6f, 0x00, 0x66, 0x00, 0x74,
                0x00, 0x20, 0x00, 0x53, 0x00, 0x51, 0x00, 0x4c, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72,
                0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x02, 0x6f, 0xe3,
                0x13, 0x00, 0x04, 0x04, 0x38, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00, 0x04, 0x34, 0x00, 0x30,
                0x00, 0x39, 0x00, 0x36, 0x00, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            },
            new byte []{0x04, 0x01, 0x04, 0x42, 0x00, 0x00, 0x00, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00,
                0xa7, 0x28, 0x00, 0x08, 0x61, 0x00, 0x75, 0x00, 0x5f, 0x00, 0x6c, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x6d, 0x00,
                0x65, 0x00, 0x00, 0x00, 0x08, 0x00, 0xa7, 0x14, 0x00, 0x08, 0x61, 0x00, 0x75, 0x00, 0x5f, 0x00,
                0x66, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x01, 0x01, 0x08, 0x00, 0xa7, 0x0b,
                0x00, 0x05, 0x61, 0x00, 0x75, 0x00, 0x5f, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00, 0x09, 0x00,
                0xa7, 0x14, 0x00, 0x04, 0x63, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0xd1, 0x05, 0x00, 0x57,
                0x68, 0x69, 0x74, 0x65, 0x07, 0x00, 0x4a, 0x6f, 0x68, 0x6e, 0x73, 0x6f, 0x6e, 0x0b, 0x00, 0x31,
                0x37, 0x32, 0x2d, 0x33, 0x32, 0x2d, 0x31, 0x31, 0x37, 0x36, 0x0a, 0x00, 0x4d, 0x65, 0x6e, 0x6c,
                0x6f, 0x20, 0x50, 0x61, 0x72, 0x6b, 0xd1, 0x05, 0x00, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x08, 0x00,
                0x4d, 0x61, 0x72, 0x6a, 0x6f, 0x72, 0x69, 0x65, 0x0b, 0x00, 0x32, 0x31, 0x33, 0x2d, 0x34, 0x36,
                0x2d, 0x38, 0x39, 0x31, 0x35, 0x07, 0x00, 0x4f, 0x61, 0x6b, 0x6c, 0x61, 0x6e, 0x64, 0xd1, 0x06,
                0x00, 0x43, 0x61, 0x72, 0x73, 0x6f, 0x6e, 0x06, 0x00, 0x43, 0x68, 0x65, 0x72, 0x79, 0x6c, 0x0b,
                0x00, 0x32, 0x33, 0x38, 0x2d, 0x39, 0x35, 0x2d, 0x37, 0x37, 0x36, 0x36, 0x08, 0x00, 0x42, 0x65,
                0x72, 0x6b, 0x65, 0x6c, 0x65, 0x79, 0xd1, 0x07, 0x00, 0x4f, 0x27, 0x4c, 0x65, 0x61, 0x72, 0x79,
                0x07, 0x00, 0x4d, 0x69, 0x63, 0x68, 0x61, 0x65, 0x6c, 0x0b, 0x00, 0x32, 0x36, 0x37, 0x2d, 0x34,
                0x31, 0x2d, 0x32, 0x33, 0x39, 0x34, 0x08, 0x00, 0x53, 0x61, 0x6e, 0x20, 0x4a, 0x6f, 0x73, 0x65,
                0xd1, 0x08, 0x00, 0x53, 0x74, 0x72, 0x61, 0x69, 0x67, 0x68, 0x74, 0x04, 0x00, 0x44, 0x65, 0x61,
                0x6e, 0x0b, 0x00, 0x32, 0x37, 0x34, 0x2d, 0x38, 0x30, 0x2d, 0x39, 0x33, 0x39, 0x31, 0x07, 0x00,
                0x4f, 0x61, 0x6b, 0x6c, 0x61, 0x6e, 0x64, 0xd1, 0x05, 0x00, 0x53, 0x6d, 0x69, 0x74, 0x68, 0x07,
                0x00, 0x4d, 0x65, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x0b, 0x00, 0x33, 0x34, 0x31, 0x2d, 0x32, 0x32,
                0x2d, 0x31, 0x37, 0x38, 0x32, 0x08, 0x00, 0x4c, 0x61, 0x77, 0x72, 0x65, 0x6e, 0x63, 0x65, 0xd1,
                0x06, 0x00, 0x42, 0x65, 0x6e, 0x6e, 0x65, 0x74, 0x07, 0x00, 0x41, 0x62, 0x72, 0x61, 0x68, 0x61,
                0x6d, 0x0b, 0x00, 0x34, 0x30, 0x39, 0x2d, 0x35, 0x36, 0x2d, 0x37, 0x30, 0x30, 0x38, 0x08, 0x00,
                0x42, 0x65, 0x72, 0x6b, 0x65, 0x6c, 0x65, 0x79, 0xd1, 0x04, 0x00, 0x44, 0x75, 0x6c, 0x6c, 0x03,
                0x00, 0x41, 0x6e, 0x6e, 0x0b, 0x00, 0x34, 0x32, 0x37, 0x2d, 0x31, 0x37, 0x2d, 0x32, 0x33, 0x31,
                0x39, 0x09, 0x00, 0x50, 0x61, 0x6c, 0x6f, 0x20, 0x41, 0x6c, 0x74, 0x6f, 0xd1, 0x0a, 0x00, 0x47,
                0x72, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x73, 0x62, 0x79, 0x04, 0x00, 0x42, 0x75, 0x72, 0x74, 0x0b,
                0x00, 0x34, 0x37, 0x32, 0x2d, 0x32, 0x37, 0x2d, 0x32, 0x33, 0x34, 0x39, 0x06, 0x00, 0x43, 0x6f,
                0x76, 0x65, 0x6c, 0x6f, 0xd1, 0x08, 0x00, 0x4c, 0x6f, 0x63, 0x6b, 0x73, 0x6c, 0x65, 0x79, 0x08,
                0x00, 0x43, 0x68, 0x61, 0x72, 0x6c, 0x65, 0x6e, 0x65, 0x0b, 0x00, 0x34, 0x38, 0x36, 0x2d, 0x32,
                0x39, 0x2d, 0x31, 0x37, 0x38, 0x36, 0x0d, 0x00, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e,
                0x63, 0x69, 0x73, 0x63, 0x6f, 0xd1, 0x06, 0x00, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x65, 0x0b, 0x00,
                0x4d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x74, 0x61, 0x72, 0x0b, 0x00, 0x35, 0x32, 0x37,
                0x2d, 0x37, 0x32, 0x2d, 0x33, 0x32, 0x34, 0x36, 0x09, 0x00, 0x4e, 0x61, 0x73, 0x68, 0x76, 0x69,
                0x6c, 0x6c, 0x65, 0xd1, 0x0e, 0x00, 0x42, 0x6c, 0x6f, 0x74, 0x63, 0x68, 0x65, 0x74, 0x2d, 0x48,
                0x61, 0x6c, 0x6c, 0x73, 0x08, 0x00, 0x52, 0x65, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x64, 0x0b, 0x00,
                0x36, 0x34, 0x38, 0x2d, 0x39, 0x32, 0x2d, 0x31, 0x38, 0x37, 0x32, 0x09, 0x00, 0x43, 0x6f, 0x72,
                0x76, 0x61, 0x6c, 0x6c, 0x69, 0x73, 0xd1, 0x08, 0x00, 0x59, 0x6f, 0x6b, 0x6f, 0x6d, 0x6f, 0x74,
                0x6f, 0x05, 0x00, 0x41, 0x6b, 0x69, 0x6b, 0x6f, 0x0b, 0x00, 0x36, 0x37, 0x32, 0x2d, 0x37, 0x31,
                0x2d, 0x33, 0x32, 0x34, 0x39, 0x0c, 0x00, 0x57, 0x61, 0x6c, 0x6e, 0x75, 0x74, 0x20, 0x43, 0x72,
                0x65, 0x65, 0x6b, 0xd1, 0x0c, 0x00, 0x64, 0x65, 0x6c, 0x20, 0x43, 0x61, 0x73, 0x74, 0x69, 0x6c,
                0x6c, 0x6f, 0x05, 0x00, 0x49, 0x6e, 0x6e, 0x65, 0x73, 0x0b, 0x00, 0x37, 0x31, 0x32, 0x2d, 0x34,
                0x35, 0x2d, 0x31, 0x38, 0x36, 0x37, 0x09, 0x00, 0x41, 0x6e, 0x6e, 0x20, 0x41, 0x72, 0x62, 0x6f,
                0x72, 0xd1, 0x08, 0x00, 0x44, 0x65, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x65, 0x06, 0x00, 0x4d, 0x69,
                0x63, 0x68, 0x65, 0x6c, 0x0b, 0x00, 0x37, 0x32, 0x32, 0x2d, 0x35, 0x31, 0x2d, 0x35, 0x34, 0x35,
                0x34, 0x04, 0x00, 0x47, 0x61, 0x72, 0x79, 0xd1, 0x08, 0x00, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
                0x65, 0x72, 0x04, 0x00, 0x44, 0x69, 0x72, 0x6b, 0x0b, 0x00, 0x37, 0x32, 0x34, 0x2d, 0x30, 0x38,
                0x2d, 0x39, 0x39, 0x33, 0x31, 0x07, 0x00, 0x4f, 0x61, 0x6b, 0x6c, 0x61, 0x6e, 0x64, 0xd1, 0x0a,
                0x00, 0x4d, 0x61, 0x63, 0x46, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x07, 0x00, 0x53, 0x74, 0x65,
                0x61, 0x72, 0x6e, 0x73, 0x0b, 0x00, 0x37, 0x32, 0x34, 0x2d, 0x38, 0x30, 0x2d, 0x39, 0x33, 0x39,
                0x31, 0x07, 0x00, 0x4f, 0x61, 0x6b, 0x6c, 0x61, 0x6e, 0x64, 0xd1, 0x06, 0x00, 0x4b, 0x61, 0x72,
                0x73, 0x65, 0x6e, 0x05, 0x00, 0x4c, 0x69, 0x76, 0x69, 0x61, 0x0b, 0x00, 0x37, 0x35, 0x36, 0x2d,
                0x33, 0x30, 0x2d, 0x37, 0x33, 0x39, 0x31, 0x07, 0x00, 0x4f, 0x61, 0x6b, 0x6c, 0x61, 0x6e, 0x64,
                0xd1, 0x08, 0x00, 0x50, 0x61, 0x6e, 0x74, 0x65, 0x6c, 0x65, 0x79, 0x06, 0x00, 0x53, 0x79, 0x6c,
                0x76, 0x69, 0x61, 0x0b, 0x00, 0x38, 0x30, 0x37, 0x2d, 0x39, 0x31, 0x2d, 0x36, 0x36, 0x35, 0x34,
                0x09, 0x00, 0x52, 0x6f, 0x63, 0x6b, 0x76, 0x69, 0x6c, 0x6c, 0x65, 0xd1, 0x06, 0x00, 0x48, 0x75,
                0x6e, 0x74, 0x65, 0x72, 0x06, 0x00, 0x53, 0x68, 0x65, 0x72, 0x79, 0x6c, 0x0b, 0x00, 0x38, 0x34,
                0x36, 0x2d, 0x39, 0x32, 0x2d, 0x37, 0x31, 0x38, 0x36, 0x09, 0x00, 0x50, 0x61, 0x6c, 0x6f, 0x20,
                0x41, 0x6c, 0x74, 0x6f, 0xd1, 0x08, 0x00, 0x4d, 0x63, 0x42, 0x61, 0x64, 0x64, 0x65, 0x6e, 0x07,
                0x00, 0x48, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x0b, 0x00, 0x38, 0x39, 0x33, 0x2d, 0x37, 0x32,
                0x2d, 0x31, 0x31, 0x35, 0x38, 0x09, 0x00, 0x56, 0x61, 0x63, 0x61, 0x76, 0x69, 0x6c, 0x6c, 0x65,
                0xd1, 0x06, 0x00, 0x52, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x04, 0x00, 0x41, 0x6e, 0x6e, 0x65, 0x0b,
                0x00, 0x38, 0x39, 0x39, 0x2d, 0x34, 0x36, 0x2d, 0x32, 0x30, 0x33, 0x35, 0x0e, 0x00, 0x53, 0x61,
                0x6c, 0x74, 0x20, 0x4c, 0x61, 0x6b, 0x65, 0x20, 0x43, 0x69, 0x74, 0x79, 0xd1, 0x06, 0x00, 0x52,
                0x69, 0x6e, 0x67, 0x65, 0x72, 0x06, 0x00, 0x41, 0x6c, 0x62, 0x65, 0x72, 0x74, 0x0b, 0x00, 0x39,
                0x39, 0x38, 0x2d, 0x37, 0x32, 0x2d, 0x33, 0x35, 0x36, 0x37, 0x0e, 0x00, 0x53, 0x61, 0x6c, 0x74,
                0x20, 0x4c, 0x61, 0x6b, 0x65, 0x20, 0x43, 0x69, 0x74, 0x79, 0xff, 0x11, 0x00, 0xc1, 0x00, 0x17,
                0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xe0, 0x00, 0x17, 0x00, 0x00,
                0x00
             }
        };
#endif // ISOLATE_NETWORK
    }// tdsparser
}//namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlint16.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLInt16.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlInt16.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlInt16 which is equivalent to 
//            data type "smallint" in SQL Server
//
// Notes: 
//    
// History:
//
//   11/1/99  JunFang    Created.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a 16-bit signed integer to be stored in
    ///       or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlInt16 : INullable, IComparable {
        private short   m_value;
        private bool    m_fNotNull; // false if null

        private static readonly int O_MASKI2    = ~0x00007fff;

        // constructor
        // construct a Null
        private SqlInt16(bool fNull) {
            m_fNotNull = false;
            m_value = 0;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.SqlInt16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt16(short value) {
            m_value = value;
            m_fNotNull = true;
        }

        // INullable
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public short Value {
            get {
                if (m_fNotNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from short to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt16(short x) {
            return new SqlInt16(x);
        }

        // Explicit conversion from SqlInt16 to short. Throw exception if x is Null.
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorshort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator short(SqlInt16 x) {
            return x.Value;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 Parse(String s) {
            return new SqlInt16(Int16.Parse(s));
        }


        // Unary operators
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator -(SqlInt16 x) {
            return x.IsNull ? Null : new SqlInt16((short)-x.m_value);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator~"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator ~(SqlInt16 x) {
            return x.IsNull ? Null : new SqlInt16((short)~x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator +(SqlInt16 x, SqlInt16 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value + (int)y.m_value;
            if ((((iResult >> 15) ^ (iResult >> 16)) & 1) != 0) // Bit 15 != bit 16
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)iResult);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator -(SqlInt16 x, SqlInt16 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value - (int)y.m_value;
            if ((((iResult >> 15) ^ (iResult >> 16)) & 1) != 0) // Bit 15 != bit 16
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)iResult);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator *(SqlInt16 x, SqlInt16 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = (int)x.m_value * (int)y.m_value;
            int iTemp = iResult & O_MASKI2;
            if (iTemp != 0 && iTemp != O_MASKI2)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)iResult);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator /(SqlInt16 x, SqlInt16 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == Int16.MinValue) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt16((short)(x.m_value / y.m_value));
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator%"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator %(SqlInt16 x, SqlInt16 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == Int16.MinValue) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt16((short)(x.m_value % y.m_value));
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        // Bitwise operators
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorAMP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator &(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt16((short)(x.m_value & y.m_value));
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator|"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator |(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt16((short)((ushort)x.m_value | (ushort)y.m_value));
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator^"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt16 operator ^(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt16((short)(x.m_value ^ y.m_value));
        }



        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt161"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlBoolean x) {
            return x.IsNull ? Null : new SqlInt16((short)(x.ByteValue));
        }

        // Implicit conversion from SqlByte to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt162"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt16(SqlByte x) {
            return x.IsNull ? Null : new SqlInt16((short)(x.Value));
        }

        // Explicit conversions

        // Explicit conversion from SqlInt32 to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt163"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlInt32 x) {
            if (x.IsNull)
                return Null;

            int value = x.Value;
            if (value > (int)Int16.MaxValue || value < (int)Int16.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)value);
        }

        // Explicit conversion from SqlInt64 to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt164"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlInt64 x) {
            if (x.IsNull)
                return Null;

            long value = x.Value;
            if (value > (long)Int16.MaxValue || value < (long)Int16.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)value);
        }

        // Explicit conversion from SqlSingle to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt165"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlSingle x) {
            if (x.IsNull)
                return Null;

            float value = x.Value;
            if (value < (float)Int16.MinValue || value > (float)Int16.MaxValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)value);
        }

        // Explicit conversion from SqlDouble to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt166"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlDouble x) {
            if (x.IsNull)
                return Null;

            double value = x.Value;
            if (value < (double)Int16.MinValue || value > (double)Int16.MaxValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt16((short)value);
        }

        // Explicit conversion from SqlMoney to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt167"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlMoney x) {
            return x.IsNull ? Null : new SqlInt16(checked((short)x.ToInt32()));
        }

        // Explicit conversion from SqlDecimal to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt168"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlDecimal x) {
            return(SqlInt16)(SqlInt32)x;
        }

        // Explicit conversion from SqlString to SqlInt16
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorSqlInt169"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt16(SqlString x) {
            return x.IsNull ? Null : new SqlInt16(Int16.Parse(x.Value));
        }


        // Builtin functions
        internal static SqlInt16 Abs(SqlInt16 x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlInt16((short) - x.m_value);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlInt16 x, SqlInt16 y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlInt16 x, SqlInt16 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ~
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.OnesComplement"]/*' />
        public static SqlInt16 OnesComplement(SqlInt16 x) {
            return ~x;
        }

        // Alternative method for operator +
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Add"]/*' />
        public static SqlInt16 Add(SqlInt16 x, SqlInt16 y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Subtract"]/*' />
        public static SqlInt16 Subtract(SqlInt16 x, SqlInt16 y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Multiply"]/*' />
        public static SqlInt16 Multiply(SqlInt16 x, SqlInt16 y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Divide"]/*' />
        public static SqlInt16 Divide(SqlInt16 x, SqlInt16 y) {
            return x / y;
        }

        // Alternative method for operator %
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Mod"]/*' />
        public static SqlInt16 Mod(SqlInt16 x, SqlInt16 y) {
            return x % y;
        }

        // Alternative method for operator &
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.BitwiseAnd"]/*' />
        public static SqlInt16 BitwiseAnd(SqlInt16 x, SqlInt16 y) {
            return x & y;
        }

        // Alternative method for operator |
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.BitwiseOr"]/*' />
        public static SqlInt16 BitwiseOr(SqlInt16 x, SqlInt16 y) {
            return x | y;
        }

        // Alternative method for operator ^
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Xor"]/*' />
        public static SqlInt16 Xor(SqlInt16 x, SqlInt16 y) {
            return x ^ y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Equals1"]/*' />
        public static SqlBoolean Equals(SqlInt16 x, SqlInt16 y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlInt16 x, SqlInt16 y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlInt16 x, SqlInt16 y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlInt16 x, SqlInt16 y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlInt16 x, SqlInt16 y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlInt16 x, SqlInt16 y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }



        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlInt16) {
                SqlInt16 i = (SqlInt16)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlInt16)) {
                return false;
            }

            SqlInt16 i = (SqlInt16)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt16 Null        = new SqlInt16(true);
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt16 Zero        = new SqlInt16(0);
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt16 MinValue    = new SqlInt16(Int16.MinValue);
        /// <include file='doc\SQLInt16.uex' path='docs/doc[@for="SqlInt16.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt16 MaxValue    = new SqlInt16(Int16.MaxValue);

    } // SqlInt16

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqldouble.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLDouble.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlDouble.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlDouble which is equivalent to 
//            data type "float" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a floating-point number within the range of
    ///       -1.79E
    ///       +308 through 1.79E +308 to be stored in or retrieved from
    ///       a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlDouble : INullable, IComparable {
        private double m_value;
        private bool m_fNotNull; // false if null

        // constructor
        // construct a Null
        private SqlDouble(bool fNull) {
            m_fNotNull = false;
            m_value = 0.0;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.SqlDouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDouble(double value) {
            if (Double.IsInfinity(value) || Double.IsNaN(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else {
                m_value = value;
                m_fNotNull = true;
            }
        }

        // INullable
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public double Value {
            get {
                if (m_fNotNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from double to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(double x) {
            return new SqlDouble(x);
        }

        // Explicit conversion from SqlDouble to double. Throw exception if x is Null.
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatordouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator double(SqlDouble x) {
            return x.Value;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble Parse(String s) {
            return new SqlDouble(Double.Parse(s, CultureInfo.InvariantCulture));
        }


        // Unary operators
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble operator -(SqlDouble x) {
            return x.IsNull ? Null : new SqlDouble(-x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble operator +(SqlDouble x, SqlDouble y) {
            if (x.IsNull || y.IsNull)
                return Null;

            double value = x.m_value + y.m_value;

            if (Double.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlDouble(value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble operator -(SqlDouble x, SqlDouble y) {
            if (x.IsNull || y.IsNull)
                return Null;

            double value = x.m_value - y.m_value;

            if (Double.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlDouble(value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble operator *(SqlDouble x, SqlDouble y) {
            if (x.IsNull || y.IsNull)
                return Null;

            double value = x.m_value * y.m_value;

            if (Double.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlDouble(value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDouble operator /(SqlDouble x, SqlDouble y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value == (double)0.0)
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);

            double value = x.m_value / y.m_value;

            if (Double.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlDouble(value);
        }



        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDouble(SqlBoolean x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.ByteValue));
        }

        // Implicit conversion from SqlByte to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlByte x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.Value));
        }

        // Implicit conversion from SqlInt16 to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlInt16 x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.Value));
        }

        // Implicit conversion from SqlInt32 to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlInt32 x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.Value));
        }

        // Implicit conversion from SqlInt64 to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlInt64 x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.Value));
        }

        // Implicit conversion from SqlSingle to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlSingle x) {
            return x.IsNull ? Null : new SqlDouble((double)(x.Value));
        }

        // Implicit conversion from SqlMoney to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlMoney x) {
            return x.IsNull ? Null : new SqlDouble(x.ToDouble());
        }

        // Implicit conversion from SqlDecimal to SqlDouble
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDouble(SqlDecimal x) {
            return x.IsNull ? Null : new SqlDouble(x.ToDouble());
        }


        // Explicit conversions



        // Explicit conversion from SqlString to SqlDouble
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorSqlDouble9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDouble(SqlString x) {
            if (x.IsNull)
                return SqlDouble.Null;

            return Parse(x.Value);
        }



        // Builtin functions
        internal static SqlDouble Abs(SqlDouble x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlDouble(- x.m_value);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlDouble x, SqlDouble y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlDouble x, SqlDouble y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlDouble x, SqlDouble y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlDouble x, SqlDouble y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlDouble x, SqlDouble y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlDouble x, SqlDouble y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Add"]/*' />
        public static SqlDouble Add(SqlDouble x, SqlDouble y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Subtract"]/*' />
        public static SqlDouble Subtract(SqlDouble x, SqlDouble y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Multiply"]/*' />
        public static SqlDouble Multiply(SqlDouble x, SqlDouble y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Divide"]/*' />
        public static SqlDouble Divide(SqlDouble x, SqlDouble y) {
            return x / y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Equals1"]/*' />
        public static SqlBoolean Equals(SqlDouble x, SqlDouble y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlDouble x, SqlDouble y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlDouble x, SqlDouble y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlDouble x, SqlDouble y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlDouble x, SqlDouble y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlDouble x, SqlDouble y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }



        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlDouble) {
                SqlDouble i = (SqlDouble)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlDouble)) {
                return false;
            }

            SqlDouble i = (SqlDouble)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDouble Null       = new SqlDouble(true);
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDouble Zero       = new SqlDouble(0.0);
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDouble MinValue   = new SqlDouble(Double.MinValue);
        /// <include file='doc\SQLDouble.uex' path='docs/doc[@for="SqlDouble.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDouble MaxValue   = new SqlDouble(Double.MaxValue);

    } // SqlDouble

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlboolean.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLBoolean.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlBoolean.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlBoolean which is equivalent to 
//            data type "bit" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {
    /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an integer value that is either 1 or 0.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlBoolean : INullable, IComparable {

        // m_value: 1 (true), 2 (false), 0 (unknown/Null)
        private byte m_value;

        private const byte x_Null   = 0;
        private const byte x_True   = 1;
        private const byte x_False  = 2;

        // constructor

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.SqlBoolean"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlBoolean'/> class.
        ///    </para>
        /// </devdoc>
        public SqlBoolean(bool value) {
            m_value = (byte)(value ? x_True : x_False);
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.SqlBoolean2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlBoolean(int value) : this(value, false) {
        }

        private SqlBoolean(int value, bool fNull) {
            if (fNull)
                m_value = x_Null;
            else
                m_value = (value != 0) ? x_True : x_False;
        }


        // INullable
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.IsNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the current <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> is <see cref='System.Data.SqlTypes.SqlBoolean.Null'/>.
        ///    </para>
        /// </devdoc>
        public bool IsNull {
            get { return m_value == x_Null;}
        }

        // property: Value
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Data.SqlTypes.SqlBoolean'/> to be <see langword='true'/> or
        ///    <see langword='false'/>.
        ///    </para>
        /// </devdoc>
        public bool Value {
            get {
                switch (m_value) {
                    case x_True:
                        return true;

                    case x_False:
                        return false;

                    default:
                        throw new SqlNullValueException();
                }
            }
        }

        // property: IsTrue
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.IsTrue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the current <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> is <see cref='System.Data.SqlTypes.SqlBoolean.True'/>.
        ///    </para>
        /// </devdoc>
        public bool IsTrue {
            get { return m_value == x_True;}
        }

        // property: IsFalse
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.IsFalse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the current <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> is <see cref='System.Data.SqlTypes.SqlBoolean.False'/>.
        ///    </para>
        /// </devdoc>
        public bool IsFalse {
            get { return m_value == x_False;}
        }


        // Implicit conversion from bool to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a boolean to a <see cref='System.Data.SqlTypes.SqlBoolean'/>.
        ///    </para>
        /// </devdoc>
        public static implicit operator SqlBoolean(bool x) {
            return new SqlBoolean(x);
        }

        // Explicit conversion from SqlBoolean to bool. Throw exception if x is Null.
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorbool"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a <see cref='System.Data.SqlTypes.SqlBoolean'/>
        ///       to a boolean.
        ///    </para>
        /// </devdoc>
        public static explicit operator bool(SqlBoolean x) {
            return x.Value;
        }


        // Unary operators

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator!"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs a NOT operation on a <see cref='System.Data.SqlTypes.SqlBoolean'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator !(SqlBoolean x) {
            switch (x.m_value) {
                case x_True:
                    return SqlBoolean.False;

                case x_False:
                    return SqlBoolean.True;

                default:
                    SQLDebug.Check(x.m_value == x_Null);
                    return SqlBoolean.Null;
            }
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatortrue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool operator true(SqlBoolean x) {
            return x.IsTrue;
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorfalse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool operator false(SqlBoolean x) {
            return x.IsFalse;
        }

        // Binary operators

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorAMP"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs a bitwise AND operation on two instances of
        ///    <see cref='System.Data.SqlTypes.SqlBoolean'/>
        ///    .
        /// </para>
        /// </devdoc>
        public static SqlBoolean operator &(SqlBoolean x, SqlBoolean y) {
            if (x.m_value == x_False || y.m_value == x_False)
                return SqlBoolean.False;
            else if (x.m_value == x_True && y.m_value == x_True)
                return SqlBoolean.True;
            else
                return SqlBoolean.Null;
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator|"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs
        ///       a bitwise OR operation on two instances of a
        ///    <see cref='System.Data.SqlTypes.SqlBoolean'/>
        ///    .
        /// </para>
        /// </devdoc>
        public static SqlBoolean operator |(SqlBoolean x, SqlBoolean y) {
            if (x.m_value == x_True || y.m_value == x_True)
                return SqlBoolean.True;
            else if (x.m_value == x_False && y.m_value == x_False)
                return SqlBoolean.False;
            else
                return SqlBoolean.Null;
        }



        // property: ByteValue
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.ByteValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte ByteValue {
            get {
                if (!IsNull)
                    return (m_value == x_True) ? (byte)1 : (byte)0;
                else
                    throw new SqlNullValueException();
            }
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : Value.ToString();
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean Parse(String s) {
            SqlBoolean ret;
            try {
                ret = new SqlBoolean(Int32.Parse(s));
            }
            catch (Exception) {
                ret = new SqlBoolean(Boolean.Parse(s));
            }
            return ret;
        }


        // Unary operators
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator~"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator ~(SqlBoolean x) {
            return (!x);
        }


        // Binary operators

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator^"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator ^(SqlBoolean x, SqlBoolean y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlBoolean(x.m_value != y.m_value);
        }



        // Implicit conversions


        // Explicit conversions

        // Explicit conversion from SqlByte to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlByte x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0);
        }

        // Explicit conversion from SqlInt16 to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlInt16 x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0);
        }

        // Explicit conversion from SqlInt32 to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlInt32 x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0);
        }

        // Explicit conversion from SqlInt64 to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlInt64 x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0);
        }

        // Explicit conversion from SqlDouble to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlDouble x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0.0);
        }

        // Explicit conversion from SqlSingle to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlSingle x) {
            return x.IsNull ? Null : new SqlBoolean(x.Value != 0.0);
        }

        // Explicit conversion from SqlMoney to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlMoney x) {
            return x.IsNull ? Null : (x != SqlMoney.Zero);
        }

        // Explicit conversion from SqlDecimal to SqlBoolean
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlDecimal x) {
            return x.IsNull ? SqlBoolean.Null : new SqlBoolean(x.m_data1 != 0 || x.m_data2 != 0 ||
                                                       x.m_data3 != 0 || x.m_data4 != 0);
        }

        // Explicit conversion from SqlString to SqlBoolean
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operatorSqlBoolean10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlBoolean(SqlString x) {
            return x.IsNull ? Null : SqlBoolean.Parse(x.Value);
        }

        // Overloading comparison operators
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlBoolean x, SqlBoolean y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlBoolean x, SqlBoolean y) {
            return ! (x == y);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ~
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.OnesComplement"]/*' />
        public static SqlBoolean OnesComplement(SqlBoolean x) {
            return ~x;
        }

        // Alternative method for operator &
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.And"]/*' />
        public static SqlBoolean And(SqlBoolean x, SqlBoolean y) {
            return x & y;
        }

        // Alternative method for operator |
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.Or"]/*' />
        public static SqlBoolean Or(SqlBoolean x, SqlBoolean y) {
            return x | y;
        }

        // Alternative method for operator ^
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.Xor"]/*' />
        public static SqlBoolean Xor(SqlBoolean x, SqlBoolean y) {
            return x ^ y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.Equals1"]/*' />
        public static SqlBoolean Equals(SqlBoolean x, SqlBoolean y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlBoolean x, SqlBoolean y) {
            return (x != y);
        }


        // Alternative method for conversions.

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLBoolean.uex' path='docs/doc[@for="SqlBoolean.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }



        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlBoolean) {
                SqlBoolean i = (SqlBoolean)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this.ByteValue < i.ByteValue) return -1;
                if (this.ByteValue > i.ByteValue) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlBoolean)) {
                return false;
            }

            SqlBoolean i = (SqlBoolean)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.True"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a true value that can be assigned to the
        ///    <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> property of an instance of 
        ///       the <see cref='System.Data.SqlTypes.SqlBoolean'/> class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlBoolean True      = new SqlBoolean(true);
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.False"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a false value that can be assigned to the
        ///    <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> property of an instance of 
        ///       the <see cref='System.Data.SqlTypes.SqlBoolean'/> class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlBoolean False     = new SqlBoolean(false);
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.Null"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a null value that can be assigned to the <see cref='System.Data.SqlTypes.SqlBoolean.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlBoolean'/> class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlBoolean Null      = new SqlBoolean(0, true);

        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlBoolean Zero  = new SqlBoolean(0);
        /// <include file='doc\SqlBoolean.uex' path='docs/doc[@for="SqlBoolean.One"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlBoolean One   = new SqlBoolean(1);


    } // SqlBoolean

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlbinary.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLBinary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlBinary.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlBinary which is corresponding to 
//            data type "binary/varbinary" in SQL Server
//
// Notes: 
//    
// History:
//
//   1/30/2000  JunFang        Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a variable-length
    ///       stream of binary data to be stored in or retrieved from the
    ///       database.
    ///    </para>
    /// </devdoc>
    public struct SqlBinary : INullable, IComparable {
        private byte[] m_value; // null if m_value is null

        // constructor
        // construct a Null
        private SqlBinary(bool fNull) {
            m_value = null;
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.SqlBinary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlBinary'/> class with a binary object to be stored.
        ///    </para>
        /// </devdoc>
        public SqlBinary(byte[] value) {
            // if value is null, this generates a SqlBinary.Null
            if (value == null)
                m_value = null;
            else {
                m_value = new byte[value.Length];
                value.CopyTo(m_value, 0);
            }
        }

        // INullable
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.IsNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether or not <see cref='System.Data.SqlTypes.SqlBinary.Value'/> is null.
        ///    </para>
        /// </devdoc>
        public bool IsNull {
            get { return(m_value == null);}
        }

        // property: Value
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the
        ///       value of the SQL binary object retrieved.
        ///    </para>
        /// </devdoc>
        public byte[] Value {
            get {
                if (IsNull)
                    throw new SqlNullValueException();
                else {
                    byte[] value = new byte[m_value.Length];
                    m_value.CopyTo(value, 0);
                    return value;
                }
            }
        }

		// class indexer
		/// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.this"]/*' />
		public byte this[int index] {
			get {
				if (IsNull)
                    throw new SqlNullValueException();
				else
					return m_value[index];
			}
		}

        // property: Length
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Length"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the length in bytes of <see cref='System.Data.SqlTypes.SqlBinary.Value'/>.
        ///    </para>
        /// </devdoc>
        public int Length {
            get {
                if (!IsNull)
                    return m_value.Length;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from byte[] to SqlBinary
		// Alternative: constructor SqlBinary(bytep[])
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operatorSqlBinary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a binary object to a <see cref='System.Data.SqlTypes.SqlBinary'/>.
        ///    </para>
        /// </devdoc>
        public static implicit operator SqlBinary(byte[] x) {
            return new SqlBinary(x);
        }

        // Explicit conversion from SqlBinary to byte[]. Throw exception if x is Null.
		// Alternative: Value property
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operatorbyte"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a <see cref='System.Data.SqlTypes.SqlBinary'/> to a binary object.
        ///    </para>
        /// </devdoc>
        public static explicit operator byte[](SqlBinary x) {
            return x.Value;
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a string describing a <see cref='System.Data.SqlTypes.SqlBinary'/> object.
        ///    </para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : "SqlBinary(" + m_value.Length.ToString() + ")";
        }


        // Unary operators

        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operator+"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds two instances of <see cref='System.Data.SqlTypes.SqlBinary'/> together.
        ///    </para>
        /// </devdoc>
        // Alternative method: SqlBinary.Concat
        public static SqlBinary operator +(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return Null;

            byte[] rgbResult = new byte[x.Value.Length + y.Value.Length];
            x.Value.CopyTo(rgbResult, 0);
            y.Value.CopyTo(rgbResult, x.Value.Length);

            return new SqlBinary(rgbResult);
        }


        // Comparisons

        private static EComparison PerformCompareByte(byte[] x, byte[] y) {
            int len1 = x.Length;
            int len2 = y.Length;

            bool fXShorter = (len1 < len2);
            // the smaller length of two arrays
            int len = (fXShorter) ? len1 : len2;
            int i;

            for (i = 0; i < len; i ++) {
                if (x[i] != y[i]) {
                    if (x[i] < y[i])
                        return EComparison.LT;
                    else
                        return EComparison.GT;
                }
            }

            if (len1 == len2)
                return EComparison.EQ;
            else {
                // if the remaining bytes are all zeroes, they are still equal.

                byte bZero = (byte)0;

                if (fXShorter) {
                    // array X is shorter
                    for (i = len; i < len2; i ++) {
                        if (y[i] != bZero)
                            return EComparison.LT;
                    }
                }
                else {
                    // array Y is shorter
                    for (i = len; i < len1; i ++) {
                        if (x[i] != bZero)
                            return EComparison.GT;
                    }
                }

                return EComparison.EQ;
            }
        }


        // Implicit conversions

        // Explicit conversions

        // Explicit conversion from SqlGuid to SqlBinary
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operatorSqlBinary1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a <see cref='System.Data.SqlTypes.SqlGuid'/> to a <see cref='System.Data.SqlTypes.SqlBinary'/>
        ///       .
        ///    </para>
        /// </devdoc>
        // Alternative method: SqlGuid.ToSqlBinary
        public static explicit operator SqlBinary(SqlGuid x) {
            return x.IsNull ? SqlBinary.Null : new SqlBinary(x.ToByteArray());
        }

        // Builtin functions

        // Overloading comparison operators
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two instances of <see cref='System.Data.SqlTypes.SqlBinary'/> for
        ///       equality.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            return new SqlBoolean(PerformCompareByte(x.Value, y.Value) == EComparison.EQ);
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two instances of <see cref='System.Data.SqlTypes.SqlBinary'/>
        ///       for equality.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlBinary x, SqlBinary y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares the first <see cref='System.Data.SqlTypes.SqlBinary'/> for being less than the
        ///       second <see cref='System.Data.SqlTypes.SqlBinary'/>.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            return new SqlBoolean(PerformCompareByte(x.Value, y.Value) == EComparison.LT);
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operator>"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares the first <see cref='System.Data.SqlTypes.SqlBinary'/> for being greater than the second <see cref='System.Data.SqlTypes.SqlBinary'/>.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            return new SqlBoolean(PerformCompareByte(x.Value, y.Value) == EComparison.GT);
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares the first <see cref='System.Data.SqlTypes.SqlBinary'/> for being less than or equal to the second <see cref='System.Data.SqlTypes.SqlBinary'/>.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            EComparison cmpResult = PerformCompareByte(x.Value, y.Value);
            return new SqlBoolean(cmpResult == EComparison.LT || cmpResult == EComparison.EQ);
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.operator>="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares the first <see cref='System.Data.SqlTypes.SqlBinary'/> for being greater than or equal the second <see cref='System.Data.SqlTypes.SqlBinary'/>.
        ///    </para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlBinary x, SqlBinary y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            EComparison cmpResult = PerformCompareByte(x.Value, y.Value);
            return new SqlBoolean(cmpResult == EComparison.GT || cmpResult == EComparison.EQ);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Concat"]/*' />
        public static SqlBinary Concat(SqlBinary x, SqlBinary y) {
                return x + y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Equals1"]/*' />
        public static SqlBoolean Equals(SqlBinary x, SqlBinary y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlBinary x, SqlBinary y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlBinary x, SqlBinary y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlBinary x, SqlBinary y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlBinary x, SqlBinary y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlBinary x, SqlBinary y) {
            return (x >= y);
        }

        // Alternative method for conversions.
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.ToSqlGuid"]/*' />
        public SqlGuid ToSqlGuid() {
            return (SqlGuid)this;
        }

        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlBinary) {
                SqlBinary i = (SqlBinary)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlBinary)) {
                return false;
            }

            SqlBinary i = (SqlBinary)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            if (IsNull)
                return 0;

            //First trim off extra '\0's
            int cbLen = m_value.Length;
            while (cbLen > 0 && m_value[cbLen - 1] == 0)
                --cbLen;

            int ulValue = 0;
            int ulHi;

            // Size of CRC window (hashing bytes, ssstr, sswstr, numeric)
            const int x_cbCrcWindow = 4;
            // const int iShiftVal = (sizeof ulValue) * (8*sizeof(char)) - x_cbCrcWindow;
            const int iShiftVal = 4 * 8 - x_cbCrcWindow;

            for(int i = 0; i < cbLen; i++)
                {
                ulHi = (ulValue >> iShiftVal) & 0xff;
                ulValue <<= x_cbCrcWindow;
                ulValue = ulValue ^ m_value[i] ^ ulHi;
                }

            return ulValue;
        }

        /// <include file='doc\SQLBinary.uex' path='docs/doc[@for="SqlBinary.Null"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a null value that can be assigned to
        ///       the <see cref='System.Data.SqlTypes.SqlBinary.Value'/> property of an
        ///       instance of the <see cref='System.Data.SqlTypes.SqlBinary'/> class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlBinary Null       = new SqlBinary(true);

    } // SqlBinary

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlguid.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLGuid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlGuid.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlGuid which is equivalent to 
//            data type "uniqueidentifier" in SQL Server
//
// Notes: 
//    
// History:
//
//   11/1/99  JunFang    Created.
//
// @EndHeader@
//**************************************************************************

using System;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a globally unique identifier to be stored in
    ///       or retrieved from a database.
    ///    </para>
    /// </devdoc>
    public struct SqlGuid : INullable, IComparable {
        private static readonly int SizeOfGuid = 16;

        // Comparison orders.
        private static readonly int[] x_rgiGuidOrder = new int[16] 
        {10, 11, 12, 13, 14, 15, 8, 9, 6, 7, 4, 5, 0, 1, 2, 3};

        private byte[] m_value; // the SqlGuid is null if m_value is null

        // constructor
        // construct a SqlGuid.Null
        private SqlGuid(bool fNull) {
            m_value = null;
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.SqlGuid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlGuid(byte[] value) {
            if (value == null || value.Length != SizeOfGuid)
                throw new ArgumentException(SQLResource.InvalidArraySizeMessage);

            m_value = new byte[SizeOfGuid];
            value.CopyTo(m_value, 0);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.SqlGuid1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlGuid(String s) {
            m_value = (new Guid(s)).ToByteArray();
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.SqlGuid2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlGuid(Guid g) {
            m_value = g.ToByteArray();
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.SqlGuid3"]/*' />
        public SqlGuid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k) 
            : this(new Guid(a, b, c, d, e, f, g, h, i, j, k))
        {
        }


        // INullable
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return(m_value == null);}
        }

        // property: Value
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Guid Value {
            get {
                if (IsNull)
                    throw new SqlNullValueException();
                else
                    return new Guid(m_value);
            }
        }

        // Implicit conversion from Guid to SqlGuid
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorSqlGuid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlGuid(Guid x) {
            return new SqlGuid(x);
        }

        // Explicit conversion from SqlGuid to Guid. Throw exception if x is Null.
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorGuid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator Guid(SqlGuid x) {
            return x.Value;
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.ToByteArray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] ToByteArray() {
            byte[] ret = new byte[SizeOfGuid];
            m_value.CopyTo(ret, 0);
            return ret;
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            if (IsNull)
                return SQLResource.NullString;

            Guid g = new Guid(m_value);
            return g.ToString();
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlGuid Parse(String s) {
            return new SqlGuid(s);
        }


        // Comparison operators
        private static EComparison Compare(SqlGuid x, SqlGuid y) {
            //Swap to the correct order to be compared
            for (int i = 0; i < SizeOfGuid; i++) {
                byte    b1, b2;

                b1 = x.m_value [x_rgiGuidOrder[i]];
                b2 = y.m_value [x_rgiGuidOrder[i]];
                if (b1 != b2)
                    return(b1 < b2) ? EComparison.LT : EComparison.GT;
            }
            return EComparison.EQ;
        }



        // Implicit conversions

        // Explicit conversions

        // Explicit conversion from SqlString to SqlGuid
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorSqlGuid1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlGuid(SqlString x) {
            return x.IsNull ? Null : new SqlGuid(x.Value);
        }

        // Explicit conversion from SqlBinary to SqlGuid
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorSqlGuid2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlGuid(SqlBinary x) {
            return x.IsNull ? Null : new SqlGuid(x.Value);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlGuid x, SqlGuid y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(Compare(x, y) == EComparison.EQ);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlGuid x, SqlGuid y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlGuid x, SqlGuid y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(Compare(x, y) == EComparison.LT);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlGuid x, SqlGuid y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(Compare(x, y) == EComparison.GT);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlGuid x, SqlGuid y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            EComparison cmp = Compare(x, y);
            return new SqlBoolean(cmp == EComparison.LT || cmp == EComparison.EQ);
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlGuid x, SqlGuid y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            EComparison cmp = Compare(x, y);
            return new SqlBoolean(cmp == EComparison.GT || cmp == EComparison.EQ);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ==
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.Equals1"]/*' />
        public static SqlBoolean Equals(SqlGuid x, SqlGuid y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlGuid x, SqlGuid y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlGuid x, SqlGuid y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlGuid x, SqlGuid y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlGuid x, SqlGuid y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlGuid x, SqlGuid y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }

        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.ToSqlBinary"]/*' />
        public SqlBinary ToSqlBinary() {
            return (SqlBinary)this;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlGuid) {
                SqlGuid i = (SqlGuid)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlGuid)) {
                return false;
            }

            SqlGuid i = (SqlGuid)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLGuid.uex' path='docs/doc[@for="SqlGuid.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlGuid Null     = new SqlGuid(true);

    } // SqlGuid

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlint32.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLInt32.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlInt32.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlInt32 which is equivalent to 
//            data type "int" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a 32-bit signed integer to be stored in
    ///       or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlInt32 : INullable, IComparable {
        private int m_value;
        private bool m_fNotNull; // false if null, the default ctor (plain 0) will make it Null

        private static readonly long x_iIntMin          = Int32.MinValue;   // minimum (signed) int value
        private static readonly long x_lBitNotIntMax    = ~(long)(Int32.MaxValue);

        // constructor
        // construct a Null
        private SqlInt32(bool fNull) {
            m_fNotNull = false;
            m_value = 0;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.SqlInt32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt32(int value) {
            m_value = value;
            m_fNotNull = true;
        }


        // INullable
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Value {
            get {
                if (IsNull)
                    throw new SqlNullValueException();
                else
                    return m_value;
            }
        }

        // Implicit conversion from int to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt32(int x) {
            return new SqlInt32(x);
        }

        // Explicit conversion from SqlInt32 to int. Throw exception if x is Null.
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator int(SqlInt32 x) {
            return x.Value;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 Parse(String s) {
            return new SqlInt32(Int32.Parse(s));
        }


        // Unary operators
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator -(SqlInt32 x) {
            return x.IsNull ? Null : new SqlInt32(-x.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator~"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator ~(SqlInt32 x) {
            return x.IsNull ? Null : new SqlInt32(~x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator +(SqlInt32 x, SqlInt32 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = x.m_value + y.m_value;
            if (SameSignInt(x.m_value, y.m_value) && !SameSignInt(x.m_value, iResult))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32(iResult);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator -(SqlInt32 x, SqlInt32 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            int iResult = x.m_value - y.m_value;
            if (!SameSignInt(x.m_value, y.m_value) && SameSignInt(y.m_value, iResult))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32(iResult);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator *(SqlInt32 x, SqlInt32 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            long lResult = (long)x.m_value * (long)y.m_value;
            long lTemp = lResult & x_lBitNotIntMax;
            if (lTemp != 0 && lTemp != x_lBitNotIntMax)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32((int)lResult);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator /(SqlInt32 x, SqlInt32 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == x_iIntMin) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt32(x.m_value / y.m_value);
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator%"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator %(SqlInt32 x, SqlInt32 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == x_iIntMin) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt32(x.m_value % y.m_value);
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        // Bitwise operators
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorAMP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator &(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt32(x.m_value & y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator|"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator |(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt32(x.m_value | y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator^"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 operator ^(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt32(x.m_value ^ y.m_value);
        }


        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt321"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlBoolean x) {
            return x.IsNull ? Null : new SqlInt32((int)x.ByteValue);
        }

        // Implicit conversion from SqlByte to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt322"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt32(SqlByte x) {
            return x.IsNull ? Null : new SqlInt32(x.Value);
        }

        // Implicit conversion from SqlInt16 to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt323"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt32(SqlInt16 x) {
            return x.IsNull ? Null : new SqlInt32(x.Value);
        }


        // Explicit conversions

        // Explicit conversion from SqlInt64 to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt324"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlInt64 x) {
            if (x.IsNull)
                return Null;

            long value = x.Value;
            if (value > (long)Int32.MaxValue || value < (long)Int32.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32((int)value);
        }

        // Explicit conversion from SqlSingle to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt325"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlSingle x) {
            if (x.IsNull)
                return Null;

            float value = x.Value;
            if (value > (float)Int32.MaxValue || value < (float)Int32.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32((int)value);
        }

        // Explicit conversion from SqlDouble to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt326"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlDouble x) {
            if (x.IsNull)
                return Null;

            double value = x.Value;
            if (value > (double)Int32.MaxValue || value < (double)Int32.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt32((int)value);
        }

        // Explicit conversion from SqlMoney to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt327"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlMoney x) {
            return x.IsNull ? Null : new SqlInt32(x.ToInt32());
        }

        // Explicit conversion from SqlDecimal to SqlInt32
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt328"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlDecimal x) {
            if (x.IsNull)
                return SqlInt32.Null;

            long ret = (long)x.m_data1;
            if (!x.IsPositive)
                ret = - ret;

            if (x.m_bLen > 1 || ret > (long)Int32.MaxValue || ret < (long)Int32.MinValue)
                throw new OverflowException(SQLResource.ConversionOverflowMessage);

            return new SqlInt32((int)ret);
        }

        // Explicit conversion from SqlString to SqlInt
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorSqlInt329"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt32(SqlString x) {
            return x.IsNull ? SqlInt32.Null : new SqlInt32(Int32.Parse(x.Value));
        }


        // Builtin functions
        internal static SqlInt32 Abs(SqlInt32 x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlInt32(- x.m_value);
        }

        // Utility functions
        private static bool SameSignInt(int x, int y) {
            return((x ^ y) & 0x80000000) == 0;
        }

        // Overloading comparison operators
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlInt32 x, SqlInt32 y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlInt32 x, SqlInt32 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ~
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.OnesComplement"]/*' />
        public static SqlInt32 OnesComplement(SqlInt32 x) {
            return ~x;
        }

        // Alternative method for operator +
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Add"]/*' />
        public static SqlInt32 Add(SqlInt32 x, SqlInt32 y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Subtract"]/*' />
        public static SqlInt32 Subtract(SqlInt32 x, SqlInt32 y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Multiply"]/*' />
        public static SqlInt32 Multiply(SqlInt32 x, SqlInt32 y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Divide"]/*' />
        public static SqlInt32 Divide(SqlInt32 x, SqlInt32 y) {
            return x / y;
        }

        // Alternative method for operator %
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Mod"]/*' />
        public static SqlInt32 Mod(SqlInt32 x, SqlInt32 y) {
            return x % y;
        }

        // Alternative method for operator &
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.BitwiseAnd"]/*' />
        public static SqlInt32 BitwiseAnd(SqlInt32 x, SqlInt32 y) {
            return x & y;
        }

        // Alternative method for operator |
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.BitwiseOr"]/*' />
        public static SqlInt32 BitwiseOr(SqlInt32 x, SqlInt32 y) {
            return x | y;
        }

        // Alternative method for operator ^
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Xor"]/*' />
        public static SqlInt32 Xor(SqlInt32 x, SqlInt32 y) {
            return x ^ y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Equals1"]/*' />
        public static SqlBoolean Equals(SqlInt32 x, SqlInt32 y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlInt32 x, SqlInt32 y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlInt32 x, SqlInt32 y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlInt32 x, SqlInt32 y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlInt32 x, SqlInt32 y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlInt32 x, SqlInt32 y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }



        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlInt32) {
                SqlInt32 i = (SqlInt32)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlInt32)) {
                return false;
            }

            SqlInt32 i = (SqlInt32)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt32 Null        = new SqlInt32(true);
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt32 Zero        = new SqlInt32(0);
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt32 MinValue    = new SqlInt32(Int32.MinValue);
        /// <include file='doc\SQLInt32.uex' path='docs/doc[@for="SqlInt32.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt32 MaxValue    = new SqlInt32(Int32.MaxValue);

    } // SqlInt32

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlint64.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLInt64.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlInt64.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlInt64 which is equivalent to 
//            data type "bigint" in SQL Server
//
// Notes: 
//    
// History:
//
//   10/28/99  JunFang    Created.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a 64-bit signed integer to be stored in
    ///       or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlInt64 : INullable, IComparable {
        private long m_value;
        private bool m_fNotNull; // false if null

        private static readonly long x_lLowIntMask  = 0xffffffff;
        private static readonly long x_lHighIntMask = unchecked((long)0xffffffff00000000);


        // constructor
        // construct a Null
        private SqlInt64(bool fNull) {
            m_fNotNull = false;
            m_value = 0;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.SqlInt64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlInt64(long value) {
            m_value = value;
            m_fNotNull = true;
        }

        // INullable
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public long Value {
            get {
                if (m_fNotNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from long to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt64(long x) {
            return new SqlInt64(x);
        }

        // Explicit conversion from SqlInt64 to long. Throw exception if x is Null.
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorlong"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator long(SqlInt64 x) {
            return x.Value;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 Parse(String s) {
            return new SqlInt64(Int64.Parse(s));
        }


        // Unary operators
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator -(SqlInt64 x) {
            return x.IsNull ? Null : new SqlInt64(-x.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator~"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator ~(SqlInt64 x) {
            return x.IsNull ? Null : new SqlInt64(~x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator +(SqlInt64 x, SqlInt64 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            long lResult = x.m_value + y.m_value;
            if (SameSignLong(x.m_value, y.m_value) && !SameSignLong(x.m_value, lResult))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt64(lResult);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator -(SqlInt64 x, SqlInt64 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            long lResult = x.m_value - y.m_value;
            if (!SameSignLong(x.m_value, y.m_value) && SameSignLong(y.m_value, lResult))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt64(lResult);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator *(SqlInt64 x, SqlInt64 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            bool    fNeg = false;

            long    lOp1 = x.m_value;
            long    lOp2 = y.m_value;
            long    lResult;
            long    lPartialResult = 0;

            if (lOp1 < 0) {
                fNeg = true;
                lOp1 = - lOp1;
            }

            if (lOp2 < 0) {
                fNeg = !fNeg;
                lOp2 = - lOp2;
            }

            long    lLow1   = lOp1 & x_lLowIntMask;
            long    lHigh1  = (lOp1 >> 32) & x_lLowIntMask;
            long    lLow2   = lOp2 & x_lLowIntMask;
            long    lHigh2  = (lOp2 >> 32) & x_lLowIntMask;

            // if both of the high order dwords are non-zero then overflow results
            if (lHigh1 != 0 && lHigh2 != 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            lResult = lLow1 * lLow2;

            if (lResult < 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            if (lHigh1 != 0) {
                SQLDebug.Check(lHigh2 == 0);
                lPartialResult = lHigh1 * lLow2;
                if (lPartialResult < 0 || lPartialResult > Int64.MaxValue)
                    throw new OverflowException(SQLResource.ArithOverflowMessage);
            }
            else if (lHigh2 != 0) {
                SQLDebug.Check(lHigh1 == 0);
                lPartialResult = lLow1 * lHigh2;
                if (lPartialResult < 0 || lPartialResult > Int64.MaxValue)
                    throw new OverflowException(SQLResource.ArithOverflowMessage);
            }

            lResult += lPartialResult << 32;
            if (lResult < 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            if (fNeg)
                lResult = - lResult;

            return new SqlInt64(lResult);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator /(SqlInt64 x, SqlInt64 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == Int64.MinValue) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt64(x.m_value / y.m_value);
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator%"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator %(SqlInt64 x, SqlInt64 y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value != 0) {
                if ((x.m_value == Int64.MinValue) && (y.m_value == -1))
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                return new SqlInt64(x.m_value % y.m_value);
            }
            else
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);
        }

        // Bitwise operators
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorAMP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator &(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt64(x.m_value & y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator|"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator |(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt64(x.m_value | y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator^"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt64 operator ^(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? Null : new SqlInt64(x.m_value ^ y.m_value);
        }


        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt641"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlBoolean x) {
            return x.IsNull ? Null : new SqlInt64((long)x.ByteValue);
        }

        // Implicit conversion from SqlByte to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt642"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt64(SqlByte x) {
            return x.IsNull ? Null : new SqlInt64((long)(x.Value));
        }

        // Implicit conversion from SqlInt16 to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt643"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt64(SqlInt16 x) {
            return x.IsNull ? Null : new SqlInt64((long)(x.Value));
        }

        // Implicit conversion from SqlInt32 to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt644"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlInt64(SqlInt32 x) {
            return x.IsNull ? Null : new SqlInt64((long)(x.Value));
        }


        // Explicit conversions

        // Explicit conversion from SqlSingle to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt645"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlSingle x) {
            if (x.IsNull)
                return Null;

            float value = x.Value;
            if (value > (float)Int64.MaxValue || value < (float)Int64.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt64((long)value);
        }

        // Explicit conversion from SqlDouble to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt646"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlDouble x) {
            if (x.IsNull)
                return Null;

            double value = x.Value;
            if (value > (double)Int64.MaxValue || value < (double)Int64.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else
                return new SqlInt64((long)value);
        }

        // Explicit conversion from SqlMoney to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt647"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlMoney x) {
            return x.IsNull ? Null : new SqlInt64(x.ToInt64());
        }

        // Explicit conversion from SqlDecimal to SqlInt64
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt648"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlDecimal x) {
            if (x.IsNull)
                return SqlInt64.Null;

            SqlDecimal  ssnumTemp = x;
            long        llRetVal;

            // Throw away decimal portion
            ssnumTemp.AdjustScale (-ssnumTemp.m_bScale, false);

            // More than 8 bytes of data will always overflow
            if (ssnumTemp.m_bLen > 2)
                throw new OverflowException(SQLResource.ConversionOverflowMessage);

            // If 8 bytes of data, see if fits in LONGLONG
            if (ssnumTemp.m_bLen == 2) {
                ulong dwl = SqlDecimal.DWL(ssnumTemp.m_data1, ssnumTemp.m_data2);
                if (dwl > SqlDecimal.x_llMax && (ssnumTemp.IsPositive || dwl != 1 + SqlDecimal.x_llMax))
                    throw new OverflowException(SQLResource.ConversionOverflowMessage);
                llRetVal = (long) dwl;
            }
            // 4 bytes of data always fits in a LONGLONG
            else
                llRetVal = (long) ssnumTemp.m_data1;

            //negate result if ssnumTemp negative
            if (!ssnumTemp.IsPositive)
                llRetVal = -llRetVal;

            return new SqlInt64(llRetVal);
        }

        // Explicit conversion from SqlString to SqlInt
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorSqlInt649"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlInt64(SqlString x) {
            return x.IsNull ? Null : new SqlInt64(Int64.Parse(x.Value));
        }


        // Builtin functions
        internal static SqlInt64 Abs(SqlInt64 x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlInt64(- x.m_value);
        }

        // Utility functions
        private static bool SameSignLong(long x, long y) {
            return((x ^ y) & unchecked((long)0x8000000000000000L)) == 0;
        }

        // Overloading comparison operators
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlInt64 x, SqlInt64 y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlInt64 x, SqlInt64 y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator ~
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.OnesComplement"]/*' />
        public static SqlInt64 OnesComplement(SqlInt64 x) {
            return ~x;
        }

        // Alternative method for operator +
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Add"]/*' />
        public static SqlInt64 Add(SqlInt64 x, SqlInt64 y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Subtract"]/*' />
        public static SqlInt64 Subtract(SqlInt64 x, SqlInt64 y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Multiply"]/*' />
        public static SqlInt64 Multiply(SqlInt64 x, SqlInt64 y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Divide"]/*' />
        public static SqlInt64 Divide(SqlInt64 x, SqlInt64 y) {
            return x / y;
        }

        // Alternative method for operator %
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Mod"]/*' />
        public static SqlInt64 Mod(SqlInt64 x, SqlInt64 y) {
            return x % y;
        }

        // Alternative method for operator &
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.BitwiseAnd"]/*' />
        public static SqlInt64 BitwiseAnd(SqlInt64 x, SqlInt64 y) {
            return x & y;
        }

        // Alternative method for operator |
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.BitwiseOr"]/*' />
        public static SqlInt64 BitwiseOr(SqlInt64 x, SqlInt64 y) {
            return x | y;
        }

        // Alternative method for operator ^
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Xor"]/*' />
        public static SqlInt64 Xor(SqlInt64 x, SqlInt64 y) {
            return x ^ y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Equals1"]/*' />
        public static SqlBoolean Equals(SqlInt64 x, SqlInt64 y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlInt64 x, SqlInt64 y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlInt64 x, SqlInt64 y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlInt64 x, SqlInt64 y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlInt64 x, SqlInt64 y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlInt64 x, SqlInt64 y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlInt64) {
                SqlInt64 i = (SqlInt64)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlInt64)) {
                return false;
            }

            SqlInt64 i = (SqlInt64)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt64 Null        = new SqlInt64(true);
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt64 Zero        = new SqlInt64(0);
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt64 MinValue    = new SqlInt64(Int64.MinValue);
        /// <include file='doc\SQLInt64.uex' path='docs/doc[@for="SqlInt64.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlInt64 MaxValue    = new SqlInt64(Int64.MaxValue);

    } // SqlInt64

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlnumeric.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLNumeric.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlDecimal.cs
//
// Create by:    JunFang
// @Owner:      JunFang
//
// Purpose: Implementation of SqlMoney which is equivalent to 
//            data type "numeric" and "decimal" in SQL Server
//
// Notes: 
//    
// History:
//
//	@Version: Yukon
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a fixed precision and scale numeric value between -10<superscript term='38'/>
    ///       -1 and 10<superscript term='38'/> -1 to be stored in or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlDecimal : INullable, IComparable {
        // data in CSsNumeric in SQL Server
        // BYTE    m_cbLen;                // # of DWORDs + 1 (1 is for sign)
        // BYTE    m_bPrec;                // precision
        // BYTE    m_bScale;                // scale
        // BYTE    m_bSign;                // NUM_POSITIVE or NUM_NEGATIVE
        // ULONG    m_rgulData [x_culNumeMax];

        internal byte    m_bStatus;      // bit 0: fNotNull, bit 1: fNegative
        internal byte    m_bLen;         // number of uints used, = (CSsNumeric.m_cbLen - 1) / 4.
        internal byte    m_bPrec;
        internal byte    m_bScale;
        internal uint    m_data1;
        internal uint    m_data2;
        internal uint    m_data3;
        internal uint    m_data4;

        private static readonly byte NUMERIC_MAX_PRECISION = 38;            // Maximum precision of numeric 
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.MaxPrecision"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public  static readonly byte MaxPrecision = NUMERIC_MAX_PRECISION;  // max SS precision
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.MaxScale"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public  static readonly byte MaxScale = NUMERIC_MAX_PRECISION;      // max SS scale

        private static readonly byte    x_bNullMask     = 1;    // bit mask for null bit in m_bStatus
        private static readonly byte    x_bIsNull       = 0;    // is null
        private static readonly byte    x_bNotNull      = 1;    // is not null

        private static readonly byte    x_bSignMask     = 2;    // bit mask for sign bit in m_bStatus
        private static readonly byte    x_bPositive     = 0;    // is positive
        private static readonly byte    x_bNegative     = 2;    // is negative
        private static readonly byte    x_bReverseSignMask  = (byte)~x_bSignMask;

        private static readonly uint    x_uiZero            = (uint) 0;

        private static readonly int     x_cNumeMax          = 4;
        private static readonly long    x_lInt32Base        = ((long)1) << 32;      // 2**32
        private static readonly ulong   x_ulInt32Base       = ((ulong)1) << 32;     // 2**32
        private static readonly ulong   x_ulInt32BaseForMod = x_ulInt32Base - 1;    // 2**32 - 1 (0xFFF...FF)

        internal static readonly ulong   x_llMax            = Int64.MaxValue;   // Max of Int64

        private static readonly uint    x_ulBase10          = 10;

        private static readonly double  DUINT_BASE  = (double)x_lInt32Base;     // 2**32
        private static readonly double  DUINT_BASE2 = DUINT_BASE * DUINT_BASE;  // 2**64
        private static readonly double  DUINT_BASE3 = DUINT_BASE2 * DUINT_BASE; // 2**96
        private static readonly double  DMAX_NUME   = 1.0e+38;                  // Max value of numeric
        private static readonly uint    DBL_DIG     = 17;                       // Max decimal digits of double

        private static readonly byte    x_cNumeDivScaleMin = 6;     // Minimum result scale of numeric division

        // Array of multipliers for lAdjust and Ceiling/Floor.
        private static readonly uint[] x_rgulShiftBase = new uint[9] {
            10,
            10 * 10,
            10 * 10 * 10,
            10 * 10 * 10 * 10,
            10 * 10 * 10 * 10 * 10,
            10 * 10 * 10 * 10 * 10 * 10,
            10 * 10 * 10 * 10 * 10 * 10 * 10,
            10 * 10 * 10 * 10 * 10 * 10 * 10 * 10,
            10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10
        };


        // constructor
        // construct a Null
        private SqlDecimal(bool fNull) {
            m_bLen = 
            m_bPrec = 
            m_bScale = (byte)0;
            m_bStatus = 0;
            m_data1 =
            m_data2 =
            m_data3 =
            m_data4 = x_uiZero;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(Decimal value) {
            // set the null bit
            m_bStatus = x_bNotNull;

            // set the sign bit
            if (value < Decimal.Zero)
                m_bStatus |= x_bNegative;

            int[] bits = Decimal.GetBits(value);

            m_data1 = (uint)bits[0];
            m_data2 = (uint)bits[1];
            m_data3 = (uint)bits[2];
            m_data4 = x_uiZero;

            if (bits[2] != 0)
                m_bLen = 3;
            else if (bits[1] != 0)
                m_bLen = 2;
            else
                m_bLen = 1;

            // Get the scale info from Decimal
            m_bScale = (byte)((bits[3] & 0x00FF0000)>>16);

            // Initialize m_bPrec to MaxPrecision, otherwise can't call BActualPrec();
            m_bPrec = MaxPrecision;

            m_bPrec = BActualPrec();
            if (m_bPrec < m_bScale)
                m_bPrec = m_bScale;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(int value) {
            // set the null bit
            m_bStatus = x_bNotNull;

            uint uiValue = (uint) value;

            // set the sign bit
            if (value < 0) {
                m_bStatus |= x_bNegative;
                // The negative of -2147483648 doesn't fit into int32, directly cast to int should work.
                if (value != Int32.MinValue)
                    uiValue = (uint)(- value);
            }

            // set the data
            m_data1 = uiValue;
            m_data2 = m_data3 = m_data4 = x_uiZero;

            m_bLen = 1;
            m_bPrec = BGetPrecUI4(m_data1);
            m_bScale = 0;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(long value) {
            // set the null bit
            m_bStatus = x_bNotNull;

            ulong dwl = (ulong)value;

            // set the sign bit
            if (value < 0) {
                m_bStatus |= x_bNegative;
                // The negative of Int64.MinValue doesn't fit into int64, directly cast to ulong should work.
                if (value != Int64.MinValue)
                    dwl = (ulong)(- value);
            }

            // Copy DWL into bottom 2 UI4s of numeric
            m_data1 = (uint)dwl;
            m_data2 = (uint)(dwl >> 32);
            m_data3 = m_data4 = 0;

            // Trim any leading zero from the length
            m_bLen = (byte)((m_data2 == 0) ? 1 : 2);

            m_bPrec = BGetPrecUI8(dwl);
            m_bScale = 0;

            AssertValid();
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, int[] bits) {
            CheckValidPrecScale(bPrecision, bScale);
            if (bits == null)
                throw new ArgumentNullException("bits");
            else if (bits.Length != 4)
                throw new ArgumentException(SQLResource.InvalidArraySizeMessage, "bits");

            m_bPrec = bPrecision;
            m_bScale = bScale;
            m_data1 = (uint)bits[0];
            m_data2 = (uint)bits[1];
            m_data3 = (uint)bits[2];
            m_data4 = (uint)bits[3];
            m_bLen = 1;
            for (int i = 3; i >= 0; i --) {
                if (bits[i] != 0) {
                    m_bLen = (byte)(i + 1);
                    break;
                }
            }

            // set the null bit
            m_bStatus = x_bNotNull;

            // set the sign bit
            if (!fPositive) {
                m_bStatus |= x_bNegative;
            }

            // If result is -0, adjust sign to positive.
            if (FZero())
                SetPositive();

            if (bPrecision < BActualPrec())
                throw new OverflowException(SQLResource.ArithOverflowMessage);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, int data1, int data2, int data3, int data4) {
            CheckValidPrecScale(bPrecision, bScale);
            m_bPrec = bPrecision;
            m_bScale = bScale;

            m_data1 = (uint)data1;
            m_data2 = (uint)data2;
            m_data3 = (uint)data3;
            m_data4 = (uint)data4;

            m_bLen = 1;
            if (data4 == 0)
                if (data3 == 0)
                    if (data2 == 0)
                        m_bLen = 1;
                    else
                        m_bLen = 2;
                else
                    m_bLen = 3;
            else
                m_bLen = 4;

            // set the null bit
            m_bStatus = x_bNotNull;

            // set the sign bit
            if (!fPositive) {
                m_bStatus |= x_bNegative;
            }

            // If result is -0, adjust sign to positive.
            if (FZero())
                SetPositive();

            if (bPrecision < BActualPrec())
                throw new OverflowException(SQLResource.ArithOverflowMessage);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.SqlDecimal5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlDecimal(double dVal) : this(false) {
            // set the null bit
            m_bStatus = x_bNotNull;

            // Split double to sign, integer, and fractional parts
            if (dVal < 0) {
                dVal = -dVal;
                m_bStatus |= x_bNegative;
            }

            // If it will not fit into numeric(NUMERIC_MAX_PRECISION,0), overflow.
            if (dVal >= DMAX_NUME)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            double dInt = Math.Floor(dVal);
            double dFrac = dVal - dInt;

            m_bPrec  = NUMERIC_MAX_PRECISION;
            m_bLen = 1;
            if (dInt > 0.0) {
                dVal = Math.Floor (dInt / DUINT_BASE);
                m_data1 = (uint)(dInt - dVal * DUINT_BASE);
                dInt = dVal;

                if (dInt > 0.0) {
                    dVal = Math.Floor (dInt / DUINT_BASE);
                    m_data2 = (uint)(dInt - dVal * DUINT_BASE);
                    dInt = dVal;
                    m_bLen ++;

                    if (dInt > 0.0) {
                        dVal = Math.Floor (dInt / DUINT_BASE);
                        m_data3 = (uint)(dInt - dVal * DUINT_BASE);
                        dInt = dVal;
                        m_bLen ++;

                        if (dInt > 0.0) {
                            dVal = Math.Floor (dInt / DUINT_BASE);
                            m_data4 = (uint) (dInt - dVal * DUINT_BASE);
                            dInt = dVal;
                            m_bLen ++;
                        }
                    }
                }
            }

            uint ulLen, ulLenDelta;
            uint ulTemp;

            // Get size of the integer part
            ulLen = FZero() ? 0 : (uint)BActualPrec();
            SQLDebug.Check(ulLen <= NUMERIC_MAX_PRECISION, "ulLen <= NUMERIC_MAX_PRECISION", "");

            // If we got more than 17 decimal digits, zero lower ones.
            if (ulLen > DBL_DIG) {
                // Divide number by 10 while there are more then 17 digits
                uint ulWrk = ulLen - DBL_DIG;
                do {
                    ulTemp = DivByULong (10);
                    ulWrk --;
                }
                while (ulWrk > 0);
                ulWrk = ulLen - DBL_DIG;

                // Round, if necessary. # of digits can change. Cannot be overflow.
                if (ulTemp >= 5) {
                    AddULong (1);
                    ulLen = BActualPrec() + ulWrk;
                }

                // Multiply back
                do {
                    MultByULong (10);
                    ulWrk --;
                }
                while (ulWrk > 0);
            }

            m_bScale = (byte)(ulLen < DBL_DIG ? DBL_DIG - ulLen : 0);
            m_bPrec = (byte)(ulLen + m_bScale);

            // Add meaningful fractional part - max 9 digits per iteration
            if (m_bScale > 0) {
                ulLen = m_bScale;
                do {
                    ulLenDelta = (ulLen >= 9) ? 9 : ulLen;

                    dFrac *= (double) x_rgulShiftBase[(int)ulLenDelta-1];
                    ulLen -= ulLenDelta;
                    MultByULong (x_rgulShiftBase[(int)ulLenDelta-1]);
                    AddULong ((uint) dFrac);
                    dFrac -= Math.Floor (dFrac);
                }
                while (ulLen > 0);
            }

            // Round, if necessary
            if (dFrac >= 0.5) {
                AddULong (1);
            }

            if (FZero())
                SetPositive();

            AssertValid();
        }

        private SqlDecimal(uint[] rglData, byte bLen, byte bPrec, byte bScale, bool fPositive) {
            CheckValidPrecScale(bPrec, bScale);
            SQLDebug.Check(rglData.Length == 4);

            m_bLen = bLen;
            m_bPrec = bPrec;
            m_bScale = bScale;
            m_data1 = rglData[0];
            m_data2 = rglData[1];
            m_data3 = rglData[2];
            m_data4 = rglData[3];

            // set the null bit
            m_bStatus = x_bNotNull;

            // set the sign bit
            if (!fPositive) {
                m_bStatus |= x_bNegative;
            }

            // If result is -0, adjust sign to positive.
            if (FZero())
                SetPositive();
        }


        // INullable
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return(m_bStatus & x_bNullMask) == x_bIsNull;}
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Decimal Value {
            get { return ToDecimal();}
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.IsPositive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsPositive {
            get { 
                if (IsNull)
                    throw new SqlNullValueException();
                return(m_bStatus & x_bSignMask) == x_bPositive;
            }
        }

        private void SetPositive() {
            SQLDebug.Check(!IsNull);
            m_bStatus = (byte)(m_bStatus & x_bReverseSignMask);
        }

        private void SetSignBit(bool fPositive) {
            SQLDebug.Check(!IsNull);
            m_bStatus = (byte)(fPositive ? (m_bStatus & x_bReverseSignMask) : (m_bStatus | x_bNegative));
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Precision"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte Precision {
            get { 
                if (IsNull)
                    throw new SqlNullValueException();
                return m_bPrec;
            }
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Scale"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte Scale {
            get { 
                if (IsNull)
                    throw new SqlNullValueException();
                return m_bScale;
            }
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Data"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int[] Data {
            get { 
                if (IsNull)
                    throw new SqlNullValueException();
                return new int[4] { (int)m_data1, (int)m_data2, (int)m_data3, (int)m_data4};
            }
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.BinData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] BinData {
            get {
                if (IsNull)
                    throw new SqlNullValueException();

                int data1 = (int)m_data1;
                int data2 = (int)m_data2;
                int data3 = (int)m_data3;
                int data4 = (int)m_data4;
                byte[] rgBinData = new byte[16];
                rgBinData[0] = (byte)(data1 & 0xff);
                data1 >>= 8;
                rgBinData[1] = (byte)(data1 & 0xff);
                data1 >>= 8;
                rgBinData[2] = (byte)(data1 & 0xff);
                data1 >>= 8;
                rgBinData[3] = (byte)(data1 & 0xff);
                rgBinData[4] = (byte)(data2 & 0xff);
                data2 >>= 8;
                rgBinData[5] = (byte)(data2 & 0xff);
                data2 >>= 8;
                rgBinData[6] = (byte)(data2 & 0xff);
                data2 >>= 8;
                rgBinData[7] = (byte)(data2 & 0xff);
                rgBinData[8] = (byte)(data3 & 0xff);
                data3 >>= 8;
                rgBinData[9] = (byte)(data3 & 0xff);
                data3 >>= 8;
                rgBinData[10] = (byte)(data3 & 0xff);
                data3 >>= 8;
                rgBinData[11] = (byte)(data3 & 0xff);
                rgBinData[12] = (byte)(data4 & 0xff);
                data4 >>= 8;
                rgBinData[13] = (byte)(data4 & 0xff);
                data4 >>= 8;
                rgBinData[14] = (byte)(data4 & 0xff);
                data4 >>= 8;
                rgBinData[15] = (byte)(data4 & 0xff);

                return rgBinData;
            }
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            if (IsNull)
                return SQLResource.NullString;

            AssertValid();


            // Make local copy of data to avoid modifying input.
            uint[]  rgulNumeric = new uint[4] { m_data1, m_data2, m_data3, m_data4};
            int     culLen = m_bLen;
            char[]  pszTmp = new char[NUMERIC_MAX_PRECISION + 1];   //Local Character buffer to hold
                                                                    //the decimal digits, from the 
                                                                    //lowest significant to highest significant

            int     iDigits = 0;//Number of significant digits
            uint    ulRem; //Remainder of a division by x_ulBase10, i.e.,least significant digit

            // Build the final numeric string by inserting the sign, reversing 
            // the order and inserting the decimal number at the correct position

            //Retrieve each digit from the lowest significant digit
            while (culLen > 1 || rgulNumeric[0] != 0) {
                MpDiv1 (rgulNumeric, ref culLen, x_ulBase10, out ulRem);
                //modulo x_ulBase10 is the lowest significant digit
                pszTmp[iDigits++] = ChFromDigit(ulRem);
            }

            // if scale of the number has not been
            // reached pad remaining number with zeros.
            while (iDigits <= m_bScale) {
                pszTmp[iDigits++] = ChFromDigit(0);
            }

            bool fPositive = IsPositive;

            // Increment the result length if negative (need to add '-')
            int uiResultLen = fPositive ? iDigits : iDigits + 1;

            // Increment the result length if scale > 0 (need to add '.')
            if (m_bScale > 0)
                uiResultLen ++;

            char[] szResult = new char[uiResultLen];
            int iCurChar = 0;

            if (!fPositive)
                szResult[iCurChar ++] = '-';

            while (iDigits > 0) {
                if (iDigits-- == m_bScale)
                    szResult[iCurChar ++] = '.';

                szResult[iCurChar ++] = pszTmp[iDigits];
            }

            AssertValid();

            return new String(szResult);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Parse(String s) {
            if (s == null)
                throw new ArgumentNullException("s");

            SqlDecimal snResult = SqlDecimal.Null;

            char[] rgwchStr = s.ToCharArray();
            int cwchStr = rgwchStr.Length;

            int        iData;            //index to string
            char    usChar;            //current value in string
            int        lDecPnt = -1;    //position of decimal point in string
            int     iCurChar = 0;

            //Must initialize precision and scale to valid values
            snResult.m_bPrec  = 1;
            snResult.m_bScale = 0;

            //Must initialize *this to zero
            snResult.SetToZero ();

            // Trim trailing blanks.
            while (cwchStr != 0 && rgwchStr[cwchStr-1] == ' ')
                cwchStr--;

            // If string contains only spaces, stop
            if (cwchStr == 0)
                throw new FormatException(SQLResource.FormatMessage);

            // Trim leading blanks.
            while (rgwchStr[iCurChar] == ' ') {
                iCurChar++;
                cwchStr--;
            }

            // Get sign for numeric value.
            if (rgwchStr[iCurChar] == '-') {
                snResult.SetSignBit(false);
                iCurChar++;
                cwchStr--;
            }
            else {
                snResult.SetSignBit(true);
                if (rgwchStr[iCurChar] == '+') {
                    iCurChar++;
                    cwchStr--;
                }
            }

            // Hack: Check for "0.". If so, replace by ".0".
            while ((cwchStr > 2) && (rgwchStr[iCurChar] == '0')) {
                iCurChar++;
                cwchStr--;
            }
            if (2 == cwchStr && '0' == rgwchStr[iCurChar] && '.' == rgwchStr[iCurChar + 1]) {
                rgwchStr[iCurChar] = '.';
                rgwchStr[iCurChar + 1] = '0';
            }

            // Invalid string?
            if (cwchStr == 0 || cwchStr > NUMERIC_MAX_PRECISION + 1)
                throw new FormatException(SQLResource.FormatMessage);

            // Trim leading zeros.  (There shouldn't be any except for floats 
            // less than 1.  e.g.  0.01)
            while ((cwchStr > 1) && (rgwchStr[iCurChar] == '0')) {
                iCurChar++;
                cwchStr--;
            }

            // Convert string to numeric value by looping through input string.
            for(iData=0; iData < cwchStr; iData++)
            {
                usChar = rgwchStr[iCurChar];
                iCurChar ++;

                if (usChar >= '0' && usChar <= '9')
                    usChar -= '0';
                else if (usChar == '.' && lDecPnt < 0) {
                    lDecPnt = iData;
                    continue;
                }
                else
                    throw new FormatException(SQLResource.FormatMessage);

                snResult.MultByULong(x_ulBase10);
                snResult.AddULong(usChar);
            }

            // Save precision and scale.
            if (lDecPnt < 0) {
                snResult.m_bPrec  = (byte)iData;
                snResult.m_bScale = 0;
            }
            else {
                snResult.m_bPrec =  (byte)(iData - 1);
                snResult.m_bScale = (byte) (snResult.m_bPrec - lDecPnt);
            }

            //Check for overflow condition
            if (snResult.m_bPrec > NUMERIC_MAX_PRECISION)
                throw new FormatException(SQLResource.FormatMessage);

            // Check for invalid precision for numeric value. 
            // e.g., when string is ".", precision will be 0
            if (snResult.m_bPrec == 0)
                throw new FormatException(SQLResource.FormatMessage);

            // If result is -0, adjust sign to positive.
            if (snResult.FZero())
                snResult.SetPositive();

            snResult.AssertValid();

            return snResult;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToDouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public double ToDouble() {
            if (IsNull)
                throw new SqlNullValueException();

            double dRet = 0.0;

            dRet = (double)m_data4;
            dRet = dRet * x_lInt32Base + m_data3;
            dRet = dRet * x_lInt32Base + m_data2;
            dRet = dRet * x_lInt32Base + m_data1;

            dRet /= System.Math.Pow(10.0, m_bScale);

            return IsPositive ? dRet : - dRet;
        }

        private Decimal ToDecimal() {
            if (IsNull)
                throw new SqlNullValueException();

            if ((int)m_data4 != 0 || m_bScale > 28)
                throw new OverflowException(SQLResource.ConversionOverflowMessage);

            return new Decimal((int)m_data1, (int)m_data2, (int)m_data3, !IsPositive, m_bScale);
        }

        // Implicit conversion from Decimal to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(Decimal x) {
            return new SqlDecimal(x);
        }

        // Explicit conversion from SqlDecimal to Decimal. Throw exception if x is Null.
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator Decimal(SqlDecimal x) {
            return x.Value;
        }


        // Unary operators
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal operator -(SqlDecimal x) {
            if (x.IsNull)
                return Null;
            else {
                SqlDecimal s = x;
                if (s.FZero())
                    s.SetPositive();
                else
                    s.SetSignBit(!s.IsPositive);
                return s;
            }
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal operator +(SqlDecimal x, SqlDecimal y) {
            if (x.IsNull || y.IsNull)
                return Null;

            ulong   dwlAccum;           //accumulated sum
            bool    fMySignPos;         //sign of x was positive at start
            bool    fOpSignPos;         // sign of y positive at start
            bool    fResSignPos = true; //sign of result should be positive
            int     MyScale;    //scale of x
            int     OpScale;    //scale of y
            int     ResScale;   //scale of result
            int     ResPrec;    //precision of result
            int     ResInteger; //number of digits for the integer part of result
            int     culOp1;     //# of UI4s in x
            int     culOp2;     //# of UI4s in y
            int     iulData;    //which UI4 we are operating on in x, y
            byte    bLen;       // length for the result


            x.AssertValid();
            y.AssertValid();

            fMySignPos = x.IsPositive;
            fOpSignPos = y.IsPositive;

            //result scale = max(s1,s2)
            //result precison = max(s1,s2) + max(p1-s1,p2-s2)
            MyScale = x.m_bScale;
            OpScale = y.m_bScale;

            // Calculate the integer part of the result.
            ResInteger = Math.Max((int)x.m_bPrec - MyScale, (int)y.m_bPrec - OpScale);
            SQLDebug.Check (ResInteger <= MaxPrecision);

            // Calculate the scale of the result.
            ResScale = Math.Max(MyScale, OpScale);
            SQLDebug.Check (ResScale <= MaxScale);

            // Calculate the precision of the result.
            // Add 1 for final carry.
            ResPrec = ResInteger + ResScale + 1;
            ResPrec = Math.Min(MaxPrecision, ResPrec);

            // If precision adjusted, scale is reduced to keep the integer part untruncated.
            // But discard the extra carry, only keep the interger part as ResInteger, not ResInteger + 1.
            SQLDebug.Check(ResPrec - ResInteger >= 0);
            if (ResPrec - ResInteger < ResScale)
                ResScale = ResPrec - ResInteger;

            // Adjust both operands to be the same scale as ResScale.
            if (MyScale != ResScale)
                x.AdjustScale(ResScale - MyScale, true);

            if (OpScale != ResScale)
                y.AdjustScale(ResScale - OpScale, true);

            // When sign of first operand is negative
            // negate all operands including result.
            if (!fMySignPos) {
                fMySignPos = !fMySignPos;
                fOpSignPos = !fOpSignPos;
                fResSignPos = !fResSignPos;
            }

            // Initialize operand lengths and pointer.
            culOp1 = x.m_bLen;
            culOp2 = y.m_bLen;

            uint[] rglData1 = new uint[4] {x.m_data1, x.m_data2, x.m_data3, x.m_data4};
            uint[] rglData2 = new uint[4] {y.m_data1, y.m_data2, y.m_data3, y.m_data4};

            if (fOpSignPos) {
                dwlAccum = 0;

                // CONSIDER: Call AddUlong when possible

                // Loop through UI4s adding operands and putting result in *this
                // of the operands and put result in *this
                for (iulData = 0; iulData < culOp1 || iulData < culOp2; iulData++) {
                    // None of these DWORDLONG additions can overflow, as dwlAccum comes in < x_lInt32Base
                    if (iulData < culOp1)
                        dwlAccum += rglData1[iulData];
                    if (iulData < culOp2)
                        dwlAccum += rglData2[iulData];

                    rglData1[iulData] = (uint)dwlAccum; // equiv to mod x_lInt32Base
                    dwlAccum >>= 32; // equiv to div x_lInt32Base
                }

                //If carry
                if (dwlAccum != 0) {
                    SQLDebug.Check(dwlAccum < x_ulInt32Base);

                    //Either overflowed
                    if (iulData == x_cNumeMax)
                        throw new OverflowException(SQLResource.ArithOverflowMessage);

                    // Or extended length
                    rglData1[iulData] = (uint)dwlAccum;
                    iulData ++;
                }

                // Set result length
                bLen = (byte) iulData;
            }
            else {
                int iulLastNonZero = 0; // The last nonzero UI

                // When second operand is negative, switch operands
                // if operand2 is greater than operand1
                if (x.LAbsCmp (y) < 0) {
                    fResSignPos = !fResSignPos;
                    uint[] rguiTemp = rglData2;
                    rglData2 = rglData1;
                    rglData1 = rguiTemp;
                    culOp1 = culOp2;
                    culOp2 = x.m_bLen;
                }

                dwlAccum = x_ulInt32Base;
                for (iulData = 0; iulData < culOp1 || iulData < culOp2; iulData++) {
                    if (iulData < culOp1)
                        dwlAccum += rglData1[iulData];
                    if (iulData < culOp2)
                        dwlAccum -= rglData2[iulData];

                    rglData1[iulData] = (uint)dwlAccum; // equiv to mod BaseUI4
                    if (rglData1[iulData] != 0)
                        iulLastNonZero = iulData;
                    dwlAccum >>= 32; // equiv to /= BaseUI4
                    dwlAccum += x_ulInt32BaseForMod; // equiv to BaseUI4 - 1
                }
                // Set length based on highest non-zero ULONG
                bLen = (byte) (iulLastNonZero + 1);
            }

            SqlDecimal ret = new SqlDecimal(rglData1, bLen, (byte)ResPrec, (byte)ResScale, fResSignPos);

            if (ret.BActualPrec () > NUMERIC_MAX_PRECISION)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            if (ret.FZero())
                ret.SetPositive();

            ret.AssertValid();

            return ret;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal operator -(SqlDecimal x, SqlDecimal y) {
            return x + (-y);
        }

        //    MultNm()
        //
        //    Multiply two numerics.
        //
        //  Parameters:
        //        x    - IN Multiplier
        //        y    - IN Multiplicand
        //
        //    Result scale and precision(same as in SQL Server Manual and Hydra):
        //        scale = s1 + s2
        //        precison = s1 + s2 + (p1 - s1) + (p2 - s2) + 1
        //    
        //    Overflow Rules:
        //        If scale is greater than NUMERIC_MAX_PRECISION it is set to 
        //    NUMERIC_MAX_PRECISION.  If precision is greater than NUMERIC_MAX_PRECISION 
        //    it is set to NUMERIC_MAX_PRECISION, then scale is reduced to keep the
        //    integer part untruncated but keeping a minimum value of x_cNumeDivScaleMin.
        //    For example, if using the above formula, the resulting precision is 46 and
        //    scale is 10, the precision will be reduced to 38. To keep the integral part
        //    untruncated the scale needs be reduced to 2, but since x_cNumeDivScaleMin
        //    is set to 6 currently, resulting scale will be 6.
        //        O_OVERFLOW is returned only if the actual precision is greater than
        //     NUMERIC_MAX_PRECISION or the actual length is greater than x_cbNumeBuf.
        //
        //    Algorithm:
        //        Starting from the lowest significant UI4, for each UI4 of the multiplier
        //    iterate through the UI4s of the multiplicand starting from 
        //    the least significant UI4s, multiply the multiplier UI4 with
        //    multiplicand UI4, update the result buffer with the product modulo
        //    x_dwlBaseUI4 at the same index as the multiplicand, and carry the quotient to
        //    add to the next multiplicand UI4.  Until the end of the multiplier data 
        //    array is reached.
        //
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal operator *(SqlDecimal x, SqlDecimal y) {
            x.AssertValid();
            y.AssertValid();

            if (x.IsNull || y.IsNull)
                return Null;

            //Implementation: 
            //        I) Figure result scale,prec
            //        II) Perform mult.
            //        III) Adjust product to result scale,prec        

            // Local variables for actual multiplication
            int     iulPlier;           //index of UI4 in the Multiplier
            uint    ulPlier;            //current mutiplier UI4
            ulong   dwlAccum;           //accumulated sum
            ulong   dwlNextAccum;       //overflow of accumulated sum
            int     culCand = y.m_bLen; //length of multiplicand in UI4s

            //Local variables to track scale,precision
            int ActualScale;                    // Scale after mult done
            int ResScale;                       // Final scale we will force result to
            int ResPrec;                        // Final precision we will force result to
            int ResInteger;                     // # of digits in integer part of result (prec-scale)
            int lScaleAdjust;   //How much result scale will be adjusted
            bool fResPositive;  // Result sign

            SqlDecimal  ret;


            //I) Figure result prec,scale
            ActualScale = x.m_bScale + y.m_bScale;
            ResScale = ActualScale;
            ResInteger = (x.m_bPrec - x.m_bScale) + (y.m_bPrec - y.m_bScale) + 1;

            //result precison = s1 + s2 + (p1 - s1) + (p2 - s2) + 1
            ResPrec = ResScale + ResInteger;

            // Downward adjust res prec,scale if either larger than NUMERIC_MAX_PRECISION
            if (ResPrec >  NUMERIC_MAX_PRECISION)
                ResPrec = NUMERIC_MAX_PRECISION;
            if (ResScale > NUMERIC_MAX_PRECISION)
                ResScale = NUMERIC_MAX_PRECISION;

            //
            // It is possible when two large numbers are being multiplied the scale 
            // can be reduced to 0 to keep data untruncated; the fix here is to 
            // preserve a minimum scale of 6.
            //
            // If overflow, reduce the scale to avoid truncation of data
            ResScale = Math.Min((ResPrec - ResInteger),ResScale);
            // But keep a minimum scale of NUMERIC_MIN_DVSCALE
            ResScale = Math.Max(ResScale, Math.Min(ActualScale,x_cNumeDivScaleMin));

            lScaleAdjust = ResScale - ActualScale;

            fResPositive = (x.IsPositive == y.IsPositive);//positive if both signs same.

            // II) Perform multiplication

            uint[] rglData1 = new uint[4] {x.m_data1, x.m_data2, x.m_data3, x.m_data4};
            uint[] rglData2 = new uint[4] {y.m_data1, y.m_data2, y.m_data3, y.m_data4};

            //Local buffer to hold the result of multiplication. 
            //Longer than CReNumeBuf because full precision of multiplication is carried out
            const int   x_culNumeMultRes = 9;       // Maximum # UI4s in result buffer in multiplication
            uint[]      rgulRes = new uint[x_culNumeMultRes];;
            int         culRes;             // # of UI4s in result
            int         idRes;

            // Zero result buffer
            for (idRes = 0; idRes < x_culNumeMultRes; idRes ++)
                rgulRes[idRes] = 0;


            //Iterate over the bytes of multiplier
            for (iulPlier = 0; iulPlier < x.m_bLen; iulPlier++) {
                ulPlier = rglData1[iulPlier];
                dwlAccum = 0;

                //Multiply each UI4 of multiCand by ulPliear and accumulate into result buffer

                // Start on correct place in result
                idRes = iulPlier;

                for (int iulCand = 0; iulCand < culCand; iulCand++) {
                    // dwlAccum = dwlAccum + rgulRes[idRes] + ulPlier*rglData2[iulCand]
                    //        use dwlNextAccum to detect overflow of DWORDLONG
                    dwlNextAccum = dwlAccum + rgulRes[idRes];
                    ulong ulTemp = (ulong)rglData2[iulCand];
                    dwlAccum =  (ulong)ulPlier * ulTemp;
                    dwlAccum += dwlNextAccum; 
                    if (dwlAccum < dwlNextAccum) // indicates dwl addition overflowed
                        dwlNextAccum = x_ulInt32Base; // = maxUI64/x_dwlBaseUI4
                    else
                        dwlNextAccum = 0;

                    // Update result and accum
                    rgulRes[idRes ++] = (uint)(dwlAccum);// & x_ulInt32BaseForMod); // equiv to mod x_lInt32Base
                    dwlAccum = (dwlAccum >> 32) + dwlNextAccum; // equiv to div BaseUI4 + dwlNAccum

                    // dwlNextAccum can't overflow next iteration
                    SQLDebug.Check(dwlAccum < x_ulInt32Base*2);
                }

                SQLDebug.Check(dwlAccum < x_ulInt32Base); // can never final accum > 1 more UI4
                if (dwlAccum != 0)
                    rgulRes[idRes ++] = (uint)dwlAccum;
            }
            // Skip leading 0s (may exist if we are multiplying by 0)
            for (;(rgulRes[idRes] == 0) && (idRes > 0); idRes--)
                ;
            // Calculate actual result length
            culRes = idRes + 1;

            // III) Adjust precision,scale to result prec,scale
            if (lScaleAdjust != 0) {
                // If need to decrease scale
                if (lScaleAdjust < 0) {
                    SQLDebug.Check(NUMERIC_MAX_PRECISION == ResPrec);

                    // have to adjust - might yet end up fitting.
                    // Cannot call AdjustScale - number cannot fit in a numeric, so
                    // have to duplicate code here

                    uint    ulRem;          //Remainder when downshifting
                    uint    ulShiftBase;    //What to multiply by to effect scale adjust

                    do {
                        if (lScaleAdjust <= -9) {
                            ulShiftBase = x_rgulShiftBase[8];
                            lScaleAdjust += 9;
                        }
                        else {
                            ulShiftBase = x_rgulShiftBase[-lScaleAdjust - 1];
                            lScaleAdjust = 0;
                        }
                        MpDiv1 (rgulRes, ref culRes, ulShiftBase, out ulRem);
                    }
                    while (lScaleAdjust != 0);

                    // Still do not fit?
                    if (culRes > x_cNumeMax)
                        throw new OverflowException(SQLResource.ArithOverflowMessage);

                    //move the Result to rglData1
                    for (idRes = 0; idRes < culRes; idRes ++)
                        rglData1[idRes] = rgulRes[idRes];
                    for (idRes = culRes; idRes < x_cNumeMax; idRes ++)
                        rglData1[idRes] = 0;
                    ret = new SqlDecimal(rglData1, (byte)culRes, (byte)ResPrec, (byte)ResScale, fResPositive);

                    // Is it greater than 10**38?
                    if (ret.FGt10_38())
                        throw new OverflowException(SQLResource.ArithOverflowMessage);

                    ret.AssertValid();

                    // If remainder is 5 or above, increment/decrement by 1.
                    if (ulRem >= ulShiftBase/2)
                        ret.AddULong(1);
                    // After adjusting, if the result is 0 and remainder is less than 5,
                    // set the sign to be positive
                    if (ret.FZero ())
                        ret.SetPositive();

                    return ret;
                }

                // Otherwise call AdjustScale
                if (culRes > x_cNumeMax)    // Do not fit now, so will not fit after asjustement
                    throw new OverflowException(SQLResource.ArithOverflowMessage);
                // NOTE: Have not check for value in the range (10**38..2**128),
                // as we'll call AdjustScale with positive argument, and it'll
                // return "normal" overflow

                //move the Result to rglData1
                for (idRes = 0; idRes < culRes; idRes ++)
                    rglData1[idRes] = rgulRes[idRes];
                for (idRes = culRes; idRes < x_cNumeMax; idRes ++)
                    rglData1[idRes] = 0;
                ret = new SqlDecimal(rglData1, (byte)culRes, (byte)ResPrec, (byte)ActualScale, fResPositive);

                if (ret.FZero ())
                    ret.SetPositive();

                ret.AssertValid();

                ret.AdjustScale(lScaleAdjust, true);

                return ret;
            }
            else {
                if (culRes > x_cNumeMax)
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                //move the Result to rglData1
                for (idRes = 0; idRes < culRes; idRes ++)
                    rglData1[idRes] = rgulRes[idRes];
                for (idRes = culRes; idRes < x_cNumeMax; idRes ++)
                    rglData1[idRes] = 0;
                ret = new SqlDecimal(rglData1, (byte)culRes, (byte)ResPrec, (byte)ResScale, fResPositive);

                // Is it greater than 10**38?
                if (ret.FGt10_38 ())
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                if (ret.FZero ())
                    ret.SetPositive();

                ret.AssertValid();

                return ret;
            }
        }

        //-----------------------------------------------------------
        //DivNm(): 
        //  Divide numeric by numeric.  
        //    The Quotient will be returned in *this
        //
        //Result scale&precision: 
        //    NOTE: same as in Hydra but different from SQL Server Manual, 
        //            where scale = max(s1+p2-s2+1,x_cNumeDivScaleMin)):
        //        scale = max(s1 + p2 + 1, x_cNumeDivScaleMin);
        //        precision = max(s1 + p2 + 1, x_cNumeDivScaleMin) + p1 + p2 + 1;
        //
        //Overflow Rules:
        //        If scale is greater than NUMERIC_MAX_PRECISION it is set to 
        //    NUMERIC_MAX_PRECISION.  If precision is greater than NUMERIC_MAX_PRECISION 
        //    it's set to NUMERIC_MAX_PRECISION, then scale is reduced to keep the
        //    integer part untruncated but keeping a minimum value of x_cNumeDivScaleMin.
        //    For example, if using the above formula, the resulting precision is 46 and
        //    scale is 10, the precision will be reduced to 38, to keep the integral part
        //    untruncated the scale needs be recuded to 2, but since x_cNumeDivScaleMin
        //    is set to 6 currently, resulting scale will be 6.
        //        OverflowException is throwed only if the actual precision is greater than 
        //    NUMERIC_MAX_PRECISION or actual length is greater than x_cbNumeBuf
        //
        //Algorithm
        //  Call general purpose arbitrary precision division routine with scale = 0.
        //    Scale,prec adjusted later. 
        //
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal operator /(SqlDecimal x, SqlDecimal y) {
            if (x.IsNull || y.IsNull)
                return Null;

            x.AssertValid();
            y.AssertValid();

            // Variables for figuring prec,scale
            int bScaleD;            // Input Scale of dividend (output scale of remainder)
            int bPrecD;             // Input Prec of dividend (output prec of remainder)
            int ResScale;           // Final scale we will force quotient to
            int ResPrec;            // Final precision we will force quotient to
            int ResInteger;         // # of digits in integer part of result (prec-scale)
            int MinScale;           // Temp to help compute ResScale
            int lScaleAdjust;       // How much result scale will be adjusted
            bool fResSignPos;       // sign of result

            // Steps:
            //    1) Figure result prec,scale; adjust scale of dividend
            //    2) Compute result remainder/quotient in 0 scale numbers
            //    3) Set result prec,scale and adjust as necessary

            // 0) Check for Div by 0
            if (y.FZero())
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);

            // 1) Figure out result prec,scale,sign..
            fResSignPos = (x.IsPositive == y.IsPositive);//sign of result

            //scale = max(s1 + p2 + 1, x_cNumeDivScaleMin);
            //precision = max(s1 + p2 + 1, x_cNumeDivScaleMin) + p1 + p2 + 1;
            //For backward compatibility, use exactly the same scheme as in Hydra
            bScaleD = x.m_bScale;
            bPrecD = x.m_bPrec;
            ResScale = Math.Max(x.m_bScale + y.m_bPrec + 1, x_cNumeDivScaleMin);
            ResInteger = x.m_bPrec - x.m_bScale + y.m_bScale;
            ResPrec = ResScale + x.m_bPrec + y.m_bPrec + 1;
            MinScale = Math.Min(ResScale, x_cNumeDivScaleMin);

            ResInteger = Math.Min(ResInteger, NUMERIC_MAX_PRECISION);
            ResPrec = ResInteger + ResScale;

            if (ResPrec >  NUMERIC_MAX_PRECISION)
                ResPrec = NUMERIC_MAX_PRECISION;

            // If overflow, reduce the scale to avoid truncation of data
            ResScale = Math.Min((ResPrec - ResInteger), ResScale);
            ResScale = Math.Max(ResScale, MinScale);

            //Adjust the scale of the dividend
            lScaleAdjust = ResScale - (int)x.m_bScale + (int)y.m_bScale;
            x.AdjustScale(lScaleAdjust, true);

            // Step2: Actual Computation

            uint[] rgulData1 = new uint[4] {x.m_data1, x.m_data2, x.m_data3, x.m_data4};
            uint[] rgulData2 = new uint[4] {y.m_data1, y.m_data2, y.m_data3, y.m_data4};

            // Buffers for arbitrary precision divide
            uint[] rgulR = new uint[x_cNumeMax + 1];
            uint[] rgulQ = new uint[x_cNumeMax];
            // # of ULONGs in result
            int culQ, culR;

            // Divide mantissas. V is not zero - already checked.
            // Cannot overflow, as Q <= U, R <= V. (and both are positive)
            MpDiv(rgulData1, x.m_bLen, rgulData2, y.m_bLen, rgulQ, out culQ, rgulR, out culR);

            // Construct the result from Q
            ZeroToMaxLen (rgulQ, culQ);
            SqlDecimal ret = new SqlDecimal(rgulQ, (byte)culQ, (byte)ResPrec, (byte)ResScale, fResSignPos);

            if (ret.FZero())
                ret.SetPositive();

            ret.AssertValid();

            return ret;
        }



        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDecimal(SqlBoolean x) {
            return x.IsNull ? Null : new SqlDecimal((int)x.ByteValue);
        }

        // Implicit conversion from SqlByte to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(SqlByte x) {
            return x.IsNull ? Null : new SqlDecimal((int)(x.Value));
        }

        // Implicit conversion from SqlInt16 to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(SqlInt16 x) {
            return x.IsNull ? Null : new SqlDecimal((int)(x.Value));
        }

        // Implicit conversion from SqlInt32 to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(SqlInt32 x) {
            return x.IsNull ? Null : new SqlDecimal(x.Value);
        }

        // Implicit conversion from SqlInt64 to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(SqlInt64 x) {
            return x.IsNull ? Null : new SqlDecimal(x.Value);
        }

        // Implicit conversion from SqlMoney to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlDecimal(SqlMoney x) {
            return x.IsNull ? Null : new SqlDecimal(x.ToDecimal());
        }


        // Explicit conversions

         // Explicit conversion from SqlSingle to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDecimal(SqlSingle x) {
            return x.IsNull ? SqlDecimal.Null : new SqlDecimal((double)(x.Value));
        }

       // Explicit conversion from SqlDouble to SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDecimal(SqlDouble x) {
            return x.IsNull ? SqlDecimal.Null : new SqlDecimal(x.Value);
        }

        // Explicit conversion from SqlString to SqlDecimal
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorSqlDecimal9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlDecimal(SqlString x) {
            return x.IsNull ? Null : SqlDecimal.Parse(x.Value);
        }

        // private methods

        //----------------------------------------------------------------------
        // Is this RE numeric valid?
        [System.Diagnostics.Conditional("DEBUG")]
        private void AssertValid() {
            if (IsNull)
                return;

            // Scale,Prec in range
            SQLDebug.Check(m_bScale <= NUMERIC_MAX_PRECISION, "m_bScale <= NUMERIC_MAX_PRECISION", "In AssertValid");
            SQLDebug.Check(m_bScale <= m_bPrec, "m_bScale <= m_bPrec", "In AssertValid");
            SQLDebug.Check(m_bScale >= 0, "m_bScale >= 0", "In AssertValid");
            SQLDebug.Check(m_bPrec > 0, "m_bPrec > 0", "In AssertValid");

            SQLDebug.Check(CLenFromPrec(m_bPrec) >= m_bLen, "CLenFromPrec(m_bPrec) >= m_bLen", "In AssertValid");
            SQLDebug.Check(m_bLen <= x_cNumeMax, "m_bLen <= x_cNumeMax", "In AssertValid"); 

            uint[] rglData = new uint[4] {m_data1, m_data2, m_data3, m_data4};

            // highest UI4 is non-0 unless value "zero"    
            if (rglData[m_bLen-1] == 0) {
                SQLDebug.Check(m_bLen == 1, "m_bLen == 1", "In AssertValid");
            }

            // All UI4s from length to end are 0
            for (int iulData = m_bLen; iulData < x_cNumeMax; iulData++)
                SQLDebug.Check(rglData[iulData] == 0, "rglData[iulData] == 0", "In AssertValid");
        }

        // print the data members
        [System.Diagnostics.Conditional("DEBUG")]
        private void Print() {
            if (IsNull) {
                Debug.WriteLine("Numeric: Null");
                return;
            }
            Debug.WriteLine("Numeric: data - " + m_data4.ToString() + ", " + m_data3.ToString() + ", " + 
                              m_data2.ToString() + ", " + m_data1.ToString());
            Debug.WriteLine("\tlen = " + m_bLen.ToString() + ", Prec = " + m_bPrec.ToString() + 
                              ", Scale = " + m_bScale.ToString() + ", Sign = " + IsPositive.ToString());
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void Print(String s) {
            Debug.WriteLine("*** " + s + " ***");
            if (IsNull) {
                Debug.WriteLine("Numeric: Null");
                return;
            }
            Debug.WriteLine("Numeric: data - " + m_data4.ToString() + ", " + m_data3.ToString() + ", " + 
                              m_data2.ToString() + ", " + m_data1.ToString());
            Debug.WriteLine("\tlen = " + m_bLen.ToString() + ", Prec = " + m_bPrec.ToString() + 
                              ", Scale = " + m_bScale.ToString() + ", Sign = " + IsPositive.ToString());
        }

        // Set all extra uints to zero
        private static void ZeroToMaxLen(uint[] rgulData, int cUI4sCur) {
            SQLDebug.Check(rgulData.Length == x_cNumeMax, "rgulData.Length == x_cNumeMax", "Invalid array length");

            switch (cUI4sCur) {
                case 1:
                    rgulData[1] = rgulData[2] = rgulData[3] = 0;
                    break;

                case 2:
                    rgulData[2] = rgulData[3] = 0;
                    break;

                case 3:
                    rgulData[3] = 0;
                    break;
            }
        }

        // Set all extra uints to zero
        private void ZeroToMaxLen(int cUI4sCur) {
            switch (cUI4sCur) {
                case 1:
                    m_data2 = m_data3 = m_data4 = x_uiZero;
                    break;

                case 2:
                    m_data3 = m_data4 = x_uiZero;
                    break;

                case 3:
                    m_data4 = x_uiZero;
                    break;
            }
        }

        //Determine the number of uints needed for a numeric given a precision
        //Precision        Length
        //    0            invalid
        //    1-9            1
        //    10-19        2
        //    20-28        3
        //    29-38        4
        // The array in Shiloh. Listed here for comparison.
        //private static readonly byte[] rgCLenFromPrec = new byte[] {5,5,5,5,5,5,5,5,5,9,9,9,9,9,
        //    9,9,9,9,9,13,13,13,13,13,13,13,13,13,17,17,17,17,17,17,17,17,17,17};
        private static readonly byte[] rgCLenFromPrec = new byte[] {1,1,1,1,1,1,1,1,1,2,2,2,2,2,
            2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4};

        private static byte CLenFromPrec(byte bPrec) {
            SQLDebug.Check(bPrec <= MaxPrecision && bPrec > 0, "bPrec <= MaxPrecision && bPrec > 0", 
                           "Invalid numeric precision");
            return rgCLenFromPrec[bPrec-1];
        }

        // check whether is zero
        private bool FZero() {
            return(m_data1 == 0) && (m_bLen <= 1);
        }

        // Find the case where we overflowed 10**38, but not 2**128
        private bool FGt10_38() {
            return    m_data4 >= 0x4b3b4ca8L && m_bLen == 4 && 
            ((m_data4 > 0x4b3b4ca8L) || (m_data3 > 0x5a86c47aL) ||
             (m_data3 == 0x5a86c47aL) && (m_data2 >= 0x098a2240L));
        }

        private bool FGt10_38(uint[] rglData) {
            SQLDebug.Check(rglData.Length == 4, "rglData.Length == 4", "Wrong array length: " + rglData.Length.ToString());

            return    rglData[3] >= 0x4b3b4ca8L && 
            ((rglData[3] > 0x4b3b4ca8L) || (rglData[2] > 0x5a86c47aL) ||
             (rglData[2] == 0x5a86c47aL) && (rglData[1] >= 0x098a2240L));
        }


        // Powers of ten (used by BGetPrecI4,BGetPrecI8)
        private static readonly uint x_ulT1 =       10;
        private static readonly uint x_ulT2 =       100;
        private static readonly uint x_ulT3 =       1000;
        private static readonly uint x_ulT4 =       10000;
        private static readonly uint x_ulT5 =       100000;
        private static readonly uint x_ulT6 =       1000000;
        private static readonly uint x_ulT7 =       10000000;
        private static readonly uint x_ulT8 =       100000000;
        private static readonly uint x_ulT9 =       1000000000;
        private static readonly ulong x_dwlT10 =    10000000000;
        private static readonly ulong x_dwlT11 =    100000000000;
        private static readonly ulong x_dwlT12 =    1000000000000;
        private static readonly ulong x_dwlT13 =    10000000000000;
        private static readonly ulong x_dwlT14 =    100000000000000;
        private static readonly ulong x_dwlT15 =    1000000000000000;
        private static readonly ulong x_dwlT16 =    10000000000000000;
        private static readonly ulong x_dwlT17 =    100000000000000000;
        private static readonly ulong x_dwlT18 =    1000000000000000000;
        private static readonly ulong x_dwlT19 =    10000000000000000000;

        //------------------------------------------------------------------
        //BGetPrecI4 
        //    Return the precision(number of significant digits) of a integer
        private static byte BGetPrecUI4(uint value) {
            int ret;

            // Now do the (almost) binary search
            if (value < x_ulT4) {
                if (value < x_ulT2)
                    ret = value >= x_ulT1 ? 2 : 1;
                else
                    ret = value >= x_ulT3 ? 4 : 3;
            }
            else if (value < x_ulT8) {
                if (value < x_ulT6)
                    ret = value >= x_ulT5 ? 6 : 5;
                else
                    ret = value >= x_ulT7 ? 8 : 7;
            }
            else
                ret = value >= x_ulT9 ? 10 : 9;

            return(byte)ret;
        }

        //------------------------------------------------------------------
        //BGetPrecI8 
        //    Return the precision (number of significant digits) of an Int8
        private static byte  BGetPrecUI8(ulong dwlVal) {
            int ret;

            // Now do the (almost) binary search
            if (dwlVal < x_ulT8) {
                uint ulVal = (uint) dwlVal;

                if (ulVal < x_ulT4) {
                    if (ulVal < x_ulT2)
                        ret = (ulVal >= x_ulT1) ? 2 : 1;
                    else
                        ret = (ulVal >= x_ulT3) ? 4 : 3;
                }
                else {
                    if (ulVal < x_ulT6)
                        ret = (ulVal >= x_ulT5) ? 6 : 5;
                    else
                        ret = (ulVal >= x_ulT7) ? 8 : 7;
                }
            }
            else if (dwlVal < x_dwlT16) {
                if (dwlVal < x_dwlT12) {
                    if (dwlVal < x_dwlT10)
                        ret = (dwlVal >= x_ulT9) ? 10 : 9;
                    else
                        ret = (dwlVal >= x_dwlT11) ? 12 : 11;
                }
                else {
                    if (dwlVal < x_dwlT14)
                        ret = (dwlVal >= x_dwlT13) ? 14 : 13;
                    else
                        ret = (dwlVal >= x_dwlT15) ? 16 : 15;
                }
            }
            else {
                if (dwlVal < x_dwlT18)
                    ret = (dwlVal >= x_dwlT17) ? 18 : 17;
                else
                    ret = (dwlVal >= x_dwlT19) ? 20 : 19;
            }

            return(byte)ret;
        }


        // Low-level routine: return # of digits in U4 or U8 in memory

        private static int IActualPrec(uint[] piulN, int ciulU) {
            SQLDebug.Check (ciulU == 1 || ciulU == 2);
            if (ciulU == 1) {
                return BGetPrecUI4 (piulN[0]);
            }
            else {
                ulong dwlVal = ((ulong) piulN[0]) + (((ulong) piulN[1]) << 32);
                return BGetPrecUI8 (dwlVal);
            }
        }

        //
        //    BActualPrec()
        //
        //    Determine the actual number of significant digits (precision) of a numeric
        //
        //    Parameters:
        //
        //    Complexity:
        //        For small numerics, use simpler routines = O(n)
        //        Else, max 3 divisions of mp by ULONG, then again simpler routine.
        //
        //    Returns:
        //        a byte containing the actual precision
        //
        private byte BActualPrec () {
            if (m_bPrec == 0 || m_bLen < 1)
                return 0;

            uint[]  rgulU = new uint[4] { m_data1, m_data2, m_data3, m_data4};
            int     ciulU = m_bLen;
            int     Prec;
            uint    ulRem;

            if (ciulU <= 2)
                Prec = IActualPrec (rgulU, ciulU);
            else {
                Prec = 0;
                do {
                    MpDiv1 (rgulU, ref ciulU, 1000000000, out ulRem);
                    Prec += 9;
                }
                while (ciulU > 2);
                SQLDebug.Check (Prec == 9 || Prec == 18 || Prec == 27);
                Prec += IActualPrec (rgulU, ciulU);
            }

            // If number of significant digits less than scale, return scale
            return(Prec < m_bScale ? m_bScale : (byte)Prec);
        }

        //    AddULong()
        //
        //    Add ulAdd to this numeric.  The result will be returned in *this.
        //        
        //    Parameters:
        //        this    - IN Operand1 & OUT Result
        //        ulAdd    - IN operand2.
        //
        private void AddULong(uint ulAdd) {
            ulong   dwlAccum = (ulong) ulAdd;
            int     iData;                  // which UI4 in this we are on
            int     iDataMax = (int)m_bLen; // # of UI4s in this

            uint[] rguiData = new uint[4] { m_data1, m_data2, m_data3, m_data4};

            // Add, starting at the LS UI4 until out of UI4s or no carry
            iData = 0;
            do {
                dwlAccum += (ulong) rguiData[iData];
                rguiData[iData] = (uint)dwlAccum;       // equivalent to mod x_dwlBaseUI4
                dwlAccum >>= 32;                        // equivalent to dwlAccum /= x_dwlBaseUI4;
                if (0 == dwlAccum) {
                    StoreFromWorkingArray(rguiData);
                    return;
                }
                iData ++;
            }
            while (iData < iDataMax);

            // There is carry at the end

            SQLDebug.Check(dwlAccum < x_ulInt32Base, "dwlAccum < x_lInt32Base", "");

            // Either overflowed
            if (iData == x_cNumeMax)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            // Or need to extend length by 1 UI4
            rguiData[iData] = (uint)dwlAccum;
            m_bLen ++;

            if (FGt10_38 (rguiData))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            StoreFromWorkingArray(rguiData);
        }

        // multiply by a long integer
        private void MultByULong(uint uiMultiplier) {
            int     iDataMax = m_bLen; // How many UI4s currently in *this

            ulong   dwlAccum = 0;       // accumulated sum
            ulong   dwlNextAccum = 0;   // accumulation past dwlAccum
            int     iData;              // which UI4 in *This we are on.

            uint[] rguiData = new uint[4] { m_data1, m_data2, m_data3, m_data4};

            for (iData = 0; iData < iDataMax; iData++) {
                SQLDebug.Check(dwlAccum < x_ulInt32Base);

                ulong ulTemp = (ulong)rguiData[iData];
                dwlNextAccum = ulTemp * (ulong)uiMultiplier;
                dwlAccum += dwlNextAccum;
                if (dwlAccum < dwlNextAccum)        // Overflow of int64 add
                    dwlNextAccum = x_ulInt32Base;   // how much to add to dwlAccum after div x_dwlBaseUI4
                else
                    dwlNextAccum = 0;
                rguiData[iData] = (uint)dwlAccum;           // equivalent to mod x_dwlBaseUI4
                dwlAccum = (dwlAccum >> 32) + dwlNextAccum; // equivalent to div x_dwlBaseUI4
            }

            // If any carry, 
            if (dwlAccum != 0) {
                // Either overflowed
                SQLDebug.Check(dwlAccum < x_ulInt32Base, "dwlAccum < x_dwlBaseUI4", "Integer overflow");
                if (iDataMax == x_cNumeMax)
                    throw new OverflowException(SQLResource.ArithOverflowMessage);

                // Or extend length by one uint
                rguiData[iDataMax] = (uint)dwlAccum;
                m_bLen ++;
            }

            if (FGt10_38 (rguiData))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            StoreFromWorkingArray(rguiData);
        }


        //    DivByULong()
        //
        //    Divide numeric value by a ULONG.  The result will be returned
        //    in the dividend *this.
        //        
        //    Parameters:
        //        this        - IN Dividend & OUT Result
        //        ulDivisor    - IN Divisor
        //    Returns:        - OUT Remainder
        //
        private uint DivByULong(uint iDivisor) {
            ulong   dwlDivisor = (ulong) iDivisor;
            ulong   dwlAccum = 0;           //Accumulated sum
            uint    ulQuotientCur = 0;      // Value of the current UI4 of the quotient
            bool    fAllZero = true;    // All of the quotient (so far) has been 0
            int     iData;              //Which UI4 currently on

            // Check for zero divisor.
            if (dwlDivisor == 0)
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);

            // Copy into array, so that we can iterate through the data
            uint[] rguiData = new uint[4] { m_data1, m_data2, m_data3, m_data4};

            // Start from the MS UI4 of quotient, divide by divisor, placing result
            //        in quotient and carrying the remainder.
            //DEVNOTE DWORDLONG sufficient accumulator since:
            //        Accum < Divisor <= 2^32 - 1    at start each loop    
            //                                    initially,and mod end previous loop
            //        Accum*2^32 < 2^64 - 2^32    
            //                                    multiply both side by 2^32 (x_dwlBaseUI4)
            //        Accum*2^32 + m_rgulData < 2^64
            //                                    rglData < 2^32
            for (iData = m_bLen; iData > 0; iData--) {
                SQLDebug.Check(dwlAccum < dwlDivisor);
                dwlAccum = (dwlAccum << 32) + (ulong)(rguiData[iData-1]); // dwlA*x_dwlBaseUI4 + rglData
                SQLDebug.Check((dwlAccum / dwlDivisor) < x_ulInt32Base);
                //Update dividend to the quotient.
                ulQuotientCur = (uint)(dwlAccum / dwlDivisor);
                rguiData[iData-1] = ulQuotientCur;
                //Remainder to be carried to the next lower significant byte.
                dwlAccum = dwlAccum % dwlDivisor;

                // While current part of quotient still 0, reduce length
                fAllZero = fAllZero && (ulQuotientCur == 0);
                if (fAllZero)
                    m_bLen --;
            }

            StoreFromWorkingArray(rguiData);

            // If result is 0, preserve sign but set length to 5
            if (fAllZero)
                m_bLen = 1;

            AssertValid();

            // return the remainder
            SQLDebug.Check(dwlAccum < x_ulInt32Base);
            return(uint)dwlAccum;
        }

        //    AdjustScale()
        //
        //    Adjust number of digits to the right of the decimal point.
        //    A positive adjustment increases the scale of the numeric value
        //    while a negative adjustment decreases the scale.  When decreasing
        //    the scale for the numeric value, the remainder is checked and
        //    rounded accordingly.
        //
        internal void AdjustScale(int digits, bool fRound) {
            SQLDebug.Check(!IsNull, "!IsNull", "In AdjustScale");

            uint    ulRem;                  //Remainder when downshifting
            uint    ulShiftBase;            //What to multiply by to effect scale adjust
            bool    fNeedRound = false;     //Do we really need to round?
            byte    bNewScale, bNewPrec;
            int     lAdjust = digits;

            //If downshifting causes truncation of data
            if (lAdjust + m_bScale < 0)
                throw new SqlTruncateException();

            //If uphifting causes scale overflow
            if (lAdjust + m_bScale > NUMERIC_MAX_PRECISION)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            bNewScale = (byte) (lAdjust + m_bScale);
            bNewPrec = (byte) (Math.Min(NUMERIC_MAX_PRECISION,Math.Max(1,lAdjust + m_bPrec)));

            if (lAdjust > 0) {
                m_bScale = bNewScale;
                m_bPrec  = bNewPrec;

                while (lAdjust > 0) {
                    //if lAdjust>=9, downshift by 10^9 each time, otherwise by the full amount
                    if (lAdjust >= 9) {
                        ulShiftBase = x_rgulShiftBase[8];
                        lAdjust -= 9;
                    }
                    else {
                        ulShiftBase = x_rgulShiftBase[lAdjust-1];
                        lAdjust = 0;
                    }
                    MultByULong(ulShiftBase);
                }
            }
            else if (lAdjust < 0) {
                do {
                    if (lAdjust <= -9) {
                        ulShiftBase = x_rgulShiftBase[8];
                        lAdjust += 9;
                    }
                    else {
                        ulShiftBase = x_rgulShiftBase[-lAdjust - 1];
                        lAdjust = 0;
                    }
                    ulRem = DivByULong (ulShiftBase);
                }
                while (lAdjust < 0);

                // Do we really need to round?
                fNeedRound = (ulRem >= ulShiftBase/2);

                m_bScale = bNewScale;
                m_bPrec =  bNewPrec;
            }

            AssertValid();

            // After adjusting, if the result is 0 and remainder is less than 5,
            // set the sign to be positive and return.
            if (fNeedRound && fRound) {
                // If remainder is 5 or above, increment/decrement by 1.
                AddULong(1);
            }
            else if (FZero())
                SetPositive();
        }

        // Adjust scale of a SqlDecimal
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.AdjustScale"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal AdjustScale(SqlDecimal n, int digits, bool fRound) {
            if (n.IsNull)
                return SqlDecimal.Null;

            SqlDecimal ret = n;
            ret.AdjustScale(digits, fRound);
            return ret;
        }

        // Convert to a specific precision and scale
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ConvertToPrecScale"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal ConvertToPrecScale(SqlDecimal n, int precision, int scale) {
            CheckValidPrecScale(precision, scale);
            n.AssertValid();

            if (n.IsNull)
                return SqlDecimal.Null;

            SqlDecimal ret = n;

            int lPrecAdjust = precision - (int)ret.m_bPrec;//Adjustment to precision
            int lScaleAdjust = scale - (int)ret.m_bScale;//Adjustment to scale

            //Adjust scale
            ret.AdjustScale(lScaleAdjust, true);

            //Shouldn't truncate the integer digits; BActualPrec() is an expensive
            //function call, so test the data length first to eliminate majority
            //of cases

            //The number of bytes storage required by the new precision
            byte cbWithNewPrec = CLenFromPrec((byte)precision); 

            if (cbWithNewPrec < ret.m_bLen) {
                //if current actual length greater than length corresponding to bNewPrec
                //there must be truncating
                throw new SqlTruncateException();
            }
            else if (cbWithNewPrec == ret.m_bLen) {
                //if the two lengths equal, need to check the actual precision
                if (precision < ret.BActualPrec())
                    throw new SqlTruncateException();
            }

            //Adjust precision
            ret.m_bPrec = (byte)precision;

            ret.AssertValid();

            return ret;
        }

        //    LAbsCmp()
        //
        //    Compare the absolute value of two numerics without checking scale
        //
        //  Parameters:
        //        this    - IN Operand1 
        //        snumOp    - IN Operand2 
        //
        //    Returns:
        //        positive    - |this| > |snumOp|
        //        0            - |this| = |snumOp|
        //        negative    - |this| < |snumOp|
        //
        private int LAbsCmp(SqlDecimal snumOp) {

            int         iData;  //which UI4 we are operating on
            int         culOp;  //#of UI4s on operand
            int         culThis; //# of UI4s in this

            // If one longer, it is larger
            culOp = snumOp.m_bLen;
            culThis = m_bLen;
            if (culOp != culThis)
                return(culThis > culOp) ? 1 : -1;

            uint[] rglData1 = new uint[4] {m_data1, m_data2, m_data3, m_data4};
            uint[] rglData2 = new uint[4] {snumOp.m_data1, snumOp.m_data2, snumOp.m_data3, snumOp.m_data4};

            // Loop through numeric value checking each byte for differences.
            iData = culOp-1;
            do {
                // CONSIDER PERF: Could replace second comparison with
                //        cast to LONGLONG and subtract.  Probably not worth it.
                if (rglData1[iData] != rglData2[iData])
                    return((rglData1[iData] > rglData2[iData]) ? 1 : -1);
                iData --;
            }
            while (iData >= 0);

            // All UI4s the same, return 0.
            return 0;
        }

        // Move multi-precision number
        private static void MpMove
        (
        uint[]  rgulS,      // In    | Source number
        int     ciulS,      // In    | # of digits in S
        uint[]  rgulD,      // Out    | Destination number
        out int ciulD       // Out    | # of digits in D
        ) {
            ciulD = ciulS;

            SQLDebug.Check(rgulS.Length >= ciulS, "rgulS.Length >= ciulS", "Invalid array length");
            SQLDebug.Check(rgulD.Length >= ciulS, "rgulD.Length >= ciulS", "Invalid array length");

            for (int i = 0; i < ciulS; i ++)
                rgulD[i] = rgulS[i];
        }

        // Set multi-precision number to one super-digit
        private static void MpSet
        (
        uint[]  rgulD,      // Out    | Number
        out int ciulD,      // Out    | # of digits in D
        uint    iulN        // In    | ULONG to set
        ) {
            ciulD = 1;
            rgulD[0] = iulN;
        }

        // Normalize multi-precision number - remove leading zeroes
        private static void MpNormalize
        (
        uint[]  rgulU,      // In   | Number
        ref int ciulU       // InOut| # of digits
        ) {
            while (ciulU > 1 && rgulU[ciulU-1] == 0)
                ciulU --;
        }

        // Multi-precision one super-digit multiply in place.
        // D = D * X
        // Length can increase
        private static void MpMul1
        (
        uint[]  piulD,      // InOut| D
        ref int ciulD,      // InOut| # of digits in D
        uint    iulX        // In    | X
        ) {
            SQLDebug.Check(iulX > 0 && iulX < x_ulInt32Base);
            uint ulCarry = 0;
            int iData;
            ulong dwlAccum;

            for (iData = 0; iData < ciulD; iData ++) {
                ulong ulTemp = (ulong)piulD[iData];
                dwlAccum = ulCarry + ulTemp * (ulong)iulX;
                ulCarry = HI (dwlAccum);
                piulD[iData] = LO (dwlAccum);
            }

            // If overflow occurs, increase precision
            if (ulCarry != 0) {
                piulD[iData] = ulCarry;
                ciulD ++;
            }
        }

        // Multi-precision one super-digit divide in place.
        // U = U / D,
        // R = U % D
        // Length of U can decrease
        private static void MpDiv1
        (
        uint[]      rgulU,      // InOut| U
        ref int     ciulU,      // InOut| # of digits in U
        uint        iulD,       // In    | D
        out uint    iulR        // Out    | R
        ) {
            SQLDebug.Check(rgulU.Length == x_cNumeMax);

            uint    ulCarry = 0;
            ulong   dwlAccum;
            ulong   ulD = (ulong)iulD;
            int     idU = ciulU;

            SQLDebug.Check(iulD != 0, "iulD != 0", "Divided by zero!");
            SQLDebug.Check(iulD > 0, "iulD > 0", "Invalid data: less than zero");
            SQLDebug.Check(ciulU > 0, "ciulU > 0", "No data in the array");

            while (idU > 0) {
                idU --;
                dwlAccum = (((ulong)ulCarry) << 32) + (ulong)(rgulU[idU]);
                rgulU[idU] = (uint)(dwlAccum / ulD);
                ulCarry = (uint) (dwlAccum - (ulong)rgulU[idU] * ulD);  // (ULONG) (dwlAccum % iulD)
            }
            iulR = ulCarry;
            MpNormalize (rgulU, ref ciulU);
        }

        internal static ulong DWL(uint lo, uint hi) {
            return(ulong)lo + ( ((ulong)hi) << 32 );
        }

        private static uint HI(ulong x) {
            return(uint)(x >> 32);
        }

        private static uint LO(ulong x) {
            return(uint)x;
        }

        // Multi-precision divide.
        // Q = U / D,
        // R = U % D,
        // U and D not changed.
        // It is Ok for U and R to have the same location in memory,
        // but then U will be changed.
        // Assumes that there is enough room in Q and R for results.

        // Drawbacks of this implementation:
        //    1)    Need one extra super-digit (ULONG) in R
        //    2)    As it modifies D during work, then it do (probably) unnecessary
        //        work to restore it
        //    3)    Always get Q and R - if R is unnecessary, can be slightly faster
        // Most of this can be fixed if it'll be possible to have a working buffer. But
        // then we'll use alloca() or there will be limit on the upper size of numbers
        // (maybe not a problem in SQL Server).
        //
        private static void MpDiv
        (
        uint[]  rgulU,      // In    | U
        int     ciulU,      // In    | # of digits in U
        uint[]  rgulD,      // In    | D
        int     ciulD,      // In    | # of digits in D
        uint[]  rgulQ,      // Out    | Q
        out int ciulQ,      // Out    | # of digits in Q
        uint[]  rgulR,      // Out    | R
        out int ciulR       // Out    | # of digits in R
        ) {
            SQLDebug.Check(ciulU > 0, "ciulU > 0", "In method MpDiv");
            SQLDebug.Check(ciulD > 0, "ciulD > 0", "In method MpDiv");
            SQLDebug.Check(rgulU.Length == x_cNumeMax);
            SQLDebug.Check(rgulD.Length == x_cNumeMax);

            // Division by zero?
            if (ciulD == 1 && rgulD[0] == 0) {
                ciulQ = ciulR = 0;
            }

            // Check for simplest case, so it'll be fast
            else if (ciulU == 1 && ciulD == 1) {
                MpSet (rgulQ, out ciulQ, rgulU[0] / rgulD[0]);
                MpSet (rgulR, out ciulR, rgulU[0] % rgulD[0]);
            }

            // If D > U then do not divide at all
            else if (ciulD > ciulU) {
                MpMove (rgulU, ciulU, rgulR, out ciulR);        // R = U
                MpSet (rgulQ, out ciulQ, 0);                    // Q = 0
            }

            // Try to divide faster - check for remaining good sizes (8 / 4, 8 / 8)
            else if (ciulU <= 2) {
                ulong dwlU, dwlD, dwlT;

                dwlU = DWL (rgulU[0], rgulU[1]);
                dwlD = rgulD[0];
                if (ciulD > 1)
                    dwlD += ( ((ulong)rgulD[1]) << 32 );
                dwlT = dwlU / dwlD;
                rgulQ[0] = LO (dwlT);
                rgulQ[1] = HI (dwlT);
                ciulQ = (HI (dwlT) != 0) ? 2 : 1;
                dwlT = dwlU % dwlD;
                rgulR[0] = LO (dwlT);
                rgulR[1] = HI (dwlT);
                ciulR = (HI (dwlT) != 0) ? 2 : 1;
            }

            // If we are dividing by one digit - use simpler routine
            else if (ciulD == 1) {
                MpMove (rgulU, ciulU, rgulQ, out ciulQ);        // Q = U
                uint remainder;
                MpDiv1 (rgulQ, ref ciulQ, rgulD[0], out remainder);     // Q = Q / D, R = Q % D
                rgulR[0] = remainder;
                ciulR = 1;
            }

            // Worst case. Knuth, "The Art of Computer Programming", 3rd edition, vol.II, Alg.D, pg 272
            else {
                ciulQ = ciulR = 0;

                uint D1, ulDHigh, ulDSecond;
                int iulRindex;

                if (rgulU != rgulR)
                    MpMove (rgulU, ciulU, rgulR, out ciulR);        // R = U

                ciulQ = ciulU - ciulD + 1;
                ulDHigh = rgulD[ciulD-1];

                // D1.    Normalize so high digit of D >= BASE/2 - that guarantee
                //        that QH will not be too far from the correct digit later in D3
                rgulR[ciulU] = 0;
                iulRindex = ciulU;
                D1 = (uint)(x_ulInt32Base / ((ulong)ulDHigh + 1));
                if (D1 > 1) {
                    MpMul1 (rgulD, ref ciulD, D1);
                    ulDHigh = rgulD[ciulD-1];
                    MpMul1 (rgulR, ref ciulR, D1);
                }
                ulDSecond = rgulD[ciulD-2];
                // D2 already done - iulRindex initialized before normalization of R.
                // D3-D7. Loop on iulRindex - obtaining digits one-by-one, as "in paper"
                do {
                    uint QH, RH;
                    int iulDindex, iulRwork;
                    ulong dwlAccum, dwlMulAccum;

                    // D3. Calculate Q hat - estimation of the next digit
                    dwlAccum = DWL (rgulR[iulRindex-1], rgulR[iulRindex]);
                    if (ulDHigh == rgulR[iulRindex])
                        QH = (uint)(x_ulInt32Base - 1);
                    else
                        QH = (uint)(dwlAccum / ulDHigh);
                    ulong ulTemp = (ulong)QH;
                    RH = (uint)(dwlAccum - ulTemp * (ulong)ulDHigh);

                    while (ulDSecond * ulTemp > DWL (rgulR[iulRindex-2], RH)) {
                        QH --;
                        if (RH >= (uint) - ((int) ulDHigh))
                            break;
                        RH += ulDHigh;
                        ulTemp = (ulong)QH;
                    }

                    // D4. Multiply and subtract: (some digits of) R -= D * QH
                    for (dwlAccum = x_ulInt32Base, dwlMulAccum = 0, iulDindex = 0, iulRwork = iulRindex - ciulD;
                        iulDindex < ciulD; iulDindex ++, iulRwork ++) {
                        ulong ulTemp2 = (ulong)rgulD[iulDindex];
                        dwlMulAccum += (ulong)QH * ulTemp2;
                        dwlAccum += (ulong)rgulR[iulRwork] - LO (dwlMulAccum);
                        dwlMulAccum = (ulong)(HI (dwlMulAccum));
                        rgulR[iulRwork] = LO (dwlAccum);
                        dwlAccum = HI (dwlAccum) + x_ulInt32Base - 1;
                    }
                    dwlAccum += (ulong)rgulR[iulRwork] - dwlMulAccum;
                    rgulR[iulRwork] = LO (dwlAccum);
                    rgulQ[iulRindex-ciulD] = QH;

                    // D5. Test remainder. Carry indicates result<0, therefore QH 1 too large
                    if (HI (dwlAccum) == 0) {
                        // D6. Add back - probabilty is 2**(-31). R += D. Q[digit] -= 1
                        uint ulCarry;

                        rgulQ[iulRindex-ciulD] = QH - 1;
                        for (ulCarry = 0, iulDindex = 0, iulRwork = iulRindex - ciulD;
                            iulDindex < ciulD; iulDindex ++, iulRwork ++) {
                            dwlAccum = (ulong)rgulD[iulDindex] + (ulong)rgulR[iulRwork] + (ulong)ulCarry;
                            ulCarry = HI (dwlAccum);
                            rgulR[iulRwork] = LO (dwlAccum);
                        }
                        rgulR[iulRwork] += ulCarry;
                    }
                    // D7. Loop on iulRindex
                    iulRindex --;
                }
                while (iulRindex >= ciulD);
                // Normalize results
                MpNormalize (rgulQ, ref ciulQ);
                ciulR = ciulD;
                MpNormalize (rgulR, ref ciulR);
                // D8. Unnormalize: Divide D and R to get result
                if (D1 > 1) {
                    uint ret;
                    MpDiv1 (rgulD, ref ciulD, D1, out ret);
                    MpDiv1 (rgulR, ref ciulR, D1, out ret);
                }
            }
        }

        //    CmpCompareNm()
        //
        //    Compare the value of two numerics
        //
        //    Complexity: O(pn) p: precision  n: length
        //
        //  Parameters:
        //        this    - IN Operand1
        //        snumOp    - IN operand2
        //
        //    Returns:
        //        EComparison.LT    - this < snumOp
        //        EComparison.EQ        - this = snumOp
        //        EComparison.GT    - this > snumOp
        //
        private EComparison CompareNm
        (
        SqlDecimal snumOp
        ) {
            AssertValid();
            snumOp.AssertValid();

            //Signs of the two numeric operands
            int     Sign1;
            int     Sign2;

            int     iFinalResult;   //Final result of comparision: positive = greater
                                    //than, 0 = equal, negative = less than

            //Initialize the sign values to be 1(positive) or -1(negative)
            Sign1 = IsPositive ? 1 : -1;
            Sign2 = snumOp.IsPositive ? 1 : -1;

            if (Sign1 != Sign2) //If different sign, the positive one is greater
                return Sign1 == 1 ? EComparison.GT : EComparison.LT;

            else { //same sign, have to compare absolute values
                //Temporary memory to hold the operand since it is const
                //but its scale may get adjusted during comparison
                int         ScaleDiff;
                SqlDecimal  snumArg1 = this;
                SqlDecimal  snumArg2 = snumOp;

                //First make the two operands the same scale if necessary
                ScaleDiff = ((int) m_bScale) - ((int) snumOp.m_bScale);

                if (ScaleDiff < 0) {
                    //If increasing the scale of operand1 caused an overflow,  
                    //then its absolute value is greater than that of operand2.
                    try {
                        snumArg1.AdjustScale(-ScaleDiff, true);
                    }
                    catch (OverflowException) {
                        return(Sign1 > 0) ? EComparison.GT : EComparison.LT;
                    }
                }
                else if (ScaleDiff > 0) {
                    //If increasing the scale of operand2 caused an overflow, then 
                    //operand1's absolute value is less than that of operand2.
                    try {
                        snumArg2.AdjustScale(ScaleDiff, true);
                    }
                    catch (OverflowException) {
                        return(Sign1 > 0) ? EComparison.LT : EComparison.GT;
                    }
                }

                //Compare the absolute value of the two numerics
                //Note: We are sure that scale of arguments is the same,
                //      so LAbsCmp() will not modify its argument.
                int lResult = snumArg1.LAbsCmp(snumArg2);
                if (0 == lResult)
                    return EComparison.EQ;

                //if both positive, result same as result from LAbsCmp;
                //if both negative, result reverse of result from LAbsCmp
                iFinalResult = Sign1 * lResult;

                if (iFinalResult < 0)
                    return EComparison.LT;
                else
                    return EComparison.GT;
            }
        }

        private static void CheckValidPrecScale(byte bPrec, byte bScale) {
            if (bPrec < 1 || bPrec > MaxPrecision || bScale < 0 || bScale > MaxScale || bScale > bPrec)
                throw new SqlTypeException(SQLResource.InvalidPrecScaleMessage);
        }

        private static void CheckValidPrecScale(int iPrec, int iScale) {
            if (iPrec < 1 || iPrec > MaxPrecision || iScale < 0 || iScale > MaxScale || iScale > iPrec)
                throw new SqlTypeException(SQLResource.InvalidPrecScaleMessage);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlDecimal x, SqlDecimal y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.CompareNm(y) == EComparison.EQ);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlDecimal x, SqlDecimal y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlDecimal x, SqlDecimal y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.CompareNm(y) == EComparison.LT);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlDecimal x, SqlDecimal y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.CompareNm(y) == EComparison.GT);
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlDecimal x, SqlDecimal y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;
            else {
                EComparison result = x.CompareNm(y);
                return new SqlBoolean(result == EComparison.LT || result == EComparison.EQ);
            }
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlDecimal x, SqlDecimal y) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;
            else {
                EComparison result = x.CompareNm(y);
                return new SqlBoolean(result == EComparison.GT || result == EComparison.EQ);
            }
        }


        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Add"]/*' />
        public static SqlDecimal Add(SqlDecimal x, SqlDecimal y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Subtract"]/*' />
        public static SqlDecimal Subtract(SqlDecimal x, SqlDecimal y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Multiply"]/*' />
        public static SqlDecimal Multiply(SqlDecimal x, SqlDecimal y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Divide"]/*' />
        public static SqlDecimal Divide(SqlDecimal x, SqlDecimal y) {
            return x / y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Equals1"]/*' />
        public static SqlBoolean Equals(SqlDecimal x, SqlDecimal y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlDecimal x, SqlDecimal y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlDecimal x, SqlDecimal y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlDecimal x, SqlDecimal y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlDecimal x, SqlDecimal y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlDecimal x, SqlDecimal y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }

        private static char ChFromDigit(uint uiDigit) {
            SQLDebug.Check(uiDigit < 10);
            return(char)(uiDigit + '0');
        }

        // Store data back from rguiData[] to m_data*
        private void StoreFromWorkingArray(uint[] rguiData) {
            SQLDebug.Check(rguiData.Length == 4);
            m_data1 = rguiData[0];
            m_data2 = rguiData[1];
            m_data3 = rguiData[2];
            m_data4 = rguiData[3];
        }

        private void SetToZero() {
            SQLDebug.Check(m_bPrec >= 1);
            m_bLen = 1;
            m_data1 =
            m_data2 =
            m_data3 =
            m_data4 = 0;
            m_bStatus = (byte) (x_bNotNull | x_bPositive);
            AssertValid();
        }

        // Truncate to integer
        private void MakeInteger(out bool fFraction) {
            uint ulRem;
            int iAdjust = m_bScale;

            fFraction = false;

            while (iAdjust > 0) {
                if (iAdjust >= 9) {
                    ulRem = DivByULong (x_rgulShiftBase[8]);
                    iAdjust -= 9;
                }
                else {
                    ulRem = DivByULong (x_rgulShiftBase[iAdjust-1]);
                    iAdjust = 0;
                }

                // Check for remainder and set fFraction flag.
                if (ulRem != 0)
                    fFraction = true;
            }

            m_bScale = 0;
            AssertValid();
        }

        // Builtin functions

        // Abs - absolute value
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Abs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Abs(SqlDecimal n) {
            n.AssertValid();

            if (n.IsNull)
                return SqlDecimal.Null;

            n.SetPositive();
            n.AssertValid();
            return n;
        }

        // Ceiling - next smallest integer greater than or equal to the numeric
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Ceiling"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Ceiling(SqlDecimal n) {
            n.AssertValid();

            if (n.IsNull)
                return SqlDecimal.Null;

            if (n.m_bScale == 0)
                return n;

            bool fFraction;    //Fractional flag

            n.MakeInteger(out fFraction);

            //When the numeric has fraction and is positive, adjust by adding 1.
            //Otherwise return the integral part.
            if (fFraction && n.IsPositive) {
                n.AddULong(1);
            }

            if (n.FZero())//if result is zero, sign should be positive
                n.SetPositive();
            n.AssertValid();
            return n;
        }

        // Floor - next largest integer smaller or equal to the numeric
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Floor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Floor(SqlDecimal n) {
            n.AssertValid();

            if (n.IsNull)
                return SqlDecimal.Null;

            if (n.m_bScale == 0)
                return n;

            bool fFraction;    //Fractional flag

            n.MakeInteger(out fFraction);

            //When the numeric has fraction and is negative, subtract 1 by calling AddULong(1)
            //Otherwise return the integral part.
            if (fFraction && !n.IsPositive) {
                n.AddULong(1);
            }

            if (n.FZero())//if result is zero, sign should be positive
                n.SetPositive();
            n.AssertValid();
            return n;
        }

        // Sign -   1 if positive, -1 if negative
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Sign"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlInt32 Sign(SqlDecimal n) {
            n.AssertValid();

            if (n.IsNull)
                return SqlInt32.Null;

            if (n == new SqlDecimal(0))
                return SqlInt32.Zero;
            else
                return n.IsNull ? SqlInt32.Null : 
                    (n.IsPositive ? new SqlInt32(1) : new SqlInt32(-1));
        }

        private static SqlDecimal Round(SqlDecimal n, int lPosition, bool fTruncate) {
            if (n.IsNull)
                return SqlDecimal.Null;

            uint    ulRem = 0;  //Remainder: the highest significant digit to be truncated
            int     lAdjust;    //Precision adjustment 

            if (lPosition >= 0) {
                //If round to the right of decimal number
                lPosition = Math.Min(NUMERIC_MAX_PRECISION, lPosition);
                if (lPosition >= n.m_bScale)
                    return n;   //No need to round
            }
            else {
                //If round to the left of the decimal point 
                lPosition = Math.Max(-NUMERIC_MAX_PRECISION, lPosition);

                //Return +0.00 if truncation of integer part 
                if (lPosition < n.m_bScale - n.m_bPrec) {
                    n.SetToZero();
                    return n;
                }
            }

            lAdjust = Math.Abs(lPosition - (int)n.m_bScale);

            //Compute the integral part of the numeric
            while (lAdjust > 0) {
                if (lAdjust >= 9) {
                    ulRem = n.DivByULong (x_rgulShiftBase[8]);
                    lAdjust -= 9;
                }
                else {
                    ulRem = n.DivByULong (x_rgulShiftBase[lAdjust-1]);
                    lAdjust = 0;
                }
            }
            // The rounding only depends on the first digit of the ulRem
            while (ulRem > 10)
                ulRem /= 10;

            //If result is zero, return 
            if (n.FZero() && (fTruncate || ulRem < 5))
                {
                n.SetPositive();
                n.AssertValid();
                return n;
                }

            // Adjust by adding 1 if remainder is larger than 5
            if (ulRem >= 5 && !fTruncate)
                n.AddULong(1);

            // Convert back to original scale
            lAdjust = Math.Abs(lPosition - n.m_bScale);

            while (lAdjust-- > 0) {
                n.MultByULong(x_ulBase10);
            }

            n.AssertValid();
            return n;
        }

        // Round - Round the numeric to a specific digit
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Round"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Round(SqlDecimal n, int position) {
            n.AssertValid();
            return Round(n, position, false);
        }

        // Truncate - Truncate the numeric to a specific digit
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Truncate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Truncate(SqlDecimal n, int position) {
            n.AssertValid();
            return Round(n, position, true);
        }

        // Power - Compute the power of a numeric
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Power"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlDecimal Power(SqlDecimal n, double exp) {
            n.AssertValid();

            if (n.IsNull)
                return SqlDecimal.Null;

            byte prec = n.Precision;
            int scale = n.Scale;
            double dBaseNum = n.ToDouble();

            n = new SqlDecimal(Math.Pow(dBaseNum, exp));
            n.AdjustScale(scale - (int)n.Scale, true);

            n.m_bPrec = MaxPrecision;

            return n;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlDecimal) {
                SqlDecimal i = (SqlDecimal)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlDecimal)) {
                return false;
            }

            SqlDecimal i = (SqlDecimal)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            if (IsNull)
                return 0;

            SqlDecimal ssnumTemp;
            int        lActualPrec;

            // First, "normalize" numeric, so that values with different
            // scale/precision will have the same representation.
            ssnumTemp = this;
            lActualPrec = ssnumTemp.BActualPrec();
            ssnumTemp.AdjustScale(NUMERIC_MAX_PRECISION - lActualPrec, true);

            // Now evaluate the hash
            int cDwords = ssnumTemp.m_bLen;
            int ulValue = 0;
            int ulHi;

            // Size of CRC window (hashing bytes, ssstr, sswstr, numeric)
            const int x_cbCrcWindow = 4;
            // const int iShiftVal = (sizeof ulValue) * (8*sizeof(char)) - x_cbCrcWindow;
            const int iShiftVal = 4 * 8 - x_cbCrcWindow;

            int[] rgiData = ssnumTemp.Data;

            for (int i = 0; i < cDwords; i++)
                {
                ulHi = (ulValue >> iShiftVal) & 0xff;
                ulValue <<= x_cbCrcWindow;
                ulValue = ulValue ^ rgiData[i] ^ ulHi;
                }
            return ulValue;
        }

        // These values are defined at last, because they need to call ctors, which use other 
        // constant values. Those constants must be defined before callint ctor.

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDecimal Null = new SqlDecimal(true);

        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDecimal MinValue    = SqlDecimal.Parse("-99999999999999999999999999999999999999");
        /// <include file='doc\SQLNumeric.uex' path='docs/doc[@for="SqlDecimal.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlDecimal MaxValue    = SqlDecimal.Parse("99999999999999999999999999999999999999");

    } // SqlDecimal

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlmoney.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLMoney.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlMoney.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlMoney which is equivalent to 
//            data type "money" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/17/99  JunFang    Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a currency value ranging from
    ///       -2<superscript term='63'/> (or -922,337,203,685,477.5808) to 2<superscript term='63'/> -1 (or
    ///       +922,337,203,685,477.5807) with an accuracy to
    ///       a ten-thousandth of currency unit to be stored in or retrieved from a
    ///       database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlMoney : INullable, IComparable {
        private long m_value;
        private bool m_fNotNull; // false if null

        // SQL Server stores money8 as ticks of 1/10000.
        internal static readonly int x_iMoneyScale = 4;
        private static readonly long x_lTickBase = 10000;
        private static readonly double x_dTickBase = (double)x_lTickBase;

        private static readonly long MinLong = unchecked((long)0x8000000000000000L) / x_lTickBase;
        private static readonly long MaxLong = 0x7FFFFFFFFFFFFFFFL / x_lTickBase;

        // constructor
        // construct a Null
        private SqlMoney(bool fNull) {
            m_fNotNull = false;
            m_value = 0;
        }

        // Constructs from a long value without scaling. The ignored parameter exists 
        // only to distinguish this constructor from the constructor that takes a long. 
        // Used only internally.
        internal SqlMoney(long value, int ignored) {
            m_value = value;
            m_fNotNull = true;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.SqlMoney"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlMoney'/> class with the value given.
        ///    </para>
        /// </devdoc>
        public SqlMoney(int value) {
            m_value = (long)value * x_lTickBase;
            m_fNotNull = true;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.SqlMoney1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlMoney'/> class with the value given.
        ///    </para>
        /// </devdoc>
        public SqlMoney(long value) {
            if (value < MinLong || value > MaxLong)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            m_value = value * x_lTickBase;
            m_fNotNull = true;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.SqlMoney2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlMoney'/> class with the value given.
        ///    </para>
        /// </devdoc>
        public SqlMoney(Decimal value) {
            // Since Decimal is a value type, operate directly on value, don't worry about changing it.
            SqlDecimal snum = new SqlDecimal(value);
            snum.AdjustScale(x_iMoneyScale - snum.Scale, true);
            Debug.Assert(snum.Scale == x_iMoneyScale);

            if (snum.m_data3 != 0 || snum.m_data4 != 0)
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            bool fPositive = snum.IsPositive;
            ulong ulValue = (ulong)snum.m_data1 + ( ((ulong)snum.m_data2) << 32 );
            if (fPositive && ulValue > (ulong)(Int64.MaxValue) ||
                !fPositive && ulValue > unchecked((ulong)(Int64.MinValue)))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            m_value = fPositive ? (long)ulValue : unchecked(- (long)ulValue);
            m_fNotNull = true;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.SqlMoney3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlMoney'/> class with the value given.
        ///    </para>
        /// </devdoc>
        public SqlMoney(double value) : this(new Decimal(value)) {
        }


        // INullable
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.IsNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Data.SqlTypes.SqlMoney.Value'/>
        ///       property is assigned to null.
        ///    </para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the monetary value of an instance of the <see cref='System.Data.SqlTypes.SqlMoney'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public Decimal Value {
            get {
                if (m_fNotNull)
                    return ToDecimal();
                else
                    throw new SqlNullValueException();
            }
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Decimal ToDecimal() {
            if(IsNull)
                throw new SqlNullValueException();

            bool fNegative = false;
            long value = m_value;
            if (m_value < 0) {
                fNegative = true;
                value = - m_value;
            }

            return new Decimal(unchecked((int)value), unchecked((int)(value >> 32)), 0, fNegative, (byte)x_iMoneyScale);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToInt64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public long ToInt64() {
            if(IsNull)
                throw new SqlNullValueException();

            long ret = m_value / (x_lTickBase / 10);
            bool fPositive = (ret >= 0);
            long remainder = ret % 10;
            ret = ret / 10;

            if (remainder >= 5) {
                if (fPositive)
                    ret ++;
                else
                    ret --;
            }

            return ret;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToInt32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ToInt32() {
            return checked((int)(ToInt64()));
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToDouble"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public double ToDouble() {
            return Convert.ToDouble(ToDecimal());
        }

        // Implicit conversion from Decimal to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlMoney(Decimal x) {
            return new SqlMoney(x);
        }

        // Explicit conversion from SqlMoney to Decimal. Throw exception if x is Null.
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorDecimal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator Decimal(SqlMoney x) {
            return x.Value;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : ToDecimal().ToString();
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney Parse(String s) {
            return new SqlMoney(Decimal.Parse(s, NumberStyles.Currency, null));
        }


        // Unary operators
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney operator -(SqlMoney x) {
            if (x.IsNull)
                return Null;
            if (x.m_value == MinLong)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            return new SqlMoney(-x.m_value, 0);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney operator +(SqlMoney x, SqlMoney y) {
            try {
                return(x.IsNull || y.IsNull) ? Null : new SqlMoney(checked(x.m_value + y.m_value), 0);
            }
            catch (OverflowException) {
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            }
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney operator -(SqlMoney x, SqlMoney y) {
            try {
                return(x.IsNull || y.IsNull) ? Null : new SqlMoney(checked(x.m_value - y.m_value), 0);
            }
            catch (OverflowException) {
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            }
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney operator *(SqlMoney x, SqlMoney y) {
            return (x.IsNull || y.IsNull) ? Null : 
		new SqlMoney(Decimal.Multiply(x.ToDecimal(), y.ToDecimal()));
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlMoney operator /(SqlMoney x, SqlMoney y) {
            return (x.IsNull || y.IsNull) ? Null : 
		new SqlMoney(Decimal.Divide(x.ToDecimal(), y.ToDecimal()));
        }


        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlMoney(SqlBoolean x) {
            return x.IsNull ? Null : new SqlMoney((int)x.ByteValue);
        }

        // Implicit conversion from SqlByte to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlMoney(SqlByte x) {
            return x.IsNull ? Null : new SqlMoney((int)x.Value);
        }

        // Implicit conversion from SqlInt16 to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlMoney(SqlInt16 x) {
            return x.IsNull ? Null : new SqlMoney((int)x.Value);
        }

        // Implicit conversion from SqlInt32 to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlMoney(SqlInt32 x) {
            return x.IsNull ? Null : new SqlMoney(x.Value);
        }

        // Implicit conversion from SqlInt64 to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlMoney(SqlInt64 x) {
            return x.IsNull ? Null : new SqlMoney(x.Value);
        }


        // Explicit conversions

        // Explicit conversion from SqlSingle to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlMoney(SqlSingle x) {
            return x.IsNull ? Null : new SqlMoney((double)x.Value);
        }

        // Explicit conversion from SqlDouble to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlMoney(SqlDouble x) {
            return x.IsNull ? Null : new SqlMoney(x.Value);
        }

        // Explicit conversion from SqlDecimal to SqlMoney
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlMoney(SqlDecimal x) {
            return x.IsNull ? SqlMoney.Null : new SqlMoney(x.Value);
        }

        // Explicit conversion from SqlString to SqlMoney
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorSqlMoney9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlMoney(SqlString x) {
            return x.IsNull ? Null : new SqlMoney(Decimal.Parse(x.Value,NumberStyles.Currency,null));
        }


        // Builtin functions

        // Overloading comparison operators
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlMoney x, SqlMoney y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlMoney x, SqlMoney y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlMoney x, SqlMoney y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlMoney x, SqlMoney y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlMoney x, SqlMoney y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlMoney x, SqlMoney y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }


        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Add"]/*' />
        public static SqlMoney Add(SqlMoney x, SqlMoney y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Subtract"]/*' />
        public static SqlMoney Subtract(SqlMoney x, SqlMoney y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Multiply"]/*' />
        public static SqlMoney Multiply(SqlMoney x, SqlMoney y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Divide"]/*' />
        public static SqlMoney Divide(SqlMoney x, SqlMoney y) {
            return x / y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Equals1"]/*' />
        public static SqlBoolean Equals(SqlMoney x, SqlMoney y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlMoney x, SqlMoney y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlMoney x, SqlMoney y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlMoney x, SqlMoney y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlMoney x, SqlMoney y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlMoney x, SqlMoney y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlMoney) {
                SqlMoney i = (SqlMoney)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlMoney)) {
                return false;
            }

            SqlMoney i = (SqlMoney)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            // Don't use Value property, because Value will convert to Decimal, which is not necessary.
            return IsNull ? 0 : m_value.GetHashCode();
        }


        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Null"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a null value that can be assigned to
        ///       the <see cref='System.Data.SqlTypes.SqlMoney.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlMoney'/>class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlMoney Null        = new SqlMoney(true);

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.Zero"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the zero value that can be assigned to the <see cref='System.Data.SqlTypes.SqlMoney.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlMoney'/> class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlMoney Zero        = new SqlMoney(0);

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.MinValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the minimum value that can be assigned
        ///       to <see cref='System.Data.SqlTypes.SqlMoney.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlMoney'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlMoney MinValue    = new SqlMoney(unchecked((long)0x8000000000000000L), 0);

        /// <include file='doc\SQLMoney.uex' path='docs/doc[@for="SqlMoney.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the maximum value that can be assigned to
        ///       the <see cref='System.Data.SqlTypes.SqlMoney.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlMoney'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public static readonly SqlMoney MaxValue    = new SqlMoney(0x7FFFFFFFFFFFFFFFL, 0);

    } // SqlMoney

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlstring.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLString.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlString.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlString which is equivalent to 
//            data type "nvarchar/varchar" in SQL Server
//
// Notes: 
//    
// History:
//
//   09/30/99  JunFang    Created.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Globalization;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace System.Data.SqlTypes {
    using System.Text;
    using System.Configuration.Assemblies;

    // Options that are used in comparison
    /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions"]/*' />
    [Flags,Serializable]
    public enum SqlCompareOptions {
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.None"]/*' />
        None            = 0x00000000,
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.IgnoreCase"]/*' />
        IgnoreCase      = 0x00000001,
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.IgnoreNonSpace"]/*' />
        IgnoreNonSpace  = 0x00000002,
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.IgnoreKanaType"]/*' />
        IgnoreKanaType  = 0x00000008, // ignore kanatype
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.IgnoreWidth"]/*' />
        IgnoreWidth     = 0x00000010, // ignore width
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlCompareOptions.BinarySort"]/*' />
        BinarySort      = 0x00008000, // binary sorting
    }

    /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a variable-length stream of characters to be stored in or retrieved from the database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlString : INullable, IComparable {
        private String            m_value;
        private CompareInfo       m_cmpInfo;
        private int               m_lcid;     // Locale Id
        private SqlCompareOptions m_flag;     // Compare flags
        private bool              m_fNotNull; // false if null

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Null"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents a null value that can be assigned to the <see cref='System.Data.SqlTypes.SqlString.Value'/> property of an instance of
        ///       the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public  static readonly SqlString Null = new SqlString(true);

        internal static readonly UnicodeEncoding x_UnicodeEncoding = new UnicodeEncoding();

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.IgnoreCase"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly int IgnoreCase       = 0x1;
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.IgnoreWidth"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly int IgnoreWidth      = 0x10;
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.IgnoreNonSpace"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly int IgnoreNonSpace   = 0x2;
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.IgnoreKanaType"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly int IgnoreKanaType   = 0x8;
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.BinarySort"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly int BinarySort       = 0x8000;

        private static readonly SqlCompareOptions x_iDefaultFlag      = 
                    SqlCompareOptions.IgnoreCase | SqlCompareOptions.IgnoreKanaType | 
                    SqlCompareOptions.IgnoreWidth;
        private static readonly CompareOptions x_iValidCompareOptionMask    = 
                    CompareOptions.IgnoreCase | CompareOptions.IgnoreWidth | 
                    CompareOptions.IgnoreNonSpace | CompareOptions.IgnoreKanaType;

        private static readonly SqlCompareOptions x_iValidSqlCompareOptionMask    = 
                    SqlCompareOptions.IgnoreCase | SqlCompareOptions.IgnoreWidth | 
                    SqlCompareOptions.IgnoreNonSpace | SqlCompareOptions.IgnoreKanaType |
					SqlCompareOptions.BinarySort;

        internal static readonly int x_lcidUSEnglish    = 0x00000409;
        private  static readonly int x_lcidBinary       = 0x00008200;


        // constructor
        // construct a Null
        private SqlString(bool fNull) {
            m_value     = null;
            m_cmpInfo   = null;
            m_lcid      = 0;
            m_flag      = SqlCompareOptions.None;
            m_fNotNull  = false;
        }

        // Constructor: Construct from both Unicode and NonUnicode data, according to fUnicode
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, int index, int count, bool fUnicode) {
            m_lcid      = lcid;
            ValidateSqlCompareOptions(compareOptions);
            m_flag      = compareOptions;
            if (data == null) {
                m_fNotNull  = false;
                m_value     = null;
                m_cmpInfo   = null;
            }
            else {
                m_fNotNull  = true;

				// m_cmpInfo is set lazily, so that we don't need to pay the cost
				// unless the string is used in comparison.
                m_cmpInfo   = null;

                if (fUnicode) {
                    m_value = x_UnicodeEncoding.GetString(data, index, count);
                }
                else {
                    CultureInfo culInfo = new CultureInfo(m_lcid);
                    Encoding cpe = System.Text.Encoding.GetEncoding(culInfo.TextInfo.ANSICodePage);
                    m_value = cpe.GetString(data, index, count);
                }
            }
        }

        // Constructor: Construct from both Unicode and NonUnicode data, according to fUnicode
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, bool fUnicode)
        : this(lcid, compareOptions, data, 0, data.Length, fUnicode) {
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, int index, int count) 
			: this(lcid, compareOptions, data, index, count, true) {
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data) 
			: this(lcid, compareOptions, data, 0, data.Length, true) {
        }

/*
        // UNDONE: Should we expose SQL collation id?
        // Constructor: take SQL Server collation id, and Unicode data
        private SqlString(int sqlColId, byte[] data) {
            // UNDONE: sortid and versionid are discarded.
            m_lcid = LCIDFromSQLCID(sqlColId);
            m_flag = FlagFromSQLCID(sqlColId);
            if (m_flag == SQL_BINARYSORT) {
                SQLDebug.Check(m_lcid == x_lcidBinary, "m_lcid == x_lcidBinary", "");
                m_value = x_UnicodeEncoding.GetString(data);
                m_cmpInfo = null;
            }
            else {
                m_cmpInfo = null;

                m_value = x_UnicodeEncoding.GetString(data);
            }
            m_fNotNull = true;
        }
*/

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(String data, int lcid, SqlCompareOptions compareOptions) {
            m_lcid      = lcid;
            ValidateSqlCompareOptions(compareOptions);
            m_flag      = compareOptions;
            m_cmpInfo   = null;
            if (data == null) {
                m_fNotNull  = false;
                m_value     = null;
            }
            else {
                m_fNotNull  = true;
                m_value     = String.Copy(data);
            }
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(String data, int lcid) : this(data, lcid, x_iDefaultFlag) {
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlString6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.SqlTypes.SqlString'/> class.
        ///    </para>
        /// </devdoc>
        public SqlString(String data) : this(data, System.Globalization.CultureInfo.CurrentCulture.LCID, x_iDefaultFlag) {
        }

        private SqlString(int lcid, SqlCompareOptions compareOptions, String data, CompareInfo cmpInfo) {
            m_lcid      = lcid;
            ValidateSqlCompareOptions(compareOptions);
            m_flag      = compareOptions;
            if (data == null) {
                m_fNotNull  = false;
                m_value     = null;
                m_cmpInfo   = null;
            }
            else {
                m_value     = data;
                m_cmpInfo   = cmpInfo;
                m_fNotNull  = true;
            }
        }


        // INullable
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.IsNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the <see cref='System.Data.SqlTypes.SqlString.Value'/> of the <see cref='System.Data.SqlTypes.SqlString'/> is <see cref='System.Data.SqlTypes.SqlString.Null'/>.
        ///    </para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the string that is to be stored.
        ///    </para>
        /// </devdoc>
        public String Value {
            get {
                if (!IsNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.LCID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int LCID {
            get {
                if (!IsNull)
                    return m_lcid;
                else
                    throw new SqlNullValueException();
            }
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.CultureInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CultureInfo CultureInfo {
            get {
                if (!IsNull)
                    return new CultureInfo(m_lcid);
                else
                    throw new SqlNullValueException();
            }
        }

        private void SetCompareInfo() {
			SQLDebug.Check(!IsNull);
			if (m_cmpInfo == null)
				m_cmpInfo = (new CultureInfo(m_lcid)).CompareInfo;
		}

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.CompareInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CompareInfo CompareInfo {
            get {
                if (!IsNull) {
					SetCompareInfo();
                    return m_cmpInfo;
				}
                else
                    throw new SqlNullValueException();
            }
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.SqlCompareOptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlCompareOptions SqlCompareOptions {
            get {
                if (!IsNull)
                    return m_flag;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from String to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlString(String x) {
            return new SqlString(x);
        }

        // Explicit conversion from SqlString to String. Throw exception if x is Null.
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator String(SqlString x) {
            return x.Value;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a <see cref='System.Data.SqlTypes.SqlString'/> object to a string.
        ///    </para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.GetUnicodeBytes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] GetUnicodeBytes() {
            if (IsNull)
                return null;

            return x_UnicodeEncoding.GetBytes(m_value);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.GetNonUnicodeBytes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] GetNonUnicodeBytes() {
            if (IsNull)
                return null;

            // Get the CultureInfo
            CultureInfo culInfo = new CultureInfo(m_lcid); 

            Encoding cpe = System.Text.Encoding.GetEncoding(culInfo.TextInfo.ANSICodePage);
            return cpe.GetBytes(m_value);
        }

/*
        internal int GetSQLCID() {
            if (IsNull)
                throw new SqlNullValueException();

            return MAKECID(m_lcid, m_flag);
        }
*/

        // Binary operators

        // Concatenation
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlString operator +(SqlString x, SqlString y) {
            if (x.IsNull || y.IsNull)
                return SqlString.Null;

            if (x.m_lcid != y.m_lcid || x.m_flag != y.m_flag)
                throw new SqlTypeException(SQLResource.ConcatDiffCollationMessage);

            return new SqlString(x.m_lcid, x.m_flag, x.m_value + y.m_value, 
					(x.m_cmpInfo == null) ? y.m_cmpInfo : x.m_cmpInfo);
        }

        // Comparison operators
        private static SqlBoolean Compare(SqlString x, SqlString y, EComparison ecExpectedResult) {
            if (x.IsNull || y.IsNull)
                return SqlBoolean.Null;

            if (x.m_lcid != y.m_lcid || x.m_flag != y.m_flag)
                throw new SqlTypeException(SQLResource.CompareDiffCollationMessage);

            x.SetCompareInfo();
            y.SetCompareInfo();
            SQLDebug.Check(x.FBinarySort() || (x.m_cmpInfo != null && y.m_cmpInfo != null),
                           "x.FBinarySort() || (x.m_cmpInfo != null && y.m_cmpInfo != null)", "");

            int iCmpResult;

            if (x.FBinarySort())
                iCmpResult = CompareBinary(x, y);
            else {
                char[] rgchX = x.m_value.ToCharArray();
                char[] rgchY = y.m_value.ToCharArray();
                int cwchX = rgchX.Length;
                int cwchY = rgchY.Length;

                // Trim the trailing space for comparison
                while (cwchX > 0 && rgchX[cwchX - 1] == ' ')
                    cwchX --;
                while (cwchY > 0 && rgchY[cwchY - 1] == ' ')
                    cwchY --;

                String strX = (cwchX == rgchX.Length) ? x.m_value : new String(rgchX, 0, cwchX);
                String strY = (cwchY == rgchY.Length) ? y.m_value : new String(rgchY, 0, cwchY);

                CompareOptions options = CompareOptionsFromSqlCompareOptions(x.m_flag);
                iCmpResult = x.m_cmpInfo.Compare(strX, strY, options);
            }

            bool fResult = false;

            switch (ecExpectedResult) {
                case EComparison.EQ:
                    fResult = (iCmpResult == 0);
                    break;

                case EComparison.LT:
                    fResult = (iCmpResult < 0);
                    break;

                case EComparison.LE:
                    fResult = (iCmpResult <= 0);
                    break;

                case EComparison.GT:
                    fResult = (iCmpResult > 0);
                    break;

                case EComparison.GE:
                    fResult = (iCmpResult >= 0);
                    break;

                default:
                    SQLDebug.Check(false, "Invalid ecExpectedResult");
                    return SqlBoolean.Null;
            }

            return new SqlBoolean(fResult);
        }



        // Implicit conversions



        // Explicit conversions

        // Explicit conversion from SqlBoolean to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlBoolean x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlByte to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlByte x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlInt16 to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlInt16 x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlInt32 to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlInt32 x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlInt64 to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlInt64 x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlSingle to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlSingle x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlDouble to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlDouble x) {
            return x.IsNull ? Null : new SqlString((x.Value).ToString());
        }

        // Explicit conversion from SqlDecimal to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlDecimal x) {
            return x.IsNull ? Null : new SqlString(x.ToString());
        }

        // Explicit conversion from SqlMoney to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlMoney x) {
            return x.IsNull ? Null : new SqlString(x.ToString());
        }

        // Explicit conversion from SqlDateTime to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlDateTime x) {
            return x.IsNull ? Null : new SqlString(x.ToString());
        }

        // Explicit conversion from SqlGuid to SqlString
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorSqlString11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlString(SqlGuid x) {
            return x.IsNull ? Null : new SqlString(x.ToString());
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Clone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlString Clone() {
            if (IsNull)
                return new SqlString(true);
            else {
                SqlString ret = new SqlString(m_value, m_lcid, m_flag);
                return ret;
            }
        }

        // Overloading comparison operators
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlString x, SqlString y) {
            return Compare(x, y, EComparison.EQ);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlString x, SqlString y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlString x, SqlString y) {
            return Compare(x, y, EComparison.LT);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlString x, SqlString y) {
            return Compare(x, y, EComparison.GT);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlString x, SqlString y) {
            return Compare(x, y, EComparison.LE);
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlString x, SqlString y) {
            return Compare(x, y, EComparison.GE);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Concat"]/*' />
        public static SqlString Concat(SqlString x, SqlString y) {
            return x + y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Equals1"]/*' />
        public static SqlBoolean Equals(SqlString x, SqlString y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlString x, SqlString y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlString x, SqlString y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlString x, SqlString y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlString x, SqlString y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlString x, SqlString y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlDateTime"]/*' />
        public SqlDateTime ToSqlDateTime() {
            return (SqlDateTime)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlSingle"]/*' />
        public SqlSingle ToSqlSingle() {
            return (SqlSingle)this;
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.ToSqlGuid"]/*' />
        public SqlGuid ToSqlGuid() {
            return (SqlGuid)this;
        }




        // Utility functions and constants

/*
        private static readonly int SQL_IGNORECASE       = 0x00001000; // NORM_IGNORECASE
        private static readonly int SQL_IGNORENONSPACE   = 0x00002000; // NORM_IGNORENONSPACE
        private static readonly int SQL_IGNOREKANATYPE   = 0x00004000; // NORM_IGNOREKANATYPE
        private static readonly int SQL_IGNOREWIDTH      = 0x00008000; // NORM_IGNOREWIDTH
        private static readonly int SQL_BINARYSORT       = 0x00010000; // ON: Binary sort; OFF: Dictionary Sort

        private static readonly int SQL_VALID_LOCALE_MASK       = 0x0000003f;
        private static readonly int NLS_VALID_LOCALE_MASK       = 0x000fffff;
        private static readonly int SQL_VALID_LCIDVERSION_MASK  = 0x00fe0000;

        //  Code Page Default Values.
        private static readonly int CP_ACP = 0;           // default to ANSI code page

        // x_rgLocaleMap
        //
        // A list of the server supported Windows locales, each with its lcid, name and code page.
        //
        // Notes:
        // 
        //  - Must update x_rgIdxLocaleName if update this array; 
        //    - Code page has to be listed because a few are NT5 locales and 7.x server runs on NT4;
        //    Index is the SQL Server ordinal number;
        //  - A few Fulltext unique LCIDs are removed from the collation but kept here because
        //  LCID ordinal change implies on-disk change. The index in this array for each LCID is
        //    the ordinal for that LCID, and is maintained on disk. So we cannot move LCIDs around
        //    in this array - however, we can and should reuse the slots for the removed elements.
        //    The LCID to ordinal mapping is calculated automatically.
        //
        internal static readonly int x_lcidUnused = unchecked((int)0xffffffff); // Can reuse this slot for a new lcid
        internal static readonly SLocaleMapItem[] x_rgLocaleMap = new SLocaleMapItem[]{
            new SLocaleMapItem(0x0,             null,                       0   ), //0 "Language Neutral"/Binary data
            new SLocaleMapItem(0x00000401   ,   "Arabic",                   1256), //1
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //2  Fulltext unique; not supported in collations
            new SLocaleMapItem(0x00000404   ,   "Chinese_Taiwan_Stroke",    950 ), //3
            new SLocaleMapItem(0x00000405   ,   "Czech",                    1250), //4
            new SLocaleMapItem(0x00000406   ,   "Danish_Norwegian",         1252), //5
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //6  Fulltext unique; not supported in collations
            new SLocaleMapItem(0x00000408   ,   "Greek",                    1253), //7
            new SLocaleMapItem(0x00000409   ,   "Latin1_General",           1252), //8
            new SLocaleMapItem(0x0000040a   ,   "Mexican_Trad_Spanish",     1252), //9
            new SLocaleMapItem(0x0000040b   ,   "Finnish_Swedish",          1252), //a
            new SLocaleMapItem(0x0000040c   ,   "French",                   1252), //b
            new SLocaleMapItem(0x0000040d   ,   "Hebrew",                   1255), //c
            new SLocaleMapItem(0x0000040e   ,   "Hungarian",                1250), //d
            new SLocaleMapItem(0x0000040f   ,   "Icelandic",                1252), //e
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //f  Fulltext unique; not supported in collations
            new SLocaleMapItem(0x00000411   ,   "Japanese",                 932 ), //10
            new SLocaleMapItem(0x00000412   ,   "Korean_Wansung",           949 ), //11
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //12  Fulltext unique; not supported in collations
            new SLocaleMapItem(0x00000415   ,   "Polish",                   1250), //13
            new SLocaleMapItem(0x00000418   ,   "Romanian",                 1250), //14
            new SLocaleMapItem(0x00000419   ,   "Cyrillic_General",         1251), //15
            new SLocaleMapItem(0x0000041a   ,   "Croatian",                 1250), //16
            new SLocaleMapItem(0x0000041b   ,   "Slovak",                   1250), //17
            new SLocaleMapItem(0x0000041c   ,   "Albanian",                 1250), //18
            new SLocaleMapItem(0x0000041e   ,   "Thai",                     874 ), //19
            new SLocaleMapItem(0x0000041f   ,   "Turkish",                  1254), //1a
            new SLocaleMapItem(0x00000422   ,   "Ukrainian",                1251), //1b
            new SLocaleMapItem(0x00000424   ,   "Slovenian",                1250), //1c
            new SLocaleMapItem(0x00000425   ,   "Estonian",                 1257), //1d
            new SLocaleMapItem(0x00000426   ,   "Latvian",                  1257), //1e
            new SLocaleMapItem(0x00000427   ,   "Lithuanian",               1257), //1f
            new SLocaleMapItem(0x0000042a   ,   "Vietnamese",               1258), //20
            new SLocaleMapItem(0x0000042f   ,   "Macedonian",               1251), //21
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //22 0x00000439    ,    "Hindi",                    0,   //22
            new SLocaleMapItem(0x00000800   ,   null,                       CP_ACP), //23 LOCALE_SYSTEM_DEFAULT; used at startup
            new SLocaleMapItem(0x00000804   ,   "Chinese_PRC",              936 ), //24
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //25  Fulltext unique; not supported in collations
            new SLocaleMapItem(x_lcidUnused ,   null,                       0   ), //26  Fulltext unique; not supported in collations
            new SLocaleMapItem(0x00000827   ,   "Lithuanian_Classic",       1257), //27
            new SLocaleMapItem(0x00000c0a   ,   "Modern_Spanish",           1252), //28
            new SLocaleMapItem(0x00010407   ,   "German_PhoneBook",         1252), //29
            new SLocaleMapItem(0x0001040e   ,   "Hungarian_Technical",      1250), //2a
            new SLocaleMapItem(0x00010411   ,   "Japanese_Unicode",         932 ), //2b
            new SLocaleMapItem(0x00010412   ,   "Korean_Wansung_Unicode",   949 ), //2c
            new SLocaleMapItem(0x00010437   ,   "Georgian_Modern_sort",     1252), //2d
            new SLocaleMapItem(0x00020804   ,   "Chinese_PRC_Stroke",       936 ), //2e
            new SLocaleMapItem(0x00030404   ,   "Chinese_Taiwan_Bopomofo",  950 ) //2f
        };

        internal static readonly int x_cLocales         = x_rgLocaleMap.Length;
        internal static readonly int x_ordLCIDInvalid   = x_cLocales + 1;

        private static readonly int[] x_rgIdenticalLCIDs = new int[]
        {
            // a LCID //   // its identical sort LCID //
            0x00000402,    0x00000419,
            0x00000403,    0x00000409, // Catalan
            0x00000407,    0x00000409, // German
            0x00000410,    0x00000409, // Italian
            0x00000413,    0x00000409, // Dutch
            0x00000414,    0x00000406,
            0x00000416,    0x00000409,
            0x0000041d,    0x0000040b,
            0x00000420,    0x00000401,
            0x00000421,    0x00000409,
            0x00000423,    0x00000419,
            0x00000429,    0x00000401,
            0x0000042D,    0x00000409,
            0x00000436,    0x00000409,
            0x00000437,    0x00000409,
            0x00000438,    0x00000409,
            0x0000043e,    0x00000409,
            0x00000441,    0x00000409,
            0x00000801,    0x00000401,
            0x00000807,    0x00000409,
            0x00000809,    0x00000409, // English_UK
            0x0000080a,    0x0000040a,
            0x0000080c,    0x0000040c,
            0x00000810,    0x00000409,
            0x00000813,    0x00000409,
            0x00000814,    0x00000406,
            0x00000816,    0x00000409, // Portuguese
            0x0000081a,    0x00000419,
            0x0000081d,    0x0000040b,
            0x0000083e,    0x00000409,
            0x00000C01,    0x00000401,
            0x00000c04,    0x00000804,
            0x00000c07,    0x00000409,
            0x00000C09,    0x00000409,
            0x00000c0c,    0x0000040c,
            0x00000c1a,    0x00000419,
            0x00001001,    0x00000401,
            0x00001004,    0x00000804,
            0x00001007,    0x00000409,
            0x00001009,    0x00000409,
            0x0000100a,    0x00000c0a,
            0x0000100c,    0x0000040c,
            0x00001401,    0x00000401,
            0x00001404,    0x00000804,
            0x00001407,    0x00000409,
            0x00001409,    0x00000409,
            0x0000140a,    0x00000c0a,
            0x0000140c,    0x0000040c,
            0x00001801,    0x00000401,
            0x00001809,    0x00000409,
            0x0000180a,    0x00000c0a,
            0x0000180c,    0x0000040c,
            0x00001C01,    0x00000401,
            0x00001C09,    0x00000409,
            0x00001c0a,    0x00000c0a,
            0x00002001,    0x00000401,
            0x00002009,    0x00000409,
            0x0000200a,    0x00000c0a,
            0x00002401,    0x00000401,
            0x00002409,    0x00000409,
            0x00002801,    0x00000401,
            0x00002809,    0x00000409,
            0x0000280a,    0x00000c0a,
            0x00002C01,    0x00000401,
            0x00002C09,    0x00000409,
            0x00002c0a,    0x00000c0a,
            0x00003001,    0x00000401,
            0x00003009,    0x00000409,
            0x0000300a,    0x00000c0a,
            0x00003401,    0x00000401,
            0x00003409,    0x00000409,
            0x0000340a,    0x00000c0a,
            0x00003801,    0x00000401,
            0x0000380a,    0x00000c0a,
            0x00003c01,    0x00000401,
            0x00003c0a,    0x00000c0a,
            0x00004001,    0x00000401,
            0x0000400a,    0x00000c0a,
            0x0000440a,    0x00000c0a,
            0x0000480a,    0x00000c0a,
            0x00004c0a,    0x00000c0a,
            0x0000500a,    0x00000c0a,
            0x00020c04,    0x00020804,
            0x00021004,    0x00020804,
            0x00021404,    0x00020804,
        };

        private static readonly int x_cArray = x_rgIdenticalLCIDs.Length;

        private static CBuildLcidOrdMap x_LcidOrdMap = new CBuildLcidOrdMap(); // must be the final data member definition.


        private static int LCIDFromSQLCID(int cid) {
            return x_rgLocaleMap[(cid) & SQL_VALID_LOCALE_MASK].lcid; 
        }

        private static int FlagFromSQLCID(int cid) {
            int flag = (int)CompareOptions.None; // returns 0 -- all sensitive for binary sorting;

            if ((cid & SQL_BINARYSORT) != 0)
                flag = SQL_BINARYSORT;
            else {
                if ((cid & SQL_IGNORECASE) != 0)
                    flag |= (int)CompareOptions.IgnoreCase;
                if ((cid & SQL_IGNORENONSPACE) != 0)
                    flag |= (int)CompareOptions.IgnoreNonSpace;
                if ((cid & SQL_IGNOREKANATYPE) != 0)
                    flag |= (int)CompareOptions.IgnoreKanaType;
                if ((cid & SQL_IGNOREWIDTH) != 0)
                    flag |= (int)CompareOptions.IgnoreWidth;
            }

            return flag;
        }

        // FGetSortLcid
        //
        // Find the lcid group with the same sorting behavior.
        //
        private static bool FGetSortLcid(int lcid, out int lcidSort) {

            SQLDebug.Check(x_cArray % 2 == 0);

            int iStart = 0, iEnd = x_cArray / 2 - 1;
            int iMid;
            int lcidMid;

            //    binary search sort group LCID by given LCID   
            while (iStart <= iEnd) {
                iMid = (iStart + iEnd) / 2;
                lcidMid = x_rgIdenticalLCIDs[iMid*2];
                if (lcid == lcidMid) {
                    lcidSort = x_rgIdenticalLCIDs[iMid*2 + 1];
                    return true;
                }
                else if (lcid > lcidMid) {
                    iStart = iMid + 1;
                }
                else {
                    iEnd = iMid - 1;
                }
            }

            lcidSort = -1;
            return false;
        }

        // LCIDOrdFromLCID
        //
        // IN lcid
        //
        // Returns the ordinal corresponding to the lcid, using binary search
        // if lcid not found, return x_ordLCIDInvalid
        //
        int LCIDOrdFromLCID(int lcid) {
            int iStart = 0, iEnd = x_LcidOrdMap.m_cValidLocales - 1;
            int iMid = x_LcidOrdMap.m_uiPosEnglish; // Start search at US_English (Latin1_General)
            int lcidMid, lcidSort;

            //    binary search name by LCID
            do {
                lcidMid = x_LcidOrdMap.m_rgLcidOrdMap[iMid].lcid;
                if (lcid == lcidMid) {
                    return x_LcidOrdMap.m_rgLcidOrdMap[iMid].uiOrd;
                }
                else if (lcid > lcidMid) {
                    iStart = iMid + 1;
                }
                else {
                    iEnd = iMid - 1;
                }
                iMid = (iStart + iEnd)/2;
            }
            while (iStart <= iEnd);

            // Not found - means it was mapped
            // First find its corresponding sort lcid and if found map to the common sort LCID
            if (FGetSortLcid(lcid, out lcidSort)) {
                return LCIDOrdFromLCID(lcidSort);   // recurse
            }

            return x_ordLCIDInvalid;  // return invalid ordinal number
        }

        // MAKECID
        //
        // construct a SQL Server in memory/on-disk collatin ID from Windows LCID, Windows compflags,
        // SQL Server sort order for non-Unicode string if not zero, and LCID version.
        //
        // Notes:
        //   It handles the "binary unicode collation" represented by a special LCID in 7.0.
        //
        // UNDONE: sortid and versionid are both set to 0, need to restore sortid(it is already lost)?
        private int MAKECID(int lcid, int compFlags) {
            byte bSortid = 0;
            byte bVersion = 0;
            int cid = 0;
            if (lcid == x_lcidBinary) {
                cid |= SQL_BINARYSORT;
                // otherwise for Unicode binary collation, lower/upper are done
                // in Latin1_General locale
                lcid = x_lcidUSEnglish;
            }
            else {
                if ((compFlags & (int)CompareOptions.IgnoreCase) != 0)
                    cid |= SQL_IGNORECASE;
                if ((compFlags & (int)CompareOptions.IgnoreNonSpace) != 0)
                    cid |= SQL_IGNORENONSPACE;
                if ((compFlags & (int)CompareOptions.IgnoreKanaType) != 0)
                    cid |= SQL_IGNOREKANATYPE;
                if ((compFlags & (int)CompareOptions.IgnoreWidth) != 0)
                    cid |= SQL_IGNOREWIDTH;
            }

            cid |= LCIDOrdFromLCID(lcid & NLS_VALID_LOCALE_MASK);
            cid |= ((int)bSortid) << 24;
            cid |= ((int)bVersion << 17) & SQL_VALID_LCIDVERSION_MASK;
            return cid;
        }
*/

        private static void ValidateSqlCompareOptions(SqlCompareOptions compareOptions) {
            if ((compareOptions & x_iValidSqlCompareOptionMask) != compareOptions)
                throw new ArgumentOutOfRangeException ("compareOptions");
        }

        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.CompareOptionsFromSqlCompareOptions"]/*' />
        public static CompareOptions CompareOptionsFromSqlCompareOptions(SqlCompareOptions compareOptions) {
            CompareOptions options = CompareOptions.None;

			ValidateSqlCompareOptions(compareOptions);

            if ((compareOptions & SqlCompareOptions.BinarySort) != 0)
                throw new ArgumentOutOfRangeException ();
            else {
                if ((compareOptions & SqlCompareOptions.IgnoreCase) != 0)
                    options |= CompareOptions.IgnoreCase;
                if ((compareOptions & SqlCompareOptions.IgnoreNonSpace) != 0)
                    options |= CompareOptions.IgnoreNonSpace;
                if ((compareOptions & SqlCompareOptions.IgnoreKanaType) != 0)
                    options |= CompareOptions.IgnoreKanaType;
                if ((compareOptions & SqlCompareOptions.IgnoreWidth) != 0)
                    options |= CompareOptions.IgnoreWidth;
            }

            return  options;
        }

        private static SqlCompareOptions SqlCompareOptionsFromCompareOptions(CompareOptions compareOptions) {
            SqlCompareOptions sqlOptions = SqlCompareOptions.None;

            if ((compareOptions & x_iValidCompareOptionMask) != compareOptions)
                throw new ArgumentOutOfRangeException ("compareOptions");
            else {
                if ((compareOptions & CompareOptions.IgnoreCase) != 0)
                    sqlOptions |= SqlCompareOptions.IgnoreCase;
                if ((compareOptions & CompareOptions.IgnoreNonSpace) != 0)
                    sqlOptions |= SqlCompareOptions.IgnoreNonSpace;
                if ((compareOptions & CompareOptions.IgnoreKanaType) != 0)
                    sqlOptions |= SqlCompareOptions.IgnoreKanaType;
                if ((compareOptions & CompareOptions.IgnoreWidth) != 0)
                    sqlOptions |= SqlCompareOptions.IgnoreWidth;
            }

            return  sqlOptions;
        }

        private bool FBinarySort() {
            return(!IsNull && (m_flag & SqlCompareOptions.BinarySort) != 0);
        }

        //    Wide-character string comparison for Binary Unicode Collation
        //    Return values:
        //        -1 : wstr1 < wstr2 
        //        0  : wstr1 = wstr2 
        //        1  : wstr1 > wstr2 
        //
        //    Does a memory comparison.
        private static int CompareBinary(SqlString x, SqlString y) {
            byte[] rgDataX = x_UnicodeEncoding.GetBytes(x.m_value);
            byte[] rgDataY = x_UnicodeEncoding.GetBytes(y.m_value);
            int cbX = rgDataX.Length;
            int cbY = rgDataY.Length;
            int cbMin = cbX < cbY ? cbX : cbY;
            int i;

            SQLDebug.Check(cbX % 2 == 0);
            SQLDebug.Check(cbY % 2 == 0);

            for (i = 0; i < cbMin; i ++) {
                if (rgDataX[i] < rgDataY[i])
                    return -1;
                else if (rgDataX[i] > rgDataY[i])
                    return 1;
            }

            i = cbMin;

            int iCh;
            int iSpace = (int)' ';

            if (cbX < cbY) {
                for (; i < cbY; i += 2) {
                    iCh = ((int)rgDataY[i + 1]) << 8 + rgDataY[i];
                    if (iCh != iSpace)
                        return (iSpace > iCh) ? 1 : -1;
                }
            }
            else {
                for (; i < cbX; i += 2) {
                    iCh = ((int)rgDataX[i + 1]) << 8 + rgDataX[i];
                    if (iCh != iSpace)
                        return (iCh > iSpace) ? 1 : -1;
                }
            }

            return 0;
        }

        private void Print() {
            Debug.WriteLine("SqlString - ");
            Debug.WriteLine("\tlcid = " + m_lcid.ToString());
            Debug.Write("\t");
            if ((m_flag & SqlCompareOptions.IgnoreCase) != 0)
                Debug.Write("IgnoreCase, ");
            if ((m_flag & SqlCompareOptions.IgnoreNonSpace) != 0)
                Debug.Write("IgnoreNonSpace, ");
            if ((m_flag & SqlCompareOptions.IgnoreKanaType) != 0)
                Debug.Write("IgnoreKanaType, ");
            if ((m_flag & SqlCompareOptions.IgnoreWidth) != 0)
                Debug.Write("IgnoreWidth, ");
            Debug.WriteLine("");
            Debug.WriteLine("\tvalue = " + m_value);
            Debug.WriteLine("\tcmpinfo = " + m_cmpInfo);
        }

        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlString) {
                SqlString i = (SqlString)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlString)) {
                return false;
            }

            SqlString i = (SqlString)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLString.uex' path='docs/doc[@for="SqlString.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : m_value.GetHashCode();
        }

    } // SqlString

/*
    internal struct SLocaleMapItem {
        public int      lcid;           // the primary key, not nullable
        public String   name;           // unique, nullable
        public int      idCodePage;     // the ANSI default code page of the locale

        public SLocaleMapItem(int lid, String str, int cpid) {
            lcid = lid;
            name = str;
            idCodePage = cpid;
        }
    }

    // Struct to map lcid to ordinal
    internal struct SLcidOrdMapItem {
        internal int    lcid;
        internal int    uiOrd;
    };

    // Class to store map of lcids to ordinal
    internal class CBuildLcidOrdMap {
        internal SLcidOrdMapItem[] m_rgLcidOrdMap;
        internal int m_cValidLocales;
        internal int m_uiPosEnglish; // Start binary searches here - this is index in array, not ordinal

        // Constructor builds the array sorted by lcid
        // We use a simple n**2 sort because the array is mostly sorted anyway
        // and objects of this class will be const, hence this will be called
        // only by VC compiler
        public CBuildLcidOrdMap() {
            int i,j;

            m_rgLcidOrdMap = new SLcidOrdMapItem[SqlString.x_cLocales];

            // Compact the array
            for (i=0,j=0; i < SqlString.x_cLocales; i++) {
                if (SqlString.x_rgLocaleMap[i].lcid != SqlString.x_lcidUnused) {
                    m_rgLcidOrdMap[j].lcid = SqlString.x_rgLocaleMap[i].lcid; 
                    m_rgLcidOrdMap[j].uiOrd = i;
                    j++;
                }
            }

            m_cValidLocales = j;

            // Set the rest to invalid
            while (j < SqlString.x_cLocales) {
                m_rgLcidOrdMap[j].lcid = SqlString.x_lcidUnused;
                m_rgLcidOrdMap[j].uiOrd = 0;
                j++;
            }

            // Now sort in place
            // Algo:
            // Start from 1, assume list before i is sorted, if next item
            // violates this assumption, exchange with prev items until the
            // item is in its correct place
            for (i=1; i<m_cValidLocales; i++) {
                for (j=i; j>0 && 
                    m_rgLcidOrdMap[j].lcid < m_rgLcidOrdMap[j-1].lcid; j--) {
                    // Swap with prev element
                    int lcidTemp = m_rgLcidOrdMap[j-1].lcid;
                    int uiOrdTemp = m_rgLcidOrdMap[j-1].uiOrd;
                    m_rgLcidOrdMap[j-1].lcid = m_rgLcidOrdMap[j].lcid;
                    m_rgLcidOrdMap[j-1].uiOrd = m_rgLcidOrdMap[j].uiOrd;
                    m_rgLcidOrdMap[j].lcid = lcidTemp;
                    m_rgLcidOrdMap[j].uiOrd = uiOrdTemp;
                }
            }

            // Set the position of the US_English LCID (Latin1_General)
            for (i=0; i<m_cValidLocales && m_rgLcidOrdMap[i].lcid != SqlString.x_lcidUSEnglish; i++)
                ; // Deliberately empty

            SQLDebug.Check(i<m_cValidLocales);  // Latin1_General better be present
            m_uiPosEnglish = i;     // This is index in array, not ordinal
        }

    } // CBuildLcidOrdMap
*/

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlsingle.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLSingle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SqlSingle.cs
//
// Create by:    JunFang
//
// Purpose: Implementation of SqlSingle which is equivalent to 
//            data type "real" in SQL Server
//
// Notes: 
//    
// History:
//
//   1/30/2000  JunFang        Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a floating point number within the range of -3.40E +38 through
    ///       3.40E +38 to be stored in or retrieved from a database.
    ///    </para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct SqlSingle : INullable, IComparable {
        private float m_value;
        private bool m_fNotNull; // false if null

        // constructor
        // construct a Null
        private SqlSingle(bool fNull) {
            m_fNotNull = false;
            m_value = (float)0.0;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.SqlSingle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlSingle(float value) {
            if (Single.IsInfinity(value) || Single.IsNaN(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else {
                m_fNotNull = true;
                m_value = value;
            }
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.SqlSingle1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SqlSingle(double value) {
            if (value > Single.MaxValue || value < Single.MinValue)
                throw new OverflowException(SQLResource.ArithOverflowMessage);
            else {
                m_value = (float)value;
                m_fNotNull = true;
            }
        }

        // INullable
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get { return !m_fNotNull;}
        }

        // property: Value
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public float Value {
            get {
                if (m_fNotNull)
                    return m_value;
                else
                    throw new SqlNullValueException();
            }
        }

        // Implicit conversion from float to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(float x) {
            return new SqlSingle(x);
        }

        // Explicit conversion from SqlSingle to float. Throw exception if x is Null.
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorfloat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator float(SqlSingle x) {
            return x.Value;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String ToString() {
            return IsNull ? SQLResource.NullString : m_value.ToString();
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle Parse(String s) {
            return new SqlSingle(Single.Parse(s, CultureInfo.InvariantCulture));
        }


        // Unary operators
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator-"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle operator -(SqlSingle x) {
            return x.IsNull ? Null : new SqlSingle(-x.m_value);
        }


        // Binary operators

        // Arithmetic operators
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator+"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle operator +(SqlSingle x, SqlSingle y) {
            if (x.IsNull || y.IsNull)
                return Null;

            float value = x.m_value + y.m_value;

            if (Single.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlSingle(value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator-1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle operator -(SqlSingle x, SqlSingle y) {
            if (x.IsNull || y.IsNull)
                return Null;

            float value = x.m_value - y.m_value;

            if (Single.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlSingle(value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator*"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle operator *(SqlSingle x, SqlSingle y) {
            if (x.IsNull || y.IsNull)
                return Null;

            float value = x.m_value * y.m_value;

            if (Single.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlSingle(value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator/"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlSingle operator /(SqlSingle x, SqlSingle y) {
            if (x.IsNull || y.IsNull)
                return Null;

            if (y.m_value == (float)0.0)
                throw new DivideByZeroException(SQLResource.DivideByZeroMessage);

            float value = x.m_value / y.m_value;

            if (Single.IsInfinity(value))
                throw new OverflowException(SQLResource.ArithOverflowMessage);

            return new SqlSingle(value);
        }



        // Implicit conversions

        // Implicit conversion from SqlBoolean to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlSingle(SqlBoolean x) {
            return x.IsNull ? Null : new SqlSingle(x.ByteValue);
        }

        // Implicit conversion from SqlByte to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlByte x) {
            // Will not overflow
            return x.IsNull ? Null : new SqlSingle((float)(x.Value));
        }

        // Implicit conversion from SqlInt16 to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlInt16 x) {
            // Will not overflow
            return x.IsNull ? Null : new SqlSingle((float)(x.Value));
        }

        // Implicit conversion from SqlInt32 to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlInt32 x) {
            // Will not overflow
            return x.IsNull ? Null : new SqlSingle((float)(x.Value));
        }

        // Implicit conversion from SqlInt64 to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlInt64 x) {
            // Will not overflow
            return x.IsNull ? Null : new SqlSingle((float)(x.Value));
        }

        // Implicit conversion from SqlMoney to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlMoney x) {
            return x.IsNull ? Null : new SqlSingle(x.ToDouble());
        }

        // Implicit conversion from SqlDecimal to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static implicit operator SqlSingle(SqlDecimal x) {
            // Will not overflow
            return x.IsNull ? Null : new SqlSingle(x.ToDouble());
        }


        // Explicit conversions


        // Explicit conversion from SqlDouble to SqlSingle
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlSingle(SqlDouble x) {
            return x.IsNull ? Null : new SqlSingle(x.Value);
        }

        // Explicit conversion from SqlString to SqlSingle
        // Throws FormatException or OverflowException if necessary.
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorSqlSingle9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static explicit operator SqlSingle(SqlString x) {
            if (x.IsNull)
                return SqlSingle.Null;
            return Parse(x.Value);
        }



        // Builtin functions
        internal    static    SqlSingle    Abs(   SqlSingle    x) {
            if (x.IsNull || x.m_value >= 0)
                return x;
            else
                return new SqlSingle(- x.m_value);
        }

        // Overloading comparison operators
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator==(SqlSingle x, SqlSingle y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value == y.m_value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator!=(SqlSingle x, SqlSingle y) {
            return ! (x == y);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorLT"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<(SqlSingle x, SqlSingle y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value < y.m_value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator>"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>(SqlSingle x, SqlSingle y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value > y.m_value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operatorLE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator<=(SqlSingle x, SqlSingle y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value <= y.m_value);
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.operator>="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SqlBoolean operator>=(SqlSingle x, SqlSingle y) {
            return(x.IsNull || y.IsNull) ? SqlBoolean.Null : new SqlBoolean(x.m_value >= y.m_value);
        }

        //--------------------------------------------------
        // Alternative methods for overloaded operators
        //--------------------------------------------------

        // Alternative method for operator +
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Add"]/*' />
        public static SqlSingle Add(SqlSingle x, SqlSingle y) {
            return x + y;
        }
        // Alternative method for operator -
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Subtract"]/*' />
        public static SqlSingle Subtract(SqlSingle x, SqlSingle y) {
            return x - y;
        }

        // Alternative method for operator *
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Multiply"]/*' />
        public static SqlSingle Multiply(SqlSingle x, SqlSingle y) {
            return x * y;
        }

        // Alternative method for operator /
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Divide"]/*' />
        public static SqlSingle Divide(SqlSingle x, SqlSingle y) {
            return x / y;
        }

        // Alternative method for operator ==
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Equals1"]/*' />
        public static SqlBoolean Equals(SqlSingle x, SqlSingle y) {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.NotEquals"]/*' />
        public static SqlBoolean NotEquals(SqlSingle x, SqlSingle y) {
            return (x != y);
        }

        // Alternative method for operator <
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.LessThan"]/*' />
        public static SqlBoolean LessThan(SqlSingle x, SqlSingle y) {
            return (x < y);
        }

        // Alternative method for operator >
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.GreaterThan"]/*' />
        public static SqlBoolean GreaterThan(SqlSingle x, SqlSingle y) {
            return (x > y);
        }

        // Alternative method for operator <=
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.LessThanOrEqual"]/*' />
        public static SqlBoolean LessThanOrEqual(SqlSingle x, SqlSingle y) {
            return (x <= y);
        }

        // Alternative method for operator >=
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.GreaterThanOrEqual"]/*' />
        public static SqlBoolean GreaterThanOrEqual(SqlSingle x, SqlSingle y) {
            return (x >= y);
        }

        // Alternative method for conversions.

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlBoolean"]/*' />
        public SqlBoolean ToSqlBoolean() {
            return (SqlBoolean)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlByte"]/*' />
        public SqlByte ToSqlByte() {
            return (SqlByte)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlDouble"]/*' />
        public SqlDouble ToSqlDouble() {
            return (SqlDouble)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlInt16"]/*' />
        public SqlInt16 ToSqlInt16() {
            return (SqlInt16)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlInt32"]/*' />
        public SqlInt32 ToSqlInt32() {
            return (SqlInt32)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlInt64"]/*' />
        public SqlInt64 ToSqlInt64() {
            return (SqlInt64)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlMoney"]/*' />
        public SqlMoney ToSqlMoney() {
            return (SqlMoney)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlDecimal"]/*' />
        public SqlDecimal ToSqlDecimal() {
            return (SqlDecimal)this;
        }

        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.ToSqlString"]/*' />
        public SqlString ToSqlString() {
            return (SqlString)this;
        }


        // IComparable
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, zero if this = object, 
        // or a value greater than zero if this > object.
        // null is considered to be less than any instance.
        // If object is not of same type, this method throws an ArgumentException.
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CompareTo(Object value) {
            if (value is SqlSingle) {
                SqlSingle i = (SqlSingle)value;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this < i) return -1;
                if (this > i) return 1;
                return 0;
            }
            throw new ArgumentException ();
        }

        // Compares this instance with a specified object
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(Object value) {
            if (!(value is SqlSingle)) {
                return false;
            }

            SqlSingle i = (SqlSingle)value;

            if (i.IsNull || IsNull)
                return (i.IsNull && IsNull);
            else
                return (this == i).Value;
        }

        // For hashing purpose
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return IsNull ? 0 : Value.GetHashCode();
        }


        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlSingle Null       = new SqlSingle(true);
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.Zero"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlSingle Zero       = new SqlSingle((float)0.0);
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.MinValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlSingle MinValue   = new SqlSingle(Single.MinValue);
        /// <include file='doc\SQLSingle.uex' path='docs/doc[@for="SqlSingle.MaxValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly SqlSingle MaxValue   = new SqlSingle(Single.MaxValue);

    } // SqlSingle

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\basetreeiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseTreeIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   BaseTreeIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.Data;
    using System.Diagnostics;

    // Iterates over non-attribute nodes
    internal abstract class BaseTreeIterator {
        protected DataSetMapper   mapper;

        internal BaseTreeIterator( DataSetMapper mapper ) {
            this.mapper      = mapper;
        }

        internal abstract void Reset();

        internal abstract XmlNode CurrentNode { get; }

        internal abstract bool Next();
        internal abstract bool NextRight();

        internal bool NextRowElement() {
            while ( Next() ) {
                if ( OnRowElement() )
                    return true;
            }
            return false;
        }

        internal bool NextRightRowElement() {
            if ( NextRight() ) {
                if ( OnRowElement() )
                    return true;
                return NextRowElement();
            }
            return false;
        }

        // Returns true if the current node is on a row element (head of a region)
        internal bool OnRowElement() {
            XmlBoundElement be = CurrentNode as XmlBoundElement;
            return (be != null) && (be.Row != null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlutility.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLUtility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SQLUtility.cs
//
// Create by:	JunFang
//
// Purpose: Implementation of utilities in COM+ SQL Types Library.
//			Includes interface INullable, exceptions SqlNullValueException
//			and SqlTruncateException, and SQLDebug class.
//
// Notes: 
//	
// History:
//
//   09/17/99  JunFang	Created and implemented as first drop.
//
// @EndHeader@
//**************************************************************************

using System;
using System.Diagnostics;
using System.Runtime.Serialization;

namespace System.Data.SqlTypes {

    /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="INullable"]/*' />
    public interface INullable {
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="INullable.IsNull"]/*' />
        bool IsNull { get;}
    }

    internal enum EComparison {
        LT,
        LE,
        EQ,
        GE,
        GT,
        NE
    }

    /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException"]/*' />
    [Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class SqlTypeException : SystemException, ISerializable {

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException.SqlTypeException3"]/*' />
        public SqlTypeException() : base() { // MDAC 82931
        }

        // Creates a new SqlTypeException with its message string set to message. 
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException.SqlTypeException"]/*' />
        public SqlTypeException(String message) : base(message) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException.SqlTypeException2"]/*' />
        public SqlTypeException(String message, Exception e) : base(message, e) { // MDAC 82931
        }

        // runtime will call even if private...
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException.SqlTypeException1"]/*' />
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        protected SqlTypeException(SerializationInfo si, StreamingContext sc) 
			: base((String) si.GetValue("SqlTypeExceptionMessage", typeof(String))) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTypeException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("SqlTypeExceptionMessage", Message, typeof(String));
        }

    } // SqlTypeException

    /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlNullValueException"]/*' />
    [Serializable]
    public sealed class SqlNullValueException : SqlTypeException, ISerializable {

        // Creates a new SqlNullValueException with its message string set to the common string.
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlNullValueException.SqlNullValueException"]/*' />
        public SqlNullValueException() : base(SQLResource.NullValueMessage) {
        }

        // Creates a new NullValueException with its message string set to message. 
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlNullValueException.SqlNullValueException1"]/*' />
        public SqlNullValueException(String message) : base(message) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlNullValueException.SqlNullValueException2"]/*' />
        public SqlNullValueException(String message, Exception e) : base(message, e) { // MDAC 82931
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private SqlNullValueException(SerializationInfo si, StreamingContext sc) 
			: base((String) si.GetValue("SqlNullValueExceptionMessage", typeof(String))) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlNullValueException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("SqlNullValueExceptionMessage", Message, typeof(String));
        }

    } // NullValueException

    /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTruncateException"]/*' />
    [Serializable]
    public sealed class SqlTruncateException : SqlTypeException, ISerializable {

        // Creates a new SqlTruncateException with its message string set to the empty string. 
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTruncateException.SqlTruncateException"]/*' />
        public SqlTruncateException() : base(SQLResource.TruncationMessage) {
        }

        // Creates a new SqlTruncateException with its message string set to message. 
        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTruncateException.SqlTruncateException1"]/*' />
        public SqlTruncateException(String message) : base(message) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTruncateException.SqlTruncateException2"]/*' />
        public SqlTruncateException(String message, Exception e) : base(message, e) { // MDAC 82931
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private SqlTruncateException(SerializationInfo si, StreamingContext sc) 
			: base((String) si.GetValue("SqlTruncateExceptionMessage", typeof(String))) {
        }

        /// <include file='doc\SQLUtility.uex' path='docs/doc[@for="SqlTruncateException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("SqlTruncateExceptionMessage", Message, typeof(String));
        }

    } // SqlTruncateException

    internal class SQLDebug {
        [System.Diagnostics.Conditional("DEBUG")] 
        internal static void Check(bool condition) {
            Debug.Assert(condition, "", "");
        }

        [System.Diagnostics.Conditional("DEBUG")] 
        internal static void Check(bool condition, String conditionString, string message) {
            Debug.Assert(condition, conditionString, message);
        }

        [System.Diagnostics.Conditional("DEBUG")] 
        internal static void Check(bool condition, String conditionString) {
            Debug.Assert(condition, conditionString, "");
        }

        [System.Diagnostics.Conditional("DEBUG")] 
        internal static void Message(String traceMessage) {
            Debug.WriteLine(SQLResource.MessageString + ": " + traceMessage);
        }

    } // SQLDebug

} // namespace System.Data.SqlTypes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqltypes\sqlresource.cs ===
//------------------------------------------------------------------------------
// <copyright file="SQLResource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//**************************************************************************
// @File: SQLResource.cs
//
// Create by:	JunFang
//
// Purpose: Implementation of utilities in COM+ SQL Types Library.
//			Includes interface INullable, exceptions SqlNullValueException
//			and SqlTruncateException, and SQLDebug class.
//
// Notes: 
//	
// History:
//
//   10/22/99  JunFang	Created.
//
// @EndHeader@
//**************************************************************************

using System;

namespace System.Data.SqlTypes {
    internal class SQLResource {
        internal static readonly String NullString                  = Res.GetString(Res.SqlMisc_NullString);

        internal static readonly String MessageString               = Res.GetString(Res.SqlMisc_MessageString);

        internal static readonly String ArithOverflowMessage        = Res.GetString(Res.SqlMisc_ArithOverflowMessage);

        internal static readonly String DivideByZeroMessage         = Res.GetString(Res.SqlMisc_DivideByZeroMessage);

        internal static readonly String NullValueMessage            = Res.GetString(Res.SqlMisc_NullValueMessage);

        internal static readonly String TruncationMessage           = Res.GetString(Res.SqlMisc_TruncationMessage);

        internal static readonly String DateTimeOverflowMessage     = Res.GetString(Res.SqlMisc_DateTimeOverflowMessage);

        internal static readonly String ConcatDiffCollationMessage  = Res.GetString(Res.SqlMisc_ConcatDiffCollationMessage);

        internal static readonly String CompareDiffCollationMessage = Res.GetString(Res.SqlMisc_CompareDiffCollationMessage);

        internal static readonly String InvalidFlagMessage          = Res.GetString(Res.SqlMisc_InvalidFlagMessage);

        internal static readonly String NumeToDecOverflowMessage    = Res.GetString(Res.SqlMisc_NumeToDecOverflowMessage);

        internal static readonly String ConversionOverflowMessage   = Res.GetString(Res.SqlMisc_ConversionOverflowMessage);

        internal static readonly String InvalidDateTimeMessage      = Res.GetString(Res.SqlMisc_InvalidDateTimeMessage);

        internal static readonly String InvalidArraySizeMessage     = Res.GetString(Res.SqlMisc_InvalidArraySizeMessage);

        internal static readonly String InvalidPrecScaleMessage     = Res.GetString(Res.SqlMisc_InvalidPrecScaleMessage);

        internal static readonly String FormatMessage               = Res.GetString(Res.SqlMisc_FormatMessage);

    } // SqlResource

} // namespace System
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\ixmldatavirtualnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="IXmlDataVirtualNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IXmlDataVirtualNode.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {

    using System;
    using System.Data;

    internal interface IXmlDataVirtualNode {
        bool IsOnNode( XmlNode nodeToCheck );
        bool IsOnColumn(DataColumn col );
        bool IsInUse();
        void OnFoliated( XmlNode foliatedNode );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\datadocumentxpathnavigator.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataDocumentXPathNavigator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DataDocumentXPathNavigator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.Data;
    using System.Collections;
    using System.Text;
    using System.Xml.XPath;
    using System.Diagnostics;

    internal class DataDocumentXPathNavigator: XPathNavigator, IHasXmlNode {
        private XPathNodePointer    _curNode;           //pointer to remember the current node position
        private XmlDataDocument     _doc;              //pointer to remember the root -- can only be XmlDataDocument for DataDocumentXPathNavigator
        private XPathNodePointer    _temp;           
         
        internal DataDocumentXPathNavigator( XmlDataDocument doc, XmlNode node ) {
            _curNode = new XPathNodePointer( this, doc, node );
            _temp = new XPathNodePointer( this, doc, node );
            _doc = doc;
        }

        private DataDocumentXPathNavigator( DataDocumentXPathNavigator other ) {
            this._curNode = other._curNode.Clone( this );
            this._temp = other._temp.Clone( this );
            this._doc = other._doc;
        }
        public override XPathNavigator Clone(){
            return new DataDocumentXPathNavigator( this );
        }

        internal XPathNodePointer CurNode { get { return _curNode; } }
        internal XmlDataDocument Document { get { return _doc; } }

        //Convert will deal with nodeType as Attribute or Namespace nodes
        public override XPathNodeType NodeType { get { return _curNode.NodeType; } }

        public override string LocalName { get { return _curNode.LocalName; } }

        public override string NamespaceURI { get { return _curNode.NamespaceURI; } }

        public override string Name { get { return _curNode.Name; } }

        public override string Prefix { get { return _curNode.Prefix; } }

        public override string Value { 
            get { 
                XPathNodeType xnt = _curNode.NodeType;
                if ( xnt == XPathNodeType.Element || xnt == XPathNodeType.Root )
                    return _curNode.InnerText; 
                return _curNode.Value;
            } 
        }

        public override String BaseURI { get { return _curNode.BaseURI; } }

        public override String XmlLang { get { return _curNode.XmlLang; } }
        
        public override bool IsEmptyElement { get { return _curNode.IsEmptyElement; } }

        public override XmlNameTable NameTable { get { return _doc.NameTable; } }

        // Attributes
        public override bool HasAttributes { get { return _curNode.AttributeCount > 0; } }

        public override string GetAttribute( string localName, string namespaceURI ) {
            if ( _curNode.NodeType != XPathNodeType.Element )
                return string.Empty; //other type of nodes can't have attributes
            _temp.MoveTo( _curNode );
            if ( _temp.MoveToAttribute( localName, namespaceURI ) )
                return _temp.Value;
            return string.Empty;
        }

//#if SupportNamespaces

        public override string GetNamespace(string name) {
            return _curNode.GetNamespace( name );
        }

        public override bool MoveToNamespace(string name) {
            if ( _curNode.NodeType != XPathNodeType.Element )
                return false;
            return _curNode.MoveToNamespace( name );
        }

        public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope) {
            if ( _curNode.NodeType != XPathNodeType.Element )
                return false;
            return _curNode.MoveToFirstNamespace(namespaceScope);
        }

        public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope) {
            if ( _curNode.NodeType != XPathNodeType.Namespace )
                return false;
            return _curNode.MoveToNextNamespace(namespaceScope);
        }
//#endif        

        public override bool MoveToAttribute( string localName, string namespaceURI ) {
            if ( _curNode.NodeType != XPathNodeType.Element )
                return false; //other type of nodes can't have attributes
            return _curNode.MoveToAttribute( localName, namespaceURI );
        }

        public override bool MoveToFirstAttribute() {
            if ( _curNode.NodeType != XPathNodeType.Element )
                return false; //other type of nodes can't have attributes
            return _curNode.MoveToNextAttribute(true);
        }

        public override bool MoveToNextAttribute() {
            if ( _curNode.NodeType != XPathNodeType.Attribute ) 
                return false;
            return _curNode.MoveToNextAttribute(false);
        }


        // Tree
        public override bool MoveToNext() {
            if ( _curNode.NodeType == XPathNodeType.Attribute ) 
                return false;
            return _curNode.MoveToNextSibling();
        }

        public override bool MoveToPrevious() {
            if ( _curNode.NodeType == XPathNodeType.Attribute ) 
                return false;
            return _curNode.MoveToPreviousSibling();
        }

        public override bool MoveToFirst() {
            if ( _curNode.NodeType == XPathNodeType.Attribute ) 
                return false;
            return _curNode.MoveToFirst();
        }

        public override bool HasChildren { get { return _curNode.HasChildren; } }

        public override bool MoveToFirstChild() {
            return _curNode.MoveToFirstChild();
        }

        public override bool MoveToParent() {
            return _curNode.MoveToParent();
        }

        public override void MoveToRoot() {
            _curNode.MoveToRoot();
        }

        public override bool MoveTo( XPathNavigator other ) {
            if ( other == null )
                return false;
            DataDocumentXPathNavigator otherDataDocXPathNav = other as DataDocumentXPathNavigator;
            if ( otherDataDocXPathNav != null ) {
                if ( _curNode.MoveTo( otherDataDocXPathNav.CurNode ) ) {
                    _doc = _curNode.Document;
                    return true;
                } 
                else
                    return false;
            }
            return false;
        }

        //doesn't support MoveToId
        public override bool MoveToId( string id ) {
            return false;
        }

        public override bool IsSamePosition( XPathNavigator other ) {
            if ( other == null )
                return false;
            DataDocumentXPathNavigator otherDataDocXPathNav = other as DataDocumentXPathNavigator;
            if ( otherDataDocXPathNav != null ) {
                if ( this._doc == otherDataDocXPathNav.Document && this._curNode.IsSamePosition(otherDataDocXPathNav.CurNode) )
                    return true;
            }
            return false;
        }

        //the function is only called for XPathNodeList enumerate nodes and 
        // shouldn't be promoted to frequently use because it will cause foliation
        XmlNode IHasXmlNode.GetNode() { return _curNode.Node; }

        public override XmlNodeOrder ComparePosition( XPathNavigator other ) {
            if ( other == null )
                throw new NullReferenceException();
            
            DataDocumentXPathNavigator otherDataDocXPathNav = other as DataDocumentXPathNavigator;

            if ( otherDataDocXPathNav == null || otherDataDocXPathNav.Document != this._doc )
                return XmlNodeOrder.Unknown;            

            return this._curNode.ComparePosition( otherDataDocXPathNav.CurNode );
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\datapointer.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataPointer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DataPointer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.IO;
    using System.Data;
    using System.Collections;
    using System.Text;
    using System.Diagnostics;
    
    internal class DataPointer : IXmlDataVirtualNode {
        private XmlDataDocument doc;
        private XmlNode node;
        private DataColumn column;
        private bool fOnValue;
        private bool bNeedFoliate = false;
        private bool _isInUse;

        internal DataPointer( XmlDataDocument doc, XmlNode node ) {
            this.doc = doc;
            this.node = node;
            this.column = null;
            this.fOnValue = false;
            bNeedFoliate = false;
            this._isInUse = true;
            this.doc.AddPointer( (IXmlDataVirtualNode)this );
            AssertValid();
        }

        internal DataPointer( DataPointer pointer ) {
            this.doc = pointer.doc;
            this.node = pointer.node;
            this.column = pointer.column;
            this.fOnValue = pointer.fOnValue;
            this.bNeedFoliate = false;
            this._isInUse = true;
            this.doc.AddPointer( (IXmlDataVirtualNode)this );
            AssertValid();
        }

        // Returns the row element of the region that the pointer points into
        private XmlBoundElement GetRowElement() {
            //AssertValid();

            XmlBoundElement rowElem;
            if ( this.column != null ) {
                rowElem = this.node as XmlBoundElement;
                Debug.Assert( rowElem != null );
                Debug.Assert( rowElem.Row != null );
                return rowElem;
            }

            doc.Mapper.GetRegion( this.node, out rowElem );
            return rowElem;
        }

        private DataRow Row {
            get { 
                //AssertValid();
                XmlBoundElement rowElem = GetRowElement();
                if ( rowElem == null )
                    return null;

                Debug.Assert( rowElem.Row != null );
                return rowElem.Row;
            }
        }

        private static bool IsFoliated( XmlNode node ) {
            if (node != null && node is XmlBoundElement)
                return((XmlBoundElement)node).IsFoliated;
            return true;
        }
        
        internal void MoveTo( DataPointer pointer ) {
            AssertValid();
            // You should not move outside of this document
            Debug.Assert( node == this.doc || node.OwnerDocument == this.doc );

            this.doc = pointer.doc;
            this.node = pointer.node;
            this.column = pointer.column;
            this.fOnValue = pointer.fOnValue;
            AssertValid();
        }
        private void MoveTo( XmlNode node ) {
            //AssertValid();
            // You should not move outside of this document
            Debug.Assert( node == this.doc || node.OwnerDocument == this.doc );

            this.node = node;
            this.column = null;
            this.fOnValue = false;
            AssertValid();
        }
        
        private void MoveTo( XmlNode node, DataColumn column, bool fOnValue ) {
            //AssertValid();
            // You should not move outside of this document
            Debug.Assert( node == this.doc || node.OwnerDocument == this.doc );

            this.node = node;
            this.column = column;
            this.fOnValue = fOnValue;
            AssertValid();
        }

        private DataColumn NextColumn( DataRow row, DataColumn col, bool fAttribute, bool fNulls ) {
            if (row.RowState == DataRowState.Deleted)
                return null;

            DataTable table = row.Table;
            DataColumnCollection columns = table.Columns;
            int iColumn = (col != null) ? col.Ordinal + 1 : 0;
            int cColumns = columns.Count;
            DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;

            for (; iColumn < cColumns; iColumn++) {
                DataColumn c = columns[iColumn];
                if (!doc.IsNotMapped( c ) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && (fNulls || ! Convert.IsDBNull( row[c, rowVersion] ) ) )
                    return c;
            }

            return null;
        }

        private DataColumn NthColumn( DataRow row, bool fAttribute, int iColumn, bool fNulls ) {
            DataColumn c = null;
            while ((c = NextColumn( row, c, fAttribute, fNulls )) != null) {
                if (iColumn == 0)
                    return c;

                iColumn--;
            }
            return null;
        }

        private int ColumnCount( DataRow row, bool fAttribute, bool fNulls ) {
            DataColumn c = null;
            int count = 0;
            while ((c = NextColumn( row, c, fAttribute, fNulls )) != null) {
                count++;
            }
            return count;
        }

        internal bool MoveToFirstChild() {
            RealFoliate();
            AssertValid();
            if (node == null)
                return false;

            if (column != null) {
                if (fOnValue)
                    return false;

                fOnValue = true;
                return true;
            }
            else if (!IsFoliated( node )) {
                // find virtual column elements first
                DataColumn c = NextColumn( Row, null, false, false );
                if (c != null) {
                    MoveTo( node, c, doc.IsTextOnly(c) );
                    return true;
                }
            }

            // look for anything
            XmlNode n = doc.SafeFirstChild( node );
            if (n != null) {
                MoveTo(n);
                return true;
            }

            return false;
        }

        internal bool MoveToNextSibling() {
            RealFoliate();
            AssertValid();
            if (node != null) {
                if (column != null) {
                    if (fOnValue && !doc.IsTextOnly(column))
                        return false;

                    DataColumn c = NextColumn( Row, column, false, false );
                    if (c != null) {
                        MoveTo( this.node, c, false );
                        return true;
                    }

                    XmlNode n = doc.SafeFirstChild( node );
                    if (n != null) {
                        MoveTo( n );
                        return true;
                    }
                }
                else {
                    XmlNode n = doc.SafeNextSibling( node );
                    if (n != null) {
                        MoveTo(n);
                        return true;
                    }
                }
            }

            return false;
        }

        internal bool MoveToParent() {
            RealFoliate();
            AssertValid();
            if (node != null) {
                if (column != null) {
                    if (fOnValue && !doc.IsTextOnly(column)) {
                        MoveTo( node, column, false );
                        return true;
                    }

                    if (column.ColumnMapping != MappingType.Attribute) {
                        MoveTo( node, null, false );
                        return true;
                    }
                }
                else {
                    XmlNode n = node.ParentNode;
                    if (n != null) {
                        MoveTo(n);
                        return true;
                    }
                }
            }
            return false;
        }

        internal bool MoveToOwnerElement() {
            RealFoliate();
            AssertValid();
            if (node != null) {
                if (column != null) {
                    if (fOnValue || doc.IsTextOnly(column) || column.ColumnMapping != MappingType.Attribute)
                        return false;

                    MoveTo( node, null, false );
                    return true;
                }
                else if (node.NodeType == XmlNodeType.Attribute) {
                    XmlNode n = ((XmlAttribute)node).OwnerElement;
                    if (n != null) {
                        MoveTo( n, null, false );
                        return true;
                    }
                }
            }

            return false;
        }


        internal int AttributeCount {
            get {
                RealFoliate();
                AssertValid();
                if (node != null) {
                    if (column == null && node.NodeType == XmlNodeType.Element) {
                        if (!IsFoliated( node )) {
                            return ColumnCount( Row, true, false );
                        }
                        else 
                            return node.Attributes.Count;
                    }
                }
                return 0;
            }            
        }

        internal bool MoveToAttribute( int i ) {
            RealFoliate();
            AssertValid();
            if ( i < 0 ) 
                return false;
            if (node != null) {
                if ((column == null || column.ColumnMapping == MappingType.Attribute) && node.NodeType == XmlNodeType.Element) {
                    if (!IsFoliated( node )) {
                        DataColumn c = NthColumn( Row, true, i, false );
                        if (c != null) {
                            MoveTo( node, c, false );
                            return true;
                        }
                    }
                    else {
                        XmlNode n = node.Attributes.Item(i);
                        if (n != null) {
                            MoveTo( n, null, false );
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        internal XmlNodeType NodeType { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return XmlNodeType.None;
                }
                else if (this.column == null) {
                    return this.node.NodeType; 
                }
                else if (this.fOnValue) {
                    return XmlNodeType.Text;
                }
                else if (this.column.ColumnMapping == MappingType.Attribute) {
                    return XmlNodeType.Attribute;
                }
                else {
                    return XmlNodeType.Element;
                }
            }
        }

        internal string LocalName { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return string.Empty;
                }else if (this.column == null) {
                    String name = node.LocalName;
                    Debug.Assert( name != null );
                    if ( IsLocalNameEmpty( this.node.NodeType ) )
                        return String.Empty;
                    return name;
                }
                else if (this.fOnValue) {
                    return String.Empty;
                }
                else {
                    return doc.NameTable.Add(column.EncodedColumnName);
                }
            }
        }

        internal string NamespaceURI { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return string.Empty;
                }
                else if (this.column == null) {
                    return node.NamespaceURI; 
                }
                else if (this.fOnValue) {
                    return string.Empty;
                }
                else {
                    return doc.NameTable.Add(column.Namespace);
                }
            }
        }
        
        internal string Name { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return string.Empty;
                }
                else if (this.column == null) {
                    String name = node.Name;
                    //Again it could be String.Empty at null position
                    Debug.Assert( name != null );
                    if ( IsLocalNameEmpty( this.node.NodeType ) )
                        return String.Empty;
                    return name;
                }
                else {
                    string prefix = Prefix;
                    string lname = LocalName;
                    if (prefix != null && prefix.Length > 0) {
                        if (lname != null && lname.Length > 0) {
                            return doc.NameTable.Add( prefix + ":" + lname );
                        }
                        else {
                            return prefix;
                        }
                    }
                    else {
                        return lname;
                    }
                }
            }
        }
        

        private bool IsLocalNameEmpty ( XmlNodeType nt) {
                switch ( nt ) {
                    case XmlNodeType.None : 
                    case XmlNodeType.Text :  
                    case XmlNodeType.CDATA : 
                    case XmlNodeType.Comment :
                    case XmlNodeType.Document :
                    case XmlNodeType.DocumentFragment : 
                    case XmlNodeType.Whitespace : 
                    case XmlNodeType.SignificantWhitespace :
                    case XmlNodeType.EndElement : 
                    case XmlNodeType.EndEntity :
                        return true;                         
                    case XmlNodeType.Element :
                    case XmlNodeType.Attribute : 
                    case XmlNodeType.EntityReference :
                    case XmlNodeType.Entity : 
                    case XmlNodeType.ProcessingInstruction :  
                    case XmlNodeType.DocumentType :     
                    case XmlNodeType.Notation :
                    case XmlNodeType.XmlDeclaration :
                        return false;                        
                    default :
                        return true;                        
                }                
            }

        internal string Prefix { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return string.Empty;
                }
                else if (this.column == null) {
                    return node.Prefix; 
                }
                else {
                    return string.Empty;
                }
            }
        }

        internal string Value { 
            get {
                RealFoliate();
                AssertValid();
                if (this.node == null) {
                    return null;
                }
                else if (this.column == null) {
                    return this.node.Value;
                }
                else if (this.column.ColumnMapping == MappingType.Attribute || this.fOnValue) {
                    DataRow row = this.Row;
                    DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                    object value = row[ this.column, rowVersion ];
                    if ( ! Convert.IsDBNull( value ) )
                        return this.column.ConvertObjectToXml( value );
                    return null;
                }
                else {
                    // column element has no value
                    return null;
                }
            }
        }

        bool IXmlDataVirtualNode.IsOnNode( XmlNode nodeToCheck ) {
            RealFoliate();
            return nodeToCheck == this.node;
        }
        
        bool IXmlDataVirtualNode.IsOnColumn( DataColumn col ) {
            RealFoliate();
            return col == this.column;
        }
        
        internal XmlNode GetNode() {
            return this.node;
        }
        
        internal bool IsEmptyElement { 
            get {
                RealFoliate();
                AssertValid();
                if (node != null && column == null) {
                    // TODO: Need support for IsEmptyElement in tree
                    if (node.NodeType == XmlNodeType.Element) {
                        return((XmlElement)node).IsEmpty;
                    }
                }
                return false;
            }
        }

        internal bool IsDefault { 
            get {
                RealFoliate();
                AssertValid();
                if (node != null && column == null && node.NodeType == XmlNodeType.Attribute) {
                    return !((XmlAttribute)node).Specified;
                }

                return false;
            }
        }

        void IXmlDataVirtualNode.OnFoliated( XmlNode foliatedNode ) {
            // update the pointer if the element node has been foliated
            if (node == foliatedNode) {
                // if already on this node, nothing to do!
                if (column == null)
                    return;
                bNeedFoliate = true;
            }
        }

        internal void RealFoliate() {
            if ( !bNeedFoliate )
                return;

            XmlNode n = null;

            if (doc.IsTextOnly( column )) {
                n = node.FirstChild;
            }
            else {
                if (column.ColumnMapping == MappingType.Attribute) {
                    n = node.Attributes.GetNamedItem( column.EncodedColumnName, column.Namespace );
                }
                else {
                    for (n = node.FirstChild; n != null; n = n.NextSibling) {
                        if (n.LocalName == column.EncodedColumnName && n.NamespaceURI == column.Namespace)
                            break;
                    }
                }

                if (n != null && fOnValue)
                    n = n.FirstChild;
            }

            if (n == null)
                throw new InvalidOperationException(Res.GetString(Res.DataDom_Foliation));

            // Cannot use MoveTo( n ); b/c the initial state for MoveTo is invalid (region is foliated but this is not)
            this.node = n;
            this.column = null;
            this.fOnValue = false;
            AssertValid();
            
            bNeedFoliate = false;
        }

        //for the 6 properties below, only when the this.column == null that the nodetype could be XmlDeclaration node
        internal String PublicId {
            get {
                XmlNodeType nt = NodeType;
                switch ( nt ) {
                    case XmlNodeType.DocumentType : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlDocumentType ) (this.node)).PublicId;
                    }
                    case XmlNodeType.Entity : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlEntity ) (this.node)).PublicId;
                    }
                    case XmlNodeType.Notation : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlNotation ) (this.node)).PublicId;
                    }
                }
                return null;
            }
        }

        internal String SystemId {
            get {
                XmlNodeType nt = NodeType;
                switch ( nt ) {
                    case XmlNodeType.DocumentType : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlDocumentType ) (this.node)).SystemId;
                    }
                    case XmlNodeType.Entity : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlEntity ) (this.node)).SystemId;
                    }
                    case XmlNodeType.Notation : {
                        Debug.Assert( this.column == null );
                        return ( ( XmlNotation ) (this.node)).SystemId;
                    }
                }
                return null;
            }
        }

        internal String InternalSubset {
            get {
                if ( NodeType == XmlNodeType.DocumentType ) {
                    Debug.Assert( this.column == null );
                    return ( ( XmlDocumentType ) (this.node)).InternalSubset;
                }
                return null;
            }
        }

        internal XmlDeclaration Declaration {
            get {
                XmlNode child = doc.SafeFirstChild(doc);
                if ( child != null && child.NodeType == XmlNodeType.XmlDeclaration )
                    return (XmlDeclaration)child;
                return null;
            }
        }
        
        internal String Encoding {
            get {
                if ( NodeType == XmlNodeType.XmlDeclaration ) {
                    Debug.Assert( this.column == null );
                    return ( ( XmlDeclaration ) (this.node)).Encoding;
                } else if ( NodeType == XmlNodeType.Document ) {
                    XmlDeclaration dec = Declaration;
                    if ( dec != null )
                        return dec.Encoding;
                }
                return null;
            }
        }
        
        internal String Standalone {
            get {
                if ( NodeType == XmlNodeType.XmlDeclaration ) {
                    Debug.Assert( this.column == null );
                    return ( ( XmlDeclaration ) (this.node)).Standalone;
                } else if ( NodeType == XmlNodeType.Document ) {
                    XmlDeclaration dec = Declaration;
                    if ( dec != null )
                        return dec.Standalone;
                }
                return null;
            }
        }

        internal String Version {
            get {
                if ( NodeType == XmlNodeType.XmlDeclaration ) {
                    Debug.Assert( this.column == null );
                    return ( ( XmlDeclaration ) (this.node)).Version;
                } else if ( NodeType == XmlNodeType.Document ) {
                    XmlDeclaration dec = Declaration;
                    if ( dec != null )
                        return dec.Version;
                }
                return null;
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void AssertValid() {
            // This pointer must be int the document list
            if ( this.column != null ) {
                // We must be on a de-foliated region
                XmlBoundElement rowElem = this.node as XmlBoundElement;
                Debug.Assert( rowElem != null );

                DataRow row = rowElem.Row;
                Debug.Assert( row != null );

                ElementState state = rowElem.ElementState;
                Debug.Assert( state == ElementState.Defoliated, "Region is accessed using column, but it's state is FOLIATED" );

                // We cannot be on a column for which the value is DBNull
                DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                Debug.Assert( ! Convert.IsDBNull( row[ this.column, rowVersion ] ) );

                // If we are on the Text column, we should always have fOnValue == true
                Debug.Assert( (this.column.ColumnMapping == MappingType.SimpleContent) ? (this.fOnValue == true) : true );
            }
        }

        bool IXmlDataVirtualNode.IsInUse() {
            return _isInUse;
        }

        internal void SetNoLongerUse() {
            this.node = null;
            this.column = null;
            this.fOnValue = false;
            this.bNeedFoliate = false;
            this._isInUse = true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\xmlboundelement.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlBoundElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlBoundElement.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.IO;
    using System.Collections;
    using System.Data;
    using System.Diagnostics;

    internal enum ElementState {
        None,
        Defoliated,
        WeakFoliation,
        StrongFoliation,
        Foliating,
        Defoliating,
    }

    internal class XmlBoundElement: XmlElement {
        private DataRow row;
        private ElementState state;

        internal XmlBoundElement( string prefix, string localName, string namespaceURI, XmlDocument doc )
        : base( prefix, localName, namespaceURI, doc ) {
            state = ElementState.None;
        }

        public override XmlAttributeCollection Attributes {
            get {
                AutoFoliate();
                return base.Attributes;
            }
        }

        public override bool HasAttributes {
            get { return Attributes.Count > 0; }
        }

        public override XmlNode FirstChild { 
            get { 
                AutoFoliate();
                return base.FirstChild;
            }
        }

        internal XmlNode SafeFirstChild { get { return base.FirstChild; } }

        public override XmlNode LastChild { 
            get { 
                AutoFoliate();
                return base.LastChild;
            }
        }

        internal XmlNode SafeLastChild { get { return base.LastChild; } }

        public override XmlNode PreviousSibling { 
            get { 
                XmlNode prev = base.PreviousSibling;
                if ( prev == null ) {
                    XmlBoundElement parent = ParentNode as XmlBoundElement;
                    if ( parent != null ) {
                        parent.AutoFoliate();
                        return base.PreviousSibling;
                    }
                }
                return prev;
            }
        }

        internal XmlNode SafePreviousSibling { get { return base.PreviousSibling; } }

        public override XmlNode NextSibling { 
            get { 
                XmlNode next = base.NextSibling;
                if ( next == null ) {
                    XmlBoundElement parent = ParentNode as XmlBoundElement;
                    if ( parent != null ) {
                        parent.AutoFoliate();
                        return base.NextSibling;
                    }
                }
                return next;
            } 
        }

        internal XmlNode SafeNextSibling { get { return base.NextSibling; } }

        public override XmlNode InsertBefore(XmlNode newChild, XmlNode refChild) {
            AutoFoliate();
            return base.InsertBefore( newChild, refChild );
        }

        public override XmlNode InsertAfter(XmlNode newChild, XmlNode refChild) {
            AutoFoliate();
            return base.InsertAfter( newChild, refChild );
        }

        public override XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild) {
            AutoFoliate();
            return base.ReplaceChild( newChild, oldChild );
        }

        public override XmlNode AppendChild(XmlNode newChild) {
            AutoFoliate();
            return base.AppendChild( newChild );
        }

        internal void RemoveAllChildren() {           
            XmlNode child = FirstChild;
            XmlNode sibling = null;

            while ( child != null ) {
                sibling = child.NextSibling;
                RemoveChild( child );
                child = sibling;
            }
        }
        
        public override string InnerXml {
            get {
                return base.InnerXml;
            }
            set {
                
                RemoveAllChildren();
                
                XmlDataDocument doc = (XmlDataDocument) OwnerDocument;
                
                bool bOrigIgnoreXmlEvents = doc.IgnoreXmlEvents;
                bool bOrigIgnoreDataSetEvents = doc.IgnoreDataSetEvents;
                
                doc.IgnoreXmlEvents = true;
                doc.IgnoreDataSetEvents = true;
                
                base.InnerXml = value;

                doc.SyncTree( this );

                doc.IgnoreDataSetEvents = bOrigIgnoreDataSetEvents;
                doc.IgnoreXmlEvents = bOrigIgnoreXmlEvents;
            }
        }
        
        internal DataRow Row {
            get { return row;}
            set { row = value;}
        }

        internal bool IsFoliated {
            get { 
                while ( state == ElementState.Foliating || state == ElementState.Defoliating )
                    System.Threading.Thread.Sleep(0);
                //has to be sure that we are either foliated or defoliated when ask for IsFoliated.
                return state != ElementState.Defoliated;
            }
        }

        internal ElementState ElementState {
            get { return state;}
            set { state = value;}
        }

        internal void Foliate( ElementState newState ) {
            XmlDataDocument doc = (XmlDataDocument) OwnerDocument;
            if ( doc != null )
                doc.Foliate( this, newState );
        }

        // Foliate the node as a side effect of user calling functions on this node (like NextSibling) OR as a side effect of DataDocNav using nodes to do editing
        private void AutoFoliate() {
            XmlDataDocument doc = (XmlDataDocument) OwnerDocument;
            if ( doc != null )
                doc.Foliate( this, doc.AutoFoliationState );
        }

        public override XmlNode CloneNode(bool deep) {
            XmlDataDocument doc = (XmlDataDocument)(this.OwnerDocument);
            ElementState oldAutoFoliationState = doc.AutoFoliationState;
            doc.AutoFoliationState = ElementState.WeakFoliation;
            XmlElement element;
            try {
                Foliate( ElementState.WeakFoliation );
                element = (XmlElement)(base.CloneNode( deep ));
                // Clone should create a XmlBoundElement node
                Debug.Assert( element is XmlBoundElement );
            }
            finally {
                doc.AutoFoliationState = oldAutoFoliationState;
            }

            return element;
        }

        public override void WriteContentTo( XmlWriter w ) {
            DataPointer dp = new DataPointer( (XmlDataDocument)OwnerDocument, this );            
            WriteBoundElementContentTo( dp, w );            
        }

        public override void WriteTo( XmlWriter w ) {
            DataPointer dp = new DataPointer( (XmlDataDocument)OwnerDocument, this );            
            WriteRootBoundElementTo( dp, w );            
        }

        private void WriteRootBoundElementTo(DataPointer dp, XmlWriter w) {            
            Debug.Assert( dp.NodeType == XmlNodeType.Element );
            XmlDataDocument doc = (XmlDataDocument)OwnerDocument;
            w.WriteStartElement( dp.Prefix, dp.LocalName, dp.NamespaceURI );            
            int cAttr = dp.AttributeCount;
            bool bHasXSI = false;
            if ( cAttr > 0 ) {
                for ( int iAttr = 0; iAttr < cAttr; iAttr++ ) {
                    dp.MoveToAttribute( iAttr );
                    if ( dp.Prefix == "xmlns" && dp.LocalName == XmlDataDocument.XSI )
                        bHasXSI = true;
                    WriteTo( dp, w );
                    dp.MoveToOwnerElement();
                }
            }
            
            if ( !bHasXSI && doc.bLoadFromDataSet && doc.bHasXSINIL ) 
                w.WriteAttributeString( "xmlns", "xsi", "http://www.w3.org/2000/xmlns/", Keywords.XSINS );
            
            
            WriteBoundElementContentTo( dp, w );
            
            // Force long end tag when the elem is not empty, even if there are no children.
            if ( dp.IsEmptyElement )
                w.WriteEndElement();
            else
                w.WriteFullEndElement();
        }

        private static void WriteBoundElementTo( DataPointer dp, XmlWriter w ) {
            Debug.Assert( dp.NodeType == XmlNodeType.Element );
            w.WriteStartElement( dp.Prefix, dp.LocalName, dp.NamespaceURI );
            int cAttr = dp.AttributeCount;
            if ( cAttr > 0 ) {
                for ( int iAttr = 0; iAttr < cAttr; iAttr++ ) {
                    dp.MoveToAttribute( iAttr );
                    WriteTo( dp, w );
                    dp.MoveToOwnerElement();
                }
            }
            
            WriteBoundElementContentTo( dp, w );
            
            // Force long end tag when the elem is not empty, even if there are no children.
            if ( dp.IsEmptyElement )
                w.WriteEndElement();
            else
                w.WriteFullEndElement();
        }

        private static void WriteBoundElementContentTo( DataPointer dp, XmlWriter w ) {
            if ( !dp.IsEmptyElement && dp.MoveToFirstChild() ) {
                do {
                    WriteTo( dp, w );
                }
                while ( dp.MoveToNextSibling() );

                dp.MoveToParent();
            }
        }
        
        private static void WriteTo( DataPointer dp, XmlWriter w ) {
            switch ( dp.NodeType ) {
                case XmlNodeType.Attribute:
                    if ( !dp.IsDefault ) {
                        w.WriteStartAttribute( dp.Prefix, dp.LocalName, dp.NamespaceURI );

                        if ( dp.MoveToFirstChild() ) {
                            do {
                                WriteTo( dp, w );
                            }
                            while ( dp.MoveToNextSibling() );

                            dp.MoveToParent();
                        }

                        w.WriteEndAttribute();
                    }
                    break;

                case XmlNodeType.Element:
                    WriteBoundElementTo( dp, w );
                    break;

                case XmlNodeType.Text:
                    w.WriteString(dp.Value);
                    break;

                default:
                    Debug.Assert( ((IXmlDataVirtualNode)dp).IsOnColumn( null ) );
                    if ( dp.GetNode() != null )
                        dp.GetNode().WriteTo( w );
                    break;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\xmldatadocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDataDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlDataDocument.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.IO;
    using System.Collections;
    using System.Data;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Xml.XPath;

    /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an entire document. An XmlDataDocument can contain XML
    ///       data or relational data (DataSet).
    ///    </para>
    /// </devdoc>
    public class XmlDataDocument: XmlDocument {
        DataSet dataSet;

        DataSetMapper mapper;
        internal Hashtable pointers;         // Hastable w/ all pointer objects used by this XmlDataDocument. Hashtable are guaranteed to work OK w/ one writer and mutiple readers, so as long as we guarantee
                                    // that there is at most one thread in AddPointer we are OK.
        int     countAddPointer;    // Approximate count of how many times AddPointer was called since the last time we removed the unused pointer objects from pointers hashtable.
        ArrayList columnChangeList;
        DataRowState rollbackState;

        bool fBoundToDataSet;       // true if our permanent event listeners are registered to receive DataSet events
        bool fBoundToDocument;      // true if our permanent event listeners are registered to receive XML events. Note that both fBoundToDataSet and fBoundToDataSet should be both true or false.
        bool fDataRowCreatedSpecial;    // true if our special event listener is registered to receive DataRowCreated events. Note that we either have special listeners subsribed or permanent ones (i.e. fDataRowCreatedSpecial and fBoundToDocument/fBoundToDataSet cannot be both true).
        bool ignoreXmlEvents;       // true if XML events should not be processed
        bool ignoreDataSetEvents;   // true if DataSet events should not be processed
        bool isFoliationEnabled;    // true if we should create and reveal the virtual nodes, false if we should reveal only the physical stored nodes
        bool optimizeStorage;       // false if we should only have foilated regions.
        ElementState autoFoliationState;    // When XmlBoundElement will foliate because of memeber functions, this will contain the foliation mode: usually this is
                                    // ElementState.StrongFoliation, however when foliation occurs due to DataDocumentNavigator operations (InsertNode for example),
                                    // it it usually ElementState.WeakFoliation
        bool fAssociateDataRow;     // if true, CreateElement will create and associate data rows w/ the newly created XmlBoundElement.
                                    // If false, then CreateElement will just create the XmlBoundElement nodes. This is usefull for Loading case,
                                    // when CreateElement is called by DOM.
        object foliationLock;
        internal const string XSI_NIL = "xsi:nil";
        internal const string XSI = "xsi";
        private bool bForceExpandEntity = false;
        internal XmlAttribute attrXml = null;
        internal bool bLoadFromDataSet = false;
        internal bool bHasXSINIL = false;

        internal void AddPointer( IXmlDataVirtualNode pointer ) {
            Debug.Assert( pointers.ContainsValue(pointer) == false );
            lock ( pointers ) {
                countAddPointer++;
                if ( countAddPointer >= 5 ) {   // 5 is choosed to be small enough to not affect perf, but high enough so we will not scan all the time
                    ArrayList al = new ArrayList();
                    foreach( DictionaryEntry entry in pointers ) {
                        IXmlDataVirtualNode temp = (IXmlDataVirtualNode)(entry.Value);
                        Debug.Assert( temp != null );
                        if ( ! temp.IsInUse() )
                            al.Add( temp );
                    }
                    for (int i = 0; i < al.Count; i++ ) {
                        pointers.Remove( al[ i ] );
                    }
                    countAddPointer = 0;
                }
                pointers[pointer] = pointer;
            }
        }
        internal void RemovePointer( IXmlDataVirtualNode pointer ) {
            lock ( pointers ) {
                countAddPointer++;
                pointers.Remove( pointer );
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void AssertPointerPresent( IXmlDataVirtualNode pointer ) {
#if DEBUG
                object val = pointers[pointer];
                if ( val != ( object ) pointer )
                    Debug.Assert( false );
#endif
        }
        // This function attaches the DataSet to XmlDataDocument
        // We also register a special listener (OnDataRowCreatedSpecial) to DataSet, so we know when we should setup all regular listeners (OnDataRowCreated, OnColumnChanging, etc).
        // We need to do this because of the following scenario:
        //  - XmlDataDocument doc = new XmlDataDocument();
        //  - DataSet ds = doc.DataSet;     // doc.DataSet creates a data-set, however does not sets-up the regular listeners.
        //  - ds.ReadXmlSchema();           // since there are regular listeners in doc that track ds schema changes, doc does not know about the new tables/columns/etc
        //  - ds.ReadXmlData();             // ds is now filled, however doc has no content (since there were no listeners for the new created DataRow's)
        // We can set-up listeners and track each change in schema, but it is more perf-friendly to do it laizily, all at once, when the first DataRow is created
        // (we rely on the fact that DataRowCreated is a DataSet wide event, rather than a DataTable event)
        private void AttachDataSet( DataSet ds ) {
            // You should not have already an associated dataset
            Debug.Assert( dataSet == null );
            Debug.Assert( ds != null );
            if ( ds.FBoundToDocument )
                throw new ArgumentException( Res.GetString(Res.DataDom_MultipleDataSet) );
            ds.FBoundToDocument = true;
            dataSet = ds;
            // Register the special listener to catch the first DataRow event(s)
            BindSpecialListeners();
        }

        // after loading, all detached DataRows are synchronized with the xml tree and inserted to their tables
        // or after setting the innerxml, synchronize the rows and if created new and detached, will be inserted.
        internal void SyncRows( DataRow parentRow, XmlNode node, bool fAddRowsToTable) {
            XmlBoundElement be = node as XmlBoundElement;
            if ( be != null ) {
                DataRow r = be.Row;
                if (r!=null && be.ElementState == ElementState.Defoliated)
                    return; //no need of syncRow

                if ( r != null ) {
                    // get all field values.
                    SynchronizeRowFromRowElement( be );

                    // defoliate if possible
                    be.ElementState = ElementState.WeakFoliation;
                    DefoliateRegion( be );

                    if ( parentRow != null )
                        SetNestedParentRow( r, parentRow );                    
                    if ( fAddRowsToTable && r.RowState == DataRowState.Detached ) 
                        r.Table.Rows.Add( r );
                    parentRow = r;
                }
            }

            // Attach all rows from children nodes
            for ( XmlNode child = node.FirstChild; child != null; child = child.NextSibling )
            	SyncRows( parentRow, child, fAddRowsToTable );
        }

        // All detached DataRows are synchronized with the xml tree and inserted to their tables.
        // Synchronize the rows and if created new and detached, will be inserted.
        internal void SyncTree( XmlNode node) {
            XmlBoundElement be = null;
            mapper.GetRegion( node, out be ) ;
            DataRow parentRow = null;
            bool fAddRowsToTable = IsConnected(node) ;
    
            if ( be != null ) {
                DataRow r = be.Row;
                if (r!=null && be.ElementState == ElementState.Defoliated)
                    return; //no need of syncRow

                if ( r != null ) {
                    // get all field values.
                    SynchronizeRowFromRowElement( be );
                    
                    // defoliation will not be done on the node which is not RowElement, in case of node is externally being used
                    if ( node == be ) {
                         // defoliate if possible
                         be.ElementState = ElementState.WeakFoliation;
                         DefoliateRegion( be );
                    }

                    if ( fAddRowsToTable && r.RowState == DataRowState.Detached ) 
                        r.Table.Rows.Add( r );
                    
                    parentRow = r;
                }
            }

            // Attach all rows from children nodes
            for ( XmlNode child = node.FirstChild; child != null; child = child.NextSibling )
            	SyncRows( parentRow, child, fAddRowsToTable );
        }

        internal ElementState AutoFoliationState {
            get { return this.autoFoliationState; }
            set { this.autoFoliationState = value; }
        }

        private void BindForLoad() {
            Debug.Assert( ignoreXmlEvents == true );
            ignoreDataSetEvents = true;
            mapper.SetupMapping( this, dataSet );
            if ( dataSet.Tables.Count > 0 ) {
                //at least one table
                LoadDataSetFromTree( );
            }
            BindListeners();
            ignoreDataSetEvents = false;
        }

        private void Bind( bool fLoadFromDataSet ) {
            // If we have a DocumentElement then it is illegal to call this func to load from data-set
            Debug.Assert( DocumentElement == null || ! fLoadFromDataSet );

            ignoreDataSetEvents = true;
            ignoreXmlEvents = true;

            // Do the mapping. This could be a successive mapping in case of this scenario: xd = XmlDataDocument( emptyDataSet ); xd.Load( "file.xml" );
            mapper.SetupMapping(this, dataSet);

            if ( DocumentElement != null ) {
                LoadDataSetFromTree();
                BindListeners();
            }
            else if ( fLoadFromDataSet ) {
                this.bLoadFromDataSet = true;
                LoadTreeFromDataSet( DataSet );
                BindListeners();
            }

            ignoreDataSetEvents = false;
            ignoreXmlEvents = false;
        }

        internal void Bind( DataRow r, XmlBoundElement e ) {
            r.Element = e;
            e.Row = r;
        }

        // Binds special listeners to catch the 1st data-row created. When the 1st DataRow is created, XmlDataDocument will automatically bind all regular listeners.
        private void BindSpecialListeners() {
            Debug.Assert( fDataRowCreatedSpecial == false );
            Debug.Assert( fBoundToDataSet == false && fBoundToDocument == false );
            dataSet.DataRowCreated += new DataRowCreatedEventHandler( this.OnDataRowCreatedSpecial );
            fDataRowCreatedSpecial = true;
        }
        private void UnBindSpecialListeners() {
            Debug.Assert( fDataRowCreatedSpecial == true );
            dataSet.DataRowCreated -= new DataRowCreatedEventHandler( this.OnDataRowCreatedSpecial );
            fDataRowCreatedSpecial = false;
        }

        private void BindListeners() {
            BindToDocument();
            BindToDataSet();
        }

        private void BindToDataSet() {
            // We could be already bound to DataSet in this scenario:
            //     xd = new XmlDataDocument( dataSetThatHasNoData ); xd.Load( "foo.xml" );
            // so we must not rebound again to it.
            if ( fBoundToDataSet ) {
                Debug.Assert( dataSet != null );
                return;
            }

            // Unregister the DataRowCreatedSpecial notification
            if ( fDataRowCreatedSpecial )
                UnBindSpecialListeners();

            dataSet.Tables.CollectionChanging += new CollectionChangeEventHandler( this.OnDataSetTablesChanging );
            dataSet.Relations.CollectionChanging += new CollectionChangeEventHandler( this.OnDataSetRelationsChanging );
            dataSet.DataRowCreated += new DataRowCreatedEventHandler( this.OnDataRowCreated );
            dataSet.PropertyChanging += new PropertyChangedEventHandler( this.OnDataSetPropertyChanging );

            //this is the hack for this release, should change it in the future
            dataSet.ClearFunctionCalled += new DataSetClearEventhandler( this.OnClearCalled );

            if ( dataSet.Tables.Count > 0 ) {
                foreach( DataTable t in dataSet.Tables ) {
                    BindToTable( t );
                }
            }

            foreach ( DataRelation rel in dataSet.Relations ) {
                rel.PropertyChanging += new PropertyChangedEventHandler( this.OnRelationPropertyChanging );
            }
            fBoundToDataSet = true;
        }

        private void BindToDocument() {
            if ( !fBoundToDocument ) {
                NodeInserting +=  new XmlNodeChangedEventHandler( this.OnNodeInserting ) ;
                NodeInserted +=  new XmlNodeChangedEventHandler( this.OnNodeInserted ) ;
                NodeRemoving +=  new XmlNodeChangedEventHandler( this.OnNodeRemoving ) ;
                NodeRemoved +=  new XmlNodeChangedEventHandler( this.OnNodeRemoved ) ;
                NodeChanging +=  new XmlNodeChangedEventHandler( this.OnNodeChanging ) ;
                NodeChanged +=  new XmlNodeChangedEventHandler( this.OnNodeChanged ) ;
                fBoundToDocument = true;
            }
        }

        private void BindToTable( DataTable t ) {
//            t.ColumnChanging  += new DataColumnChangeEventHandler( this.OnColumnChanging );
            t.ColumnChanged   += new DataColumnChangeEventHandler( this.OnColumnChanged );
            t.RowChanging     += new DataRowChangeEventHandler( this.OnRowChanging );
            t.RowChanged      += new DataRowChangeEventHandler( this.OnRowChanged );
            t.RowDeleting     += new DataRowChangeEventHandler( this.OnRowChanging);
            t.RowDeleted      += new DataRowChangeEventHandler( this.OnRowChanged );
            t.PropertyChanging += new PropertyChangedEventHandler( this.OnTablePropertyChanging );
            t.Columns.CollectionChanging += new CollectionChangeEventHandler( this.OnTableColumnsChanging );

            foreach( DataColumn col in t.Columns ) {
                // Hook column properties changes, so we can react properly to ROM changes.
                col.PropertyChanging += new PropertyChangedEventHandler( this.OnColumnPropertyChanging );
            }
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.CreateElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an element with the specified Prefix, LocalName, and
        ///       NamespaceURI.
        ///    </para>
        /// </devdoc>
        public override XmlElement CreateElement( string prefix, string localName, string namespaceURI) {
            //BUGBUG: We misbehave if there are default attributes (see base class implementation)

            // There are three states for the document:
            //  - special listeners ON, no permananent listeners: this is when the data doc was created w/o any dataset, and the 1st time a new row/element
            //    is created we should subscribe the permenent listeners.
            //  - special listeners OFF, permanent listeners ON: this is when the data doc is loaded (from dataset or XML file) and synchronization takes place.
            //  - special listeners OFF, permanent listeners OFF: this is then the data doc is LOADING (from dataset or XML file) - the synchronization is done by code,
            //    not based on listening to events.
#if DEBUG
            // Cannot have both special and permananent listeners ON
            if ( fDataRowCreatedSpecial )
                Debug.Assert( (fBoundToDataSet == false) && (fBoundToDocument == false) );
            // fBoundToDataSet and fBoundToDocument should have the same value
            Debug.Assert( fBoundToDataSet ? fBoundToDocument : (! fBoundToDocument) );
#endif
            if ( prefix == null )
                prefix = String.Empty;
            if ( namespaceURI == null )
                namespaceURI = String.Empty;

            if ( ! fAssociateDataRow ) {
                // Loading state: create just the XmlBoundElement: the LoadTreeFromDataSet/LoadDataSetFromTree will take care of synchronization
                return new XmlBoundElement( prefix, localName, namespaceURI, this );
            }

            // This is the 1st time an element is beeing created on an empty XmlDataDocument - unbind special listeners, bind permanent ones and then go on w/
            // creation of this element
            EnsurePopulatedMode();
            Debug.Assert( fDataRowCreatedSpecial == false );

            // Loaded state: create a DataRow, this in turn will create and associate the XmlBoundElement, which we will return.
            DataTable dt = mapper.SearchMatchingTableSchema( localName, namespaceURI );
            if ( dt != null ) {
                DataRow row = dt.CreateEmptyRow();
                // We need to make sure all fields are DBNull
                foreach( DataColumn col in dt.Columns ) {
                    if ( col.ColumnMapping != MappingType.Hidden )
                        SetRowValueToNull( row, col );
                }
                XmlBoundElement be = row.Element;
                Debug.Assert( be != null );
                be.Prefix = prefix;
                return be;
            }
            // No matching table schema for this element: just create the element
            return new XmlBoundElement( prefix, localName, namespaceURI, this );
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.CreateEntityReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override XmlEntityReference CreateEntityReference(String name) {
            throw new NotSupportedException( Res.GetString( Res.DataDom_NotSupport_EntRef ) );
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.DataSet"]/*' />
        /// <devdoc>
        ///    <para>Gets a DataSet that provides a relational representation of the data in this
        ///       XmlDataDocument.</para>
        /// </devdoc>
        public DataSet DataSet {
            get {
                return dataSet;
            }
        }

        private void DefoliateRegion( XmlBoundElement rowElem ) {
            // You must pass a row element (which s/b associated w/ a DataRow)
            Debug.Assert( rowElem.Row != null );

            if ( !optimizeStorage )
                return;

            if ( rowElem.ElementState != ElementState.WeakFoliation )
                return;

            if ( !mapper.IsRegionRadical( rowElem ) ) {
                //Console.WriteLine("Region is not radical: "+rowElem.GetHashCode());
                return;
            }

            //Console.WriteLine("Defoliating Region: " + rowElem.GetHashCode());

            bool saveIgnore = IgnoreXmlEvents;
            IgnoreXmlEvents = true;

            rowElem.ElementState = ElementState.Defoliating;

            try {
                // drop all attributes
                rowElem.RemoveAllAttributes();

                XmlNode node = rowElem.FirstChild;
                while ( node != null ) {
                    XmlNode next = node.NextSibling;

                    XmlBoundElement be = node as XmlBoundElement;
                    if ( be != null && be.Row != null )
                        break;

                    // The node must be mapped to a column (since the region is radically structured)
                    Debug.Assert( mapper.GetColumnSchemaForNode( rowElem, node ) != null );
                    rowElem.RemoveChild( node );

                    node = next;
                }
#if DEBUG
                // All subsequent siblings must be sub-regions
                for ( ; node != null; node = node.NextSibling ) {
                    Debug.Assert( (node is XmlBoundElement) && (((XmlBoundElement)node).Row != null) );
                }
#endif

                rowElem.ElementState = ElementState.Defoliated;
            }
            finally {
                IgnoreXmlEvents = saveIgnore;
            }
        }

        private XmlElement EnsureDocumentElement() {
            XmlElement docelem = DocumentElement;
            if ( docelem == null ) {
                string docElemName = XmlConvert.EncodeLocalName( this.DataSet.DataSetName );
                if ( docElemName == null || docElemName == String.Empty )
                    docElemName = "Xml";
                string ns = this.DataSet.Namespace;
                if ( ns == null )
                    ns = String.Empty;
                docelem = new XmlBoundElement( string.Empty, docElemName, ns, this );
                AppendChild( docelem );
            }

            return docelem;
        }
        private XmlElement EnsureNonRowDocumentElement() {
            XmlElement docElem = this.DocumentElement;
            if ( docElem == null )
                return EnsureDocumentElement();

            DataRow rowDocElem = GetRowFromElement( docElem );
            if ( rowDocElem == null )
                return docElem;

            return DemoteDocumentElement();
        }
        private XmlElement DemoteDocumentElement() {
            // Changes of Xml here should not affect ROM
            Debug.Assert( this.ignoreXmlEvents == true );
            // There should be no reason to call this function if docElem is not a rowElem
            Debug.Assert( this.GetRowFromElement( this.DocumentElement ) != null );

            // Remove the DocumentElement and create a new one
            XmlElement oldDocElem = this.DocumentElement;
            RemoveChild( oldDocElem );
            XmlElement docElem = EnsureDocumentElement();
            docElem.AppendChild( oldDocElem );
            // We should have only one child now
            Debug.Assert( docElem.LastChild == docElem.FirstChild );
            return docElem;
        }
        // This function ensures that the special listeners are un-subscribed, the permanent listeners are subscribed and
        // CreateElement will attach DataRows to newly created XmlBoundElement.
        // It should be called when we have special listeners hooked and we need to change from the special-listeners mode to the
        // populated/permanenet mode where all listeners are corectly hooked up and the mapper is correctly set-up.
        private void EnsurePopulatedMode() {
            // Unbind special listeners, bind permanent ones, setup the mapping, etc
#if DEBUG
            bool fDataRowCreatedSpecialOld = fDataRowCreatedSpecial;
            bool fAssociateDataRowOld = fAssociateDataRow;
#endif
            if ( fDataRowCreatedSpecial ) {
                UnBindSpecialListeners();
                // If a special listener was ON, we should not have had an already set-up mapper or permanent listeners subscribed
                Debug.Assert( ! mapper.IsMapped() );
                Debug.Assert( ! fBoundToDocument );
                Debug.Assert( ! fBoundToDataSet );

                mapper.SetupMapping( this, dataSet);
                BindListeners();

                // CreateElement should now create associate DataRows w/ new XmlBoundElement nodes
                // We should do this ONLY if we switch from special listeners to permanent listeners. The reason is
                // that DataDocumentNavigator wants to put XmlDataDocument in a batch mode, where CreateElement will just
                // create a XmlBoundElement (see DataDocumentNavigator.CloneTree)
                fAssociateDataRow = true;
            }

            Debug.Assert( fDataRowCreatedSpecial == false );
            Debug.Assert( mapper.IsMapped() );
            Debug.Assert( fBoundToDataSet && fBoundToDocument );
#if DEBUG
            // In case we EnsurePopulatedMode was called on an already populated mode, we should NOT change fAssociateDataRow
            if ( fDataRowCreatedSpecialOld == false )
                Debug.Assert( fAssociateDataRowOld == fAssociateDataRow );
#endif
        }

        // Move regions that are marked in ROM as nested children of row/rowElement as last children in XML fragment
        private void FixNestedChildren(DataRow row, XmlElement rowElement) {
            foreach( DataRelation dr in GetNestedChildRelations(row) ) {
                foreach( DataRow r in row.GetChildRows(dr) ) {
                    XmlElement childElem = r.Element;
                    // childElem can be null when we create XML from DataSet (XmlDataDocument( DataSet ) is called) and we insert rowElem of the parentRow before
                    // we insert the rowElem of children rows.
                    if ( childElem != null ) {
#if DEBUG
                        bool fIsChildConnected = IsConnected( childElem );
#endif
                        if ( childElem.ParentNode != rowElement ) {
                            childElem.ParentNode.RemoveChild( childElem );
                            rowElement.AppendChild( childElem );
                        }
#if DEBUG
                        // We should not have changed the connected/disconnected state of the node (since the row state did not change)
                        Debug.Assert( fIsChildConnected == IsConnected( childElem ) );
                        Debug.Assert( IsRowLive( r ) ? IsConnected( childElem ) : ! IsConnected( childElem ) );
#endif
                    }
                }
            }
        }

        // This function accepts node params that are not row-elements. In this case, calling this function is a no-op
        internal void Foliate( XmlBoundElement node, ElementState newState ) {

            Debug.Assert( newState == ElementState.WeakFoliation || newState == ElementState.StrongFoliation );
#if DEBUG
            // If we want to strong foliate one of the non-row-elem in a region, then the region MUST be strong-foliated (or there must be no region)
            // Do this only when we are not loading
            if ( IsFoliationEnabled ) {
                if( newState == ElementState.StrongFoliation && node.Row == null ) {
                    XmlBoundElement rowElem;
                    ElementState rowElemState = ElementState.None;
                    if ( mapper.GetRegion( node, out rowElem ) ) {
                        rowElemState = rowElem.ElementState;
                        Debug.Assert( rowElemState == ElementState.StrongFoliation || rowElemState == ElementState.WeakFoliation );
                    }
                    // Add a no-op, so we can still debug in the assert fails
                    rowElemState = rowElemState;
                }
            }
#endif

            if ( IsFoliationEnabled ) {
                if ( node.ElementState == ElementState.Defoliated ) {
                    ForceFoliation( node, newState );
                }
                else if ( node.ElementState == ElementState.WeakFoliation && newState == ElementState.StrongFoliation ) {
                    // Node must be a row-elem
                    Debug.Assert( node.Row != null );
                    node.ElementState = newState;
                }
            }
        }

        private void Foliate( XmlElement element ) {
            if ( element is XmlBoundElement )
                ((XmlBoundElement)element).Foliate( ElementState.WeakFoliation );
        }

        // Foliate rowElement region if there are DataPointers that points into it
        private void FoliateIfDataPointers( DataRow row, XmlElement rowElement ) {
            if ( !IsFoliated( rowElement) && HasPointers( rowElement ) ) {
                bool wasFoliationEnabled = IsFoliationEnabled;
                IsFoliationEnabled = true;
                try {
                    Foliate( rowElement );
                }
                finally {
                    IsFoliationEnabled = wasFoliationEnabled;
                }
            }
        }

        private void EnsureFoliation( XmlBoundElement rowElem, ElementState foliation ) {
            if ( rowElem.IsFoliated ) //perf reason, avoid unecessary lock.
                return;
            ForceFoliation( rowElem, foliation);
        }

        private void ForceFoliation( XmlBoundElement node, ElementState newState ) {            
            lock ( this.foliationLock ) {
                if ( node.ElementState != ElementState.Defoliated )
                    // The region was foliated by an other thread while this thread was locked
                    return;

                // Node must be a row-elem associated w/ a non-deleted row
                Debug.Assert( node.Row != null );
                Debug.Assert( node.Row.RowState != DataRowState.Deleted );

                node.ElementState = ElementState.Foliating;

                bool saveIgnore = IgnoreXmlEvents;
                IgnoreXmlEvents = true;

                try {
                    XmlNode priorNode = null;
                    DataRow row = node.Row;

                    // create new attrs & elements for row
                    // For detached rows: we are in sync w/ temp values
                    // For non-detached rows: we are in sync w/ the current values
                    // For deleted rows: we never sync
                    DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                    foreach( DataColumn col in row.Table.Columns ) {
                        if ( !IsNotMapped(col) ) {
                            object value = row[col, rowVersion];

                            if ( ! Convert.IsDBNull( value ) ) {
                                if ( col.ColumnMapping == MappingType.Attribute ) {
                                    node.SetAttribute( col.EncodedColumnName, col.Namespace, col.ConvertObjectToXml( value ) );
                                }
                                else {
                                    XmlNode newNode = null;
                                    if ( col.ColumnMapping == MappingType.Element ) {
                                        newNode = new XmlBoundElement( string.Empty, col.EncodedColumnName, col.Namespace, this );
                                        newNode.AppendChild( CreateTextNode( col.ConvertObjectToXml( value ) ) );
                                        if ( priorNode != null ) {
                                            node.InsertAfter(newNode, priorNode);
                                        }
                                        else if ( node.FirstChild != null ) {
                                            node.InsertBefore( newNode, node.FirstChild );
                                        }
                                        else {
                                            node.AppendChild( newNode );
                                        }
                                        priorNode = newNode;
                                    }
                                    else {
                                        Debug.Assert( col.ColumnMapping == MappingType.SimpleContent );
                                        newNode = CreateTextNode( col.ConvertObjectToXml( value ) );
                                        if ( node.FirstChild != null )
                                            node.InsertBefore( newNode, node.FirstChild );
                                        else
                                            node.AppendChild( newNode );
                                        if ( priorNode == null )
                                            priorNode = newNode;
                                    }
                                }
                            }
                            else {
                                if ( col.ColumnMapping == MappingType.SimpleContent ) {
                                    XmlAttribute attr = CreateAttribute( XSI, Keywords.XSI_NIL, Keywords.XSINS );
                                    attr.Value = Keywords.TRUE;
                                    node.SetAttributeNode( attr );
                                    this.bHasXSINIL = true;
                                }
                            }
                        }
                    }
                }
                finally {
                    IgnoreXmlEvents = saveIgnore;
                    node.ElementState = newState;
                }
                // update all live pointers
                OnFoliated( node );
            }
        }

        //Determine best radical insert position for inserting column elements
        private XmlNode GetColumnInsertAfterLocation( DataRow row, DataColumn col, XmlBoundElement rowElement ) {
            XmlNode prev = null;
            XmlNode node = null;

            // text only columns appear first
            if ( IsTextOnly( col ) )
                return null;

            // insert location must be after free text
            for ( node = rowElement.FirstChild; node != null; prev = node, node = node.NextSibling ) {
                if ( !IsTextLikeNode( node ) )
                    break;
            }

            for ( ; node != null; prev = node, node = node.NextSibling ) {
                // insert location must be before any non-element nodes
                if ( node.NodeType != XmlNodeType.Element )
                    break;
                XmlElement e = node as XmlElement;

                // insert location must be before any non-mapped elements or separate regions
                if ( mapper.GetRowFromElement( e ) != null )
                    break;

                object schema = mapper.GetColumnSchemaForNode( rowElement, node );
                if ( schema == null || !(schema is DataColumn) )
                    break;

                // insert location must be before any columns logically after this column
                if ( ((DataColumn)schema).Ordinal > col.Ordinal )
                    break;
            }

            return prev;
        }

        private ArrayList GetNestedChildRelations(DataRow row) {
            ArrayList list = new ArrayList();

            foreach( DataRelation r in row.Table.ChildRelations ) {
                if ( r.Nested )
                    list.Add(r);
            }

            return list;
        }

        private DataRow GetNestedParent(DataRow row) {
            DataRelation relation = GetNestedParentRelation(row);
            if ( relation != null )
                return row.GetParentRow(relation);
            return null;
        }

        private static DataRelation GetNestedParentRelation( DataRow row ) {
            return row.Table.nestedParentRelation;
        }

        private DataColumn GetTextOnlyColumn( DataRow row ) {
#if DEBUG
            {
                // Make sure there is at most only one text column, and the text column (if present) is the one reported by row.Table.XmlText
                DataColumnCollection columns = row.Table.Columns;
                int cCols = columns.Count;
                int cTextCols = 0;
                for ( int iCol = 0; iCol < cCols; iCol++ ) {
                    DataColumn c = columns[iCol];
                    if ( IsTextOnly( c ) ) {
                        Debug.Assert( c == row.Table.XmlText );
                        ++cTextCols;
                    }
                }
                Debug.Assert( cTextCols == 0 || cTextCols == 1 );
                if ( cTextCols == 0 )
                    Debug.Assert( row.Table.XmlText == null );
            }
#endif
            return row.Table.XmlText;
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.GetRowFromElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       <SPAN>Retrieves the
        ///          DataRow associated with the specified XmlElement.</SPAN>
        ///       </para>
        ///    </devdoc>
        public DataRow GetRowFromElement( XmlElement e ) {
            return mapper.GetRowFromElement( e );
        }

        private XmlNode GetRowInsertBeforeLocation(DataRow row, XmlElement rowElement, XmlNode parentElement) {
            DataRow refRow = row;
            int i = 0;
            int pos;

            // Find position
            // int pos = row.Table.Rows[row];
            for (i = 0; i < row.Table.Rows.Count; i++)
                if (row == row.Table.Rows[i])
                    break;
            pos = i;

            DataRow parentRow = GetNestedParent(row);
            for (i = pos + 1; i < row.Table.Rows.Count; i++) {
                refRow = row.Table.Rows[i];
                if (GetNestedParent(refRow) == parentRow && GetElementFromRow(refRow).ParentNode == parentElement)
                    break;
            }

            if (i < row.Table.Rows.Count)
                return GetElementFromRow(refRow);
            else
                return(XmlNode) null;
        }


        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.GetElementFromRow"]/*' />
        /// <devdoc>
        ///    <para><SPAN>Retrieves
        ///       the XmlElement associated with the specified DataRow.</SPAN></para>
        /// </devdoc>
        public XmlElement GetElementFromRow( DataRow r ) {
            XmlBoundElement be = r.Element;
            //BUGBUG: We do not check for DataRow's that belong to a different DataSet
            Debug.Assert( be != null );
            return be;
        }

        internal bool HasPointers( XmlNode node ) {
            while ( true ) {
                try {
                    if ( pointers.Count > 0 ) {
                        object pointer = null;
                        foreach( DictionaryEntry entry in pointers ) {
                            pointer = entry.Value;
                            Debug.Assert( pointer != null );
                            if ( ((IXmlDataVirtualNode)pointer).IsOnNode( node ) )
                                return true;
                        }
                    }
                    return false;
                }
                catch {
                    // This can happens only when some threads are creating navigators (thus modifying this.pointers) while other threads are in the foreach loop.
                    // Solution is to re-try HasPointers.
                }
            }
            //should never get to this point due to while (true) loop
        }

        internal bool IgnoreXmlEvents {
            get { return ignoreXmlEvents;}
            set { ignoreXmlEvents = value;}
        }

        internal bool IgnoreDataSetEvents {
            get { return this.ignoreDataSetEvents; }
            set { this.ignoreDataSetEvents = value; }
        }

        private bool IsFoliated( XmlElement element ) {
            if ( element is XmlBoundElement ) {
                return((XmlBoundElement)element).IsFoliated;
            }

            return true;
        }
        private bool IsFoliated( XmlBoundElement be ) {
            return be.IsFoliated;
        }

        internal bool IsFoliationEnabled {
            get { return isFoliationEnabled; }
            set { isFoliationEnabled = value; }
        }

        // This creates a tree and synchronize ROM w/ the created tree.
        // It requires the populated mode to be on - in case we are not in populated mode, it will make the XmlDataDocument be in populated mode.
        // It takes advantage of the fAssociateDataRow flag for populated mode, which allows creation of XmlBoundElement w/o associating DataRow objects.
        internal XmlNode CloneTree( DataPointer other ) {
            EnsurePopulatedMode();

            bool oldIgnoreDataSetEvents = ignoreDataSetEvents;
            bool oldIgnoreXmlEvents     = ignoreXmlEvents;
            bool oldFoliationEnabled    = IsFoliationEnabled;
            bool oldAssociateDataRow    = fAssociateDataRow;

            // Caller should ensure that the EnforceConstraints == false. See 60486 for more info about why this was changed from DataSet.EnforceConstraints = false to an assert.
            Debug.Assert( DataSet.EnforceConstraints == false );
            XmlNode newNode;

            try {
                ignoreDataSetEvents = true;
                ignoreXmlEvents     = true;
                IsFoliationEnabled  = false;
                fAssociateDataRow   = false;

                // Create the diconnected tree based on the other navigator
                newNode = CloneTreeInternal( other );
                Debug.Assert( newNode != null );

                // Synchronize DataSet from XML
                LoadRows( null, newNode );
                SyncRows( null, newNode, false );
            }
            finally {
                ignoreDataSetEvents = oldIgnoreDataSetEvents;
                ignoreXmlEvents     = oldIgnoreXmlEvents;
                IsFoliationEnabled  = oldFoliationEnabled;
                fAssociateDataRow   = oldAssociateDataRow;
            }
            return newNode;
        }

        private XmlNode CloneTreeInternal( DataPointer other ) {
            Debug.Assert( ignoreDataSetEvents == true );
            Debug.Assert( ignoreXmlEvents == true );
            Debug.Assert( IsFoliationEnabled == false );

            // Create the diconnected tree based on the other navigator
            XmlNode newNode = CloneNode( other );

            DataPointer dp = new DataPointer( other );

            if (newNode.NodeType == XmlNodeType.Element) {
                int cAttributes = dp.AttributeCount;
                for ( int i = 0; i < cAttributes; i++ ) {
                    dp.MoveToOwnerElement();
                    if( dp.MoveToAttribute(i) ) {
                        newNode.Attributes.Append( (XmlAttribute)CloneTreeInternal(dp) );
                    }
                }

                dp.MoveTo( other );
            }

            // TODO: Do not Push/Pop if the nodes are leaf nodes
            for ( bool fMore = dp.MoveToFirstChild(); fMore; fMore = dp.MoveToNextSibling() )
                newNode.AppendChild( CloneTreeInternal( dp ) );

            dp.SetNoLongerUse();

            return newNode;
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override XmlNode CloneNode( bool deep ) {
            XmlDataDocument clone = (XmlDataDocument)(base.CloneNode(false));
            clone.Init(this.DataSet.Clone());

            clone.dataSet.EnforceConstraints = this.dataSet.EnforceConstraints;
            Debug.Assert( clone.FirstChild == null );
            if ( deep ) {
                DataPointer dp = new DataPointer( this, this );
                for ( bool fMore = dp.MoveToFirstChild(); fMore; fMore = dp.MoveToNextSibling() ) {
                    XmlNode cloneNode;
                    if ( dp.NodeType == XmlNodeType.Element )
                        cloneNode = clone.CloneTree( dp );
                    else
                        cloneNode = clone.CloneNode( dp );
                    clone.AppendChild( cloneNode );
                }
                dp.SetNoLongerUse();
            }

            return clone;
        }

        private XmlNode CloneNode( DataPointer dp ) {
            switch (dp.NodeType) {
                //for the nodes without value and have no children
                case XmlNodeType.DocumentFragment:
                    return this.CreateDocumentFragment();
                case XmlNodeType.DocumentType:
                    //BUGBUG: currently we don't have a way to get Entity nodes and Notation nodes
                    return this.CreateDocumentType( dp.Name, dp.PublicId, dp.SystemId, dp.InternalSubset );
                case XmlNodeType.XmlDeclaration:
                    return this.CreateXmlDeclaration( dp.Version, dp.Encoding, dp.Standalone );
                //case XmlNodeType.Notation: -- notation should not be able to be accessed by XmlNavigator
                    //return this.CreateNotation(dp.Name, dp.PublicId, dp.SystemId );

                //for the nodes with value but no children
                case XmlNodeType.Text:
                    return this.CreateTextNode( dp.Value );
                case XmlNodeType.CDATA:
                    return this.CreateCDataSection( dp.Value );
                case XmlNodeType.ProcessingInstruction:
                    return this.CreateProcessingInstruction( dp.Name, dp.Value );
                case XmlNodeType.Comment:
                    return this.CreateComment( dp.Value );
                case XmlNodeType.Whitespace:
                    return this.CreateWhitespace( dp.Value );
                case XmlNodeType.SignificantWhitespace:
                    return this.CreateSignificantWhitespace( dp.Value );
                //for the nodes that don't have values, but might have children -- only clone the node and leave the children untouched
                case XmlNodeType.Element:
                    return this.CreateElement(dp.Prefix, dp.LocalName, dp.NamespaceURI);
                case XmlNodeType.Attribute:
                    return this.CreateAttribute(dp.Prefix, dp.LocalName, dp.NamespaceURI);
                case XmlNodeType.EntityReference:
                    return this.CreateEntityReference( dp.Name );
            }
            throw new InvalidOperationException( Res.GetString( Res.DataDom_CloneNode, dp.NodeType.ToString() ) );
        }

#if DEBUG
        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.IsRowOptimized"]/*' />
        public bool IsRowOptimized( DataRow r ) {
            XmlBoundElement e = r.Element;
            Debug.Assert( e != null );
            return ! IsFoliated( e );
        }
#endif
        internal static bool IsTextLikeNode( XmlNode n ) {
            switch ( n.NodeType ) {
                case XmlNodeType.Text:
                case XmlNodeType.CDATA:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    return true;

                case XmlNodeType.EntityReference:
                    Debug.Assert( false );
                    return false;

                default:
                    return false;
            }
        }

        internal bool IsNotMapped( DataColumn c ) {
            return DataSetMapper.IsNotMapped( c );
        }

        private bool IsSame( DataColumn c, int recNo1, int recNo2 ) {
            if ( c.Compare( recNo1, recNo2 ) == 0 )
                return true;

            return false;
        }

        internal bool IsTextOnly( DataColumn c ) {
            return c.ColumnMapping == MappingType.SimpleContent;
        }


        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.Load1"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified file.</para>
        /// </devdoc>
        public override void Load( string filename ) {
            this.bForceExpandEntity = true;
            base.Load( filename );
            this.bForceExpandEntity = false;
        }
        
        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.Load2"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified Stream.</para>
        /// </devdoc>
        public override void Load( Stream inStream ) {
            this.bForceExpandEntity = true;
            base.Load( inStream );
            this.bForceExpandEntity = false;
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.Load3"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified TextReader.</para>
        /// </devdoc>
        public override void Load( TextReader txtReader ) {
            this.bForceExpandEntity = true;
            base.Load( txtReader );
            this.bForceExpandEntity = false;
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.Load"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified XmlReader.</para>
        /// </devdoc>
        public override void Load( XmlReader reader ) {
            if ( this.FirstChild != null )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_MultipleLoad ) );

            try {
                ignoreXmlEvents = true;

                // Unhook the DataRowCreatedSpecial listener, since we no longer base on the first created DataRow to do the Bind
                if ( fDataRowCreatedSpecial )
                    UnBindSpecialListeners();

                // We should NOT create DataRow objects when calling XmlDataDocument.CreateElement
                fAssociateDataRow = false;
                // Foliation s/b disabled
                isFoliationEnabled = false;

                //now if we load from file we need to set the ExpandEntity flag to ExpandEntities
                if ( this.bForceExpandEntity ) {
                    Debug.Assert( reader is XmlValidatingReader );
                    ((XmlValidatingReader)reader).EntityHandling = EntityHandling.ExpandEntities;
                }
                base.Load( reader );
                BindForLoad();
            }
            finally {
                ignoreXmlEvents = false;
                isFoliationEnabled = true;
                autoFoliationState = ElementState.StrongFoliation;
                fAssociateDataRow = true;
            }
        }

        private void LoadDataSetFromTree() {
            ignoreDataSetEvents = true;
            ignoreXmlEvents = true;
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;
            bool saveEnforce = dataSet.EnforceConstraints;
            dataSet.EnforceConstraints = false;

            try {
                Debug.Assert( DocumentElement != null );
                LoadRows( null, DocumentElement );
                SyncRows( null, DocumentElement, true );

                dataSet.EnforceConstraints = saveEnforce;
            }
            finally {
                ignoreDataSetEvents = false;
                ignoreXmlEvents = false;
                IsFoliationEnabled = wasFoliationEnabled;
            }
        }

        private void LoadTreeFromDataSet( DataSet ds ) {
            ignoreDataSetEvents = true;
            ignoreXmlEvents = true;
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;
            this.fAssociateDataRow = false;

            try {
                foreach( DataTable t in ds.Tables ) {
                    foreach( DataRow r in t.Rows ) {
                        Debug.Assert( r.Element == null );
                        XmlBoundElement rowElem = AttachBoundElementToDataRow( r );
                        // BUGBUG: are we handling the Deleted/Detached case correctly ?
                        switch ( r.RowState ) {
                        case DataRowState.Added:
                        case DataRowState.Unchanged:
                        case DataRowState.Modified:
                            // BUGBUG: What happens when we are trying to insert a row that is a nested child for a row that is not yet added to the tree ?
                            OnAddRow( r );
                            break;
                        case DataRowState.Deleted:
                            // Nothing to do (the row already has an associated element as a fragment
                            break;
                        case DataRowState.Detached:
                            // We should not get rows in this state
                            Debug.Assert( false );
                            break;
                        default:
                            // Unknown row state
                            Debug.Assert( false );
                            break;
                        }
                    }
                }
            }
            finally {
                ignoreDataSetEvents = false;
                ignoreXmlEvents = false;
                IsFoliationEnabled = wasFoliationEnabled;
                this.fAssociateDataRow = true;
            }
        }

        // load all data from tree structre into datarows
        private void LoadRows( XmlBoundElement rowElem, XmlNode node ) {
            Debug.Assert( node != null );

            XmlBoundElement be = node as XmlBoundElement;
            if ( be != null ) {
                DataTable dt = mapper.SearchMatchingTableSchema( rowElem, be );

                if ( dt != null ) {
                    DataRow r = GetRowFromElement( be );
                    Debug.Assert( r == null );
                    // If the rowElement was just created and has an un-initialized
                    if ( be.ElementState == ElementState.None )
                        be.ElementState = ElementState.WeakFoliation;
                    r = dt.CreateEmptyRow();
                    Bind( r, be );

                    // the region rowElem is now be
                    Debug.Assert( be.Row != null );
                    rowElem = be;
                }
            }
            // recurse down for children
            for ( XmlNode child = node.FirstChild; child != null; child = child.NextSibling )
                LoadRows( rowElem, child );
        }

        internal DataSetMapper Mapper {
            get {
                return mapper;
            }
        }

        internal void OnDataRowCreated( object oDataSet, DataRow row ) {
            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom( "OnDataRowCreated", row ) );

            Debug.Assert( row.RowState == DataRowState.Detached );
            OnNewRow( row );
        }

        internal void OnClearCalled( object oDataSet, DataTable table ) {
            throw new NotSupportedException( Res.GetString( Res.DataDom_NotSupport_Clear ) );
        }
        
        internal void OnDataRowCreatedSpecial( object oDataSet, DataRow row ) {
            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom( "OnDataRowCreatedSpecial", row ) );

            Debug.Assert( row.RowState == DataRowState.Detached );

            // Register the regular events and un-register this one
            Bind(true);
            // Pass the event to the regular listener
            OnNewRow( row );
        }
        // Called when a new DataRow is created
        internal void OnNewRow( DataRow row ) {
            Debug.Assert( row.Element == null );
            // Allow New state also because we are calling this function from
            Debug.Assert( row.RowState == DataRowState.Detached );

            AttachBoundElementToDataRow( row );
        }

        private XmlBoundElement AttachBoundElementToDataRow( DataRow row ) {
            Debug.Assert( row.Element == null );
            DataTable table = row.Table;
            // We shoould NOT call CreateElement here, since CreateElement will create and attach a new DataRow to the element
            XmlBoundElement rowElement = new XmlBoundElement( string.Empty, table.EncodedTableName, table.Namespace, this );
            rowElement.IsEmpty = false;
            Bind( row, rowElement );
            rowElement.ElementState = ElementState.Defoliated;
            return rowElement;
        }

        private bool NeedXSI_NilAttr( DataRow row ) {
            DataTable tb = row.Table;
            Debug.Assert( tb != null ) ;
            if ( tb.xmlText == null )
                return false; 
            object value = row[tb.xmlText];
            return ( Convert.IsDBNull( value ) );
        }

        private void OnAddRow( DataRow row ) {
            // Xml operations in this func should not trigger ROM operations
            Debug.Assert( this.ignoreXmlEvents == true );

            XmlBoundElement rowElement = (XmlBoundElement)(GetElementFromRow( row ));
            Debug.Assert( rowElement != null );

            if ( NeedXSI_NilAttr( row ) && !rowElement.IsFoliated )
                //we need to foliate it because we need to add one more attribute xsi:nil = true;
                ForceFoliation( rowElement, AutoFoliationState );
            
            Debug.Assert( rowElement != null );
            DataRow rowDocElem = GetRowFromElement( this.DocumentElement );
            if ( rowDocElem != null ) {
                DataRow parentRow = GetNestedParent( row );
                if ( parentRow == null )
                    DemoteDocumentElement();
            }
            EnsureDocumentElement().AppendChild( rowElement );

            // Move the children of the row under
            FixNestedChildren( row, rowElement );
            OnNestedParentChange( row, rowElement, null );
        }

        private void OnColumnValueChanged( DataRow row, DataColumn col, XmlBoundElement rowElement ) {
            // BUGBUG - Does this break this scenario: nested relationship between parentRow and childRow, where childRow nestedRel column is not hidden. Child row changes the childRow[nestedRelColumn] value. Does both the nested parent and value changes ?
            if ( IsNotMapped(col) )
                goto lblDoNestedRelationSync;

            object value = row[col];

            if ( col.ColumnMapping == MappingType.SimpleContent && Convert.IsDBNull( value ) && !rowElement.IsFoliated )
                ForceFoliation( rowElement, ElementState.WeakFoliation);
            else {
                // no need to sync if not foliated
                if ( !IsFoliated( rowElement ) ) {
#if DEBUG
                    // If the new value is null, we should be already foliated if there is a DataPointer that points to the column
                    // (see OnRowChanging, case DataRowAction.Change)
                    if ( Convert.IsDBNull( row[col, DataRowVersion.Current] ) ) {
                        try {
                            if ( pointers.Count > 0 ) {
                                object pointer = null;
                                foreach( DictionaryEntry entry in pointers ) {
                                    pointer = entry.Value;
                                    Debug.Assert( (pointer != null) && ! ((IXmlDataVirtualNode)pointer).IsOnColumn( col ) );
                                }
                            }
                        }
                        catch {
                            // We may get an exception if we are in foreach and a new pointer has been added to this.pointers. When this happens, we will skip this check and ignore the exceptions
                        }
                    }
#endif
                    goto lblDoNestedRelationSync;
                }
            }

            if ( IsTextOnly( col ) ) {
                if ( Convert.IsDBNull( value ) ) {
                    value = String.Empty;
                    //make sure that rowElement has Attribute xsi:nil and its value is true
                    XmlAttribute attr = rowElement.GetAttributeNode(XSI_NIL);
                    if ( attr == null ) {
                        attr = CreateAttribute( XSI, Keywords.XSI_NIL, Keywords.XSINS );
                        attr.Value = Keywords.TRUE;
                        rowElement.SetAttributeNode( attr );
                        this.bHasXSINIL = true;
                    }
                    else
                        attr.Value = Keywords.TRUE;                    
                }
                else {
                    //make sure that if rowElement has Attribute xsi:nil, its value is false
                    XmlAttribute attr = rowElement.GetAttributeNode(XSI_NIL);
                    if ( attr != null )
                        attr.Value = Keywords.FALSE;
                }
                ReplaceInitialChildText( rowElement, col.ConvertObjectToXml( value ) );
                goto lblDoNestedRelationSync;
            }

            // update the attribute that maps to the column
            bool fFound = false;

            // Find the field node and set it's value
            if (col.ColumnMapping == MappingType.Attribute) {
                foreach( XmlAttribute attr in rowElement.Attributes ) {
                    if ( attr.LocalName == col.EncodedColumnName && attr.NamespaceURI == col.Namespace ) {
                        if ( Convert.IsDBNull( value ) ) {
                            attr.OwnerElement.Attributes.Remove( attr );
                        }
                        else {
                            attr.Value = col.ConvertObjectToXml( value );
                        }
                        fFound = true;
                        break;
                    }
                }

                // create new attribute if we didn't find one.
                if ( !fFound && ! Convert.IsDBNull( value ) ) {
                    rowElement.SetAttribute( col.EncodedColumnName, col.Namespace, col.ConvertObjectToXml( value ) );
                }
            }
            else {
                // update elements that map to the column...
                RegionIterator iter = new RegionIterator( (XmlBoundElement)rowElement );
                bool fMore = iter.Next();
                while ( fMore ) {
                    if ( iter.CurrentNode.NodeType == XmlNodeType.Element ) {
                        XmlElement e = (XmlElement) iter.CurrentNode;
                        Debug.Assert( e != null );
                        //we should skip the subregion 
                        XmlBoundElement be = e as XmlBoundElement;
                        if ( be != null && be.Row != null ) {
                            fMore = iter.NextRight(); //skip over the sub-region
                            continue;
                        }
                        if ( e.LocalName == col.EncodedColumnName && e.NamespaceURI == col.Namespace ) {
                            fFound = true;
                            if ( Convert.IsDBNull( value ) ) {
                                PromoteNonValueChildren( e );
                                fMore = iter.NextRight();
                                e.ParentNode.RemoveChild( e );
                                // keep looking for more matching elements
                                continue;
                            }
                            else {
                                ReplaceInitialChildText( e, col.ConvertObjectToXml( value ) );
                                //make sure that if the Element has Attribute xsi:nil, its value is false
                                XmlAttribute attr = e.GetAttributeNode(XSI_NIL);
                                if ( attr != null )
                                    attr.Value = Keywords.FALSE;
                                // no need to look any further.
                                goto lblDoNestedRelationSync;
                            }
                        }
                    }
                    fMore = iter.Next();
                }

                // create new element if we didn't find one.
                if ( !fFound && ! Convert.IsDBNull( value ) ) {
                    XmlElement newElem = new XmlBoundElement( string.Empty, col.EncodedColumnName, col.Namespace, this );
                    newElem.AppendChild( CreateTextNode( col.ConvertObjectToXml( value ) ) );

                    XmlNode elemBefore = GetColumnInsertAfterLocation( row, col, rowElement );
                    if ( elemBefore != null ) {
                        rowElement.InsertAfter( newElem, elemBefore );
                    }
                    else if ( rowElement.FirstChild != null ) {
                        rowElement.InsertBefore( newElem, rowElement.FirstChild );
                    }
                    else {
                        rowElement.AppendChild( newElem );
                    }
                }
            }
lblDoNestedRelationSync:
            // Change the XML to conform to the (potentially) change in parent nested relation
            DataRelation relation = GetNestedParentRelation(row);
            if ( relation != null ) {
                Debug.Assert( relation.ChildTable == row.Table );
                if ( relation.ChildKey.ContainsColumn( col ) )
                    OnNestedParentChange( row, rowElement, col );
            }
        }

        private void OnColumnChanged( object sender, DataColumnChangeEventArgs args ) {
            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom("OnColumnChanged", args) );

            // You should not be able to make DataRow field changes if the DataRow is deleted
            Debug.Assert( args.Row.RowState != DataRowState.Deleted );

            if ( ignoreDataSetEvents )
                return;

            bool wasIgnoreXmlEvents = ignoreXmlEvents;
            ignoreXmlEvents = true;
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;

            try {
                DataRow row     = args.Row;
                DataColumn col  = args.Column;
                object oVal     = args.ProposedValue;

                if ( row.RowState == DataRowState.Detached ) {
                    XmlBoundElement be = row.Element;
                    Debug.Assert( be != null );
                    if ( be.IsFoliated ) {
                        // Need to sync changes from ROM to DOM
                        OnColumnValueChanged( row, col, be );
                    }
                }
            }
            finally {
                IsFoliationEnabled = wasFoliationEnabled;
                ignoreXmlEvents = wasIgnoreXmlEvents;
            }
        }

//        private void OnColumnChanging( object sender, DataColumnChangeEventArgs args ) {
//            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom("OnColumnChanging", args) );
//        }

        private void OnColumnValuesChanged( DataRow row, XmlBoundElement rowElement ) {
            Debug.Assert( row != null );
            Debug.Assert( rowElement != null );

            // If user has cascading relationships, then columnChangeList will contains the changed columns only for the last row beeing cascaded
            // but there will be multiple ROM events
            if ( columnChangeList.Count > 0 ) {
                if ( ((DataColumn)(columnChangeList[0])).Table == row.Table ) {
                    Debug.WriteLineIf( XmlTrace.traceRomChanges.Enabled, XmlTrace.StringFrom( "Sync ROM->XML: " + columnChangeList.Count + " cols (from cache): ", row ) );
                    foreach( DataColumn c in columnChangeList )
                        OnColumnValueChanged( row, c, rowElement );
                }
                else {
                    Debug.WriteLineIf( XmlTrace.traceRomChanges.Enabled, XmlTrace.StringFrom( "Sync ROM->XML: All " + columnChangeList.Count + " cols (bad cache): ", row ) );
                    foreach( DataColumn c in row.Table.Columns )
                        OnColumnValueChanged( row, c, rowElement );
                }
            }
            else {
                Debug.WriteLineIf( XmlTrace.traceRomChanges.Enabled, XmlTrace.StringFrom( "Sync ROM->XML: All " + columnChangeList.Count + " cols (empty cache): ", row ) );
                foreach( DataColumn c in row.Table.Columns )
                    OnColumnValueChanged( row, c, rowElement );
            }

            Debug.WriteLineIf( XmlTrace.traceRomChanges.Enabled, XmlTrace.StringFrom( "Sync ROM->XML: Clear cache: ", row ) );
            columnChangeList.Clear();
        }

        private void OnDeleteRow( DataRow row, XmlBoundElement rowElement ) {
            // IgnoreXmlEvents s/b on since we are manipulating the XML tree and we not want this to reflect in ROM view.
            Debug.Assert( this.ignoreXmlEvents == true );
            // Special case when rowElem is document element: we create a new docElem, move the current one as a child of
            // the new created docElem, then process as if the docElem is not a rowElem
            if ( rowElement == this.DocumentElement )
                DemoteDocumentElement();

            PromoteInnerRegions( rowElement );
            rowElement.ParentNode.RemoveChild( rowElement );
        }

        private void OnDeletingRow( DataRow row, XmlBoundElement rowElement ) {
            // Note that this function is beeing called even if ignoreDataSetEvents == true.

            // Foliate, so we can be able to preserve the nodes even if the DataRow has no longer values for the crtRecord.
            if ( IsFoliated( rowElement ) )
                return;

            bool wasIgnoreXmlEvents  = IgnoreXmlEvents;
            IgnoreXmlEvents          = true;
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled       = true;
            try {
                Foliate( rowElement );
            }
            finally {
                IsFoliationEnabled = wasFoliationEnabled;
                IgnoreXmlEvents    = wasIgnoreXmlEvents;
            }
        }

        private void OnFoliated( XmlNode node ) {
            Debug.WriteLineIf(XmlTrace.traceXmlDataDocumentEvents.Enabled, XmlTrace.StringFrom("XmlDataDocument::OnFoliated", node));
            while ( true ) {
                try {
                    if ( pointers.Count > 0 ) {
                        foreach( DictionaryEntry entry in pointers ) {
                            object pointer = entry.Value;
                            Debug.Assert( pointer != null );
                            ((IXmlDataVirtualNode)pointer).OnFoliated( node );
                        }
                    }
                    return;
                }
                catch {
                    // This can happens only when some threads are creating navigators (thus modifying this.pointers) while other threads are in the foreach loop.
                    // Solution is to re-try OnFoliated.
                }
            }
            // You should never get here in regular cases
        }

        DataColumn FindAssociatedParentColumn( DataRelation relation, DataColumn childCol ) {
            DataColumn[] columns = relation.ChildKey.Columns;
            for (int i = 0; i < columns.Length; i++) {
                if ( childCol == columns[i] )
                    return relation.ParentKey.Columns[i];
            }
            return null;
        }

        // Change the childElement position in the tree to conform to the parent nested relationship in ROM
        private void OnNestedParentChange(DataRow child, XmlBoundElement childElement, DataColumn childCol) {
            Debug.Assert( child.Element == childElement && childElement.Row == child );
            // This function is (and s/b) called as a result of ROM changes, therefore XML changes done here should not be sync-ed to ROM
            Debug.Assert( ignoreXmlEvents == true );
#if DEBUG
            // In order to check that this move does not change the connected/disconnected state of the node
            bool fChildElementConnected = IsConnected( childElement );
#endif
            DataRow parentRowInTree;
            if ( childElement == this.DocumentElement || childElement.ParentNode == null )
                parentRowInTree = null;
            else
                parentRowInTree = GetRowFromElement( (XmlElement) childElement.ParentNode );
            DataRow parentRowInRelation = GetNestedParent(child);

            if ( parentRowInTree != parentRowInRelation ) {
                if ( parentRowInRelation != null ) {
                    // BUGBUG: What happens if I load this XML: <order>...<cust>...</cust>..</order>, then I go to ROM and change the nested parent of order to be cust ?
                    //   XML will throw an exception because it cannot make order a child of the cust.
                    XmlElement newParent = GetElementFromRow( parentRowInRelation );
                    newParent.AppendChild( childElement );
                }
                else {
                    // no parent? Maybe the parentRow is during changing or childCol is the ID is set to null ( detached from the parent row ).
                    DataRelation relation = GetNestedParentRelation(child);
                    if ( childCol == null || relation == null || Convert.IsDBNull(child[childCol]) ) {
                        EnsureNonRowDocumentElement().AppendChild( childElement );
                    }
                    else {
                        DataColumn colInParent = FindAssociatedParentColumn( relation, childCol );
                        Debug.Assert( colInParent != null );
                        if ( colInParent.CompareToValue( parentRowInTree.tempRecord, child[childCol] ) != 0 )
                            EnsureNonRowDocumentElement().AppendChild( childElement );
                        //else do nothing because its original parentRowInRelation will be changed so that this row will still be its child
                    }
                }
            }
#if DEBUG
            // We should not have changed the connected/disconnected state of the node (since the row state did not change) -- IOW if the original childElem was in dis-connected
            // state and corresponded to a detached/deleted row, by adding it to the main tree we become inconsistent (since we have now a deleted/detached row in the main tree)
            // Same goes when we remove a node from connected tree to make it a child of a row-node corresponding to a non-live row.
            Debug.Assert( fChildElementConnected == IsConnected( childElement ) );
            Debug.Assert( IsRowLive( child ) ? IsConnected( childElement ) : ! IsConnected( childElement ) );
#endif
        }

        private void OnNodeChanged( object sender, XmlNodeChangedEventArgs args ) {
            if ( ignoreXmlEvents )
                return;

            bool wasIgnoreDataSetEvents = ignoreDataSetEvents;
            bool wasIgnoreXmlEvents     = ignoreXmlEvents;
            bool wasFoliationEnabled    = IsFoliationEnabled;
            ignoreDataSetEvents = true;
            ignoreXmlEvents     = true;
            IsFoliationEnabled  = false;
            bool fEnableCascading = DataSet.fEnableCascading;
            DataSet.fEnableCascading = false;

            try {
                // okay to allow text node value changes when bound.
                XmlBoundElement rowElement = null;

                Debug.Assert( DataSet.EnforceConstraints == false );

                if ( mapper.GetRegion( args.Node, out rowElement ) ) {
                    SynchronizeRowFromRowElement( rowElement );
                }
            }
            finally {
                ignoreDataSetEvents = wasIgnoreDataSetEvents;
                ignoreXmlEvents     = wasIgnoreXmlEvents;
                IsFoliationEnabled  = wasFoliationEnabled;
                DataSet.fEnableCascading = fEnableCascading;
            }
        }

        private void OnNodeChanging( object sender, XmlNodeChangedEventArgs args ) {
            if( ignoreXmlEvents )
                return;
            if ( DataSet.EnforceConstraints != false )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_EnforceConstraintsShouldBeOff ) );
        }


        private void OnNodeInserted( object sender, XmlNodeChangedEventArgs args ) {
            if ( ignoreXmlEvents )
                return;

            bool wasIgnoreDataSetEvents = ignoreDataSetEvents;
            bool wasIgnoreXmlEvents     = ignoreXmlEvents;
            bool wasFoliationEnabled    = IsFoliationEnabled;
            ignoreDataSetEvents = true;
            ignoreXmlEvents     = true;
            IsFoliationEnabled  = false;

            Debug.Assert( DataSet.EnforceConstraints == false );

            bool fEnableCascading = DataSet.fEnableCascading;
            DataSet.fEnableCascading = false;

            try {
                // Handle both new node inserted and 2nd part of a move operation.
                // TODO: For performance reasons, handle Move operation in a signle step (we need support from DOM to send a Move event, rather than 2 separate events: Remove and Insert)
                XmlNode node = args.Node;
                XmlNode oldParent = args.OldParent;
                XmlNode newParent = args.NewParent;

                // The code bellow assumes a move operation is fired by DOM in 2 steps: a Remvoe followed by an Insert - this is the 2nd part, the Insert.
                Debug.Assert( oldParent == null );
                if ( IsConnected( newParent ) ) {
                    // Inserting a node to connected tree
                    OnNodeInsertedInTree( node );
                }
                else {
                    // Inserting a node to disconnected tree
                    OnNodeInsertedInFragment( node );
                }
            }
            finally {
                ignoreDataSetEvents = wasIgnoreDataSetEvents;
                ignoreXmlEvents     = wasIgnoreXmlEvents;
                IsFoliationEnabled  = wasFoliationEnabled;
                DataSet.fEnableCascading = fEnableCascading;
            }

        }

        private void OnNodeInserting( object sender, XmlNodeChangedEventArgs args ) {
            if ( ignoreXmlEvents )
                return;
            if ( DataSet.EnforceConstraints != false )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_EnforceConstraintsShouldBeOff ) );
        }


        private void OnNodeRemoved( object sender, XmlNodeChangedEventArgs args ) {
            if ( ignoreXmlEvents )
                return;

            bool wasIgnoreDataSetEvents = ignoreDataSetEvents;
            bool wasIgnoreXmlEvents     = ignoreXmlEvents;
            bool wasFoliationEnabled    = IsFoliationEnabled;
            ignoreDataSetEvents = true;
            ignoreXmlEvents     = true;
            IsFoliationEnabled  = false;

            Debug.Assert( DataSet.EnforceConstraints == false );

            bool fEnableCascading = DataSet.fEnableCascading;
            DataSet.fEnableCascading = false;

            try {
                XmlNode node = args.Node;
                XmlNode oldParent = args.OldParent;
                Debug.Assert( args.NewParent == null );

                if ( IsConnected( oldParent ) ) {
                    // Removing from connected tree to disconnected tree
                    OnNodeRemovedFromTree( node, oldParent );
                }
                else {
                    // Removing from disconnected tree to disconnected tree: just sync the old region
                    OnNodeRemovedFromFragment( node, oldParent );
                }
            }
            finally {
                ignoreDataSetEvents = wasIgnoreDataSetEvents;
                ignoreXmlEvents     = wasIgnoreXmlEvents;
                IsFoliationEnabled  = wasFoliationEnabled;
                DataSet.fEnableCascading = fEnableCascading;
            }
        }

        private void OnNodeRemoving( object sender, XmlNodeChangedEventArgs args ) {
            if ( ignoreXmlEvents )
                return;
            if ( DataSet.EnforceConstraints != false )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_EnforceConstraintsShouldBeOff ) );
        }

        // Node was removed from connected tree to disconnected tree
        private void OnNodeRemovedFromTree( XmlNode node, XmlNode oldParent ) {
            XmlBoundElement oldRowElem;

            // Synchronize values from old region
            if ( mapper.GetRegion( oldParent, out oldRowElem ) )
                SynchronizeRowFromRowElement( oldRowElem );

            // Disconnect all regions, starting w/ node (if it is a row-elem)
            XmlBoundElement rowElem = node as XmlBoundElement;
            if ( rowElem != null && rowElem.Row != null )
                EnsureDisconnectedDataRow( rowElem );
            TreeIterator iter = new TreeIterator( node );
            for ( bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRowElement() ) {
                rowElem = (XmlBoundElement)(iter.CurrentNode);
                EnsureDisconnectedDataRow( rowElem );
            }

            // Assert that all sub-regions are disconnected
            AssertNonLiveRows( node );
        }
        // Node was removed from the disconnected tree to disconnected tree
        private void OnNodeRemovedFromFragment( XmlNode node, XmlNode oldParent ) {
            XmlBoundElement oldRowElem;

            if ( mapper.GetRegion( oldParent, out oldRowElem ) ) {
                // Sync the old region if it is not deleted
                DataRow row = oldRowElem.Row;
                // Since the old old region was disconnected, then the row can be only Deleted or Detached
                Debug.Assert( ! IsRowLive( row ) );
                if ( oldRowElem.Row.RowState == DataRowState.Detached )
                    SynchronizeRowFromRowElement( oldRowElem );
            }

            // Need to set nested for the sub-regions (if node is a row-elem, we need to set it just for itself)
            XmlBoundElement be = node as XmlBoundElement;
            if ( be != null && be.Row != null ) {
                Debug.Assert( ! IsRowLive( be.Row ) );
                SetNestedParentRegion( be, null );
            }
            else {
                // Set nested parent to null for all child regions
                TreeIterator iter = new TreeIterator( node );
                for ( bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRightRowElement() ) {
                    XmlBoundElement rowElemChild = (XmlBoundElement)(iter.CurrentNode);
                    SetNestedParentRegion( rowElemChild, null );
                }
            }

            // Assert that all sub-regions are disconnected
            AssertNonLiveRows( node );
        }


        private void OnRowChanged( object sender, DataRowChangeEventArgs args ) {
            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom("OnRowChanged", args) );
            if ( ignoreDataSetEvents )
                return;

            ignoreXmlEvents = true;
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;

            try {
                DataRow row = args.Row;
                XmlBoundElement rowElement = row.Element;
                // We should have an associated row-elem created when the DataRow was created (or at the load time)
                Debug.Assert( rowElement != null );

                switch ( args.Action ) {
                    case DataRowAction.Add:
                        // BUGBUG: We may not have an associated DataRow for this scenario:
                        //  - dr = ds.Tables[0].NewRow();
                        //  - XmlDataDocument doc = new XmlDataDocument( ds );
                        //  - doc.DataSet.Tables[0].Add( dr )
                        // The problem here is that in doc constructor we don't know about the detached rows, so we do not create XmlBoundElement's for them.
                        // The solution is to create and attach XmlBoundElements when the row is added to the table (if there is no XmlBoundElem associtead w/ dr)
                        // and/or when the user calls doc.GetElementFromRow().
                        // BUGBUG - What happens when we have dr1 which is detached and dr2 which is in the tree, each of them have no parent - and then we
                        // call dr2.SetParent( dr1, nestedRel ); - bassically ROM has a nested relationship between a live row (child) and non-live row (parent) ?
                        OnAddRow( row );
                        break;

                    case DataRowAction.Delete:
                        OnDeleteRow( row, rowElement );
                        break;

                    case DataRowAction.Rollback:
                        switch ( rollbackState ) {
                            case DataRowState.Deleted:
                                OnUndeleteRow( row, rowElement );
                                UpdateAllColumns( row, rowElement );
                                break;

                            case DataRowState.Added:
                                rowElement.ParentNode.RemoveChild( rowElement );
                                break;

                            case DataRowState.Modified:
                                OnColumnValuesChanged( row, rowElement );
                                break;
                        }
                        break;

                    case DataRowAction.Change:
                        OnColumnValuesChanged( row, rowElement );
                        break;

                    case DataRowAction.Commit:
                        if ( row.RowState == DataRowState.Detached ) {
                            //by now, all the descendent of the element that is not of this region should have been promoted already
                            rowElement.RemoveAll();
                        }
                        break;
                    default:
                        //Console.WriteLine("Other Event");
                        break;
                }
            }
            finally {
                IsFoliationEnabled = wasFoliationEnabled;
                ignoreXmlEvents = false;
            }
        }

        private void OnRowChanging( object sender, DataRowChangeEventArgs args ) {
            Debug.WriteLineIf(XmlTrace.traceDataSetEvents.Enabled, XmlTrace.StringFrom("OnRowChanging", args) );

            // We foliate the region each time the assocaited row gets deleted
            DataRow row = args.Row;
            if ( args.Action == DataRowAction.Delete && row.Element != null ) {
                OnDeletingRow( row, row.Element );
                return;
            }

            if ( ignoreDataSetEvents )
                return;

            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;

            try {
                ignoreXmlEvents = true;

                XmlElement rowElement = GetElementFromRow( row );

                int nRec1 = -1; 
                int nRec2 = -1;
                
                if ( rowElement != null ) {
                    switch ( args.Action ) {
                        case DataRowAction.Add:
                            // DataRow is beeing added to the table (Table.Rows.Add is beeing called)
                            break;

                        case DataRowAction.Delete:
                            // DataRow is beeing deleted
                            //    - state transition from New (AKA PendingInsert) to Detached (AKA Created)
                            //    - state transition from Unchanged to Deleted (AKA PendingDelete)
                            //    - state transition from Modified (AKA PendingChange) to Delete (AKA PendingDelete)
                            Debug.Assert( false );  // This should have been handled above, irrespective of ignoreDataSetEvents value (true or false)
                            break;

                        case DataRowAction.Rollback:
                            // DataRow gets reverted to previous values (by calling DataRow.RejectChanges):
                            //    - state transition from Detached (AKA Created) to Detached (AKA Created)
                            //    - state transition from New (AKA PendingInsert) to Detached (AKA Created)
                            //    - state transition from Modified (AKA PendingChange) to Unchanged
                            //    - state transition from Deleted (AKA PendingDelete) to Unchanged
                            rollbackState = row.RowState;
                            switch ( rollbackState ) {
                                case DataRowState.Deleted:
                                    break;

                                case DataRowState.Detached:
                                    break;

                                case DataRowState.Added:
                                    break;

                                case DataRowState.Modified:
                                    columnChangeList.Clear();
                                    nRec1 = row.GetRecordFromVersion(DataRowVersion.Original);
                                    nRec2 = row.GetRecordFromVersion(DataRowVersion.Current);
                                    foreach( DataColumn c in row.Table.Columns ) {
                                        if ( !IsSame( c, nRec1, nRec2 ) )
                                            columnChangeList.Add(c);
                                    }
                                    break;

                            }
                            break;

                        case DataRowAction.Change:
                            // A DataRow field is beeing changed
                            //    - state transition from New (AKA PendingInsert) to New (AKA PendingInsert)
                            //    - state transition from Unchanged to Modified (AKA PendingChange)
                            //    - state transition from Modified (AKA PendingChange) to Modified (AKA PendingChange)
                            //TODO(DanielD): Can further optimize this by tracking the ColumnChange event rather than comparing column values ?
                            columnChangeList.Clear();
                            nRec1 = row.GetRecordFromVersion( DataRowVersion.Proposed );
                            nRec2 = row.GetRecordFromVersion( DataRowVersion.Current );
                            foreach( DataColumn c in row.Table.Columns ) {
                                object proposedValue = row[c, DataRowVersion.Proposed];                                
                                object currentValue  = row[c, DataRowVersion.Current];
                                // Foliate if proposedValue is DBNull; this way the DataPointer objects will point to a disconnected fragment after
                                // the DBNull value is beeing set
                                if ( Convert.IsDBNull( proposedValue ) && ! Convert.IsDBNull( currentValue ) ) {
                                    // Foliate only for non-hidden columns (since hidden cols are not represented in XML)
                                    if ( c.ColumnMapping != MappingType.Hidden )
                                        FoliateIfDataPointers( row, rowElement );
                                }
                                if ( !IsSame( c, nRec1, nRec2 ) )
                                    columnChangeList.Add(c);
                            }
                            break;

                        case DataRowAction.Commit:
                            break;
                    }
                }
            }
            finally {
                ignoreXmlEvents = false;
                IsFoliationEnabled = wasFoliationEnabled;
            }
        }

        private void OnDataSetPropertyChanging( object oDataSet, PropertyChangedEventArgs args ) {
            if ( args.PropertyName == "DataSetName" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_DataSetNameChange ) );
            // TODO: What about the prefix and namespace ?
        }
        private void OnColumnPropertyChanging( object oColumn, PropertyChangedEventArgs args ) {
            if ( args.PropertyName == "ColumnName" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_ColumnNameChange ) );
            if ( args.PropertyName == "Namespace" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_ColumnNamespaceChange ) );
            if ( args.PropertyName == "ColumnMapping" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_ColumnMappingChange ) );
        }
        private void OnTablePropertyChanging( object oTable, PropertyChangedEventArgs args ) {
            if ( args.PropertyName == "TableName" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_TableNameChange ) );
            if ( args.PropertyName == "Namespace" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_TableNamespaceChange ) );
        }
        private void OnTableColumnsChanging( object oColumnsCollection, CollectionChangeEventArgs args ) {
            // args.Action is one of CollectionChangeAction.Add, CollectionChangeAction.Remove or CollectionChangeAction.Refresh
            // args.Element is one of either the column (for Add and Remove actions or null, if the entire colection of columns is changing)

            // Disallow changing the columns collection (since we are subscribed only in populated mode, we allow changes in any state but non-populated mode)
            throw new InvalidOperationException(  Res.GetString( Res.DataDom_TableColumnsChange ) );
        }

        private void OnDataSetTablesChanging( object oTablesCollection, CollectionChangeEventArgs args ) {
            // args.Action is one of CollectionChangeAction.Add, CollectionChangeAction.Remove or CollectionChangeAction.Refresh
            // args.Element is a table (dont know if it can be null: TODO: find this out)

            // Disallow changing the tables collection (since we are subscribed only in populated mode, we allow changes in any state but non-populated mode)
            throw new InvalidOperationException(  Res.GetString( Res.DataDom_DataSetTablesChange ) );
        }

        private void OnDataSetRelationsChanging( object oRelationsCollection, CollectionChangeEventArgs args ) {
            // args.Action is one of CollectionChangeAction.Add, CollectionChangeAction.Remove or CollectionChangeAction.Refresh
            // args.Element is a DataRelation (dont know if it can be null: TODO: find this out)

            // Disallow changing the tables collection if there is data loaded and there are nested relationship that are added/refreshed
            DataRelation rel = (DataRelation)(args.Element);
            if ( rel != null && rel.Nested )
                throw new InvalidOperationException(  Res.GetString( Res.DataDom_DataSetNestedRelationsChange ) );

            // If Add and Remove, we should already been throwing if .Nested == false
            Debug.Assert( ! (args.Action == CollectionChangeAction.Add || args.Action == CollectionChangeAction.Remove) || rel.Nested == false );
            if ( args.Action == CollectionChangeAction.Refresh ) {
                foreach ( DataRelation relTemp in (DataRelationCollection)oRelationsCollection ) {
                    if ( relTemp.Nested ) {
                        throw new InvalidOperationException(  Res.GetString( Res.DataDom_DataSetNestedRelationsChange ) );
                    }
                }
            }
        }

        private void OnRelationPropertyChanging( object oRelationsCollection, PropertyChangedEventArgs args ) {
            if ( args.PropertyName == "Nested" )
                throw new InvalidOperationException( Res.GetString( Res.DataDom_DataSetNestedRelationsChange ) );
        }

        private void OnUndeleteRow( DataRow row, XmlElement rowElement ) {
            XmlNode refRow;
            XmlElement parent;

            // make certain we weren't place somewhere else.
            if ( rowElement.ParentNode != null )
                rowElement.ParentNode.RemoveChild( rowElement );

            // Find the parent of RowNode to be inserted
            DataRow parentRowInRelation = GetNestedParent(row);
            if (parentRowInRelation == null) {
                parent = EnsureNonRowDocumentElement();
            }
            else
                parent = GetElementFromRow(parentRowInRelation);

            if ((refRow = GetRowInsertBeforeLocation(row, rowElement, parent)) != null)
                parent.InsertBefore(rowElement, refRow);
            else
                parent.AppendChild( rowElement );

            FixNestedChildren(row, rowElement);
        }

        // Promote the rowElemChild node/region after prevSibling node (as the next sibling)
        private void PromoteChild( XmlNode child, XmlNode prevSibling ) {
            // It makes no sense to move rowElemChild on the same level
            Debug.Assert( child.ParentNode != prevSibling.ParentNode );
            // prevSibling must have a parent, since we want to add a sibling to it
            Debug.Assert( prevSibling.ParentNode != null );
            Debug.Assert( IsFoliationEnabled == false );
            Debug.Assert( IgnoreXmlEvents == true );
            // Should not insert after docElem node
            Debug.Assert( prevSibling != this.DocumentElement );

            if ( child.ParentNode != null )
                child.ParentNode.RemoveChild( child );

            Debug.Assert( child.ParentNode == null );
            prevSibling.ParentNode.InsertAfter( child, prevSibling );
        }

        // Promote child regions under parent as next siblings of parent        
        private void PromoteInnerRegions( XmlNode parent ) {
            Debug.Assert( parent != null );
            Debug.Assert( parent.NodeType != XmlNodeType.Attribute );   // We need to get get the grand-parent region
            Debug.Assert( parent != DocumentElement );                  // We cannot promote children of the DocumentElement

            XmlNode prevSibling = parent;
            XmlBoundElement parentRegionRowElem;
            mapper.GetRegion( parent.ParentNode, out parentRegionRowElem );

            TreeIterator iter = new TreeIterator( parent );
            bool fMore = iter.NextRowElement();
            while ( fMore ) {
                Debug.Assert( iter.CurrentNode is XmlBoundElement && ((XmlBoundElement)(iter.CurrentNode)).Row != null );
                XmlBoundElement rowElemChild = (XmlBoundElement)(iter.CurrentNode);
                fMore = iter.NextRightRowElement();
                PromoteChild( rowElemChild, prevSibling );
                SetNestedParentRegion( rowElemChild, parentRegionRowElem );
            }
        }

        private void PromoteNonValueChildren( XmlNode parent ) {
            Debug.Assert( parent != null );
            XmlNode prevSibling = parent;
            XmlNode child = parent.FirstChild;
            bool bTextLikeNode = true; 
            XmlNode nextSibling = null;
            while ( child != null ) {
                nextSibling = child.NextSibling;
                bTextLikeNode = bTextLikeNode && IsTextLikeNode(child);
                if ( !bTextLikeNode ) {
                    nextSibling = child.NextSibling;
                    PromoteChild( child, prevSibling );
                    prevSibling = child;
                }
                child = nextSibling;
            }
        }

        private void RemoveInitialTextNodes( XmlNode node ) {
            while ( node != null && IsTextLikeNode( node ) ) {
                XmlNode sibling = node.NextSibling;
                node.ParentNode.RemoveChild( node );
                node = sibling;
            }
        }

        private void ReplaceInitialChildText( XmlNode parent, string value ) {
            XmlNode n = parent.FirstChild;

            // don't consider whitespace when replacing initial text
            while ( n != null && n.NodeType == XmlNodeType.Whitespace )
                n = n.NextSibling;

            if ( n != null ) {
                if ( n.NodeType == XmlNodeType.Text ) 
                    n.Value = value;
                else 
                    n = parent.InsertBefore( CreateTextNode( value ), n );
                RemoveInitialTextNodes( n.NextSibling );
            }
            else {
                parent.AppendChild( CreateTextNode( value ) );
            }
        }

        internal XmlNode SafeFirstChild( XmlNode n ) {
            XmlBoundElement be = n as XmlBoundElement;
            if ( be != null )
                return be.SafeFirstChild;
            else
                //other type of node should be already foliated.
                return n.FirstChild;
        }

        internal XmlNode SafeLastChild( XmlNode n ) {
            XmlBoundElement be = n as XmlBoundElement;
            if ( be != null )
                return be.SafeLastChild;
            else
                //other type of node should be already foliated.
                return n.LastChild;
        }

        internal XmlNode SafeNextSibling( XmlNode n ) {
            XmlBoundElement be = n as XmlBoundElement;
            if ( be != null )
                return be.SafeNextSibling;
            else
                //other type of node should be already foliated.
                return n.NextSibling;
        }

        internal XmlNode SafePreviousSibling( XmlNode n ) {
            XmlBoundElement be = n as XmlBoundElement;
            if ( be != null )
                return be.SafePreviousSibling;
            else
                //other type of node should be already foliated.
                return n.PreviousSibling;
        }

        internal static void SetRowValueToNull( DataRow row, DataColumn col ) {
            Debug.Assert( col.ColumnMapping != MappingType.Hidden );
            Debug.Assert( row.Table.DataSet.EnforceConstraints == false );

            // TODO: Are we guaranteed that row[ col ] will always return the same object as Convert.DBNull when the value is DB-null so we can do just an obj comparison ?
            if ( ! ( row.IsNull( col ) ) )
                row[ col ] = Convert.DBNull;
        }

        internal static void SetRowValueFromXmlText( DataRow row, DataColumn col, string xmlText ) {
            Debug.Assert( xmlText != null );
            Debug.Assert( row.Table.DataSet.EnforceConstraints == false );
            object oVal;
            try {
                oVal = col.ConvertXmlToObject( xmlText );
                // This func does not set the field value to null - call SetRowValueToNull in order to do so
                Debug.Assert( oVal != null && ! ( oVal is DBNull ) );
            }
            catch {
                // Catch data-type errors and set ROM to Unspecified value
                SetRowValueToNull( row, col );
                return;
            }

            if ( ! oVal.Equals( row[col] ) )
                row[ col ] = oVal;
        }

        private void SynchronizeRowFromRowElement( XmlBoundElement rowElement ) {
            SynchronizeRowFromRowElement( rowElement, null );
        }
        // Sync row fields w/ values from rowElem region.
        // If rowElemList is != null, all subregions of rowElem are appended to it.
        private void SynchronizeRowFromRowElement( XmlBoundElement rowElement, ArrayList rowElemList ) {
            DataRow row = rowElement.Row;
            Debug.Assert( row != null );

            // No synchronization needed for deleted rows
            if ( row.RowState == DataRowState.Deleted )
                return;

            row.BeginEdit();
#if DEBUG
            try {
#endif
                SynchronizeRowFromRowElementEx( rowElement, rowElemList );
#if DEBUG
            }
            catch {
                // We should not get any exceptions because we always handle data-type conversion
                Debug.Assert( false );
                throw;
            }
#endif
#if DEBUG
            try {
#endif
                row.EndEdit();
#if DEBUG
            }
            catch {
                // We should not get any exceptions because DataSet.EnforceConstraints should be always off
                // BUGBUG: Shouldn't we turn off DataSet.EnforceConstraints and do again an EndEdit ? If this is NOT the case we should do the try just in DEBUG
                Debug.Assert( false );
                throw;
            }
#endif
        }
        private void SynchronizeRowFromRowElementEx( XmlBoundElement rowElement, ArrayList rowElemList ) {
            Debug.Assert( rowElement != null );
            Debug.Assert( rowElement.Row != null );
            Debug.Assert( this.DataSet.EnforceConstraints == false );

            DataRow row = rowElement.Row;
            Debug.Assert( row != null );
            DataTable table = row.Table;

            // if not foliated, already synch'd
//            if ( !IsFoliated(rowElement) )
//                return;
            //Debug.Assert( IsFoliated(rowElement) ); // If foliated we should not get the event (should be handled directly by DataPointer)

            Hashtable foundColumns = new Hashtable();
            string xsi_attrVal = string.Empty;

            RegionIterator iter = new RegionIterator( rowElement );
            bool fMore;
            // If present, fill up the TextOnly column
            DataColumn column = GetTextOnlyColumn( row );
            if ( column != null ) {
                foundColumns[column] = column;
                string value;
                fMore = iter.NextInitialTextLikeNodes( out value );
                if ( value.Length == 0 && ( ( (xsi_attrVal = rowElement.GetAttribute(XSI_NIL) ) == "1" ) || xsi_attrVal == "true" ) )
                    row[column] = Convert.DBNull;
                else
                    SetRowValueFromXmlText( row, column, value );
            }
            else
                fMore = iter.Next();

            // Fill up the columns mapped to an element
            while ( fMore ) {
                XmlElement e = iter.CurrentNode as XmlElement;
                if ( e == null ) {
                    fMore = iter.Next();
                    continue;
                }

                XmlBoundElement be = e as XmlBoundElement;
                if ( be != null && be.Row != null ) {
                    if ( rowElemList != null )
                        rowElemList.Add( e );
                    // Skip over sub-regions
                    fMore = iter.NextRight();
                    continue;
                }

                DataColumn c = mapper.GetColumnSchemaForNode( rowElement, e );
                if ( c != null ) {
                    Debug.Assert( c.Table == row.Table );
                    if ( foundColumns[c] == null ) {
                        foundColumns[c] = c;
                        string value;
                        fMore = iter.NextInitialTextLikeNodes( out value );
                        if ( value.Length == 0 && ( ( (xsi_attrVal = e.GetAttribute(XSI_NIL) ) == "1" ) || xsi_attrVal == "true" ) )
                            row[c] = Convert.DBNull;
                        else
                            SetRowValueFromXmlText( row, c, value );
                        continue;
                    }
                }

                fMore = iter.Next();
            }

            //
            // Walk the attributes to find attributes that map to columns.
            //
            foreach( XmlAttribute attr in rowElement.Attributes ) {
                DataColumn c = mapper.GetColumnSchemaForNode( rowElement, attr );

                if ( c != null ) {
                    if ( foundColumns[c] == null ) {
                        foundColumns[c] = c;
                        SetRowValueFromXmlText( row, c, attr.Value );
                    }
                }
            }

            // Null all columns values that aren't represented in the tree
            foreach( DataColumn c in row.Table.Columns ) {
                if ( foundColumns[c] == null && !IsNotMapped(c) ) {
                    if (!c.AutoIncrement)
                        SetRowValueToNull( row, c );
                    else
                        c.Init(row.tempRecord);
                }
            }
        }

        private void UpdateAllColumns( DataRow row, XmlBoundElement rowElement ) {
            foreach( DataColumn c in row.Table.Columns ) {
                OnColumnValueChanged( row, c, rowElement );
            }
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.XmlDataDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlDataDocument class.
        ///    </para>
        /// </devdoc>
        public XmlDataDocument(): base(new XmlDataImplementation()) {
            Init();
            AttachDataSet( new DataSet() );
            this.dataSet.EnforceConstraints = false;
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.XmlDataDocument1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlDataDocument class with the specified
        ///       DataSet.
        ///    </para>
        /// </devdoc>
        public XmlDataDocument( DataSet dataset ): base(new XmlDataImplementation()) {            
            Init( dataset );
        }

        internal XmlDataDocument( XmlImplementation imp ) : base( imp ) {
        }

        private void Init() {
            this.pointers = new Hashtable();
            this.countAddPointer = 0;
            this.columnChangeList = new ArrayList();
            this.ignoreDataSetEvents = false;
            this.isFoliationEnabled = true;
            this.optimizeStorage = true;
            this.fDataRowCreatedSpecial = false;
            autoFoliationState = ElementState.StrongFoliation;
            fAssociateDataRow = true; //this needs to be true for newly created elements should have associated datarows
            mapper = new DataSetMapper();
            this.foliationLock = new object();
            this.ignoreXmlEvents = true;
            this.attrXml = CreateAttribute( "xmlns", "xml", XPathNodePointer.s_strReservedXmlns );
            this.attrXml.Value = XPathNodePointer.s_strReservedXml;
            this.ignoreXmlEvents = false;
        }

        private void Init( DataSet ds ) {
            if ( ds == null )
                throw new ArgumentException(Res.GetString(Res.DataDom_DataSetNull));
            Init();
            if ( ds.FBoundToDocument )
                throw new ArgumentException( Res.GetString(Res.DataDom_MultipleDataSet) );
            ds.FBoundToDocument = true;
            this.dataSet = ds;
            Bind(true);
        }

        private bool IsConnected( XmlNode node ) {
            while ( true ) {
                if ( node == null )
                    return false;
                if ( node == this )
                    return true;

                XmlAttribute attr = node as XmlAttribute;
                if ( attr != null )
                    node = attr.OwnerElement;
                else
                    node = node.ParentNode;
            }
        }
        private bool IsRowLive( DataRow row ) {
            return ( row.RowState & ( DataRowState.Added | DataRowState.Unchanged | DataRowState.Modified ) ) != 0;
        }
        private static void SetNestedParentRow( DataRow childRow, DataRow parentRow ) {
            DataRelation rel = GetNestedParentRelation( childRow );
            //we should not set this row's parentRow if the table doesn't match.
            if ( rel != null ) {
                if ( parentRow == null || rel.ParentKey.Table != parentRow.Table )
                    childRow.SetParentRow( null, rel );
                else
                   childRow.SetParentRow( parentRow, rel );
            }
        }

        // A node (node) was inserted into the main tree (connected) from oldParent==null state
        private void OnNodeInsertedInTree( XmlNode node ) {
            XmlBoundElement be;
            ArrayList rowElemList = new ArrayList();
            if ( mapper.GetRegion( node, out be ) ) {
                // TODO: Rethink this so it will be just one subRegion Object list shared accross all functions
                if ( be == node ) {
                    OnRowElementInsertedInTree( be, rowElemList );
                }
                else {
                    OnNonRowElementInsertedInTree( node, be, rowElemList );
                }
            }
            else {
                // We only need to sync the embedded sub-regions
                TreeIterator iter = new TreeIterator( node );
                for (bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRightRowElement() )
                    rowElemList.Add( iter.CurrentNode );
            }

            // Process subregions, so they make transition from disconnected to connected tree
            while ( rowElemList.Count > 0 ) {
                Debug.Assert(rowElemList[0] != null && rowElemList[0] is XmlBoundElement);
                XmlBoundElement subRowElem = (XmlBoundElement)(rowElemList[0]);
                rowElemList.RemoveAt( 0 );
                // Expect rowElem to have a DataTable schema, since it is a sub-region
                Debug.Assert( subRowElem != null );
                OnRowElementInsertedInTree( subRowElem, rowElemList );
            }

            // Assert that all sub-regions are assoc w/ "live" rows
            AssertLiveRows( node );
        }
        // "node" was inserting into a disconnected tree from oldParent==null state
        private void OnNodeInsertedInFragment( XmlNode node ) {
            XmlBoundElement be;
            if ( mapper.GetRegion( node, out be ) ) {
                if ( be == node ) {
                    Debug.Assert( ! IsRowLive( be.Row ) );
                    SetNestedParentRegion( be );
                }
                else {
                    ArrayList rowElemList = new ArrayList();
                    OnNonRowElementInsertedInFragment( node, be, rowElemList );
                    // Set nested parent for the 1st level subregions (they should already be associated w/ Deleted or Detached rows)
                    while ( rowElemList.Count > 0 ) {
                        Debug.Assert(rowElemList[0] != null && rowElemList[0] is XmlBoundElement);
                        XmlBoundElement subRowElem = (XmlBoundElement)(rowElemList[0]);
                        rowElemList.RemoveAt( 0 );
                        SetNestedParentRegion( subRowElem, be );
                    }
                }

                // Check to make sure all sub-regions are disconnected
                AssertNonLiveRows( node );

                return;
            }

            // Nothing to do, since the node belongs to no region

            // Check to make sure all sub-regions are disconnected
            AssertNonLiveRows( node );
        }

        // A row-elem was inserted into the connected tree (connected) from oldParent==null state
        private void OnRowElementInsertedInTree( XmlBoundElement rowElem, ArrayList rowElemList ) {
            Debug.Assert( rowElem.Row != null );

            DataRow row = rowElem.Row;
            DataRowState rowState = row.RowState;

            switch( rowState ) {
            case DataRowState.Detached:
#if DEBUG
                try {
                    Debug.Assert( row.Table.DataSet.EnforceConstraints == false );
#endif
                    row.Table.Rows.Add( row );
                    SetNestedParentRegion( rowElem );
#if DEBUG
                }
                catch {
                    // We should not get any exceptions here
                    Debug.Assert( false );
                    throw;
                }
#endif
                // Add all sub-regions to the list if the caller needs this
                if ( rowElemList != null ) {
                    RegionIterator iter = new RegionIterator( rowElem );
                    for (bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRightRowElement() )
                        rowElemList.Add( iter.CurrentNode );
                }
                break;
            case DataRowState.Deleted:
#if DEBUG
                try {
                    Debug.Assert( row.Table.DataSet.EnforceConstraints == false );
#endif
                    // Change the row status to be alive (unchanged)
                    row.RejectChanges();
                    // Set ROM from XML
                    SynchronizeRowFromRowElement( rowElem, rowElemList );
                    // Set nested parent data row according to where is the row positioned in the tree
                    SetNestedParentRegion( rowElem );
#if DEBUG
                }
                catch {
                    // We should not get any exceptions here
                    Debug.Assert( false );
                    throw;
                }
#endif
                break;
            default:
                // Handle your case above
                // TODO: When we will have a Move event, we should handle above all other cases, since there is no guarnatee that Inserted event will have oldParent == null
                Debug.Assert( false );
                break;
            }
            Debug.Assert( IsRowLive( rowElem.Row ) );
        }

        // Disconnect the DataRow associated w/ the rowElem region
        private void EnsureDisconnectedDataRow( XmlBoundElement rowElem ) {
            Debug.Assert( rowElem.Row != null );

            DataRow row = rowElem.Row;
            DataRowState rowState = row.RowState;

            switch( rowState ) {
            case DataRowState.Detached:
#if DEBUG
                try {
                    Debug.Assert( row.Table.DataSet.EnforceConstraints == false );
#endif
                    SetNestedParentRegion( rowElem );
#if DEBUG
                }
                catch {
                    // We should not get any exceptions here
                    Debug.Assert( false );
                    throw;
                }
#endif
                break;

            case DataRowState.Deleted:
                // Nothing to do: moving a region associated w/ a deleted row to another disconnected tree is a NO-OP.
                break;

            case DataRowState.Unchanged:
            case DataRowState.Modified:
                EnsureFoliation( rowElem, ElementState.WeakFoliation );
                row.Delete();
                break;

            case DataRowState.Added:
                EnsureFoliation( rowElem, ElementState.WeakFoliation );
                row.Delete();
                SetNestedParentRegion( rowElem );
                break;

            default:
                // Handle your case above
                // TODO: When we will have a Move event, we should handle above all other cases, since there is no guarnatee that Inserted event will have oldParent == null
                Debug.Assert( false );
                break;
            }

            Debug.Assert( ! IsRowLive( rowElem.Row ) );
        }


        // A non-row-elem was inserted into the connected tree (connected) from oldParent==null state
        private void OnNonRowElementInsertedInTree( XmlNode node, XmlBoundElement rowElement, ArrayList rowElemList ) {
            // non-row-elem is beeing inserted
            DataRow row = rowElement.Row;
            // Region should already have an associated data row (otherwise how was the original row-elem inserted ?)
            Debug.Assert( row != null );
            SynchronizeRowFromRowElement( rowElement );
            if ( rowElemList != null ) {
                TreeIterator iter = new TreeIterator( node );
                for (bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRightRowElement() )
                    rowElemList.Add( iter.CurrentNode );
            }
        }

        // A non-row-elem was inserted into disconnected tree (fragment) from oldParent==null state (i.e. was disconnected)
        private void OnNonRowElementInsertedInFragment( XmlNode node, XmlBoundElement rowElement, ArrayList rowElemList ) {
            // non-row-elem is beeing inserted
            DataRow row = rowElement.Row;
            // Region should already have an associated data row (otherwise how was the original row-elem inserted ?)
            Debug.Assert( row != null );
            // Since oldParent == null, the only 2 row states should have been Detached or Deleted
            Debug.Assert( row.RowState == DataRowState.Detached || row.RowState == DataRowState.Deleted );

            if ( row.RowState == DataRowState.Detached )
                SynchronizeRowFromRowElementEx( rowElement, rowElemList );
            // Nothing to do if the row is deleted (there is no sync-ing from XML to ROM for deleted rows)
        }

        private void SetNestedParentRegion( XmlBoundElement childRowElem ) {
            Debug.Assert( childRowElem.Row != null );

            XmlBoundElement parentRowElem;
            mapper.GetRegion( childRowElem.ParentNode, out parentRowElem );
            SetNestedParentRegion( childRowElem, parentRowElem );
        }
        private void SetNestedParentRegion( XmlBoundElement childRowElem, XmlBoundElement parentRowElem ) {
            DataRow childRow = childRowElem.Row;
            if ( parentRowElem == null ) {
                SetNestedParentRow( childRow, null );
                return;
            }

            DataRow parentRow = parentRowElem.Row;
            Debug.Assert( parentRow != null );
            // We should set it only if there is a nested relationship between this child and parent regions
            if ( (childRow.Table.nestedParentRelation != null) && childRow.Table.nestedParentRelation.ParentTable == parentRow.Table )
                // BUGBUG: We should set only the nested relationship, not all relationships
                SetNestedParentRow( childRow, parentRow );
            else
                SetNestedParentRow( childRow, null );
        }

        internal static bool IsTextNode( XmlNodeType nt ) {
            switch( nt ) {
                case XmlNodeType.Text:
                case XmlNodeType.CDATA:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    return true;
                default:
                    return false;
            }
        }

        /*
        internal static bool IsWhiteSpace(char ch) {
            switch ( ch ) {
                case '\u0009' :
                case '\u000a' :
                case '\u000d' :
                case '\u0020' :
                    return true;
                default :
                    return false;
            }
        }
        
        internal static bool IsOnlyWhitespace( string str ) {
            if (str != null) {
                for (int index = 0; index < str.Length; index ++) {
                    if (! IsWhiteSpace(str[index]))
                        return false;
                }
            }
            return true;
        }
        */
        
        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.CreateNavigator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override XPathNavigator CreateNavigator(XmlNode node) {
            Debug.Assert( node.OwnerDocument == this || node == this );
            if ( XPathNodePointer.xmlNodeType_To_XpathNodeType_Map[(int)(node.NodeType)] == -1 )
                return null;
            if ( IsTextNode( node.NodeType ) ) {
                XmlNode parent = node.ParentNode;
                if ( parent != null && parent.NodeType == XmlNodeType.Attribute )
                    return null;
                else {
#if DEBUG
                    //if current node is a text node, its parent node has to be foliated
                    XmlBoundElement be = node.ParentNode as XmlBoundElement;
                    if ( be != null )
                        Debug.Assert( be.IsFoliated );
#endif
                    XmlNode prevSib = node.PreviousSibling;
                    while ( prevSib != null && IsTextNode( prevSib.NodeType ) ) {
                        node = prevSib;
                        prevSib = SafePreviousSibling( node );
                    }
                }
            }
            return new DataDocumentXPathNavigator( this, node );
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void AssertLiveRows( XmlNode node ) {
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;
            try {
                XmlBoundElement rowElement = node as XmlBoundElement;
                if ( rowElement != null && rowElement.Row != null )
                    Debug.Assert( IsRowLive( rowElement.Row ) );
                TreeIterator iter = new TreeIterator( node );
                for (bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRowElement() ) {
                    rowElement = iter.CurrentNode as XmlBoundElement;
                    Debug.Assert( rowElement.Row != null );
                    Debug.Assert( IsRowLive( rowElement.Row ) );
                }
            }
            finally {
                IsFoliationEnabled = wasFoliationEnabled;
            }
        }
        [System.Diagnostics.Conditional("DEBUG")]
        private void AssertNonLiveRows( XmlNode node ) {
            bool wasFoliationEnabled = IsFoliationEnabled;
            IsFoliationEnabled = false;
            try {
                XmlBoundElement rowElement = node as XmlBoundElement;
                if ( rowElement != null && rowElement.Row != null )
                    Debug.Assert( ! IsRowLive( rowElement.Row ) );
                TreeIterator iter = new TreeIterator( node );
                for (bool fMore = iter.NextRowElement(); fMore; fMore = iter.NextRowElement() ) {
                    rowElement = iter.CurrentNode as XmlBoundElement;
                    Debug.Assert( rowElement.Row != null );
                    Debug.Assert( ! IsRowLive( rowElement.Row ) );
                }
            }
            finally {
                IsFoliationEnabled = wasFoliationEnabled;
            }
        }

        /// <include file='doc\XmlDataDocument.uex' path='docs/doc[@for="XmlDataDocument.GetElementById"]/*' />
        public override XmlElement GetElementById( string elemId ) {
            throw new NotSupportedException( Res.GetString( Res.DataDom_NotSupport_GetElementById ) );
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\treeiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TreeIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.Data;
    using System.Diagnostics;

    // Iterates over non-attribute nodes
    internal class TreeIterator : BaseTreeIterator {
        private XmlNode         nodeTop;
        private XmlNode         currentNode;

        internal TreeIterator( XmlNode nodeTop ) : base( ((XmlDataDocument)(nodeTop.OwnerDocument)).Mapper ) {
            Debug.Assert( nodeTop != null );
            this.nodeTop     = nodeTop;
            this.currentNode = nodeTop;
        }

        internal override void Reset() {
            currentNode = nodeTop;
        }

        internal override XmlNode CurrentNode {
            get {
                return currentNode;
            }
        }

        internal override bool Next() {
            XmlNode nextNode;

            // Try to move to the first child
            nextNode = currentNode.FirstChild;

            // No children, try next sibling
            if ( nextNode != null ) {
                currentNode = nextNode;
                return true;
            }
            return NextRight();
        }

        internal override bool NextRight() {
            // Make sure we do not get past the nodeTop if we call NextRight on a just initialized iterator and nodeTop has no children
            if ( currentNode == nodeTop ) {
                currentNode = null;
                return false;
            }

            XmlNode nextNode = currentNode.NextSibling;

            if ( nextNode != null ) {
                currentNode = nextNode;
                return true;
            }

            // No next sibling, try the first sibling of from the parent chain
            nextNode = currentNode;
            while ( nextNode != nodeTop && nextNode.NextSibling == null )
                nextNode = nextNode.ParentNode;

            if ( nextNode == nodeTop ) {
                currentNode = null;
                return false;
            }

            currentNode = nextNode.NextSibling;
            Debug.Assert( currentNode != null );
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\regioniterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegionIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RegionIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.Data;
    using System.Diagnostics;
    using System.Text;


    internal abstract class BaseRegionIterator : BaseTreeIterator {
        internal BaseRegionIterator( DataSetMapper mapper ) : base( mapper ) {
        }

    }


    // Iterates over non-attribute nodes
    internal class RegionIterator : BaseRegionIterator {
        private XmlBoundElement rowElement;
        private XmlNode         currentNode;

        internal RegionIterator( XmlBoundElement rowElement ) : base( ((XmlDataDocument)(rowElement.OwnerDocument)).Mapper ) {
            Debug.Assert( rowElement != null && rowElement.Row != null );
            this.rowElement  = rowElement;
            this.currentNode = rowElement;
        }

        internal override void Reset() {
            currentNode = rowElement;
        }

        internal override XmlNode CurrentNode {
            get {
                return currentNode;
            }
        }

        internal override bool Next() {
            XmlNode nextNode;
            ElementState oldState = rowElement.ElementState;
            // We do not want to cause any foliation w/ this iterator or use this iterator once the region was defoliated
            Debug.Assert( oldState != ElementState.None );

            // Try to move to the first child
            nextNode = currentNode.FirstChild;

            // No children, try next sibling
            if ( nextNode != null ) {
                currentNode = nextNode;
                // If we have been defoliated, we should have stayed that way
                Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
                // Rollback foliation
                rowElement.ElementState = oldState;
                return true;
            }
            return NextRight();
        }

        internal override bool NextRight() {
            // Make sure we do not get past the rowElement if we call NextRight on a just initialized iterator and rowElement has no children
            if ( currentNode == rowElement ) {
                currentNode = null;
                return false;
            }

            ElementState oldState = rowElement.ElementState;
            // We do not want to cause any foliation w/ this iterator or use this iterator once the region was defoliated
            Debug.Assert( oldState != ElementState.None );

            XmlNode nextNode = currentNode.NextSibling;

            if ( nextNode != null ) {
                currentNode = nextNode;
                // If we have been defoliated, we should have stayed that way
                Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
                // Rollback foliation
                rowElement.ElementState = oldState;
                return true;
            }

            // No next sibling, try the first sibling of from the parent chain
            nextNode = currentNode;
            while ( nextNode != rowElement && nextNode.NextSibling == null )
                nextNode = nextNode.ParentNode;

            if ( nextNode == rowElement ) {
                currentNode = null;
                // If we have been defoliated, we should have stayed that way
                Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
                // Rollback foliation
                rowElement.ElementState = oldState;
                return false;
            }

            currentNode = nextNode.NextSibling;
            Debug.Assert( currentNode != null );
            // If we have been defoliated, we should have stayed that way
            Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
            // Rollback foliation
            rowElement.ElementState = oldState;
            return true;
        }

        // Get the initial text value for the current node. You should be positioned on the node (element) for
        // which to get the initial text value, not on the text node.
        internal bool NextInitialTextLikeNodes( out String value ) {
            Debug.Assert( this.CurrentNode != null );
            Debug.Assert( this.CurrentNode.NodeType == XmlNodeType.Element );
#if DEBUG
            // It's not OK to try to read the initial text value for sub-regions, because we do not know how to revert their initial state
            if ( this.CurrentNode.NodeType == XmlNodeType.Element && mapper.GetTableSchemaForElement( (XmlElement)(this.CurrentNode) ) != null ) {
                if ( this.CurrentNode != rowElement )
                    Debug.Assert( false );
            }
#endif

            ElementState oldState = rowElement.ElementState;
            // We do not want to cause any foliation w/ this iterator or use this iterator once the region was defoliated
            Debug.Assert( oldState != ElementState.None );

            XmlNode n = this.CurrentNode.FirstChild;
            value = GetInitialTextFromNodes( ref n );
            if ( n == null ) {
                // If we have been defoliated, we should have stayed that way
                Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
                // Rollback eventual foliation
                rowElement.ElementState = oldState;
                return NextRight();
            }
            Debug.Assert( ! XmlDataDocument.IsTextLikeNode( n ) );
            currentNode = n;
            // If we have been defoliated, we should have stayed that way
            Debug.Assert( (oldState == ElementState.Defoliated) ? (rowElement.ElementState == ElementState.Defoliated) : true );
            // Rollback eventual foliation
            rowElement.ElementState = oldState;
            return true;
        }

        private static string GetInitialTextFromNodes( ref XmlNode n ) {
            string value = null;

            if ( n != null ) {
                // don't consider whitespace
                while ( n.NodeType == XmlNodeType.Whitespace ) {
                    n = n.NextSibling;
                    if ( n == null )
                        return String.Empty;
                }

                if ( XmlDataDocument.IsTextLikeNode( n ) && (n.NextSibling == null || ! XmlDataDocument.IsTextLikeNode( n.NextSibling )) ) {
                    // don't use string builder if only one text node exists
                    value = n.Value;
                    n = n.NextSibling;
                }
                else {
                    StringBuilder sb = new StringBuilder();
                    while ( n != null && XmlDataDocument.IsTextLikeNode( n ) ) {
                        // Ignore non-significant whitespace nodes
                        if ( n.NodeType != XmlNodeType.Whitespace )
                            sb.Append( n.Value );
                        n = n.NextSibling;
                    }
                    value = sb.ToString();
                }
            }

            if ( value == null )
                value = String.Empty;

            return value;
        }


        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\datasetmappper.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSetMappper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DataSetMappper.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {

    using System;
    using System.Collections;
    using System.Data;
    using System.Diagnostics;


    //
    // Maps XML nodes to schema
    //
    // With the exception of some functions (the most important is SearchMatchingTableSchema) all functions expect that each region rowElem is already associated
    // w/ it's DataRow (bassically the test to determine a rowElem is based on a != null associated DataRow). As a result of this, some functions will NOT work properly
    // when they are used on a tree for which rowElem's are not associated w/ a DataRow.
    //
    
    internal class DataSetMapper {
        Hashtable tableSchemaMap;   // maps an string (currently this is localName:nsURI) to a DataTable. Used to quickly find if a bound-elem matches any data-table metadata..
        Hashtable columnSchemaMap;  // maps a string (table localName:nsURI) to a Hashtable. The 2nd hastable (the one that is stored as data in columnSchemaMap, maps a string to a DataColumn.

        XmlDataDocument doc;        // The document this mapper is related to
        DataSet   dataSet;          // The dataset this mapper is related to
        internal const string strReservedXmlns = "http://www.w3.org/2000/xmlns/";


        internal DataSetMapper() {
            Debug.Assert( this.dataSet == null );
            this.tableSchemaMap = new Hashtable();
            this.columnSchemaMap = new Hashtable();
        }

        internal void SetupMapping( XmlDataDocument xd, DataSet ds ) {
            // If are already mapped, forget about our current mapping and re-do it again.
            if ( IsMapped() ) {
                this.tableSchemaMap = new Hashtable();
                this.columnSchemaMap = new Hashtable();
            }
            doc = xd;
            dataSet = ds;
            foreach( DataTable t in dataSet.Tables ) {
                AddTableSchema( t );

                foreach( DataColumn c in t.Columns ) {
                    // don't include auto-generated PK & FK to be part of mapping
                    if ( ! IsNotMapped(c) ) {
                        AddColumnSchema( c );
                    }
                }
            }
        }

        internal bool IsMapped() {
            return dataSet != null;
        }

        internal DataTable SearchMatchingTableSchema( string localName, string namespaceURI ) {
            object tid = GetIdentity( localName, namespaceURI );
            return (DataTable)(tableSchemaMap[ tid ]);
            
        }
        // SearchMatchingTableSchema function works only when the elem has not been bound to a DataRow. If you want to get the table associated w/ an element after 
        // it has been associated w/ a DataRow use GetTableSchemaForElement function.
        // rowElem is the parent region rowElem or null if there is no parent region (in case elem is a row elem, then rowElem will be the parent region; if elem is not
        //    mapped to a DataRow, then rowElem is the region elem is part of)
        //
        // Those are the rules for determing if elem is a row element:
        //  1. node is an element (already meet, since elem is of type XmlElement)
        //  2. If the node is already associated w/ a DataRow, then the node is a row element - not applicable, b/c this function is intended to be called on a
        //    to find out if the node s/b associated w/ a DataRow (see XmlDataDocument.LoadRows)
        //  3. If the node localName/ns matches a DataTable then
        //      3.1 Take the parent region DataTable (in our case rowElem.Row.DataTable)
        //          3.2 If no parent region, then the node is associated w/ a DataTable
        //          3.3 If there is a parent region
        //              3.3.1 If the node has no elem children and no attr other than namespace declaration, and the node can match
        //                  a column from the parent region table, then the node is NOT associated w/ a DataTable (it is a potential DataColumn in the parent region)
        //              3.3.2 Else the node is a row-element (and associated w/ a DataTable / DataRow )
        //
        internal DataTable SearchMatchingTableSchema( XmlBoundElement rowElem, XmlBoundElement elem ) {
            Debug.Assert( elem != null );

            DataTable t = SearchMatchingTableSchema( elem.LocalName, elem.NamespaceURI );
            if ( t == null )
                return null;

            if ( rowElem == null )
                return t;
            // Currently we expect we map things from top of the tree to the bottom
            Debug.Assert( rowElem.Row != null );

            DataColumn col = GetColumnSchemaForNode( rowElem, elem );
            if ( col == null )
                return t;

            foreach ( XmlAttribute a in elem.Attributes ) {
#if DEBUG
                // Some sanity check to catch errors like namespace attributes have the right localName/namespace value, but a wrong atomized namespace value
                if ( a.LocalName == "xmlns" ) {
                    Debug.Assert( a.Prefix == String.Empty );
                    Debug.Assert( (object)a.NamespaceURI == (object)strReservedXmlns );
                }
                if ( a.Prefix == "xmlns" ) {
                    Debug.Assert( (object)a.NamespaceURI == (object)strReservedXmlns );
                }
                if ( a.NamespaceURI == strReservedXmlns )
                    Debug.Assert( (object)a.NamespaceURI == (object)strReservedXmlns );
#endif
                // No namespace attribute found, so elem cannot be a potential DataColumn, therefore is a row-elem
                if ( (object)(a.NamespaceURI) != (object)strReservedXmlns )
                    return t;
            }

            for ( XmlNode n = elem.FirstChild; n != null; n = n.NextSibling ) {
                if ( n.NodeType == XmlNodeType.Element ) {
                    // elem has an element child, so elem cannot be a potential DataColumn, therefore is a row-elem
                    return t;
                }
            }
            // Node is a potential DataColumn in rowElem region
            return null;
        }

        internal DataColumn GetColumnSchemaForNode( XmlBoundElement rowElem, XmlNode node ) {
            // TODO: Optimize this function by specializing it for XmlElement, XmlAttribute and anything else
            Debug.Assert( rowElem != null );
            // The caller must make sure that node is not a row-element
            Debug.Assert( (node is XmlBoundElement) ? ((XmlBoundElement)node).Row == null : true );

            object tid = GetIdentity( rowElem.LocalName, rowElem.NamespaceURI );
            object cid = GetIdentity( node.LocalName, node.NamespaceURI );

            Hashtable columns = (Hashtable) columnSchemaMap[ tid ];
            if ( columns != null ) {
                DataColumn col = (DataColumn)(columns[ cid ]);
                if ( col == null )
                    return null;

                MappingType mt = col.ColumnMapping;

                if ( node.NodeType == XmlNodeType.Attribute && mt == MappingType.Attribute )
                    return col;
                if ( node.NodeType == XmlNodeType.Element && mt == MappingType.Element )
                    return col;
                // node's (localName, ns) matches a column, but the MappingType is different (i.e. node is elem, MT is attr)
                return null;
            }
            return null;
        }
        internal DataTable GetTableSchemaForElement( XmlElement elem ) {
            //TODO: Create an overridable that takes an XmlBoundElement.
            XmlBoundElement be = elem as XmlBoundElement;
            if ( be == null )
                return null;

            return GetTableSchemaForElement( be );
        }

        internal DataTable GetTableSchemaForElement( XmlBoundElement be ) {
            // if bound to a row, must be a table.
            DataRow row = be.Row;
            if ( row != null )
                return row.Table;

            return null;
        }

        internal static bool IsNotMapped( DataColumn c ) {
            return c.ColumnMapping == MappingType.Hidden;
        }

        // ATTENTION: GetRowFromElement( XmlElement ) and GetRowFromElement( XmlBoundElement ) should have the same functionality and side effects. 
        // See this code fragment for why:
        //     XmlBoundElement be = ...;
        //     XmlElement e = be;
        //     GetRowFromElement( be ); // Calls GetRowFromElement( XmlBoundElement )
        //     GetRowFromElement( e );  // Calls GetRowFromElement( XmlElement ), in spite of e beeing an instance of XmlBoundElement
        internal DataRow GetRowFromElement( XmlElement e ) {
            XmlBoundElement be = e as XmlBoundElement;
            if ( be != null )
                return be.Row;
            return null;
        }
        internal DataRow GetRowFromElement( XmlBoundElement be ) {
            return be.Row;
        }

        // Get the row-elem associatd w/ the region node is in.
        // If node is in a region not mapped (like document element node) the function returns false and sets elem to null)
        // This function does not work if the region is not associated w/ a DataRow (it uses DataRow association to know what is the row element associated w/ the region)
        internal bool GetRegion( XmlNode node, out XmlBoundElement rowElem ) {
            while ( node != null ) {
                XmlBoundElement be = node as XmlBoundElement;
                // Break if found a region
                if ( be != null && GetRowFromElement( be ) != null ) {
                    rowElem = be;
                    return true;
                }

                if ( node.NodeType == XmlNodeType.Attribute )
                    node = ((XmlAttribute)node).OwnerElement;
                else
                    node = node.ParentNode;
            }

            rowElem = null;
            return false;
        }

        internal bool IsRegionRadical( XmlBoundElement rowElem ) {
            // You must pass a row element (which s/b associated w/ a DataRow)
            Debug.Assert( rowElem.Row != null );

            if ( rowElem.ElementState == ElementState.Defoliated )
                return true;

            DataTable table = GetTableSchemaForElement( rowElem );
            DataColumnCollection columns = table.Columns;
            int iColumn = 0;

            // check column attributes...
            int cAttrs = rowElem.Attributes.Count;
            for ( int iAttr = 0; iAttr < cAttrs; iAttr++ ) {
                XmlAttribute attr = rowElem.Attributes[iAttr];

                // only specified attributes are radical
                if ( !attr.Specified )
                    return false;

                // only mapped attrs are valid
                DataColumn schema = GetColumnSchemaForNode( rowElem, attr );
                if ( schema == null ) {
                    //Console.WriteLine("Region has unmapped attribute");
                    return false;
                }

                // check to see if column is in order
                if ( !IsNextColumn( columns, ref iColumn, schema ) ) {
                    //Console.WriteLine("Region has attribute columns out of order or duplicate");
                    return false;
                }

                // must have exactly one text node (XmlNodeType.Text) child
                // BUGBUG: We should also check that a round trip trough ROM yields back the same value
                XmlNode fc = attr.FirstChild;
                if ( fc == null || fc.NodeType != XmlNodeType.Text || fc.NextSibling != null ) {
                    //Console.WriteLine("column element has other than a single child text node");
                    return false;
                }
            }

            // check column elements
            iColumn = 0;
            XmlNode n = rowElem.FirstChild;
            for ( ; n != null; n = n.NextSibling ) {
                // only elements can exist in radically structured data
                if ( n.NodeType != XmlNodeType.Element ) {
                    //Console.WriteLine("Region has non-element child");
                    return false;
                }
                XmlElement e = n as XmlElement;

                // only checking for column mappings in this loop
                if ( GetRowFromElement( e ) != null )
                    break;

                // element's must have schema to be radically structured
                DataColumn schema = GetColumnSchemaForNode( rowElem, e );
                if ( schema == null ) {
                    //Console.WriteLine("Region has unmapped child element");
                    return false;
                }

                // check to see if column is in order
                if ( !IsNextColumn( columns, ref iColumn, schema ) ) {
                    //Console.WriteLine("Region has element columns out of order or duplicate");
                    return false;
                }

                // must have no attributes
                if ( e.HasAttributes )
                    return false;

                // must have exactly one text node child
                XmlNode fc = e.FirstChild;
                if ( fc == null || fc.NodeType != XmlNodeType.Text || fc.NextSibling != null ) {
                    //Console.WriteLine("column element has other than a single child text node");
                    return false;
                }
            }

            // check for remaining sub-regions
            for (; n != null; n = n.NextSibling ) {
                // only elements can exist in radically structured data
                if ( n.NodeType != XmlNodeType.Element ) {
                    //Console.WriteLine("Region has non-element child");
                    return false;
                }

                // element's must be regions in order to be radially structured
                DataRow row = GetRowFromElement( (XmlElement)n );
                if ( row == null ) {
                    //Console.WriteLine("Region has unmapped element");
                    return false;
                }
            }

            return true;
        }

        private void AddTableSchema( DataTable table ) {
            object idTable = GetIdentity( table.EncodedTableName, table.Namespace );
            tableSchemaMap[ idTable ] = table;
        }
        private void AddColumnSchema( DataColumn col ) {
            DataTable table = col.Table;
            object idTable = GetIdentity( table.EncodedTableName, table.Namespace );
            object idColumn = GetIdentity( col.EncodedColumnName, col.Namespace );

            Hashtable columns = (Hashtable) columnSchemaMap[ idTable ];
            if ( columns == null ) {
                columns = new Hashtable();
                columnSchemaMap[ idTable ] = columns;
            }
            columns[ idColumn ] = col;
        }
        private static object GetIdentity( string localName, string namespaceURI ) {
            // we need access to XmlName to make this faster
            return localName+":"+namespaceURI;
        }

        private bool IsNextColumn( DataColumnCollection columns, ref int iColumn, DataColumn col ) {
            for ( ; iColumn < columns.Count; iColumn++ ) {
                if ( columns[iColumn] == col ) {
                    iColumn++; // advance before we return...
                    return true;
                }
            }

            return false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\xmldataimplementation.cs ===
/*
* 
* Copyright (c) 2000 Microsoft Corporation. All rights reserved.
* 
*/

namespace System.Xml {
    using System;

    internal class XmlDataImplementation : XmlImplementation {
        
        public XmlDataImplementation() : base() {
        }
        
        public override XmlDocument CreateDocument() {
            return new XmlDataDocument( this );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\xpathnodepointer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNodePointer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNodePointer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.IO;
    using System.Data;
    using System.Collections;
    using System.Text;
    using System.Diagnostics;
    using System.Xml.XPath;
  
    internal class XPathNodePointer : IXmlDataVirtualNode {
        private WeakReference _owner;  // Owner of this pointer (an DataDocumentXPathNavigator). When the associated DataDocumentXPathNavigator (the owner) goes away, this XPathNodePointer can go away as well.
        private XmlDataDocument _doc;
        private XmlNode _node;
        private DataColumn _column;
        private bool _fOnValue;
        internal XmlBoundElement _parentOfNS;
        internal static int[] xmlNodeType_To_XpathNodeType_Map;
        internal static string s_strReservedXmlns = "http://www.w3.org/2000/xmlns/";
        internal static string s_strReservedXml = "http://www.w3.org/XML/1998/namespace";
        internal static string s_strXmlNS = "xmlns";
        private bool _bNeedFoliate;

        static XPathNodePointer(){
#if DEBUG
            int max=0, tempVal=0;            
            Array enumValues = Enum.GetValues(typeof(XmlNodeType));
            for ( int i = 0; i < enumValues.Length; i++) {
                tempVal = (int)enumValues.GetValue(i);
                if ( tempVal > max )
                    max = tempVal;
            }
            Debug.Assert( max == (int) XmlNodeType.XmlDeclaration );
#endif        
            xmlNodeType_To_XpathNodeType_Map = new int[20];
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.None)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Element)] = (int)XPathNodeType.Element;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Attribute)] = (int)XPathNodeType.Attribute;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Text)] = (int)XPathNodeType.Text;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.CDATA)] = (int)XPathNodeType.Text;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.EntityReference)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Entity)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.ProcessingInstruction)] = (int)XPathNodeType.ProcessingInstruction;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Comment)] = (int)XPathNodeType.Comment;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Document)] = (int)XPathNodeType.Root;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.DocumentType)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.DocumentFragment)] = (int)XPathNodeType.Root;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Notation)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.Whitespace)] = (int)XPathNodeType.Whitespace;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.SignificantWhitespace)] = (int)XPathNodeType.SignificantWhitespace;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.EndElement)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.EndEntity)] = -1;      
            xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.XmlDeclaration)] = -1;      
           // xmlNodeType_To_XpathNodeType_Map[(int)(XmlNodeType.All)] = -1;      
        }

        private XPathNodeType DecideXPNodeTypeForTextNodes( XmlNode node ) {
            //the function can only be called on text like nodes.
            Debug.Assert( XmlDataDocument.IsTextNode( node.NodeType ) );
            XPathNodeType xnt = XPathNodeType.Whitespace;
            while( node != null ) {
                switch( node.NodeType ) {
                    case XmlNodeType.Whitespace :
                        break;
                    case XmlNodeType.SignificantWhitespace :
                        xnt = XPathNodeType.SignificantWhitespace; 
                        break;
                    case XmlNodeType.Text :
                    case XmlNodeType.CDATA :
                        return XPathNodeType.Text;
                    default :                        
                        return xnt;
                }                 
                node = this._doc.SafeNextSibling(node);
            }
            return xnt;
        }
        
        private XPathNodeType ConvertNodeType( XmlNode node ) {
            int xnt = -1;
            if ( XmlDataDocument.IsTextNode( node.NodeType ) )
                return DecideXPNodeTypeForTextNodes( node );
            xnt = xmlNodeType_To_XpathNodeType_Map[(int)(node.NodeType)];
            if ( xnt == (int) XPathNodeType.Attribute ) {
                if ( node.NamespaceURI == s_strReservedXmlns )
                    return XPathNodeType.Namespace;
                else 
                    return XPathNodeType.Attribute;
            }
            Debug.Assert( xnt != -1 );
            return (XPathNodeType)xnt;
        }

        private bool IsNamespaceNode( XmlNodeType nt, string ns ) {
            if ( nt == XmlNodeType.Attribute && ns == s_strReservedXmlns )
                return true;
            return false;
        }

        //when the constructor is called, the node has to be a valid XPath node at the valid location ( for example, the first
        //text/WS/SWS/CData nodes of a series continuous text-like nodes.
        internal XPathNodePointer( DataDocumentXPathNavigator owner,  XmlDataDocument doc, XmlNode node ) 
        : this ( owner, doc, node, null, false, null ){             
        }

        internal XPathNodePointer( DataDocumentXPathNavigator owner, XPathNodePointer pointer ) 
        : this ( owner, pointer._doc, pointer._node, pointer._column, pointer._fOnValue, pointer._parentOfNS ) { 
        }

        private XPathNodePointer( DataDocumentXPathNavigator owner, XmlDataDocument doc, XmlNode node, DataColumn c, bool bOnValue, XmlBoundElement parentOfNS ) {
            Debug.Assert( owner != null );
            this._owner = new WeakReference( owner );
            this._doc = doc;
            this._node = node;
            this._column = c;
            this._fOnValue = bOnValue;
            this._parentOfNS = parentOfNS;
            // Add this pointer to the document so it will be updated each time region changes it's foliation state.
            this._doc.AddPointer( (IXmlDataVirtualNode)this );
            _bNeedFoliate = false;
            AssertValid();
        }

        internal XPathNodePointer Clone( DataDocumentXPathNavigator owner ){
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Clone");
            RealFoliate();
            return new XPathNodePointer( owner, this ) ;
        }

        internal bool IsEmptyElement { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsEmptyElement");
                AssertValid();
                if (_node != null && _column == null) {
                    if (_node.NodeType == XmlNodeType.Element) {
                        return((XmlElement)_node).IsEmpty;
                    }
                }
                return false;
            }
        }

        internal XPathNodeType NodeType { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:NodeType");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return XPathNodeType.All; 
                }
                else if (this._column == null) {
                    return ConvertNodeType(this._node); 
                } 
                else if (this._fOnValue) {
                    return XPathNodeType.Text;
                } 
                else if (this._column.ColumnMapping == MappingType.Attribute) {
                    if ( this._column.Namespace == s_strReservedXmlns )
                        return XPathNodeType.Namespace;
                    else 
                        return XPathNodeType.Attribute;
                } 
                else //TODO: find out what is the else senario?
                    return XPathNodeType.Element;
            }
        }

        //LDAI: From CodeReview: Perf: We should have another array similar w/ 
        //  xmlNodeType_To_XpathNodeType_Map that will return String.Empty for everything but the element and
        //  attribute case.
        internal string LocalName { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:LocalName");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return string.Empty;
                } 
                else if (this._column == null) {
                    XmlNodeType nt = this._node.NodeType;
                    if ( IsNamespaceNode( nt, this._node.NamespaceURI ) && this._node.LocalName == s_strXmlNS )
                        return string.Empty;
                    if ( nt == XmlNodeType.Element || nt == XmlNodeType.Attribute || nt == XmlNodeType.ProcessingInstruction )
                        return _node.LocalName;
                    return string.Empty;
                } 
                else if (this._fOnValue) {
                    return String.Empty;
                } 
                else //when column is not null
                    return _doc.NameTable.Add(_column.EncodedColumnName);
            }
        }

        //note that, we've have lost the prefix in this senario ( defoliation will toss prefix away. )
        internal string Name {
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Name");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return string.Empty;
                } 
                else if (this._column == null) {
                    XmlNodeType nt = this._node.NodeType;
                    if ( IsNamespaceNode( nt, this._node.NamespaceURI ) ) {
                        if ( this._node.LocalName == s_strXmlNS )
                            return string.Empty;
                        else
                            return this._node.LocalName;
                    }
                    if ( nt == XmlNodeType.Element || nt == XmlNodeType.Attribute || nt == XmlNodeType.ProcessingInstruction )
                        return _node.Name;
                    return string.Empty;
                } 
                else if (this._fOnValue) {
                    return String.Empty;
                } 
                else { //when column is not null
                    //we've lost prefix in this senario.
                    return _doc.NameTable.Add(_column.EncodedColumnName);
                }
            }
        }
        
        internal string NamespaceURI { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:NamespaceURI");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return string.Empty;
                } 
                else if (this._column == null) {
                    XPathNodeType xnt = ConvertNodeType( this._node );
                    if ( xnt == XPathNodeType.Element || xnt == XPathNodeType.Root || xnt == XPathNodeType.Attribute ) 
                        return _node.NamespaceURI; 
                    return string.Empty;
                } 
                else if (this._fOnValue) {
                    return string.Empty;
                } 
                else { //When column is not null
                    if ( _column.Namespace == s_strReservedXmlns )
                        //namespace nodes has empty string as namespaceURI
                        return string.Empty;
                    return _doc.NameTable.Add(_column.Namespace);
                }
            }
        }

        //BUGBUG: If saved in DataSet, the prefix of the node is not preserved.
        internal string Prefix { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Prefix");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return string.Empty;
                } 
                else if (this._column == null) {
                    if ( IsNamespaceNode( this._node.NodeType, this._node.NamespaceURI ) )
                        return string.Empty;
                    return _node.Prefix; 
                }
                return string.Empty;
            }
        }

        internal string Value { 
            get { 
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Value");
                RealFoliate();
                AssertValid();
                if (this._node == null) 
                    return null;
                else if (this._column == null) {                    
                    string strRet = this._node.Value;
                    if ( XmlDataDocument.IsTextNode( this._node.NodeType ) ) {
                        //concatenate adjacent textlike nodes
                        XmlNode parent = this._node.ParentNode;
                        if ( parent == null )
                            return strRet; 
                        XmlNode n = _doc.SafeNextSibling(this._node);
                        while ( n != null && XmlDataDocument.IsTextNode( n.NodeType ) ) {                            
                            strRet += n.Value;
                            n = _doc.SafeNextSibling(n);
                        }
                    }
                    return strRet;
                }
                else if (this._column.ColumnMapping == MappingType.Attribute || this._fOnValue) {
                    DataRow row = this.Row;
                    DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                    object value = row[ this._column, rowVersion ];
                    if ( ! Convert.IsDBNull( value ) )
                        return this._column.ConvertObjectToXml( value );
                    return null;
                }
                else 
                    //TODO: findout what is theis senario means: column element has no value --  
                    return null;
            }
        }

        internal string InnerText { 
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:InnerText");
                RealFoliate();
                AssertValid();
                if (this._node == null) {
                    return string.Empty;
                }
                else if (this._column == null) {
                    //TODO: replace with non-foliating walk for perf reason
                    if ( this._node.NodeType == XmlNodeType.Document ) {
                        //document node's region should always be uncompressed
                        XmlElement rootElem = ((XmlDocument)this._node).DocumentElement;
                        if ( rootElem != null )
                            return rootElem.InnerText; 
                        return string.Empty;
                    }
                    else
                        return this._node.InnerText;
                }
                else {
                    DataRow row = this.Row;
                    DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                    object value = row[ this._column, rowVersion ];
                    if ( ! Convert.IsDBNull( value ) )
                        return this._column.ConvertObjectToXml( value );
                    return string.Empty;
                }
            }
        }

        internal String BaseURI {
            get { 
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:BaseURI");
                RealFoliate();
                if ( this._node != null )
                    return this._node.BaseURI;
                return String.Empty; 
            }
        }

        internal XmlSpace XmlSpace { 
            get { 
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:XmlSpace");
                RealFoliate();
                XmlNode curNode = this._node;
                XmlBoundElement curBoundElem = null;
                while ( curNode != null ) {
                    curBoundElem = curNode as XmlBoundElement;
                    if ( curBoundElem != null ) {
                        //this._doc.Foliate( curBoundElem, ElementState.WeakFoliation );
                        String xmlSpaceVal = null;
                        if ( curBoundElem.ElementState == ElementState.Defoliated ) {
                            //if not foliated, going through the columns to get the xml:space
                            DataRow row = curBoundElem.Row;
                            foreach( DataColumn col in row.Table.Columns ) {
                                if ( col.Prefix == "xml" && col.EncodedColumnName == "space" ) {
                                    xmlSpaceVal = (String) row[col];
                                    break; //break out of the for loop
                                }
                            }                            
                        } 
                        else {
                            //if foliated, ask for the attribute directly
                            xmlSpaceVal = curBoundElem.GetAttribute( "xml:space" );
                        }
                        if ( xmlSpaceVal == "default" )
                            return XmlSpace.Default;
                        else if ( xmlSpaceVal == "preserve" ) 
                            return XmlSpace.Preserve;  
                    }
                    if ( curNode.NodeType == XmlNodeType.Attribute )
                        curNode = ((XmlAttribute)curNode).OwnerElement;
                    else
                        curNode = curNode.ParentNode;
                }
                return XmlSpace.None;
            } 
        }

        internal String XmlLang { 
            get { 
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:XmlLang");
                RealFoliate();
                XmlNode curNode = this._node;
                XmlBoundElement curBoundElem = null;
                object colVal = null;
                while ( curNode != null ) {
                    //TODO: we might improve the perf by going through the columns rather than
                    //    foliating the node                    
                    curBoundElem = curNode as XmlBoundElement;
                    if ( curBoundElem != null ) {
                        //this._doc.Foliate( curBoundElem, ElementState.WeakFoliation );
                        if ( curBoundElem.ElementState == ElementState.Defoliated ) {
                            //if not foliated, going through the columns to get the xml:lang
                            DataRow row = curBoundElem.Row;
                            foreach( DataColumn col in row.Table.Columns ) {
                                if ( col.Prefix == "xml" && col.EncodedColumnName == "lang" ) {
                                    colVal = row[col];
                                    if ( colVal == DBNull.Value )
                                        break; //goto its ancesstors
                                    return (String) colVal;
                                }
                            }
                        } 
                        else {
                            //if folicated, get the attribute directly
                            if ( curBoundElem.HasAttribute( "xml:lang" ) ) 
                                return curBoundElem.GetAttribute( "xml:lang" );                            
                        }
                    }
                    if ( curNode.NodeType == XmlNodeType.Attribute )
                        curNode = ((XmlAttribute)curNode).OwnerElement;
                    else
                        curNode = curNode.ParentNode;                    
                }
                return String.Empty;
            } 
        }
        
        private XmlBoundElement GetRowElement() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetRowElement()");
            //AssertValid();

            XmlBoundElement rowElem;
            if ( this._column != null ) {
                rowElem = this._node as XmlBoundElement;
                Debug.Assert( rowElem != null );
                Debug.Assert( rowElem.Row != null );
                return rowElem;
            }

            _doc.Mapper.GetRegion( this._node, out rowElem );
            return rowElem;
        }

        //TODO: We might improve perf by cashing the Row instead to get it everytime we move around the sibling
        private DataRow Row {
            get { 
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Row");
                //AssertValid();
                XmlBoundElement rowElem = GetRowElement();
                if ( rowElem == null )
                    return null;

                Debug.Assert( rowElem.Row != null );
                return rowElem.Row;
            }
        }

        internal bool MoveTo( XPathNodePointer pointer ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveTo(pointer)");
            AssertValid();
            if ( this._doc != pointer._doc )
                return false;
            /*
            XmlDataDocument docOld = this._doc;
            XmlDataDocument docNew = pointer._doc;
            if ( docNew != docOld ) {
                this._doc.RemovePointer( this );
                this._doc = pointer._doc;
                this._doc.AddPointer( this );
            } 
            */
            this._node = pointer._node;
            this._column = pointer._column;
            this._fOnValue = pointer._fOnValue;
            this._bNeedFoliate = pointer._bNeedFoliate;
            AssertValid();
            return true;
        }

        private void MoveTo( XmlNode node ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveTo(node)");
            //AssertValid();
            // Should not move outside of this document
            Debug.Assert( node == this._doc || node.OwnerDocument == this._doc );
            this._node = node;
            this._column = null;
            this._fOnValue = false;
            //AssertValid();
        }

        private void MoveTo( XmlNode node, DataColumn column, bool _fOnValue ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveTo(node, column, fOnValue)");
            //AssertValid();
            // Should not move outside of this document
            Debug.Assert( node == this._doc || node.OwnerDocument == this._doc );
            this._node = node;
            this._column = column;
            this._fOnValue = _fOnValue;
            //AssertValid();
        }

        private bool IsFoliated( XmlNode node ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsFoliated(node)");
            //AssertValid();
            if (node != null && node is XmlBoundElement)
                return((XmlBoundElement)node).IsFoliated;
            return true;
        }

        private int ColumnCount( DataRow row, bool fAttribute ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:ColumnCount(row,fAttribute)");
            DataColumn c = null;
            int count = 0;
            while ((c = NextColumn( row, c, fAttribute )) != null) {
                if ( c.Namespace != s_strReservedXmlns )
                    count++;
            }
            return count;
        }

        internal int AttributeCount {
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:AttributeCount");
                RealFoliate();
                AssertValid();
                if (_node != null) {
                    if (_column == null && _node.NodeType == XmlNodeType.Element) {
                        if (!IsFoliated( _node )) 
                            return ColumnCount( Row, true );
                        else {
                            int nc = 0;
                            foreach ( XmlAttribute attr in _node.Attributes ) {
                                if ( attr.NamespaceURI != s_strReservedXmlns )
                                    nc++;
                            }
                            return nc;
                        }
                    }
                }
                return 0;
            }            
        }

        internal DataColumn NextColumn( DataRow row, DataColumn col, bool fAttribute ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:NextColumn(row,col,fAttribute)");
            if (row.RowState == DataRowState.Deleted)
                return null;

            DataTable table = row.Table;
            DataColumnCollection columns = table.Columns;
            int iColumn = (col != null) ? col.Ordinal + 1 : 0;
            int cColumns = columns.Count;
            DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;

            for (; iColumn < cColumns; iColumn++) {
                DataColumn c = columns[iColumn];
                if (!_doc.IsNotMapped( c ) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && ! Convert.IsDBNull( row[c, rowVersion] ) )
                    return c;
            }

            return null;
        }

        internal DataColumn PreviousColumn( DataRow row, DataColumn col, bool fAttribute ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:PreviousColumn(row,col,fAttribute)");
            if (row.RowState == DataRowState.Deleted)
                return null;

            DataTable table = row.Table;
            DataColumnCollection columns = table.Columns;
            int iColumn = (col != null) ? col.Ordinal - 1 : columns.Count - 1;
            int cColumns = columns.Count;
            DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;

            for (; iColumn >= 0; iColumn--) {
                DataColumn c = columns[iColumn];
                if (!_doc.IsNotMapped( c ) && (c.ColumnMapping == MappingType.Attribute) == fAttribute && !Convert.IsDBNull( row[c, rowVersion] ) )
                    return c;
            }

            return null;
        }

        internal DataColumn NthColumn( DataRow row, bool fAttribute, int iColumn ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:NthColumn(row,fAttribute,iColumn)");
            DataColumn c = null;
            while ((c = NextColumn( row, c, fAttribute )) != null) {
                if (iColumn == 0)
                    return c;

                iColumn--;
            }
            return null;
        }
        
        internal bool MoveToAttribute( string localName, string namespaceURI ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToAttribute(localName, namespaceURI)");
            RealFoliate();
            AssertValid();
            if ( namespaceURI == s_strReservedXmlns )
                return false;
            if (_node != null) {
                //_column.ColumnMapping checkin below is not really needed since the pointer should be pointing at the node before this
                // function should even be called ( there is always a call MoveToOwnerElement() before MoveToAttribute(..)
                if ((_column == null || _column.ColumnMapping == MappingType.Attribute) && _node.NodeType == XmlNodeType.Element) {
                    if (!IsFoliated( _node )) {
                        DataColumn c = null;
                        while ((c = NextColumn( Row, c, true )) != null) {
                            if (c.EncodedColumnName == localName && c.Namespace == namespaceURI) {
                                MoveTo( _node, c, false );
                                return true;
                            }
                        }
                    } 
                    else {
                        Debug.Assert( _node.Attributes != null );
                        XmlNode n = _node.Attributes.GetNamedItem(localName, namespaceURI);
                        if (n != null) {
                            MoveTo( n, null, false );
                            return true;
                        }
                    }
                }
            }
            return false;
        }
      
        internal bool MoveToNextAttribute( bool bFirst ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToNextAttribute(bFirst)");
            //BUGBUG: what if _column != null && _column.ColumnMapping == MappingType.Element?
            RealFoliate();
            AssertValid();
            if (_node != null) {
                if ( bFirst && ( _column != null || _node.NodeType != XmlNodeType.Element ) )
                    return false;
                if ( !bFirst ) {
                    if ( _column != null && _column.ColumnMapping != MappingType.Attribute ) 
                        return false;
                    if ( _column == null && _node.NodeType != XmlNodeType.Attribute )
                        return false;
                }
                if ( !IsFoliated( _node ) ) {
                    DataColumn c = _column;
                    while ( ( c = NextColumn( Row, c, true ) ) != null ) {
                        if ( c.Namespace != s_strReservedXmlns ) {
                            MoveTo( _node, c, false );
                            return true;
                        }
                    }
                    return false;
                }
                else {
                    if ( bFirst ) {
                        XmlAttributeCollection attrs = _node.Attributes;
                        foreach ( XmlAttribute attr in attrs ) {
                            if ( attr.NamespaceURI != s_strReservedXmlns ) {
                                MoveTo( attr, null, false );
                                return true;
                            }
                        }
                    } 
                    else {
                        XmlAttributeCollection attrs = ((XmlAttribute)_node).OwnerElement.Attributes;
                        bool bFound = false;
                        foreach ( XmlAttribute attr in attrs ) {
                            if ( bFound && attr.NamespaceURI != s_strReservedXmlns ) {
                                MoveTo( attr, null, false );
                                return true;
                            }
                            if ( attr == _node )
                                bFound = true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool IsValidChild( XmlNode parent, XmlNode child ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsValidChild(parent,child)");
            int xntChildInt = xmlNodeType_To_XpathNodeType_Map[(int)(child.NodeType)];
            if ( xntChildInt == -1 )
                return false;
            int xntInt = xmlNodeType_To_XpathNodeType_Map[(int)(parent.NodeType)];
            Debug.Assert( xntInt != -1 );
            switch ( xntInt ) {
                case (int)XPathNodeType.Root:
                    return ( xntChildInt == (int)XPathNodeType.Element ||
                             xntChildInt == (int)XPathNodeType.Comment ||
                             xntChildInt == (int)XPathNodeType.ProcessingInstruction );
                case (int)XPathNodeType.Element:
                    return ( xntChildInt == (int)XPathNodeType.Element ||
                             xntChildInt == (int)XPathNodeType.Text ||
                             xntChildInt == (int)XPathNodeType.Comment ||
                             xntChildInt == (int)XPathNodeType.Whitespace ||
                             xntChildInt == (int)XPathNodeType.SignificantWhitespace ||
                             xntChildInt == (int)XPathNodeType.ProcessingInstruction );
                default :
                    return false;                    
            }
        }

        private bool IsValidChild( XmlNode parent, DataColumn c ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsValidChild(parent,c)");
            int xntInt = xmlNodeType_To_XpathNodeType_Map[(int)(parent.NodeType)];
            Debug.Assert( xntInt != -1 );
            switch ( xntInt ) {
                case (int)XPathNodeType.Root:
                    return c.ColumnMapping == MappingType.Element;
                case (int)XPathNodeType.Element:
                    return ( c.ColumnMapping == MappingType.Element || c.ColumnMapping == MappingType.SimpleContent );
                default :
                    return false;                    
            }            
        }
        
        internal bool MoveToNextSibling() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToNextSibling()");
            RealFoliate();
            AssertValid();
            if (_node != null) {
                if ( _column != null ) {
                    if ( _fOnValue ) { 
                        // _fOnValue could be true only when the column is mapped as simplecontent or element
                        Debug.Assert( _column.ColumnMapping != MappingType.Attribute && _column.ColumnMapping != MappingType.Hidden );
                        return false;
                    }
                    DataRow curRow = Row;
                    DataColumn c = NextColumn( curRow, _column, false ); 
                    while ( c != null ) {
                        if ( IsValidChild( _node, c ) ) {
                            MoveTo( this._node, c, _doc.IsTextOnly(c));
                            return true;
                        }
                        c = NextColumn( curRow, c, false );
                    } 
                    XmlNode n = _doc.SafeFirstChild( _node );
                    if (n != null) {
                        MoveTo( n );
                        return true;
                    }
                } 
                else {
                    XmlNode n = _node;
                    XmlNode parent = _node.ParentNode;
                    if ( parent == null )
                        return false;
                    bool bTextLike = XmlDataDocument.IsTextNode( _node.NodeType );
                    do {
                        do {
                            n = _doc.SafeNextSibling(n);
                        } while ( n != null && bTextLike && XmlDataDocument.IsTextNode( n.NodeType ));
                    } while ( n != null && !IsValidChild(parent, n) );
                    if (n != null) {
                        MoveTo(n);
                        return true;
                    }
                }
            }
            return false;
        }
        
        internal bool MoveToPreviousSibling() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToPreviousSibling()");
            RealFoliate();
            AssertValid();
            if (_node != null) {
                if (_column != null) {
                    if (_fOnValue)
                        return false;
                    DataRow curRow = Row;
                    DataColumn c = PreviousColumn( curRow, _column, false );
                    while ( c != null ) {
                        if ( IsValidChild(_node,c)) {
                            MoveTo( _node, c, _doc.IsTextOnly(c) );
                            return true;
                        }
                        c = PreviousColumn( curRow, c , false );
                    } 
                }
                else {
                    XmlNode n = _node;
                    XmlNode parent = _node.ParentNode;
                    if ( parent == null )
                        return false;
                    bool bTextLike = XmlDataDocument.IsTextNode( _node.NodeType );
                    do {
                        do {
                            n = _doc.SafePreviousSibling( n );
                        } while ( n != null && bTextLike && XmlDataDocument.IsTextNode( n.NodeType ) );
                    } while ( n != null && !IsValidChild(parent, n) );
                    if (n != null) {
                        MoveTo(n);
                        return true;
                    }
                    if (!IsFoliated( parent ) && (parent is XmlBoundElement)) {
                        DataRow row = ((XmlBoundElement)parent).Row;
                        if (row != null) {
                            DataColumn c = PreviousColumn( row, null, false );
                            if (c != null) {
                                MoveTo( parent, c, _doc.IsTextOnly(c) );
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        internal bool MoveToFirst() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToFirst()");
            RealFoliate();
            AssertValid();
            if (_node != null) {
                DataRow curRow = null;
                XmlNode parent = null;
                if (_column != null) {
                    curRow = Row;
                    parent = _node;
                } 
                else {
                    parent = _node.ParentNode;
                    if ( parent == null )
                        return false;
                    if ( !IsFoliated( parent ) && (parent is XmlBoundElement) ) 
                        curRow = ((XmlBoundElement)parent).Row;
                } 
                //first check with the columns in the row
                if ( curRow != null ) {
                    DataColumn c = NextColumn( curRow, null, false );
                    while ( c != null ) {
                        if ( IsValidChild( _node, c ) ) {
                            MoveTo( _node, c, _doc.IsTextOnly( c ) );
                            return true;
                        }
                        c = NextColumn( curRow, c, false );
                    } 
                }
                //didn't find a valid column or maybe already Foliated, go through its children nodes
                XmlNode n = _doc.SafeFirstChild( parent );
                while ( n != null ) {
                    if ( IsValidChild( parent, n ) ) {
                        MoveTo( n );
                        return true;
                    }
                    n = _doc.SafeNextSibling( n );
                } 
            }
            return false;
        }

        internal bool HasChildren {
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:HasChildren");
                RealFoliate();
                AssertValid();
                if (_node == null)
                    return false;

                if (_column != null) {
                    if ( _column.ColumnMapping == MappingType.Attribute || _column.ColumnMapping == MappingType.Hidden )
                        return false;
                    return !_fOnValue;
                } 
                if (!IsFoliated( _node )) {
                    // find virtual column elements first
                    DataRow curRow = Row;
                    DataColumn c = NextColumn( curRow, null, false );
                    while ( c != null ) {
                        if ( IsValidChild( _node, c) ) 
                            return true;
                        c = NextColumn( curRow, c, false );
                    } 
                }
                // look for anything
                XmlNode n = _doc.SafeFirstChild( _node );
                while ( n != null ) {
                    if ( IsValidChild( _node, n ) ) 
                        return true;
                    n = _doc.SafeNextSibling( n );
                } 

                return false;
            }
        }
        
        internal bool MoveToFirstChild() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToFirstChild()");
            RealFoliate();
            AssertValid();
            if (_node == null)
                return false;

            if (_column != null) {
                if ( _column.ColumnMapping == MappingType.Attribute || _column.ColumnMapping == MappingType.Hidden )
                    return false;
                if (_fOnValue) //text node has no children to move to
                    return false;
                _fOnValue = true;
                return true;
            } 
            if (!IsFoliated( _node )) {
                // find virtual column elements first
                DataRow curRow = Row;
                DataColumn c = NextColumn( curRow, null, false );
                while ( c != null ) {
                    if ( IsValidChild( _node, c) ) {
                        MoveTo( _node, c, _doc.IsTextOnly(c) );
                        return true;
                    }
                    c = NextColumn( curRow, c, false );
                } 
            }
            // look for anything
            XmlNode n = _doc.SafeFirstChild( _node );
            while ( n != null ) {
                if ( IsValidChild( _node, n ) ) {
                    MoveTo(n);
                    return true;
                }
                n = _doc.SafeNextSibling( n );
            } 

            return false;
        }
        
        //this version of MoveToParent will consider Attribute type position and move to its owner element
        //TODO: consider namespace node
        internal bool MoveToParent() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToParent()");        
            RealFoliate();
            AssertValid();
            if ( NodeType == XPathNodeType.Namespace ) {
                Debug.Assert( _parentOfNS != null );
                MoveTo( _parentOfNS );
                return true;
            }
            if (_node != null) {
                if (_column != null) {
                    if (_fOnValue && !_doc.IsTextOnly(_column)) {
                        MoveTo( _node, _column, false );
                        return true;
                    }
                    MoveTo( _node, null, false );
                    return true;
                }
                else {
                    XmlNode n = null;
                    if ( _node.NodeType == XmlNodeType.Attribute )
                        n = ((XmlAttribute)_node).OwnerElement;
                    else 
                        n = _node.ParentNode;
                    if (n != null) {
                        MoveTo(n);
                        return true;
                    }
                }
            }
            return false;
        }

        private XmlNode GetParent( XmlNode node ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetParent(node)");
            XPathNodeType xnt = ConvertNodeType( node );
            if ( xnt == XPathNodeType.Namespace ) {
                Debug.Assert( _parentOfNS != null );
                return _parentOfNS;
            }
            if ( xnt == XPathNodeType.Attribute )
                return ((XmlAttribute)node).OwnerElement;
            return node.ParentNode;
        }
        
        internal void MoveToRoot() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToRoot()");
            XmlNode node = this._node;
            XmlNode parent = this._node;
            while ( parent != null ) {
                node = parent;
                parent = GetParent(parent);
            }
            this._node = node;
            this._column = null;
            this._fOnValue = false;
            AssertValid();
        }
        
        internal bool IsSamePosition( XPathNodePointer pointer ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsSamePosition(pointer)");
            RealFoliate();
            pointer.RealFoliate();
            AssertValid();
            pointer.AssertValid();
            if (_column == null && pointer._column == null)
                return ( pointer._node == this._node && pointer._parentOfNS == this._parentOfNS );

            return ( pointer._doc == this._doc 
                    && pointer._node == this._node 
                    && pointer._column == this._column 
                    && pointer._fOnValue == this._fOnValue 
                    && pointer._parentOfNS == this._parentOfNS );
        }

        private XmlNodeOrder CompareNamespacePosition( XPathNodePointer other ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:CompareNamespacePostion(other)");
            XPathNodePointer xp1 = this.Clone((DataDocumentXPathNavigator)(this._owner.Target));
            XPathNodePointer xp2 = other.Clone((DataDocumentXPathNavigator)(other._owner.Target));
            while ( xp1.MoveToNextNamespace(XPathNamespaceScope.All) ) {
                if ( xp1.IsSamePosition( other ) )
                    return XmlNodeOrder.Before;
            }
            return XmlNodeOrder.After;
        }
        
        private static XmlNode GetRoot( XmlNode node, ref int depth ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetRoot(node, depth)");
            depth = 0;
            XmlNode curNode = node;
            XmlNode parent = ( ( curNode.NodeType == XmlNodeType.Attribute ) ? ( ((XmlAttribute)curNode).OwnerElement ) : ( curNode.ParentNode ) );
            for ( ; parent != null; depth++ ) {
                curNode = parent; 
                parent = curNode.ParentNode; // no need to check for attribute since navigator can't be built on its children or navigate to its children 
            }
            return curNode;  
        }

        internal XmlNodeOrder ComparePosition( XPathNodePointer other ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:ComparePosition(other)");
            RealFoliate();
            other.RealFoliate();
            Debug.Assert( other != null );
            if ( IsSamePosition( other ) )
                return XmlNodeOrder.Same;
            XmlNode curNode1 = null, curNode2 = null;
            //deal with namespace node first
            if ( this.NodeType == XPathNodeType.Namespace && other.NodeType == XPathNodeType.Namespace ) {
                if ( this._parentOfNS == other._parentOfNS )
                    return this.CompareNamespacePosition( other );
                //if not from the same parent
                curNode1 = this._parentOfNS;
                curNode2 = other._parentOfNS;
            }
            else if ( this.NodeType == XPathNodeType.Namespace ) {
                Debug.Assert( other.NodeType != XPathNodeType.Namespace );
                if ( this._parentOfNS == other._node ) {
                    //from the same region, NS nodes come before all other nodes
                    if ( other._column == null )
                        return XmlNodeOrder.After;
                    else
                        return XmlNodeOrder.Before;
                }
                //if not from the same region
                curNode1 = this._parentOfNS;
                curNode2 = other._node;
            } 
            else if ( other.NodeType == XPathNodeType.Namespace ) {
                Debug.Assert( this.NodeType != XPathNodeType.Namespace );
                if ( this._node == other._parentOfNS ) {
                    //from the same region
                    if ( this._column == null )
                        return XmlNodeOrder.Before;
                    else
                        return XmlNodeOrder.After;
                }
                //if not from the same region
                curNode1 = this._node;
                curNode2 = other._parentOfNS;
            }
            else {
                if ( this._node == other._node ) {
                    //compare within the same region
                    if ( this._column == other._column ) {
                        //one is the children of the other
                        Debug.Assert( this._fOnValue != other._fOnValue );
                        if ( this._fOnValue )
                            return XmlNodeOrder.After;
                        else
                            return XmlNodeOrder.Before;
                    }
                    else {
                        Debug.Assert( this.Row == other.Row ); //in the same row
                        if ( this._column == null ) 
                            return XmlNodeOrder.Before;
                        else if ( other._column == null ) 
                            return XmlNodeOrder.After;
                        else if ( this._column.Ordinal < other._column.Ordinal )
                            return XmlNodeOrder.Before;
                        else
                            return XmlNodeOrder.After;
                    }
                }
                curNode1 = this._node;
                curNode2 = other._node;
                
            }

            Debug.Assert( curNode1 != null );
            Debug.Assert( curNode2 != null );

            int depth1 = -1, depth2 = -1;
            XmlNode root1 = XPathNodePointer.GetRoot( curNode1, ref depth1 );
            XmlNode root2 = XPathNodePointer.GetRoot( curNode2, ref depth2 );
            if ( root1 != root2 ) 
                return XmlNodeOrder.Unknown;

            if ( depth1 > depth2 ) {
                while ( curNode1 != null && depth1 > depth2 ) {
                    curNode1 = ( ( curNode1.NodeType == XmlNodeType.Attribute ) ? ( ((XmlAttribute)curNode1).OwnerElement ) : ( curNode1.ParentNode ) );
                    depth1--;
                }
                if ( curNode1 == curNode2 )
                    return XmlNodeOrder.After;
            }
            else if ( depth2 > depth1 ) {
                while ( curNode2 != null && depth2 > depth1 ) {
                    curNode2 = ( ( curNode2.NodeType == XmlNodeType.Attribute ) ? ( ((XmlAttribute)curNode2).OwnerElement ) : ( curNode2.ParentNode ) );
                    depth2--;
                }
                if ( curNode1 == curNode2 )
                    return XmlNodeOrder.Before;
            }

            XmlNode parent1 = GetParent(curNode1);
            XmlNode parent2 = GetParent(curNode2);
            XmlNode nextNode = null;
            while ( parent1 != null && parent2 != null ) {
                if ( parent1 == parent2 ) {
                    while (curNode1 != null ) {
                        nextNode = curNode1.NextSibling;
                        if ( nextNode == curNode2 )
                            return XmlNodeOrder.Before;
                        curNode1 = nextNode;
                    }
                    return XmlNodeOrder.After;
                }
                curNode1 = parent1;
                curNode2 = parent2;
                parent1 = curNode1.ParentNode;
                parent2 = curNode2.ParentNode;
            }
            
            //logically, we shouldn't reach here
            Debug.Assert( false );
            return XmlNodeOrder.Unknown;
        }
        
        internal bool MoveToAttribute( string name ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToAttribute(name)");
            RealFoliate();
            AssertValid();
            if (_node != null) {
                //_column.ColumnMapping checkin below is not really needed since the pointer should be pointing at the node before this
                // function should even be called ( there is always a call MoveToOwnerElement() before MoveToAttribute(..)
                if ((_column == null || _column.ColumnMapping == MappingType.Attribute) && _node.NodeType == XmlNodeType.Element) {
                    if (!IsFoliated( _node )) {
                        DataColumn c = null;
                        while ((c = NextColumn( Row, c, true )) != null) {
                            //TODO: need to check namespace node if SupportNamespaces
                            if (c.EncodedColumnName == name) {
                                MoveTo( _node, c, false );
                                return true;
                            }
                        }
                    } 
                    else {
                        XmlNode n = _node.Attributes.GetNamedItem(name);
                        if (n != null) {
                            MoveTo( n, null, false );
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        internal XmlNode Node {
            get {
                //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:Node");
                RealFoliate();
                AssertValid();

                if ( this._node == null )
                    return null;

                XmlBoundElement rowElem = GetRowElement();
                if ( rowElem != null ) {
                    //lock ( this._doc.pointers ) {
                        bool wasFoliationEnabled = this._doc.IsFoliationEnabled;
                        this._doc.IsFoliationEnabled = true;
                        this._doc.Foliate( rowElem, ElementState.StrongFoliation );
                        this._doc.IsFoliationEnabled = wasFoliationEnabled;
                    //}
                }
                RealFoliate();
                AssertValid();
                return this._node;
            }
        }

        bool IXmlDataVirtualNode.IsOnNode( XmlNode nodeToCheck ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsOnNode(nodeToCheck)");
            RealFoliate();
            return nodeToCheck == this._node;
        }

        bool IXmlDataVirtualNode.IsOnColumn( DataColumn col ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsOnColumn(col)");
            RealFoliate();
            return col == this._column;
        }
        
        void IXmlDataVirtualNode.OnFoliated( XmlNode foliatedNode ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:OnFoliated(foliatedNode)");
            // update the pointer if the element node has been foliated
            if (_node == foliatedNode) {
                // if already on this node, nothing to do!
                if (_column == null)
                    return;
                _bNeedFoliate = true;
            }
        }

        private void RealFoliate() {
            if ( !_bNeedFoliate )
                return;
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:RealFoliate()");
            _bNeedFoliate = false;

            Debug.Assert( this._column != null );
        
            XmlNode n = null;

            if (_doc.IsTextOnly( _column ))
                n = _node.FirstChild;
            else  {
                if (_column.ColumnMapping == MappingType.Attribute) {
                    n = _node.Attributes.GetNamedItem( _column.EncodedColumnName, _column.Namespace );
                }
                else {
                    for (n = _node.FirstChild; n != null; n = n.NextSibling) {
                        if (n.LocalName == _column.EncodedColumnName && n.NamespaceURI == _column.Namespace)
                            break;
                    }
                }

                if (n != null && _fOnValue)
                    n = n.FirstChild;
            }

            if (n == null)
                throw new InvalidOperationException(Res.GetString(Res.DataDom_Foliation));

            // Cannot use MoveTo( n ); b/c the initial state for MoveTo is invalid (region is foliated but this is not)            
            this._node = n;
            this._column = null;
            this._fOnValue = false;
            AssertValid();
            _bNeedFoliate = false;
        }


        //The function only helps to find out if there is a namespace declaration of given name is defined on the given node
        //It will not check the accestors of the given node.
        private string GetNamespace( XmlBoundElement be, string name ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetNamespace(be,name)");

            if ( be == null )
                return null;
            XmlAttribute attr = null;
            if ( be.IsFoliated ) {
                attr = be.GetAttributeNode ( name, s_strReservedXmlns );
                if ( attr != null )
                    return attr.Value;
                else
                    return null;
            } 
            else { //defoliated so that we need to search through its column 
                DataRow curRow = be.Row;
                if ( curRow == null )
                    return null;
                //going through its attribute columns
                DataColumn curCol = PreviousColumn( curRow, null, true );
                while ( curCol != null ) {
                    if ( curCol.Namespace == s_strReservedXmlns ) {
                        //TODO: Find out if we can assume that rowVersion will always be DataRowVersion.Current in this case
                        DataRowVersion rowVersion = ( curRow.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                        return curCol.ConvertObjectToXml( curRow[curCol,rowVersion] );
                    }
                    curCol = PreviousColumn( curRow, curCol, true );
                }
                return null;
            }
        }
        
        internal string GetNamespace(string name) {
           //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetNamespace(name)");
            //we are checking the namespace nodes backwards comparing its normal order in DOM tree
            if ( name == "xml" )
                return s_strReservedXml;
            if ( name == "xmlns" )
                return s_strReservedXmlns;
            if ( name == "" )
                name = "xmlns";
            RealFoliate();
            XmlNode node = _node;
            XmlNodeType nt = node.NodeType;
            String retVal = null;
            while ( node != null ) {
                //first identify an element node in the ancestor + itself
                while ( node != null && ( ( nt = node.NodeType ) != XmlNodeType.Element ) ) {
                    if ( nt == XmlNodeType.Attribute )
                        node = ((XmlAttribute)node).OwnerElement;
                    else
                        node = node.ParentNode;
                }
                //found one -- inside if
                if ( node != null ) {
                    //must be element node
                    retVal = GetNamespace((XmlBoundElement)node, name);
                    if ( retVal != null )
                        return retVal;
                    //didn't find it, try the next parentnode
                    node = node.ParentNode;    
                }                
            }
            //nothing happens, then return string.empty.
            return string.Empty;
        }

        internal bool MoveToNamespace(string name) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToNamespace(name)");
            _parentOfNS = this._node as XmlBoundElement;
            //only need to check with _node, even if _column is not null and its mapping type is element, it can't have attributes
            if ( _parentOfNS == null )
                return false; 
            string attrName = name;
            if ( attrName == "xmlns" )
                attrName = "xmlns:xmlns";
            if ( attrName == "" )
                attrName = "xmlns";
            RealFoliate();
            XmlNode node = this._node;
            XmlNodeType nt = node.NodeType;
            XmlAttribute attr = null;
            XmlBoundElement be = null;
            while ( node != null ) {
                //check current element node
                be = node as XmlBoundElement;
                if ( be != null ) {
                    if ( be.IsFoliated ) {
                        attr = be.GetAttributeNode ( name, s_strReservedXmlns );
                        if ( attr != null ) {
                            MoveTo( attr );
                            return true;
                        }
                    } 
                    else {//defoliated so that we need to search through its column 
                        DataRow curRow = be.Row;
                        if ( curRow == null )
                            return false;
                        //going through its attribute columns
                        DataColumn curCol = PreviousColumn( curRow, null, true );
                        while ( curCol != null ) {
                            if ( curCol.Namespace == s_strReservedXmlns && curCol.ColumnName == name ) {
                                MoveTo( be, curCol, false );
                                return true;
                            }
                            curCol = PreviousColumn( curRow, curCol, true );
                        }
                    }
                } 
                //didn't find it, try the next element anccester.
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }
            //nothing happens, the name doesn't exist as a namespace node.
            _parentOfNS = null;
            return false;
        }

        //the function will find the next namespace node on the given bound element starting with the given column or attribte
        // wether to use column or attribute depends on if the bound element is folicated or not.
        private bool MoveToNextNamespace( XmlBoundElement be, DataColumn col, XmlAttribute curAttr ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToNextNamespace(be,col,curAttr)");
            if ( be != null ) {
                if ( be.IsFoliated ) {
                    XmlAttributeCollection attrs = be.Attributes;
                    XmlAttribute attr = null;
                    bool bFound = false;
                    if ( curAttr == null )
                        bFound = true; //the first namespace will be the one
#if DEBUG
                    if ( curAttr != null )
                        Debug.Assert( curAttr.NamespaceURI == s_strReservedXmlns );
#endif
                    Debug.Assert( attrs!=null );
                    int attrInd = attrs.Count;                
                    while ( attrInd > 0 ) {
                        attrInd--;
                        attr = attrs[attrInd];
                        if ( bFound && attr.NamespaceURI == s_strReservedXmlns && !DuplicateNS( be, attr.LocalName ) ) {
                            MoveTo(attr);
                            return true;
                        }
                        if ( attr == curAttr )
                            bFound = true;
                    }
                } 
                else {//defoliated so that we need to search through its column 
                    DataRow curRow = be.Row;
                    if ( curRow == null )
                        return false;
                    //going through its attribute columns
                    DataColumn curCol = PreviousColumn( curRow, col, true );
                    while ( curCol != null ) {
                        if ( curCol.Namespace == s_strReservedXmlns && !DuplicateNS( be, curCol.ColumnName ) ) {
                            MoveTo( be, curCol, false );
                            return true;
                        }
                        curCol = PreviousColumn( curRow, curCol, true );
                    }
                }
            } 
            return false;
        }
        
        //Caller( DataDocumentXPathNavigator will make sure that the node is at the right position for this call )
        internal bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToFirstNamespace(namespaceScope)");
            RealFoliate();
            _parentOfNS = this._node as XmlBoundElement;
            //only need to check with _node, even if _column is not null and its mapping type is element, it can't have attributes
            if ( _parentOfNS == null )
                return false; 
            XmlNode node = this._node;
            XmlBoundElement be = null;
            while ( node != null ) {
                be = node as XmlBoundElement;
                if ( MoveToNextNamespace( be, null, null ) )
                    return true;
                //didn't find it
                if ( namespaceScope == XPathNamespaceScope.Local )
                    goto labelNoNS;
                //try the next element anccestor.
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }
            if ( namespaceScope == XPathNamespaceScope.All ) {
                MoveTo( this._doc.attrXml, null, false );
                return true;
            }
labelNoNS:
            //didn't find one namespace node
            _parentOfNS = null;
            return false;
        }

        //endElem is on the path from startElem to root is enforced by the caller
        private bool DuplicateNS( XmlBoundElement endElem, string lname) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:DuplicateNS(endElem, lname)");
            if ( this._parentOfNS == null || endElem == null )
                return false;
            XmlBoundElement be = this._parentOfNS; 
            XmlNode node = null;
            while ( be != null && be != endElem ) {
                if ( GetNamespace( be, lname ) != null )
                    return true;
                node = (XmlNode)be;
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
                be = node as XmlBoundElement;
            }
            return false;            
        }
        
        //Caller( DataDocumentXPathNavigator will make sure that the node is at the right position for this call )
        internal bool MoveToNextNamespace(XPathNamespaceScope namespaceScope) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToNextNamespace(namespaceScope)");
            RealFoliate();
            Debug.Assert( _parentOfNS != null );
            XmlNode node = this._node;
            //first check within the same boundelement
            if ( this._column != null ) {
                Debug.Assert( this._column.Namespace == s_strReservedXmlns );
                if ( namespaceScope == XPathNamespaceScope.Local && _parentOfNS != this._node ) //already outside scope
                    return false;
                XmlBoundElement be = this._node as XmlBoundElement;
                Debug.Assert( be != null );
                DataRow curRow = be.Row;
                Debug.Assert( curRow != null );
                DataColumn curCol = PreviousColumn( curRow, this._column, true );
                while ( curCol != null ) {
                    if ( curCol.Namespace == s_strReservedXmlns ) {
                        MoveTo( be, curCol, false );
                        return true;
                    }
                    curCol = PreviousColumn( curRow, curCol, true );
                }                
                //didn't find it in this loop
                if ( namespaceScope == XPathNamespaceScope.Local )
                    return false;
                //try its ancesstor
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            } 
            else  if ( this._node.NodeType == XmlNodeType.Attribute ) {
                XmlAttribute attr = (XmlAttribute)(this._node);
                Debug.Assert( attr != null );
                node = attr.OwnerElement;
                if ( node == null )
                    return false;
                if ( namespaceScope == XPathNamespaceScope.Local && _parentOfNS != node ) //already outside scope
                    return false;
                if ( MoveToNextNamespace( (XmlBoundElement)node, null, (XmlAttribute)attr ) )
                    return true;
                //didn't find it
                if ( namespaceScope == XPathNamespaceScope.Local )
                    return false;
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }
            // till now, node should be the next accesstor (bound) element of the element parent of current namespace node (attribute or data column)
            while ( node != null ) {
                //try the namespace attributes from the same element
                XmlBoundElement be = node as XmlBoundElement;
                if ( MoveToNextNamespace( be, null, null ) )
                    return true;
                //no more namespace attribute under the same element
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType == XmlNodeType.Element );
            }
            //didn't find the next namespace, thus return
            if ( namespaceScope == XPathNamespaceScope.All ) {
                MoveTo( this._doc.attrXml, null, false );
                return true;
            }
            return false;
        }
        
        [System.Diagnostics.Conditional("DEBUG")]
        private void AssertValid() {
            // This pointer must be int the document list
            //RealFoliate();
            this._doc.AssertPointerPresent( this );
            if ( this._column != null ) {
                // We must be on a de-foliated region
                XmlBoundElement rowElem = this._node as XmlBoundElement;
                Debug.Assert( rowElem != null );

                DataRow row = rowElem.Row;
                Debug.Assert( row != null );

                //ElementState state = rowElem.ElementState;
                //Debug.Assert( state == ElementState.Defoliated || _bNeedFoliated, "Region is accessed using column, but it's state is FOLIATED" );

                // We cannot be on a column for which the value is DBNull
                DataRowVersion rowVersion = ( row.RowState == DataRowState.Detached ) ? DataRowVersion.Proposed : DataRowVersion.Current;
                Debug.Assert( ! Convert.IsDBNull( row[ this._column, rowVersion ] ) );

                // If we are on the Text column, we should always have _fOnValue == true
                Debug.Assert( (this._column.ColumnMapping == MappingType.SimpleContent) ? (this._fOnValue == true) : true );
            }
            if ( this._column == null ) 
                Debug.Assert( !this._fOnValue );
        }

        internal XmlDataDocument Document { get { return _doc; } }

        //The function below might be called from XmlDataDocument, we need to find out are these really necessary
        // Same as MoveTo( DataPointer ) but takes into account that you can move between documents        
        internal void MoveToOtherDocument( XPathNodePointer pointer ) {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:MoveToOtherDocument(pointer)");  
            RealFoliate();
            AssertValid();

            XmlDataDocument docOld = this._doc;
            XmlDataDocument docNew = pointer.Document;
            if ( docOld != docNew ) {
                this._doc.RemovePointer( this );
                this._doc = pointer.Document;
                this._doc.AddPointer( this );
            }
            this._node = pointer._node;
            this._column = pointer._column;
            this._fOnValue = pointer._fOnValue;

            AssertValid();
        }
        internal XmlNode GetNode() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetNode()");
            RealFoliate();
            return this._node;
        }
        internal DataColumn GetColumn() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:GetColumn()");
            RealFoliate();
            return this._column;
        }

        bool IXmlDataVirtualNode.IsInUse() {
            //Debug.WriteLineIf( XmlTrace.traceXPathNodePointerFunctions.Enabled, "XPathNodePointer:IsInUse()");
            return _owner.IsAlive;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\newxml\xmltrace.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTrace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlTrace.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml 
{
    using System.Diagnostics;
    using System.Data;
    using System.Globalization;
        
    internal class XmlTrace
    {
        // To see traces run DBMon.exe
        // To enable traces set an env var names _SWITCH_switchname (i.e. _SWITCH_FOO if the switch is new BooleanSwitch("foo");)"
        //  - for boolean switches:
        //      - to disable it: do not define the env var OR set the env var to 0
        //      - to enable it: define the env var to != 0
        //  - for trace switches:
        //      - to set it to TraceLevel.Off: do not define the env var OR set it to 0
        //      - to set it to TraceLevel.Error: define the env var to 1
        //      - to set it to TraceLevel.Warning: define the env var to 2
        //      - to set it to TraceLevel.Info: define the env var to 3
        //      - to set it to TraceLevel.Verbose: define the env var to 4
        //      - don't know what happens if you set it to something != (0, 1, 2, 3 or 4)
        // To trace use the following in your code:
        //  - for a boolean switch: Debug.WriteLineIf(mySwitchObject.Enabled, "My text here");
        //  - for a trace switch  : Debug.WriteLineIf(mySwitchObject.TraceError, "My text here"); // Replace TraceError w/ TraceWarning, TraceInfo, TraceVerbose)
        //
        internal static readonly BooleanSwitch traceDataSetEvents;
        internal static readonly BooleanSwitch traceXmlEvents;
        internal static readonly BooleanSwitch traceXmlDataDocumentEvents;
        internal static readonly BooleanSwitch traceSynch;
        internal static readonly BooleanSwitch traceRomChanges;
        internal static readonly BooleanSwitch traceXPathNodePointerFunctions;
#if DEBUG
        static void SetSwitchFromEnv( BooleanSwitch sw ) {
            sw.Enabled = (Environment.GetEnvironmentVariable( ("_Switch_" + sw.DisplayName).ToLower(CultureInfo.InvariantCulture) ) == "1");
        }
#endif
        static XmlTrace()
        {
#if DEBUG
            traceDataSetEvents = new BooleanSwitch("System.Xml.XmlDataDocument.DataSetEvents", "Show events received from DataSet by XmlDataDocument.");
            traceXmlEvents     = new BooleanSwitch("System.Xml.XmlDataDocument.XmlEvents", "Show events sent by XmlDataDocument.");
            traceXmlDataDocumentEvents  = new BooleanSwitch("System.Xml.XmlDataDocument.XmlDataDocumentEvents", "Show internal XmlDataDocument events.");
            traceSynch         = new BooleanSwitch("System.Xml.XmlDataDocument.Synch", "Show internal synchonization events.");
            traceRomChanges    = new BooleanSwitch("System.Xml.XmlDataDocument.RomChanges", "Show effects of ROM changes.");
            traceXPathNodePointerFunctions = new BooleanSwitch("System.Xml.XmlDataDocument.XPathNodePointerFunctions", "Show the trace of functions being called in XPathNodePointer.");

            SetSwitchFromEnv( traceDataSetEvents );
            SetSwitchFromEnv( traceXmlEvents );
            SetSwitchFromEnv( traceXmlDataDocumentEvents );
            SetSwitchFromEnv( traceSynch );
            SetSwitchFromEnv( traceRomChanges );
            SetSwitchFromEnv( traceXPathNodePointerFunctions );
#endif
        }
        internal static string StringFrom( string header, DataRow row ) {
#if DEBUG
            return header + " " + StringOf( row );
#else
            // This function should be used only in DEBUG bits
            // Throw rather than just returning "" so we can catch the error (using it in release bits)
            throw new NotSupportedException("Cannot compute argument value");
#endif

        }

        internal static string StringFrom(string header, DataRowChangeEventArgs args)
        {
#if DEBUG
            DataRow row = args.Row;
            DataRowAction action = args.Action;
//            return header + "DataRowChangeEvent:  [" + row.ToString() + "-" + action.Format() + "]";
            switch (action)
            {
            case DataRowAction.Add:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Add]";
            case DataRowAction.Change:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Change]";
            case DataRowAction.Commit:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Commit]";
            case DataRowAction.Delete:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Delete]";
            case DataRowAction.Nothing:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Nothing]";
            case DataRowAction.Rollback:
                return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-Rollback]";
            }
            return header + " - DataRowChangeEvent: [" + StringOf( row ) + "-?????]";
#else
            // This function should be used only in DEBUG bits
            // Throw rather than just returning "" so we can catch the error (using it in release bits)
            throw new NotSupportedException("Cannot compute argument value");
#endif
        }
        internal static string StringFrom(string header, DataColumnChangeEventArgs args)
        {
#if DEBUG
            DataColumn col = args.Column;
            object  oNewValue = args.ProposedValue;
            DataRow row = args.Row;
            return header + " - DataColumnChangeEvent: (" + col.Table.EncodedTableName + "." + col.EncodedColumnName + "): " + StringOf( row ) + " Proposed: " + ((oNewValue==null)?"null":oNewValue.ToString());
#else
            // This function should be used only in DEBUG bits
            // Throw rather than just returning "" so we can catch the error (using it in release bits)
            throw new NotSupportedException("Cannot compute argument value");
#endif
        }
        internal static string StringFrom(string header, XmlNode node)
        {
#if DEBUG
            return header;
#else
            // This function should be used only in DEBUG bits
            // Throw rather than just returning "" so we can catch the error (using it in release bits)
            throw new NotSupportedException("Cannot compute argument value");
#endif
        }


#if DEBUG
        private static string StringOf( DataRow row )
        {
            return "row: " + row.Table.TableName + " [o " + row.oldRecord + " n " + row.newRecord + " t " + row.tempRecord + "]";
        }
#endif
            
            
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\irtldbg.cpp ===
//------------------------------------------------------------------------------
// <copyright file="IRtlDbg.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IRtlDbg.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include <stdafx.h>

#if SUPPORT_OCI7_COMPONENTS

#include ".\import\lkrhash\src\irtldbg.cpp"

#endif // SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\debug.h ===
//-----------------------------------------------------------------------------
// File:		Debug.h
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Definition/Declaration of Debug tools
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __DEBUG_H_
#define __DEBUG_H_

#include <crtdbg.h>

void DBGTRACE(const wchar_t *format,	... );

#endif //__DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\debug.cpp ===
//-----------------------------------------------------------------------------
// File:		Debug.cpp
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of Debug tools
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

void DBGTRACE(
	const wchar_t *format, 	//@parm IN | Format string, like printf.
	... )					//@parmvar IN | Any other arguments.
{
#ifndef NOTRACE
	wchar_t wszBuff[4096];
	int     cBytesWritten;
	va_list argptr;

	va_start( argptr, format );
	cBytesWritten = _vsnwprintf( wszBuff, NUMELEM(wszBuff), format, argptr );
	va_end( argptr );
	wszBuff[NUMELEM(wszBuff)-1] = L'\0';	// guarantee null termination

	// Leave as Unicode
	OutputDebugStringW( wszBuff );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\cdawrapper.cpp ===
//-----------------------------------------------------------------------------
// File:		CdaWrapper.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of helper routines for CdaWrapper
//
// Comments: 	We use an LKRhash table as the hash table which stores
//				all known transacted CDAs; non-transacted CDAs are not
//				stored since there isn't any reason to track them.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#if SUPPORT_OCI7_COMPONENTS


class CdaHashTable
    : public LKRhash::CTypedHashTable<CdaHashTable, CdaWrapper, INT_PTR, LKRhash::CLKRHashTable>
{
private:
    // Private copy ctor and op= to prevent compiler synthesizing them.
    CdaHashTable(const CdaHashTable&);
    CdaHashTable& operator=(const CdaHashTable&);

public:
    CdaHashTable()
        : LKRhash::CTypedHashTable<CdaHashTable, CdaWrapper, INT_PTR, LKRhash::CLKRHashTable>("cdawrapper")
    {}


    static INT_PTR	ExtractKey(const CdaWrapper* pRecord)					{ return (INT_PTR)pRecord->m_pUsersCda; }
	static DWORD	CalcKeyHash(INT_PTR key) 							{ return HashFn::Hash((int)key); }
    static bool		EqualKeys(const INT_PTR key1, const INT_PTR key2)	{ return (key1 == key2); }
    static void		AddRefRecord(const CdaWrapper* pRecord, int nIncr) 	{ /* do nothing yet */ }
};

CdaHashTable*	s_CdaHashTable = NULL;

//-----------------------------------------------------------------------------
// ConstructCdaWrapperTable
//
//	construct the hash table of CdaWrapper objects
//
HRESULT ConstructCdaWrapperTable()
{
	if (NULL == s_CdaHashTable)
		s_CdaHashTable = new CdaHashTable();

	if (NULL == s_CdaHashTable)
		return E_OUTOFMEMORY;

	return S_OK;
}

//-----------------------------------------------------------------------------
// DestroyCdaWrapperTable
//
//	destroy the hash table of CdaWrapper objects
//
void DestroyCdaWrapperTable()
{
	if (NULL != s_CdaHashTable) 
	{
		delete s_CdaHashTable;
		s_CdaHashTable = NULL;
	}
}

//-----------------------------------------------------------------------------
// AddCdaWrapper
//
//	adds a new CdaWrapper to the CdaWrapper hash table
//
HRESULT AddCdaWrapper(CdaWrapper* pCda)
{
	_ASSERT (NULL != s_CdaHashTable);
	_ASSERT (NULL != pCda);
	
	LKRhash::LK_RETCODE rc = s_CdaHashTable->InsertRecord(pCda);

	if (LKRhash::LK_SUCCESS == rc)
		return S_OK;

	return E_FAIL;	// TODO: ERROR HANDLING
}

//-----------------------------------------------------------------------------
// FindCdaWrapper
//
//	locates the CdaWrapper for the specified CDA pointer in the CdaWrapper 
//	hash table
//
CdaWrapper* FindCdaWrapper(struct cda_def* pcda)
{
	_ASSERT (NULL != s_CdaHashTable);
	_ASSERT (NULL != pcda);
	
	CdaWrapper*	pCda = NULL;
	
	LKRhash::LK_RETCODE rc = s_CdaHashTable->FindKey((INT_PTR)pcda, &pCda);

	if (LKRhash::LK_SUCCESS != rc)
		pCda = NULL;

	return pCda;
}

//-----------------------------------------------------------------------------
// RemoveCdaWrapper
//
//	remove an existing CdaWrapper from the CdaWrapper hash table
//
void RemoveCdaWrapper(CdaWrapper* pCda)
{
	_ASSERT (NULL != s_CdaHashTable);
	_ASSERT (NULL != pCda);

	LKRhash::LK_RETCODE rc = s_CdaHashTable->DeleteRecord(pCda);
	
	if (LKRhash::LK_SUCCESS == rc)
	{
		if (NULL != pCda->m_pResourceManagerProxy)
			pCda->m_pResourceManagerProxy->RemoveCursorFromList( pCda->m_pUsersCda );		 // on the odd chance this is a CDA, not an LDA
	}

	delete pCda;
}

#endif //SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\cdawrapper.h ===
//-----------------------------------------------------------------------------
// File:		CdaWrapper.h
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Declaration of CdaWrapper class and helper methods
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#if SUPPORT_OCI7_COMPONENTS

#include "ResourceManagerProxy.h"

struct CdaWrapper 
{
public:
	IResourceManagerProxy *	m_pResourceManagerProxy;	// where to send the requests; will be NULL for un-enlisted connections.
	struct cda_def*			m_pUsersCda;				// the user's LDA/CDA

	CdaWrapper(Cda_Def* pcda)
	{
		m_pUsersCda				= pcda;
		m_pResourceManagerProxy = NULL;
	}

	CdaWrapper(IResourceManagerProxy* pResourceManagerProxy, struct cda_def *pcda)
	{
		m_pUsersCda				= pcda;

		if (pResourceManagerProxy)
			pResourceManagerProxy->AddRef();	
		
	 	m_pResourceManagerProxy = pResourceManagerProxy;
	}

	~CdaWrapper()
	{
		if (NULL != m_pResourceManagerProxy)
			m_pResourceManagerProxy->Release();
		
		m_pResourceManagerProxy = NULL;
		m_pUsersCda				= NULL;
	} 
};

HRESULT ConstructCdaWrapperTable();					// construct the hash table of CdaWrapper objects
void DestroyCdaWrapperTable();						// destroy the hash table of CdaWrapper objects

HRESULT AddCdaWrapper(CdaWrapper* pCda);				// adds a new CdaWrapper to the CdaWrapper hash table
CdaWrapper* FindCdaWrapper(struct cda_def* pcda);		// locates the CdaWrapper for the specified CDA pointer in the CdaWrapper hash table
void RemoveCdaWrapper(CdaWrapper* pCda);			// remove an existing CdaWrapper from the CdaWrapper hash table

#endif //SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\lkrhash.cpp ===
//------------------------------------------------------------------------------
// <copyright file="LKRHash.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   LKRHash.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include <stdafx.h>

#if SUPPORT_OCI7_COMPONENTS

#include ".\import\lkrhash\src\lkrhash.cpp"

#endif // SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\logevent.h ===
//-----------------------------------------------------------------------------
// File:		LogEvent.h
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Event Logging Helper Methods
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __LOGEVENT_H_
#define __LOGEVENT_H_


void LogEvent(DWORD dwMessageId, short cStrings, wchar_t* rgwzStrings[]);

inline void LogEvent_ExceptionInXACall(wchar_t * wzName)
{
	// Deal with exceptions that occur when calling into Oracle's XA methods

	short		cStrings = 1;
	wchar_t*	rgwzStrings[] = {&wzName[0]};

	DBGTRACE(L"\tMTXOCI8: TID=%03x\t\tlogging event: message id=%d (Exception in XA Call) name=%s\n", GetCurrentThreadId(), IDS_E_EXCEPTION_IN_XA_CALL, wzName);
	
	LogEvent(IDS_E_EXCEPTION_IN_XA_CALL, cStrings, rgwzStrings);
}

inline void LogEvent_ResourceManagerError(wchar_t * wzName, DWORD xarc)
{
	// Deal with exceptions that occur when calling into Oracle's XA methods

	short		cStrings = 2;
	wchar_t		wzErrorCode[100];
	wchar_t*	rgwzStrings[] = {&wzName[0], &wzErrorCode[0]};

	wsprintfW(wzErrorCode, L"%d", xarc);	//3 SECURITY REVIEW: dangerous function, but buffer is large enough

	DBGTRACE(L"\tMTXOCI8: TID=%03x\t\tlogging event: message id=%d (Resource Manager returned error) name=%s rc=%d\n", GetCurrentThreadId(), IDS_E_RESOURCE_MANAGER_ERROR, wzName, xarc);
	
	LogEvent(IDS_E_RESOURCE_MANAGER_ERROR, cStrings, rgwzStrings);
}

inline void LogEvent_InternalError(wchar_t * wzDescription)
{
	// Deal with exceptions that occur when calling into Oracle's XA methods

	short		cStrings = 1;
	wchar_t*	rgwzStrings[] = {&wzDescription[0]};

	DBGTRACE(L"\tMTXOCI8: TID=%03x\t\tlogging event: message id=%d (Internal Error) description=%s\n", GetCurrentThreadId(), IDS_E_INTERNAL_ERROR, wzDescription);
	
	LogEvent(IDS_E_INTERNAL_ERROR, cStrings, rgwzStrings);
}

inline void LogEvent_UnexpectedEvent(wchar_t * wzCurrentState, wchar_t* wzEvent)
{
	// Deal with exceptions that occur when calling into Oracle's XA methods

	short		cStrings = 2;
	wchar_t*	rgwzStrings[] = {&wzCurrentState[0], &wzEvent[0] };

	DBGTRACE(L"\tMTXOCI8: TID=%03x\t\tlogging event: message id=%d (Unexpected Event or Event Occured Out Of Order) currentState=%s event=%s\n", GetCurrentThreadId(), IDS_E_UNEXPECTED_EVENT, wzCurrentState, wzEvent);
	
	LogEvent(IDS_E_UNEXPECTED_EVENT, cStrings, rgwzStrings);
}

#endif // __LOGEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\locks.cpp ===
//------------------------------------------------------------------------------
// <copyright file="Locks.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Locks.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include <stdafx.h>

#if SUPPORT_OCI7_COMPONENTS

#include ".\import\lkrhash\src\locks.cpp"

#endif // SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\logevent.cpp ===
//-----------------------------------------------------------------------------
// File:		LogEvent.cpp
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Event Logging Helper Methods
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

void LogEvent(DWORD dwMessageId, short cStrings, wchar_t* rgwzStrings[])
{
	HANDLE	hEventLog = NULL;

	hEventLog = RegisterEventSourceW(NULL, L"MSDTC to Oracle8 XA Bridge Version 1.5") ;

	if (hEventLog)
	{
		ReportEventW(hEventLog,
						EVENTLOG_ERROR_TYPE,
						0,		// define categories?  I don't think we need them, but...
						dwMessageId,
						NULL,
						cStrings,
						0,
						(LPCWSTR *) rgwzStrings,
						NULL
						);

		DeregisterEventSource(hEventLog);
	}
//	DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\mtxoci8.h ===
//-----------------------------------------------------------------------------
// File:		mtxoci8.h
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Global Definitions and Declarations for the MTxOCI8
//				component
//
// Comments: 	You must change mtxoci8.def to effect changes in which
//				components you support, see the comments in that file.
//
//-----------------------------------------------------------------------------

#ifndef __MTXOCI8_H_
#define __MTXOCI8_H_

//---------------------------------------------------------------------------
// Compile-time Configuration
//
#define SUPPORT_DTCXAPROXY			0		// set this to 1 if you want to enable distributed transaction support using the DTC 2 XA Proxy
#define SUPPORT_OCI7_COMPONENTS		0		// set this to 1 if you want to enable support for MSORCL32 and MSDAORA
#define SUPPORT_OCI8_COMPONENTS		1		// set this to 1 if you want to enable support for System.Data.OracleClient
#define SINGLE_THREAD_THRU_XA		0		// set this to 1 if you want to turn on single threading through XA, for debugging purposes.

#if SUPPORT_DTCXAPROXY
//---------------------------------------------------------------------------
// Constants/Macros
//
const DWORD	MTXOCI_VERSION_CURRENT		=	(DWORD)3;

#define MAX_XA_DBNAME_SIZE		36	//sizeof("6B29FC40-CA47-1067-B31D-00DD010662DA");
#define MAX_XA_OPEN_STRING_SIZE	255

#define	OCI_FAIL		E_FAIL
#define	OCI_OUTOFMEMORY	E_OUTOFMEMORY

#define NUMELEM(x)	(sizeof(x) / sizeof(x[0]) )

//---------------------------------------------------------------------------
// Global Variables
//
struct OCICallEntry
{
	CHAR *	pfnName;
	FARPROC	pfnAddr;
} ;


//---------------------------------------------------------------------------
// Global Variables
//
extern HRESULT						g_hrInitialization;
extern char							g_szModulePathName[];
extern char*						g_pszModuleFileName;
extern IDtcToXaHelperFactory*		g_pIDtcToXaHelperFactory;
extern IResourceManagerFactory*		g_pIResourceManagerFactory;
extern xa_switch_t*					g_pXaSwitchOracle;
extern OCICallEntry					g_XaCall[];
extern long							g_rmid;
extern int							g_oracleClientVersion;				// Major Version Number of Oracle Client Software: 7, 8, 9

// values for g_oracleClientVersion
enum {
	ORACLE_VERSION_73 = 73,
	ORACLE_VERSION_80 = 80,
	ORACLE_VERSION_8i = 81,
	ORACLE_VERSION_9i = 91,
};


#if SINGLE_THREAD_THRU_XA
extern CRITICAL_SECTION				g_csXaInUse;
#endif //SINGLE_THREAD_THRU_XA

//---------------------------------------------------------------------------
// Function Declarations
//

HRESULT GetDbName ( char* dbName, size_t dbNameLength );
HRESULT GetOpenString ( char* userId,	int userIdLength,
							char* password,	int passwordLength, 
							char* server,	int serverLength, 
							char* xaDbName,	int xaDbNameLength,
							char* xaOpenString );
HRESULT LoadFactories();


#if SUPPORT_OCI7_COMPONENTS
//---------------------------------------------------------------------------
// OCI7 related items
//
extern OCICallEntry					g_SqlCall[];
extern OCICallEntry 				g_Oci7Call[];
extern int 							g_numOci7Calls;

sword GetOCILda ( struct cda_def* lda, char * xaDbName );

extern sword Do_Oci7Call(int idxOciCall, void * pvCallStack, int cbCallStack);
#endif // SUPPORT_OCI7_COMPONENTS


#if SUPPORT_OCI8_COMPONENTS
//---------------------------------------------------------------------------
// OCI8 related items
//
extern OCICallEntry 				g_Oci8Call[];
extern int 							g_numOci8Calls;

INT_PTR GetOCIEnvHandle		( char*	i_pszXADbName );
INT_PTR GetOCISvcCtxHandle	( char*	i_pszXADbName );
#endif // SUPPORT_OCI8_COMPONENTS


//---------------------------------------------------------------------------
// Oracle XA Call Interface function table
//
//	WARNING!!!	Keep the IDX_.... values in sync with g_XaCall, g_SqlCall, g_Oci7Call and g_Oci8Call!

enum {
	IDX_xaosw = 0,
	IDX_xaoEnv,
	IDX_xaoSvcCtx,

#if SUPPORT_OCI7_COMPONENTS
	IDX_sqlld2 = 0,

	IDX_obindps = 0,
	IDX_obndra,
	IDX_obndrn,
	IDX_obndrv,
	IDX_obreak,
	IDX_ocan,
	IDX_oclose,
	IDX_ocof,
	IDX_ocom,
	IDX_ocon,
	IDX_odefin,
	IDX_odefinps,
	IDX_odessp,
	IDX_odescr,
	IDX_oerhms,
	IDX_oermsg,
	IDX_oexec,
	IDX_oexfet,
	IDX_oexn,
	IDX_ofen,
	IDX_ofetch,
	IDX_oflng,
	IDX_ogetpi,
	IDX_olog,
	IDX_ologof,
	IDX_oopt,
	IDX_oopen,
	IDX_oparse,
	IDX_opinit,
	IDX_orol,
	IDX_osetpi,
#endif //SUPPORT_OCI7_COMPONENTS

#if SUPPORT_OCI8_COMPONENTS
	IDX_OCIInitialize = 0,
	IDX_OCIDefineDynamic,
#endif //SUPPORT_OCI8_COMPONENTS
	};

#endif //SUPPORT_DTCXAPROXY

#endif // __MTXOCI8_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\oci7support.cpp ===
//-----------------------------------------------------------------------------
// File:		Oci7Support.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of Oci7 wrapper functions
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#if SUPPORT_OCI7_COMPONENTS

#define TRACE_BAD_CDA()		// define something to trace when the LDA/CDA provided is bogus.

//-----------------------------------------------------------------------------
// Do_Oci7Call
//
//	Does all the work to make the call int OCI, once it's determined that we're
//	on the correct thread, etc.
//
sword Do_Oci7Call(
		int				idxOciCall,
		void*			pvCallStack,
		int				cbCallStack)
{
	typedef sword (__cdecl * PFN_OCI_API) (void);

	PFN_OCI_API	pfnOCIApi	= NULL;
	void*		pv 			= NULL;
	int			swRet		= OCI_FAIL;		

	if (idxOciCall >= 0 && idxOciCall < g_numOci7Calls)
		pfnOCIApi = (PFN_OCI_API)g_Oci7Call[idxOciCall].pfnAddr;
	
	if (pfnOCIApi)
	{
		if (0 < cbCallStack)
		{
			//make space on the call stack
			pv = _alloca (cbCallStack);

			if (NULL == pv)
			{
				swRet = OCI_OUTOFMEMORY;
				goto done;
			}

			//copy the previous call stack to the new call stack
			memcpy (pv, pvCallStack, cbCallStack);	//3 SECURITY REVIEW: dangerous function, but we're using the same value we passed to the allocator above.
		}
		swRet = pfnOCIApi();
	}
	
done:
	return swRet;	
}

//-----------------------------------------------------------------------------
// MakeOci7Call
//
//	Examines the Cda Wrapper and determines whether this call should be made on
//	the resource manager proxies thread or on the current thread, and takes the
//	appropriate action to effect the call.
//
static sword MakeOci7Call(
		CdaWrapper *	pCda,
		int				idxOciCall,
		void*			pvCallStack,
		int				cbCallStack)
{
	int swRet;
	
	if (NULL == pCda || NULL == pCda->m_pResourceManagerProxy)
		swRet = Do_Oci7Call(idxOciCall, pvCallStack, cbCallStack);
	else 
		swRet = pCda->m_pResourceManagerProxy->Oci7Call (idxOciCall,pvCallStack,cbCallStack);

	return swRet;
}

//-----------------------------------------------------------------------------
// GetOCILda
//
//	Connects the LDA the caller specified with the transaction.
//
sword GetOCILda ( struct cda_def* lda, char * xaDbName )
{
	typedef void __cdecl PFN_OCI_API (struct cda_def *lda, text *cname, sb4 *cnlen);
	PFN_OCI_API*	pfnOCIApi = (PFN_OCI_API*)g_SqlCall[IDX_sqlld2].pfnAddr;

	int		lVal= -1;
	memset(lda,0,sizeof(struct cda_def));		//3 SECURITY REVIEW: this is safe
	pfnOCIApi(lda, (text *)xaDbName, &lVal);
	return lda->rc;
}

//-----------------------------------------------------------------------------
// RegisterCursorForLda
//
//	Used by oopen and MTxOCIRegisterCursor, does the work of managing the 
//	hash table entries for the cursor to ensure that all transacted cursors
//	are connected to the resource manager proxy.
//
static sword RegisterCursorForLda
		(
			CdaWrapper**	 ppCda,
			struct cda_def * lda,	
			struct cda_def * cursor
		)
{
	HRESULT hr = S_OK;
	
	if (NULL == cursor)
	{
		hr = OCI_FAIL;
		goto done;
	}

	// Non-transacted CDA's don't have a wrapper, so we need to make
	// sure that they're not re-using an existing CDA, and remove it
	// from the hash table if they are.
	CdaWrapper* pCda = FindCdaWrapper(cursor);

	if (NULL != pCda)
	{
		_ASSERT (pCda->m_pUsersCda == cursor);
 		RemoveCdaWrapper (pCda);
 		pCda = NULL;
	}

	// Transacted LDAs will have a wrapper, and if we find a wrapper
	// for the LDA provided, we have to wrap the the CDA we're creating
	// too or we won't know to use the proxy thread for calls that use
	// it.
	CdaWrapper*	pLda = FindCdaWrapper(lda);

	if (NULL != pLda && NULL != pLda->m_pResourceManagerProxy)
		hr = pLda->m_pResourceManagerProxy->AddCursorToList( cursor );

done:
	return hr;
}

//-----------------------------------------------------------------------------
// MTxOciInit
//
//	This returns the initilization state of the dll
//
sword __cdecl MTxOciInit (void)
{
	sword swRet = OCI_FAIL;

	if (S_OK == g_hrInitialization)
		swRet = OCI_SUCCESS;

	return swRet;
}

//-----------------------------------------------------------------------------
// MTxOciRegisterCursor
//
//	Register a cursor (ostensibly from a REF CURSOR binding) as belonging to a 
//	specific transacted LDA.
//
sword MTxOciRegisterCursor
		(
			struct cda_def * lda,	
			struct cda_def * cursor		
		)
{
	CdaWrapper* pCda = NULL;
	return RegisterCursorForLda(&pCda, lda, cursor);
}

//-----------------------------------------------------------------------------
// Enlist
//
//	Enlist the connection in the specified transaction.
//
sword __cdecl Enlist ( Lda_Def* lda, void * pvITransaction )
{
	sword 		rc;
	
	if (NULL == pvITransaction)
	{
		rc = OCI_FAIL;
		goto done;
	}
	
	CdaWrapper*	pLda = FindCdaWrapper(lda);
	
	if (NULL == pLda)
	{
		TRACE_BAD_CDA();
		rc = OCI_FAIL;
		goto done;
	}

	IResourceManagerProxy*	pIResourceManagerProxy = pLda->m_pResourceManagerProxy;
	
	if (NULL == pIResourceManagerProxy)
	{
		TRACE_BAD_CDA();
		rc = OCI_FAIL;
		goto done;
	}

	rc = pIResourceManagerProxy->OKToEnlist();

	if (OCI_SUCCESS == rc)
	{
		pIResourceManagerProxy->SetTransaction((ITransaction*)pvITransaction);
		pIResourceManagerProxy->SetLda(pLda->m_pUsersCda);
		rc = pIResourceManagerProxy->ProcessRequest(REQUEST_ENLIST, FALSE);
	}
	
done:
	return rc;
}

//-----------------------------------------------------------------------------
sword __cdecl obindps (
				struct cda_def *cursor,		ub1 opcode,		text *sqlvar, 
				sb4 sqlvl,					ub1 *pvctx,		sb4 progvl, 
				sword ftype,				sword scale,
				sb2 *indp,					ub2 *alen,		ub2 *arcode, 
				sb4 pv_skip,				sb4 ind_skip,	sb4 alen_skip, sb4 rc_skip,
				ub4 maxsiz,					ub4 *cursiz,
				text *fmt,					sb4 fmtl,		sword fmtt
				)
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (text *) * 2)
							+ (sizeof (ub1)) 
							+ (sizeof (ub1 *))
							+ (sizeof (ub4 *)) 
							+ (sizeof (ub4)) 
							+ (sizeof (sword) * 3) 
							+ (sizeof (sb4) * 7) 
							+ (sizeof (ub2 *) * 2) 
							+ (sizeof (sb2 *));

	return MakeOci7Call(pCda, IDX_obindps, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl obndra ( struct cda_def *cursor, text *sqlvar, sword sqlvl,
						 ub1 *progv, sword progvl, sword ftype, sword scale,
						 sb2 *indp, ub2 *alen, ub2 *arcode, ub4 maxsiz,
						 ub4 *cursiz, text *fmt, sword fmtl, sword fmtt )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (ub1 *)) 
							+ (sizeof (sb2 *)) 
							+ (sizeof (sword) * 6) 
							+ (sizeof (ub2 *) * 2) 
							+ (sizeof (text *) * 2) 
							+ (sizeof (ub4)) 
							+ (sizeof (ub4 *));
	
	return MakeOci7Call(pCda, IDX_obndra, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl obndrn ( struct cda_def *cursor, sword sqlvn, ub1 *progv,
						 sword progvl, sword ftype, sword scale, sb2 *indp,
						 text *fmt, sword fmtl, sword fmtt )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (ub1 *)) 
							+ (sizeof (sb2 *))
							+ (sizeof (sword) * 6)
							+ (sizeof (text *));

	return MakeOci7Call(pCda, IDX_obndrn, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl obndrv ( struct cda_def *cursor, text *sqlvar, sword sqlvl,
						 ub1 *progv, sword progvl, sword ftype, sword scale,
						 sb2 *indp, text *fmt, sword fmtl, sword fmtt )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (ub1 *)) 
							+ (sizeof (sb2 *))
							+ (sizeof (sword) * 6)
							+ (sizeof (text *) * 2);

	return MakeOci7Call(pCda, IDX_obndrv, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl obreak ( struct cda_def *lda )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_obreak, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ocan ( struct cda_def *cursor )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_ocan, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oclose ( struct cda_def *cursor )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *);

	sword		swRet = MakeOci7Call(pCda, IDX_oclose, &cursor, cbCallStack);

	if (NULL != pCda)
	{
 		_ASSERT (pCda->m_pUsersCda == cursor);
 		RemoveCdaWrapper (pCda);
  	}
	return swRet;
}
//-----------------------------------------------------------------------------
sword __cdecl ocof ( struct cda_def *cursor )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_ocof, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ocom ( struct cda_def *lda )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_ocom, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ocon ( struct cda_def *lda )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_ocon, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl odefin ( struct cda_def *cursor, sword pos, ub1 *buf,
						  sword bufl, sword ftype, sword scale, sb2 *indp,
						  text *fmt, sword fmtl, sword fmtt, ub2 *rlen, ub2 *rcode )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (sword) * 6)
							+ (sizeof (ub1 *)) 
							+ (sizeof (sb2 *))
							+ (sizeof (text *)) 
							+ (sizeof (ub2 *) * 2);
	
	return MakeOci7Call(pCda, IDX_odefin, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl odefinps 
		(
			struct cda_def *cursor, ub1 opcode,		sword pos,		ub1 *bufctx,
			sb4 bufl,				sword ftype,	sword scale, 
			sb2 *indp,				text *fmt,		sb4 fmtl,		sword fmtt, 
			ub2 *rlen,				ub2 *rcode,
			sb4 pv_skip,			sb4 ind_skip,	sb4 alen_skip,	sb4 rc_skip
		)
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (text *))
							+ (sizeof (ub1)) 
							+ (sizeof (ub1 *))
							+ (sizeof (sb4 *) * 6) 
							+ (sizeof (sword) * 4)
							+ (sizeof (sb2 *)) 
							+ (sizeof (ub2 *) * 2);
	
	return MakeOci7Call(pCda, IDX_odefinps, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl odessp
				(
				struct cda_def * lda,			text *objnam,	size_t onlen,
				ub1 *rsv1,		size_t rsv1ln,	ub1 *rsv2,		size_t rsv2ln,
				ub2 *ovrld,		ub2 *pos,		ub2 *level,		text **argnam,
				ub2 *arnlen,	ub2 *dtype,		ub1 *defsup,	ub1* mode,
				ub4 *dtsiz,		sb2 *prec,		sb2 *scale,		ub1* radix,
				ub4 *spare,		ub4 *arrsiz
				)
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (text *))
							+ (sizeof (size_t) * 3) 
							+ (sizeof (ub1 *) * 5)
							+ (sizeof (ub4 *) * 3) 
							+ sizeof (text **)
							+ (sizeof (sb2 *) * 2) 
							+ (sizeof (ub2 *) * 5);
	
	return MakeOci7Call(pCda, IDX_odessp, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl odescr 
				(
				struct cda_def *cursor, sword pos, sb4 *dbsize,
				sb2 *dbtype, sb1 *cbuf, sb4 *cbufl, sb4 *dsize,
				sb2 *prec, sb2 *scale, sb2 *nullok
				)
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (sword)) 
							+ (sizeof (sb4 *) * 3)
							+ (sizeof (sb2 *) * 4) 
							+ (sizeof (sb1 *));
	
	return MakeOci7Call(pCda, IDX_odescr, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oerhms ( struct cda_def *lda, sb2 rcode, text *buf,
							sword bufsiz )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ sizeof (sb2) 
							+ sizeof (text *) 
							+ sizeof (sword);
	
	return MakeOci7Call(pCda, IDX_oerhms, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oermsg ( sb2 rcode, text *buf )
{
	int			cbCallStack	= sizeof (sb2)
							+ sizeof (text *);

	return Do_Oci7Call(IDX_oermsg, &rcode, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oexec ( struct cda_def *cursor )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_oexec, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oexfet ( struct cda_def *cursor, ub4 nrows,
							sword cancel, sword exact )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (sword) * 2)
							+ sizeof (ub4);

	return MakeOci7Call(pCda, IDX_oexfet, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oexn ( struct cda_def *cursor, sword iters, sword rowoff )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ (sizeof (sword) * 2);

	return MakeOci7Call(pCda, IDX_oexn, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ofen ( struct cda_def *cursor, sword nrows )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *) 
							+ sizeof (sword);

	return MakeOci7Call(pCda, IDX_ofen, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ofetch ( struct cda_def *cursor )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_ofetch, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oflng ( struct cda_def *cursor, sword pos, ub1 *buf,
							sb4 bufl, sword dtype, ub4 *retl, sb4 offset )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (ub1 *)) 
							+ (sizeof(sword) * 2)
							+ (sizeof(ub4 *)) 
							+ (sizeof (sb4) * 2);
	
	return MakeOci7Call(pCda, IDX_oflng, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ogetpi ( struct cda_def *cursor, ub1 *piecep, dvoid **ctxpp, 
		                 ub4 *iterp, ub4 *indexp )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ sizeof (ub1 *)  
							+ (sizeof(dvoid **))
							+ (sizeof(ub4 *) * 2);
	
	return MakeOci7Call(pCda, IDX_ogetpi, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl ologTransacted ( 
				    	struct cda_def *lda, ub1 *	hda,
						text * uid, sword uidl,
						text * pswd, sword pswdl, 
						text * conn, sword connl, 
						ub4 mode, BOOL fTransacted )
{
	HRESULT		hr = S_OK;
	int			cbCallStack	= sizeof (struct cda_def *)
							+ sizeof (ub1 *)  
							+ (sizeof(text*)*3)
							+ (sizeof(sword)*3)
							+ (sizeof(ub4));

	if (!fTransacted)
	{
		// Non-transacted LDA's don't have a wrapper, so we need to make
		// sure that they're not re-using an existing LDA, and remove it
		// from the hash table if they are.
		CdaWrapper* pLda = FindCdaWrapper(lda);

		if (NULL != pLda)
		{
			RemoveCdaWrapper(pLda);
 			pLda = NULL;
		}
		hr = MakeOci7Call(NULL, IDX_olog, &lda, cbCallStack);
	}
	else
	{
		IDtcToXaHelper*	pIDtcToXaHelper;
		CdaWrapper* 	pLda = new CdaWrapper(lda);
		UUID			uuidRmId;
		char			xaOpenString[MAX_XA_OPEN_STRING_SIZE+1];
		char			xaDbName[MAX_XA_DBNAME_SIZE+1];
		
		if (NULL == pLda)
		{
			hr = OCI_OUTOFMEMORY;
			goto done;
		}
	
		long rmid = InterlockedIncrement(&g_rmid);

		// Get the ResourceManager factory if it does not exist; don't 
		// lock unless it's NULL so we don't single thread through here.
		if (NULL == g_pIResourceManagerFactory)
		{
			hr = LoadFactories();
			
			if ( FAILED(hr) )
				goto done;
		}

		hr = GetDbName(xaDbName, sizeof(xaDbName));

		if (S_OK == hr)
		{
			hr = GetOpenString(	(char*)uid,		uidl,
								(char*)pswd,	pswdl,
								(char*)conn,	connl,
								xaDbName,	MAX_XA_DBNAME_SIZE,
								xaOpenString);

			if (S_OK == hr)
			{
				// Now create the DTC to XA Helper object
				hr = g_pIDtcToXaHelperFactory->Create (	(char*)xaOpenString, 
														g_pszModuleFileName,
														&uuidRmId,
														&pIDtcToXaHelper
														);

				if (S_OK == hr)
				{
					// Create the ResourceManager proxy object for this connection
					hr = CreateResourceManagerProxy (
													pIDtcToXaHelper,
													&uuidRmId,
													(char*)xaOpenString,
													(char*)xaDbName,
													rmid,
													&pLda->m_pResourceManagerProxy
													);

					if (S_OK == hr)
					{
						hr = pLda->m_pResourceManagerProxy->ProcessRequest(REQUEST_CONNECT, FALSE);
					}
				}
			}
		}
	
		hr = AddCdaWrapper(pLda);
	}
	
done:
	return hr;
}
//-----------------------------------------------------------------------------
sword __cdecl olog ( struct cda_def *lda, ub1 *	hda,
						text * uid, sword uidl,
						text * pswd, sword pswdl, 
						text * conn, sword connl, 
						ub4 mode )
{
	return ologTransacted(lda, hda, uid, uidl, pswd, pswdl, conn, connl, mode, FALSE);
}
//-----------------------------------------------------------------------------
sword __cdecl ologof ( struct cda_def *lda )
{
	CdaWrapper*	pLda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *);
	sword 		swRet;

	if (NULL == pLda || NULL == pLda->m_pResourceManagerProxy)
		swRet = MakeOci7Call(pLda, IDX_ologof, &lda, cbCallStack);
	else
		swRet = pLda->m_pResourceManagerProxy->ProcessRequest(REQUEST_DISCONNECT, FALSE);

	if (NULL != pLda)
 		RemoveCdaWrapper(pLda);

 	return swRet;
}
//-----------------------------------------------------------------------------
sword __cdecl oopt ( struct cda_def *cursor, sword rbopt, sword waitopt )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (sword) * 2);
	
	return MakeOci7Call(pCda, IDX_oopt, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl oopen ( struct cda_def *cursor, struct cda_def *lda,
							text *dbn, sword dbnl, sword arsize,
							text *uid, sword uidl )
{
	HRESULT		hr			= S_OK;
	int			cbCallStack	= (sizeof (struct cda_def *) * 2)
							+ (sizeof (text *) * 2)
							+ (sizeof (sword) * 3);

	CdaWrapper* pCda = NULL;
	hr = RegisterCursorForLda(&pCda, lda, cursor);

	if ( SUCCEEDED(hr) )
		hr = MakeOci7Call(pCda, IDX_oopen, &cursor, cbCallStack);

	return hr;
}
//-----------------------------------------------------------------------------
sword __cdecl oparse ( struct cda_def *cursor, text *sqlstm, sb4 sqllen,
							sword defflg, ub4 lngflg )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (text *)) 
							+ (sizeof (sword))
							+ (sizeof (ub4)) 
							+ (sizeof (sb4));
	
	return MakeOci7Call(pCda, IDX_oparse, &cursor, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl opinit ( ub4 mode )
{
	return OCI_SUCCESS;	// initialized in dll main
}
//-----------------------------------------------------------------------------
sword __cdecl orol ( struct cda_def *lda )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(lda);
	int			cbCallStack	= sizeof (struct cda_def *);

	return MakeOci7Call(pCda, IDX_orol, &lda, cbCallStack);
}
//-----------------------------------------------------------------------------
sword __cdecl osetpi ( struct cda_def *cursor, ub1 piece, dvoid *bufp, ub4 *lenp )
{
	CdaWrapper*	pCda 		= FindCdaWrapper(cursor);
	int			cbCallStack	= sizeof (struct cda_def *)
							+ (sizeof (ub1)) 
							+ (sizeof (dvoid *))
							+ (sizeof (ub4 *));
	
	return MakeOci7Call(pCda, IDX_osetpi, &cursor, cbCallStack);
}
#endif //SUPPORT_OCI7_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\mtxoci8.cpp ===
//-----------------------------------------------------------------------------
// File:		mtxoci8.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of DLL startup code and the 
//				core entry points
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

// Helper function
inline IsWin95(DWORD dwVer)
{
	return ((LOBYTE(LOWORD(dwVer)) >= 4) && (HIWORD(dwVer) & 0x8000));
}

#if SUPPORT_DTCXAPROXY
//-----------------------------------------------------------------------------
// global objects
//
HRESULT							g_hrInitialization = E_UNEXPECTED;	// set to the HR we should return when OCI hasn't been initialized (or S_OK if it has)
char							g_szModulePathName[MAX_PATH+1];		// full path to ourself.
char*							g_pszModuleFileName;				// just the filename portion
IDtcToXaHelperFactory*			g_pIDtcToXaHelperFactory = NULL;	// factory to create IDtcToXaHelper objects
IResourceManagerFactory*		g_pIResourceManagerFactory = NULL;	// factory to create IResourceManager objects
xa_switch_t*					g_pXaSwitchOracle = NULL;			// Oracle's xa_switch_t, which we front-end.
int								g_oracleClientVersion = 0;			// Major Version Number of Oracle Client Software: 73, 80, 81, 90


#if SINGLE_THREAD_THRU_XA
CRITICAL_SECTION				g_csXaInUse;						// force single thread through XA at a time
#endif //SINGLE_THREAD_THRU_XA

//---------------------------------------------------------------------------
// Oracle XA Call Interface function table
//
//	WARNING!!!	Keep the IDX_.... values in sync with g_XaCall, g_Oci7Call and g_Oci8Call!

OCICallEntry g_XaCall[] =
{
	{	"xaosw",					0 },
	{	"xaoEnv",					0 },
	{	"xaoSvcCtx",				0 },
};

#if SUPPORT_OCI7_COMPONENTS
OCICallEntry g_SqlCall[] =
{
	{	"sqlld2",					0 },
};

OCICallEntry g_Oci7Call[] =
{
	{	"obindps",					0 },
	{	"obndra",					0 },
	{	"obndrn",					0 },
	{	"obndrv",					0 },
	{	"obreak",					0 },
	{	"ocan",						0 },
	{	"oclose",					0 },
	{	"ocof",						0 },
	{	"ocom",						0 },
	{	"ocon",						0 },
	{	"odefin",					0 },
	{	"odefinps",					0 },
	{	"odessp",					0 },
	{	"odescr",					0 },
	{	"oerhms",					0 },
	{	"oermsg",					0 },
	{	"oexec",					0 },
	{	"oexfet",					0 },
	{	"oexn",						0 },
	{	"ofen",						0 },
	{	"ofetch",					0 },
	{	"oflng",					0 },
	{	"ogetpi",					0 },
	{	"olog",						0 },
	{	"ologof",					0 },
	{	"oopt",						0 },
	{	"oopen",					0 },
	{	"oparse",					0 },
	{	"opinit",					0 },
	{	"orol",						0 },
	{	"osetpi",					0 },
};

int g_numOci7Calls = NUMELEM(g_Oci7Call);

#endif //SUPPORT_OCI7_COMPONENTS

OCICallEntry g_Oci8Call[] =
{
	{	"OCIInitialize",			0 },
	{	"OCIDefineDynamic",			0 },
};

int g_numOci8Calls = NUMELEM(g_Oci8Call);


//-----------------------------------------------------------------------------
// static objects
//
static CRITICAL_SECTION			s_csGlobal;

static char						s_OciDllFileName[MAX_PATH+1];
static HINSTANCE				s_hinstOciDll = NULL;

static char						s_XaDllFileName[MAX_PATH+1];
static HINSTANCE				s_hinstXaDll = NULL;

#if SUPPORT_OCI7_COMPONENTS

static char						s_SqlDllFileName[MAX_PATH+1];
static HINSTANCE				s_hinstSqlDll = NULL;

#endif //SUPPORT_OCI7_COMPONENTS

static xa_switch_t				s_XaSwitchMine =
										{
										"MSDTC to Oracle8 XA Bridge",
										TMNOMIGRATE,	// flags
										0L,  			// version  (must be zero)
										XaOpen,		// XA call handlers
										XaClose,
										XaStart,
										XaEnd,
										XaRollback,
										XaPrepare,
										XaCommit,
										XaRecover,
										XaForget,
										XaComplete
										};

static char*	s_EventLog_RegKey = "System\\CurrentControlSet\\Services\\EventLog\\Application\\MSDTC to Oracle8 XA Bridge Version 1.5";

	
// TODO: Consider: should we get the the file name of the DLL from a registry location as a fallback?  (or as a first choice?)

struct XADllInfo{
	int			oracleVersion;
	char*		xaDllName;
	char*		sqlLibDllName;
};

XADllInfo	s_Oci8xDllInfo[] = {
								//	oracleVersion		xaDllName			sqlLibDllName	
									{ORACLE_VERSION_9i,	"oraclient9.dll",	"orasql9.dll"},
									{ORACLE_VERSION_8i,	"oraclient8.dll",	"orasql8.dll"},
									{ORACLE_VERSION_80,	"xa80.dll",			"sqllib80.dll"},
								};
int			s_Oci8xDllInfoSize = NUMELEM(s_Oci8xDllInfo);

XADllInfo	s_Oci7xDllInfo[] = {
								//	oracleVersion		xaDllName			sqlLibDllName	
									{ORACLE_VERSION_73,	"xa73.dll",			"sqllib18.dll"},
								};
int			s_Oci7xDllInfoSize = NUMELEM(s_Oci7xDllInfo);

static struct {
	char*		ociDllName;
	int			xaDllInfoSize;
	XADllInfo*	xaDllInfo;
} s_DllNames[] = {
//	 ociDllName		xaDllInfoSize		xaDllInfo	
	{"oci.dll",		s_Oci8xDllInfoSize,	s_Oci8xDllInfo},
	{"ociw32.dll",	s_Oci7xDllInfoSize,	s_Oci7xDllInfo},
};


//-----------------------------------------------------------------------------
// LoadFactories 
//
//	Gets the ResourceManager factory and the DtcToXaHelper factory
//
HRESULT LoadFactories()
{
	HRESULT	hr;
	Synch	sync(&s_csGlobal);

	if (NULL == g_pIResourceManagerFactory)
	{
		hr = DtcGetTransactionManager( NULL, NULL,
										IID_IResourceManagerFactory, 
										0, 0, NULL, 
										(void**)&g_pIResourceManagerFactory);
		if (S_OK != hr)
			return hr;
	}
		
	if (NULL == g_pIDtcToXaHelperFactory)
	{
		hr = g_pIResourceManagerFactory->QueryInterface(
												IID_IDtcToXaHelperFactory,
												(void**)&g_pIDtcToXaHelperFactory);

		if (S_OK != hr)
			return hr;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// UnloadFactories 
//
//	releases the factories loaded in LoadFactories
//
void UnloadFactories()
{
	Synch	sync(&s_csGlobal);

	if (g_pIResourceManagerFactory)
	{
		g_pIResourceManagerFactory->Release();
		g_pIResourceManagerFactory = NULL;
	}
		
	if (g_pIDtcToXaHelperFactory)
	{
		g_pIDtcToXaHelperFactory->Release();
		g_pIDtcToXaHelperFactory = NULL;
	}
}


//-----------------------------------------------------------------------------
// InitializeOracle 
//
//	Calls the appropriate initialize method for the Oracle version that was
//	loaded...
//
BOOL InitializeOracle ()
{
	sword swRet = -1;

#if SUPPORT_OCI7_COMPONENTS
//	if (73 == g_oracleClientVersion)
//	{
		typedef sword (__cdecl * PFN_OCI_API) (ub4 mode );

		PFN_OCI_API	pfnOCIApi	= (PFN_OCI_API)g_Oci7Call[IDX_opinit].pfnAddr;

		if (NULL != pfnOCIApi)
			swRet = pfnOCIApi(OCI_EV_TSF);
//	}
#if SUPPORT_OCI8_COMPONENTS
	else
#endif //SUPPORT_OCI8_COMPONENTS
#endif //SUPPORT_OCI7_COMPONENTS
#if SUPPORT_OCI8_COMPONENTS
	{
		typedef sword (__cdecl * PFN_OCI_API) (ub4 mode, dvoid *ctxp, 
	                 dvoid *(*malocfp)(dvoid *ctxp, size_t size),
	                 dvoid *(*ralocfp)(dvoid *ctxp, dvoid *memptr, size_t newsize),
	                 void   (*mfreefp)(dvoid *ctxp, dvoid *memptr) );

		PFN_OCI_API	pfnOCIApi	= (PFN_OCI_API)g_Oci8Call[IDX_OCIInitialize].pfnAddr;

		if (NULL != pfnOCIApi)
			swRet = pfnOCIApi(OCI_THREADED|OCI_OBJECT,NULL,NULL,NULL,NULL);
	}
#endif //SUPPORT_OCI8_COMPONENTS
	return (0 == swRet) ? TRUE : FALSE;
}
 
//-----------------------------------------------------------------------------
// LoadOracleCalls 
//
//	Gets the proc addresses we need from the loaded oracle dll.  Returns TRUE
//	if it loads everything.
//
BOOL LoadOracleCalls (int oracleVersion)
{
	int  i;

#if SUPPORT_OCI7_COMPONENTS
	for (i = 0; i < NUMELEM(g_Oci7Call); i++)
	{
		_ASSERT (g_Oci7Call[i].pfnName);

		if ((g_Oci7Call[i].pfnAddr = GetProcAddress (s_hinstOciDll, g_Oci7Call[i].pfnName)) == NULL)
			return FALSE;
	}
#endif //SUPPORT_OCI7_COMPONENTS

#if SUPPORT_OCI8_COMPONENTS
	if (8 <= oracleVersion)
	{
		for (i = 0; i < NUMELEM(g_Oci8Call); i++)
		{
			_ASSERT (g_Oci8Call[i].pfnName);

			if ((g_Oci8Call[i].pfnAddr = GetProcAddress (s_hinstOciDll, g_Oci8Call[i].pfnName)) == NULL)
				return FALSE;
		}
	}
#endif //SUPPORT_OCI8_COMPONENTS
	
	for (i = 0; i < NUMELEM(g_XaCall); i++)
	{
		_ASSERT (g_XaCall[i].pfnName);

		if ((g_XaCall[i].pfnAddr = GetProcAddress (s_hinstXaDll, g_XaCall[i].pfnName)) == NULL)
			return FALSE;
	}
	
	g_pXaSwitchOracle = (xa_switch_t*)g_XaCall[IDX_xaosw].pfnAddr;

#if SUPPORT_OCI7_COMPONENTS
	if (NULL != s_hinstSqlDll)
	{
		for (i = 0; i < NUMELEM(g_SqlCall); i++)
		{
			_ASSERT (g_SqlCall[i].pfnName);

			if ((g_SqlCall[i].pfnAddr = GetProcAddress (s_hinstSqlDll, g_SqlCall[i].pfnName)) == NULL)
				return FALSE;
		}
	}
#endif //SUPPORT_OCI7_COMPONENTS

	return TRUE;
}

//-----------------------------------------------------------------------------
// LoadOracleDlls 
//
//	Attempts to loads the correct Oracle Dlls and get the
//	necessary proc addresses from them.
//
HRESULT LoadOracleDlls()
{
	HRESULT	hr = S_OK;
	Synch	sync(&s_csGlobal);

	for (int i=0; i < NUMELEM(s_DllNames); i++)
	{
		if ((s_hinstOciDll = LoadLibraryExA (s_DllNames[i].ociDllName, NULL,0)) != NULL)			//3 SECURITY REVIEW: dangerous function, but full path is not specified
		{
			// Now loop through the valid combinations of XA dll names for the version
			// of Oracle that we found.  We hard-code the path to the dll name so we
			// only load it from the same location that the OCI dll was loaded from.
			if (0 == GetModuleFileNameA(s_hinstOciDll, s_OciDllFileName, NUMELEM(s_OciDllFileName)))
				goto failedOci;

			char*		ociFileName = strrchr(s_OciDllFileName, '\\');

			if (NULL == ociFileName)
				goto failedOci;

			size_t 		cbOciDirectory = (ociFileName - s_OciDllFileName) + 1;

			for (int j=0; j < s_DllNames[i].xaDllInfoSize; j++)
			{
				memcpy(s_XaDllFileName, s_OciDllFileName, cbOciDirectory);							//3 SECURITY REVIEW: dangerous function, but input is from a Win32 API, and buffers are adequate.
				memcpy(s_XaDllFileName + cbOciDirectory, s_DllNames[i].xaDllInfo[j].xaDllName, strlen(s_DllNames[i].xaDllInfo[j].xaDllName));	//3 SECURITY REVIEW: dangerous function, but we're merely copying data 
		
				if ((s_hinstXaDll = LoadLibraryExA (s_XaDllFileName, NULL, 0)) != NULL)			//3 SECURITY REVIEW: dangerous function, specifying full path name, but the path is supposed to be the same as the OCI.DLL we loaded
				{
#if SUPPORT_OCI7_COMPONENTS
					memcpy(s_SqlDllFileName, s_OciDllFileName, cbOciDirectory);						//3 SECURITY REVIEW: dangerous function, but input is from a Win32 API, and buffers are adequate.
					memcpy(s_SqlDllFileName + cbOciDirectory, s_DllNames[i].xaDllInfo[j].sqlLibDllName, strlen(s_DllNames[i].xaDllInfo[j].xaDllName));	//3 SECURITY REVIEW: dangerous function, 
					
					if ((s_hinstSqlDll = LoadLibraryExA (s_SqlDllFileName, NULL, 0)) != NULL)		//3 SECURITY REVIEW: dangerous function, specifying full path name, but the path is supposed to be the same as the OCI.DLL we loaded
#endif //SUPPORT_OCI7_COMPONENTS
					{
						// If we get here, we've loaded all the DLLs successfully, so now we can go and
						// load the OCI calls;
						
						if (LoadOracleCalls(s_DllNames[i].xaDllInfo[j].oracleVersion))
						{
							g_oracleClientVersion = s_DllNames[i].xaDllInfo[j].oracleVersion;

							if (InitializeOracle())
							{
				 				hr = S_OK;
								goto done;
							}
						}
					}				
				}				

				// If we get here, we couldn't find the XA DLL or the SQLLIB dll; reset and  
				// try the next combination.

				hr = HRESULT_FROM_WIN32(GetLastError());
				
				if (NULL != s_hinstXaDll)
					FreeLibrary(s_hinstXaDll);

				s_hinstXaDll = NULL;

#if SUPPORT_OCI7_COMPONENTS
				if (NULL != s_hinstSqlDll)
					FreeLibrary(s_hinstSqlDll);

				s_hinstSqlDll = NULL;
#endif //SUPPORT_OCI7_COMPONENTS
			}
		}

		// If we get here, we couldn't find a combination of OCI, XA and SQL dlls;
		// that would work, reset and try the next combination.
failedOci:
		hr = HRESULT_FROM_WIN32(GetLastError());
		
		if (NULL != s_hinstOciDll)
			FreeLibrary(s_hinstOciDll);

		s_hinstOciDll = NULL;
	}

done:
	return hr;
}

//-----------------------------------------------------------------------------
// UnloadOracleDlls 
//
void UnloadOracleDlls()
{
	DWORD	dwVersion = GetVersion();

	if ( !IsWin95 (dwVersion) )
	{
		if (s_hinstOciDll)
			FreeLibrary (s_hinstOciDll);

		if (s_hinstXaDll)
			FreeLibrary (s_hinstXaDll);

#if SUPPORT_OCI7_COMPONENTS
		if (s_hinstSqlDll)
			FreeLibrary (s_hinstSqlDll);

		s_hinstSqlDll = NULL;
#endif //SUPPORT_OCI7_COMPONENTS

	}
	s_hinstOciDll = NULL;
	s_hinstXaDll = NULL;
}

//-----------------------------------------------------------------------------
// DllMain 
//
//	The primary DLL Entry Point; we do as little as possible here, waiting
//	for the actual API call(s) to load Oracle
//
BOOL APIENTRY DllMain( HMODULE hModule, 
                       DWORD   ul_reason_for_call, 
                       LPVOID  lpReserved
					 )
{
	HRESULT hr = S_OK;
	
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		GetModuleFileNameA(hModule, g_szModulePathName, sizeof(g_szModulePathName));	// ANSI, because IDTCToXAHelperFactory requires it.

		g_pszModuleFileName = strrchr(g_szModulePathName, '\\');
		if (NULL == g_pszModuleFileName)
			g_pszModuleFileName = g_szModulePathName;
		else
			g_pszModuleFileName++;

		DisableThreadLibraryCalls(hModule);
		InitializeCriticalSection(&s_csGlobal);			//3 SECURITY REVIEW: may throw an exception in low-memory situations, but then the process shouldn't be starting either.
#if SINGLE_THREAD_THRU_XA
		InitializeCriticalSection(&g_csXaInUse);		//3 SECURITY REVIEW: may throw an exception in low-memory situations, but then the process shouldn't be starting either.
#endif //SINGLE_THREAD_THRU_XA


		g_hrInitialization = LoadOracleDlls();

#if SUPPORT_OCI7_COMPONENTS
		if ( SUCCEEDED(g_hrInitialization) )
		{
			Locks_Initialize();
			if (LKRHashTableInit())
				hr = ConstructCdaWrapperTable();
			else
				hr = E_OUTOFMEMORY;	// Why else would LKRHashTableInit fail?
		}
#endif //SUPPORT_OCI7_COMPONENTS
		break;

	case DLL_PROCESS_DETACH:
		try 
		{
#if SUPPORT_OCI7_COMPONENTS
			DestroyCdaWrapperTable();
			LKRHashTableUninit();
#endif //SUPPORT_OCI7_COMPONENTS
			UnloadOracleDlls();
			UnloadFactories();
		}
		catch (...)
		{
			// TODO: Is this an issue?  Do we need to use Try/Catch to prevent crashes on shutdown?
		}
#if SINGLE_THREAD_THRU_XA
		DeleteCriticalSection(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA
		DeleteCriticalSection(&s_csGlobal);
		break;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
    return (S_OK == hr) ? TRUE : FALSE;
}
//-----------------------------------------------------------------------------
// DllRegisterServer
//
//	Adds necessary keys to the registry.
//
STDAPI DllRegisterServer(void)
{
	DWORD	stat;
	HUSKEY	key;
	DWORD	dwValue;

	if (ERROR_SUCCESS != (stat = SHRegCreateUSKeyA(s_EventLog_RegKey, KEY_SET_VALUE, NULL, &key, SHREGSET_HKLM)))
	{
		DBGTRACE (L"DllRegisterServer: error opening regkey: %d\n", stat);
		return ResultFromScode(E_FAIL);
	}

	dwValue = ( EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE );

	if (ERROR_SUCCESS != (stat = SHRegWriteUSValueA(key, "TypesSupported", REG_DWORD, (VOID*)&dwValue, sizeof(dwValue), SHREGSET_FORCE_HKLM)))
		goto Error;

	if (ERROR_SUCCESS != (stat = SHRegWriteUSValueA(key, "EventMessageFile", REG_SZ, (VOID*)g_szModulePathName, (DWORD)strlen(g_szModulePathName)+1, SHREGSET_FORCE_HKLM)))
		goto Error;

	SHRegCloseUSKey(key);
	return ResultFromScode(S_OK);

Error:
	DBGTRACE (L"DllRegisterServer: error setting value: %d\n", stat);
	return ResultFromScode(E_FAIL);
	
}

//-----------------------------------------------------------------------------
// DllUnregisterServer
//
//	Removes keys from the registry.
//
STDAPI DllUnregisterServer( void )
{
	return SHDeleteKeyA(HKEY_LOCAL_MACHINE, s_EventLog_RegKey);
}

//-----------------------------------------------------------------------------
// GetXaSwitch
//
//	This routine is required for the DTC to XA mapper to accept this DLL as
//	a valid one.  It must return our XA switch, so we can hook the XA calls
//
HRESULT __cdecl GetXaSwitch (
		XA_SWITCH_FLAGS	i_dwFlags,
		xa_switch_t **	o_ppXaSwitch)
{
	// If we've got an XA switch from Oracle, then return the pointer to our own
	// xa switch which wraps the real one, otherwise they're hosed.
	if ( SUCCEEDED(g_hrInitialization) )
	{
		*o_ppXaSwitch = &s_XaSwitchMine;
		return S_OK;
	}	
	
	*o_ppXaSwitch = NULL;
	return E_UNEXPECTED;
}

//-----------------------------------------------------------------------------
// MTxOciGetVersion
//
//	This returns the version of this dll
//
int __cdecl MTxOciGetVersion (int * pdwVersion)
{
	*pdwVersion = MTXOCI_VERSION_CURRENT;
	return S_OK;
}
#else //!SUPPORT_DTCXAPROXY
//-----------------------------------------------------------------------------
// global objects
//
HRESULT							g_hrInitialization = E_UNEXPECTED;	// set to the HR we should return when OCI hasn't been initialized (or S_OK if it has)
FARPROC							g_pfnOCIDefineDynamic = NULL;
int								g_oracleClientVersion = 0;			// Major Version Number of Oracle Client Software: 80, 81, 90

//-----------------------------------------------------------------------------
// static objects
//
static CRITICAL_SECTION			s_csGlobal;
static HINSTANCE				s_hinstOciDll = NULL;

//-----------------------------------------------------------------------------
// LoadOracleDlls 
//
//	Attempts to loads the correct Oracle Dlls and get the
//	necessary proc addresses from them.
//
HRESULT LoadOracleDlls()
{
	HRESULT	hr = S_OK;
	Synch	sync(&s_csGlobal);

	if ((s_hinstOciDll = LoadLibraryExA ("oci.dll", NULL,0)) != NULL)			//3 SECURITY REVIEW: dangerous function, but full path is not specified in the constant
	{
		if ((g_pfnOCIDefineDynamic = GetProcAddress (s_hinstOciDll, "OCIDefineDynamic")) != NULL)
		{
			hr = S_OK;

			// Determine the version of Oracle that we have
			if (NULL != GetProcAddress (s_hinstOciDll, "OCIEnvNlsCreate"))				// Introduced in Oracle9i Release 2
				g_oracleClientVersion = 92;
			else if (NULL != GetProcAddress (s_hinstOciDll, "OCIRowidToChar"))			// Introduced in Oracle9i
				g_oracleClientVersion = 90;
			else if (NULL != GetProcAddress (s_hinstOciDll, "OCIEnvCreate"))			// Introduced in Oracle8i
				g_oracleClientVersion = 81;				
			else
				g_oracleClientVersion = 80;		// We loaded OCI.DLL, so we must have Oracle 8.0.x -- ick.			

			goto done;
		}
	}				

	// If we get here, we couldn't find a combination of OCI, XA and SQL dlls;
	// that would work, reset and try the next combination.
	hr = HRESULT_FROM_WIN32(GetLastError());

	if (NULL != s_hinstOciDll)
		FreeLibrary(s_hinstOciDll);

	s_hinstOciDll = NULL;

done:
	return hr;
}

//-----------------------------------------------------------------------------
// UnloadOracleDlls 
//
void UnloadOracleDlls()
{
	DWORD	dwVersion = GetVersion();

	if ( !IsWin95 (dwVersion) )
	{
		if (s_hinstOciDll)
			FreeLibrary (s_hinstOciDll);

	}
	s_hinstOciDll = NULL;
}

//-----------------------------------------------------------------------------
// DllMain 
//
//	The primary DLL Entry Point; we do as little as possible here, waiting
//	for the actual API call(s) to load Oracle
//
BOOL APIENTRY DllMain( HMODULE hModule, 
                       DWORD   ul_reason_for_call, 
                       LPVOID  lpReserved
					 )
{
	HRESULT hr = S_OK;
	
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls(hModule);
		InitializeCriticalSection(&s_csGlobal);			//3 SECURITY REVIEW: may throw an exception in low-memory situations, but then the process shouldn't be starting either.
		g_hrInitialization = LoadOracleDlls();
		break;

	case DLL_PROCESS_DETACH:
		try 
		{
			UnloadOracleDlls();
		}
		catch (...)
		{
			// TODO: Is this an issue?  Do we need to use Try/Catch to prevent crashes on shutdown?
		}
		DeleteCriticalSection(&s_csGlobal);
		break;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
    return (S_OK == hr) ? TRUE : FALSE;
}

#endif //!SUPPORT_DTCXAPROXY

//-----------------------------------------------------------------------------
// MTxOciGetOracleVersion
//
//	This returns which major version of Oracle is in use - 7, 8 or 9 
//
int __cdecl MTxOciGetOracleVersion (int * pdwVersion)
{
	*pdwVersion = g_oracleClientVersion;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\oci8support.cpp ===
//-----------------------------------------------------------------------------
// File:		Oci8Support.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of routines to support OCI8 components
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#if SUPPORT_OCI8_COMPONENTS

#if SUPPORT_DTCXAPROXY

//-----------------------------------------------------------------------------
// GetOCIEnvHandle,GetOCISvcCtxHandle
//
//	Call Oracle's routine that returns the Environment or Service Context handle
//	for the DbName specified.
//
INT_PTR GetOCIEnvHandle(
	char*	i_pszXADbName
	)
{
	typedef INT_PTR (__cdecl * PFN_OCI_API) (text* dbName);
	return ((PFN_OCI_API)g_XaCall[IDX_xaoEnv].pfnAddr)	((text*)i_pszXADbName);
}
INT_PTR GetOCISvcCtxHandle(
	char*	i_pszXADbName
	)
{
	typedef INT_PTR (__cdecl * PFN_OCI_API) (text* dbName);
	return ((PFN_OCI_API)g_XaCall[IDX_xaoSvcCtx].pfnAddr)	((text*)i_pszXADbName);
}

//-----------------------------------------------------------------------------
// MTxOciConnectToResourceManager
//
//	Construct a Resource Manager Proxy for the specified user, password, and 
//	server, and return it.
//
HRESULT MTxOciConnectToResourceManager(
							char* userId,	int userIdLength,
							char* password,	int passwordLength, 
							char* server,	int serverLength,
							IUnknown** ppIResourceManagerProxy
							)
{
	HRESULT					hr = S_OK;
	IResourceManagerProxy*	pIResourceManagerProxy = NULL;
	IDtcToXaHelper*			pIDtcToXaHelper	= NULL;
	UUID					uuidRmId;
	
	char					xaOpenString[MAX_XA_OPEN_STRING_SIZE+1];
	char					xaDbName[MAX_XA_DBNAME_SIZE+1];

	// Verify arguments
	if (NULL == ppIResourceManagerProxy)
	{
		hr = E_INVALIDARG;
		goto DONE;
	}
	 
	// Initialize the output values	
	*ppIResourceManagerProxy = NULL;

	hr = g_hrInitialization;
	if ( FAILED(hr) )
		goto DONE;
		
	// Get the ResourceManager factory if it does not exist; don't 
	// lock unless it's NULL so we don't single thread through here.
	if (NULL == g_pIResourceManagerFactory)
	{
		hr = LoadFactories();
		
		if ( FAILED(hr) )
			goto DONE;
	}

	long rmid = InterlockedIncrement(&g_rmid);
	
	hr = GetDbName(xaDbName, sizeof(xaDbName));

	if (S_OK == hr)
	{
		hr = GetOpenString(	userId,		userIdLength,
							password,	passwordLength,
							server,		serverLength,
							xaDbName,	MAX_XA_DBNAME_SIZE,
							xaOpenString);

		if (S_OK == hr)
		{
			// Now create the DTC to XA Helper object
			hr = g_pIDtcToXaHelperFactory->Create (	(char*)xaOpenString, 
													g_pszModuleFileName,
													&uuidRmId,
													&pIDtcToXaHelper
													);

			if (S_OK == hr)
			{
				// Create the ResourceManager proxy object for this connection
				hr = CreateResourceManagerProxy (
												pIDtcToXaHelper,
												&uuidRmId,
												(char*)xaOpenString,
												(char*)xaDbName,
												rmid,
												&pIResourceManagerProxy
												);

				if (S_OK == hr)
				{
					hr = pIResourceManagerProxy->ProcessRequest(REQUEST_CONNECT, FALSE);

					if (S_OK == hr)
					{
						*ppIResourceManagerProxy = pIResourceManagerProxy;
						pIResourceManagerProxy = NULL;
					}
				}
			}
		}
	}
	
DONE:
	if (pIResourceManagerProxy)
	{
		pIResourceManagerProxy->Release();
		pIResourceManagerProxy = NULL;	
	}

	if (pIDtcToXaHelper)
	{
		pIDtcToXaHelper->Release();
		pIDtcToXaHelper = NULL;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// MTxOciEnlistInTransaction
//
//	Construct a Resource Manager Proxy for the specified user, password, and 
//	server, and return it.
//
HRESULT MTxOciEnlistInTransaction(
							IResourceManagerProxy*	pIResourceManagerProxy,
							ITransaction*	pITransaction,
							INT_PTR*		phOCIEnv,
							INT_PTR*		phOCISvcCtx
							)
{
	HRESULT hr;
	
	pIResourceManagerProxy->SetTransaction(pITransaction);
	
	hr = pIResourceManagerProxy->ProcessRequest(REQUEST_ENLIST, FALSE);
	
	if (S_OK == hr)
	{
		*phOCIEnv 		= pIResourceManagerProxy->GetOCIEnvHandle();
		*phOCISvcCtx	= pIResourceManagerProxy->GetOCISvcCtxHandle();
	}
	return hr;
}
#endif //SUPPORT_DTCXAPROXY

//-----------------------------------------------------------------------------
// MTxOciDefineDynamicCallback
//
//	This is the wrapper callback routine that calls the real callback, which is
//	expected to be stdcall.
//
int __cdecl	MTxOciDefineDynamicCallback
				(
				void *octxp,
				void *defnp,
				int iter,
				void **bufpp,
				unsigned int  **alenp,
				unsigned char *piecep,
				void **indp,
				unsigned short **rcodep
				)
{
	typedef INT_PTR (__stdcall * PFN_OCICALLBACK_API) (
												void *octxp,
												void *defnp,
												int iter,
												void **bufpp,
												unsigned int  **alenp,
												unsigned char *piecep,
												void **indp,
												unsigned short **rcodep
												);

	return ((PFN_OCICALLBACK_API)octxp) (octxp, defnp, iter, bufpp, alenp, piecep, indp, rcodep);
}

//-----------------------------------------------------------------------------
// MTxOciDefineDynamic
//
//	Oracle requires that their callbacks be __cdecl, but the delegate mechanism
//	in managed code appears to only support __stdcall, causing nasty crashes in 
//	Oracle when they're called. 
//
//	To prevent this, we have to use a glue routine to prevent them.  It happens
//	to be much easier to define the glue routine in native code than from the 
//	mananged provider, because you seem to need to use Reflection to do it there,
//	so here you have it.
//
//	NOTE:	At this time, this mechanism eats the context pointer that you pass,
//			so it can pass your callback to it's own callback routine.  Since we
//			expect to use managed delegates that can be non-static (where native
//			callbacks are always static) this shouldn't be an issue. If it
//			becomes an issue, however, you can implement a structure that contains 
//			both the real callback and the context pointer, store it in a hash 
//			table by context pointer, (so our wrapper callback can find the real
//			callback pointer) and have people "unregister" their callback to remove
//			the callback.
//
int __cdecl MTxOciDefineDynamic 
				(
				OCIDefine*			defnp,
				OCIError*			errhp,
				dvoid*				octxp,
				OCICallbackDefine	ocbfp
				)
{
	typedef INT_PTR (__cdecl * PFN_OCICALLBACK_API) (
												void *octxp,
												void *defnp,
												int iter,
												void **bufpp,
												unsigned int  **alenp,
												unsigned char *piecep,
												void **indp,
												unsigned short **rcodep
												);

	typedef INT_PTR (__cdecl * PFN_OCI_API) (
												OCIDefine   *defnp,
												OCIError    *errhp,
												dvoid       *octxp,
												PFN_OCICALLBACK_API ocbfp
												);

#if SUPPORT_DTCXAPROXY
	return ((PFN_OCI_API)g_Oci8Call[IDX_OCIDefineDynamic].pfnAddr) (defnp, errhp, ocbfp, MTxOciDefineDynamicCallback);
#else //!SUPPORT_DTCXAPROXY
	extern FARPROC	g_pfnOCIDefineDynamic;
	return ((PFN_OCI_API)g_pfnOCIDefineDynamic) (defnp, errhp, ocbfp, MTxOciDefineDynamicCallback);
#endif //!SUPPORT_DTCXAPROXY
}

#endif //SUPPORT_OCI8_COMPONENTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\openstring.cpp ===
//-----------------------------------------------------------------------------
// File:		OpenString.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of Helper Functions which format the
//				XA Open Strings
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

static const char * part1 = "Oracle_XA+Acc=P/";
static const int	part1_length = 16;	// strlen(part1)

static const char * part2 = "/";
static const int	part2_length = 1;	// strlen(part2)

static const char * part3 = "+SqlNet=";
static const int	part3_length = 8;	// strlen(part3)

static const char * part4oci8 = "+SesTm=600+Objects=TRUE+Threads=TRUE+DB=";
static const int	part4oci8_length = 40;	// strlen(part4oci8_length)

static const char * part4oci7 = "+SesTm=600+Threads=TRUE+DB=";
static const int	part4oci7_length = 27;	// strlen(part4oci7)

//-----------------------------------------------------------------------------
// global objects
//
long	g_rmid = 0;		// autoincrmement for each transaction.

//-----------------------------------------------------------------------------
// GetDbName
//
//	Gets a unique DBName (a UUID string)
//
HRESULT GetDbName ( char* dbName, size_t dbNameLength )
{
	HRESULT		hr;
	UUID		uuid;
	RPC_STATUS	rpcstatus = UuidCreate (&uuid);
	
	if (RPC_S_OK == rpcstatus)
	{
		char *	uuidString;
		
		hr = UuidToString (&uuid, (unsigned char **) &uuidString);

		if ( SUCCEEDED(hr) )
		{
			strncpy ((char*)dbName, uuidString, dbNameLength);		//3 SECURITY REVIEW: dangerous function, but we're getting the input data from a Win32 API above, and length is limited.
			dbName[dbNameLength-1] = 0;
			RpcStringFree ((unsigned char **)&uuidString);
		}
	}
	else
		hr = HRESULT_FROM_WIN32(rpcstatus);

	return hr;
}

//-----------------------------------------------------------------------------
// GetStringLength
//
//	returns the length of a string
//
static HRESULT GetStringLength ( char* arg, int* argLen )
{
	_ASSERT(NULL != argLen);
	
	if (NULL == arg)
		*argLen = 0;
	else if (-1 == *argLen)
		*argLen = (sword)strlen((char*)arg);
		
	return S_OK;
}

//-----------------------------------------------------------------------------
// GetOpenString
//
//	Given an userid, password, server and dbname, returns the XA Open
//	string necessary.
//
HRESULT GetOpenString ( char* userId,	int userIdLength,
							char* password,	int passwordLength, 
							char* server,	int serverLength, 
							char* xaDbName,	int xaDbNameLength,
							char* xaOpenString )
{
	GetStringLength(userId,	  &userIdLength);
	GetStringLength(password, &passwordLength);
	GetStringLength(server,   &serverLength);
	GetStringLength(xaDbName, &xaDbNameLength);

	// OK, I suck. Our ODBC Driver for Oracle combines userId, password and 
	// server into the classic Oracle syntax: userId/password@server and passes 
	// it in the userId field.  Because of that, I have to extract out each of
	// the individual components to build the open string here.
	if (NULL == password && 0 == passwordLength
	 && NULL == server   && 0 == serverLength
	 && NULL != userId   && 0 != userIdLength)
	{
		char* psz = strchr(userId, '/');

		if (NULL != psz)
		{
			int	templength = userIdLength;
			userIdLength = (int)(psz - userId);
			password = psz+1;

			psz = strchr(password, '@');

			if (NULL == psz)
				passwordLength	= (int)(userId + templength - password);
			else
			{
				passwordLength	= (int)(psz - password);
				server			= psz+1;
				serverLength	= (int)(userId + templength - server);
			}
		}
	}

	if (30 < userIdLength
	 || 30 < passwordLength
	 || 30 < serverLength
	 || MAX_XA_DBNAME_SIZE < xaDbNameLength)
		return E_INVALIDARG;

	char*	psz = (char*)xaOpenString;

	memcpy(psz, part1,		part1_length);		psz += part1_length;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	memcpy(psz, userId,		userIdLength);		psz += userIdLength;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	memcpy(psz, part2,		part2_length);		psz += part2_length;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	memcpy(psz, password,	passwordLength);	psz += passwordLength;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.

	if (0 < serverLength)
	{
		memcpy(psz, part3,	part3_length);		psz += part3_length;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
		memcpy(psz, server,	serverLength);		psz += serverLength;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	}

	if (ORACLE_VERSION_73 >= g_oracleClientVersion)
	{
		memcpy(psz, part4oci7,	part4oci7_length);	psz += part4oci7_length;	//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	}
	else
	{
		memcpy(psz, part4oci8,	part4oci8_length);	psz += part4oci8_length;	//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	}

	memcpy(psz, xaDbName,	xaDbNameLength);	psz += xaDbNameLength;			//3 SECURITY REVIEW: dangerous function, but the buffers are large enough.
	*psz = 0;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\stdafx.h ===
//-----------------------------------------------------------------------------
// File:		stdafx.h
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	include file for standard system include files, or project
//				specific include files that are used frequently, but are 
//				changed infrequently
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// Windows header files
#include "wtypes.h"

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <malloc.h>

// Oracle header files
#include <oci.h>

    
// Project specific header files

#include "Mtxoci8.h"
#include "Synch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\resourcemanagerproxy.h ===
//-----------------------------------------------------------------------------
// File:		ResourceManagerProxy.h
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Definitions for the ResourceManagerProxy object.
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __RESOURCEMANAGERPROXY_H_
#define __RESOURCEMANAGERPROXY_H_

#include "mtxoci8.h"

// !!!IMPORTANT!!!
// the State Machine in ResourceManagerProxy.cpp expects these to be in the order
// they are in here.  Any modifications to this enumeration must be accompanied
// by an adjustment to the state machine!
// !!!IMPORTANT!!!
enum REQUEST {
		REQUEST_STOPALLWORK = -3,
		REQUEST_OCICALL = -2,
		REQUEST_IDLE = -1,
		REQUEST_CONNECT = 0,
		REQUEST_DISCONNECT,
		REQUEST_ENLIST,
		REQUEST_PREPAREONEPHASE,
		REQUEST_PREPARETWOPHASE,
		REQUEST_PREPARESINGLECOMPLETED,
		REQUEST_PREPARECOMPLETED,
		REQUEST_PREPAREFAILED,
		REQUEST_PREPAREUNKNOWN,
		REQUEST_TXCOMPLETE,
		REQUEST_ABORT,
		REQUEST_COMMIT,
		REQUEST_TMDOWN,
		REQUEST_UNBIND_ENLISTMENT,
		REQUEST_ABANDON,
};

// Interface-based programming -- here's the interface for the proxy object
interface IResourceManagerProxy : public IResourceManagerSink
{
	virtual STDMETHODIMP_(sword)	OKToEnlist() = 0;
	virtual STDMETHODIMP			ProcessRequest(REQUEST request, BOOL fAsync) = 0;
	virtual STDMETHODIMP_(void)		SetTransaction ( ITransaction* i_pITransaction ) = 0;

#if SUPPORT_OCI7_COMPONENTS
	virtual STDMETHODIMP			AddCursorToList( struct cda_def* cursor ) = 0;
	virtual STDMETHODIMP			RemoveCursorFromList( struct cda_def* cursor ) = 0;
	virtual STDMETHODIMP_(sword)	Oci7Call (
											int				idxOciCall,
											void*			pvCallStack,
											int				cbCallStack) = 0;
	virtual STDMETHODIMP_(void)		SetLda ( struct cda_def* lda ) = 0;
#endif // SUPPORT_OCI7_COMPONENTS

#if SUPPORT_OCI8_COMPONENTS
	virtual STDMETHODIMP_(INT_PTR)	GetOCIEnvHandle	() = 0;
	virtual STDMETHODIMP_(INT_PTR)	GetOCISvcCtxHandle () = 0;
#endif SUPPORT_OCI8_COMPONENTS
};



//-----------------------------------------------------------------------------
// CreateResourceManagerProxy
//
//	Instantiates a transaction enlistment for the resource manager
//
HRESULT CreateResourceManagerProxy(
	IDtcToXaHelper *		i_pIDtcToXaHelper,	
	GUID *					i_pguidRM,
	char*					i_pszXAOpenString,
	char*					i_pszXADbName,
	int						i_rmid,
	IResourceManagerProxy**	o_ppResourceManagerProxy
	);

#endif // __RESOURCEMANAGERPROXY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\synch.h ===
//-----------------------------------------------------------------------------
// File:		Synch.h
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Interface and Implementation of Synch object, used to
//				automate critical section usage.
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __SYNCH_H_
#define __SYNCH_H_

//-----------------------------------------------------------------------------
// @class Synch | Simplified Critical Section handling
//
class Synch
{
private:
	CRITICAL_SECTION* m_pcs;
	Synch();

public:
	Synch(CRITICAL_SECTION* pcs)
	{
		m_pcs = pcs;
		EnterCriticalSection (m_pcs);	//3 SECURITY REVIEW: This can throw in low memory situations.  We'll use MPCS when we move to MDAC 9.0 and it  should be handled for us.
	}

	~Synch()
	{
		LeaveCriticalSection (m_pcs);
	}
};

#endif // __SYNCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\transactionenlistment.cpp ===
//-----------------------------------------------------------------------------
// File:		TransactionEnlistment.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of the TransactionEnlistment object
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

class TransactionEnlistment : public ITransactionEnlistment
{
private:
	DWORD					m_cRef;
	BOOL					m_fGiveUnbindNotification;
	IResourceManagerProxy*	m_pResourceManager;

public:
	//-----------------------------------------------------------------------------
	// Constructor
	//
	TransactionEnlistment(
			IResourceManagerProxy* pResourceManager)
	{
		m_fGiveUnbindNotification	= FALSE;
		m_cRef						= 1;
		m_pResourceManager			= pResourceManager;
		m_pResourceManager->AddRef();
	}

	//-----------------------------------------------------------------------------
	// Destructor
	//
	~TransactionEnlistment()
	{
		if (m_pResourceManager)
		{
			if (m_fGiveUnbindNotification)
				m_pResourceManager->ProcessRequest(REQUEST_UNBIND_ENLISTMENT, TRUE);

			m_pResourceManager->Release();
			m_pResourceManager = NULL;
		}
 	}
	
	//-----------------------------------------------------------------------------
	// IUnknown.QueryInterface
	//
	STDMETHODIMP QueryInterface (REFIID iid, void ** ppv)
	{
		HRESULT		hr = S_OK;
		
		if (IID_IUnknown == iid)
		{
			*ppv = (IUnknown *) this;
		}
		else if (IID_ITransactionResourceAsync == iid)
		{
			*ppv = (ITransactionResourceAsync *) this;
		}
		else 
		{
			hr = E_NOINTERFACE;
			*ppv = NULL;
		}

		if (*ppv)
		{
			((IUnknown *)*ppv)->AddRef();
		}

		return hr;
	}
	
	//-----------------------------------------------------------------------------
	// IUnknown.AddRef
	//
	STDMETHODIMP_(ULONG) IUnknown::AddRef ()
	{
		return InterlockedIncrement ((long *) &m_cRef);
	}

	//-----------------------------------------------------------------------------
	// IUnknown.Release
	//
	STDMETHODIMP_(ULONG) IUnknown::Release()
  	{
		long lVal = InterlockedDecrement ((long *) &m_cRef);

		if (0 == lVal)
		{
			delete this;
			return 0;
		}

		return lVal;
	}
  
	//-----------------------------------------------------------------------------
	// ITransactionResourceAsync.PrepareRequest
	//
	STDMETHODIMP ITransactionResourceAsync::PrepareRequest ( 
						/* [in] */ BOOL fRetaining,
						/* [in] */ DWORD grfRM,
						/* [in] */ BOOL fWantMoniker,
						/* [in] */ BOOL fSinglePhase
						)  
	{
		m_pResourceManager->ProcessRequest(fSinglePhase ? REQUEST_PREPAREONEPHASE : REQUEST_PREPARETWOPHASE, TRUE);
		return S_OK;
	}  
	
	//-----------------------------------------------------------------------------
	// ITransactionResourceAsync.CommitRequest
	//
	STDMETHODIMP ITransactionResourceAsync::CommitRequest ( 
						/* [in] */ DWORD grfRM,
						/* [in] */ XACTUOW __RPC_FAR *pNewUOW
						)
	{
		m_pResourceManager->ProcessRequest(REQUEST_COMMIT, TRUE);
		return S_OK;
	}  
	
	//-----------------------------------------------------------------------------
	// ITransactionResourceAsync.AbortRequest
	//
	STDMETHODIMP ITransactionResourceAsync::AbortRequest ( 
						/* [in] */ BOID __RPC_FAR *pboidReason,
						/* [in] */ BOOL fRetaining,
						/* [in] */ XACTUOW __RPC_FAR *pNewUOW
						)
	{
		m_pResourceManager->ProcessRequest(REQUEST_ABORT, TRUE);
		return S_OK;
	}  
    
	//-----------------------------------------------------------------------------
	// ITransactionResourceAsync.TMDown
	//
	STDMETHODIMP ITransactionResourceAsync::TMDown (void)
	{
		m_pResourceManager->ProcessRequest(REQUEST_TMDOWN, TRUE);
		return S_OK;
	}  

	//-----------------------------------------------------------------------------
	// ITransactionEnlistment.UnilateralAbort
	//
	STDMETHODIMP UnilateralAbort (void)
	{
		m_fGiveUnbindNotification = TRUE;
		return S_OK;
	}
}; 


//-----------------------------------------------------------------------------
// CreateTransactionEnlistment
//
//	Instantiates a transaction enlistment for the resource manager
//
void CreateTransactionEnlistment(
	IResourceManagerProxy*	pResourceManager,
	TransactionEnlistment**	ppTransactionEnlistment
	)
{
	*ppTransactionEnlistment = new TransactionEnlistment(pResourceManager);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\resourcemanagerproxy.cpp ===
//-----------------------------------------------------------------------------
// File:		ResourceManagerProxy.cpp
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of the ResourceManagerProxy object
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

extern IResourceManagerFactory*		g_pIResourceManagerFactory;

#define MAX_QUEUE			10		// don't allow more than this many requests in the queue;
#define TRACE_REFCOUNTS		0		// set this to 1 if you want the refcounting traced.

#if SUPPORT_OCI7_COMPONENTS
class CdaListEntry : public CListEntry
{
public:
	CdaWrapper*	pCda;
};
#endif //SUPPORT_OCI7_COMPONENTS


enum TRANSTATE {
		TRANSTATE_INIT = 0,
		TRANSTATE_DONE,
		TRANSTATE_ACTIVE,
		TRANSTATE_PREPARINGONEPHASE,
		TRANSTATE_PREPARINGTWOPHASE,
		TRANSTATE_PREPARED,
		TRANSTATE_DISCONNECTINGPREPARED,
		TRANSTATE_DISCONNECTINGDONE,
		TRANSTATE_UNILATERALLYABORTING,
		TRANSTATE_DOOMED,
		TRANSTATE_OBLIVION,
		TRANSTATE_ERROR
};

enum ACTION {
		ACTION_CONNECT = 1,
		ACTION_DISCONNECTXXX,
		ACTION_DISCONNECT,
		ACTION_ENLIST,
		ACTION_PREPAREONEPHASE,
		ACTION_PREPARETWOPHASE,
		ACTION_ABORT,
		ACTION_COMMIT,
		ACTION_UNILATERALABORT,
};

#define ERR TRANSTATE_ERROR			// for simplicity

static struct
{
	char action;
	char newState;
}
stateMachine[10][14] =
{
	// TRANSTATE_INIT
	{
			{ACTION_CONNECT,		TRANSTATE_DONE},					// REQUEST_CONNECT,	
			{NULL,					ERR},								// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{NULL,					ERR},								// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_DONE
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{ACTION_DISCONNECT,		TRANSTATE_OBLIVION},				// REQUEST_DISCONNECT,					
			{ACTION_ENLIST,			TRANSTATE_ACTIVE},					// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{NULL,					TRANSTATE_DONE},					// REQUEST_TXCOMPLETE,
			{NULL,					ERR},								// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_ACTIVE
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{ACTION_UNILATERALABORT,TRANSTATE_UNILATERALLYABORTING},	// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{ACTION_PREPAREONEPHASE,TRANSTATE_PREPARINGONEPHASE},		// REQUEST_PREPAREONEPHASE,					
			{ACTION_PREPARETWOPHASE,TRANSTATE_PREPARINGTWOPHASE},		// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{ACTION_ABORT,			TRANSTATE_DONE},					// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_PREPARINGONEPHASE
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{ACTION_DISCONNECT,		TRANSTATE_OBLIVION},				// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					TRANSTATE_DONE},					// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPAREFAILED,					
			{NULL,					TRANSTATE_DONE},					// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{NULL,					ERR},								// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_PREPARINGTWOPHASE
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{ACTION_DISCONNECT,		TRANSTATE_OBLIVION},				// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					TRANSTATE_DONE},					// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					TRANSTATE_PREPARED},				// REQUEST_PREPARECOMPLETED,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPAREFAILED,					
			{NULL,					TRANSTATE_DONE},					// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{NULL,					ERR},								// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},
	
	// TRANSTATE_PREPARED
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{NULL,					TRANSTATE_DISCONNECTINGPREPARED},	// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{ACTION_ABORT,			TRANSTATE_DONE},					// REQUEST_ABORT,					
			{ACTION_COMMIT,			TRANSTATE_DONE},					// REQUEST_COMMIT,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_TMDOWN,					
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_DISCONNECTINGPREPARED
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{NULL,					ERR},								// REQUEST_DISCONNECT,	
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{ACTION_ABORT,			TRANSTATE_DISCONNECTINGDONE},		// REQUEST_ABORT, 		
			{ACTION_COMMIT,			TRANSTATE_DISCONNECTINGDONE},		// REQUEST_COMMIT, 	
			{NULL,					TRANSTATE_OBLIVION},				// REQUEST_TMDOWN, 	
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_DISCONNECTINGDONE
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{NULL,					ERR},								// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{ACTION_DISCONNECT,		TRANSTATE_OBLIVION},				// REQUEST_TXCOMPLETE,
			{NULL,					ERR},								// REQUEST_ABORT, 		
			{NULL,					ERR},								// REQUEST_COMMIT, 	
			{NULL,					ERR},								// REQUEST_TMDOWN, 	
			{NULL,					ERR},								// REQUEST_UNBIND_ENLISTMENT,					
	},
	
	// TRANSTATE_UNILATERALLYABORTING
	{
			{NULL,					ERR},								// REQUEST_CONNECT,					
			{NULL,					ERR},								// REQUEST_DISCONNECT,					
			{NULL,					ERR},								// REQUEST_ENLIST,					
			{NULL,					ERR},								// REQUEST_PREPAREONEPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARETWOPHASE,					
			{NULL,					ERR},								// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPARECOMPLETED,					
			{NULL,					ERR},								// REQUEST_PREPAREFAILED,					
			{NULL,					ERR},								// REQUEST_PREPAREUNKNOWN,					
			{NULL,					ERR},								// REQUEST_TXCOMPLETE,
			{NULL,					TRANSTATE_OBLIVION},				// REQUEST_ABORT,					
			{NULL,					ERR},								// REQUEST_COMMIT,					
			{NULL,					ERR},								// REQUEST_TMDOWN,					
			{NULL,					TRANSTATE_OBLIVION},				// REQUEST_UNBIND_ENLISTMENT,					
	},

	// TRANSTATE_DOOMED
	{
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_CONNECT,					
			{ACTION_DISCONNECT,		TRANSTATE_OBLIVION},				// REQUEST_DISCONNECT,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_ENLIST,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPAREONEPHASE,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPARETWOPHASE,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPARESINGLECOMPLETED,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPARECOMPLETED,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPAREFAILED,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_PREPAREUNKNOWN,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_TXCOMPLETE,
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_ABORT,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_COMMIT,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_TMDOWN,					
			{NULL,					TRANSTATE_DOOMED},					// REQUEST_UNBIND_ENLISTMENT,					
	},
};


static WCHAR *s_debugStateName[] = {
		L"INIT",
		L"DONE",
		L"ACTIVE",
		L"PREPARINGONEPHASE",
		L"PREPARINGTWOPHASE",
		L"PREPARED",
		L"DISCONNECTINGPREPARED",
		L"DISCONNECTINGDONE",
		L"UNILATERALLYABORTING",
		L"DOOMED",
		L"OBLIVION",
		L"ERROR",
};
#define STATENAME(x)	s_debugStateName[x]

static WCHAR *s_debugActionName[] = {
		L"(none)",
		L"CONNECT",
		L"DISCONNECTXXX",
		L"DISCONNECT",
		L"ENLIST",
		L"PREPAREONEPHASE",
		L"PREPARETWOPHASE",
		L"ABORT",
		L"COMMIT",
		L"UNILATERALABORT",
};
#define ACTIONNAME(x)	s_debugActionName[x]

static WCHAR *s_debugRequestName[] = {
		L"STOPALLWORK",
		L"OCICALL",
		L"IDLE",
		L"CONNECT",
		L"DISCONNECT",
		L"ENLIST",
		L"PREPAREONEPHASE",
		L"PREPARETWOPHASE",
		L"PREPARESINGLECOMPLETED",
		L"PREPARECOMPLETED",
		L"PREPAREFAILED",
		L"PREPAREUNKNOWN",
		L"TXCOMPLETE",
		L"ABORT",
		L"COMMIT",
		L"TMDOWN",
		L"UNBIND_ENLISTMENT",
		L"ABANDON",
};
#define REQUESTNAME(x)	s_debugRequestName[x-REQUEST_STOPALLWORK]

struct RequestQueueEntry
{
	REQUEST		m_request;
	HRESULT*	m_phr;
	int			m_idxOciCall;
	void*		m_pvCallStack;
	int			m_cbCallStack;

	RequestQueueEntry() {}
	
	RequestQueueEntry(REQUEST request)
	{
		m_request = request;
		m_phr = NULL;
		m_idxOciCall = 0;
		m_pvCallStack = NULL;
		m_cbCallStack = 0;
		
	}
	
	RequestQueueEntry(int			idxOciCall,
							void*		pvCallStack,
							int			cbCallStack)
	{
		m_request = REQUEST_OCICALL;
		m_phr = NULL;
		m_idxOciCall = idxOciCall;
		m_pvCallStack = pvCallStack;
		m_cbCallStack = cbCallStack;
	}
};


class ResourceManagerProxy : public IResourceManagerProxy
{
private:
	DWORD					m_cRef;						// refcount

	IDtcToXaHelper*			m_pIDtcToXaHelper;			// helper object
	int						m_rmid;						// rmid
	ITransaction*			m_pITransaction;			// transaction object
	
	IResourceManager*		m_pIResourceManager;		// the actual resource manager
	TRANSTATE				m_tranState;				// current transaction state

	TransactionEnlistment*	m_pTransactionEnlistment;

	ITransactionEnlistmentAsync* m_pITransactionEnlistmentAsync;
 														// callback object to notify DTC of completion of async operations
#if SUPPORT_OCI8_COMPONENTS
	INT_PTR					m_hOCIEnv;					// OCI Environment Handle for the connection used
	INT_PTR					m_hOCISvcCtx;				// OCI Service Context Handle for the connection used
#endif //SUPPORT_OCI8_COMPONENTS
#if SUPPORT_OCI7_COMPONENTS
	struct cda_def*			m_plda;						// OCI7 LDA; null if an OCI8 connection.
	CDoubleList				m_cursorList;				// OCI7 CDAWrappers attached to the LDA.
 	CRITICAL_SECTION		m_csCursorList;				// Controls access to the cursor list
#endif //SUPPORT_OCI7_COMPONENTS

	int						m_xarc;						// Return code from last XA call

	HANDLE					m_heventWorkerStart;		// Event to signal the worker thread that it should do something
	HANDLE					m_heventWorkerDone;			// Event to signal the callig thread that the worker thread is done
	HANDLE					m_hthreadWorker;			// Thread to perform all the OCI calls from
	DWORD					m_dwThreadIdWorker;			// Thread ID of the worker thread
	
	XID						m_xid;						// XA Transaction ID

	char					m_szXADbName[MAX_XA_DBNAME_SIZE+1];					// dbname part of the XA open string (separated out)
	char					m_szXAOpenString [MAX_XA_OPEN_STRING_SIZE+1];		// XA open string to use
							// TODO: we really ought to protect this using CryptProtectMemory...
							
	int						m_nextQueueEntry;
	int						m_lastQueueEntry;

 	CRITICAL_SECTION		m_csRequestQueue;			// Controls access to the request queue
	RequestQueueEntry		m_requestQueue[MAX_QUEUE];	// OCI entry point that the worker thread should call (-1 == stop working)  we don't allow more than MAX_QUEUE requests

	
public:
	//-----------------------------------------------------------------------------
	// Constructor
	//
	ResourceManagerProxy()
	{
		m_cRef				= 1;
		m_pIDtcToXaHelper	= NULL;
		m_rmid				= -1;
		m_pITransaction		= NULL;
		m_pIResourceManager	= NULL;
		m_tranState			= TRANSTATE_INIT;
		m_pTransactionEnlistment = NULL;
		m_pITransactionEnlistmentAsync = NULL;
#if SUPPORT_OCI8_COMPONENTS
		m_hOCIEnv			= NULL; 
		m_hOCISvcCtx		= NULL;
#endif //SUPPORT_OCI8_COMPONENTS
#if SUPPORT_OCI7_COMPONENTS
		m_plda				= NULL;
		InitializeCriticalSection(&m_csCursorList);		//3 SECURITY REVIEW: This can throw in low memory situations.  We'll use MPCS when we move to MDAC 9.0 and it should be handled for us.
#endif //SUPPORT_OCI7_COMPONENTS
		m_xarc				= 0;
		m_heventWorkerStart	= 0;
		m_heventWorkerDone	= 0;
		m_hthreadWorker		= 0;
		m_dwThreadIdWorker	= 0;
		m_nextQueueEntry	= 0;
		m_lastQueueEntry	= 0;
		InitializeCriticalSection(&m_csRequestQueue);	//3 SECURITY REVIEW: This can throw in low memory situations.  We'll use MPCS when we move to MDAC 9.0 and it  should be handled for us.
	}

	//-----------------------------------------------------------------------------
	// Destructor
	//
	~ResourceManagerProxy()
	{
		StopWorkerThread();
		Oblivion();		
		Cleanup();		

#if SUPPORT_OCI7_COMPONENTS
		DeleteCriticalSection(&m_csCursorList);				// TODO: use MPCS?
#endif //SUPPORT_OCI7_COMPONENTS
		DeleteCriticalSection(&m_csRequestQueue);			// TODO: use MPCS?
	}
	
	//-----------------------------------------------------------------------------
	// IUnknown.QueryInterface
	//
	STDMETHODIMP QueryInterface (REFIID iid, void ** ppv)
	{
		HRESULT		hr = S_OK;
		
		if (IID_IUnknown == iid)
		{
			*ppv = (IUnknown *) this;
		}
		else if (IID_IResourceManagerSink == iid)
		{
			*ppv = (IResourceManagerSink *) this;
		}
		else 
		{
			hr = E_NOINTERFACE;
			*ppv = NULL;
		}

		if (*ppv)
		{
			((IUnknown *)*ppv)->AddRef();
		}

		return hr;
	}
	
	//-----------------------------------------------------------------------------
	// IUnknown.AddRef
	//
	STDMETHODIMP_(ULONG) IUnknown::AddRef ()
	{
		long lVal = InterlockedIncrement ((long *) &m_cRef);

#if TRACE_REFCOUNTS
	 	DBGTRACE (L"\tMTXOCI8: TID=%-4x + DBNAME=%S RMID=%-5d tranState=%-22.22s cref=%d\n",
					GetCurrentThreadId(), 
					m_szXADbName,
					m_rmid,
					STATENAME(m_tranState), 
					lVal
					);
#endif // TRACE_REFCOUNTS

		return lVal;
	}

	//-----------------------------------------------------------------------------
	// IUnknown.Release
	//
	STDMETHODIMP_(ULONG) IUnknown::Release ()
  	{
		long lVal = InterlockedDecrement ((long *) &m_cRef);

#if TRACE_REFCOUNTS
	 	DBGTRACE (L"\tMTXOCI8: TID=%-4x - DBNAME=%S RMID=%-5d tranState=%-22.22s cref=%d\n",
					GetCurrentThreadId(), 
					m_szXADbName,
					m_rmid,
					STATENAME(m_tranState), 
					lVal
					);
#endif // TRACE_REFCOUNTS

		if (0 == lVal)
		{
			delete this;
			return 0;
		}

		return lVal;
	}
  
	//-----------------------------------------------------------------------------
	// IResourceManagerSink.TMDown
	//
    STDMETHODIMP IResourceManagerSink::TMDown()
	{
		if (m_pIResourceManager)
		{
			m_pIResourceManager->Release();
			m_pIResourceManager = NULL;
		}
		return S_OK;
	}
	
	//-----------------------------------------------------------------------------
	// OKToEnlist 
	//
	//	We need to wait to enlist if the connection is not in a done state; this
	//	method does the waiting for us.
	//
	STDMETHODIMP_(sword) IResourceManagerProxy::OKToEnlist()
	{
		sword	rc = XACT_E_XTIONEXISTS; // was OCI_FAIL in version 1, but that's not very descriptive...
		int		i;

		for (i = 0; i < 6000; i++)		// 6000 tries every 5 msec == 30 seconds
		{
			switch ((int)m_tranState)
			{
			case TRANSTATE_DONE:
				_ASSERT (NULL == m_pTransactionEnlistment); // Expect no enlistments
				rc = OCI_SUCCESS;
				goto done;

			case TRANSTATE_ACTIVE:
			case TRANSTATE_PREPARINGONEPHASE:
			case TRANSTATE_PREPARINGTWOPHASE:
			case TRANSTATE_PREPARED:
				Sleep (5);
				break;

			default:
				goto done;
			}
		}

	done:
		if (OCI_SUCCESS != rc)
		{
			DBGTRACE (L"\tMTXOCI8: TID=%-4x . DBNAME=%S RMID=%-5d cannot enlist when tranState=%-22.22s rc=0x%x\n",
								GetCurrentThreadId(), 
								m_szXADbName,
								m_rmid,
								STATENAME(m_tranState),
								rc
								);
		}
		return rc;
	}

	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.ProcessRequest 
	//
	// Oracle requires that all XA calls for a transaction be made from the
	// same thread; if you don't do this, the XA calls will return XAER_RMERR.
	// So, we have to marshal the request over to a worker thread... (Boo hiss)
	//
	STDMETHODIMP IResourceManagerProxy::ProcessRequest(
			REQUEST request,
			BOOL	fAsync
			)
	{
		if (request < 0 || request > REQUEST_ABANDON)
			return E_INVALIDARG;

		return ProcessRequestInternal(RequestQueueEntry(request), fAsync);
	}
	
	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.SetTransaction
	//
	//	Set the transaction object in the proxy
	//
	STDMETHODIMP_(void) IResourceManagerProxy::SetTransaction( ITransaction* i_pITransaction )
	{
		m_pITransaction = i_pITransaction;

		if (NULL != m_pITransaction)
			m_pITransaction->AddRef();
	}
	
#if SUPPORT_OCI8_COMPONENTS
	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.GetOCIEnvHandle, GetOCISvcCtxHandle
	//
	//	return the OCI Enviroment, Service Context handles
	//
	STDMETHODIMP_(INT_PTR) IResourceManagerProxy::GetOCIEnvHandle()
	{
		return m_hOCIEnv;
	}
	STDMETHODIMP_(INT_PTR) IResourceManagerProxy::GetOCISvcCtxHandle()
	{
		return m_hOCISvcCtx;
	}
#endif // SUPPORT_OCI8_COMPONENTS

#if SUPPORT_OCI7_COMPONENTS
	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.AddCursorToList
	//
	//	Add the CDA (cursor) specified to the list of cursors for this proxy.
	//
	STDMETHODIMP IResourceManagerProxy::AddCursorToList( struct cda_def* cursor )
	{
		HRESULT			hr = S_OK;
		CdaWrapper* 	pCda = new CdaWrapper((IResourceManagerProxy*)this, cursor);
		CdaListEntry* 	ple = new CdaListEntry();
		
		if (NULL == pCda || NULL == ple)
		{
			hr = OCI_OUTOFMEMORY;
			goto done;
		}

		ple->pCda = pCda;

		m_cursorList.InsertTail((CListEntry*)ple);

		hr = AddCdaWrapper( pCda );	
		
	done:
		return hr;
	}

	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.RemoveCda
	//
	//	Remove the cursor from the cursor list for this resource.
	//
	STDMETHODIMP IResourceManagerProxy::RemoveCursorFromList( struct cda_def* cursor ) 
	{
		Synch	sync(&m_csCursorList);					// Yes, I know this could cause contention, but it isn't likely to be a problem for a single connection.	
		CdaListEntry* ple = (CdaListEntry*)m_cursorList.First();

		while (m_cursorList.HeadNode() != (CListEntry*)ple)
		{
			CdaWrapper* pCda = ple->pCda;

			if (NULL != pCda && pCda->m_pUsersCda == cursor)
			{
				m_cursorList.RemoveEntry((CListEntry*)ple);
 				delete ple;
				break;
			}
			ple = (CdaListEntry*)ple->Flink;
		}
		return S_OK;
	}

	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.Oci7Call
	//
	//	Queue an OCI call on the request queue (because all OCI7 calls must be made
	//	on the same thread as the xa_open, or they will fail)
	//
	STDMETHODIMP_(sword) IResourceManagerProxy::Oci7Call(
							int				idxOciCall,
							void*			pvCallStack,
							int				cbCallStack)
	{
		return ProcessRequestInternal(RequestQueueEntry(idxOciCall, pvCallStack, cbCallStack), false);
	}

	//-----------------------------------------------------------------------------
	// IResourceManagerProxy.SetLda
	//
	//	Specify the LDA you wish to be connected as part of the transaction
	//
	STDMETHODIMP_(void) IResourceManagerProxy::SetLda ( struct cda_def* lda )
	{
		m_plda = lda;
	}
#endif // SUPPORT_OCI7_COMPONENTS
							
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Init
	//
	//	Initialize the resource manager proxy
	//	
	STDMETHODIMP Init (
			IDtcToXaHelper* i_pIDtcToXaHelper,	
			GUID *			i_pguidRM,
			char*			i_pszXAOpenString,
			char*			i_pszXADbName,
			int				i_rmid
 			)
	{
		HRESULT		hr;

		// Verify that there aren't any buffer overruns with this data
		if ((sizeof(m_szXAOpenString) - sizeof(m_szXADbName)) < strlen(i_pszXAOpenString)
		 || sizeof(m_szXADbName)	 < strlen(i_pszXADbName))
			return E_INVALIDARG;

		// Create/Start the worker thread
		hr = StartWorkerThread();

		if (S_OK == hr)
		{
			m_pIDtcToXaHelper = i_pIDtcToXaHelper;
			m_pIDtcToXaHelper->AddRef();

			strncpy (m_szXAOpenString, i_pszXAOpenString,	sizeof(m_szXAOpenString));		//3 SECURITY REVIEW: dangerous function, but this method only accessible internally, input value is created internally, output buffer is on the heap, and length is limited.
			m_szXAOpenString[sizeof(m_szXAOpenString)-1] = 0;
			
			strncpy (m_szXADbName,	  i_pszXADbName, 		sizeof(m_szXADbName));			//3 SECURITY REVIEW: dangerous function, but this method only accessible internally, input value is created internally, output buffer is on the heap, and length is limited.
			m_szXADbName[sizeof(m_szXADbName)-1] = 0;

			m_rmid = i_rmid;
 
			hr = g_pIResourceManagerFactory->Create (
													i_pguidRM,
													"MS Oracle8 RM",
													(IResourceManagerSink *) this,
													&m_pIResourceManager
													);
		}
		return hr;
	} 
	
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Cleanup
	//
	//	Cleanup the enlistment, once the transaction is completed (either by
	//	commit, abort or failure)
	//	
	STDMETHODIMP Cleanup ()
	{
		if (m_pITransactionEnlistmentAsync)
		{
			m_pITransactionEnlistmentAsync->Release();
			m_pITransactionEnlistmentAsync = NULL;
		}

		if (m_pTransactionEnlistment)
		{
			((IUnknown*)m_pTransactionEnlistment)->Release();
			m_pTransactionEnlistment = NULL;
		}
		return S_OK;
	}
	
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Oblivion
	//
	//	We are done with this object, send it to oblivion...
	//
	STDMETHODIMP_(void) Oblivion()
	{
#if SUPPORT_OCI7_COMPONENTS
		{
			Synch	sync(&m_csCursorList);					// Yes, I know this could cause contention, but it isn't likely to be a problem for a single connection.	

			while ( !m_cursorList.IsEmpty() )
			{
				CdaListEntry*	ple = (CdaListEntry*)m_cursorList.RemoveHead();
				CdaWrapper*		pCda;
				
				if (NULL != ple)
				{
					pCda = ple->pCda;

					if (NULL != pCda)
					{
						pCda->m_pResourceManagerProxy = NULL; 	// prevent the recursive RemoveCursorFromList
						RemoveCdaWrapper(pCda);
		 			}
					delete ple;
				}
			}
		}
#endif //SUPPORT_OCI7_COMPONENTS

		if (m_pITransaction)
		{
			m_pITransaction->Release();
			m_pITransaction = NULL;
		}
		
		if (m_pIDtcToXaHelper)
		{
			// When releasing the proxy, if the transaction state is DOOMED, it
			// means we're really busted and must do recovery (otherwise we're 
			// just fine)
			m_pIDtcToXaHelper->Close ((TRANSTATE_DOOMED == m_tranState));

			m_pIDtcToXaHelper->Release();
			m_pIDtcToXaHelper = NULL;
		}
		
		if (m_pIResourceManager)
		{
			m_pIResourceManager->Release();
			m_pIResourceManager = NULL;
		}
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_Abort
	//
	//	handle the ABORT action from the state machine
	//	
	STDMETHODIMP Do_Abort()
	{
		m_xarc = XaEnd ( &m_xid, m_rmid, TMFAIL );
		
		// TODO: Research what we should do if the XaEnd fails -- shouldn't we rollback anyway? (MTxOCI currently doesn't do that)
		if (XA_OK == m_xarc)
		{
			XaRollback ( &m_xid, m_rmid, TMNOFLAGS );
		} 

		// TODO: Shouldn't we be truthful here and say that the abort failed if it did?  (MTxOCI currently doesn't do that)
		m_pITransactionEnlistmentAsync->AbortRequestDone ( S_OK );

		EnqueueRequest(RequestQueueEntry(REQUEST_TXCOMPLETE));
		return S_OK;
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_Commit
	//
	//	handle the CONNECT action from the state machine
	//	
	STDMETHODIMP Do_Commit ()
	{
		m_xarc = XaCommit ( &m_xid, m_rmid, TMNOFLAGS );

		if (XA_OK == m_xarc)
		{
			m_pITransactionEnlistmentAsync->CommitRequestDone ( S_OK );
			EnqueueRequest(RequestQueueEntry(REQUEST_TXCOMPLETE));		
			return S_OK;
		}
		LogEvent_ResourceManagerError(L"xa_commit", m_xarc);
		return E_FAIL;
	}
	
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_Connect
	//
	//	handle the CONNECT action from the state machine
	//	
	STDMETHODIMP Do_Connect()
	{
		m_xarc = XaOpen ( m_szXAOpenString, m_rmid, TMNOFLAGS );

		if (XA_OK == m_xarc)
		{
			return S_OK;
		}
		LogEvent_ResourceManagerError(L"xa_open", m_xarc);
		return E_FAIL;
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_Disconnect
	//
	//	handle the DISCONNECT action from the state machine
	//	
	STDMETHODIMP Do_Disconnect()
	{
		if (TRANSTATE_ACTIVE == m_tranState)	// TODO: I don't like logic in the actions that depend upon the state that they're in; investigate an alternative.
		{
			m_xarc = XaEnd ( &m_xid, m_rmid, TMFAIL );

			if (XA_OK != m_xarc)
				LogEvent_ResourceManagerError(L"xa_end", m_xarc);
		}

		m_xarc = XaClose( "", m_rmid, TMNOFLAGS ); 

		if (XA_OK != m_xarc)
			LogEvent_ResourceManagerError(L"xa_close", m_xarc);

		return S_OK;	 // this method can't really fail...
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_Enlist
	//
	//	handle the ENLIST action from the state machine
	//	
	STDMETHODIMP Do_Enlist ()
	{
		HRESULT		hr;
		UUID		guidBQual;

		_ASSERT (m_pIDtcToXaHelper);						// Should have an instance of IDtcToXaHelper
		_ASSERT (NULL == m_pITransactionEnlistmentAsync);	// Should have been released by now
		_ASSERT (NULL == m_pTransactionEnlistment);			// Should have been released by now
					
		if (NULL == m_pIResourceManager)
		{
			return XACT_E_TMNOTAVAILABLE;
		}
		
		// Get the XID from the ITransaction; we have to provide a GUID for the branch
		// qualifier, so we just make up a new one for each enlist call so we can avoid
		// any conflicts.
		hr = UuidCreate (&guidBQual);
		if(RPC_S_OK != hr)
		{
			return HRESULT_FROM_WIN32(hr);
		}

 		hr = m_pIDtcToXaHelper->TranslateTridToXid (
 													m_pITransaction,
													&guidBQual,
													&m_xid
													);
		if (S_OK == hr)
 		{
 			// Now do the XaStart call to connect to the XA transaction.
			m_xarc = XaStart ( &m_xid, m_rmid, TMNOFLAGS );

			if (XA_OK == m_xarc)
			{
				// Get the OCI Handles (for OCI8) or the LDA (for OCI7).
#if SUPPORT_OCI7_COMPONENTS
				// The OCI7 methods will set the LDA pointer they want to use on this 
				// object, so we can use that as the indicator of which API is going to
				// be used
				if (NULL != m_plda)
				{
					// We have to get the LDA on the XA thread, because the XA Api's 
					// must be called on the thread that the xa_open was called on.
					hr = GetOCILda(m_plda, m_szXADbName);
				}
#if SUPPORT_OCI8_COMPONENTS
				else
#endif //SUPPORT_OCI8_COMPONENTS
#endif //SUPPORT_OCI7_COMPONENTS
#if SUPPORT_OCI8_COMPONENTS
				{
					// We have to get the handles on the XA thread, because the XA Api's 
					// must be called on the thread that the xa_open was called on.
					m_hOCIEnv 		= ::GetOCIEnvHandle (m_szXADbName);
					m_hOCISvcCtx 	= ::GetOCISvcCtxHandle (m_szXADbName);

					if (NULL == m_hOCIEnv || NULL == m_hOCISvcCtx)
 						hr = OCI_FAIL;	// TODO: Need to pick a better return code
 				}
#endif //SUPPORT_OCI8_COMPONENTS

				if ( SUCCEEDED(hr) )
				{
					// Create a new transaction enlistment object to receive Transaction Manager
					// callbacks
					CreateTransactionEnlistment(this, &m_pTransactionEnlistment);
					if (NULL == m_pTransactionEnlistment)
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						// there probably isn't a reason to store these in the object, because
						// they're never used.  Just in case, you might want them, though.
						XACTUOW	uow;
						LONG	isolationLevel;

						// Tell the resource manager that we're enlisted and provide it the 
						// enlistment object for it to call back on.
						hr = m_pIResourceManager->Enlist (	m_pITransaction,
															(ITransactionResourceAsync*)m_pTransactionEnlistment,
															(XACTUOW*)&uow,
															&isolationLevel,
															&m_pITransactionEnlistmentAsync	
															);
					}

					if ( !SUCCEEDED(hr) )
					{
						// If the enlistment failed for any reason, then we must do an XaEnd to
						// prevent dangling it, and we must release the transaction enlistment
						// object we created too.
						m_xarc = XaEnd ( &m_xid, m_rmid, TMFAIL );

						if (m_pTransactionEnlistment)
						{
							((IUnknown*)m_pTransactionEnlistment)->Release();
							m_pTransactionEnlistment = NULL;
						}
					}
				}
			}
			else
			{
				LogEvent_ResourceManagerError(L"xa_start", m_xarc);
				return E_FAIL;
			}
 		}
		return hr;
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_PrepareOnePhase
	//
	//	handle the PREPAREONEPHASE action from the state machine
	//	
	STDMETHODIMP Do_PrepareOnePhase ()
	{
		HRESULT		hr;
		wchar_t *	xacall = L"xa_end";

		// First, we have to get rid of our hold on the enlistment object
		if (m_pTransactionEnlistment)
		{
			((IUnknown*)m_pTransactionEnlistment)->Release();
			m_pTransactionEnlistment = NULL;
		}

		// Next, we have to "successfully" end our work on this branch.
		m_xarc = XaEnd ( &m_xid, m_rmid, TMSUCCESS ); 
		if (XA_OK == m_xarc)
		{
			// In case of a single phase prepare, we just have to commit with the
			// appropriate flag.
			xacall = L"xa_commit";
			m_xarc = XaCommit ( &m_xid, m_rmid, TMONEPHASE );
		}

		// No matter what, we have to tell DTC that we did something, because this
		// is an asynchronous call, remember?  Figure out what hresult we want to 
		// provide.
		switch (m_xarc)
		{
		case XA_OK: 		
				hr = XACT_S_SINGLEPHASE;
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPARESINGLECOMPLETED));
				break;
				
		case XAER_RMERR:
		case XAER_RMFAIL:
				hr = E_FAIL;
				LogEvent_ResourceManagerError(xacall, m_xarc);
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPAREFAILED));
				break;
				
		default:		
				hr = E_FAIL;
				LogEvent_ResourceManagerError(xacall, m_xarc);
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPAREUNKNOWN));
				break;
		}

		m_pITransactionEnlistmentAsync->PrepareRequestDone ( hr, 0x0, 0x0 );
		return hr;
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_PrepareTwoPhase
	//
	//	handle the PREPARETWOPHASE action from the state machine
	//	
	STDMETHODIMP Do_PrepareTwoPhase()
	{
		HRESULT		hr;
		wchar_t *	xacall = L"xa_end";

		// First, we have to get rid of our hold on the enlistment object
		if (m_pTransactionEnlistment)
		{
			((IUnknown*)m_pTransactionEnlistment)->Release();
			m_pTransactionEnlistment = NULL;
		}

		// Next, we have to "successfully" end our work on this branch.
		m_xarc = XaEnd ( &m_xid, m_rmid, TMSUCCESS ); 
		if (XA_OK == m_xarc)
		{
			xacall = L"xa_prepare";
			m_xarc = XaPrepare ( &m_xid, m_rmid, TMNOFLAGS );
		}

		// No matter what, we have to tell DTC that we did something, because this
		// is an asynchronous call, remember?  Figure out what hresult we want to 
		// provide.
		switch (m_xarc)
		{
		case XA_OK: 		
				hr = S_OK;
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPARECOMPLETED));
				break;
				
		case XA_RDONLY:
				hr = XACT_S_READONLY;
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPARESINGLECOMPLETED));
				break;
				
		case XAER_RMERR:
		case XAER_RMFAIL:
				hr = E_FAIL;
				LogEvent_ResourceManagerError(xacall, m_xarc);
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPAREFAILED));
				break;
				
		default:		
				hr = E_FAIL;
				LogEvent_ResourceManagerError(xacall, m_xarc);
				EnqueueRequest(RequestQueueEntry(REQUEST_PREPAREUNKNOWN));
				break;
		}
	
		m_pITransactionEnlistmentAsync->PrepareRequestDone ( hr, 0x0, 0x0 );
		return hr;
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.Do_UnilateralAbort
	//
	//	handle the UNILATERALABORT action from the state machine
	//	
	STDMETHODIMP Do_UnilateralAbort()
	{
		ITransactionEnlistment*	pTransactionEnlistment = (ITransactionEnlistment*)m_pTransactionEnlistment;
		m_pTransactionEnlistment = NULL;
		
		if (NULL != pTransactionEnlistment)
		{
			pTransactionEnlistment->UnilateralAbort();
			pTransactionEnlistment->Release();
		}
		
		return Do_Disconnect();
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.DequeueRequest 
	//
	// 	grabs the next request off the queue of requests for the worker thread to process
	//
	RequestQueueEntry DequeueRequest ()
	{
		Synch	sync(&m_csRequestQueue);					// Yes, I know this could cause contention, but it isn't likely to be a problem for a single connection.	

		if (m_nextQueueEntry < m_lastQueueEntry)
			return m_requestQueue[m_nextQueueEntry++];

		// if the queue is empty, reset the queue to the beginning and return the fact that
		// there isn't anything.
		m_nextQueueEntry = m_lastQueueEntry = 0;
		return RequestQueueEntry(REQUEST_IDLE);
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.EnqueueRequest 
	//
	// 	puts the request of the queue of requests for the worker thread to process
	//
	void EnqueueRequest (RequestQueueEntry entry)
	{
		Synch	sync(&m_csRequestQueue);					// Yes, I know this could cause contention, but it isn't likely to be a problem for a single connection.	

		// if the queue is empty, reset the queue to the beginning
		if (m_nextQueueEntry == m_lastQueueEntry)
			m_nextQueueEntry = m_lastQueueEntry = 0;
		
		_ASSERT(MAX_QUEUE > m_lastQueueEntry+1);		// Should never exceed this!  there are only a few async requests!

		m_requestQueue[m_lastQueueEntry++] = entry;
	}
	
	//-----------------------------------------------------------------------------
	// ProcessRequestInternal 
	//
	// Oracle requires that all XA calls for a transaction be made from the
	// same thread; if you don't do this, the XA calls will return XAER_RMERR.
	// So, we have to marshal the request over to a worker thread... (Boo hiss)
	//
	STDMETHODIMP ProcessRequestInternal(
			RequestQueueEntry	request,
			BOOL				fAsync
			)
	{
		DWORD	 dwRet;
		BOOL	 fSetValue;
		HRESULT* phr = NULL;
		HRESULT	 hr = S_OK;
		
		// Unsignal the event on which this thread will be blocked (if we're not 
		// supposed to do this in an async way)  We need to do this, because we're
		// going to wait for this event, and if the previous request was async, 
		// it would not have waited, which causes the reset to occur.
		if (FALSE == fAsync)
		{
			ResetEvent (m_heventWorkerDone);
			phr = &hr;
		}

		// Store the request and tell the worker thread to begin.
		request.m_phr = phr;
		EnqueueRequest(request);

		fSetValue = SetEvent (m_heventWorkerStart);
		_ASSERT (fSetValue);

		// If this is a synchronous request, we have to wait for the worker thread
		// to complete (duh!) before returning the result.
		if (FALSE == fAsync)
		{
			if ((dwRet = WaitForSingleObject(m_heventWorkerDone, INFINITE)) != WAIT_OBJECT_0) 
			{
				LogEvent_InternalError(L"Thread call to worker thread Failed");
				return ResultFromScode(E_FAIL);			// Thread call to worker thread Failed		
			}
			return hr;
		}

		// Asynchronous requests always succeed;
		return S_OK;
	}

	
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.StateMachine 
	//
	//	Handle a single request, taking the appropriate action(s) and modifying the
	//	transaction state of the accordingly.
	//
	STDMETHODIMP StateMachine(
			REQUEST request
			)
	{
		if (request < 0 || request > REQUEST_ABANDON)
			return E_INVALIDARG;

		// The state machine only works with these states; anything else is an
		// an error state that we shouldn't be in...
		if (m_tranState < 0 || m_tranState > TRANSTATE_DOOMED)
			return E_UNEXPECTED;	// TODO: Pick a better return code

		// Here's the meat of the state machine.
		HRESULT		hr = S_OK;
		TRANSTATE	newTranState = (TRANSTATE)stateMachine[m_tranState][request].newState;
		ACTION 		action = (ACTION)stateMachine[m_tranState][request].action;
		BOOL		doomOnFailure = FALSE;

	 	DBGTRACE (L"\tMTXOCI8: TID=%-4x > DBNAME=%S RMID=%-5d tranState=%-22.22s request=%-17.17s action=%-15.15s newstate=%-22.22s\n",
					GetCurrentThreadId(), 
					m_szXADbName,
					m_rmid,
					STATENAME(m_tranState), 
					REQUESTNAME(request), 
					ACTIONNAME(action), 
					STATENAME(newTranState), 
					m_szXAOpenString
					);

		if (NULL != action)
		{
			switch (action)
			{
				case ACTION_CONNECT:		hr = Do_Connect ();			break;
				case ACTION_DISCONNECT:		hr = Do_Disconnect ();		break;
				case ACTION_ENLIST:			hr = Do_Enlist ();			break;
				case ACTION_PREPAREONEPHASE:hr = Do_PrepareOnePhase ();	doomOnFailure = TRUE;	break;
				case ACTION_PREPARETWOPHASE:hr = Do_PrepareTwoPhase ();	doomOnFailure = TRUE;	break;
				case ACTION_ABORT:			hr = Do_Abort ();			doomOnFailure = TRUE;	break;
				case ACTION_COMMIT:			hr = Do_Commit ();			doomOnFailure = TRUE;	break;
				case ACTION_UNILATERALABORT:hr = Do_UnilateralAbort ();	break;
			}
		}

		// If the action fails, this transaction is DOOMED.
		if ( FAILED(hr) )
		{
			if (doomOnFailure)
				newTranState = TRANSTATE_DOOMED;
			else
				newTranState = m_tranState;
		}

		DBGTRACE(L"\tMTXOCI8: TID=%-4x < DBNAME=%S RMID=%-5d tranState=%-22.22s request=%-17.17s action=%-15.15s newstate=%-22.22s hr=0x%x\n",
					GetCurrentThreadId(), 
					m_szXADbName,
					m_rmid,
					STATENAME(m_tranState), 
					REQUESTNAME(request), 
					ACTIONNAME(action), 
					STATENAME(newTranState), 
					hr);

		// When we get an error from the state machine, log it so we can keep track of it.
		if (TRANSTATE_ERROR == newTranState)
		{
			LogEvent_UnexpectedEvent(STATENAME(m_tranState), REQUESTNAME(request));
			hr = E_UNEXPECTED;
		}

		m_tranState = newTranState;

		if (TRANSTATE_DONE	 == newTranState
		 || TRANSTATE_DOOMED == newTranState
		 || TRANSTATE_ERROR	 == newTranState)
		{
			Cleanup();
		}

		if (TRANSTATE_OBLIVION == newTranState)
		{
			Oblivion();		
		}
		return hr;
	}
	
	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.StartWorkerThread 
	//
	// 	Initialize for the worker thread, if it hasn't been already
	//
	STDMETHODIMP StartWorkerThread ()
	{
		DWORD dwRet;
		
		if ( m_heventWorkerStart )
		{
			ResetEvent (m_heventWorkerStart);
		}
		else
		{
			m_heventWorkerStart = CreateEvent (NULL, FALSE, FALSE, NULL);	//3 SECURITY REVIEW: This is safe.

			if ( !m_heventWorkerStart )
			{
				goto ErrorExit;
			}
		}
		
		if ( m_heventWorkerDone )
		{
			ResetEvent (m_heventWorkerDone);
		}
		else
		{
			m_heventWorkerDone = CreateEvent (NULL, FALSE, FALSE, NULL);	//3 SECURITY REVIEW: This is safe.

			if ( !m_heventWorkerDone )
			{
				goto ErrorExit;
			}
		}

		if ( !m_hthreadWorker )
		{
			m_hthreadWorker = (HANDLE)_beginthreadex
											(
											NULL,					// pointer to thread security attributes (NULL==default)
											0,						// initial thread stack size, in bytes (0==default)
											WorkerThread,			// pointer to thread function
											this,					// argument for new thread
											0,						// creation flags
											(unsigned *)&m_dwThreadIdWorker		// pointer to returned thread identifier
											);
			if ( !m_hthreadWorker )
			{
				goto ErrorExit;
			}

			DBGTRACE (L"MTXOCI8: Creating RM Worker TID=%-4x\n", m_dwThreadIdWorker );
			
			if ( (dwRet = WaitForSingleObject(m_heventWorkerDone,INFINITE)) != WAIT_OBJECT_0)
			{
				_ASSERTE (!"Worker thread didn't wake up???");
				DebugBreak();
			}
		}
		return ResultFromScode(S_OK);

	ErrorExit:
		if (m_heventWorkerStart)
		{
			CloseHandle(m_heventWorkerStart);
			m_heventWorkerStart = NULL;
		}

		if (m_heventWorkerDone)
		{
			CloseHandle(m_heventWorkerDone);
			m_heventWorkerDone = NULL;
		}

		LogEvent_InternalError(L"Failed to create worker thread");
		DebugBreak();
		return ResultFromScode(E_FAIL);			// Failed to create worker thread
	}	

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.StopWorkerThread 
	//
	//	Stop the worker thread, if it hasn't been already
	//
	STDMETHODIMP StopWorkerThread ()
	{
		if (m_hthreadWorker)
		{
			DBGTRACE (L"MTXOCI8: Telling RM Worker TID=%-4x to stop\n", m_dwThreadIdWorker );

			// Tell the thread to exit; we use the internal routine, because the
			// external one fails if the request is STOPALLWORK.
			ProcessRequestInternal(RequestQueueEntry(REQUEST_STOPALLWORK), FALSE);

			// Wait for the thread to exit
			while (WaitForSingleObject(m_hthreadWorker, 500) == WAIT_TIMEOUT)
			{
				Sleep (0);  // This is OK, because it only fires if the 500 msec wait above timed out.
			}
			
			// Clean up
			if( m_hthreadWorker )
				CloseHandle(m_hthreadWorker);
			
			m_hthreadWorker = NULL;
			m_dwThreadIdWorker = 0;
		}
		
		if (m_heventWorkerStart)
		{
			CloseHandle(m_heventWorkerStart);
			m_heventWorkerStart = NULL;
		}
		
		if (m_heventWorkerDone)
		{
			CloseHandle(m_heventWorkerDone);
			m_heventWorkerDone = NULL;
		}
		return ResultFromScode(S_OK);
	}

	//-----------------------------------------------------------------------------
	// ResourceManagerProxy.WorkerThread 
	//
	// 	Thread routine for the worker thread that processes the resource manager
	//	state machine
	//
	static unsigned __stdcall WorkerThread
		(
		void* pThis		//@parm IN  | pointer to ResourceManager Object
		)
	{
		ResourceManagerProxy*	pResourceManagerProxy = static_cast<ResourceManagerProxy *>(pThis);
		BOOL					fSetValue;
		DWORD					dwThreadID = GetCurrentThreadId();
		DWORD					dwRet;
		MSG						msg;
		HRESULT 				hr;
		RequestQueueEntry		entry;

		DBGTRACE (L"\tMTXOCI8: TID=%-4x Starting RM Worker Thread\n", dwThreadID);

		// Signal the application thread that I have arrived
		SetEvent (pResourceManagerProxy->m_heventWorkerDone);

		// Service work queue until told to do otherwise
		for (;;)
		{
			entry = pResourceManagerProxy->DequeueRequest();
			
			if (REQUEST_STOPALLWORK == entry.m_request)
			{
				DBGTRACE (L"\tMTXOCI8: TID=%-4x Stopping RM Worker Thread\n", dwThreadID);
				break;
			}

			if (REQUEST_IDLE == entry.m_request)
			{
				// Indicate that we're done
				fSetValue = SetEvent (pResourceManagerProxy->m_heventWorkerDone);
				_ASSERT (fSetValue);
				
				// If we recieve an Idle message, then we've exhausted the queue, 
				// so we go and wait for another start event;
				
			 	// Process messages or wonderful OLE will hang
				dwRet = MsgWaitForMultipleObjects(1, &pResourceManagerProxy->m_heventWorkerStart, FALSE, INFINITE, QS_ALLINPUT);

				if (WAIT_OBJECT_0 != dwRet)
				{
					if (dwRet == WAIT_OBJECT_0 + 1)
					{
						while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
						{
							TranslateMessage(&msg);
							DispatchMessage(&msg);
						}
					}
					else
					{				
						_ASSERTE (!"Unexpected reason for the thread to wake up!");
						DebugBreak();
						break;
					}
				}
				continue; // don't process idle events...
			} 

			// Service the request
#if SUPPORT_OCI7_COMPONENTS
			if (REQUEST_OCICALL == entry.m_request)
				hr = Do_Oci7Call(entry.m_idxOciCall,entry.m_pvCallStack,entry.m_cbCallStack);
			else
#endif //SUPPORT_OCI7_COMPONENTS
				hr = pResourceManagerProxy->StateMachine(entry.m_request);
	
			if (entry.m_phr)
				*(entry.m_phr) = hr;
 		} 

		fSetValue = SetEvent (pResourceManagerProxy->m_heventWorkerDone);
		_ASSERT (fSetValue);
		
		DBGTRACE (L"\tMTXOCI8: TID=%-4x RM Worker Thread Stopped, tranState=%-22.22s cref=%d\n", dwThreadID, STATENAME(pResourceManagerProxy->m_tranState), pResourceManagerProxy->m_cRef);
		return 0;
	}
			
};

//-----------------------------------------------------------------------------
// CreateResourceManagerProxy
//
//	Instantiates a transaction enlistment for the resource manager
//
HRESULT CreateResourceManagerProxy(
	IDtcToXaHelper *		i_pIDtcToXaHelper,	
	GUID *					i_pguidRM,
	char*					i_pszXAOpenString,
	char*					i_pszXADbName,
	int						i_rmid,
	IResourceManagerProxy**	o_ppResourceManagerProxy
	)
{
	_ASSERT(o_ppResourceManagerProxy);
	
	ResourceManagerProxy* pResourceManagerProxy = new ResourceManagerProxy();

	if (pResourceManagerProxy)
	{
		*o_ppResourceManagerProxy = pResourceManagerProxy;
		return pResourceManagerProxy->Init(
										i_pIDtcToXaHelper,
										i_pguidRM,
										i_pszXAOpenString,
										i_pszXADbName,
										i_rmid
										);
	}
	
	*o_ppResourceManagerProxy = NULL;
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\transactionenlistment.h ===
//-----------------------------------------------------------------------------
// File:		TransactionEnlistment.h
//
// Copyright:   Copyright (c) Microsoft Corporation         
//
// Contents: 	Definitions for the TransactionEnlistment object.
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __TRANSACTIONENLISTMENT_H_
#define __TRANSACTIONENLISTMENT_H_

#include "ResourceManagerProxy.h"

class TransactionEnlistment;

// Interface-based programming -- here's the interface for the transaction enlistment object
interface ITransactionEnlistment : public ITransactionResourceAsync
{
	virtual STDMETHODIMP UnilateralAbort() = 0;
};


//-----------------------------------------------------------------------------
// CreateTransactionEnlistment
//
//	Instantiates a transaction enlistment for the resource manager
//
void CreateTransactionEnlistment(
	IResourceManagerProxy*	pResourceManager,
	TransactionEnlistment**	ppTransactionEnlistment
	);

#endif // __TRANSACTIONENLISTMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\xaswitch.h ===
//-----------------------------------------------------------------------------
// File:		XaSwitch.h
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Declaration of our XA Switch Wrappers
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#ifndef __XASWITCH_H_
#define __XASWITCH_H_

extern xa_switch_t	*	g_pXaSwitchOracle;

int __cdecl XaOpen (char * i_pszOpenString, int i_iRmid, long i_lFlags);
int __cdecl XaClose (char * i_pszCloseString, int i_iRmid, long i_lFlags);
int __cdecl XaRollback (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaPrepare (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaCommit (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaRecover (XID * i_prgxid, long i_lCnt, int i_iRmid, long i_lFlag);
int __cdecl XaStart (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaEnd (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaForget (XID * i_pxid, int i_iRmId, long i_lFlags);
int __cdecl XaComplete (int * pi1, int * pi2, int iRmId, long lFlags);

#endif //__XASWITCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\mtxoci8\xaswitch.cpp ===
//-----------------------------------------------------------------------------
// File:		XaSwitch.cpp
//
// Copyright: 	Copyright (c) Microsoft Corporation         
//
// Contents: 	Implementation of XA Switch Wrappers and the GetXaSwitch API
//
// Comments: 		
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

//-----------------------------------------------------------------------------
// Xa...
//
//	Wrapper routines for Oracle's XA methods; for the most part, they just
//	make sure that we capture any exceptions that occur
//
int __cdecl XaOpen (char * i_pszOpenString, int i_iRmid, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_open_entry(i_pszOpenString, i_iRmid, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_open(%S, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pszOpenString, i_iRmid, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_open");
		rc = XAER_RMFAIL;
	}

	return rc;
} 
//-----------------------------------------------------------------------------
int __cdecl XaClose (char * i_pszCloseString, int i_iRmid, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_close_entry("", i_iRmid, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_close(%S, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pszCloseString, i_iRmid, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_close");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaRollback (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_rollback_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_rollback(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_rollback");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaPrepare (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_prepare_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_prepare(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_prepare");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaCommit (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_commit_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_commit(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_commit");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaRecover (XID * i_prgxid, long i_lCnt, int i_iRmid, long i_lFlag)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_recover_entry(i_prgxid, i_lCnt, i_iRmid, i_lFlag);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_recover(0x%x, 0x%x, %d, 0x%x) returns %d\n", GetCurrentThreadId(), i_prgxid, i_lCnt, i_iRmid, i_lFlag, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_recover");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaStart (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_start_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_start(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_start");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaEnd (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_end_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_end(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_end");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaForget (XID * i_pxid, int i_iRmId, long i_lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_forget_entry(i_pxid, i_iRmId, i_lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_forget(0x%x, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), i_pxid, i_iRmId, i_lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_forget");
		rc = XAER_RMFAIL;
	}

	return rc;
}
//-----------------------------------------------------------------------------
int __cdecl XaComplete (int * pi1, int * pi2, int iRmId, long lFlags)
{
	_ASSERT (g_pXaSwitchOracle);

	int		rc;
#if SINGLE_THREAD_THRU_XA
	Synch	sync(&g_csXaInUse);
#endif //SINGLE_THREAD_THRU_XA

	try
	{
		rc = g_pXaSwitchOracle->xa_complete_entry(pi1, pi2, iRmId, lFlags);
		DBGTRACE(L"\tMTXOCI8: TID=%03x\t\txa_complete(%d, %d, 0x%x, 0x%x) returns %d\n", GetCurrentThreadId(), pi1, pi2, iRmId, lFlags, rc);
	}
	catch (...)
	{
		LogEvent_ExceptionInXACall(L"xa_complete");
		rc = XAER_RMFAIL;
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\cataloglocation.cs ===
//------------------------------------------------------------------------------
// <copyright file="CatalogLocation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;

    /// <include file='doc\CatalogLocation.uex' path='docs/doc[@for="CatalogLocation"]/*' />
    internal enum CatalogLocation { // MDAC 79449

        /// <include file='doc\CatalogLocation.uex' path='docs/doc[@for="CatalogLocation.Start"]/*' />
        Start = 0,

        /// <include file='doc\CatalogLocation.uex' path='docs/doc[@for="CatalogLocation.End"]/*' />
        End = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\commandbuilderbehavior.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;

    [ Flags() ] 
    internal enum CommandBuilderBehavior
    {
        Default = 0,
        UpdateSetSameValue = 1,
        UseRowVersionInUpdateWhereClause = 2,
        UseRowVersionInDeleteWhereClause = 4,
        UseRowVersionInWhereClause = UseRowVersionInUpdateWhereClause | UseRowVersionInDeleteWhereClause,
        PrimaryKeyOnlyUpdateWhereClause = 16,
        PrimaryKeyOnlyDeleteWhereClause = 32,
        PrimaryKeyOnlyWhereClause = PrimaryKeyOnlyUpdateWhereClause | PrimaryKeyOnlyDeleteWhereClause,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\adapterswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdapterSwitches.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Diagnostics;

#if DEBUG
    sealed internal class AdapterSwitches {

        private static TraceSwitch dataError;
        private static TraceSwitch dataSchema;
        private static TraceSwitch dataTrace;
        private static TraceSwitch dataValue;

        private static BooleanSwitch oledbMemory;

        private static TraceSwitch adoTrace;
        private static TraceSwitch adoSQL;

        private static TraceSwitch sqlPacketInfo;
        private static TraceSwitch sqlNetlibVersion;
        private static TraceSwitch sqlNetlibInfo;
        private static TraceSwitch sqlExceptionInfo;
        private static TraceSwitch sqlTDSStream;
        private static TraceSwitch sqlTimeout;
        private static TraceSwitch sqlExceptionStack;
        private static TraceSwitch sqlConnectionInfo;
        private static TraceSwitch sqlMetadataInfo;
        private static TraceSwitch sqlParameterInfo;
        private static TraceSwitch sqlAutoGenUpdate;
        private static TraceSwitch sqlStorage;
        private static TraceSwitch sqlDebugIL;
        private static TraceSwitch sqlPooling;
        private static TraceSwitch sqlParsing;

        private static BooleanSwitch	ociTracing;
        private static BooleanSwitch	objectPoolActivity;
        

        public static TraceSwitch DataError {
            get {
                if (dataError == null) {
                    dataError = new TraceSwitch("Data.Error", "trace exceptions");
                }
                return dataError;
            }
        }

        public static TraceSwitch DataSchema {
            get {
                if (dataSchema == null) {
                    dataSchema = new TraceSwitch("Data.Schema", "Enable tracing for schema actions.");
                }
                return dataSchema;
            }
        }

        public static TraceSwitch DataTrace {
            get {
                if (dataTrace == null) {
                    dataTrace = new TraceSwitch("Data.Trace", "Enable tracing of Data calls.");
                }
                return dataTrace;
            }
        }

        public static TraceSwitch DataValue {
            get {
                if (dataValue == null) {
                    dataValue = new TraceSwitch("Data.Value", "trace the setting of data");
                }
                return dataValue;
            }
        }

        public static BooleanSwitch OleDbMemory {
            get {
                if (oledbMemory == null) {
                    oledbMemory = new BooleanSwitch("OleDb.Memory", "Enable tracing of OleDb memory allocaton and free");
                }
                return oledbMemory;
            }
        }

        public static TraceSwitch OleDbTrace {
            get {
                if (adoTrace == null) {
                    adoTrace = new TraceSwitch("OleDb.Trace", "Enable tracing of OleDb to OLEDB interaction");
                }
                return adoTrace;
            }
        }

        public static TraceSwitch DBCommandBuilder {
            get {
                if (adoSQL == null) {
                    adoSQL = new TraceSwitch("OleDb.SQL", "Enable tracing of OleDb generating SQL statements");
                }
                return adoSQL;
            }
        }
        public static TraceSwitch SqlPacketInfo {
            get {
                if (sqlPacketInfo == null) {
                    sqlPacketInfo = new TraceSwitch("SqlPacketInfo", "info on packets sent");
                }
                return sqlPacketInfo;
            }
        }

        public static TraceSwitch SqlNetlibVersion {
            get {
                if (sqlNetlibVersion == null) {
                    sqlNetlibVersion = new TraceSwitch("SqlNetlibVersion", "version of netlib used for connections");
                }
                return sqlNetlibVersion;
            }
        }

        public static TraceSwitch SqlNetlibInfo {
            get {
                if (sqlNetlibInfo == null) {
                    sqlNetlibInfo = new TraceSwitch("SqlNetlibInfo", "trace netlib reads");
                }
                return sqlNetlibInfo;
            }
        }

        public static TraceSwitch SqlExceptionInfo {
            get {
                if (sqlExceptionInfo == null) {
                    sqlExceptionInfo = new TraceSwitch("SqlExceptionInfo", "exception information");
                }
                return sqlExceptionInfo;
            }
        }

        public static TraceSwitch SqlTDSStream {
            get {
                if (sqlTDSStream == null) {
                    sqlTDSStream = new TraceSwitch("SqlTDSStream", "tds stream info");
                }
                return sqlTDSStream;
            }
        }

        public static TraceSwitch SqlTimeout {
            get {
                if (sqlTimeout == null) {
                    sqlTimeout = new TraceSwitch("SqlTimeout", "timeout tracing");
                }
                return sqlTimeout;
            }
        }

        public static TraceSwitch SqlExceptionStack {
            get {
                if (sqlExceptionStack == null) {
                    sqlExceptionStack = new TraceSwitch("SqlExceptionStack", "prints correct call stack for exceptions");
                }
                return sqlExceptionStack;
            }
        }

        public static TraceSwitch SqlConnectionInfo {
            get {
                if (sqlConnectionInfo == null) {
                    sqlConnectionInfo = new TraceSwitch("SqlConnectionInfo", "connection information");
                }
                return sqlConnectionInfo;
            }
        }

        public static TraceSwitch SqlMetadataInfo {
            get {
                if (sqlMetadataInfo == null) {
                    sqlMetadataInfo = new TraceSwitch("SqlMetadataInfo", "metadata information");
                }
                return sqlMetadataInfo;
            }
        }

        public static TraceSwitch SqlParameterInfo {
            get {
                if (sqlParameterInfo == null) {
                    sqlParameterInfo = new TraceSwitch("SqlParameterInfo", "parameter information");
                }
                return sqlParameterInfo;
            }
        }

        public static TraceSwitch SqlAutoGenUpdate {
            get {
                if (sqlAutoGenUpdate == null) {
                    sqlAutoGenUpdate = new TraceSwitch("SqlAutoGenUpdate", "trace autogen'd update statements");
                }
                return sqlAutoGenUpdate;
            }
        }

        public static TraceSwitch SqlStorage {
            get {
                if (sqlStorage == null) {
                    sqlStorage = new TraceSwitch("SqlStorage", "trace creation and destruction of storage objects");
                }
                return sqlStorage;
            }
        }

        public static TraceSwitch SqlDebugIL {
            get {
                if (sqlDebugIL == null) {
                    sqlDebugIL = new TraceSwitch("SqlDebugIL", "turn on debug dynamic IL generation statements");
                }
                return sqlDebugIL;
            }
        }

        public static TraceSwitch SqlPooling {
            get {
                if (sqlPooling == null) {
                    sqlPooling = new TraceSwitch("SqlPooling", "trace operation of pooled objects");
                }
                return sqlPooling;
            }
        }

        public static TraceSwitch SqlParsing {
            get {
                if (sqlParsing == null) {
                    sqlParsing = new TraceSwitch("SqlParsing", "trace parsing of connection string");
                }
                return sqlParsing;
            }
        }

        public static BooleanSwitch OciTracing {
            get {
                if (ociTracing == null) {
                    ociTracing = new BooleanSwitch("OciTracing", "trace oci calls");
                }
                return ociTracing;
            }
        }

        public static BooleanSwitch ObjectPoolActivity {
            get {
                if (objectPoolActivity == null) {
                    objectPoolActivity = new BooleanSwitch("ObjectPoolActivity", "trace object pool activity");
                }
                return objectPoolActivity;
            }
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\crypto.cs ===
//------------------------------------------------------------------------------
// <copyright file="Crypto.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if USECRYPTO // MDAC 82831

namespace System.Data.OracleClient {

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;

    sealed internal class Crypto {
        private static SymmetricAlgorithm s_oDes;
        private static InterlockedStack   s_oEncryptorStack;
        private static InterlockedStack   s_oDecryptorStack;
        private static InterlockedStack   s_oHashAlgoStack;

        private static object             s_initLock = new object();
        private static bool               s_useEncryption = true;

        private static void EnsureConfig() {
            if (null == s_oDes) {
                ConfigureEncryptionObject();
            }
        }

        private static void ConfigureEncryptionObject() {
            lock (s_initLock) {
                if (null == s_oDes) {
                    s_oEncryptorStack = new InterlockedStack();
                    s_oDecryptorStack = new InterlockedStack();
                    s_oHashAlgoStack = new InterlockedStack();

                    DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                    des.GenerateKey();
                    des.GenerateIV();
                    s_oDes = des;
                }
            }
        }

        private static ICryptoTransform GetCryptoTransform(bool fEncrypt) {
            InterlockedStack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            ICryptoTransform ct = (st.Pop() as ICryptoTransform);
            if (null == ct) {
                ct = NewCryptTransform(fEncrypt);
            }
            return ct;
        }

        private static ICryptoTransform NewCryptTransform(bool fEncrypt) {
            lock(s_oDes) {
                return (fEncrypt ? s_oDes.CreateEncryptor() : s_oDes.CreateDecryptor());
            }
        }

        private static HashAlgorithm NewHashAlgorithm() {
            return new SHA1Managed();
        }

        private static void ReturnCryptoTransform(bool fEncrypt, ICryptoTransform ct) {
            InterlockedStack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            st.Push(ct);
        }

        internal static byte [] EncryptOrDecryptData(bool fEncrypt, byte[] inputBuffer, int inputOffset, int inputCount) {
            byte[] outputBuffer;
            if (s_useEncryption) {
                EnsureConfig();
                ICryptoTransform ct = GetCryptoTransform(fEncrypt);
                outputBuffer = ct.TransformFinalBlock(inputBuffer, inputOffset, inputCount);
                ReturnCryptoTransform(fEncrypt, ct); // if an exception occurs, don't return ct to stack
            }
            else {
                outputBuffer = new byte[inputCount];
                Buffer.BlockCopy(inputBuffer, inputOffset, outputBuffer, 0, inputCount);
            }
            return outputBuffer;
        }

        internal static string ComputeHash(string value) {
            if (s_useEncryption) {
                EnsureConfig();
                HashAlgorithm algorithm = (HashAlgorithm) s_oHashAlgoStack.Pop();
                if (null == algorithm) { algorithm = NewHashAlgorithm(); }

                byte[] encrypted;
                byte[] bytes = new byte[ADP.CharSize * value.Length];
                GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                try {
                    System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, bytes, 0);
                    encrypted = algorithm.ComputeHash(bytes);
                }
                finally {
                    Array.Clear(bytes, 0, bytes.Length);
                    if (handle.IsAllocated) {
                        handle.Free();
                    }
                }
                s_oHashAlgoStack.Push(algorithm);
                return System.Text.Encoding.Unicode.GetString(encrypted, 0, encrypted.Length);
            }
            return value;
        }

        static internal int DecryptToBlock(string value, byte[] outblock, int offset, int length) {
            int plainLength = 0;
            if ((null != value) && (0 < value.Length)) {
                try {
                    byte[] plainText = null;
                    try {
                        byte[] encrypted = new byte[ADP.CharSize*value.Length];
                        System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, encrypted, 0);
                        if (s_useEncryption) {
                            plainText = EncryptOrDecryptData(false, encrypted, 0, encrypted.Length);
                        }
                        else {
                            plainText = encrypted;
                        }
                        Debug.Assert((0 <= offset) && (0 < length) && (plainText.Length <= length), "Decrypt outblock too small");
                        Buffer.BlockCopy(plainText, 0, outblock, offset, Math.Min(plainText.Length, length)); 
                    }
                    finally {
                        if (null != plainText) {
                            plainLength = plainText.Length;
                            Array.Clear(plainText, 0, plainLength);
                            plainText = null;
                        }
                    }
                }
                catch {
                    throw;
                }
            }
            return plainLength;
        }

        static internal byte[] DecryptString(string value) { // UNDONE: MDAC 82612
            byte[] plainText = null;            
            if ((null != value) && (0 < value.Length)) {
                byte[] encrypted = System.Text.Encoding.Unicode.GetBytes(value);
                if (s_useEncryption) {
                    plainText = EncryptOrDecryptData(false, encrypted, 0, encrypted.Length);
                }
                else {
                    plainText = encrypted;
                }
            }
            return ((null != plainText) ? plainText : ADP.EmptyByteArray);
        }

        static internal string EncryptString(string value) {
            if (s_useEncryption) {
                Debug.Assert(!ADP.IsEmpty(value), "empty string");
                byte[] encryptedBlock = null;
                try {
                    byte[] plainText = new byte[ADP.CharSize*value.Length];
                    GCHandle handle = GCHandle.Alloc(plainText, GCHandleType.Pinned); // MDAC 82612
                    try {
                        System.Text.Encoding.Unicode.GetBytes(value, 0, value.Length, plainText, 0);
                        encryptedBlock = EncryptOrDecryptData(true, plainText, 0, plainText.Length);
                    }
                    finally {
                        Array.Clear(plainText, 0, plainText.Length);
                        if (handle.IsAllocated) {
                            handle.Free();
                        }
                        plainText = null;
                    }
                }
                catch {
                    throw;
                }
                value = ((null != encryptedBlock) ? System.Text.Encoding.Unicode.GetString(encryptedBlock, 0, encryptedBlock.Length) : ADP.StrEmpty);
            }
            return ((null != value) ? value : ADP.StrEmpty);
        }

        static internal string EncryptFromBlock(char[] inblock, int offset, int length) {
            Debug.Assert((null != inblock) && (0 <= inblock.Length) , "no data to encrypt");
            Debug.Assert((0 <= offset) && (0 <= length) && (offset+length <= inblock.Length), "data to encrypt outofbound");

            string encrypted = null;
            if ((null != inblock) && (0 < length)) {
                if (s_useEncryption) {
                    byte[] encryptedBlock = null;
                    try {
                        byte[] plainText = new byte[ADP.CharSize*length];
                        GCHandle handle = GCHandle.Alloc(plainText, GCHandleType.Pinned); // MDAC 82612
                        try {
                            Buffer.BlockCopy(inblock, ADP.CharSize*offset, plainText, 0, ADP.CharSize*length);
                            encryptedBlock = EncryptOrDecryptData(true, plainText, 0, plainText.Length);
                        }
                        finally {
                            Array.Clear(plainText, 0, plainText.Length);
                            if (handle.IsAllocated) {
                                handle.Free();
                            }
                            plainText = null;
                        }
                    }
                    catch {
                        throw;
                    }
                    encrypted = System.Text.Encoding.Unicode.GetString(encryptedBlock, 0, encryptedBlock.Length);
                }
                else {
                    encrypted = new String(inblock, offset, length);
                }
            }
            return ((null != encrypted) ? encrypted : ADP.StrEmpty);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbobjectpoolmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBObjectPoolManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal sealed class DBObjectPoolManager
    {
        private Hashtable _map;

        public DBObjectPoolManager()
        {
            _map = new Hashtable();
        }

        public DBObjectPool FindOrCreatePool(DBObjectPoolControl ctrl)
        {
            Debug.Assert(ctrl != null, "Unexpected DefaultPoolControl null!");
            
            String poolKey      = ctrl.Key;
            DBObjectPool pool = FindPool(poolKey);

            if(pool == null)
            {
                lock (_map.SyncRoot) {
                    // Did somebody else created it while we were waiting?
                    pool = FindPool(poolKey);

                    if (pool == null) {
                        // Create a new pool, shove it into the map:
                        pool = new DBObjectPool(ctrl);
                        _map[poolKey] = pool;
                    }
                }
            }

            return(pool);
        }

        public DBObjectPool FindPool(String key)
        {
            // Returns null if the pool does not exist.
            return ((DBObjectPool)(_map[key]));
        }

        /*
        This is the previous implementation that has pool shutdown and requires a reader-
        writer lock.  Move to this implementation when pools do shutdown and go away.

        private ReaderWriterLock _rwlock; // instantiate in constructor

        public ConnectionPool FindOrCreatePool(DefaultPoolControl ctrl)
        {
            String poolKey      = ctrl.Key;
            ConnectionPool pool = FindPool(poolKey);
            if(pool != null) return(pool);
            
            try
            {
                _rwlock.AcquireWriterLock(-1);

                // Did somebody else created it while we were waiting?
                pool = (ConnectionPool)(_map[poolKey]);
                if(pool == null)
                {
                    // Create a new pool, shove it into the map:
                    pool = new ConnectionPool(ctrl);
                    _map[poolKey] = pool;
                }
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }
            }
            return(pool);
        }

        public ConnectionPool FindPool(String key)
        {
            ConnectionPool pool = null;

            // Returns null if the pool does not exist.
            try
            {
                _rwlock.AcquireReaderLock(-1);

                pool = (ConnectionPool)(_map[key]);
            }
            finally
            {
                try {
                    _rwlock.ReleaseReaderLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }
            }
            return(pool);
        }


        // Currently this is never called - since pools do not go away!
        public void ShutdownPool(String poolKey)
        {
            try {
                _rwlock.AcquireWriterLock(-1);

                ConnectionPool p = (ConnectionPool)(_map[poolKey]);
                if(p != null)
                {
                    p.Shutdown();
                    _map[poolKey] = null;
                    _map.Remove(poolKey);
                }
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.
                }            
            }
        }

        // Currently this is never called - since pools do not go away!
        public void Shutdown()
        {
            try {
                _rwlock.AcquireWriterLock(-1);

                foreach(DictionaryEntry e in _map)
                {
                    ConnectionPool p = (ConnectionPool)(e.Value);
                    if(p != null)
                    {
                        p.Shutdown();
                    }
                }
                _map.Clear();
            }
            finally
            {
                try {
                    _rwlock.ReleaseWriterLock();
                }
                catch (Exception) {
                    // This should only fail in the case the AcquireWriterLock call
                    // failed, or if there was a thread-abort and the AcquireWriterLock
                    // call did not have a chance to finish.                
                }
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbpooledobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleInternalConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
	using System.EnterpriseServices;
	using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
	using System.Text;	
	using System.Threading;
	
    abstract internal class DBPooledObject  {   
#if USEORAMTS
        sealed internal class TransactionWrapper {
            private IntPtr iunknown;

            ~TransactionWrapper() {
                if (IntPtr.Zero != this.iunknown) {
                    Marshal.Release(this.iunknown);
                    this.iunknown = IntPtr.Zero;
                }
            }

            internal TransactionWrapper(ITransaction transaction) {
                this.iunknown = Marshal.GetIUnknownForObject(transaction);
            }

            internal ITransaction GetITransaction() {
                ITransaction value = (ITransaction) System.Runtime.Remoting.Services.EnterpriseServicesHelper.WrapIUnknownWithComObject(this.iunknown);
                GC.KeepAlive(this);
                return value;
            }
        }
#endif //USEORAMTS

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private DBObjectPool			 _pool;					// the pooler that the connection came from
		private WeakReference			 _owningObject;			// the owning OracleConnection object, when not in the pool.	
		private int						 _pooledCount;			// the number of times this object has been pushed into the pool less the number of times it's been popped (0 == inPool)
#if USEORAMTS
        private TransactionWrapper       _transaction;			// cache the ITransaction in the case of manual enlistment
#endif //USEORAMTS
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		public DBPooledObject () {}

		public DBPooledObject ( DBObjectPool pool)
		{
			_pool = pool;
		}

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal bool IsEmancipated
		{
			get {
				bool value = (0 >= _pooledCount) && (null == _owningObject || (null != _owningObject && !_owningObject.IsAlive));
				return value; 
			}
		}

#if USEORAMTS
        public ITransaction ManualEnlistedTransaction {
            get {
                if (null == _transaction)
                    return null;
                    
                return _transaction.GetITransaction();
            }
            set {
            	if (null != value)
            		_transaction = new TransactionWrapper(value);
            	else 
            		_transaction = null;
            }
        }                
#endif //USEORAMTS
                        	
		private WeakReference OwningObject 
		{
			// We use a weak reference to the owning object so we can identify when
			// it has been garbage collected without thowing exceptions.
            get { return _owningObject; }
		}
		
		public DBObjectPool Pool
		{
			get { return _pool; }
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		public void PrePush(object expectedOwner)
		{
			lock (this) {
				//3 // The following tests are retail assertions of things we can't allow to happen.
				if (null == expectedOwner)
				{
					if (null != _owningObject && null != _owningObject.Target)
						throw ADP.InternalPoolerError(1); 		// new unpooled object has an owner
				}
				else
				{
					if ((null == _owningObject)
					  || (null != _owningObject && _owningObject.Target != expectedOwner))
					  	throw ADP.InternalPoolerError(2);		// unpooled object has incorrect owner
				}

				_pooledCount++;

				if (1 != _pooledCount)
					throw ADP.InternalPoolerError(3);			// pushing object onto stack a second time
				
				if (null != _owningObject)
					_owningObject.Target = null;
			}
		}

		public void PostPop (object newOwner)
		{
			lock (this) {
		        if (null == _owningObject) 
					_owningObject = new WeakReference(newOwner);
		       	else
		       	{
		       		if (null != _owningObject.Target)
		       			throw ADP.InternalPoolerError(4);		// pooled connection already has an owner!
		       		
		            _owningObject.Target = newOwner; 
	       		}

				_pooledCount--;

				if (0 != _pooledCount)
					throw ADP.InternalPoolerError(5);			// popping object off stack with multiple pooledCount
			}
		}

		abstract public void Activate();
		abstract public bool CanBePooled();
		abstract public void Cleanup();
		abstract public void Close();
		abstract public bool Deactivate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbschemarow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSchemaRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow"]/*' />
    /// <devdoc>
    /// </devdoc>
    sealed internal class DBSchemaRow {
        DBSchemaTable schemaTable;
        DataRow dataRow;

        static internal DBSchemaRow[] GetSortedSchemaRows(DataTable dataTable) { // MDAC 60609
            DataColumn sortindex = new DataColumn("SchemaMapping Unsorted Index", typeof(Int32)); // MDAC 67050
            dataTable.Columns.Add(sortindex);
            int count = dataTable.Rows.Count;
            for (int i = 0; i < count; ++i) {
                dataTable.Rows[i][sortindex] = i;
            };
            DBSchemaTable schemaTable = new DBSchemaTable(dataTable);

            const DataViewRowState rowStates = DataViewRowState.Unchanged | DataViewRowState.Added | DataViewRowState.ModifiedCurrent;
            DataRow[] dataRows = dataTable.Select(null, "ColumnOrdinal ASC", rowStates);
            Debug.Assert(null != dataRows, "GetSchemaRows: unexpected null dataRows");

            DBSchemaRow[] schemaRows = new DBSchemaRow[dataRows.Length];

            for (int i = 0; i < dataRows.Length; ++i) {
                schemaRows[i] = new DBSchemaRow(schemaTable, dataRows[i]);
            }
            return schemaRows;
        }
        
        static internal DBSchemaRow[] GetSchemaRows(DataTable dataTable) {
            DBSchemaTable schemaTable = new DBSchemaTable(dataTable);

            const DataViewRowState rowStates = DataViewRowState.Unchanged | DataViewRowState.Added | DataViewRowState.ModifiedCurrent;
            DataRow[] dataRows = ADP.SelectRows(dataTable, rowStates);
            Debug.Assert(null != dataRows, "GetSchemaRows: unexpected null dataRows");

            DBSchemaRow[] schemaRows = new DBSchemaRow[dataRows.Length];

            for (int i = 0; i < dataRows.Length; ++i) {
                schemaRows[i] = new DBSchemaRow(schemaTable, dataRows[i]);
            }
            return schemaRows;
        }

        internal DBSchemaRow(DBSchemaTable schemaTable, DataRow dataRow) {
            this.schemaTable = schemaTable;
            this.dataRow = dataRow;
        }

        internal DataRow DataRow {
            get {
                return dataRow;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.ColumnName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string ColumnName {
            get {
                Debug.Assert(null != schemaTable.ColumnName, "no column ColumnName");
                object value = dataRow[schemaTable.ColumnName, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToString(value);
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.ColumnName, "missing column ColumnName");
                dataRow[schemaTable.ColumnName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Ordinal"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int32 Ordinal {
            get {
                Debug.Assert(null != schemaTable.Ordinal, "no column Ordinal");
                return Convert.ToInt32(dataRow[schemaTable.Ordinal, DataRowVersion.Default]);
            }
            set {
                Debug.Assert(null != schemaTable.Ordinal, "missing column Ordinal");
                dataRow[schemaTable.Ordinal] = value;
            }

        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Size"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int32 Size {
            get {
                Debug.Assert(null != schemaTable.Size, "no column Size");
                object value = dataRow[schemaTable.Size, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt32(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Size, "missing column Size");
                dataRow[schemaTable.Size] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Precision"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int16 Precision {
            get {
                Debug.Assert(null != schemaTable.Precision, "no column Precision");
                object value = dataRow[schemaTable.Precision, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt16(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Precision, "missing column Precision");
                dataRow[schemaTable.Precision] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.Scale"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Int16 Scale {
            get {
                Debug.Assert(null != schemaTable.Scale, "no column Scale");
                object value = dataRow[schemaTable.Scale, DataRowVersion.Default];
                if (!Convert.IsDBNull(value)) {
                    return Convert.ToInt16(value);
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.Scale, "missing column Scale");
                dataRow[schemaTable.Scale] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseColumnName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseColumnName {
            get {
                if (null != schemaTable.BaseColumnName) {
                    object value = dataRow[schemaTable.BaseColumnName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseColumnName, "missing column BaseColumnName");
                dataRow[schemaTable.BaseColumnName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseServerName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseServerName {
            get {
                if (null != schemaTable.BaseServerName) {
                    object value = dataRow[schemaTable.BaseServerName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseServerName, "missing column BaseServerName");
                dataRow[schemaTable.BaseServerName] = value;
            }
        }
        
    
        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseCatalogName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseCatalogName {
            get {
                if (null != schemaTable.BaseCatalogName) {
                    object value = dataRow[schemaTable.BaseCatalogName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseCatalogName, "missing column BaseCatalogName");
                dataRow[schemaTable.BaseCatalogName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseSchemaName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseSchemaName {
            get {
                if (null != schemaTable.BaseSchemaName) {
                    object value = dataRow[schemaTable.BaseSchemaName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseSchemaName, "missing column BaseSchemaName");
                dataRow[schemaTable.BaseSchemaName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.BaseTableName"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal string BaseTableName {
            get {
                if (null != schemaTable.BaseTableName) {
                    object value = dataRow[schemaTable.BaseTableName, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToString(value);
                    }
                }
                return "";
            }
            set {
                Debug.Assert(null != schemaTable.BaseTableName, "missing column BaseTableName");
                dataRow[schemaTable.BaseTableName] = value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.IsAutoIncrement"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsAutoIncrement {
            get {
                if (null != schemaTable.IsAutoIncrement) {
                    object value = dataRow[schemaTable.IsAutoIncrement, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsAutoIncrement, "missing column IsAutoIncrement");
                dataRow[schemaTable.IsAutoIncrement] = (bool)value;
            }
        }

        /// <include file='doc\DBSchemaRow.uex' path='docs/doc[@for="DBSchemaRow.IsUnique"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsUnique {
            get {
                if (null != schemaTable.IsUnique) {
                    object value = dataRow[schemaTable.IsUnique, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsUnique, "missing column IsUnique");
                dataRow[schemaTable.IsUnique] = (bool)value;
            }
        }

        internal bool IsRowVersion {
            get {
                if (null != schemaTable.IsRowVersion) {
                    object value = dataRow[schemaTable.IsRowVersion, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsRowVersion, "missing column IsRowVersion");
                dataRow[schemaTable.IsRowVersion] = value;
            }
        }
        
        internal bool IsKey {
            get {
                if (null != schemaTable.IsKey) {
                    object value = dataRow[schemaTable.IsKey, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsKey, "missing column IsKey");
                dataRow[schemaTable.IsKey] = value;
            }
        }

        // consider:  just do comparison directly -> (object)(baseColumnName) == (object)(columnName)
        internal bool IsAliased {
            get {
                if (null != schemaTable.IsAliased) { // MDAC 62336
                    object value = dataRow[schemaTable.IsAliased, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsAliased, "missing column IsAliased");
                dataRow[schemaTable.IsAliased] = value;
            }
        }

        internal bool IsExpression {
            get {
                if (null != schemaTable.IsExpression) { // MDAC 62336
                    object value = dataRow[schemaTable.IsExpression, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsExpression, "missing column IsExpression");
                dataRow[schemaTable.IsExpression] = value;
            }
        }

        internal bool IsIdentity {
            get {
                if (null != schemaTable.IsIdentity) { // MDAC 62336
                    object value = dataRow[schemaTable.IsIdentity, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsIdentity, "missing column IsIdentity");
                dataRow[schemaTable.IsIdentity] = value;
            }
        }

        internal bool IsHidden {
            get {
                if (null != schemaTable.IsHidden) { // MDAC 62336
                    object value = dataRow[schemaTable.IsHidden, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsHidden, "missing column IsHidden");
                dataRow[schemaTable.IsHidden] = value;
            }
        }

        internal bool IsLong {
            get {
                if (null != schemaTable.IsLong) { // MDAC 62336
                    object value = dataRow[schemaTable.IsLong, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsLong, "missing column IsHidden");
                dataRow[schemaTable.IsLong] = value;
            }
        }

        internal bool IsReadOnly {
            get {
                if (null != schemaTable.IsReadOnly) { // MDAC 62336
                    object value = dataRow[schemaTable.IsReadOnly, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return false;
            }
            set {
                Debug.Assert(null != schemaTable.IsReadOnly, "missing column IsReadOnly");
                dataRow[schemaTable.IsReadOnly] = value;
            }
        }

        internal System.Type DataType {
            get {
                if (null != schemaTable.DataType) {
                    object value = dataRow[schemaTable.DataType, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return(System.Type) value;
                    }
                }
                Debug.Assert(false, "missing value DataType");
                return null;
            }
            set {
                Debug.Assert(null != schemaTable.DataType, "missing column DataType");
                dataRow[schemaTable.DataType] = value;
            }
        }

        internal bool AllowDBNull {
            get {
                if (null != schemaTable.AllowDBNull) {
                    object value = dataRow[schemaTable.AllowDBNull, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToBoolean(value);
                    }
                }
                return true;
            }
            set {
                Debug.Assert(null != schemaTable.AllowDBNull, "missing column MaybeNull");
                dataRow[schemaTable.AllowDBNull] = value;
            }
        }
        
        internal Int32 ProviderType {
            get {
                if (null != schemaTable.ProviderType) {
                    object value = dataRow[schemaTable.ProviderType, DataRowVersion.Default];
                    if (!Convert.IsDBNull(value)) {
                        return Convert.ToInt32(value);
                    }
                }
                return 0;
            }
            set {
                Debug.Assert(null != schemaTable.ProviderType, "missing column ProviderType");
                dataRow[schemaTable.ProviderType] = value;
            }
        }

        internal Int32 UnsortedIndex {
            get {
                return (Int32) dataRow[schemaTable.UnsortedIndex, DataRowVersion.Default];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbobjectpoolcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBObjectPoolControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Threading;

    internal abstract class DBObjectPoolControl {
        private static Random _random;
        private static volatile bool _initialized; // UNDONE MDAC 75795: must be volatile, double locking problem
        
        private static void Initialize() {
            if (!_initialized) {
                lock(typeof(DBObjectPoolControl)) {
                    if (!_initialized) {
                        // This random number is only used to vary the cleanup time of the pool.
                        _random      = new Random(5101977); // Value obtained from Dave Driver
                        _initialized = true;
                    }
                }
            }
        }

        private String _key;
        private int    _cleanupWait;
        private int    _max;
        private int    _min;
        private int    _timeout;
        private bool   _affinity;

        // integrated security variables
        private string _userId;
        

        public DBObjectPoolControl(String key) {
            Initialize();
            _key  = key;
            _max = 65536;
            _min = 0;
            _timeout = 30000; // 30 seconds;
            _cleanupWait = _random.Next(12)+12; // 2-4 minutes in 10 sec intervals:
            _cleanupWait *= 10*1000;
            _affinity = false; // No affinity
        }

        public String Key {
            get { 
                return (_key); 
            }
        }

        public int MaxPool { 
            get { 
                return (_max); 
            } 
            set { 
                _max = value; 
            }
        }
        
        public int MinPool { 
            get { 
                return (_min); 
            } 
            set { 
                _min = value; 
            }
        }
        
        public int CreationTimeout { 
            get { 
                return (_timeout); 
            } 
            set { 
                _timeout = value; 
            }
        }

        public bool TransactionAffinity { 
            get { 
                return (_affinity); 
            } 
            set { 
                _affinity = value; 
            }
        }

        public int CleanupTimeout { 
            get { 
                return (_cleanupWait); 
            } 
            set { 
                _cleanupWait = value; 
            }
        }

        public string UserId {
            get {
                return _userId;
            }
            set {
                _userId = value;
            }
        }

        public abstract DBPooledObject CreateObject(DBObjectPool p);

        public abstract void DestroyObject(DBObjectPool p, DBPooledObject con);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbschematable.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSchemaTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;

    sealed internal class DBSchemaTable {

        private enum ColumnEnum {
            ColumnName,
            ColumnOrdinal,
            ColumnSize,
            NumericPrecision,
            NumericScale,
            BaseServerName,
            BaseCatalogName,
            BaseColumnName,
            BaseSchemaName,
            BaseTableName,
            IsAutoIncrement,
            IsUnique,
            IsKey,
            IsRowVersion,
            DataType,
            AllowDBNull,
            ProviderType,
            IsAliased,
            IsExpression,
            IsIdentity,
            IsHidden,
            IsLong,
            IsReadOnly,
            SchemaMappingUnsortedIndex,
        }

        static readonly private string[] DBCOLUMN_NAME = new string[] {
            "ColumnName",
            "ColumnOrdinal",
            "ColumnSize",
            "NumericPrecision",
            "NumericScale",
            "BaseServerName",
            "BaseCatalogName",
            "BaseColumnName",
            "BaseSchemaName",
            "BaseTableName",
            "IsAutoIncrement",
            "IsUnique",
            "IsKey",
            "IsRowVersion",
            "DataType",
            "AllowDBNull",
            "ProviderType",
            "IsAliased",
            "IsExpression",
            "IsIdentity",
            "IsHidden",
            "IsLong",
            "IsReadOnly",
            "SchemaMapping Unsorted Index",
        };

        internal DataTable dataTable;
        private DataColumnCollection columns;
        private DataColumn[] columnCache = new DataColumn[DBCOLUMN_NAME.Length];

        internal DBSchemaTable(DataTable dataTable) {
            this.dataTable = dataTable;
            this.columns = dataTable.Columns;
        }

        internal DataColumn ColumnName      { get { return CachedDataColumn(ColumnEnum.ColumnName);}}
        internal DataColumn Ordinal         { get { return CachedDataColumn(ColumnEnum.ColumnOrdinal);}}
        internal DataColumn Size            { get { return CachedDataColumn(ColumnEnum.ColumnSize);}}
        internal DataColumn Precision       { get { return CachedDataColumn(ColumnEnum.NumericPrecision);}}
        internal DataColumn Scale           { get { return CachedDataColumn(ColumnEnum.NumericScale);}}
        internal DataColumn BaseServerName  { get { return CachedDataColumn(ColumnEnum.BaseServerName);}}
        internal DataColumn BaseColumnName  { get { return CachedDataColumn(ColumnEnum.BaseColumnName);}}
        internal DataColumn BaseTableName   { get { return CachedDataColumn(ColumnEnum.BaseTableName);}}
        internal DataColumn BaseCatalogName { get { return CachedDataColumn(ColumnEnum.BaseCatalogName);}}
        internal DataColumn BaseSchemaName  { get { return CachedDataColumn(ColumnEnum.BaseSchemaName);}}
        internal DataColumn IsAutoIncrement { get { return CachedDataColumn(ColumnEnum.IsAutoIncrement);}}
        internal DataColumn IsUnique        { get { return CachedDataColumn(ColumnEnum.IsUnique);}}
        internal DataColumn IsKey           { get { return CachedDataColumn(ColumnEnum.IsKey);}}
        internal DataColumn IsRowVersion    { get { return CachedDataColumn(ColumnEnum.IsRowVersion);}}

        internal DataColumn DataType        { get { return CachedDataColumn(ColumnEnum.DataType);}}
        internal DataColumn AllowDBNull     { get { return CachedDataColumn(ColumnEnum.AllowDBNull);}}
        internal DataColumn ProviderType    { get { return CachedDataColumn(ColumnEnum.ProviderType);}}
        internal DataColumn IsAliased       { get { return CachedDataColumn(ColumnEnum.IsAliased);}}
        internal DataColumn IsExpression    { get { return CachedDataColumn(ColumnEnum.IsExpression);}}
        internal DataColumn IsIdentity      { get { return CachedDataColumn(ColumnEnum.IsIdentity);}}
        internal DataColumn IsHidden        { get { return CachedDataColumn(ColumnEnum.IsHidden);}}
        internal DataColumn IsLong          { get { return CachedDataColumn(ColumnEnum.IsLong);}}
        internal DataColumn IsReadOnly      { get { return CachedDataColumn(ColumnEnum.IsReadOnly);}}

        internal DataColumn UnsortedIndex   { get { return CachedDataColumn(ColumnEnum.SchemaMappingUnsortedIndex);}}

        internal void AddRow(DBSchemaRow dataRow) {
            dataTable.Rows.Add(dataRow.DataRow);
            dataRow.DataRow.AcceptChanges();
        }

        private DataColumn CachedDataColumn(ColumnEnum column) {
            if (null == columnCache[(int) column]) {
                int index = columns.IndexOf(DBCOLUMN_NAME[(int) column]);
                if (-1 != index) {
                    columnCache[(int) column] = columns[index];
                }
            }
            return columnCache[(int) column];
        }

        internal DBSchemaRow NewRow() {
            return new DBSchemaRow(this, dataTable.NewRow());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbobjectpool.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBObjectPool.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Threading;


    sealed internal class DBObjectPool {
        private enum State {
            Initializing, 
            Running, 
            ShuttingDown,
        }

#if USECOUNTEROBJECT
        //
        // Counter values:
        //
        private const long  cQon        =  unchecked((long)0x8000000000000000);
        private const long  cErrorFlag  =  (long)0x4000000000000000;
        private const long  cAddWait    =  (long)0x0000010000000000;
        private const long  cAddFree    =  (long)0x0000000000100000;
        private const long  cAddTotal   =  (long)0x0000000000000001;
        
        private const long Q_MASK       =  unchecked((long)0x8000000000000000);
        private const long ERROR_MASK   =  (long)0x4000000000000000;
        //                              =  0x3000000000000000; unused bits
        private const long WAIT_MASK    =  (long)0x0FFFFF0000000000;
        private const long FREE_MASK    =  (long)0x000000FFFFF00000;
        private const long TOTAL_MASK   =  (long)0x00000000000FFFFF;

        sealed internal class Counter {
            private Object _value;
            
            private Counter(Object value) {
                _value = value;
            }
            
            public Counter() {
                _value = (Object)((long)0);
            }
            
            public void Modify(long add) {
                while (true) {
                    Object oldval = _value;
                    Object newval = ((long)oldval) + add;

                    if(Interlocked.CompareExchange(ref _value, newval, oldval) == oldval) {
                        break;
                    }
                }
            }
            
            public bool TryUpdate(long newval, Counter clone) {
                Object onewval = (Object)newval;
                return(Interlocked.CompareExchange(ref _value, onewval, clone._value) == clone._value);
            }
            
            public long Value {
                get { 
                    return((long)_value); 
                }
            }
            
            public Counter Clone() {
                return (new Counter(_value));
            }
            
            public bool IsQueued     { get { return (Value < 0); } }
            public bool IsInError    { get { return ((int)((Value & ERROR_MASK) >> 60)) != 0; } }
            public int  WaitCount  { get { return (int)(( Value & WAIT_MASK) >> 40); } }
            public int  FreeCount  { get { return (int)((Value & FREE_MASK) >> 20); } }
            public int  TotalCount { get { return (int)(Value & TOTAL_MASK); } }
        }
#endif //USECOUNTEROBJECT

        sealed internal class ObjectPoolWaitHandle : WaitHandle {
            // Mutex class finalizer will call CloseHandle, so we do not WaitHandle
            // finalizer to call CloseHandle on the same handle
            bool fCreatedForMutex = false;

            public ObjectPoolWaitHandle(bool fMutex) : base() {
                fCreatedForMutex = fMutex;
            }

            protected override void Dispose(bool disposing)
            {
                // In the case where we have created this for a Mutex, we
                // have created one Mutex that will "own" the handle and close
                // it when it gets cleaned up.  We must make sure that this object
                // never does the cleanup on that mutex.  
                if (!fCreatedForMutex)
                    base.Dispose(disposing);
            }
        }

#if USEORAMTS
        internal class TransactionOutcomeEvents : UnsafeNativeMethods.ITransactionOutcomeEvents {
            // Class used to listen to transaction outcome events in the case of a manually enlisted
            // object.  In this scenario, we cannot put the object immediately back into the pool.
            // Instead, it must wait until TransactionOutcomeEvent is fired, and then we can put
            // back into the general population of the pool.
            //
            // From Jagan Peri:
            //
            //   There will be a subtle difference between using voters and using outcome events. If you have 
            //   registered as a voter, you will get the notification from msdtc as soon as the 2PC process has 
            //   started. If you have registered for outcome events, you will get a notification from msdtc only 
            //   after the 1st stage of the 2PC process is over (ie when msdtc has decided on the outcome of the
            //   transaction).
            //
            //   In practical terms, this means there can be a delay of around 25msec or so, if you are using 
            //   outcome events rather than voters, before the connection can be released to the main pool. 
            //   I dont think this will have an impact on the systems overall performance (thruput, response 
            //   time etc). There arent any correctness issues either. Just thought you should know about this.
            //
            // I included the above to doc the fact that the transaction has been decided prior to our callback -
            // so we don't hand out this connection and try to re-enlist the connection prior to the first
            // one finishing.
            
            private DBObjectPool            _pool;
            private DBPooledObject          _pooledObject;
            private UCOMIConnectionPoint    _point;
            private Int32                   _cookie;
            private bool                    _signaled; // Bool in case signal occurs before Cookie is set.

            public TransactionOutcomeEvents(DBObjectPool pool, DBPooledObject pooledObject, UCOMIConnectionPoint point) {
                _pool           = pool;
                _pooledObject   = pooledObject;
                _point          = point;
            }

            public void SetCookie(Int32 cookie) {
                // Lock object to prevent race conditions between SetCookie and the OutcomeEvent calls
                lock (this) {
                    _cookie = cookie;
                    ReturnToPool(); // Call reset in case event signaled before cookie set.
                }
            }

            /*
            We do not care about the arguments to Committed, Aborted, or HeuristicDecision.
            The outcome of the transaction can be in-doubt if the connection between the MSDTC proxy 
            and the MSDTC TM was broken after the proxy asked the transaction manager to commit or 
            abort a transaction but before the transaction manager's response to the commit or abort 
            was received by the proxy. Note: Receiving this method call is not the same as the state 
            of the transaction being in-doubt.
            */

            public void Committed(bool fRetaining, IntPtr pNewUOW, Int32 hResutl) {
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("OutcomeCommited", _pooledObject);
#endif //ALLOWTRACING
                this.TransactionCompleted();
            }
            public void Aborted(IntPtr pBoidReason, bool fRetaining, IntPtr pNewUOW, Int32 hResult) {
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("OutcomeAborted", _pooledObject);
#endif //ALLOWTRACING
                this.TransactionCompleted();
            }
            public void HeuristicDecision(UInt32 decision, IntPtr pBoidReason, Int32 hResult) {
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("OutcomeHeuristicDecision", _pooledObject);
#endif //ALLOWTRACING
                this.TransactionCompleted();
            }
            public void Indoubt() {
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("OutcomeInDoubt", _pooledObject);
#endif //ALLOWTRACING
                this.TransactionCompleted();
            }

            private void TransactionCompleted() {
                // Lock object to prevent race conditions between SetCookie and the OutcomeEvent calls
                lock (this) {
                    _signaled = true;
                    this.ReturnToPool();
                }
            }

            private void ReturnToPool() {
                if (_signaled) {
                    if (null != _pooledObject && null != _pool) {
                        _pool.PutNewObject(_pooledObject);
                        _pool       = null;
                        _pooledObject = null;                    
                    }

                    if (0 != _cookie && null != _point) {
                        _point.Unadvise(_cookie);
                        _point  = null;
                        _cookie = 0;
                    }
                }
            }
        }
#endif //USEORAMTS

        private const int MAX_Q_SIZE    = (int)0x00100000;

        // The order of these is important; we want the WaitAny call to be signaled
        // for a free object before a creation signal.  Only the index first signaled
        // object is returned from the WaitAny call.
        private const int SEMAPHORE_HANDLE = (int)0x0;
        private const int ERROR_HANDLE     = (int)0x1;
        private const int CREATION_HANDLE  = (int)0x2;

        private const int WAIT_TIMEOUT   = (int)0x102;
        private const int WAIT_ABANDONED = (int)0x80;

        private const int ERROR_WAIT_DEFAULT = 5 * 1000; // 5 seconds

        private DBObjectPoolControl     _ctrl;
        private State                   _state;
#if USECOUNTEROBJECT
        private Counter                 _poolCounter;
#endif //USECOUNTEROBJECT
        private InterlockedStack        _stackOld;
        private InterlockedStack        _stackNew;
        
#if !USECOUNTEROBJECT
        private int                     _waitCount;
#endif //!USECOUNTEROBJECT
        private ObjectPoolWaitHandle[]  _waitHandles;
        private Mutex                   _creationMutex;
        
        private Exception               _resError;
#if !USECOUNTEROBJECT
        private volatile bool           _errorOccurred;
#endif //!USECOUNTEROBJECT
        
        private int                     _errorWait;
        private Timer                   _errorTimer;
        
        private int                     _cleanupWait;
        private Timer                   _cleanupTimer;
        
        private ResourcePool            _txPool;
        
        private ArrayList               _objectList;
#if !USECOUNTEROBJECT
        private int                     _totalObjects;
#endif //!USECOUNTEROBJECT
        

        public DBObjectPool(DBObjectPoolControl ctrl) {
            _state       = State.Initializing;
            _ctrl        = ctrl;
#if USECOUNTEROBJECT
            _poolCounter = new Counter();
#endif //USECOUNTEROBJECT
            _stackOld    = new InterlockedStack();
            _stackNew    = new InterlockedStack();
            _waitHandles = new ObjectPoolWaitHandle[3];
            _waitHandles[SEMAPHORE_HANDLE] = CreateWaitHandle(SafeNativeMethods.CreateSemaphore(IntPtr.Zero, 0, MAX_Q_SIZE, IntPtr.Zero), false);
            _waitHandles[ERROR_HANDLE]     = CreateWaitHandle(SafeNativeMethods.CreateEvent(IntPtr.Zero, 1, 0, IntPtr.Zero), false);
            _creationMutex = new Mutex();
            _waitHandles[CREATION_HANDLE]  = CreateWaitHandle(_creationMutex.Handle, true);
            _errorWait   = ERROR_WAIT_DEFAULT;
            _cleanupWait = 0; // Set in CreateCleanupTimer
            _errorTimer  = null;  // No error yet.
            _objectList  = new ArrayList(_ctrl.MaxPool);

            if(ctrl.TransactionAffinity) {
                OperatingSystem osversion = Environment.OSVersion;

                if (PlatformID.Win32NT == osversion.Platform && 5 <= osversion.Version.Major)    // TODO: create an ADP.IsPlatformNT5 function?
                    _txPool = CreateResourcePool();
            }

            _cleanupTimer = CreateCleanupTimer();
            _state = State.Running;

            // PerfCounters - this counter will never be decremented!
            IncrementPoolCount();

            // Make sure we're at quota by posting a callback to the threadpool.
            ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
        }

#if !USECOUNTEROBJECT
        public int Count { 
            get { 
                return(_totalObjects); 
            } 
        }

        public bool ErrorOccurred {
            get { return _errorOccurred; }
        }

        public bool NeedToReplenish {
            get { 

                int totalObjects = Count;

                if (totalObjects >= PoolControl.MaxPool)
                    return false;

                if (totalObjects < PoolControl.MinPool)
                    return true;
                
                int freeObjects     = (_stackNew.Count + _stackOld.Count);
                int waitingRequests = _waitCount;
                bool needToReplenish = (freeObjects < waitingRequests) || ((freeObjects == waitingRequests) && (totalObjects > 1));
                
                return needToReplenish;
            }
        }
#endif //USECOUNTEROBJECT

        public DBObjectPoolControl PoolControl { 
            get { 
                return(_ctrl); 
            } 
        }

        private void CleanupCallback(Object state) {
            // Called when the cleanup-timer ticks over.
            //
            // This is the automatic prunning method.  Every period, we will perform a two-step
            // process.  First, for the objects above MinPool, we will obtain the semaphore for
            // the object and then destroy it if it was on the old stack.  We will continue this
            // until we either reach MinPool size, or we are unable to obtain a free object, or
            // until we have exhausted all the objects on the old stack.  After that, push all
            // objects on the new stack to the old stack.  So, every period the objects on the
            // old stack are destroyed and the objects on the new stack are pushed to the old 
            // stack.  All objects that are currently out and in use are not on either stack.  
            // With this logic, a object is prunned if unused for at least one period but not 
            // more than two periods.

            // Destroy free objects above MinPool size from old stack.
#if USECOUNTEROBJECT
            while(_poolCounter.TotalCount > _ctrl.MinPool)
#else //!USECOUNTEROBJECT
            while(Count > _ctrl.MinPool)
#endif //!USECOUNTEROBJECT
            {
                // While above MinPoolSize...

                if (_waitHandles[SEMAPHORE_HANDLE].WaitOne(0, false) /* != WAIT_TIMEOUT */) {
                    // We obtained a objects from the semaphore.
                    DBPooledObject obj = (DBPooledObject) _stackOld.Pop();

                    if (null != obj) {
                        // If we obtained one from the old stack, destroy it.
#if USECOUNTEROBJECT
                        _poolCounter.Modify(-cAddFree);
#endif //USECOUNTEROBJECT
                        DestroyObject(obj);
                    }
                    else {
                        // Else we exhausted the old stack, so break.
                        SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, IntPtr.Zero);
                        break;
                    }
                }
                else break;
            }
            
            // Push to the old-stack.  For each free object, move object from new stack
            // to old stack.
            if(_waitHandles[SEMAPHORE_HANDLE].WaitOne(0, false) /* != WAIT_TIMEOUT */) { 
                for(;;) {
                    DBPooledObject obj = (DBPooledObject) _stackNew.Pop();
                    
                    if (null == obj)
                        break;
 
                    _stackOld.Push(obj);
                }
                SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, IntPtr.Zero);
            }

            // Make sure we're at quota by posting a callback to the threadpool.
            ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
        }
        
        private Timer CreateCleanupTimer() {
            _cleanupWait = _ctrl.CleanupTimeout;
            return (new Timer(new TimerCallback(this.CleanupCallback), null, _cleanupWait, _cleanupWait));
        }
        
        private DBPooledObject CreateObject() {
            DBPooledObject newObj = null;

            try {
                newObj = PoolControl.CreateObject(this);

                Debug.Assert(newObj != null, "CreateObject succeeded, but object null");

                newObj.PrePush(null);

                lock (_objectList.SyncRoot) {
                    _objectList.Add(newObj);
#if !USECOUNTEROBJECT
                    _totalObjects = _objectList.Count;
#endif //!USECOUNTEROBJECT
                }
#if USECOUNTEROBJECT
                _poolCounter.Modify(cAddTotal);
#endif //USECOUNTEROBJECT

#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("CreateObject", newObj);
#endif //ALLOWTRACING

                // Reset the error wait:
                _errorWait = ERROR_WAIT_DEFAULT;
            }
            catch(Exception e)  {
                ADP.TraceException(e);

                newObj = null; // set to null, so we do not return bad new object
                // Failed to create instance
                _resError = e;
                SafeNativeMethods.SetEvent(_waitHandles[ERROR_HANDLE].Handle);
#if USECOUNTEROBJECT
                _poolCounter.Modify(cErrorFlag);
#else //!USECOUNTEROBJECT
                _errorOccurred = true;
#endif //!USECOUNTEROBJECT
                _errorTimer = new Timer(new TimerCallback(this.ErrorCallback), null, _errorWait, _errorWait);
                _errorWait *= 2;
            }

            return newObj;
        }

        private ResourcePool CreateResourcePool() {
            ResourcePool.TransactionEndDelegate enddelegate =  new ResourcePool.TransactionEndDelegate(this.TransactionEndedCallback);
#if DEBUG
            try {
                (new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\COM3\\System.EnterpriseServices")).Assert(); // MDAC 84045
                try {
#endif
                    return new ResourcePool(enddelegate);
#if DEBUG
                }
                finally {
                    RegistryPermission.RevertAssert();
                }
            }
            catch {
                throw;
            }
#endif
        }

        private ObjectPoolWaitHandle CreateWaitHandle(IntPtr handle, bool createdForMutex) {
            ObjectPoolWaitHandle whandle = new ObjectPoolWaitHandle(createdForMutex);
            whandle.Handle = handle;
            return(whandle);
        }
        
        private void DestroyObject(DBPooledObject obj) {
#if ALLOWTRACING
            ADP.TraceObjectPoolActivity("DestroyObject", obj);
#endif //ALLOWTRACING

            lock (_objectList.SyncRoot) {
                _objectList.Remove(obj);
#if !USECOUNTEROBJECT
                _totalObjects = _objectList.Count;
#endif //!USECOUNTEROBJECT
            }
#if USECOUNTEROBJECT
                _poolCounter.Modify(-cAddTotal);
#endif //USECOUNTEROBJECT
            PoolControl.DestroyObject(this, obj);
        }

        private void ErrorCallback(Object state) {
#if USECOUNTEROBJECT
            _poolCounter.Modify(-cErrorFlag);
#else //!USECOUNTEROBJECT
            _errorOccurred = false;
#endif //!USECOUNTEROBJECT
            SafeNativeMethods.ResetEvent(_waitHandles[ERROR_HANDLE].Handle);
            Timer t     = _errorTimer;
            _errorTimer = null;
            if (t != null) {
                t.Dispose(); // Cancel timer request.
            }
        }

        internal static string GetCurrentIdentityName()
        {
            string identityName;

            try 
            {
                (new SecurityPermission(SecurityPermissionFlag.ControlPrincipal)).Assert(); // MDAC 66683
                try 
                { 
                    identityName = WindowsIdentity.GetCurrent().Name;
                }
                finally 
                {
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch
            {
                throw;
            }
            return identityName;
        }

        private DBPooledObject GetFromPool(object owningObject) {
            DBPooledObject res = null;
            
            res = (DBPooledObject) _stackNew.Pop();
            if(res == null) {
                res = (DBPooledObject) _stackOld.Pop();
            }
            
            // Shouldn't be null, we could assert here.
            Debug.Assert(res != null, "GetFromPool called with nothing in the pool!");

            if (null != res) {
                res.PostPop(owningObject);
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("GetFromGeneralPool", res);
#endif //ALLOWTRACING
            }
            
            return(res);
        }
        
        public DBPooledObject GetObject(object owningObject, out bool isInTransaction) {
            DBPooledObject obj = null;

            isInTransaction = false;

            if(_state != State.Running) {
                return null;
            }

            // Try to get from the context if we're context specific:
            obj = TryGetResourceFromContext(out isInTransaction);
            
            if (null != obj) {
                obj.PostPop(owningObject);
            } else {
#if USECOUNTEROBJECT
                _poolCounter.Modify(cAddWait);
#else //!USECOUNTEROBJECT
                Interlocked.Increment(ref _waitCount);
#endif //!USECOUNTEROBJECT
          
                ObjectPoolWaitHandle[] localWaitHandles = _waitHandles;

                while (obj == null) {
                    int r = WaitHandle.WaitAny(localWaitHandles, PoolControl.CreationTimeout, false);

                    // From the WaitAny docs: "If more than one object became signaled during 
                    // the call, this is the array index of the signaled object with the 
                    // smallest index value of all the signaled objects."  This is important
                    // so that the free object signal will be returned before a creation 
                    // signal.

                    switch (r) {
                    case WAIT_TIMEOUT:
#if USECOUNTEROBJECT
                        _poolCounter.Modify(-cAddWait);
#else //!USECOUNTEROBJECT
                       Interlocked.Decrement(ref _waitCount);
#endif //!USECOUNTEROBJECT
                        return null;

                    case ERROR_HANDLE:
                        // Throw the error that PoolCreateRequest stashed.
#if USECOUNTEROBJECT
                        _poolCounter.Modify(-cAddWait);
#else //!USECOUNTEROBJECT
                        Interlocked.Decrement(ref _waitCount);
#endif //!USECOUNTEROBJECT
                        throw _resError;

                    case CREATION_HANDLE:
                        try {
                            obj = UserCreateRequest();

                            if (null != obj) {
                                obj.PostPop(owningObject);
#if USECOUNTEROBJECT
                                _poolCounter.Modify(-cAddWait);
#else //!USECOUNTEROBJECT
                                Interlocked.Decrement(ref _waitCount);
#endif //!USECOUNTEROBJECT
                            } 
                            else {
                                // If we were not able to create an object, check to see if
                                // we reached MaxPool.  If so, we will no longer wait on the
                                // CreationHandle, but instead wait for a free object or 
                                // the timeout.
                                
                                // BUG - if we receive the CreationHandle midway into the wait
                                // period and re-wait, we will be waiting on the full period
#if USECOUNTEROBJECT
                            if (_poolCounter.TotalCount == PoolControl.MaxPool) {
#else //!USECOUNTEROBJECT
                                if (Count >= PoolControl.MaxPool) {
#endif //!USECOUNTEROBJECT
                                    if (!ReclaimEmancipatedObjects()) {
                                        // modify handle array not to wait on creation mutex anymore
                                        localWaitHandles    = new ObjectPoolWaitHandle[2];
                                        localWaitHandles[0] = _waitHandles[0];
                                        localWaitHandles[1] = _waitHandles[1];
                                    }
                                }
                            }
                        }
                        finally {
                            _creationMutex.ReleaseMutex();
                        }
                        break;
                        
                    default:
                        //
                        //  guaranteed available inventory
                        //
#if USECOUNTEROBJECT
                        _poolCounter.Modify(-cAddWait - cAddFree);
#else //!USECOUNTEROBJECT
                        Interlocked.Decrement(ref _waitCount);
#endif //!USECOUNTEROBJECT
                        obj = GetFromPool(owningObject);
                        break;
                    }
                }
            }
            Debug.Assert(obj != null, "Failed to create pooled object, resulted in null instance.");

            if (null != obj)
                obj.Activate();
            
            return(obj);
        }
        
        private void IncrementPoolCount() {
            // TODO: implement pool counter logic
        }

        private void PoolCreateRequest(object state) {
            // called by pooler to ensure pool requests are currently being satisfied -
            // creation mutex has not been obtained

            // Before creating any new objects, reclaim any released objects that were
            // not closed.
            ReclaimEmancipatedObjects();

#if USECOUNTEROBJECT
            Counter comp = _poolCounter.Clone();

            if (comp.IsInError) {
                return;
            }

            int nFree  = comp.FreeCount;
            int nWait  = comp.WaitCount;
            int nTotal = comp.TotalCount;
            
            if ((nTotal < PoolControl.MaxPool) && ( ((nFree == nWait) && (nTotal > 0)) || (nFree < nWait) || (nTotal < PoolControl.MinPool))) {
#else //!USECOUNTEROBJECT
            if (ErrorOccurred) {
                return;
            }

            if (NeedToReplenish) {
#endif //!USECOUNTEROBJECT
                // Check to see if pool was created using integrated security.  If so, check to 
                // make sure identity of current user matches that of user that created pool.  
                // If it doesn't match, do not create any objects on the ThreadPool thread, 
                // since either Open will fail or we will open a object for this pool that does 
                // not belong in this pool.  The side effect of this is that if using integrated
                // security min pool size cannot be guaranteed.
                if (null != ((DBObjectPoolControl) PoolControl).UserId) {
                    string identityName = GetCurrentIdentityName();

                    if (identityName != ((DBObjectPoolControl) PoolControl).UserId) {
                        return;
                    }
                }

                try {
                    // Obtain creation mutex so we're the only one creating objects
                    _creationMutex.WaitOne();
                    
                    DBPooledObject newObj;

#if USECOUNTEROBJECT
                    comp   = _poolCounter.Clone();
                    nFree  = comp.FreeCount;
                    nWait  = comp.WaitCount;
                    nTotal = comp.TotalCount;

                    // Check IsInError again after obtaining mutex
                    if (!comp.IsInError) {
                        while ((nTotal < PoolControl.MaxPool) && ( ((nFree == nWait) && (nTotal > 0)) || (nFree < nWait) || (nTotal < PoolControl.MinPool))) {
#else //!USECOUNTEROBJECT
                    // Check ErrorOccurred again after obtaining mutex
                    if (!ErrorOccurred) {
                        while (NeedToReplenish) {
#endif //!USECOUNTEROBJECT
                            newObj = CreateObject();
    
                            // We do not need to check error flag here, since we know if 
                            // CreateObject returned null, we are in error case.
                            if (null != newObj) {
                                PutNewObject(newObj);
#if USECOUNTEROBJECT
                                comp   = _poolCounter.Clone();
                                nFree  = comp.FreeCount;
                                nWait  = comp.WaitCount;
                                nTotal = comp.TotalCount;
#endif //USECOUNTEROBJECT
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
                finally {
                    // always release
                    _creationMutex.ReleaseMutex();
                }
            }
        }

        private void PutNewObject(DBPooledObject obj) {
            Debug.Assert(null != obj, "why are we adding a null object to the pool?");
            
#if ALLOWTRACING
            ADP.TraceObjectPoolActivity("PutToGeneralPool", obj);
#endif //ALLOWTRACING
             _stackNew.Push(obj);
#if USECOUNTEROBJECT
            _poolCounter.Modify(cAddFree);
#endif //USECOUNTEROBJECT
            SafeNativeMethods.ReleaseSemaphore(_waitHandles[SEMAPHORE_HANDLE].Handle, 1, IntPtr.Zero);
        }

        public void PutObject(DBPooledObject obj, object owningObject) {
            if (obj == null) {
                throw ADP.ArgumentNull("obj");
            }

            obj.PrePush(owningObject);

            if (_state != State.ShuttingDown) {
                bool isInTransaction = obj.Deactivate();

                if (obj.CanBePooled()) {
#if USEORAMTS
                    ITransaction transaction = obj.ManualEnlistedTransaction;
                    
                    if (null != transaction) {
                        // When the object is put back into the pool while it is manually 
                        // enlisted in a distributed transaction, we must create an outcome 
                        // event and let the object wait until the distributed transaction
                        // has finished.  Once it does, the TransactionOutcomeEvents class
                        // can put it back into the general population of the pool.
                        
                        UCOMIConnectionPoint point = (UCOMIConnectionPoint) transaction;

                        TransactionOutcomeEvents outcomeEvent = new TransactionOutcomeEvents(this, obj, point);
                        
                        Int32 cookie = 0;
                        point.Advise(outcomeEvent, out cookie); // Register for callbacks, obtain cookie
                        outcomeEvent.SetCookie(cookie);         // Set the cookie on the event

#if ALLOWTRACING
                        ADP.TraceObjectPoolActivity("WaitForOutcomeEvnt", obj);
#endif //ALLOWTRACING
                        return;
                    }
#endif //USEORAMTS                    
                    // Try shoving it in the tx context first.  If that succeeds,
                    // we're done.
                    if (isInTransaction && TryPutResourceInContext(obj)) {
                        return;
                    }

                    // If the above failed, we just shove it into our current collection
                    PutNewObject(obj);
                 }
                else {
                    DestroyObject(obj);
                    // Make sure we're at quota by posting a callback to the threadpool.
                    ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
                }
            }
            else {
                // If we're shutting down, we destroy the object.
                DestroyObject(obj);
            }
        }

        private bool ReclaimEmancipatedObjects() {
            bool emancipatedObjectFound = false;

            lock(_objectList.SyncRoot) {
                object[] objectList = _objectList.ToArray();

                if (null != objectList) {
                    DBPooledObject obj;

                    int length = objectList.Length;

                    for (int i=0; i<length; i++) {
                        obj = (DBPooledObject) objectList[i];

                        if (null != obj) {
                            bool locked = false;
                            
                            try {
                                locked = Monitor.TryEnter(obj);

                                if (locked) {
                                    if (obj.IsEmancipated) {
#if ALLOWTRACING
                                        ADP.TraceObjectPoolActivity("EmancipatedObject", obj);
#endif //ALLOWTRACING
                                        obj.Cleanup();
                                        PutObject(obj, null);
                                        emancipatedObjectFound = true;
                                    }                           
                                }
                            }
                            finally {
                                if (locked)
                                    Monitor.Exit(obj);
                            }
                        }
                    }
                }
            }
            return emancipatedObjectFound;
        }
        
        internal void TransactionEndedCallback(object obj)
        {
            // Internal, because it's called from the TxResourcePool as a callback.  This
            // method is called for transacted connections to ensure that they are cleaned
            // up when the transaction their attached to is completed.
            
            if(_state == State.ShuttingDown) {
                DestroyObject((DBPooledObject) obj);
                return;
            }

#if ALLOWTRACING
            ADP.TraceObjectPoolActivity("TransactionEnded", (DBPooledObject)obj);
#endif //ALLOWTRACING

            if(!(((DBPooledObject) obj).CanBePooled())) {
                DestroyObject((DBPooledObject) obj);
                // Make sure we're at quota by posting a callback to the threadpool.
                ThreadPool.QueueUserWorkItem(new WaitCallback(PoolCreateRequest));
                return;
            }
            
            PutNewObject((DBPooledObject) obj);
        }

        private DBPooledObject TryGetResourceFromContext(out bool isInTransaction)
        {
            isInTransaction = false;

            DBPooledObject obj = null;
            try {
                if(PoolControl.TransactionAffinity && ContextUtil.IsInTransaction) {
                    isInTransaction = true;
                    if (null != _txPool)
                        obj = (DBPooledObject) _txPool.GetResource();
                }
                else {
                    isInTransaction = false;
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
#if ALLOWTRACING
            if (null != obj) 
                ADP.TraceObjectPoolActivity("GetFromTransactedPool", obj);
#endif //ALLOWTRACING
            return(obj);
        }

        private bool TryPutResourceInContext(DBPooledObject obj) {
            try {
                if(PoolControl.TransactionAffinity && ContextUtil.IsInTransaction) {
                    if (null != _txPool) {
                        if(_txPool.PutResource(obj)) {
#if ALLOWTRACING
                            ADP.TraceObjectPoolActivity("PutToTransactedPool", obj);
#endif //ALLOWTRACING
                            return(true);
                        }
                    }
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
            return(false);
        }

        private DBPooledObject UserCreateRequest() {
            // called by user when they were not able to obtain a free object but
            // instead obtained creation mutex

#if USECOUNTEROBJECT
            Counter comp = _poolCounter.Clone();

            if (comp.IsInError) {
#else //!USECOUNTEROBJECT
            if (ErrorOccurred) {
#endif //!USECOUNTEROBJECT
                return null;
            }

#if USECOUNTEROBJECT
            if (comp.TotalCount < PoolControl.MaxPool) {
#else //!USECOUNTEROBJECT
            if (Count < PoolControl.MaxPool) {
#endif //!USECOUNTEROBJECT
                // If we have an odd number of total objects, reclaim any dead objects.
                // If we did not find any objects to reclaim, create a new one.

                // TODO: Implement a control knob here; why do we only check for dead objects ever other time?  why not every 10th time or every time?
#if USECOUNTEROBJECT
                if ((comp.TotalCount & 0x1) == 0x1) {
#else //!USECOUNTEROBJECT
                if ((Count & 0x1) == 0x1) {
#endif //!USECOUNTEROBJECT
                    if (!ReclaimEmancipatedObjects()) {
                        return (CreateObject());
                    }
                }
                else {
                    return (CreateObject());
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbconnectionstring.cs ===
//------------------------------------------------------------------------------
//  <copyright company='Microsoft Corporation'>
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
//  </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.Win32;

    internal enum UdlSupport {
        LoadFromFile,
        UdlAsKeyword,
        ThrowIfFound
    }

    [Serializable] // MDAC 83147
    internal class DBConnectionString {

#if true
        static internal IComparer   invariantComparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
#else
        static internal IComparer   invariantComparer = InvariantComparer.Default;
#endif

        // connection string common keywords
        sealed private class KEY {
            internal const string Extended_Properties      = "extended properties";
            internal const string File_Name                = "file name";
            internal const string Integrated_Security      = "integrated security";
            internal const string Password                 = "password";
            internal const string Persist_Security_Info    = "persist security info";
            internal const string User_ID                  = "user id";
        };

        // known connection string common synonyms
        sealed private class SYNONYM {
            internal const string Pwd                   = "pwd";
            internal const string UID                   = "uid";
        };

#if OLEDB
        // registry key and dword value entry for udl pooling
        sealed private class UDL {
            internal const string Header   = "\xfeff[oledb]\r\n; Everything after this line is an OLE DB initstring\r\n";
            internal const string Location = "SOFTWARE\\Microsoft\\DataAccess";
            internal const string Pooling  = "Udl Pooling";

            static internal volatile bool    _PoolSizeInit; // UNDONE MDAC 75795: must be volatile, double locking problem
            static internal int              _PoolSize;
            static internal Hashtable        _Pool;
        }
#endif //OLEDB

#if DEBUG
        private static BooleanSwitch    _TraceParse;
#endif

        readonly private string         _encryptedUsersConnectionString;
        readonly private NameValuePair  _keychain;

        readonly private string         _encryptedActualConnectionString; // if != _connectionString the UDL was used
        readonly private Hashtable      _parsetable;            // should be immutable

        readonly private string[]       _restrictionValues;
        readonly private string         _restrictions;          // = ADP.StrEmpty;

        readonly private KeyRestrictionBehavior _behavior;      // = KeyRestrictionBehavior.AllowOnly

#if USECRYPTO
        private bool _isEncrypted; // MDAC 83212
#endif
        private string _displayString;

        // called by derived classes that may cache based on encryptedConnectionString and we only want to encrypt once
#if USECRYPTO
        protected DBConnectionString(string connectionString, string encryptedConnectionString, UdlSupport checkForUdl) {
#else
        protected DBConnectionString(string connectionString, UdlSupport checkForUdl) {
#endif
            _parsetable = new Hashtable();
            if (!ADP.IsEmpty(connectionString)) {
#if USECRYPTO
                if (ADP.IsEmpty(encryptedConnectionString)) {
                    encryptedConnectionString = Crypto.EncryptString(connectionString);
                }
                _encryptedUsersConnectionString = encryptedConnectionString;

                _encryptedActualConnectionString = ParseConnectionString(connectionString, encryptedConnectionString, checkForUdl, ref _keychain);
#else
                _encryptedUsersConnectionString = connectionString;
                char[] actual = ParseInternal(connectionString.ToCharArray(), checkForUdl, ref _keychain);
                _encryptedActualConnectionString = new String(actual);
#endif
            }
#if DEBUG
            _parsetable = ADP.ProtectHashtable(_parsetable);
#endif
#if USECRYPTO
            if (!_isEncrypted || ((connectionString as object) != (encryptedConnectionString as object))
                || !(_parsetable.ContainsKey(KEY.Password) || _parsetable.ContainsKey(SYNONYM.Pwd))) {
                _isEncrypted = false;
                _encryptedUsersConnectionString = connectionString;
            }
#endif
            if (null != _keychain) {
                _encryptedActualConnectionString = ValidateParse();
            }
        }

        // only called by DBDataPermission.Add
#if USECRYPTO
        internal DBConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : this(connectionString, null, UdlSupport.UdlAsKeyword) {
#else
        internal DBConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : this(connectionString, UdlSupport.UdlAsKeyword) {
#endif
            if (!ADP.IsEmpty(restrictions)) {
                _restrictionValues = ParseRestrictions(restrictions);
                _restrictions = restrictions;
            }
            _behavior = behavior;
        }

        protected internal DBConnectionString(DBConnectionString constr, bool withoutSensitiveOptions) { // Clone, DBDataPermission
            _encryptedUsersConnectionString  = constr._encryptedUsersConnectionString;
            _keychain                        = constr._keychain;

            _encryptedActualConnectionString = constr._encryptedActualConnectionString;
            _parsetable                      = constr._parsetable;

            _restrictionValues               = constr._restrictionValues;
            _restrictions                    = constr._restrictions;
            _behavior                        = constr._behavior;

            _displayString                   = constr._displayString;
#if USECRYPTO
            _isEncrypted                     = constr._isEncrypted;
#endif
            if (withoutSensitiveOptions && (null != _keychain) && !ContainsPersistablePassword()) { // MDAC 83180
                if (null == _displayString) {
                    _encryptedUsersConnectionString = _displayString = constr.GetConnectionString(true);
#if USECRYPTO
                    _isEncrypted = false; // MDAC 84193
#endif
                }
                _encryptedActualConnectionString = null;
                _parsetable = (Hashtable) _parsetable.Clone();
                _parsetable.Remove(KEY.Password);
                _parsetable.Remove(SYNONYM.Pwd);
#if DEBUG
                _parsetable = ADP.ProtectHashtable(_parsetable);
#endif
                NameValuePair tail = null;
                for(NameValuePair current = _keychain; null != current; current = current.Next) {
                    if ((KEY.Password != current.Name) && (SYNONYM.Pwd != current.Name)) {
                        if (null != tail) {
                            tail = tail.Next = current.Clone();
                        }
                        else {
                            _keychain = tail = current.Clone();
                        }
                    }
                }
            }
        }

        // only called by MergeIntersect which will pass restrictionValues we can trust that won't be mutated
        private DBConnectionString(DBConnectionString constr, string[] restrictionValues, KeyRestrictionBehavior behavior) : this(constr, false) {
            _restrictionValues = restrictionValues;
            _restrictions = null;
            _behavior = behavior;
        }

        internal KeyRestrictionBehavior Behavior {
            get { return _behavior; }
        }        

        internal string GetConnectionString(bool hidePasswordPwd) {
            string value = null;
            if (hidePasswordPwd) {
                hidePasswordPwd = !ContainsPersistablePassword();
                if (hidePasswordPwd && (null != _displayString)) {
                    return _displayString;
                }
            }
            if (null != _encryptedUsersConnectionString) {
#if USECRYPTO
                try {
                    byte[] plainBytes = null;
                    GCHandle plainHandle = GCHandle.Alloc(null, GCHandleType.Normal);
                    try {
                        if (_isEncrypted) {
                            plainBytes = Crypto.DecryptString(_encryptedUsersConnectionString);
                        }
                        else {
                            plainBytes = new byte[ADP.CharSize * _encryptedUsersConnectionString.Length];
                            System.Text.Encoding.Unicode.GetBytes(_encryptedUsersConnectionString, 0, _encryptedUsersConnectionString.Length, plainBytes, 0);
                        }
                        plainHandle = GCHandle.Alloc(plainBytes, GCHandleType.Pinned);
                        if ((null != plainBytes) && (0 < plainBytes.Length)) {
                            if (hidePasswordPwd) {
                                char[] plainText = new char[plainBytes.Length / ADP.CharSize];
                                GCHandle textHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
                                try {
                                    Buffer.BlockCopy(plainBytes, 0, plainText, 0, plainBytes.Length);
                                    _displayString = value = RemovePasswordPwd(plainText);
                                }
                                finally {
                                    Array.Clear(plainText, 0, plainText.Length);
                                    if (textHandle.IsAllocated) {
                                        textHandle.Free();
                                    }
                                }
                            }
                            else {
                                value = System.Text.Encoding.Unicode.GetString(plainBytes, 0, plainBytes.Length);
                            }
                        }
                    }
                    finally {
                        if (null != plainBytes) {
                            Array.Clear(plainBytes, 0, plainBytes.Length);
                        }
                        if (plainHandle.IsAllocated) {
                            plainHandle.Free();
                        }
                    }
                }
                catch {
                    throw;
                }
#else
                if (hidePasswordPwd) {
                    _displayString = value = RemovePasswordPwd(_encryptedUsersConnectionString.ToCharArray());
                }
                else value = _encryptedUsersConnectionString;
#endif
            }
            return ((null != value) ? value : ADP.StrEmpty);
        }

        internal string EncryptedActualConnectionString { // may return null
            get { return _encryptedActualConnectionString; }
        }
#if USECRYPTO
        internal bool IsEncrypted {
            get { return _isEncrypted; }
        }
#endif
        internal NameValuePair KeyChain {
            get { return _keychain; }
        }

#if MDAC80721
        protected virtual bool EmbeddedExtendedProperties {
            get { return false; }
        }
#endif

        internal string Restrictions {
            get {
                string restrictions = _restrictions;
                if (null == restrictions) {
                    string[] restrictionValues = _restrictionValues;
                    if ((null != restrictionValues) && (0 < restrictionValues.Length)) {
                        StringBuilder builder = new StringBuilder();
                        for(int i = 0; i < restrictionValues.Length; ++i) {
                            builder.Append(restrictionValues[i]);
                            builder.Append("=;");
                        }
                        restrictions = builder.ToString();
                    }
                }
                return ((null != restrictions) ? restrictions: ADP.StrEmpty);
            }
        }

        internal string this[string keyword] {
            get { return (string)_parsetable[keyword]; }
        }
#if DEBUG
        static private BooleanSwitch TraceParseConnectionString {
            get {
                BooleanSwitch traceparse = _TraceParse;
                if (null == traceparse) {
                    traceparse = new BooleanSwitch("Data.ConnectionStringParse", "Enable tracing of connection string key/value pairs.");
                    _TraceParse = traceparse;
                }
                return traceparse;
            }
        }
#endif

#if OLEDB
        static internal int UdlPoolSize { // MDAC 69925
            get {
                int poolsize = UDL._PoolSize;
                if (!UDL._PoolSizeInit) {
                    object value = ADP.LocalMachineRegistryValue(UDL.Location, UDL.Pooling);
                    if (value is Int32) {
                        poolsize = (int) value;
                        poolsize = ((0 < poolsize) ? poolsize : 0);
                        UDL._PoolSize = poolsize;
                    }
                    UDL._PoolSizeInit = true;
                }
                return poolsize;
            }
        }
#endif //OLEDB

        static internal void CacheAdd(string encrypted, DBConnectionString value, ref Hashtable providerCache) {
            ADP.CheckArgumentNull(value, "value");
            ADP.CheckArgumentLength(value._encryptedUsersConnectionString, "connectionString");

            if (null == encrypted) {
                encrypted = value._encryptedUsersConnectionString;
            }

            // multiple threads could have parsed the same connection string at the same time
            // it doesn't really matter because they all should have resulted in the same value
            try {
                Hashtable hash = providerCache;
                if ((null == hash) || (250 <= hash.Count)) {
                    lock(typeof(DBConnectionString)) {
                        // flush the ConnectionString cache when it reaches a certain size
                        // this avoid accumlating parsed strings in a uncontrolled fashion
                        hash = new Hashtable();
                        hash[encrypted] = value;
                        providerCache = hash;
                    }
                }
                else {
                    lock(hash.SyncRoot) { // MDAC 74006
                        hash[encrypted] = value;
                    }
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        static internal DBConnectionString CacheQuery(string encryptedConnectionString, Hashtable providerCache) {
            Debug.Assert(!ADP.IsEmpty(encryptedConnectionString), "empty string");
            if ((null != providerCache) && providerCache.ContainsKey(encryptedConnectionString)) {
                return (providerCache[encryptedConnectionString] as DBConnectionString);
            }
            return null;
        }

        internal bool CheckConvertToBoolean(string keyname, bool defaultvalue) {
            object value;
            if (!_parsetable.ContainsKey(keyname) || (null == (value = _parsetable[keyname]))) {
                return defaultvalue;
            }
            if (value is String) {
                return CheckConvertToBooleanInternal(keyname, (string) value);
            }
            else {
                Debug.Assert(value is bool, keyname);
                return (bool) value;
            }
        }

        private bool CheckConvertToBooleanInternal(string keyname, string svalue) {
            if (CompareInsensitiveInvariant(svalue, "true") || CompareInsensitiveInvariant(svalue, "yes"))
                return true;
            else if (CompareInsensitiveInvariant(svalue, "false") || CompareInsensitiveInvariant(svalue, "no"))
                return false;
            else {
                string tmp = svalue.Trim();  // Remove leading & trailing white space.
                if (CompareInsensitiveInvariant(tmp, "true") || CompareInsensitiveInvariant(tmp, "yes"))
                    return true;
                else if (CompareInsensitiveInvariant(tmp, "false") || CompareInsensitiveInvariant(tmp, "no"))
                    return false;
                else {
#if DEBUG
                    if (TraceParseConnectionString.Enabled) {
                        Debug.WriteLine("ConvertToBoolean <" + svalue + ">");
                    }
#endif
                    throw ADP.InvalidConnectionOptionValue(keyname);
                }
            }
        }

        // same as CheckConvertBoolean, but with SSPI thrown in as valid yes
        internal bool CheckConvertIntegratedSecurity() {
            object value;
            if (!_parsetable.ContainsKey(KEY.Integrated_Security) || (null == (value = _parsetable[KEY.Integrated_Security]))) {
                return false;
            }
            if (value is String) {
                string svalue = (string) value;

                if (CompareInsensitiveInvariant(svalue, "sspi") || CompareInsensitiveInvariant(svalue, "true") || CompareInsensitiveInvariant(svalue, "yes"))
                    return true;
                else if (CompareInsensitiveInvariant(svalue, "false") || CompareInsensitiveInvariant(svalue, "no"))
                    return false;
                else {
                    string tmp = svalue.Trim();  // Remove leading & trailing white space.
                    if (CompareInsensitiveInvariant(tmp, "sspi") || CompareInsensitiveInvariant(tmp, "true") || CompareInsensitiveInvariant(tmp, "yes"))
                        return true;
                    else if (CompareInsensitiveInvariant(tmp, "false") || CompareInsensitiveInvariant(tmp, "no"))
                        return false;
                    else {
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            Debug.WriteLine("ConvertIntegratedSecurity <" + svalue + ">");
                        }
#endif
                        throw ADP.InvalidConnectionOptionValue(KEY.Integrated_Security);
                    }
                }
            }
            else {
                Debug.Assert(value is bool, KEY.Integrated_Security);
                return (bool) value;
            }
        }

        internal int CheckConvertToInt32(string keyname, int defaultvalue) {
            object value;
            if (!_parsetable.ContainsKey(keyname) || (null == (value = _parsetable[keyname]))) {
                return defaultvalue;
            }
            if (value is String) {
                try {
                    return Convert.ToInt32((string)value);
                }
                catch(Exception e) {
#if DEBUG
                    if (TraceParseConnectionString.Enabled) {
                        Debug.WriteLine("ConvertToInt32 <" + (string)value + ">");
                    }
#endif
                    throw ADP.InvalidConnectionOptionValue(keyname, e);
                }
            }
            else {
                Debug.Assert(value is Int32, keyname);
                return (int) value;
            }
        }

        internal string CheckConvertToString(string keyname, string defaultValue) {
            string value = null;
            if (_parsetable.ContainsKey(keyname)) {
                value = (string)_parsetable[keyname];
            }
            return ((null != value) ? value : defaultValue);
        }

        static private bool CompareInsensitiveInvariant(string strvalue, string strconst) {
            return (0 == CultureInfo.InvariantCulture.CompareInfo.Compare(strvalue, strconst, CompareOptions.IgnoreCase));
        }

        internal bool Contains(string keyword) {
            return _parsetable.ContainsKey(keyword);
        }

#if DEBUG
        [System.Diagnostics.Conditional("DEBUG")]
        internal void DebugTraceConnectionString(char[] connectionString) {
            try {
                string reducedConnectionString = RemovePasswordPwd(connectionString); // don't trace passwords ever!
                Debug.WriteLine("<" + reducedConnectionString + ">");
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void DebugTraceKeyValuePair(string keyname, string keyvalue) {
            try {
                Debug.Assert(keyname == keyname.ToLower(CultureInfo.InvariantCulture), "keyname == keyname.ToLower");
                keyname = KeywordLookup(keyname);
                if (!IsSensitiveOption(keyname)) { // don't trace passwords ever!
                    if (null != keyvalue) {
#if MDAC80721
                        if (EmbeddedExtendedProperties && (KEY.Extended_Properties == keyname)) {
                            Debug.Write("\t<" + keyname + ">=");
                            DebugTraceConnectionString(keyvalue.ToCharArray());
                        }
                        else {
#endif
                            Debug.WriteLine("\t<" + keyname + ">=<" + keyvalue + ">;");
#if MDAC80721
                        }
#endif
                    }
                    else {
                        Debug.WriteLine("\t<" + keyname + ">=;");
                    }
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);
            }
        }
#endif

        static private string GetKey(char[] valuebuf, int bufPosition) {
            bufPosition = TrimWhiteSpace(valuebuf, bufPosition);

            string key = System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valuebuf, 0, bufPosition));
            key = key.ToLower(CultureInfo.InvariantCulture);

            return key;
        }

        static private Exception ConnectionStringSyntax(int index, char[] connectionString) {
#if DEBUG
            if (TraceParseConnectionString.Enabled) {
                foreach(byte v in System.Text.Encoding.Unicode.GetBytes(connectionString)) {
                    Debug.Write(String.Format("{0,2:X},", v));
                }
                Debug.WriteLine("");
            }
#endif
            return ADP.ConnectionStringSyntax(index);
        }

        // transistion states used for parsing
        private enum PARSERSTATE {
            NothingYet=1,   //start point
            Key,
            KeyEqual,
            KeyEnd,
            UnquotedValue,
            DoubleQuoteValue,
            DoubleQuoteValueQuote,
            DoubleQuoteValueEnd,
            SingleQuoteValue,
            SingleQuoteValueQuote,
            SingleQuoteValueEnd,
            NullTermination,
        };

        /*
            Here is the RegEx pattern we used to use:

                private const string ConnectionStringPattern =      // available via DBConnectionString.ConnectionStringRegEx.ToString();
                     "(?<pair>"                                     // for easy key-value pair identification and removal
                    + "[\\s;]*"                                     // leading and in-between-pair whitespace/semicolons
                    + "(?<key>([^=\\s]|\\s+[^=\\s]|\\s+==|==)+)"    // allow any visible character for key except '=' which must be quoted as '=='
                    +    "\\s*=(?!=)\\s*"                           // the equal sign divides the key and value parts
                    + "(?<value>("
                    +    "(" + "\"" + "([^\"]|\"\")*" + "\"" + ")"  // double quoted string, inside " must be quoted as ""
                    +    "|"
                    +    "(" + "'" + "([^']|'')*" + "'" + ")"       // single quoted string, inside ' must be quoted as '
                    +    "|"
                    +    "(" + "(?![\"'])"                          // treated as error if start/stop with ' or "
                    +               "([^\\s;]|\\s+[^\\s;])*"        // allow everything else, using ; as stop
                             + "(?<![\"'])" + ")"                   // treated as error if start/stop with ' or "
                    +  "))"
                    +")*"
                    +"[\\s;\u0000]*"                                // trailing whitespace/semicolons and embedded nulls from DataSourceLocator
                ;
        */
        static private int GetKeyValuePair (char[] connectionString, int currentPosition, out string key, char[] valuebuf, out int vallength, out bool isempty) {
            PARSERSTATE     parserState = PARSERSTATE.NothingYet;
            int             bufPosition = 0;
            int startposition = currentPosition;

            key = null;
            vallength = -1;
            isempty = false;

            char currentChar = '\0';
            for (; currentPosition < connectionString.Length; ++currentPosition) {
                currentChar = connectionString[currentPosition];

                switch(parserState) {
                case PARSERSTATE.NothingYet:
                    if (';' == currentChar || Char.IsWhiteSpace(currentChar)) {
                        continue;
                    }
                    startposition = currentPosition;
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    parserState = PARSERSTATE.Key;
                    bufPosition = 0;
                    break;

                case PARSERSTATE.Key:
                    if ('=' == currentChar)             { parserState = PARSERSTATE.KeyEqual;       continue; }
                    if (Char.IsWhiteSpace(currentChar)) { break; }
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.KeyEqual:
                    if ('=' == currentChar)             { parserState = PARSERSTATE.Key;            break; }
                    key = GetKey(valuebuf, bufPosition);
                    bufPosition = 0;
                    parserState = PARSERSTATE.KeyEnd;
                    goto case PARSERSTATE.KeyEnd;

                case PARSERSTATE.KeyEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValue; continue; }
                    if ('"'  == currentChar)            { parserState = PARSERSTATE.DoubleQuoteValue; continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { goto Done; }
                    if (Char.IsControl(currentChar))    { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    parserState = PARSERSTATE.UnquotedValue;
                    break;

                case PARSERSTATE.UnquotedValue:
                    if (Char.IsWhiteSpace(currentChar)) { break; }
                    if (Char.IsControl(currentChar) || ';' == currentChar) {
                        goto Done;
                    }
                    break;

                case PARSERSTATE.DoubleQuoteValue:
                    if ('"' == currentChar)             { parserState = PARSERSTATE.DoubleQuoteValueQuote;   continue; }
                    if ('\0' == currentChar)            { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.DoubleQuoteValueQuote:
                    if ('"' == currentChar)             { parserState = PARSERSTATE.DoubleQuoteValue;      continue; }
                    parserState = PARSERSTATE.DoubleQuoteValueEnd;
                    goto case PARSERSTATE.DoubleQuoteValueEnd;

                case PARSERSTATE.DoubleQuoteValueEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    throw ConnectionStringSyntax(currentPosition, connectionString);  // unbalanced double quote

                case PARSERSTATE.SingleQuoteValue:
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValueQuote;   continue; }
                    if ('\0' == currentChar)            { throw ConnectionStringSyntax(currentPosition, connectionString); }
                    break;

                case PARSERSTATE.SingleQuoteValueQuote:
                    if ('\''== currentChar)             { parserState = PARSERSTATE.SingleQuoteValue;      continue; }
                    parserState = PARSERSTATE.SingleQuoteValueEnd;
                    goto case PARSERSTATE.SingleQuoteValueEnd;

                case PARSERSTATE.SingleQuoteValueEnd:
                    if (Char.IsWhiteSpace(currentChar)) { continue; }
                    if (';' == currentChar)             { goto Done; }
                    if ('\0' == currentChar)            { parserState = PARSERSTATE.NullTermination; continue; } // MDAC 83540
                    throw ConnectionStringSyntax(currentPosition, connectionString);  // unbalanced single quote

                case PARSERSTATE.NullTermination:
                    if ('\0' == currentChar) { continue; }
                    if (Char.IsWhiteSpace(currentChar)) { continue; } // MDAC 83540
                    throw ConnectionStringSyntax(startposition, connectionString);

                default:
                    Debug.Assert (false, "no state defined!!!!we should never be here!!!");
                    break;
                }

                valuebuf[bufPosition++] = currentChar;
            }

            if (PARSERSTATE.KeyEqual == parserState) {
                key = GetKey(valuebuf, bufPosition);
                bufPosition = 0;
            }
            if (PARSERSTATE.Key == parserState
                || PARSERSTATE.DoubleQuoteValue == parserState
                || PARSERSTATE.SingleQuoteValue == parserState) {
                throw ConnectionStringSyntax(startposition, connectionString);    // keyword not found/unbalanced double/single quote
            }
            Done:
                if (PARSERSTATE.UnquotedValue == parserState) {
                    bufPosition = TrimWhiteSpace(valuebuf, bufPosition);
                    if (('\'' == valuebuf[bufPosition-1]) || ('"' == valuebuf[bufPosition-1])) {
                        throw ConnectionStringSyntax(currentPosition-1, connectionString);    // unquoted value must not end in quote
                    }
                }
                else if ((PARSERSTATE.KeyEqual != parserState) && (PARSERSTATE.KeyEnd != parserState)) { // MDAC 83525
                    isempty = (0 == bufPosition); // MDAC 83525
                }

            if ((';' == currentChar) && (currentPosition < connectionString.Length)) {
                currentPosition++;
            }

            vallength = bufPosition;

            return currentPosition;
        }

        static private string GetSensitiveValue (char[] valuebuf, int valstart, int vallength, bool isempty) {
            string result = ((isempty) ? ADP.StrEmpty : null);

            if (0 < vallength) {
#if USECRYPTO
                result = Crypto.EncryptFromBlock(valuebuf, valstart, vallength);
#else
                result = new string(valuebuf, valstart, vallength);
#endif
            }
#if USECRYPTO
            Array.Clear(valuebuf, valstart, vallength); // valuebuf should be pinned
#endif
            return result;
        }

        static private string GetValue(char[] valuebuf, int valstart, int vallength, bool isempty) {
            string result = ((isempty) ? ADP.StrEmpty : null);

            if (0 < vallength)
                result = new string(valuebuf, valstart, vallength);

            return result;
        }

        internal bool HasBlankPassword() {
            bool blankPassword = false;

            if (!CheckConvertIntegratedSecurity()) {
	            bool checkuserid = true;
	            if (_parsetable.ContainsKey(KEY.Password)) {
	                blankPassword = ADP.IsEmpty((string)_parsetable[KEY.Password]);
	                checkuserid = false;
	            }
	            if (_parsetable.ContainsKey(SYNONYM.Pwd)) {
	                blankPassword |= ADP.IsEmpty((string)_parsetable[SYNONYM.Pwd]); // MDAC 83097
	                checkuserid = false;
	            }
	            if (checkuserid) {
	                blankPassword = ((_parsetable.ContainsKey(KEY.User_ID) && !ADP.IsEmpty((string)_parsetable[KEY.User_ID]))
	                    || (_parsetable.ContainsKey(SYNONYM.UID) && !ADP.IsEmpty((string)_parsetable[SYNONYM.UID])));
	            }
        	}
            return blankPassword;
        }

        internal bool IsEmpty() {
            return (null == _keychain);
        }

        virtual protected bool IsSensitiveOption(string keyname) {
            return ((KEY.Password == keyname) || (SYNONYM.Pwd == keyname));
        }

        virtual protected string KeywordLookup(string keyname) {
            return keyname;
        }

        internal bool IsSubsetOf(DBConnectionString entry) {
            Hashtable parsetable = entry._parsetable;
            switch(_behavior) {
            case KeyRestrictionBehavior.AllowOnly:
                foreach(string key in parsetable.Keys) {
                    if (!_parsetable.ContainsKey(key) && ((null == _restrictionValues) || (0 > Array.BinarySearch(_restrictionValues, key, invariantComparer)))) {
#if DATAPERMIT
                        Debug.WriteLine("DBDataPermission failed on AllowOnly");
#endif
                        return false;
                    }
                }
                break;
            case KeyRestrictionBehavior.PreventUsage:
                if (null != _restrictionValues) {
                    for(int i = 0; i < _restrictionValues.Length; ++i) {
                        if (parsetable.ContainsKey(_restrictionValues[i])) {
#if DATAPERMIT
                                Debug.WriteLine("DBDataPermission failed on PreventUsage");
#endif
                            return false;
                        }
                    }
                }
                break;
            default:
                Debug.Assert(false, "invalid KeyRestrictionBehavior");
                throw ADP.InvalidCast();
            }
            return true;
        }

#if OLEDB
        static private char[] LoadStringFromStorage(string udlfilename) { // UNDONE: MDAC 82612
            string udlFullPath = udlfilename;
            if (!ADP.IsEmpty(udlFullPath)) { // fail via new FileStream vs. GetFullPath
                udlFullPath = ADP.GetFullPath(udlFullPath); // MDAC 82833
            }
            return LoadStringFromCacheStorage(udlFullPath);
        }

        static private char[] LoadStringFromCacheStorage(string udlfilename) { // UNDONE: MDAC 82612
            char[] plainText = null;
            Hashtable udlcache = UDL._Pool;

            if ((null != udlcache) && udlcache.ContainsKey(udlfilename)) {
                string encrypted = (string)udlcache[udlfilename];
#if USECRYPTO
                byte[] plainBytes = new Byte[ADP.CharSize*encrypted.Length];
                GCHandle handle = GCHandle.Alloc(plainBytes, GCHandleType.Pinned);
                try {
                    int count = Crypto.DecryptToBlock(encrypted, plainBytes, 0, plainBytes.Length);
                    plainText = new Char[count/ADP.CharSize]; // UNDONE: creating unpinned buffer
                    /*GCHandle lostHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);*/
                    Buffer.BlockCopy(plainBytes, 0, plainText, 0, count);
                }
                finally {
                    Array.Clear(plainBytes, 0, plainBytes.Length);
                    if (handle.IsAllocated) {
                        handle.Free();
                    }
                }
#else
                plainText = encrypted.ToCharArray();
#endif
            }
            else {
                plainText = LoadStringFromFileStorage(udlfilename);
                if (null != plainText) {
#if USECRYPTO
                    GCHandle plainHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
#endif
                    Debug.Assert(!ADP.IsEmpty(udlfilename), "empty filename didn't fail");

                    if (0 < UdlPoolSize) {
#if USECRYPTO
                        string encrypted = Crypto.EncryptFromBlock(plainText, 0, plainText.Length);
#else
                        string encrypted = new String(plainText);
#endif
                        Debug.Assert(udlfilename == ADP.GetFullPath(udlfilename), "only cache full path filenames"); // MDAC 82833

                        if (null == udlcache) {
                            udlcache = new Hashtable();
                            udlcache[udlfilename] = encrypted;

                            lock(typeof(DBConnectionString)) {
                                if (null == UDL._Pool) {
                                    UDL._Pool = udlcache;
                                    udlcache = null;
                                }
                            }
                        }
                        if (null != udlcache) {
                            lock(udlcache.SyncRoot) {
                                udlcache[udlfilename] = encrypted;
                            }
                        }
                    }
#if USECRYPTO
                    plainHandle.Free();
#endif
                }
            }
            return plainText;
        }

        static private char[] LoadStringFromFileStorage(string udlfilename) { // UNDONE: MDAC 82612
            // Microsoft Data Link File Format
            // The first two lines of a .udl file must have exactly the following contents in order to work properly:
            //  [oledb]
            //  ; Everything after this line is an OLE DB initstring
            //
            char[] plainText = null;
            Exception failure = null;
            try {
                int hdrlength = ADP.CharSize*UDL.Header.Length;
                using(FileStream fstream = new FileStream(udlfilename, FileMode.Open, FileAccess.Read, FileShare.Read)) {
                    long length = fstream.Length;
                    if (length < hdrlength || (0 != length%ADP.CharSize)) {
                        failure = ADP.InvalidUDL();
                    }
                    else {
                        byte[] bytes = new Byte[hdrlength];
                        int count = fstream.Read(bytes, 0, bytes.Length);
                        if (count < hdrlength) {
                            failure = ADP.InvalidUDL();
                        }
                        else if (System.Text.Encoding.Unicode.GetString(bytes, 0, hdrlength) != UDL.Header) {
                            failure = ADP.InvalidUDL();
                        }
                        else { // please verify header before allocating memory block for connection string
                            bytes = new Byte[length - hdrlength];
#if USECRYPTO
                            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                            try {
#endif
                                count = fstream.Read(bytes, 0, bytes.Length);
                                plainText = new Char[count/ADP.CharSize]; // UNDONE: creating unpinned buffer
                                /*GCHandle lostHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);*/
                                Buffer.BlockCopy(bytes, 0, plainText, 0, count);
#if USECRYPTO
                            }
                            finally {
                                Array.Clear(bytes, 0, bytes.Length);
                                if (handle.IsAllocated) {
                                    handle.Free();
                                }
                            }
#endif
                        }
                    }
                }
            }
            catch(Exception e) {
                throw ADP.UdlFileError(e);
            }
            if (null != failure) {
                throw failure;
            }
            return plainText;
        }
#endif // OLEDB

        internal DBConnectionString MergeIntersect(DBConnectionString entry) { // modify this _restrictionValues with intersect of entry
            KeyRestrictionBehavior behavior = _behavior;
            string[] restrictionValues = null;

            if (null == entry) {
                //Debug.WriteLine("0 entry AllowNothing");
                behavior = KeyRestrictionBehavior.AllowOnly;
            }
            else if (this._behavior != entry._behavior) { // subset of the AllowOnly array
                if (KeyRestrictionBehavior.AllowOnly == entry._behavior) { // this PreventUsage and entry AllowOnly
                    if (!ADP.IsEmpty(_restrictionValues)) {
                        if (!ADP.IsEmpty(entry._restrictionValues)) {
                            //Debug.WriteLine("1 this PreventUsage with restrictions and entry AllowOnly with restrictions");
                            restrictionValues = NewRestrictionAllowOnly(entry._restrictionValues, _restrictionValues);
                        }
                        else {
                            //Debug.WriteLine("2 this PreventUsage with restrictions and entry AllowOnly with no restrictions");
                        }
                    }
                    else {
                        //Debug.WriteLine("3/4 this PreventUsage with no restrictions and entry AllowOnly");
                        restrictionValues = entry._restrictionValues;
                    }
                }
                else if (!ADP.IsEmpty(_restrictionValues)) { // this AllowOnly and entry PreventUsage
                    if (!ADP.IsEmpty(entry._restrictionValues)) {
                        //Debug.WriteLine("5 this AllowOnly with restrictions and entry PreventUsage with restrictions");
                        restrictionValues = NewRestrictionAllowOnly(_restrictionValues, entry._restrictionValues);
                    }
                    else {
                        //Debug.WriteLine("6 this AllowOnly and entry PreventUsage with no restrictions");
                        restrictionValues = _restrictionValues;
                    }
                }
                else {
                    //Debug.WriteLine("7/8 this AllowOnly with no restrictions and entry PreventUsage");
                }
                behavior = KeyRestrictionBehavior.AllowOnly;
            }
            else if (KeyRestrictionBehavior.PreventUsage == this._behavior) { // both PreventUsage
                if (ADP.IsEmpty(_restrictionValues)) {
                    //Debug.WriteLine("9/10 both PreventUsage and this with no restrictions");
                    restrictionValues = entry._restrictionValues;
                }
                else if (ADP.IsEmpty(entry._restrictionValues)) {
                    //Debug.WriteLine("11 both PreventUsage and entry with no restrictions");
                    restrictionValues = _restrictionValues;
                }
                else {
                    //Debug.WriteLine("12 both PreventUsage with restrictions");
                    restrictionValues = NoDuplicateUnion(_restrictionValues, entry._restrictionValues);
                }
            }
            else if (!ADP.IsEmpty(_restrictionValues) && !ADP.IsEmpty(entry._restrictionValues)) { // both AllowOnly with restrictions
                if (this._restrictionValues.Length <= entry._restrictionValues.Length) {
                    //Debug.WriteLine("13a this AllowOnly with restrictions and entry AllowOnly with restrictions");
                    restrictionValues = NewRestrictionIntersect(_restrictionValues, entry._restrictionValues);
                }
                else {
                    //Debug.WriteLine("13b this AllowOnly with restrictions and entry AllowOnly with restrictions");
                    restrictionValues = NewRestrictionIntersect(entry._restrictionValues, _restrictionValues);
                }
            }
            else { // both AllowOnly
                //Debug.WriteLine("14/15/16 this AllowOnly and entry AllowOnly but no restrictions");
            }
            return new DBConnectionString(this, restrictionValues, behavior);
        }


        static private string[] NewRestrictionAllowOnly(string[] allowonly, string[] preventusage) {
            ArrayList newlist = null;
            for (int i = 0; i < allowonly.Length; ++i) {
                if (0 > Array.BinarySearch(preventusage, allowonly[i], invariantComparer)) {
                    if (null == newlist) {
                        newlist = new ArrayList();
                    }
                    newlist.Add(allowonly[i]);
                }
            }
            if (null != newlist) {
                return (string[])newlist.ToArray(typeof(String));
            }
            return null;
        }

        static private string[] NewRestrictionIntersect(string[] a, string[] b) {
            ArrayList newlist = null;
            for (int i = 0; i < a.Length; ++i) {
                if (0 <= Array.BinarySearch(b, a[i], invariantComparer)) {
                    if (null == newlist) {
                        newlist = new ArrayList();
                    }
                    newlist.Add(a[i]);
                }
            }
            if (newlist != null) {
                return (string[])newlist.ToArray(typeof(String));
            }
            return null;
        }

        static private string[] NoDuplicateUnion(string[] a, string[] b) {
            int length = a.Length;
            int count = b.Length;
            int index = 0;

            for(int i = 0; i < length; ++i) { // find duplicates
                if (0 > Array.BinarySearch(b, a[i], invariantComparer)) {
                    a[i] = null;
                    --count;
                }
            }
            string[] restrictionValues = new string[length + count];
            for(int i = 0; i < length; ++i) { // copy from this except duplicates (now as null)
                string restriction = a[i];
                if (null != restriction) {
                    restrictionValues[index++] = restriction;
                }
            }
            length = b.Length;
            for (int i = 0; i < length; ++i, index++) { // copy from entry
                restrictionValues[index] = b[i];
            }
            Array.Sort(restrictionValues, invariantComparer);
            return restrictionValues;
        }

#if USECRYPTO
        private string ParseConnectionString(string connectionString, string encryptedConnectionString, UdlSupport checkForUdl, ref NameValuePair keychain) {
            string encryptedActualConnectionString = encryptedConnectionString;
            try {
                char[] plainText = new char[connectionString.Length];
                GCHandle plainHandle = GCHandle.Alloc(plainText, GCHandleType.Pinned);
                try {
                    connectionString.CopyTo(0, plainText, 0, plainText.Length);
                    char[] resultText = ParseInternal(plainText, checkForUdl, ref keychain);
                    if ((plainText as object) != (resultText as object)) {
                        GCHandle resultHandle = GCHandle.Alloc(resultText, GCHandleType.Pinned);
                        try {
                            encryptedActualConnectionString = Crypto.EncryptFromBlock(resultText, 0, resultText.Length);
                        }
                        finally {
                            Array.Clear(resultText, 0, resultText.Length);
                            if(resultHandle.IsAllocated) {
                                resultHandle.Free();
                            }
                            resultText = null;
                        }
                    }
                }
                finally {
                    Array.Clear(plainText, 0, plainText.Length);
                    if(plainHandle.IsAllocated) {
                        plainHandle.Free();
                    }
                    plainText = null;
                }
            }
            catch {
                throw;
            }
            return encryptedActualConnectionString;
        }
#endif

        private char[] ParseInternal(char[] connectionString, UdlSupport checkForUdl, ref NameValuePair keychain) { // UNDONE: MDAC 82612
            Debug.Assert(null != connectionString, "null connectionstring");
#if DEBUG
            if (TraceParseConnectionString.Enabled) {
                DebugTraceConnectionString(connectionString);
            }
#endif
            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = connectionString.Length;
            string  keyname;
            char[]  valueBuffer = new char[connectionString.Length];
            int     valueLength;
#if OLEDB
            string  udlFileName = null;
            int     udlInsertPosition = 0;
            char[]  actualConnectionString = null;
            int     actualConnectionStringLength = 0;
#endif //OLEDB
#if USECRYPTO
            GCHandle actualHandle = GCHandle.Alloc(null, GCHandleType.Normal);
#endif

            char[]  result = connectionString;

            NameValuePair localKeychain = null;

#if USECRYPTO
            GCHandle valueHandle = GCHandle.Alloc(valueBuffer, GCHandleType.Pinned);
            try {
#endif
                while (nextStartPosition < endPosition) {
                    startPosition    = nextStartPosition;
                    nextStartPosition = GetKeyValuePair(connectionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);

                    if (!ADP.IsEmpty(keyname)) {
                        string keyvalue = null;
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            DebugTraceKeyValuePair(keyname, System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valueBuffer, 0, valueLength)));
                        }
#endif
#if OLEDB
                        if (KEY.File_Name == keyname) {
                            keyvalue = GetValue(valueBuffer, 0, valueLength, isempty); // MDAC 83987, 83543
                            switch (checkForUdl) {
                            case UdlSupport.LoadFromFile:
                                udlFileName = keyvalue;

                                int pairLength = nextStartPosition-startPosition;

                                if (null == actualConnectionString) {
                                    actualConnectionStringLength = connectionString.Length;
                                    actualConnectionString       = new char[actualConnectionStringLength];
#if USECRYPTO
                                    actualHandle = GCHandle.Alloc(actualConnectionString, GCHandleType.Pinned);
#endif
                                    ADP.CopyChars(connectionString, 0, actualConnectionString, 0, startPosition);
                                }
                                udlInsertPosition = startPosition - (connectionString.Length - actualConnectionStringLength);
                                ADP.CopyChars(connectionString, nextStartPosition, actualConnectionString, udlInsertPosition, connectionString.Length-nextStartPosition);

                                actualConnectionStringLength -= pairLength;
#if USECRYPTO
                                Array.Clear(actualConnectionString, actualConnectionStringLength, pairLength);   // don't leave sensitive stuff in memory.
#endif
                                break;

                            case UdlSupport.UdlAsKeyword:
                                break;

                            default: //UdlSupport.ThrowIfFound
                                throw ADP.KeywordNotSupported(keyname);
                            }
                        }
                        else 
#endif //OLEDB
                        {
                            string realkeyname = KeywordLookup(keyname);
                            if (ADP.IsEmpty(realkeyname)) {
                                throw ADP.KeywordNotSupported(keyname);
                            }
                            keyname = realkeyname;

                            if (IsSensitiveOption(keyname)) {
                                keyvalue = GetSensitiveValue(valueBuffer, 0, valueLength, isempty);
#if USECRYPTO
                                _isEncrypted = true;
#endif
                            }
                            else {
                                keyvalue = GetValue(valueBuffer, 0, valueLength, isempty);
                            }
                        }
                        _parsetable[keyname] = keyvalue; // last key-value pair wins

                        if(null != localKeychain) {
                            localKeychain = localKeychain.Next = new NameValuePair(keyname, keyvalue);
                        }
                        else if (null == keychain) { // first time only - don't contain modified chain from UDL file
                            keychain = localKeychain = new NameValuePair(keyname, keyvalue);
                        }
                        
                    }
                }

#if OLEDB
                if (null != actualConnectionString) {
                    if (UdlSupport.LoadFromFile == checkForUdl && (null != udlFileName)) { // UDL file support
                        char[] udlConnectionString = udlConnectionString = LoadStringFromStorage(udlFileName);
                        if ((null != udlConnectionString) && (0 < udlConnectionString.Length)) {
#if USECRYPTO
                            GCHandle udlHandle = GCHandle.Alloc(udlConnectionString, GCHandleType.Pinned);
                            try {
#endif
                                int newLength = actualConnectionStringLength + udlConnectionString.Length;

                                result = new char[newLength]; // UNDONE: creating unpinned buffer
                                /*GCHandle lostHandle = GCHandle.Alloc(result, GCHandleType.Pinned);*/

                                ADP.CopyChars(actualConnectionString, 0,    result, 0,                  udlInsertPosition);
                                ADP.CopyChars(udlConnectionString,    0,    result, udlInsertPosition,  udlConnectionString.Length);
                                ADP.CopyChars(actualConnectionString, udlInsertPosition,
                                    result, udlConnectionString.Length + udlInsertPosition,
                                    actualConnectionStringLength - udlInsertPosition);

                                // recursively parse the new connection string (but only allow one
                                // level of recursion by specifying checkForUdl=false)
                                result = ParseInternal(result, UdlSupport.UdlAsKeyword, ref keychain);
#if USECRYPTO
                            }
                            finally {
                                Array.Clear(udlConnectionString, 0, udlConnectionString.Length);
                                if (udlHandle.IsAllocated) {
                                    udlHandle.Free();
                                }
                                udlConnectionString = null;
                            }
#endif
                        }
                    }
                    else {
                        result = actualConnectionString;
                    }
#if USECRYPTO
                    if (result != actualConnectionString) {
                        Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                    }
                    if (actualHandle.IsAllocated) {
                        actualHandle.Free();
                    }
                    actualConnectionString = null;
#endif
                }
#endif // OLEDB
#if USECRYPTO
            }
            catch {
                Array.Clear(valueBuffer, 0, valueBuffer.Length);
                if (valueHandle.IsAllocated) {
                    valueHandle.Free();
                }
                if (null != actualConnectionString) {
                    Array.Clear(actualConnectionString, 0, actualConnectionString.Length);
                    if (actualHandle.IsAllocated) {
                        actualHandle.Free();
                    }
                }
                throw;
            }
            // valueBuffer is cleared by GetSensitiveOption in normal scenario
            if (valueHandle.IsAllocated) {
                valueHandle.Free();
            }
#endif
            return result;
        }

        private string[] ParseRestrictions(string restrictions) {
            ADP.CheckArgumentNull(restrictions, "restrictions");

            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = restrictions.Length;
            string  keyname;
            char[]  valueBuffer = new char[restrictions.Length];        // TODO: determine if there sensitive data here we need to clear?
            int     valueLength;

            char[]  restrictionString = restrictions.ToCharArray();

            ArrayList restrictionValues = new ArrayList();

            while (nextStartPosition < endPosition) {
                startPosition    = nextStartPosition;
                nextStartPosition = GetKeyValuePair(restrictionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);
                if (!ADP.IsEmpty(keyname)) {
                    string realkeyname = KeywordLookup(keyname); // MDAC 85144
                    if (ADP.IsEmpty(realkeyname)) {
                        throw ADP.KeywordNotSupported(keyname);
                    }
                    restrictionValues.Add(realkeyname);
                }
            }
            return RemoveDuplicates((string[])restrictionValues.ToArray(typeof(string)));
        }

        static internal string[] RemoveDuplicates(string[] restrictions) {
            int count = restrictions.Length;
            if (0 < count) {
                Array.Sort((String[]) restrictions, invariantComparer);

                for (int i = 1; i < restrictions.Length; ++i) {
                    string prev = restrictions[i-1];
                    if ((0 == prev.Length) || (prev == restrictions[i])) {
                        restrictions[i-1] = null;
                        count--;
                    }
                }
                if (0 == restrictions[restrictions.Length-1].Length) {
                    restrictions[restrictions.Length-1] = null;
                    count--;
                }
                if (count != restrictions.Length) {
                    string[] tmp = new String[count];
                    count = 0;
                    for (int i = 0; i < restrictions.Length; ++i) {
                        if (null != restrictions[i]) {
                            tmp[count++] = restrictions[i];
                        }
                    }
                    return tmp;
                }
            }
            return restrictions;
        }

#if MDAC80721
        static internal int AppendKeyValuePair(char[] builder, int index, string keyname, string value) { // MDAC 80721
            ADP.CheckArgumentNull(builder, "builder");
            ADP.CheckArgumentLength(keyname, "keyname");

            if ((0 < index) && (';' != builder[index-1])) {
                builder[index++] = ';';
            }

            char c;
            int length = keyname.Length;
            for (int i = 0; i < length; ++i) { // <key=word>=<value> -> <key==word>=<value>
                builder[index++] = c = keyname[i];
                if ('=' == c) { builder[index++] = c; }
            }
            builder[index++] = '=';

            if (null != value) { // else <keyword>=;
                bool doubleQuote = (-1 != value.IndexOf('\"'));
                bool singleQuote = (-1 != value.IndexOf('\''));
                bool semiColon   = (-1 != value.IndexOf(';'));
                length = value.Length;

                if (doubleQuote) {
                    if (singleQuote) { // <va'l"ue> -> <"va'l""ue">
                        builder[index++] = '\"';
                        for (int i = 0; i < length; ++i) {
                            builder[index++] = c = keyname[i];
                            if ('\"' == c) { builder[index++] = c; }
                        }
                        builder[index++] = '\"';
                    }
                    else { // <val"ue> -> <'val"ue'>
                        builder[index++] = '\'';
                        value.CopyTo(0, builder, index, value.Length);
                        index += value.Length;
                        builder[index++] = '\'';
                    }
                }
                else if (singleQuote || semiColon || (0 == value.Length) || ((0 < value.Length) && ('=' == value[0]))) {
                    // <val'ue> -> <"val'ue"> || <val;ue> -> <"val;ue"> || <> -> <""> || <=value> -> <"=value">
                    builder[index++] = '\"';
                    value.CopyTo(0, builder, index, value.Length);
                    index += value.Length;
                    builder[index++] = '\"';
                }
                else {
                    value.CopyTo(0, builder, index, value.Length);
                    index += value.Length;
                }
            }
            builder[index++] = ';';
            return index;
        }
#endif

        // doesn't valid connection string syntax
        // remove generic keyvalue pairs from a connection string
        internal string RemoveKeyValuePairs(char[] connectionString, string[] keyNames) {
            ADP.CheckArgumentNull(connectionString, "connectionString");
            ADP.CheckArgumentLength(keyNames, "keyNames");

            bool    isempty;
            int     startPosition;
            int     nextStartPosition = 0;
            int     endPosition = connectionString.Length;
            string  keyname;
            int     valueLength;

            char[]  actualConnectionString = null;
            int     outputPosition = 0;

            char[]  valueBuffer = new char[connectionString.Length];
#if USECRYPTO
            GCHandle valueHandle = GCHandle.Alloc(valueBuffer, GCHandleType.Pinned);
            try {
#endif
                while (nextStartPosition < endPosition) {
                    startPosition    = nextStartPosition;
                    nextStartPosition = GetKeyValuePair(connectionString, startPosition, out keyname, valueBuffer, out valueLength, out isempty);
                    if (!ADP.IsEmpty(keyname)) {
                        bool found = false;
#if DEBUG
                        if (TraceParseConnectionString.Enabled) {
                            DebugTraceKeyValuePair(keyname, System.Text.Encoding.Unicode.GetString(System.Text.Encoding.Unicode.GetBytes(valueBuffer, 0, valueLength)));
                        }
#endif
                        int length = keyNames.Length;
                        for (int i = 0; !found && i < length; i++) {
                            found = (keyNames[i] == keyname);
                        }
                        if(!found) {
                            if (null == actualConnectionString) {
                                actualConnectionString = new char[connectionString.Length];
                            }
                            int pairLength = nextStartPosition-startPosition;
#if MDAC80721
                            if (EmbeddedExtendedProperties && !isempty && (KEY.Extended_Properties == keyname)) { // MDAC 80721
                                char[] tmp = new char[valueLength];
#if USECRYPTO
                                GCHandle tmpHandle = GCHandle.Alloc(tmp, GCHandleType.Pinned);
#endif
                                try { // if 'Extended Properties' is an embedded connection string, remove the keynames from that embedded string
                                    ADP.CopyChars(valueBuffer, 0, tmp, 0, valueLength);
                                    string reducedExtendedProperties = RemoveKeyValuePairs(tmp, keyNames);
                                    outputPosition = AppendKeyValuePair(actualConnectionString, outputPosition, keyname, reducedExtendedProperties);
                                }
                                catch(Exception e) { // extended properties is not an embedded connection string
                                    ADP.TraceException(e);
                                    ADP.CopyChars(connectionString, startPosition, actualConnectionString, outputPosition, pairLength);
                                    outputPosition += pairLength;
                                }
#if USECRYPTO
                                finally {
                                    Array.Clear(tmp, 0, tmp.Length);
                                    if (tmpHandle.IsAllocated) {
                                        tmpHandle.Free();
                                    }
                                }
#endif
                            }
                            else { // copy normal keyvalue pairs to new connection string
#endif
                                ADP.CopyChars(connectionString, startPosition, actualConnectionString, outputPosition, pairLength);
                                outputPosition += pairLength;
#if MDAC80721
                            }
#endif
                        }
                        else {
#if USECRYPTO
                            Array.Clear(valueBuffer, 0, valueLength);
#endif
                            for (; nextStartPosition < connectionString.Length; ++nextStartPosition) {
                                char currentChar = connectionString[nextStartPosition];
                                if (Char.IsWhiteSpace(currentChar) || ';' == currentChar) {
                                    continue;
                                }
                                break;
                            }
                        }
                    }
                }
#if USECRYPTO
            }
            catch {
                Array.Clear(valueBuffer, 0, valueBuffer.Length);
                if (valueHandle.IsAllocated) {
                    valueHandle.Free();
                }
                throw;
            }
#endif
            return GetValue(actualConnectionString, 0, outputPosition, (null == actualConnectionString));
        }

        // remove Password and Pwd keyvalue pairs from a connection string
        internal string RemovePasswordPwd(char[] connectionString) {
            if (null != connectionString) {
                return RemoveKeyValuePairs(connectionString, new string[] { KEY.Password, SYNONYM.Pwd });
            }
            return null;
        }

        internal bool ShouldCache() {
            bool flag = true;
#if OLEDB
            if (_parsetable.ContainsKey(KEY.File_Name)) {
                string filename = (string)_parsetable[KEY.File_Name];
                Hashtable udlcache = UDL._Pool; // only caches full path filenames
                flag = (ADP.IsEmpty(filename) || ((null != udlcache) && udlcache.ContainsKey(filename))); // MDAC 83987, 83543
            }
#endif //OLEDB
            return flag;
        }

        internal bool ContainsPersistablePassword() {
            bool contains = (_parsetable.ContainsKey(KEY.Password) || _parsetable.ContainsKey(SYNONYM.Pwd));
            if (contains) {
                return CheckConvertToBoolean(KEY.Persist_Security_Info, false);
            }
            return true; // no password means persistable password so we don't have to munge
        }

        static private int TrimWhiteSpace(char[] valuebuf, int bufPosition) {
            // remove trailing whitespace from the buffer
            while ((0 < bufPosition) && Char.IsWhiteSpace(valuebuf[bufPosition-1])) {
                bufPosition--;
            }
            return bufPosition;
        }

        virtual protected string ValidateParse() {
            return EncryptedActualConnectionString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbsqlparsertable.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSqlParserTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;

	//----------------------------------------------------------------------
	// DBSqlParserTable
	//
	//	A parsed table reference from DBSqlParser.
	//
	sealed internal class DBSqlParserTable
	{
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		
					
		private string		_databaseName;
		private string		_schemaName;
		private string		_tableName;
		private string		_correlationName;

		private	DBSqlParserColumnCollection	_columns;


		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Constructor 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		internal DBSqlParserTable(
				string databaseName,
				string schemaName,
				string tableName,
				string correlationName
				)
		{
			_databaseName	= databaseName;
			_schemaName		= schemaName;
			_tableName		= tableName;
			_correlationName= correlationName;
		}

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal DBSqlParserColumnCollection Columns
		{
			get 
			{
				if (null == _columns)
				{
					_columns = new DBSqlParserColumnCollection();
				}
				return _columns;
			}
			set 
			{
				if (null == value)
					throw new ArgumentNullException("value");
				
       		    if (!typeof(DBSqlParserColumnCollection).IsInstanceOfType(value))
       		    	throw new InvalidCastException("value");

       		    _columns = value;
 			}
		}

		internal string	CorrelationName	{ get { return (null == _correlationName)?string.Empty : _correlationName; } }
		internal string	DatabaseName	{ get { return (null == _databaseName)	? string.Empty : _databaseName; } }
		internal string SchemaName		{ get { return (null == _schemaName)	? string.Empty : _schemaName; } }
		internal string	TableName		{ get { return (null == _tableName)		? string.Empty : _tableName; } }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbsqlparsercolumncollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSqlParserColumnCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;
	
	//----------------------------------------------------------------------
	// DBSqlParserColumnCollection
	//
	//	A collection of parsed column references from DBSqlParser.
	//
	sealed internal class DBSqlParserColumnCollection : CollectionBase
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// ItemType
		//
		private Type ItemType
		{
            get { return typeof(DBSqlParserColumn); }
        }

		//----------------------------------------------------------------------
		// this[]
		//
		internal DBSqlParserColumn this[int i]
		{
			get
			{
	            DBSqlParserColumn value = (DBSqlParserColumn)InnerList[i];
	            return value;
			}
		}
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// Add()
		//
		internal DBSqlParserColumn Add(DBSqlParserColumn value) 
		{
			OnValidate(value);
            InnerList.Add(value);
            return value;
		}
		
		internal DBSqlParserColumn Add (
				string databaseName,
				string schemaName,
				string tableName,
				string columnName,
				string alias
				)
		{
			DBSqlParserColumn p = new DBSqlParserColumn(databaseName, schemaName, tableName, columnName, alias);
			return Add(p);
		}

		//----------------------------------------------------------------------
		// Insert
		//
        internal void Insert(int index, DBSqlParserColumn value)
        {
        	InnerList.Insert(index, value);
        }

		//----------------------------------------------------------------------
		// OnValidate()
		//
        protected override void OnValidate(Object value)
        { 
            Debug.Assert (value != null, 					"may not add null objects to collection!");
            Debug.Assert (ItemType.IsInstanceOfType(value), "object to add must be a DBSqlParserColumn!");
        }
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbsqlparsercolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSqlParserColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;

	//----------------------------------------------------------------------
	// DBSqlParserColumn
	//
	//	A parsed column reference from DBSqlParser.
	//
	sealed internal class DBSqlParserColumn
	{
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		
					
		private bool		_isKey;
		private bool		_isUnique;
		private string		_databaseName;
		private string		_schemaName;
		private string		_tableName;
		private string		_columnName;
		private string		_alias;


		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Constructor 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		internal DBSqlParserColumn(
				string databaseName,
				string schemaName,
				string tableName,
				string columnName,
				string alias
				)
		{
			_databaseName	= databaseName;
			_schemaName		= schemaName;
			_tableName		= tableName;
			_columnName		= columnName;
			_alias			= alias;
		}

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

//		internal string	Alias			{ get { return (null == _alias) 		? string.Empty : _alias; } }
		internal string	ColumnName		{ get { return (null == _columnName)	? string.Empty : _columnName; } }
		internal string	DatabaseName	{ get { return (null == _databaseName)	? string.Empty : _databaseName; } }
		
		internal bool 	IsAliased		{ get { return _alias != null; } }
		internal bool 	IsExpression	{ get { return _columnName == null; } }
		internal bool 	IsKey			{ get { return _isKey; } }
		internal bool 	IsUnique		{ get { return _isUnique; } }
		
		internal string SchemaName		{ get { return (null == _schemaName)	? string.Empty : _schemaName; } }
		internal string	TableName		{ get { return (null == _tableName)		? string.Empty : _tableName; } }


		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		internal void CopySchemaInfoFrom(DBSqlParserColumn completedColumn)
		{
			_databaseName	= completedColumn.DatabaseName;
			_schemaName		= completedColumn.SchemaName;
			_tableName		= completedColumn.TableName;
			_columnName		= completedColumn.ColumnName;
			_isKey			= completedColumn.IsKey;
			_isUnique		= completedColumn.IsUnique;		
		}
		
		internal void CopySchemaInfoFrom(DBSqlParserTable table)
		{
			_databaseName	= table.DatabaseName;
			_schemaName		= table.SchemaName;
			_tableName		= table.TableName;
			_isKey			= false;
			_isUnique		= false;		
		}

		internal void SetAsKey(bool isUniqueConstraint)
		{
 			_isKey		= true;
			_isUnique	= isUniqueConstraint;		
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbsqlparsertablecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSqlParserTableCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;
	
	//----------------------------------------------------------------------
	// DBSqlParserColumnCollection
	//
	//	A collection of parsed table references from DBSqlParser.
	//
	sealed internal class DBSqlParserTableCollection : CollectionBase
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// ItemType
		//
		private Type ItemType
		{
            get { return typeof(DBSqlParserTable); }
        }


		//----------------------------------------------------------------------
		// this[]
		//
		internal DBSqlParserTable this[int i]
		{
			get
			{
	            DBSqlParserTable value = (DBSqlParserTable)InnerList[i];
	            return value;
			}
		}
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// Add()
		//
		internal DBSqlParserTable Add(DBSqlParserTable value) 
		{
			OnValidate(value);
            InnerList.Add(value);
            return value;
		}
		
		internal DBSqlParserTable Add (
				string databaseName,
				string schemaName,
				string tableName,
				string correlationName
				)
		{
			DBSqlParserTable p = new DBSqlParserTable(databaseName, schemaName, tableName, correlationName);
			return Add(p);
		}

		//----------------------------------------------------------------------
		// OnValidate()
		//
        protected override void OnValidate(Object value)
        { 
            Debug.Assert (value != null, 					"may not add null objects to collection!");
            Debug.Assert (ItemType.IsInstanceOfType(value), "object to add must be a DBSqlParserTable!");
        }

	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\fieldnamelookup.cs ===
//------------------------------------------------------------------------------
// <copyright file="FieldNameLookup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Text;

    sealed internal class FieldNameLookup { // MDAC 69015, 71470
        
        // hashtable stores the index into the _fieldNames, match via case-sensitive
        private Hashtable _fieldNameLookup;

        // original names for linear searches when exact matches fail
        private string[] _fieldNames;

        // if _defaultLCID is -1 then _compareInfo is initialized with CurrentCulture CompareInfo
        // otherwise it is specified by the server? for the correct compare info
        private CompareInfo _compareInfo;
        private int _defaultLCID;

        /*internal FieldNameLookup(string[] fieldNames, int defaultLCID) {
            _fieldNames = fieldNames;
            _defaultLCID = defaultLCID;
        }*/

        internal FieldNameLookup(IDataReader reader, int defaultLCID) {

            int length = reader.FieldCount;
            string[] fieldNames = new string[length];
            for (int i = 0; i < length; ++i) {
                fieldNames[i] = reader.GetName(i);
                Debug.Assert(null != fieldNames[i], "MDAC 66681");
            }
            _fieldNames = fieldNames;
            _defaultLCID = defaultLCID;
        }

        /*internal string this[int ordinal] {
            get {
                return _fieldNames[ordinal];
            }
        }*/

        internal int GetOrdinal(string fieldName) {
            if (null == fieldName) {
                throw ADP.ArgumentNull("fieldName");
            }
            int index = IndexOf(fieldName);
            if (-1 == index) {
                throw ADP.IndexOutOfRange(fieldName);
            }
            return index;
        }

        internal int IndexOfName(string fieldName) {
            if (null == _fieldNameLookup) {
                GenerateLookup();
            }
            // via case sensitive search, first match with lowest ordinal matches
            if (_fieldNameLookup.Contains(fieldName)) {
                return (int)_fieldNameLookup[fieldName];
            }
            return -1;
        }

        internal int IndexOf(string fieldName) {
            if (null == _fieldNameLookup) {
                GenerateLookup();
            }
            int index;

            // via case sensitive search, first match with lowest ordinal matches
            if (_fieldNameLookup.Contains(fieldName)) {
                index = (int)_fieldNameLookup[fieldName];
            }
            else {
                // via case insensitive search, first match with lowest ordinal matches
                index = LinearIndexOf(fieldName, CompareOptions.IgnoreCase);
                if (-1 == index) {
                    // do the slow search now (kana, width insensitive comparison)
                    index = LinearIndexOf(fieldName, ADP.compareOptions);
                }
            }
            return index;
        }

        private int LinearIndexOf(string fieldName, CompareOptions compareOptions) {
            CompareInfo compareInfo = _compareInfo;
            if (null == compareInfo) {
                if (-1 != _defaultLCID) {
                    compareInfo = CompareInfo.GetCompareInfo(_defaultLCID);
                }
                if (null == compareInfo) {
                    compareInfo = CultureInfo.CurrentCulture.CompareInfo;
                }
                _compareInfo = compareInfo;
            }
            int length = _fieldNames.Length;
            for (int i = 0; i < length; ++i) {
                if (0 == compareInfo.Compare(fieldName, _fieldNames[i], compareOptions)) {
                    _fieldNameLookup[fieldName] = i; // add an exact match for the future
                    return i;
                }
            }
            return -1;
        }

        // RTM common code for generating Hashtable from array of column names
        private void GenerateLookup() {
            int length = _fieldNames.Length;
            Hashtable hash = new Hashtable(length);

            // via case sensitive search, first match with lowest ordinal matches
            for (int i = length-1; 0 <= i; --i) {
                string fieldName = _fieldNames[i];
                hash[fieldName] = i;
            }
            _fieldNameLookup = hash;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\dbsqlparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBSqlParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.ComponentModel;
	using System.Diagnostics;
    using System.Globalization;
	using System.Text;
	using System.Text.RegularExpressions;

	//----------------------------------------------------------------------
	// DBSqlParser
	//
	//	This class implements a basic SQL parser to allow providers that
	//	do not get schema information from their back end to gather it
	//	from the statement text itself.
	//
    abstract internal class DBSqlParser
	{

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Private types and string constants 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		public enum TokenType
		{
			Null		= 0,
			Identifier	= 1,
			QuotedIdentifier = 2,
			String		= 3,
			
			Other		= 100,
			Other_Comma,
			Other_Period,
			Other_LeftParen,
			Other_RightParen,
			Other_Star,

			Keyword		= 200,

			Keyword_ALL,
			Keyword_AS,
			Keyword_COMPUTE,
			Keyword_DISTINCT,
			Keyword_FOR,
			Keyword_FROM,
			Keyword_GROUP,
			Keyword_HAVING,
			Keyword_INTERSECT,
			Keyword_INTO,
			Keyword_MINUS,
			Keyword_ORDER,
			Keyword_SELECT,
			Keyword_TOP,
			Keyword_UNION,
			Keyword_WHERE,
		};
		
		internal struct Token
		{
			private TokenType 	_type;
			private string		_value;

			internal static readonly Token Null = new Token(0, null);

			internal string		Value	{ get { return _value; } }
			internal TokenType	Type	{ get { return _type; } }

			internal Token(TokenType type, string value)
			{
				_type 	= type;
				_value	= value;
			}
		}

		private const string SqlTokenPattern_Part1 =
			@"[\s;]*"
			+@"("
			+@"(?<keyword>all|as|compute|distinct|for|from|group|having|intersect|minus|order|select|top|union|where)\b"
			+@"|"
 			+@"(?<identifier>"
			;

			// validIdentifierFirstCharacters
			// validIdentifierCharacters

		private const string SqlTokenPattern_Part2 =
			@"*)"
			+@"|"
			;

		// quotePrefixCharacter
		
		private const string SqlTokenPattern_Part3 =
 			"(?<quotedidentifier>"
 			;

		// quotedIdentifierCharacters
		
		private const string SqlTokenPattern_Part4 =
 			")"
 			;
		
		// quoteSuffixCharacter
		
		private const string SqlTokenPattern_Part5 =
			@"|"
			+@"(?<string>"
			;

		// stringPattern

		private const string SqlTokenPattern_Part6 =
			@")"
			+@"|"
			+@"(?<other>.)"
			+@")"
			+@"[\s;]*"
			;

		
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		static private Regex	_sqlTokenParser;
		static private string	_sqlTokenPattern;
		
		static private int		_identifierGroup;
		static private int		_quotedidentifierGroup;
		static private int		_keywordGroup;
		static private int		_stringGroup;
		static private int		_otherGroup;


		private string _quotePrefixCharacter;
		private string _quoteSuffixCharacter;

		private DBSqlParserColumnCollection		_columns;
		private DBSqlParserTableCollection		_tables;


		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Constructor 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		public DBSqlParser(
				string quotePrefixCharacter,
				string quoteSuffixCharacter,
				string regexPattern
				)
		{
			_quotePrefixCharacter = quotePrefixCharacter;
			_quoteSuffixCharacter = quoteSuffixCharacter;
			_sqlTokenPattern = regexPattern;
		}

		static internal string CreateRegexPattern(
				string validIdentifierFirstCharacters,
				string validIdendifierCharacters,
				string quotePrefixCharacter,
				string quotedIdentifierCharacters,
				string quoteSuffixCharacter,
				string stringPattern
				)
		{
			// Combine the regex patterns from the user and the framework that we
			// will require, and will return the actual regex pattern string to
			// be handed to the class constructor.
			StringBuilder sb = new StringBuilder();

			sb.Append(SqlTokenPattern_Part1);
			sb.Append(validIdentifierFirstCharacters);
			sb.Append(validIdendifierCharacters);
			sb.Append(SqlTokenPattern_Part2);
			sb.Append(quotePrefixCharacter);
			sb.Append(SqlTokenPattern_Part3);
			sb.Append(quotedIdentifierCharacters);
			sb.Append(SqlTokenPattern_Part4);
			sb.Append(quoteSuffixCharacter);
			sb.Append(SqlTokenPattern_Part5);
			sb.Append(stringPattern);
			sb.Append(SqlTokenPattern_Part6);

			string result = sb.ToString();
			return result;
		}

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		internal DBSqlParserColumnCollection Columns
		{
			get 
			{
				if (null == _columns)
				{
					_columns = new DBSqlParserColumnCollection();
				}
				return _columns;
			}
		}

		virtual protected string QuotePrefixCharacter
		{
			get { return _quotePrefixCharacter; }
		}

		virtual protected string QuoteSuffixCharacter
		{
			get { return _quoteSuffixCharacter; }
		}

		static private Regex SqlTokenParser 
		{
			get 
			{
				Regex parser = _sqlTokenParser;

				if (null == parser) 
					parser = GetSqlTokenParser();

				return parser;
			}
		}

		internal DBSqlParserTableCollection Tables
		{
			get 
			{
				if (null == _tables)
				{
					_tables = new DBSqlParserTableCollection();
				}
				return _tables;
			}
		}
		

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////		

		private void AddColumn(
			int 		maxPart,
			Token[]		namePart,
			Token		aliasName
			)
		{
			Columns.Add(
					GetPart(0, namePart, maxPart),
					GetPart(1, namePart, maxPart),
					GetPart(2, namePart, maxPart),
					GetPart(3, namePart, maxPart),
					GetTokenAsString(aliasName)
					);
		}

		private void AddTable(
			int 		maxPart,
			Token[]		namePart,
			Token		correlationName
			)
		{
			Tables.Add(
					GetPart(1, namePart, maxPart),
					GetPart(2, namePart, maxPart),
					GetPart(3, namePart, maxPart),
					GetTokenAsString(correlationName)
					);
		}
				
		private void CompleteSchemaInformation()
		{
			DBSqlParserColumnCollection	columns = Columns;
			DBSqlParserTableCollection	tables  = Tables;

			int columnCount = columns.Count;
			int tableCount	= tables.Count;
			
			// First, derive all of the information we can about each table
			for (int i = 0; i < tableCount; i++)
			{
				DBSqlParserTable			table = tables[i];
				DBSqlParserColumnCollection tableColumns = GatherTableColumns(table);
				table.Columns = tableColumns;
			}

			// Next, derive all of the column information we can.
			for (int i = 0; i < columnCount; i++)
			{
				DBSqlParserColumn 	column = columns[i];
				DBSqlParserTable	table = FindTableForColumn(column);
				
				if ( !column.IsExpression )
				{
					// If this is a '*' column, then we have to expand the '*' into 
					// its component parts.
					if ("*" == column.ColumnName)
					{
						// Remove the existing "*" column entry and replace it with the 
						// complete list of columns in the table.
						columns.RemoveAt(i);
							
						// If this is a tablename.* column, then add references to the 
						// all columns in the specified table, otherwise add references
						// to all columns in all tables.
						if (String.Empty != column.TableName)
						{
							DBSqlParserColumnCollection tableColumns = table.Columns;
							int							tableColumnCount = tableColumns.Count;

							for (int j=0; j < tableColumnCount; ++j) 
							{
								columns.Insert(i+j, tableColumns[j]);
							}
							columnCount += tableColumnCount - 1;	// don't forget to adjust our loop end
							i			+= tableColumnCount - 1;
						}
						else
						{
							for (int k = 0; k < tableCount; k++)
							{
								table = tables[k];
								
								DBSqlParserColumnCollection tableColumns = table.Columns;
								int							tableColumnCount = tableColumns.Count;

								for (int j=0; j < tableColumnCount; ++j) 
								{
									columns.Insert(i+j, tableColumns[j]);
								}
								columnCount += tableColumnCount - 1;	// don't forget to adjust our loop end
								i			+= tableColumnCount;
							}
						}
					}
					else
					{
						// if this isn't a '*' column, we find the table that the column belongs
						// to, and ask it's column collection for the completed column info (that
						// contains information about key values, etc.)
						DBSqlParserColumn	completedColumn = FindCompletedColumn(table, column);

						if (null != completedColumn) // MDAC 87152
							column.CopySchemaInfoFrom(completedColumn);
						else
							column.CopySchemaInfoFrom(table);
					}
				}
			}

			// Finally, derive the key column information for each table
			for (int i = 0; i < tableCount; i++)
			{
				DBSqlParserTable table = tables[i];
				GatherKeyColumns(table);
			}
		}

		protected DBSqlParserColumn FindCompletedColumn(
			DBSqlParserTable	table,
			DBSqlParserColumn	searchColumn
			)
		{
			DBSqlParserColumnCollection	columns = table.Columns;
			int							columnsCount = columns.Count;

			for (int i = 0; i < columnsCount; ++i)
			{
				DBSqlParserColumn	column = columns[i];

				// Compare each part of the name (if they exist) with the
				// table and pick the one that matches all the parts that exist.
				if (CatalogMatch(column.ColumnName, searchColumn.ColumnName))
					return column;
			}

			// MDAC 87152: ROWID and ROWNUM shouldn't fire an assert here:
			//Debug.Assert(false, "Why didn't we find a match for the search column?");
			return null;
		}
				
		internal DBSqlParserTable FindTableForColumn(
			DBSqlParserColumn column
			)
		{
			DBSqlParserTableCollection	tables = Tables;
			int							tableCount = tables.Count;

			for (int i = 0; i < tableCount; ++i)
			{
				DBSqlParserTable table = tables[i];

				// if the table name matches the correlation name, then we're certain
				// of a match
				if (string.Empty == column.DatabaseName
				 && string.Empty == column.SchemaName
				 && CatalogMatch(column.TableName, table.CorrelationName))
					return table;

				// otherwise, compare each part of the name (if they exist) with the
				// table and pick the one that matches all the parts that exist.
				if ((string.Empty == column.DatabaseName || CatalogMatch(column.DatabaseName, table.DatabaseName))
				 && (string.Empty == column.SchemaName   || CatalogMatch(column.SchemaName,   table.SchemaName))
				 && (string.Empty == column.TableName    || CatalogMatch(column.TableName, 	  table.TableName)) )
					return table;
			}

			Debug.Assert(false, "Why didn't we find a match for the column?");
			return null;
		}
				
		private string GetPart(
			int			part,
			Token[]		namePart,
			int 		maxPart
			)
		{
			int partBase = (maxPart - namePart.Length) + part + 1;

			if (0 > partBase)
				return null;

			return GetTokenAsString(namePart[partBase]);
		}
		
		static private Regex GetSqlTokenParser() 
		{
			Regex parser;

			lock(typeof(DBSqlParser)) 
			{
				parser = _sqlTokenParser;
				if (null == parser) 
				{
					// due to workingset size issues ~1.5MB, don't use RegexOptions.Compiled
					// using System.Data.RegularExpressions.dll saves an additional 50K

					_sqlTokenParser = new Regex(_sqlTokenPattern, RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase);
					_identifierGroup		= _sqlTokenParser.GroupNumberFromName("identifier");
					_quotedidentifierGroup	= _sqlTokenParser.GroupNumberFromName("quotedidentifier");
					_keywordGroup			= _sqlTokenParser.GroupNumberFromName("keyword");
					_stringGroup			= _sqlTokenParser.GroupNumberFromName("string");
					_otherGroup				= _sqlTokenParser.GroupNumberFromName("other");
					parser = _sqlTokenParser;
				}
			}
			return parser;
		}
		
		private string GetTokenAsString(
			Token		token
			)
		{
			if (TokenType.QuotedIdentifier == token.Type) 
				return _quotePrefixCharacter + token.Value + _quoteSuffixCharacter;

			return token.Value;
		}
		
		// transistion states used for parsing
		private enum PARSERSTATE
		{
			NOTHINGYET=1,	//start point
			SELECT,			
			COLUMN,
			COLUMNALIAS,
			TABLE,
			TABLEALIAS,
			FROM,
			EXPRESSION,
			DONE,
		};
	
		public void Parse(
			string 	statementText
			)
		{
			Parse2(statementText);
			CompleteSchemaInformation();
		}
		
		private void Parse2(
			string 	statementText
			)
		{
//			Debug.WriteLine(statementText);

			PARSERSTATE		parserState = PARSERSTATE.NOTHINGYET;

			Token[]			namePart = new Token[4];
			int				currentPart = 0;

			Token			alias = Token.Null;
			
			TokenType		lastTokenType = TokenType.Null;

			int				parenLevel = 0;
//			bool			distinctFound;

			_columns = null;
			_tables = null;

			Match match = SqlTokenParser.Match(statementText);
			Token token = TokenFromMatch(match);

			while (true) 
			{
//				Debug.WriteLine(String.Format("{0,-15} {1,-17} {2} {3}", parserState, token.Type.ToString(), parenLevel, token.Value));

				switch(parserState)
				{
					case PARSERSTATE.DONE:
						return;

					case PARSERSTATE.NOTHINGYET:
						switch (token.Type)
						{
							case TokenType.Keyword_SELECT:
								parserState = PARSERSTATE.SELECT;
								break;

							default:
								Debug.Assert (false, "no state defined!!!!we should never be here!!!");
								throw ADP.InvalidOperation(Res.GetString(Res.ADP_SQLParserInternalError));
 						}
						break;

					case PARSERSTATE.SELECT:
						switch (token.Type)
						{
							case TokenType.Identifier:
							case TokenType.QuotedIdentifier:
								parserState = PARSERSTATE.COLUMN;
								currentPart = 0;
								namePart[0] = token;
								break;

							case TokenType.Keyword_FROM:
								parserState = PARSERSTATE.FROM;
								break;

							case TokenType.Other_Star:
								parserState = PARSERSTATE.COLUMNALIAS;
								currentPart = 0;
								namePart[0] = token;
								break;

							case TokenType.Keyword_DISTINCT:
//								distinctFound = true;
								break;
								
							case TokenType.Keyword_ALL:
								break;
								
							case TokenType.Other_LeftParen:
								parserState = PARSERSTATE.EXPRESSION;
								parenLevel++; 
								break;

							case TokenType.Other_RightParen:
								throw ADP.SyntaxErrorMissingParenthesis();

							default:
								parserState = PARSERSTATE.EXPRESSION;
								break;
						}
						break;

					case PARSERSTATE.COLUMN:
						switch (token.Type)
						{
							case TokenType.Identifier:
							case TokenType.QuotedIdentifier:
								if (TokenType.Other_Period != lastTokenType)
								{
									parserState = PARSERSTATE.COLUMNALIAS;
									alias = token;
								}
								else
								{
									namePart[++currentPart] = token;
								}
								break;
								
							case TokenType.Other_Period:
								if (currentPart > 3)
									throw ADP.SyntaxErrorTooManyNameParts();
								
								break;

							case TokenType.Other_Star:
								parserState = PARSERSTATE.COLUMNALIAS;
								namePart[++currentPart] = token;
								break;

							case TokenType.Keyword_AS:
								break;

							case TokenType.Keyword_FROM:
							case TokenType.Other_Comma:
								parserState = (token.Type == TokenType.Keyword_FROM) ? PARSERSTATE.FROM : PARSERSTATE.SELECT;
								AddColumn(currentPart, namePart, alias);
								currentPart = -1;
								alias = Token.Null;
								break;

							case TokenType.Other_LeftParen:
								parserState = PARSERSTATE.EXPRESSION;
								parenLevel++; 
								currentPart = -1;
								break;

							case TokenType.Other_RightParen:
								throw ADP.SyntaxErrorMissingParenthesis();

							default:
								parserState = PARSERSTATE.EXPRESSION;
								currentPart = -1;
								break;
						}
						break;

					case PARSERSTATE.COLUMNALIAS:
						switch (token.Type)
						{
							case TokenType.Keyword_FROM:
							case TokenType.Other_Comma:
								parserState = (token.Type == TokenType.Keyword_FROM) ? PARSERSTATE.FROM : PARSERSTATE.SELECT;
								AddColumn(currentPart, namePart, alias);
								currentPart = -1;
								alias = Token.Null;
								break;

							default:
								throw ADP.SyntaxErrorExpectedCommaAfterColumn();
						}
						break;

					case PARSERSTATE.EXPRESSION:
						switch (token.Type)
						{
							case TokenType.Identifier:
							case TokenType.QuotedIdentifier:
								if (0 == parenLevel)
								{
									alias = token;
								}
								break;

							case TokenType.Keyword_FROM:
							case TokenType.Other_Comma:
								if (0 == parenLevel)
								{
									parserState = (token.Type == TokenType.Keyword_FROM) ? PARSERSTATE.FROM : PARSERSTATE.SELECT;
									AddColumn(currentPart, namePart, alias);
									currentPart = -1;
									alias = Token.Null;
								}
								else
								{
									if (token.Type == TokenType.Keyword_FROM)
										throw ADP.SyntaxErrorUnexpectedFrom();
								}
								break;

							case TokenType.Other_LeftParen:
								parenLevel++; 
								break;

							case TokenType.Other_RightParen:
								parenLevel--; 
								break;
						}
						break;

					case PARSERSTATE.FROM:
						switch (token.Type)
						{
							case TokenType.Identifier:
							case TokenType.QuotedIdentifier:
								parserState = PARSERSTATE.TABLE;
								currentPart = 0;
								namePart[0] = token;
								break;

							default:
								throw ADP.SyntaxErrorExpectedIdentifier();
						}
						break;

					case PARSERSTATE.TABLE:
						switch (token.Type)
						{
							case TokenType.Identifier:
							case TokenType.QuotedIdentifier:
								if (TokenType.Other_Period != lastTokenType)
								{
									parserState = PARSERSTATE.TABLEALIAS;
									alias = token;
								}
								else
								{
									namePart[++currentPart] = token;
								}
								break;
								
							case TokenType.Other_Period:
								if (currentPart > 2)
									throw ADP.SyntaxErrorTooManyNameParts();
								
								break;

							case TokenType.Keyword_AS:
								break;

							case TokenType.Keyword_COMPUTE:
							case TokenType.Keyword_FOR:
							case TokenType.Keyword_GROUP:
							case TokenType.Keyword_HAVING:
							case TokenType.Keyword_INTERSECT:
							case TokenType.Keyword_MINUS:
							case TokenType.Keyword_ORDER:
							case TokenType.Keyword_UNION:
							case TokenType.Keyword_WHERE:
							case TokenType.Null:
								
							case TokenType.Other_Comma:
								parserState = (TokenType.Other_Comma == token.Type) ? PARSERSTATE.FROM : PARSERSTATE.DONE;
								AddTable(currentPart, namePart, alias);
								currentPart = -1;
								alias = Token.Null;
								break;

							default:
								throw ADP.SyntaxErrorExpectedNextPart();
 						}
						break;

					case PARSERSTATE.TABLEALIAS:
						switch (token.Type)
						{
							case TokenType.Keyword_COMPUTE:
							case TokenType.Keyword_FOR:
							case TokenType.Keyword_GROUP:
							case TokenType.Keyword_HAVING:
							case TokenType.Keyword_INTERSECT:
							case TokenType.Keyword_MINUS:
							case TokenType.Keyword_ORDER:
							c