ly way that is:
			 *	(a) Supported by the underlying interface
			 *	(b) Does not require access to any other interface
			 *	(c) Does not affect the current enumeration position
			 */
	
			SAFEARRAY	*pArray = NULL;

			if (WBEM_S_NO_ERROR == m_pIWbemContext->GetNames (0, &pArray))
			{
				long lUBound = 0, lLBound = 0;
				SafeArrayGetUBound (pArray, 1, &lUBound);
				SafeArrayGetLBound (pArray, 1, &lLBound);
				*plCount = lUBound - lLBound + 1;
				SafeArrayDestroy (pArray);
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemNamedValueSet::GetIWbemContext
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemNamedValueSet
//	interface, return the underlying IWbemContext interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemContext interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************


/* 
 * THIS FUNCTION NEEDS FIXING
 * Currently this function returns the context from the service provider
 * obtained from the host, if there is one.  If there isn't one then it uses
 * the one passed in from the user.  The correct behaviour is to _add_ the 
 * context from the user to the one provided by the service provider if there
 * is one, if not just use the one from the user
 */
IWbemContext	*CSWbemNamedValueSet::GetIWbemContext (
	IDispatch *pDispatch,
	IServiceProvider *pServiceProvider
)
{
	_RD(static char *me = "CSWbemNamedValueSet::GetIWbemContext";)
	IWbemContext *pContext = NULL;
	ISWbemInternalContext *pIContext = NULL;

	_RPrint(me, "Called", 0, "");
	if (pServiceProvider) {
		if (FAILED(pServiceProvider->QueryService(IID_IWbemContext, 
										IID_IWbemContext, (LPVOID *)&pContext))) {
			_RPrint(me, "Failed to get context from services", 0, "");
			pContext = NULL;
		} else {
			_RPrint(me, "Got context from services", 0, "");
			;
		}
	}

	if (pDispatch && !pContext)
	{
		if (SUCCEEDED (pDispatch->QueryInterface 
								(IID_ISWbemInternalContext, (PPVOID) &pIContext)))
		{
			pIContext->GetIWbemContext (&pContext);
			pIContext->Release ();
		}
	}

	return pContext;
}

/*
 * Call GetIWbemContext to get the service context if there is one. 
 * Then wrap the result with an SWbemContext and return
 */
IDispatch *CSWbemNamedValueSet::GetSWbemContext(IDispatch *pDispatch, 
									IServiceProvider *pServiceProvider, CSWbemServices *pServices)
{
	_RD(static char *me = "CSWbemNamedValueSet::GetSWbemContext";)
	IDispatch *pDispatchOut = NULL;

	IWbemContext *pContext = GetIWbemContext(pDispatch, pServiceProvider);

	if (pContext) {

		CSWbemNamedValueSet *pCSWbemNamedValueSet = new CSWbemNamedValueSet(pServices, pContext);

		if (pCSWbemNamedValueSet)
		{
			if (FAILED(pCSWbemNamedValueSet->QueryInterface 
									(IID_IDispatch, (PPVOID) &pDispatchOut))) {
				delete pCSWbemNamedValueSet;
				pDispatchOut = NULL;
			}
		}

		pContext->Release();
	}

	_RPrint(me, "Returning with context: ", (long)pDispatchOut, "");

	return pDispatchOut;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::CContextDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::CContextDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a named value (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemNamedValueSet *pContext = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemNamedValueSet, (PPVOID) &pContext)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);

			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);

				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemNamedValue *pNamedValue = NULL;

						if (SUCCEEDED (pContext->Item (V_BSTR(&nameVar), 0, &pNamedValue)))
						{
							// Try and put the value
							if (SUCCEEDED (pNamedValue->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pNamedValue->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pContext->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\classfac.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Genral purpose include file.
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemFactory
//
//  DESCRIPTION:
//
//  Class factory for the CSWbemLocator and CSWbemNamedValueBag classes.
//
//***************************************************************************

class CSWbemFactory : public IClassFactory
{
protected:
	long			m_cRef;
	int				m_iType;

public:

    CSWbemFactory(int iType);
    ~CSWbemFactory(void);
    
	enum {LOCATOR, CONTEXT, OBJECTPATH, PARSEDN, LASTERROR, SINK, DATETIME,
			REFRESHER};

    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\classfac.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains the class factory.
//
//***************************************************************************

#include "precomp.h"

extern CWbemErrorCache *g_pErrorCache;
extern CRITICAL_SECTION g_csErrorCache;

//***************************************************************************
//
// CSWbemFactory::CSWbemFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CSWbemFactory::CSWbemFactory(int iType)
{
    m_cRef=0L;
	m_iType = iType;
	return;
}

//***************************************************************************
//
// CSWbemFactory::~CSWbemFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CSWbemFactory::~CSWbemFactory(void)
{
	return;
}

//***************************************************************************
//
// CSWbemFactory::QueryInterface
// CSWbemFactory::AddRef
// CSWbemFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CSWbemFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemFactory::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CSWbemFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSWbemFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj = NULL;
    HRESULT      hr = E_FAIL;

	// A good place to ensure everything is initialized OK
	EnsureGlobalsInitialized () ;

    *ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

	if (m_iType == LOCATOR)
	    pObj = (ISWbemLocator *) new CSWbemLocator;
	else if (m_iType == SINK)
	{
		CSWbemSink *pSWbemSink = new CSWbemSink;

		if(pSWbemSink == NULL)
			return E_OUTOFMEMORY;

		// QueryInterface probably for IID_IUNKNOWN
		return pSWbemSink->QueryInterface(riid, ppvObj);

	}
	else if (m_iType == CONTEXT)
		pObj = (ISWbemNamedValueSet *) new CSWbemNamedValueSet;
	else if (m_iType == OBJECTPATH)
		pObj = (ISWbemObjectPath *) new CSWbemObjectPath;
	else if (m_iType == PARSEDN)
		pObj = new CWbemParseDN;
	else if (m_iType == DATETIME)
		pObj = (ISWbemDateTime *) new CSWbemDateTime;
	else if (m_iType == REFRESHER)
		pObj = (ISWbemRefresher *) new CSWbemRefresher;
	else if (m_iType == LASTERROR)
	{
		EnterCriticalSection (&g_csErrorCache);

		if (g_pErrorCache)
			pObj = (ISWbemObject* ) g_pErrorCache->GetAndResetCurrentThreadError ();

		LeaveCriticalSection (&g_csErrorCache);
	}
	
    if (NULL == pObj)
        return hr;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CSWbemFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CSWbemFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\asyncobj.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJECT.CPP
//
//  rogerbo  19-June-98   Created.
//
//  Defines the async implementation of ISWbemObjectEx
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

HRESULT STDMETHODCALLTYPE CSWbemObject::PutAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		if (pAsyncNotify)
		{
			// Figure out whether this is a class or instance
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{

				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);
				IWbemServices	*pIService = m_pSWbemServices->GetIWbemServices ();

				if (WBEM_GENUS_CLASS  == var.lVal)
				{
					// Save the class name for later
					VARIANT nameVar;
					VariantInit (&nameVar);

					/*
					 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
					 * the __CLASS property has not yet been set.
					 */
					if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
						&& (VT_BSTR == V_VT(&nameVar)))
					{

						if (pIService)
						{
							// Create the sink
							CWbemObjectSink *pWbemObjectSink;
							IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
										m_pSWbemServices, pAsyncNotify, pAsyncContext, true, nameVar.bstrVal);
							if (pSink)
							{
								CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

								if (pSecurity)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;
					
									if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIService->PutClassAsync (m_pIWbemClassObject, iFlags, 
																					pIContext, pSink);

									// Check to see if we need to release the stub (either we failed locally
									// or via a re-entrant call to SetStatus
									pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
							
									if (needToResetSecurity)
										pSecurity->ResetSecurity (hThreadToken);

									pSecurity->Release ();
								}
							}
						}
					}

					VariantClear (&nameVar);
				}
				else
				{

					if (pIService)
					{
						// Create the sink
						CWbemObjectSink *pWbemObjectSink;
						IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
													m_pSWbemServices, pAsyncNotify, pAsyncContext, true);
						if (pSink)
						{
							CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

							if (pSecurity)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
									hr = pIService->PutInstanceAsync (m_pIWbemClassObject, iFlags, pIContext, pSink);

								// Check to see if we need to release the stub (either we failed locally
								// or via a re-entrant call to SetStatus
								pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
						
								// Restore original privileges on this thread
								if (needToResetSecurity)
									pSecurity->ResetSecurity (hThreadToken);
							
								pSecurity->Release ();
							}
						}
					}
				}


				SetWbemError (m_pSWbemServices);

				if (pIService)
					pIService->Release ();

				if (pIContext)
					pIContext->Release ();
			}

			VariantClear (&var);
		} else
			hr = wbemErrInvalidParameter;
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			// Get the object path to pass to the IWbemServices call
			CComBSTR bsPath;
			
			if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
				hr = m_pSWbemServices->DeleteAsync (pAsyncNotify, bsPath, iFlags, 
									objContext, pAsyncContext);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::InstancesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->InstancesOfAsync (pAsyncNotify, bsPath, 
								iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::SubclassesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->SubclassesOfAsync (pAsyncNotify, bsPath, iFlags, 
								objContext,	pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::AssociatorsAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strAssocClass,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strResultRole,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->AssociatorsOfAsync (pAsyncNotify, bsPath, strAssocClass, strResultClass,
						strResultRole, strRole, bClassesOnly, bSchemaOnly, 
						strRequiredAssocQualifier, strRequiredQualifier, iFlags, 
						objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::ReferencesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ReferencesToAsync (pAsyncNotify, bsPath, 
						strResultClass,	strRole, bClassesOnly, bSchemaOnly, 
						strRequiredQualifier, iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::ExecMethodAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strMethodName,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ExecMethodAsync (pAsyncNotify, bsPath, strMethodName,
							objInParams, iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\asynserv.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SERVICES.CPP
//
//  rogerbo  26-May-98   Created.
//
//  Defines the implementation of ISWbemServicesEx
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"


//***************************************************************************
//
//  SCODE CSWbemServices::ExecQueryAsync
//
//  DESCRIPTION:
//
//  Execute an asynchronous query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		pAsyncNotify		The notification sink
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		pAsyncContext		asynchronous context information
//		ppEnum				Returns the sink
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecQueryAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR Query,
	/* [defaultvalue][optional][in] */ BSTR QueryLanguage,
	/* [defaultvalue][optional][in] */ long lFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(QueryLanguage, Query, 
							lFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext, 
							pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
				
				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetAsync
(
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->GetObjectAsync (
						(strObjectPath && (0 < wcslen(strObjectPath))) ? strObjectPath : NULL, 
						iFlags, 
						pIContext,
						pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		CComPtr<IWbemServices> pIWbemServices = GetIWbemServices ();

		if (pIWbemServices)
		{
			CWbemPathCracker pathCracker (strObjectPath);

			if ((pathCracker.GetType () != CWbemPathCracker::WbemPathType::wbemPathTypeError) &&
				pathCracker.IsClassOrInstance ())
			{
				// Create the sink
				CWbemObjectSink *pWbemObjectSink;
				IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
				if (pSink)
				{
					// Get the context
					IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																				m_pIServiceProvider);

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;
				
					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (pathCracker.IsInstance ())
							hr = pIWbemServices->DeleteInstanceAsync (strObjectPath, iFlags, pIContext, pSink);
						else
							hr = pIWbemServices->DeleteClassAsync (strObjectPath, iFlags, pIContext, pSink);
					}
						
					// Check to see if we need to release the stub (either we failed locally
					// or via a re-entrant call to SetStatus
					pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

					// Restore original privileges on this thread
					if (needToResetSecurity)
						m_SecurityInfo->ResetSecurity (hThreadToken);

					SetWbemError (this);
					
					if (pIContext)
						pIContext->Release ();
				} else
					hr = wbemErrInvalidParameter;
			}
			else
				hr = wbemErrInvalidParameter;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::InstancesOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strClass,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->CreateInstanceEnumAsync 
									(strClass, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::SubclassesOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strSuperclass,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->CreateClassEnumAsync 
							(strSuperclass, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::AssociatorsOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ BSTR strAssocClass,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strResultRole,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == strObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				// Format the query string
				BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));

				BSTR bsQuery = FormatAssociatorsQuery (strObjectPath, strAssocClass, strResultClass, strResultRole,
								strRole, bClassesOnly, bSchemaOnly, strRequiredAssocQualifier, strRequiredQualifier);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(bsQueryLanguage, bsQuery, 
							iFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext, 
							pSink); 

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				SysFreeString (bsQuery);
				SysFreeString (bsQueryLanguage);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ReferencesToAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == strObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				// Format the query string
				CComBSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
				CComBSTR bsQuery = FormatReferencesQuery (strObjectPath, strResultClass, strRole,
								bClassesOnly, bSchemaOnly, strRequiredQualifier);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(bsQueryLanguage, bsQuery, 
							iFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext,
							pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecNotificationQueryAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR Query,
	/* [defaultvalue][optional][in] */ BSTR strQueryLanguage,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecNotificationQueryAsync 
							(strQueryLanguage, Query, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecMethodAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [in] */ BSTR strMethodName,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{

				IWbemClassObject *pIInParams = CSWbemObject::GetIWbemClassObject (objInParams);

				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecMethodAsync 
							(strObjectPath, strMethodName, iFlags, pIContext, pIInParams, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			
				if (pIInParams)
					pIInParams->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::PutAsync
( 
	/* [in] */ ISWbemSink *pAsyncNotify,
	/* [in] */ ISWbemObjectEx *objObject,
    /* [in] */ long iFlags,
	/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objContext,
	/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			if (pAsyncNotify)
			{
				IWbemClassObject *pWbemClassObject = CSWbemObject::GetIWbemClassObject (objObject);

				if (pWbemClassObject)
				{
					// Figure out whether this is a class or instance
					VARIANT var;
					VariantInit (&var);

					if (WBEM_S_NO_ERROR == pWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
					{

						IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																					m_pIServiceProvider);
						if (WBEM_GENUS_CLASS  == var.lVal)
						{
							// Save the class name for later
							VARIANT nameVar;
							VariantInit (&nameVar);

							/*
							 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
							 * the __CLASS property has not yet been set.
							 */
							if ((WBEM_S_NO_ERROR == pWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
								&& (VT_BSTR == V_VT(&nameVar)))
							{
								// Create the sink
								CWbemObjectSink *pWbemObjectSink;
								IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
											this, pAsyncNotify, pAsyncContext, true, nameVar.bstrVal);
								if (pSink)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;
					
									if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIWbemServices->PutClassAsync (pWbemClassObject, iFlags, 
																					pIContext, pSink);

									// Check to see if we need to release the stub (either we failed locally
									// or via a re-entrant call to SetStatus
									pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
							
									if (needToResetSecurity)
										m_SecurityInfo->ResetSecurity (hThreadToken);
								}
							}

							VariantClear (&nameVar);
						}
						else
						{
							// Create the sink
							CWbemObjectSink *pWbemObjectSink;
							IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext, true);
							if (pSink)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
									hr = pIWbemServices->PutInstanceAsync (pWbemClassObject, iFlags, pIContext, pSink);

								// Check to see if we need to release the stub (either we failed locally
								// or via a re-entrant call to SetStatus
								pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
						
								// Restore original privileges on this thread
								if (needToResetSecurity)
										m_SecurityInfo->ResetSecurity (hThreadToken);
							}
						}

						SetWbemError (this);

						if (pIContext)
							pIContext->Release ();
					}

					pWbemClassObject->Release ();
					VariantClear (&var);
				}
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT CSWbemServices::CancelAsyncCall(IWbemObjectSink *pSink)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CancelAsyncCall(pSink); 

			pIWbemServices->Release ();

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);
		}
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\contvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  CONTVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT for iterators over 
//	ISWbemNamedValueSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CContextEnumVar::CContextEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CContextEnumVar::CContextEnumVar(CSWbemNamedValueSet *pContext, ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pContext = pContext;
	m_pContext->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CContextEnumVar::~CContextEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CContextEnumVar::~CContextEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pContext)
		m_pContext->Release ();
}

//***************************************************************************
// HRESULT CContextEnumVar::QueryInterface
// long CContextEnumVar::AddRef
// long CContextEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CContextEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CContextEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CContextEnumVar::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pContext)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					ISWbemNamedValue *pObject = NULL;
					
					if (SUCCEEDED(m_pContext->Next (0, &pObject)))
					{
						if (NULL == pObject)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pObject;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pContext)
		{
			CContextEnumVar *pEnum = new CContextEnumVar (m_pContext, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CContextEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pContext->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CContextEnumVar::SeekCurrentPosition ()
{
	ISWbemNamedValue *pDummyObject = NULL;
	m_pContext->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pContext->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include "precomp.h"

#ifdef UTILLIB
#include <assertbreak.h>
#else
#define ASSERT_BREAK(a)
#endif //UTILLIB

#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft);

//***************************************************************************
//
//  CSWbemDateTime::CSWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemDateTime::CSWbemDateTime() :
		m_dwSafetyOptions (INTERFACESAFE_FOR_UNTRUSTED_DATA|
						   INTERFACESAFE_FOR_UNTRUSTED_CALLER),
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0),
		m_dw100nsOverflow (0)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemDateTime, 
						CLSID_SWbemDateTime, L"SWbemDateTime");
    m_cRef=0;
}

//***************************************************************************
//
//  CSWbemDateTime::~CSWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemDateTime::~CSWbemDateTime(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemDateTime::QueryInterface
// long CSWbemDateTime::AddRef
// long CSWbemDateTime::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemDateTime::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemDateTime==riid)
		*ppv = (ISWbemDateTime *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemDateTime::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemDateTime::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::get_Value( 
        OUT BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			swprintf (dmtfValue, L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				swprintf (dmtfValue, L"%04d", m_iYear);
			else
				wcscpy (dmtfValue, WILD4);

			if (m_bMonthSpecified)
				swprintf (dmtfValue + 4, L"%02d", m_iMonth);
			else
				wcscat (dmtfValue + 4, WILD2);

			if (m_bDaySpecified)
				swprintf (dmtfValue + 6, L"%02d", m_iDay);
			else
				wcscat (dmtfValue + 6, WILD2);

			if (m_bHoursSpecified)
				swprintf (dmtfValue + 8, L"%02d", m_iHours);
			else
				wcscat (dmtfValue + 8, WILD2);

			if (m_bMinutesSpecified)
				swprintf (dmtfValue + 10, L"%02d", m_iMinutes);
			else
				wcscat (dmtfValue + 10, WILD2);

			if (m_bSecondsSpecified)
				swprintf (dmtfValue + 12, L"%02d.", m_iSeconds);
			else
			{
				wcscat (dmtfValue + 12, WILD2);
				wcscat (dmtfValue + 14, L".");
			}

			if (m_bMicrosecondsSpecified)
				swprintf (dmtfValue + 15, L"%06d", m_iMicroseconds);
			else
				wcscat (dmtfValue + 15, WILD6);

			if (m_bUTCSpecified)
				swprintf (dmtfValue + 21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				wcscat (dmtfValue + 21, L"+");
				wcscat (dmtfValue + 22, WILD3);
			}
		}

		*pbsValue = SysAllocString (dmtfValue);
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;

}


//***************************************************************************
//
//  SCODE CSWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::put_Value( 
        IN BSTR bsValue) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			m_dw100nsOverflow = 0;
			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CSWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (int i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [9];
			
			wcsncpy (temp, pValue, len);
			temp [len] = NULL;
			iValue = wcstol (temp, &dummy, 10);
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CSWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}


//***************************************************************************
//
//  SCODE CSWbemDateTime::GetVarDate
//
//  DESCRIPTION:
//
//  Retrieve the value in Variant form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pVarDate		holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::GetVarDate( 
        IN VARIANT_BOOL bIsLocal,
		OUT DATE *pVarDate) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();
	
	if (NULL == pVarDate)
		hr = wbemErrInvalidParameter;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = wbemErrFailed;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = m_iYear;
			sysTime.wMonth = m_iMonth;
			sysTime.wDay = m_iDay;
			sysTime.wHour = m_iHours;
			sysTime.wMinute = m_iMinutes;
			sysTime.wSecond = m_iSeconds;
			sysTime.wMilliseconds = m_iMicroseconds/1000;
				
			if (VARIANT_TRUE == bIsLocal)
			{
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.

				// Coerce the time to GMT first
				WBEMTime wbemTime (sysTime);
				
				if (!wbemTime.GetDMTF (sysTime))
					return wbemErrInvalidSyntax;
			}

			double dVarDate;

			if (SystemTimeToVariantTime (&sysTime, &dVarDate))
			{
				*pVarDate = dVarDate;
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
    
//***************************************************************************
//
//  SCODE CSWbemDateTime::GetFileTime
//
//  DESCRIPTION:
//
//  Retrieve the value in FILETIME form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pbsFileTime	holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::GetFileTime( 
        IN VARIANT_BOOL bIsLocal,
		OUT BSTR *pbsFileTime) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();
	
	if (NULL == pbsFileTime)
		hr = wbemErrInvalidParameter;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = wbemErrFailed;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = m_iYear;
			sysTime.wMonth = m_iMonth;
			sysTime.wDay = m_iDay;
			sysTime.wHour = m_iHours;
			sysTime.wMinute = m_iMinutes;
			sysTime.wSecond = m_iSeconds;
			sysTime.wMilliseconds = m_iMicroseconds/1000;
				
			if (VARIANT_TRUE == bIsLocal)
			{
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.

				// Coerce the time to GMT first
				WBEMTime wbemTime (sysTime);
				
				if (!wbemTime.GetDMTF (sysTime))
					return wbemErrInvalidSyntax;
			}

			FILETIME fileTime;

			if (SystemTimeToFileTime (&sysTime, &fileTime))
			{
				wchar_t wcBuf [30];
				unsigned __int64 ui64 = fileTime.dwHighDateTime;
				ui64 = ui64 << 32;
				ui64 += fileTime.dwLowDateTime;

				/*
				 * In converting to SYSTEMTIME we lost sub-millisecond
				 * precision from our DMTF value, so let's add it back,
				 * remembering that FILETIME is in 10ns units.
				 */
				ui64 += ((m_iMicroseconds % 1000) * 10);

				// Finally add the LSB
				ui64 += m_dw100nsOverflow;

				_ui64tow (ui64, wcBuf, 10);

				*pbsFileTime = SysAllocString (wcBuf);
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	SYSTEMTIME	sysTime;
	
	if (TRUE == VariantTimeToSystemTime (dVarDate, &sysTime))
	{
		long offset = 0;

		if (VARIANT_TRUE == bIsLocal)
		{
			WBEMTime wbemTime (sysTime);
			if (!wbemTime.GetDMTF (sysTime, offset))
				return wbemErrInvalidSyntax;
		}

		m_iYear = sysTime.wYear;
		m_iMonth = sysTime.wMonth;
		m_iDay = sysTime.wDay;
		m_iHours = sysTime.wHour;
		m_iMinutes = sysTime.wMinute;
		m_iSeconds = sysTime.wSecond;
		m_iMicroseconds = sysTime.wMilliseconds * 1000;
		m_iUTC = offset;
		m_dw100nsOverflow = 0;

		m_bYearSpecified = VARIANT_TRUE,	
		m_bMonthSpecified = VARIANT_TRUE, 
		m_bDaySpecified = VARIANT_TRUE, 
		m_bHoursSpecified = VARIANT_TRUE, 
		m_bMinutesSpecified = VARIANT_TRUE, 
		m_bSecondsSpecified = VARIANT_TRUE, 
		m_bMicrosecondsSpecified = VARIANT_TRUE, 
		m_bUTCSpecified = VARIANT_TRUE, 
		m_bIsInterval = VARIANT_FALSE;			

		hr = S_OK;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::SetFileTime
//
//  DESCRIPTION:
//
//  Set the value from a string representation of a FILETIME
//
//  PARAMETERS:
//
//		bsFileTime		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::SetFileTime( 
        /*[in]*/ BSTR bsFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	// Convert string to 64-bit
	unsigned __int64 ri64;
	
	if (ReadUI64(bsFileTime, ri64))
	{
		// Now convert 64-bit to FILETIME
		FILETIME fileTime;
		fileTime.dwHighDateTime = (DWORD)(ri64 >> 32);
		fileTime.dwLowDateTime = (DWORD)(ri64 & 0xFFFFFFFF); 
	
		// Now turn it into a SYSTEMTIME
		SYSTEMTIME	sysTime;
		
		if (TRUE == FileTimeToSystemTime (&fileTime, &sysTime))
		{
			long offset = 0;

			if (VARIANT_TRUE == bIsLocal)
			{
				WBEMTime wbemTime (sysTime);
				if (!wbemTime.GetDMTF (sysTime, offset))
					return wbemErrInvalidSyntax;
			}

			m_iYear = sysTime.wYear;
			m_iMonth = sysTime.wMonth;
			m_iDay = sysTime.wDay;
			m_iHours = sysTime.wHour;
			m_iMinutes = sysTime.wMinute;
			m_iSeconds = sysTime.wSecond;

			/*
			 * SYSTEMTIME has only 1 millisecond precision. Since
			 * a FILETIME has 100 nanosecond precision and a DMTF
			 * datetime has 1 microsecond, you can see the point
			 * of the following.
			 */
			m_iMicroseconds = sysTime.wMilliseconds * 1000 +
							((ri64 % (10000)) / 10);

			// Record our LSB in case we need it later
			m_dw100nsOverflow = ri64 % 10;

			// The FILETIME hs 1ns precision
			m_iUTC = offset;

			m_bYearSpecified = VARIANT_TRUE,	
			m_bMonthSpecified = VARIANT_TRUE, 
			m_bDaySpecified = VARIANT_TRUE, 
			m_bHoursSpecified = VARIANT_TRUE, 
			m_bMinutesSpecified = VARIANT_TRUE, 
			m_bSecondsSpecified = VARIANT_TRUE, 
			m_bMicrosecondsSpecified = VARIANT_TRUE, 
			m_bUTCSpecified = VARIANT_TRUE, 
			m_bIsInterval = VARIANT_FALSE;			

			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

LONG CSWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTimeSpan &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

CSWbemDateTime::WBEMTime CSWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const	CSWbemDateTime::WBEMTime & CSWbemDateTime::WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
	FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
	{
		// now assign using a FILETIME.
		*this = t_ft;
	}
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const CSWbemDateTime::WBEMTime & CSWbemDateTime::WBEMTime::operator=(const FILETIME & ft)
{
	FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

CSWbemDateTime::WBEMTime CSWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CSWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CSWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset)
//
//  Description:  Gets the time in DMTF string local datetime format as a 
//	SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CSWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st)
//
//  Description:  Gets the time in as local SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CSWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            long offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this + WBEMTimeSpan(offset);
            else
               wt = *this - WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\dispdefs.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  dispdefs.h
//
//  alanbos  22-May-98   Created.
//
//  Definitions for the IDL file
//
//***************************************************************************

#ifndef _DISPDEFS_H_
#define _DISPDEFS_H_


#define WBEMS_DISPID_DERIVATION			0x11
#define WBEMS_DISPID_OBJECT_FILTER		0x1E

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\contvar.h ===
//***************************************************************************
//
//  contvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CContextEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _CONTVAR_H_
#define _CONTVAR_H_

// This class implements the IEnumVARIANT interface

class CContextEnumVar : public IEnumVARIANT
{
private:
	long			m_cRef;
	CSWbemNamedValueSet	*m_pContext;
	ULONG			m_pos;

	bool			SeekCurrentPosition ();

public:
	CContextEnumVar (CSWbemNamedValueSet *pContext, ULONG initialPos = 0);
	~CContextEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\cwbemdsp.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation.
//
//  File:  cwbemdsp.cpp
//
//	Description :
//				Implementation of the IDispatch interface for Wbem Objects.
//				This is mostly standard, except for the additional support for
//				specifying the name of a Wbem class property/method directly as if it
//				was a property/method of the actual CWbemObject class ("dot notation")
//
//	Part of :	WBEM automation interface layer
//
//  History:	
//		corinaf			4/3/98		Created
//
//***************************************************************************

#include "precomp.h"

const unsigned long		CWbemDispID::s_wmiDispIdTypeMask = 0x03000000;
const unsigned long		CWbemDispID::s_wmiDispIdTypeStatic = 0x00000000;
const unsigned long		CWbemDispID::s_wmiDispIdTypeSchema = 0x01000000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeMask = 0x00800000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeProperty = 0x00800000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeMethod = 0x00000000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaElementIDMask = 0x007FFFFF;

//Forward declaration

HRESULT assignArrayElementToVariant(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvResult);
void assignVariantToArrayElement(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvNewVal);
VARTYPE CimTypeToVtType(CIMTYPE lType);
HRESULT VariantChangeByValToByRef(VARIANT *dest, VARIANT *source, VARTYPE destType);

class CWbemSchemaIDCache
{
private:
	typedef map<CComBSTR, CWbemDispID, BSTRless> DispIDNameMap;

	unsigned long				m_nextId;
	DispIDNameMap				m_cache;
	CWbemDispatchMgr			*m_pDispatchMgr;

	bool	FindPropertyName (BSTR bsName);
	bool	GetMethod (BSTR bstrMethodName, SAFEARRAY **ppsaInParams, SAFEARRAY **ppsaOutParams,
						CComPtr<IWbemClassObject> & pInParams, CComPtr<IWbemClassObject> & pOutParams);
	bool	GetIdOfMethodParameter(BSTR bstrParamName, CComPtr<IWbemClassObject> & pParams, long *pId);

	static bool FindMemberInArray(BSTR bstrName, SAFEARRAY *psaNames);

public:
	CWbemSchemaIDCache (CWbemDispatchMgr *pDispMgr) :
				m_nextId (0),
				m_pDispatchMgr (pDispMgr) {}
	virtual ~CWbemSchemaIDCache ();

	HRESULT	GetDispID (LPWSTR FAR* rgszNames, unsigned int cNames, DISPID FAR* rgdispid); 
	bool	GetName (DISPID dispId, CComBSTR & bsName);
};


CWbemDispatchMgr::CWbemDispatchMgr(CSWbemServices *pWbemServices,
								   CSWbemObject *pSWbemObject) :
			m_pWbemServices (pWbemServices),
			m_pSWbemObject (pSWbemObject),	// Backpointer to parent (not AddRef'd)
			m_pWbemClass (NULL),
			m_pTypeInfo (NULL),
			m_pCTypeInfo (NULL),
			m_hResult (S_OK)
{
	m_pSchemaCache = new CWbemSchemaIDCache (this);

	if (m_pWbemServices)
		m_pWbemServices->AddRef ();

	m_pWbemObject = pSWbemObject->GetIWbemClassObject ();
}

CWbemDispatchMgr::~CWbemDispatchMgr()
{
	RELEASEANDNULL(m_pWbemServices)
	RELEASEANDNULL(m_pWbemObject)
	RELEASEANDNULL(m_pWbemClass)
	RELEASEANDNULL(m_pTypeInfo)
	RELEASEANDNULL(m_pCTypeInfo)
	DELETEANDNULL(m_pSchemaCache)
}

void	CWbemDispatchMgr::SetNewObject (IWbemClassObject *pNewObject)
{
	if (m_pWbemObject && pNewObject)
	{
		m_pWbemObject->Release ();
		m_pWbemObject = pNewObject;
		m_pWbemObject->AddRef ();

		CComVariant var;

		if (SUCCEEDED(pNewObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL)) &&
			(WBEM_GENUS_CLASS == var.lVal))
		{
			// This is a class, so update the class object too
			if (m_pWbemClass)
				m_pWbemClass->Release ();

			m_pWbemClass = pNewObject;
			m_pWbemClass->AddRef ();
		}

		// Clear out the caches
		if (m_pSchemaCache)
		{
			delete m_pSchemaCache;
			m_pSchemaCache = new CWbemSchemaIDCache (this);
		}
	}
}

STDMETHODIMP
CWbemDispatchMgr::GetTypeInfoCount(unsigned int FAR* pctinfo)
{
    *pctinfo = 1;
	return NOERROR;
}


STDMETHODIMP CWbemDispatchMgr::GetTypeInfo(unsigned int itinfo, 
							  LCID lcid,
							  ITypeInfo FAR* FAR* pptinfo)
{
	HRESULT hr;
	ITypeLib *pTypeLib = NULL;

	//If Type Info is not cached already - load the library and 
	//get the Type Info, then cache it for further access
	if (!m_pTypeInfo)
	{

		// Load Type Library. 
		hr = LoadRegTypeLib(LIBID_WbemScripting, 1, 0, lcid, &pTypeLib);
		if (FAILED(hr)) 
		{   
			// if it wasn't registered, try to load it from the path
			// if this succeeds, it will have registered the type library for us
			// for the next time.  
			hr = LoadTypeLib(OLESTR("wbemdisp.tlb"), &pTypeLib); 
			if(FAILED(hr))        
				return hr;   
		}
    
		// Get type information for interface of the object.  
		hr = pTypeLib->GetTypeInfoOfGuid(IID_ISWbemObjectEx, &m_pTypeInfo);
		pTypeLib->Release();
		if (FAILED(hr))  
			return hr;

	}

	//AddRef whenever returning another pointer to this
	m_pTypeInfo->AddRef();
	*pptinfo = m_pTypeInfo;

    return NOERROR;
}

STDMETHODIMP CWbemDispatchMgr::GetClassInfo(ITypeInfo FAR* FAR* pptinfo)
{
	HRESULT hr;
	ITypeLib *pTypeLib = NULL;

	//If Type Info is not cached already - load the library and 
	//get the Type Info, then cache it for further access
	if (!m_pCTypeInfo)
	{

		// Load Type Library. 
		hr = LoadRegTypeLib(LIBID_WbemScripting, 1, 0, 0, &pTypeLib);
		if (FAILED(hr)) 
		{   
			// if it wasn't registered, try to load it from the path
			// if this succeeds, it will have registered the type library for us
			// for the next time.  
			hr = LoadTypeLib(OLESTR("wbemdisp.tlb"), &pTypeLib); 
			if(FAILED(hr))        
				return hr;   
		}
    
		// Get type information for coclass of the object.  
		hr = pTypeLib->GetTypeInfoOfGuid(CLSID_SWbemObjectEx, &m_pCTypeInfo);
		pTypeLib->Release();
		if (FAILED(hr))  
			return hr;

	}

	//AddRef whenever returning another pointer to this
	m_pCTypeInfo->AddRef();
	*pptinfo = m_pCTypeInfo;

    return NOERROR;
}

STDMETHODIMP
CWbemDispatchMgr::GetIDsOfNames(REFIID iid,  //always IID_NULL
								LPWSTR FAR* rgszNames,
								unsigned int cNames, 
								LCID lcid, 
								DISPID FAR* rgdispid)
{
    HRESULT hr = E_FAIL;
	CComPtr<ITypeInfo> pITypeInfo;

	if (SUCCEEDED(hr = GetTypeInfo(0, lcid, &pITypeInfo)))
	{
		// See if this is a static property or method
		if (FAILED(hr = DispGetIDsOfNames(pITypeInfo,
							   rgszNames,
							   cNames,
							   rgdispid)))
		{
			// Not static - try schema
			if (m_pSchemaCache && FAILED(hr = m_pSchemaCache->GetDispID (rgszNames, cNames, rgdispid)))
			{
				rgdispid[0] = DISPID_UNKNOWN;
				hr = DISP_E_UNKNOWNNAME;
			}
		}
	}

	return hr;

}


STDMETHODIMP CWbemDispatchMgr::Invoke(DISPID dispidMember, 
						 REFIID iid, LCID lcid,
						 unsigned short wFlags, 
						 DISPPARAMS FAR* pdispparams,
						 VARIANT FAR* pvarResult, 
						 EXCEPINFO FAR* pexcepinfo,
						 unsigned int FAR* puArgErr)
{
	HRESULT hr;
	ITypeInfo *pTypeInfo = NULL;

	//Get the type info
	hr = GetTypeInfo(0, lcid, &pTypeInfo);
	if (FAILED(hr))
		return hr;

	m_hResult = S_OK;

	CWbemDispID dispId (dispidMember);

	// Is this a regular dispId
	if (dispId.IsStatic ())
	{
		// Check for inbound NULLs masquerading as defaulted parameters
		if (wFlags & DISPATCH_METHOD)
			MapNulls (pdispparams);

		hr = DispInvoke((IDispatch *) ((ISWbemObjectEx *)m_pSWbemObject),
				        pTypeInfo,
						dispidMember,
						wFlags,
						pdispparams,
						pvarResult,
						pexcepinfo,
						puArgErr
						);

		if (FAILED(hr))
		{
			// Try the error handler for this object in case it can handle this
			hr = HandleError (dispidMember, wFlags, pdispparams, pvarResult, puArgErr, hr);
		}
	}
	else if (dispId.IsSchema ())
	{
		//Otherwise - this is a WBEM property or method, so we implement
		//the invocation ourselves...

		ResetLastErrors ();
	
		if (dispId.IsSchemaMethod ()) //WBEM method
			hr = InvokeWbemMethod(dispidMember, 
								  pdispparams,
								  pvarResult);
		else if (dispId.IsSchemaProperty ()) //WBEM property
			hr = InvokeWbemProperty(dispidMember, 
									wFlags, 
									pdispparams, 
									pvarResult,
									pexcepinfo,
									puArgErr);
		else
			hr = DISP_E_MEMBERNOTFOUND;

		if (FAILED(hr))
			RaiseException (hr);
	}

	if (FAILED (m_hResult))
	{
		if (NULL != pexcepinfo)
			SetException (pexcepinfo, m_hResult, L"SWbemObjectEx");

		hr = DISP_E_EXCEPTION;
	}

	if (pTypeInfo)
		pTypeInfo->Release();

	return hr;
}

HRESULT
CWbemDispatchMgr::InvokeWbemProperty(DISPID dispid, 
									 unsigned short wFlags, 
								     DISPPARAMS FAR* pdispparams, 
									 VARIANT FAR* pvarResult,
									 EXCEPINFO FAR* pexcepinfo,
									 unsigned int FAR* puArgErr)
{
	HRESULT hr = E_FAIL;

	if (m_pSchemaCache)
	{
		BOOL bIsGetOperation = (DISPATCH_PROPERTYGET & wFlags);

		if (bIsGetOperation)
		{
			//Check that the output parameter is valid
			if (pvarResult == NULL)
				return E_INVALIDARG;
		}
		else
		{
			//Check input parameters
			if ((pdispparams->cArgs < 1) || (pdispparams->cArgs > 2)) 
				return DISP_E_BADPARAMCOUNT;

			if ((pdispparams->cNamedArgs != 1) ||
				(pdispparams->cNamedArgs == 1 && 
				 pdispparams->rgdispidNamedArgs[0] != DISPID_PROPERTYPUT))
				return DISP_E_PARAMNOTOPTIONAL;
		}	

		//For both get & put, we need to first get the property 
		//             (for put we need to validate the syntax)
		CComBSTR bsPropertyName;

		if (m_pSchemaCache->GetName (dispid, bsPropertyName))
		{
			SAFEARRAY *psaNames = NULL;
			long inx;
			VARIANT vPropVal;
			long lArrayPropInx;
			CIMTYPE lPropType;

			//Get the value of this property
			//-------------------------------------
			VariantInit(&vPropVal);
			if (FAILED (hr = m_pWbemObject->Get(bsPropertyName, 0, &vPropVal, &lPropType, NULL)))
			{
				return hr;
			}

			// The expected VT type for the proposed property value
			VARTYPE expectedVarType =  CimTypeToVtType (lPropType & ~CIM_FLAG_ARRAY);

			//If we are in a get operation
			//----------------------------------
			if (bIsGetOperation)
			{
				//If the property is an embedded object, we might need to convert it from 
				//a VT_UNKNOWN to a VT_DISPATCH
				if (SUCCEEDED(hr = MapFromCIMOMObject(m_pWbemServices, &vPropVal, 
										m_pSWbemObject, bsPropertyName)))
				{
					//If the property is an array, need to check for index and get that element
					if ((lPropType & CIM_FLAG_ARRAY) && (pdispparams->cArgs > 0))
					{
						//Note: currently we support single dimension arrays only, so we only
						//      look for one index
						VARIANT indexVar;
						VariantInit (&indexVar);
						// Attempt to coerce the index argument into a value suitable for an array index
						if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[0], 0, VT_I4)) 
						{
							lArrayPropInx = V_I4(&indexVar);

							//Fill in the result variant with the requested array element
							hr = assignArrayElementToVariant(vPropVal.parray, (V_VT(&vPropVal) & ~VT_ARRAY),
													lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_TYPEMISMATCH;

						VariantClear (&indexVar);
					}
					else //If it's not an array index - copy to output param and we're done
					{
						// Check if it's an array value and convert as necessary
						if (V_ISARRAY(&vPropVal))
							hr = ConvertArrayRev(pvarResult, &vPropVal);
           				else
							hr = VariantCopy (pvarResult, &vPropVal);
					}
				}
			} //Property Get

			//Otherwise (put operation)
			//---------------------------------
			else
			{
				/*
				 * Need to translate this into a call to SWbemProperty.put_Value: easiest way
				 * to do this is to 
				 * (A) get the SWbemProperty object for this property
				 * (B) Call IDispatch::Invoke on that object, passing in the value
				 * This way we get the error handling behavior too.
				 */

				CComPtr<ISWbemPropertySet> pISWbemPropertySet;

				if (SUCCEEDED(hr = m_pSWbemObject->get_Properties_ (&pISWbemPropertySet)))
				{
					CComPtr<ISWbemProperty> pISWbemProperty;

					if (SUCCEEDED(hr = pISWbemPropertySet->Item (bsPropertyName, 0, &pISWbemProperty)))
					{
						// NB: The Value property of ISWbemProperty is the "default" automation property
						hr = pISWbemProperty->Invoke (
										DISPID_VALUE,
										IID_NULL, 
										0,
										wFlags,
										pdispparams, 
										pvarResult,
										pexcepinfo,
										puArgErr);

						// Use our more specific error here if we have one
						if (FAILED(hr) && pexcepinfo)
							hr = pexcepinfo->scode;
					}
				}

			} //Property Put

			VariantClear(&vPropVal);
		}
	}

	return hr;

} 

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::InvokeWbemMethod
//
//  DESCRIPTION:
//
//  Invoke the method via direct access.  
//
//  PARAMETERS:
//
//		dispid			The dispid od the method
//		pdispparams		Pointer to DISPPARAMS for this invocation
//		pvarResult		On successful return holds return value (if any)
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::InvokeWbemMethod(
	DISPID dispid, 
	DISPPARAMS FAR* pdispparams, 
	VARIANT FAR* pvarResult
)
{
	HRESULT hr = E_FAIL;

	if (m_pWbemServices && m_pSchemaCache)
	{
		//Currently we don't support named arguments
		if (pdispparams->cNamedArgs > 0)
			return DISP_E_NONAMEDARGS;

		//Map the dispid to a method name
		CComBSTR bsMethodName;

		if (m_pSchemaCache->GetName (dispid, bsMethodName))
		{
			// Build up the inparameters (if any)
			CComPtr<IWbemClassObject> pInParameters;
			CComPtr<IWbemClassObject> pOutParameters;

			//Get the input parameters object of the method (may be NULL)
			if (SUCCEEDED (hr = m_pWbemClass->GetMethod(bsMethodName, 0, &pInParameters, 
															&pOutParameters)))
			{
				CComPtr<IWbemClassObject> pInParamsInstance;

				if (pInParameters)
					hr = MapInParameters (pdispparams, pInParameters, &pInParamsInstance);
				
				if (SUCCEEDED (hr))
				{
					CComPtr<IWbemServices> pService = m_pWbemServices->GetIWbemServices ();

					if (pService)
					{
						// Need the RELPATH to specify the target class or instance
						VARIANT vObjectPathVal;
						VariantInit(&vObjectPathVal);
			
						if (SUCCEEDED (hr = m_pWbemObject->Get
											(WBEMS_SP_RELPATH, 0, &vObjectPathVal, NULL, NULL)))
						{
							/*
							 * If a "keyless" object slips through the net its __RELPATH
							 * value will be VT_NULL.  At this point we should fail gracefully.
							 */
							if 	(VT_BSTR == V_VT(&vObjectPathVal))
							{
								// Execute the CIMOM method 
								CComPtr<IWbemClassObject> pOutParamsInstance;
									
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
								CSWbemSecurity *pSecurityInfo = m_pWbemServices->GetSecurityInfo ();
			
								if (pSecurityInfo && pSecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
								{
			
									if (SUCCEEDED(hr = pService->ExecMethod(V_BSTR(&vObjectPathVal), 
											bsMethodName, 0, NULL,
											pInParamsInstance, &pOutParamsInstance, NULL)))
										hr = MapOutParameters (pdispparams, pOutParameters,
																pOutParamsInstance,	pvarResult);

									SetWbemError (m_pWbemServices);
								}

								if (pSecurityInfo)
								{
									// Restore original privileges on this thread
									if (needToResetSecurity)
										pSecurityInfo->ResetSecurity (hThreadToken);

									pSecurityInfo->Release ();
								}
							}
							else
								hr = WBEM_E_FAILED;
						}

						VariantClear (&vObjectPathVal);
					}
				}		
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapOutParameters
//
//  DESCRIPTION:
//
//  Invoke the method via direct access.  
//
//  PARAMETERS:
//
//		dispparams			Pointer to DISPPARAMS for this invocation
//		pOutParameters		Class template for out parameters
//		pOutParamsInstance	Addresses the IWbemClassObject to hold the
//							out parameters (if any) - may be NULL
//		pvarResult			On successful return holds return value (if any)
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapOutParameters (
	DISPPARAMS FAR* pdispparams,
	IWbemClassObject *pOutParameters,
	IWbemClassObject *pOutParamsInstance,
	VARIANT FAR* pvarResult
)
{
	HRESULT hr = S_OK;

	//For each "out" parameter in the output parameters object (if there is one), 
	//find it's id, then look for the parameter with this id in the arguments array
	//and set the return parameter value accordingly
	//----------------------------------------------------------------------------

	if (pOutParameters && pOutParamsInstance)
	{
		//Start an enumeration through the "out" parameters class template
		if (SUCCEEDED (hr = pOutParameters->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			BSTR bstrId = SysAllocString(L"id");
			BSTR bstrParamName = NULL;
						
			/*
			 * For each property in the outparams class template, get the [id]
			 * to map the relevant posistional value in the pdispparams.
			 */
			while (WBEM_S_NO_ERROR == 
				(hr != pOutParameters->Next(0, &bstrParamName, NULL, NULL, NULL)))
			{
				// Get the returned parameter value from the instance
				VARIANT vParamVal;
				VariantInit(&vParamVal);
				
				if (SUCCEEDED (pOutParamsInstance->Get (bstrParamName, 0, &vParamVal, NULL, NULL)))
				{
					//If this is the return value, set it separately
					if (!_wcsicmp(bstrParamName, L"ReturnValue"))
					{
						if (pvarResult)
							hr = MapReturnValue (pvarResult, &vParamVal);
					}
					//Otherwise - regular out parameter
					else
					{
						IWbemQualifierSet *pQualSet = NULL;
						
						//Get the id of this parameter (it's the "id" qualifier)
						if (SUCCEEDED (hr = pOutParameters->GetPropertyQualifierSet
													(bstrParamName, &pQualSet)))
						{
							VARIANT vIdVal;
							VariantInit(&vIdVal);

							if (SUCCEEDED (hr = pQualSet->Get(bstrId, 0, &vIdVal, NULL)))
							{
								//Calculate the position of this id in the arguments array
								long pos = (pdispparams->cArgs - 1) - V_I4(&vIdVal);

								// If its out of range, too bad
								if ((0 <= pos) && (pos < (long) pdispparams->cArgs))
									hr = MapOutParameter (&pdispparams->rgvarg[pos], &vParamVal);
							}

							VariantClear(&vIdVal);
							pQualSet->Release();	
						}
					}
				}

				VariantClear (&vParamVal);
				SysFreeString (bstrParamName);
				bstrParamName = NULL;
			} //while

			SysFreeString (bstrId);
		}
	} //if pOutParameters
		
	return hr;
} 

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapReturnValue
//
//  DESCRIPTION:
//
//  Map the method return value
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value (if any)
//		pSrc	The variant value to map	
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapReturnValue (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc
)
{
	HRESULT hr = S_OK;

	//If the return value is a VT_UNKNOWN, we need to wrap into a 
	//VT_DISPATCH before passing it back
	if (SUCCEEDED (hr = MapFromCIMOMObject(m_pWbemServices, pSrc)))
	{
		// Handle arrays correctly (must always be VT_ARRAY|VT_VARIANT)
		if(V_VT(pSrc) & VT_ARRAY)
			hr = ConvertArrayRev(pDest, pSrc);
		else
			hr = VariantCopy (pDest, pSrc);
	}
		
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapOutParameter
//
//  DESCRIPTION:
//
//  Map a (possibly by reference) out parameter
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value (if any)
//		pVal	The variant value to map	
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapOutParameter (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc
)
{
	HRESULT hr = S_OK;

	//If the return value is a VT_UNKNOWN, we need to wrap into a 
	//VT_DISPATCH before passing it back
	if (SUCCEEDED (hr = MapFromCIMOMObject(m_pWbemServices, pSrc)))
	{
		VARIANT tempVal;
		VariantInit (&tempVal);
		
		// Handle arrays correctly (must always be VT_ARRAY|VT_VARIANT)
		if(V_VT(pSrc) & VT_ARRAY)
			hr = ConvertArrayRev(&tempVal, pSrc);
		else
			hr = VariantCopy (&tempVal, pSrc);
			
		// Finally take care of ensuring we produce BYREFs if necessary
		if (SUCCEEDED (hr))
			 hr = VariantChangeByValToByRef(pDest, &tempVal, V_VT(pDest));

		VariantClear (&tempVal);
	}

	return hr;
}

								
//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapInParameters
//
//  DESCRIPTION:
//
//  Map the in parameters to a method
//
//  PARAMETERS:
//
//		pdispparams			DISPPARAMS containing the in parameters
//		pInParameters		Class template for method input parameters
//		ppInParamsInstance	On successful return holds the mapped parameters
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapInParameters (
	DISPPARAMS FAR* pdispparams, 
	IWbemClassObject *pInParameters,
	IWbemClassObject **ppInParamsInstance
)
{
	HRESULT hr = S_OK;
	*ppInParamsInstance = NULL;

	//Spawn an instance to fill in with values
	if (SUCCEEDED (hr = pInParameters->SpawnInstance(0, ppInParamsInstance)))
	{
		/*
		 * Iterate through the "in" parameters object properties in the class to find the
		 * ID positional qualifier.  Note we do this in the InParams class rather than
		 * the spawned instance to protect ourselves against the case where the [id]
		 * qualifier has been declared without the "propagate to instance" flavor setting,
		 */
		if (SUCCEEDED (hr = pInParameters->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			BSTR bstrParamName = NULL;
			BSTR bstrId = SysAllocString(L"id");
			CIMTYPE lType;

			//For each property in the inparams object
			while (WBEM_S_NO_ERROR == 
						(hr = pInParameters->Next(0, &bstrParamName, NULL, &lType, NULL)))
			{
				IWbemQualifierSet *pQualSet = NULL;
			
				//Get the id of this parameter (it's the "id" qualifier)
				if (SUCCEEDED(hr = 
						pInParameters->GetPropertyQualifierSet(bstrParamName, &pQualSet)))
				{
					VARIANT vIdVal;
					VariantInit(&vIdVal);
				
					if (SUCCEEDED(hr = pQualSet->Get(bstrId, 0, &vIdVal, NULL)))
					{
						//Calculate the position of this id in the arguments array
						long pos = (pdispparams->cArgs - 1) - V_I4(&vIdVal);

						// If no argument specified, we won't set it in ppInParamsInstance
						// and just assume it will be defaulted
						if ((0 <= pos) && (pos < (long) pdispparams->cArgs))
						{
							VARIANT vParamVal;
							VariantInit (&vParamVal);
							
							if (SUCCEEDED (hr = MapInParameter 
										(&vParamVal, &pdispparams->rgvarg[pos], lType)))
							{
								// If we have a VT_ERROR with DISP_E_PARAMNOTFOUND this
								// is a "missing" parameter - we just fail to set it and 
								// let it default in the instance

								if ((VT_ERROR == V_VT(&vParamVal)) && (DISP_E_PARAMNOTFOUND == vParamVal.scode))
								{
									// Let it default
								}
								else
								{
									//Copy the value for this parameter from the argument array
									//into the inparamsinstance object property
									hr = (*ppInParamsInstance)->Put(bstrParamName, 0, &vParamVal, NULL);
								}
							}

							VariantClear (&vParamVal);
						}
					}

					VariantClear(&vIdVal);
					pQualSet->Release();
					pQualSet = NULL;
				}

				SysFreeString (bstrParamName);						
				bstrParamName = NULL;

				if (FAILED(hr))
					break;
			} //while

			SysFreeString (bstrId);
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapInParameter
//
//  DESCRIPTION:
//
//  Map a in parameter
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value
//		pVal	The variant value to map	
//		lType	CIMTYPE of target property value
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapInParameter (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc,
	CIMTYPE		 lType
)
{
	HRESULT hr = S_OK;

	if ((NULL == pSrc) || (VT_EMPTY == V_VT(pSrc)) 
							|| (VT_NULL == V_VT(pSrc)))
	{
		// Map all of these to a VT_NULL
		pDest->vt = VT_NULL;
	}
	else if (((VT_ARRAY | VT_VARIANT) == V_VT(pSrc)) ||
			 ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pSrc)))
	{
		// Arrays need to be mapped "down" to their raw form (and watch out
		// for embedded objects!)
		if (SUCCEEDED(hr = ConvertArray(pDest, pSrc)))
            hr = MapToCIMOMObject(pDest);
	}
	else if ((CIM_FLAG_ARRAY & lType) && 
			((VT_DISPATCH == V_VT(pSrc)) 
			 || ((VT_DISPATCH|VT_BYREF) == V_VT(pSrc))))
	{
		// Look for a JScript-style IDispatch that needs to be mapped to an array
		hr = ConvertDispatchToArray (pDest, pSrc, lType & ~CIM_FLAG_ARRAY);
	}
	else if ((VT_BYREF | VT_VARIANT) == V_VT(pSrc))
	{
		// May be used if the scripting language supports functions that can change
		// the type of a reference.  CIMOM won't do this, wo we unwrap the
		// variant before proceeding
		hr = MapInParameter (pDest, pSrc->pvarVal, lType);
	}
	else
	{
		// A "straightforward" value - all we have to watch for is an embedded object
		// and a possible byRef
		if (SUCCEEDED(hr = VariantCopy (pDest, pSrc)))
		{
			hr = MapToCIMOMObject(pDest);

			// Is it byref - if so remove the indirection
			if (VT_BYREF & V_VT(pDest))
				hr = VariantChangeType(pDest, pDest, 0, V_VT(pDest) & ~VT_BYREF);
		}
	}			

	return hr;
}

//-------------------------------------------------------------
// CWbemDispatchMgr::RaiseException
//
// Description : signal exception to automation client
//
// Parameters : hr - HRESULT
//-------------------------------------------------------------
void CWbemDispatchMgr::RaiseException (HRESULT hr)
{
	// Store the HRESULT for processing in the Invoke routine
	m_hResult = hr;

	// Set a WMI scripting error on this thread for the client
	ICreateErrorInfo *pCreateErrorInfo = NULL;

	if (SUCCEEDED (CreateErrorInfo (&pCreateErrorInfo)))
	{
		BSTR bsDescr = MapHresultToWmiDescription (hr);
		pCreateErrorInfo->SetDescription (bsDescr);
		SysFreeString (bsDescr);
		pCreateErrorInfo->SetGUID (IID_ISWbemObjectEx);
		pCreateErrorInfo->SetSource (L"SWbemObjectEx");
	
		IErrorInfo *pErrorInfo = NULL;

		if (SUCCEEDED (pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**) &pErrorInfo)))
		{
			SetErrorInfo (0, pErrorInfo);
			pErrorInfo->Release ();
		}

		pCreateErrorInfo->Release ();
	}
}					

//-------------------------------------------------------------
// Name : assignArrayElementToVariant
//
// Description : According to the type of the array elements,
//			     retrieves the requested element from the array
//				 into a variant
//
// Parameters : psa - pointer to the SAFEARRAY
//				vt -  vartype of array elements
//				inx - index of the element in the array
//				pvResult - resulting variant
//-------------------------------------------------------------
HRESULT assignArrayElementToVariant(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvResult)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	switch (vt)
	{
		case VT_I2 :
			V_VT(pvResult) = VT_I2;
			SafeArrayGetElement(psa, &inx, &V_I2(pvResult));
			break;
		case VT_I4 :
			V_VT(pvResult) = VT_I4;
			SafeArrayGetElement(psa, &inx, &V_I4(pvResult));
			break;
		case VT_R4 :
			V_VT(pvResult) = VT_R4;
			SafeArrayGetElement(psa, &inx, &V_R4(pvResult));
			break;
		case VT_R8 :
			V_VT(pvResult) = VT_R8;
			SafeArrayGetElement(psa, &inx, &V_R8(pvResult));
			break;
		case VT_DATE :
			V_VT(pvResult) = VT_DATE;
			SafeArrayGetElement(psa, &inx, &V_DATE(pvResult));
			break;
		case VT_BSTR : 
			V_VT(pvResult) = VT_BSTR;
			SafeArrayGetElement(psa, &inx, &V_BSTR(pvResult));
			break;
		case VT_DISPATCH :
			V_VT(pvResult) = VT_DISPATCH;
			SafeArrayGetElement(psa, &inx, &V_DISPATCH(pvResult));
			break;
		case VT_UNKNOWN :
			V_VT(pvResult) = VT_UNKNOWN;
			SafeArrayGetElement(psa, &inx, &V_UNKNOWN(pvResult));
			break;
		case VT_BOOL :
			V_VT(pvResult) = VT_BOOL;
			SafeArrayGetElement(psa, &inx, &V_BOOL(pvResult));
			break;
		case VT_VARIANT :
		{
			V_VT(pvResult) = VT_BYREF | VT_VARIANT;
			VARIANT *pVar = new VARIANT;

			if (pVar)
			{
				VariantInit (pVar);
				SafeArrayGetElement(psa, &inx, pVar);
				V_VARIANTREF(pvResult) = pVar;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
			break;
		case VT_UI1 : 
			V_VT(pvResult) = VT_UI1;
			SafeArrayGetElement(psa, &inx, &V_UI1(pvResult));
			break;
		default :
			V_VT(pvResult) = VT_ERROR;
			break;
	}

	return hr;
}

//-------------------------------------------------------------
// Name : CheckArrayBounds
//
// Description : Check that index is within bounds and if not
//				 Redim the array
//
// Parameters : psa - pointer to the SAFEARRAY
//				inx - putative index
//-------------------------------------------------------------
void CheckArrayBounds(SAFEARRAY *psa, long inx)
{
	long lBound, uBound;
	SafeArrayGetUBound (psa, 1, &uBound);
	SafeArrayGetLBound (psa, 1, &lBound);

	if ((inx < lBound) || (inx > uBound))
	{
		// Need to redim
		SAFEARRAYBOUND psaBound;
	
		psaBound.cElements = ((inx < lBound) ? 
			(uBound + 1 - inx) : (inx + 1 - lBound));

		psaBound.lLbound = (inx < lBound) ? inx : lBound;
		SafeArrayRedim (psa, &psaBound);
	}
}
	
//-------------------------------------------------------------
// Name : assignVariantToArrayElement
//
// Description : According to the type of the array elements,
//			     puts the new value from the variant into the
//				 requested element of the array
//
// Parameters : psa - pointer to the SAFEARRAY
//				vt -  vartype of array elements
//				inx - index of the element in the array
//				pvNewVal - variant containing the new value
//-------------------------------------------------------------
void assignVariantToArrayElement(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvNewVal)
{
	HRESULT hr = E_FAIL;

	// Firstly check for out-of-bounds case and grow accordingly
	CheckArrayBounds (psa, inx);
	
	switch (vt)
	{
		case VT_I2 :
			hr = SafeArrayPutElement(psa, &inx, &V_I2(pvNewVal));
			break;
		case VT_I4 :
			hr = SafeArrayPutElement(psa, &inx, &V_I4(pvNewVal));
			break;
		case VT_R4 :
			hr = SafeArrayPutElement(psa, &inx, &V_R4(pvNewVal));
			break;
		case VT_R8 :
			hr = SafeArrayPutElement(psa, &inx, &V_R8(pvNewVal));
			break;
		case VT_DATE :
			hr = SafeArrayPutElement(psa, &inx, &V_DATE(pvNewVal));
			break;
		case VT_BSTR : 
			hr = SafeArrayPutElement(psa, &inx, V_BSTR(pvNewVal));
			break;
		case VT_DISPATCH :
			hr = SafeArrayPutElement(psa, &inx, V_DISPATCH(pvNewVal));
			break;
		case VT_UNKNOWN:
			hr = SafeArrayPutElement(psa, &inx, V_UNKNOWN(pvNewVal));
			break;
		case VT_BOOL :
			hr = SafeArrayPutElement(psa, &inx, &V_BOOL(pvNewVal));
			break;
		case VT_VARIANT :
			hr = SafeArrayPutElement(psa, &inx, V_VARIANTREF(pvNewVal));
			break;
		case VT_UI1 : 
			hr = SafeArrayPutElement(psa, &inx, &V_UI1(pvNewVal));
			break;
		default :
			//????????????
			break;
	} //switch
}


//-------------------------------------------------------------
// Name : CimTypeToVtType
//
// Description : Returns the coresponding VARTYPE for
//				 a given CIMTYPE
// Parameters : lType - the CIMTYPE we want to convert
//-------------------------------------------------------------
VARTYPE CimTypeToVtType(CIMTYPE lType)
{
	VARTYPE ret = VT_EMPTY;

	if (lType & CIM_FLAG_ARRAY)
		ret = VT_ARRAY;

	switch(lType & ~CIM_FLAG_ARRAY)
	{
		case CIM_EMPTY :	ret = (ret | VT_EMPTY); break;
		case CIM_SINT8 :	ret = (ret | VT_I2); break;
		case CIM_UINT8 :	ret = (ret | VT_UI1); break;
		case CIM_SINT16 :	ret = (ret | VT_I2); break;
		case CIM_UINT16 :	ret = (ret | VT_I4); break;
		case CIM_SINT32 :	ret = (ret | VT_I4); break;
		case CIM_UINT32 :	ret = (ret | VT_I4); break;
		case CIM_SINT64 :	ret = (ret | VT_BSTR); break;
		case CIM_UINT64 :	ret = (ret | VT_BSTR); break;
		case CIM_REAL32 :	ret = (ret | VT_R4); break;
		case CIM_REAL64 :	ret = (ret | VT_R8); break;
		case CIM_BOOLEAN :	ret = (ret | VT_BOOL); break;
		case CIM_STRING :	ret = (ret | VT_BSTR); break;
		case CIM_DATETIME :	ret = (ret | VT_BSTR); break;
		case CIM_REFERENCE :ret = (ret | VT_BSTR); break;
		case CIM_CHAR16 :	ret = (ret | VT_I2); break;
		case CIM_OBJECT :	ret = (ret | VT_UNKNOWN); break;
		default : ret = VT_ERROR;
	}

	return ret;
}


//-------------------------------------------------------------
// Name : VariantChangeByValToByRef
//
// Description : Copies a variant, while converting a "byval" to a 
//				 "byref" if the destination type requires it
//
// Parameters : dest - destination variant to hold the result
//				source - source variant to be copied
//				destType - the VARTYPE required for the result.
//					       when this type is a BY_REF, the appropriate
//						   conversion is made from the source.
//-------------------------------------------------------------
HRESULT VariantChangeByValToByRef(VARIANT *dest, VARIANT *source, VARTYPE destType)
{
	HRESULT hr = S_OK;

	if (!(destType & VT_BYREF)) //the destination is not by ref. we can do a straight copy
		hr = VariantCopy(dest, source);
	else
	{
		if ((destType & ~VT_BYREF) & VT_ARRAY)
			hr = SafeArrayCopy(V_ARRAY(source), V_ARRAYREF(dest));
		else
		{
			switch (destType & ~VT_BYREF)
			{
				case VT_UI1 :  *V_UI1REF(dest) = V_UI1(source); break;
				case VT_I2 :   *V_I2REF(dest) = V_I2(source); break;
				case VT_I4 :   *V_I4REF(dest) = V_I4(source); break;
				case VT_R4 :   *V_R4REF(dest) = V_R4(source); break;
				case VT_R8 :   *V_R8REF(dest) = V_R8(source); break;
				case VT_CY :   *V_CYREF(dest) = V_CY(source); break;
				case VT_BSTR : SysReAllocString(V_BSTRREF(dest), V_BSTR(source)); break;
				case VT_BOOL : *V_BOOLREF(dest) = V_BOOL(source); break;
				case VT_DATE : *V_DATEREF(dest) = V_DATE(source); break;
				case VT_DISPATCH : 
						//I need to addref the object behind this interface so
						//that it doesn't get released when we release the original VARIANT
						//that's holding it
						V_DISPATCH(source)->AddRef();
						*V_DISPATCHREF(dest) = V_DISPATCH(source); 
						break;
				case VT_UNKNOWN : 
						//Again, need to addref so that the object doesn't get released
						V_UNKNOWN(source)->AddRef();
						*V_UNKNOWNREF(dest) = V_UNKNOWN(source); break;
						break;
				case VT_VARIANT : hr = VariantCopy(V_VARIANTREF(dest), source); break;
				default : hr = DISP_E_TYPEMISMATCH;
			}
		}
	}

	return hr;

}

//***************************************************************************
//
//  void CWbemDispatchMgr::EnsureClassRetrieved
//
//  DESCRIPTION:
//
//  Make sure we have a class pointer
//
//***************************************************************************

void CWbemDispatchMgr::EnsureClassRetrieved ()
{
	if (!m_pWbemClass)
	{
		CComVariant vGenusVal, vClassName;
		bool bIsClass;

		if (SUCCEEDED(m_pWbemObject->Get(WBEMS_SP_GENUS, 0, &vGenusVal, NULL, NULL)))
		{
			bIsClass = (WBEM_GENUS_CLASS == vGenusVal.lVal);

			//If the object is a class, point the class pointer to it as well
			if (bIsClass)
			{
				m_pWbemClass = m_pWbemObject;
				m_pWbemClass->AddRef () ;
			}
			//Otherwise (it's an instance) we need to get the class
			else
			{
				// Check we have an IWbemServices pointer

				if (m_pWbemServices)
				{
					/*
					 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
					 * the __CLASS property has not yet been set.
					 */
							
					if (SUCCEEDED(m_pWbemObject->Get(WBEMS_SP_CLASS, 0, &vClassName, NULL, NULL)) 
						&& (VT_BSTR == V_VT(&vClassName)))
					{
						CComPtr<IWbemServices> pIWbemServices = m_pWbemServices->GetIWbemServices ();

						if (pIWbemServices)
						{
							CSWbemSecurity *pSecurity = m_pWbemServices->GetSecurityInfo ();

							if (pSecurity)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
									pIWbemServices->GetObject (vClassName.bstrVal, 0, NULL, &m_pWbemClass, NULL);
												
								// Restore original privileges on this thread
								if (needToResetSecurity)
									pSecurity->ResetSecurity (hThreadToken);
										
								pSecurity->Release ();
							}
						}
					}
				}
			}
		}
	}
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDispatchMgr::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for GET calls on the Derivation_ property which
	 * supplied an argument.  Since this property returns a SAFEARRAY, this may
	 * be legal but undetectable by the standard Dispatch mechanism. It is meaningful 
	 * to pass an index (the interpretation is that the index specifies an offset in
	 * the SAFEARRAY structure that represents the derivation value).
	 */
	if ((dispidMember == WBEMS_DISPID_DERIVATION) && (DISP_E_NOTACOLLECTION == hr) && (1 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYGET & wFlags))
	{
		// Looks promising - get the __DERIVATION property to try and resolve this
		if (m_pWbemObject)
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pWbemObject->Get (WBEMS_SP_DERIVATION, 0, &var, NULL, NULL))
			{
				/* The value should be a VT_BSTR|VT_ARRAY */
				if (((VT_ARRAY | VT_BSTR) == var.vt) && (NULL != var.parray))
				{
					VARIANT indexVar;
					VariantInit (&indexVar);

					// Attempt to coerce the index argument into a value suitable for an array index
					if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[0], 0, VT_I4)) 
					{
						long lArrayPropInx = V_I4(&indexVar);

						// We should have a VT_ARRAY|VT_BSTR value at this point; extract the
						// BSTR and set it into the VARIANT
						VariantInit (pvarResult);
						BSTR nameValue = NULL;
						if (SUCCEEDED(hr = SafeArrayGetElement (var.parray, &lArrayPropInx, &nameValue)))
						{
							VariantInit (pvarResult);
							pvarResult->vt = VT_BSTR;
							pvarResult->bstrVal = nameValue;
						}
					}
					else
					{
							hr = DISP_E_TYPEMISMATCH;
							if (puArgErr)
								*puArgErr = 0;
					}

					VariantClear (&indexVar);
				}
			}

			VariantClear (&var);
		}
	}
	
	return hr;
}


// IDispatchEx methods
HRESULT STDMETHODCALLTYPE CWbemDispatchMgr::GetDispID( 
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	return GetIDsOfNames(IID_NULL, &((OLECHAR *)bstrName), 1, ENGLISH_LOCALE, pid);
}

//***************************************************************************
//
//  SCODE CWbemSchemaIDCache::~CWbemSchemaIDCache
//
//  DESCRIPTION:
//
//		Destructor
//
//***************************************************************************

CWbemSchemaIDCache::~CWbemSchemaIDCache ()
{
	DispIDNameMap::iterator next; 

	while ((next = m_cache.begin ()) != m_cache.end ())
		next = m_cache.erase (next);
}

//***************************************************************************
//
//  SCODE CWbemSchemaIDCache::GetDispID
//
//  DESCRIPTION:
//
//  Attempts to resolves a set of names to DISP IDs based on WMI schema.
//
//  PARAMETERS:
//
//		rgszNames				Array of names
//		cNames					Length of above array
//		rgdispid				Pointer to array to hold resolved DISPIDs
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemSchemaIDCache::GetDispID (
	LPWSTR* rgszNames, 
	unsigned int cNames, 
	DISPID* rgdispid
)
{
	HRESULT hr = E_FAIL;	

	if (0 < cNames)
	{
		DispIDNameMap::iterator theIterator = m_cache.find (rgszNames [0]);

		if (theIterator != m_cache.end ())
		{
			hr = S_OK;
			rgdispid [0] = (*theIterator).second;
		}
		else
		{
			if ((1 == cNames) && FindPropertyName (rgszNames [0]))
			{
				// Get a new dispid and add it to the cache
				CWbemDispID dispId;
		
				if (dispId.SetAsSchemaID (++m_nextId))
				{
					rgdispid [0] = dispId;
					m_cache.insert (DispIDNameMap::value_type (rgszNames [0], 
											dispId));
					hr = S_OK;
				}
			}
			else
			{
				//If no property name matches, go on to methods
				SAFEARRAY *psaInParams = NULL;	//array of in parameters names
				SAFEARRAY *psaOutParams = NULL; //array of out parameter names
				CComPtr<IWbemClassObject> pInParams;
				CComPtr<IWbemClassObject> pOutParams;
				bool bMethodFound = false;
				long id = 0;
				bool bUnknownParameterFound = false;

				//Get the names of all method parameters (in and out)
				if (GetMethod (rgszNames[0], &psaInParams, &psaOutParams,
											pInParams, pOutParams))
				{	
					bMethodFound = true;
					unsigned long ulParamCount;
					bool ok = true;
		
					//For each named parameter, search for it in the method parameters
					for (ulParamCount=1; ok && (ulParamCount < cNames); ulParamCount++)
					{
						//If we find this name in the "in" parameters list, attach the id and go on
						if (psaInParams && FindMemberInArray(rgszNames[ulParamCount], psaInParams))
						{
							if (GetIdOfMethodParameter(rgszNames[ulParamCount], //param name
														pInParams, 
														&id))
								rgdispid[ulParamCount] = id;
							else
								ok = false;
						}
						//If it's not in the "in" parameters, check the "out" parameters list
						else if (psaOutParams && FindMemberInArray(rgszNames[ulParamCount], psaOutParams))
						{
							if (GetIdOfMethodParameter(rgszNames[ulParamCount], //param name
														pOutParams, 
														&id))
								rgdispid[ulParamCount] = id;
							else 
								ok = false;
						}
						//If it's not there either - we can't find it
						else
						{
							rgdispid[ulParamCount] = DISPID_UNKNOWN;
							bUnknownParameterFound = true;
						}
					} //walk parameters

					if (!ok)
						bMethodFound = false;
				}

				if (psaInParams)
					SafeArrayDestroy(psaInParams);

				if (psaOutParams)
					SafeArrayDestroy(psaOutParams);

				if (!bMethodFound)
					hr = E_FAIL;
				else if (bUnknownParameterFound) 
					hr = DISP_E_UNKNOWNNAME;
				else
					hr = S_OK;

				// Finally, if this all worked add it to the cache as a method
				if (SUCCEEDED(hr))
				{
					CWbemDispID dispId;
					
					if (dispId.SetAsSchemaID (++m_nextId, false))
					{
						rgdispid [0] = dispId;
						m_cache.insert (DispIDNameMap::value_type (rgszNames [0], 
									dispId));
					}
					else
						hr = E_FAIL;
				}
			}
		}
	}

	return hr;
}


//***************************************************************************
//
//  bool CWbemSchemaIDCache::FindPropertyName
//
//  DESCRIPTION:
//
//  Determine whether the property exists for this object and is not 
//	a system property
//
//  PARAMETERS:
//
//		bsName - name of specified property
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::FindPropertyName(
	BSTR bsName
)
{
	bool result = false;;

	if (m_pDispatchMgr)
	{
		CComPtr<IWbemClassObject> pIWbemClassObject = m_pDispatchMgr->GetObject ();

		if (pIWbemClassObject)
		{
			//Note : This limits the support to non-system properties only !!! 
			LONG lFlavor = 0;

			if (SUCCEEDED(pIWbemClassObject->Get(bsName, 0, NULL, NULL, &lFlavor))
				&& !(WBEM_FLAVOR_ORIGIN_SYSTEM & lFlavor))
				result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetMethod
//
//  DESCRIPTION:
//
//  returns the parameter names of a method in two
//				 safearrays - one for in and one for out
//
//  PARAMETERS:
//
//		bstrMethodName - name of method requested
//		ppsaInParams -   pointer to safearray to return
//								  in parameters
//		ppsaOutParams -  pointer to safearray to return
//								  out parameters
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::GetMethod(
	BSTR bstrMethodName, 
	SAFEARRAY **ppsaInParams, 
	SAFEARRAY **ppsaOutParams,
	CComPtr<IWbemClassObject> & pInParamsObject,
	CComPtr<IWbemClassObject> & pOutParamsObject
)
{
	bool result = false;
	CComPtr<IWbemClassObject> pIWbemClassObject = m_pDispatchMgr->GetClassObject ();

	if (pIWbemClassObject)
	{
		if (SUCCEEDED(pIWbemClassObject->GetMethod(bstrMethodName, 0, &pInParamsObject, &pOutParamsObject)))
		{
			*ppsaInParams = NULL;
			*ppsaOutParams = NULL;
			bool ok = true;

			if (pInParamsObject)
			{
				if (FAILED(pInParamsObject->GetNames(NULL, 0, NULL, ppsaInParams)))
					ok = false;
			}

			if (ok && pOutParamsObject)
			{
				if (FAILED(pOutParamsObject->GetNames(NULL, 0, NULL, ppsaOutParams)))
					ok = false;
			}

			result = ok;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetIdOfMethodParameter
//
//  DESCRIPTION:
//
//  gets the id of a given parameter for a given method
//	(this is a qualifier on the parameter property in the
//				  InParameters/OutParameters object)
//
//  PARAMETERS:
//
//		bstrParamName	-  parameter name
//		pParams			-  IWbemClassObject containing parameters
//		pId				-  pointer to long to receive the ID for this
//						   parameter of this method
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::GetIdOfMethodParameter(
	BSTR bstrParamName, 
	CComPtr<IWbemClassObject> &pParams, 
	long *pId
)
{
	bool result = false;

	if (pParams)
	{
		CComPtr<IWbemQualifierSet> pQualSet;
	
		//Get qualifier set for the required parameter property
		if (SUCCEEDED(pParams->GetPropertyQualifierSet(bstrParamName, &pQualSet)))
		{
			CComVariant vIdVal;
	
			//Get the "id" qualifier value
			if (SUCCEEDED(pQualSet->Get(L"id", 0, &vIdVal, NULL)))
			{
				result = true;
				*pId = vIdVal.lVal;
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetName
//
//  DESCRIPTION:
//
//  gets the name of the item given a DISPID
//
//  PARAMETERS:
//
//		dispId			- id whose name we require
//		bsName			- the name (on successful return)
//
//  RETURN VALUES:
//
//***************************************************************************

bool	CWbemSchemaIDCache::GetName (
	DISPID dispId, 
	CComBSTR & bsName
)
{
	bool result = false;

	DispIDNameMap::iterator theIterator = m_cache.begin ();

	while (theIterator != m_cache.end ())
	{
		if (dispId == (*theIterator).second)
		{
			bsName = (*theIterator).first;
			result = true;
			break;
		}
		else
			theIterator++;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::FindMemberInArray
//
//  DESCRIPTION:
//
//		determine whether a name is present in a SAFEARRAY
//
//  PARAMETERS:
//
//		bstrName			- the name we're looking for
//		psaNames			- SAFEARRAY we're looking in
//
//  RETURN VALUES:
//		true if found, false o/w
//
//***************************************************************************

bool CWbemSchemaIDCache::FindMemberInArray(BSTR bstrName, SAFEARRAY *psaNames)
{
	long lUBound;
	long i;
	
	//Walk the array and check if the requested name exists
	SafeArrayGetUBound(psaNames, 1, &lUBound);

	for (i=0; i <= lUBound; i++)
	{
		CComBSTR bstrMemberName;
		SafeArrayGetElement(psaNames, &i, &bstrMemberName);

		if (!_wcsicmp(bstrMemberName, bstrName)) //found the property
			break;
	}

	return (i <= lUBound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\disphlp.cpp ===
//***************************************************************************
//
//  cdisphlp.CPP
//
//  Module: Client side of WBEM marshalling.
//
//  Purpose: Defines dispatch helper object
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  a-davj    6-feb-97   Created.
//
//***************************************************************************


#include "precomp.h"

//***************************************************************************
//  CDispatchHelp::CDispatchHelp()
//  CDispatchHelp::~CDispatchHelp()
//
//  Purpose: constructor and destructor
//
//***************************************************************************

CDispatchHelp::CDispatchHelp()
{
    m_pITINeutral = NULL;      //Type information
	m_pCITINeutral = NULL;
    m_pObj = NULL;
	m_objectName = NULL;
	m_hResult = S_OK;
}

CDispatchHelp::~CDispatchHelp(void)
{
    RELEASEANDNULL(m_pITINeutral)
	RELEASEANDNULL(m_pCITINeutral)

	SysFreeString (m_objectName);
}

void CDispatchHelp::SetObj(IDispatch * pObj, GUID iGuid, 
						   GUID cGuid, LPWSTR objectName)
{
    m_pObj = pObj;
    m_iGUID = iGuid;
	m_cGUID = cGuid;
	m_objectName = SysAllocString (objectName);
}

SCODE CDispatchHelp::GetTypeInfoCount(UINT FAR* pctinfo)
{
    //We implement GetTypeInfo so return 1
    *pctinfo=1;
    return NOERROR;
}

SCODE CDispatchHelp::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;
    
    if (0!=itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;
    
    //Load a type lib if we don't have the information already.
    if (NULL==m_pITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WbemScripting, 1, 0, lcid, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_iGUID, &m_pITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pITINeutral->AddRef();
    *ppITypeInfo = m_pITINeutral;
    return NOERROR; 
}

SCODE CDispatchHelp::GetClassInfo(
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;
    
    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;
    
    //Load a type lib if we don't have the information already.
    if (NULL==m_pCITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WbemScripting, 1, 0, 0, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_cGUID, &m_pCITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pCITINeutral->AddRef();
    *ppITypeInfo = m_pCITINeutral;
    return NOERROR; 
}

SCODE CDispatchHelp::GetIDsOfNames(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgdispid);
        pTI->Release();
    }

    return hr;
}


void ParseDispArgs (DISPPARAMS FAR * dispparams)
{
	if (dispparams)
	{
		int argCount = dispparams->cArgs;

		for (int i = 0; i < argCount; i++)
		{
			VARIANTARG &v = dispparams->rgvarg [i];
		}

		int nargCount = dispparams->cNamedArgs;
	}
}

SCODE CDispatchHelp::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr)
{

    HRESULT     hr;
    ITypeInfo  *pTI;
	m_hResult = S_OK;

    if(m_pObj == NULL)
        return WBEM_E_FAILED;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (FAILED(hr))
        return hr;

	//ParseDispArgs (pdispparams);

	// Reinterpret inbound VT_NULLs as VT_ERRORs
	if (HandleNulls (dispidMember, wFlags))
		MapNulls (pdispparams);

	hr=pTI->Invoke(m_pObj, dispidMember, wFlags,
              pdispparams, pvarResult,
              pexcepinfo, puArgErr);

	if (FAILED(hr))
	{
		// Try the error handler for this object in case it can handle this
		hr = HandleError (dispidMember, wFlags, pdispparams, pvarResult, puArgErr, hr);
	}

	pTI->Release();
	
	if (FAILED(m_hResult))
	{
		if (NULL != pexcepinfo)
			SetException (pexcepinfo, m_hResult, m_objectName);

		hr = DISP_E_EXCEPTION;
	}

    return hr;
}


void CDispatchHelp::RaiseException (HRESULT hr)
{
	// Store the HRESULT for processing in the Invoke routine
	m_hResult = hr;

	// Set a WMI scripting error on this thread for the client
	ICreateErrorInfo *pCreateErrorInfo = NULL;

	if (SUCCEEDED (CreateErrorInfo (&pCreateErrorInfo)))
	{
		BSTR bsDescr = MapHresultToWmiDescription (hr);
		pCreateErrorInfo->SetDescription (bsDescr);
		SysFreeString (bsDescr);
		pCreateErrorInfo->SetGUID (m_cGUID);
		pCreateErrorInfo->SetSource (m_objectName);

		IErrorInfo *pErrorInfo = NULL;

		if (SUCCEEDED (pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**) &pErrorInfo)))
		{
			SetErrorInfo (0, pErrorInfo);
			pErrorInfo->Release ();
		}

		pCreateErrorInfo->Release ();
	}
}


// IDispatchEx methods
HRESULT STDMETHODCALLTYPE CDispatchHelp::GetDispID( 
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CDispatchHelp::GetDispID()";)
	_RPrint(me, "Called name:", 0, "");

	return GetIDsOfNames(IID_NULL, &((OLECHAR *)bstrName), 1, ENGLISH_LOCALE, pid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\cwbemdsp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cwbemdsp.h
//
//	Description :
//				Defines the CWbemDispatchMgr class, which implements the IDispatch
//				interfaces for Wbem Objects. The implementation is similar to a 
//				standard IDispatch, but there is an additional functionality ("dot notation") that allows
//				users to call into GetIDsOfNames() & Invoke() using an Wbem property name
//				or method name directly (although this is not a property or method of the CWbemObject class).
//
//	Part of :	WBEM automation interface layer
//
//  History:	
//		corinaf			4/3/98		Created
//		alanbos			03/21/00	Revised for Whistler
//
//***************************************************************************

#ifndef _CWBEMDISPMGR_H_
#define _CWBEMDISPMGR_H_

class CSWbemServices;
class CSWbemSecurity;
class CSWbemObject;
class CWbemSchemaIDCache;

//***************************************************************************
//
//  Class :	CWbemDispID
//
//  Description :
//			An encoded Dispatch ID for handling typelib, WMI schema
//			and custom interface DispId's.
//
//***************************************************************************
typedef unsigned long classCookie;

class CWbemDispID
{
private:
	DISPID		m_dispId;

	static unsigned long			s_dispIdCounter;

	// Static constants
	static const unsigned long		s_wmiDispIdTypeMask;
	static const unsigned long		s_wmiDispIdTypeStatic;
	static const unsigned long		s_wmiDispIdTypeSchema;

	static const unsigned long		s_wmiDispIdSchemaTypeMask;
	static const unsigned long		s_wmiDispIdSchemaTypeProperty;
	static const unsigned long		s_wmiDispIdSchemaTypeMethod;

	static const unsigned long		s_wmiDispIdSchemaElementIDMask;

public:
	CWbemDispID (void) : m_dispId (0) {}
	CWbemDispID (DISPID dispId) : m_dispId (dispId) {}
	CWbemDispID (const CWbemDispID & obj) : m_dispId (obj.m_dispId) {}

	virtual ~CWbemDispID (void) {}

	bool SetAsSchemaID (DISPID dispId, bool bIsProperty = true)
	{
		bool result = false;

		if (dispId <= s_wmiDispIdSchemaElementIDMask)
		{
			result = true;
			m_dispId = dispId;

			// Add the bits to identify as static
			m_dispId |= s_wmiDispIdTypeSchema;

			// Add a bit for the property
			if (bIsProperty)
				m_dispId |= s_wmiDispIdSchemaTypeMask;
		}

		return result;
	}

	bool IsStatic () const
	{ 
		return ((DISPID_NEWENUM == m_dispId) ||
				(DISPID_VALUE == m_dispId) ||
			s_wmiDispIdTypeStatic == (s_wmiDispIdTypeMask & m_dispId)); 
	}

	bool IsSchema () const
	{ 
		return (s_wmiDispIdTypeSchema == (s_wmiDispIdTypeMask & m_dispId)); 
	}

	bool IsSchemaProperty () const
	{
		return (s_wmiDispIdSchemaTypeProperty == (s_wmiDispIdSchemaTypeMask & m_dispId));
	}

	bool IsSchemaMethod () const
	{
		return (s_wmiDispIdSchemaTypeMethod == (s_wmiDispIdSchemaTypeMask & m_dispId));
	}

	DISPID GetStaticElementID () const
	{
		return m_dispId;
	}

	DISPID GetSchemaElementID () const
	{
		return m_dispId & s_wmiDispIdSchemaElementIDMask;
	}

	operator DISPID () const
	{
		return m_dispId;
	}

	bool operator < (const CWbemDispID & dispId) const
	{
		return (m_dispId < dispId.m_dispId);
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  BSTRless
//
//  DESCRIPTION:
//
//  Simple utility struct that provides an operator for use in a map based
//	on CComBSTR.  
//
//***************************************************************************

struct BSTRless : std::binary_function<CComBSTR, CComBSTR, bool>
{
	bool operator () (const CComBSTR& _X, const CComBSTR& _Y) const
	{
		bool result = false;

		if (_X.m_str && _Y.m_str)
			result = (_wcsicmp (_X.m_str, _Y.m_str) > 0);
		else 
		{
			// Treat any string as greater than NULL
			if (_X.m_str && !_Y.m_str)
				result = true;
		}

		return result;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  IIDless
//
//  DESCRIPTION:
//
//  Simple utility struct that provides an operator for use in a map based
//	on IID.  
//
//***************************************************************************

struct GUIDless : std::binary_function<GUID, GUID, bool>
{
	bool operator () (const GUID& _X, const GUID& _Y) const
	{
		RPC_STATUS rpcStatus;
		return (UuidCompare ((GUID*)&_X, (GUID*)&_Y, &rpcStatus) > 0);
	}
};

//***************************************************************************
//
//  Class :	CWbemDispatchMgr
//
//  Description :
//			Implements IDispatch for Wbem objects
//
//  Public Methods :
//			Constructor, Destructor
//			IDispatch Methods
//			
//	Public Data Members :
//
//***************************************************************************

class CWbemDispatchMgr
{
public:

    CWbemDispatchMgr(CSWbemServices *pWbemServices, 
					 CSWbemObject *pSWbemObject);

    ~CWbemDispatchMgr();

	//Dispatch methods

	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, 
								 LCID lcid, 
								 ITypeInfo FAR* FAR* pptinfo);

	STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, 
								   OLECHAR FAR* FAR* rgszNames, 
								   UINT cNames,
								   LCID lcid,
								   DISPID FAR* rgdispid);
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember,
							REFIID riid,
							LCID lcid,
							WORD wFlags,
							DISPPARAMS FAR* pdispparams,
							VARIANT FAR* pvarResult,
							EXCEPINFO FAR* pexcepinfo,
							UINT FAR* puArgErr);

	// IDispatchEx methods
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
	{ 
		UINT uArgErr;
		return Invoke(id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, &uArgErr); 
	}
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
	{ return S_FALSE; }
    
    // IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo (
		/* [out] */ ITypeInfo **ppTI 
	);

	// Other Methods
	void	RaiseException (HRESULT hr);
	void	SetNewObject (IWbemClassObject *pNewObject);

	IWbemClassObject	*GetObject ()
	{
		return m_pWbemObject;
	}

	IWbemClassObject	*GetClassObject ()
	{
		EnsureClassRetrieved ();
		return m_pWbemClass;
	}

	ISWbemObject		*GetSWbemObject ()
	{
		return (ISWbemObject *)m_pSWbemObject;
	}

private:

	HRESULT				m_hResult;
	
	IWbemClassObject	*m_pWbemObject;			//pointer to represented WBEM object
	CSWbemObject		*m_pSWbemObject;		//pointer to represented Scripting WBEM object 
	CSWbemServices		*m_pWbemServices;		//pointer to WBEM services
	IWbemClassObject	*m_pWbemClass;			//used when m_pWbemObject is an instance, to hold the
												//class definition for browsing method signatures
	ITypeInfo			*m_pTypeInfo;			//caches the type info pointer for the interface
	ITypeInfo			*m_pCTypeInfo;			//caches the type info pointer for the coclass

	CWbemSchemaIDCache	*m_pSchemaCache;		// cache of DISPID-Name bindings for WMI schema

	//Invokes a WBEM property get or put
	HRESULT InvokeWbemProperty(DISPID dispid, unsigned short wFlags, 
								  DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, 
								  EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr);

	//Invokes a WBEM method
	HRESULT InvokeWbemMethod(DISPID dispid, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult);

	//Helpers for WBEM method out parameter mapping
	HRESULT	MapReturnValue (VARIANT *pDest, VARIANT *pSrc);
	HRESULT	MapOutParameter (VARIANT *pDest, VARIANT *pSrc);
	HRESULT MapOutParameters (DISPPARAMS FAR* pdispparams, IWbemClassObject *pOutParameters,
								IWbemClassObject *pOutParamsInstance, VARIANT FAR* pvarResult);

	// Helpers for WBEM method in parameter mapping
	HRESULT MapInParameters (DISPPARAMS FAR* pdispparams, IWbemClassObject *pInParameters,
								IWbemClassObject **ppInParamsInstance);
	HRESULT MapInParameter (VARIANT FAR* pDest,	VARIANT FAR* pSrc, CIMTYPE lType);


	//Error handling
	HRESULT HandleError (DISPID dispidMember, unsigned short wFlags, DISPPARAMS FAR* pdispparams,
						 VARIANT FAR* pvarResult,UINT FAR* puArgErr,HRESULT hr);

	// Class retrieval
	void	EnsureClassRetrieved ();
};


#endif //_CWBEMDISPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	99999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CSWbemDateTime : public ISWbemDateTime,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:
			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime ()													{ m_uTime = INVALID_TIME ; }
			WBEMTime ( const SYSTEMTIME &st )							{ *this = st ; }

			const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
			const WBEMTime &operator= ( const FILETIME &ft ) ;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetDMTF ( SYSTEMTIME &st ) const;

			void Clear ( void )											{ m_uTime = INVALID_TIME ; }

			bool IsOk () const											{ return m_uTime != INVALID_TIME ? true : false; }
			
			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:
			ULONGLONG m_uTime;
	};

	CDispatchHelp		m_Dispatch;

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

	DWORD				m_dwSafetyOptions;

	// Records the least significant bit of a filetime
	DWORD				m_dw100nsOverflow;

protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemDateTime(void);
    virtual ~CSWbemDateTime(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemDateTime methods

    HRESULT STDMETHODCALLTYPE get_Value( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Value( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Year( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iYear;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Year( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_YEAR) || (value < WBEMDT_MIN_YEAR))
			hr = wbemErrValueOutOfRange;
		else
			m_iYear = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

    HRESULT STDMETHODCALLTYPE get_Month( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMonth;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Month( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MONTH) || (value < WBEMDT_MIN_MONTH))
			hr = wbemErrValueOutOfRange;
		else
			m_iMonth = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_Day( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iDay;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Day( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if (((VARIANT_TRUE == m_bIsInterval) && ((value > WBEMDT_MAX_DAYINT) || (value < WBEMDT_MIN_DAYINT))) ||
			((VARIANT_FALSE == m_bIsInterval) &&((value > WBEMDT_MAX_DAY) || (value < WBEMDT_MIN_DAY))))
			hr = wbemErrValueOutOfRange;
		else
			m_iDay = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_Hours( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iHours;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Hours( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_HOURS) || (value < WBEMDT_MIN_HOURS))
			hr = wbemErrValueOutOfRange;
		else
			m_iHours = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

		
	HRESULT STDMETHODCALLTYPE get_Minutes( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMinutes;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Minutes( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MINUTES) || (value < WBEMDT_MIN_MINUTES))
			hr = wbemErrValueOutOfRange;
		else
			m_iMinutes = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_Seconds( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iSeconds;
		return S_OK;
	}
        
    HRESULT STDMETHODCALLTYPE put_Seconds( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_SECONDS) || (value < WBEMDT_MIN_SECONDS))
			hr = wbemErrValueOutOfRange;
		else
			m_iSeconds = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_Microseconds( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMicroseconds;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Microseconds( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MICROSEC) || (value < WBEMDT_MIN_MICROSEC))
			hr = wbemErrValueOutOfRange;
		else
			m_iMicroseconds = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_UTC( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iUTC;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_UTC( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_UTC) || (value < WBEMDT_MIN_UTC))
			hr = wbemErrValueOutOfRange;
		else
			m_iUTC = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_YearSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bYearSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_YearSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bYearSpecified = value;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE get_MonthSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMonthSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_MonthSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMonthSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_DaySpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bDaySpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_DaySpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bDaySpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_HoursSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bHoursSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_HoursSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bHoursSpecified = value;
		return S_OK;
	}
		
	HRESULT STDMETHODCALLTYPE get_MinutesSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMinutesSpecified; 
		return S_OK;
	}
        
    HRESULT STDMETHODCALLTYPE put_MinutesSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMinutesSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_SecondsSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bSecondsSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_SecondsSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bSecondsSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_MicrosecondsSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMicrosecondsSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_MicrosecondsSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMicrosecondsSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_UTCSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bUTCSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_UTCSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bUTCSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_IsInterval( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bIsInterval; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_IsInterval( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_FALSE == value))
		{
			if (0 == m_iDay)
				m_iDay = 1;
			else if (WBEMDT_MAX_DAY < m_iDay)
				m_iDay = WBEMDT_MAX_DAY;
		}

		m_bIsInterval = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetVarDate( 
        /*[in]*/ VARIANT_BOOL bIsLocal,
		/*[out, retval]*/ DATE *dVarDate) ;
    
    HRESULT STDMETHODCALLTYPE SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) ;

	HRESULT STDMETHODCALLTYPE GetFileTime (
		/*[in, optional]*/ VARIANT_BOOL bIsLocal,
		/*[out, retval]*/ BSTR *strFileTime
	);
	
	HRESULT STDMETHODCALLTYPE SetFileTime (
		/*[in]*/ BSTR strFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal
	);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		if ((IID_IDispatch != riid) && (IID_ISWbemDateTime != riid))
			return E_NOINTERFACE;

		if (dwOptionSetMask & 
				~(INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER))
			return E_FAIL;

		m_dwSafetyOptions = (dwEnabledOptions & dwOptionSetMask);

		return S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if ((IID_IDispatch != riid) && (IID_ISWbemDateTime != riid))
			return E_NOINTERFACE;

		if (pdwSupportedOptions) *pdwSupportedOptions = 
				(INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER);
		if (pdwEnabledOptions) *pdwEnabledOptions = m_dwSafetyOptions;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemDateTime == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\enumobj.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectSet::CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectSet::CSWbemObjectSet(CSWbemServices *pService, 
								 IEnumWbemClassObject *pIEnumWbemClassObject,
								 CSWbemSecurity *pSecurity)
				: m_SecurityInfo (NULL),
				  m_bIsEmpty (false)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
						CLSID_SWbemObjectSet, L"SWbemObjectSet");
    m_cRef=0;
	m_firstEnumerator = true;
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		if (pSecurity)
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, pSecurity);
		else
		{
			pSecurity = m_pSWbemServices->GetSecurityInfo ();
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, pSecurity);

			if (pSecurity)
				pSecurity->Release ();
		}
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemObjectSet::CSWbemObjectSet (void)
				: m_SecurityInfo (NULL),
				  m_cRef (0),
				  m_firstEnumerator (true),
				  m_bIsEmpty (true),
				  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
						CLSID_SWbemObjectSet, L"SWbemObjectSet");
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemObjectSet::~CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectSet::~CSWbemObjectSet(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_SecurityInfo)
}

//***************************************************************************
// HRESULT CSWbemObjectSet::QueryInterface
// long CSWbemObjectSet::AddRef
// long CSWbemObjectSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectSet==riid)
		*ppv = (ISWbemObjectSet *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectSet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Reset ()
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Reset ();

			pIEnumWbemClassObject->Release ();

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Next (
	long lTimeout, 
	ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			*ppObject = NULL;

			IWbemClassObject *pIWbemClassObject = NULL;
			ULONG returned = 0;

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Next (lTimeout, 1, &pIWbemClassObject, &returned);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr) && (0 < returned) && pIWbemClassObject)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pIWbemClassObject,
															m_SecurityInfo);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppObject)))
					delete pObject;

				pIWbemClassObject->Release ();
			}
			else if (WBEM_S_TIMEDOUT == hr)
			{
				/*
				 * Since a timeout would be indistinguishable from an end-of-enumeration
				 * we flag it as a real error rather than an S-CODE.
				 */
				
				hr = wbemErrTimedout;
			}

			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Clone (
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			*ppEnum = NULL;
			IEnumWbemClassObject *pIWbemEnum = NULL;

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Clone (&pIWbemEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (WBEM_S_NO_ERROR == hr)
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (m_pSWbemServices, pIWbemEnum,
																m_SecurityInfo);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIWbemEnum->Release ();
			}
			
			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Skip
//
//  DESCRIPTION:
//
//  Skip over some objects in the enumeration
//
//  PARAMETERS:
//
//		lElements	Number of elements to skip
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Skip (
	ULONG lElements,
	long lTimeout
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Skip (lTimeout, lElements);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			/*
			 * Since a timeout would be indistinguishable from an end-of-enumeration
			 * we flag it as a real error rather than an S-CODE.
			 */
			if (WBEM_S_TIMEDOUT == hr)
				hr = wbemErrTimedout;

			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
//***************************************************************************
//
//  SCODE CSWbemObjectSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumVar	*pEnumVar = NULL;

		if (m_bIsEmpty)
		{
			if (!(pEnumVar = new CEnumVar ()))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			/*
			 * If this is the first enumerator, use ourselves as the underlying
			 * iterator.  Otherwise clone a copy and use that.
			 */

			if (m_firstEnumerator)
			{
				if (!(pEnumVar = new CEnumVar (this)))
					hr = WBEM_E_OUT_OF_MEMORY;
				else
					m_firstEnumerator = false;
			}
			else
			{
				CSWbemObjectSet *pNewEnum = NULL;

				/*
				 * Try to reset the cloned enumerator.  This may not always
				 * succeed, as some IEnumWbemClassObject's may not be
				 * rewindable.
				 */
				if (SUCCEEDED (CloneObjectSet (&pNewEnum)))
				{
					HRESULT hr2 = pNewEnum->Reset ();
	
					if (!(pEnumVar = new CEnumVar (pNewEnum)))
						hr = WBEM_E_OUT_OF_MEMORY;
	
					pNewEnum->Release ();
				}
			}
		}

		if (pEnumVar)
			if (FAILED(hr = pEnumVar->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
				delete pEnumVar;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_bIsEmpty)
			hr = WBEM_S_NO_ERROR;
		else if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				/* 
				 * Work out the current count - clone the object to avoid messing
				 * with the iterator.
				 */

				IEnumWbemClassObject *pNewEnum = NULL;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				{
					if (WBEM_S_NO_ERROR == pIEnumWbemClassObject->Clone (&pNewEnum))
					{
						// Secure the enumerator
						m_SecurityInfo->SecureInterface (pNewEnum);

						/*
						 * This will fail if the enumerator was created with the
						 * WBEM_FLAG_FORWARD_ONLY option.
						 */

						if (WBEM_S_NO_ERROR == pNewEnum->Reset ())
						{
							IWbemClassObject *pObject = NULL;
							ULONG lReturned = 0;
							HRESULT hrEnum;
						
							// Iterate through the enumerator to count the elements
							while (SUCCEEDED(hrEnum = pNewEnum->Next (INFINITE, 1, &pObject, &lReturned)))
							{
								if (0 == lReturned)
									break;			// We are done

								// Getting here means we have at least one object returned
								(*plCount) ++;
								pObject->Release ();
							}

							if (SUCCEEDED(hrEnum))
								hr = S_OK;
							else
								hr = hrEnum;
						}

						pNewEnum->Release ();
					}
				}

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				pIEnumWbemClassObject->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemObjectSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppObject) || (NULL == bsObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bIsEmpty)
	{
		CWbemPathCracker objectPath;

		if (objectPath = bsObjectPath)
		{
			if (m_SecurityInfo)
			{
				IEnumWbemClassObject *pIEnumWbemClassObject = 
									(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

				if (pIEnumWbemClassObject)
				{
					/* 
					 * Try to find the object - clone the object to avoid messing
					 * with the iterator.
					 */
					IEnumWbemClassObject *pNewEnum = NULL;

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;
			
					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (WBEM_S_NO_ERROR == pIEnumWbemClassObject->Clone (&pNewEnum))
						{
							// Secure the enumerator
							m_SecurityInfo->SecureInterface (pNewEnum);

							/*
							 * This will fail if the enumerator was created with the
							 * WBEM_FLAG_FORWARD_ONLY option.
							 */

							if (WBEM_S_NO_ERROR == pNewEnum->Reset ())
							{
								CComPtr<IWbemClassObject> pIWbemClassObject;
								ULONG lReturned = 0;
								bool found = false;
								hr = WBEM_E_NOT_FOUND;
								
								// Iterate through the enumerator to try to find the element with the
								// specified path.
								while (!found && 
										(WBEM_S_NO_ERROR == pNewEnum->Next (INFINITE, 1, &pIWbemClassObject, &lReturned)))
								{
									// Getting here means we have at least one object returned; check the
									// path

									if (CSWbemObjectPath::CompareObjectPaths (pIWbemClassObject, objectPath))
									{
										// Found it - assign to passed interface and break out
										found = true;
										CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, 
														pIWbemClassObject, m_SecurityInfo);

										if (!pObject)
											hr = WBEM_E_OUT_OF_MEMORY;
										else if (FAILED(pObject->QueryInterface (IID_ISWbemObject, 
												(PPVOID) ppObject)))
										{
											hr = WBEM_E_FAILED;
											delete pObject;
										}
									}
								}

								if (found)
									hr = S_OK;
							}
							
							pNewEnum->Release ();
						}
					}

					// Restore original privileges on this thread
					if (needToResetSecurity)
						m_SecurityInfo->ResetSecurity (hThreadToken);

					pIEnumWbemClassObject->Release ();
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::CloneObjectSet
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration, returning a coclass not an interface
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::CloneObjectSet (
	CSWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppEnum = NULL;

		if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
								(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				IEnumWbemClassObject *pIWbemEnum = NULL;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Clone (&pIWbemEnum);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);
				
				if (WBEM_S_NO_ERROR == hr)
				{
					*ppEnum = new CSWbemObjectSet (m_pSWbemServices, pIWbemEnum,
																	m_SecurityInfo);

					if (!(*ppEnum))
						hr = WBEM_E_OUT_OF_MEMORY;
					else
						(*ppEnum)->AddRef ();

					pIWbemEnum->Release ();
				}

				SetWbemError (m_pSWbemServices);

				pIEnumWbemClassObject->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\enumvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CEnumVar::CEnumVar
//
//  DESCRIPTION:
//
//  Constructors.
//
//***************************************************************************

CEnumVar::CEnumVar(CSWbemObjectSet *pObject)
{
	m_cRef=0;
	m_pEnumObject = pObject;
	m_pEnumObject->AddRef ();
	InterlockedIncrement(&g_cObj);
}

CEnumVar::CEnumVar(void)
{
	m_cRef=0;
	m_pEnumObject = NULL;
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumVar::~CEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumVar::~CEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pEnumObject)
}

//***************************************************************************
// HRESULT CEnumVar::QueryInterface
// long CEnumVar::AddRef
// long CEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumVar::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumVar::Reset ()
{
	HRESULT hr = S_FALSE;

	if (m_pEnumObject)
	{
		if (WBEM_S_NO_ERROR == m_pEnumObject->Reset ())
			hr = S_OK;

		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pEnumObject))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			ISWbemObject *pObject = NULL;
			
			if (SUCCEEDED(hr = m_pEnumObject->Next (INFINITE, &pObject)))
			{
				if (NULL == pObject)
				{
					break;
				}
				else
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the Next() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pObject;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;

		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pEnumObject)
		{
			CSWbemObjectSet *pEnum = NULL;
			if (WBEM_S_NO_ERROR == (hr = m_pEnumObject->CloneObjectSet (&pEnum)))
			{
				CEnumVar *pEnumVar = new CEnumVar (pEnum);

				if (!pEnumVar)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
					delete pEnumVar;

				pEnum->Release ();
			}

			SetWbemError (m_pEnumObject->GetSWbemServices ());
		}
		else
		{
			CEnumVar *pEnumVar = new CEnumVar;

			if (!pEnumVar)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
					delete pEnumVar;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVar::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pEnumObject)
	{
		hr = m_pEnumObject->Skip (cElements, INFINITE);
		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\enumpriv.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemPrivilegeSet::CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemPrivilegeSet::CSWbemPrivilegeSet()
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;
	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	const CSWbemPrivilegeSet &privSet,
	bool bMutable
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = bMutable;

	// Copy the contents of the supplied Privilege set to this set
	PrivilegeMap::const_iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		WbemPrivilegeEnum iPrivilege = (*next).first;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->AddRef ();

		m_PrivilegeMap.insert 
			(PrivilegeMap::value_type(iPrivilege, pPrivilege));

		next++;
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	ISWbemPrivilegeSet *pPrivilegeSet
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;

	// Copy the contents of the supplied Privilege set to this set
	if (pPrivilegeSet)
	{
		IUnknown *pUnk = NULL;

		if (SUCCEEDED(pPrivilegeSet->get__NewEnum (&pUnk)))
		{
			IEnumVARIANT	*pNewEnum = NULL;

			if (SUCCEEDED(pUnk->QueryInterface(IID_IEnumVARIANT, (void**) &pNewEnum)))
			{
				VARIANT var;
				VariantInit (&var);
				ULONG lFetched = 0;

				while (S_OK == pNewEnum->Next(1, &var, &lFetched))
				{
					if (VT_DISPATCH == V_VT(&var))
					{
						ISWbemPrivilege *pISWbemPrivilege = NULL;

						if (SUCCEEDED((var.pdispVal)->QueryInterface (IID_ISWbemPrivilege, 
										(void**) &pISWbemPrivilege)))
						{
							WbemPrivilegeEnum iPrivilege;
							VARIANT_BOOL	bIsEnabled;
							ISWbemPrivilege *pDummy = NULL;

							pISWbemPrivilege->get_Identifier (&iPrivilege);
							pISWbemPrivilege->get_IsEnabled (&bIsEnabled);

							if (SUCCEEDED (Add (iPrivilege, bIsEnabled, &pDummy)))
								pDummy->Release ();
							
							pISWbemPrivilege->Release ();
						}
					}

					VariantClear (&var);
				}

				VariantClear (&var);
				pNewEnum->Release ();
			}

			pUnk->Release ();
		}
	}
	InterlockedIncrement(&g_cObj);
}


//***************************************************************************
//
//  CSWbemPrivilegeSet::~CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemPrivilegeSet::~CSWbemPrivilegeSet(void)
{
	PrivilegeMap::iterator next; 
	
	while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		next = m_PrivilegeMap.erase (next);
		pPrivilege->Release ();
	}

	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::QueryInterface
// long CSWbemPrivilegeSet::AddRef
// long CSWbemPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilegeSet==riid)
		*ppv = (ISWbemPrivilegeSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilegeSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_PrivilegeMap.size ();
		hr = S_OK;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Item (
	WbemPrivilegeEnum iPrivilege,
    ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppPrivilege = NULL;
		PrivilegeMap::iterator theIterator;
		theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*theIterator).second;

			if (SUCCEEDED(pPrivilege->QueryInterface 
					(IID_ISWbemPrivilege, (PPVOID) ppPrivilege)))
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all items in the collection 
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::DeleteAll ()
{
	HRESULT hr = S_OK;

	ResetLastErrors ();

	if (m_bMutable)
	{
		PrivilegeMap::iterator next; 
		
		while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*next).second;
			next = m_PrivilegeMap.erase (next);
			pPrivilege->Release ();
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Remove
//
//  DESCRIPTION:
//
//  Remove the named item in the collection
//
//	PARAMETERS
//		bsName			Name of item to remove
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Remove (
	WbemPrivilegeEnum	iPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (m_bMutable)
	{
		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Found it - release and remove

			CSWbemPrivilege *pPrivilege = (*theIterator).second;
			m_PrivilegeMap.erase (theIterator);
			pPrivilege->Release ();
			hr = S_OK;
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Add
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Add (
	WbemPrivilegeEnum iPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_bMutable)
	{
		CSWbemPrivilege *pPrivilege = NULL;

		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Already there, so modify setting
			pPrivilege = (*theIterator).second;
			if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																	(PPVOID) ppPrivilege)))
			{
				pPrivilege->put_IsEnabled (bIsEnabled);
			}
		}
		else
		{
			/*
			 * Potential new element - first check it's 
			 * a valid Privilege name by getting it's LUID.
			 */
			LUID luid;
			TCHAR *tName = CSWbemPrivilege::GetNameFromId (iPrivilege);

			if (tName && CSWbemSecurity::LookupPrivilegeValue(tName, &luid))
			{
				// Super. Now add it to the map (note that constructor AddRef's)
				pPrivilege = new CSWbemPrivilege (iPrivilege, luid, 
					(bIsEnabled) ? true : false);

				if (!pPrivilege)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																		(PPVOID)ppPrivilege)))
				{
					m_PrivilegeMap.insert 
						(PrivilegeMap::value_type(iPrivilege, pPrivilege));
				}
				else
				{
					delete pPrivilege;
				}
			}
			else
			{
				DWORD dwLastError = GetLastError ();
				hr = wbemErrInvalidParameter;
			}
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::AddAsString
//
//  DESCRIPTION:
//
//  Add a new item to the collection; the privilege is specified by
//	an NT privilege string rather than a WbemPrivilegeEnum id.
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::AddAsString (
	BSTR bsPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = wbemErrInvalidParameter;

	ResetLastErrors ();

	// Map the string into a Privilege id
	WbemPrivilegeEnum	iPrivilege;

	if (CSWbemPrivilege::GetIdFromName (bsPrivilege, iPrivilege))
		hr = Add (iPrivilege, bIsEnabled, ppPrivilege);
	else
	{
		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::GetNumberOfDisabledElements
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

ULONG CSWbemPrivilegeSet::GetNumberOfDisabledElements ()
{
	ULONG lNum = 0;

	PrivilegeMap::iterator next = m_PrivilegeMap.begin ();

	while (next != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		VARIANT_BOOL bValue;

		if (SUCCEEDED(pPrivilege->get_IsEnabled (&bValue)) && (VARIANT_FALSE == bValue))
			lNum++;
	
		next++;
	}

	return lNum;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Remove all items from the set and reinstantiate with 
//	a copy of the items in the input privilege set
//
//***************************************************************************

void CSWbemPrivilegeSet::Reset (CSWbemPrivilegeSet &privSet)
{
	DeleteAll ();

	PrivilegeMap::iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		VARIANT_BOOL bIsEnabled;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->get_IsEnabled (&bIsEnabled);

		ISWbemPrivilege *pDummy = NULL;

		if (SUCCEEDED (Add ((*next).first, bIsEnabled, &pDummy)))
			pDummy->Release ();

		next++;
	}
}


// CEnumPrivilegeSet Methods

//***************************************************************************
//
//  CEnumPrivilegeSet::CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->AddRef ();
		m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	}

	InterlockedIncrement(&g_cObj);
}

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet,
							 PrivilegeMap::iterator iterator) :
		m_Iterator (iterator)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->AddRef ();
	}
	
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumPrivilegeSet::~CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumPrivilegeSet::~CEnumPrivilegeSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CEnumPrivilegeSet::QueryInterface
// long CEnumPrivilegeSet::AddRef
// long CEnumPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Reset ()
{
	HRESULT hr = S_FALSE;

	if (m_pPrivilegeSet)
	{
		m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pPrivilegeSet))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
			{
				CSWbemPrivilege *pSWbemPrivilege = (*m_Iterator).second;
				m_Iterator++;

				ISWbemPrivilege *pISWbemPrivilege = NULL;

				if (SUCCEEDED(pSWbemPrivilege->QueryInterface 
						(IID_ISWbemPrivilege, (PPVOID) &pISWbemPrivilege)))
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the QI() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pISWbemPrivilege;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pPrivilegeSet)
		{
			CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (m_pPrivilegeSet, m_Iterator);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pPrivilegeSet)
	{
		ULONG l2;

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
				m_Iterator++;
			else
				break;
		}

		if (l2 == cElements)
			hr = S_OK;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\disphlp.h ===
//***************************************************************************
//
//  cdisphlp.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CDispatchHelper object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _disphlp_H_
#define _disphlp_H_

// This class implements the IDispatch interface using a type library.

class CDispatchHelp
{
private:
	BSTR				m_objectName;
	HRESULT				m_hResult;	// Last HRESULT returned from CIMOM call

protected:
        ITypeInfo      *m_pITINeutral;      //Type information for interface
		ITypeInfo	   *m_pCITINeutral;		//Type information for class
        IDispatch      *m_pObj;
        GUID            m_iGUID;			// Interface GUID
		GUID            m_cGUID;			// Class GUID
		
		/*
		 * May be overriden in subclass to provide bespoke 
		 * handling of exceptions.
		 */
		virtual HRESULT HandleError (
							DISPID dispidMember,
							unsigned short wFlags,
							DISPPARAMS FAR* pdispparams,
							VARIANT FAR* pvarResult,
							UINT FAR* puArgErr,
							HRESULT hRes)
		{
			return hRes;
		}

		/*
		 * May be overriden in subclass to provide
		 * bespoke handling of VT_NULL dispparams.
		 */
		virtual bool HandleNulls (
							DISPID dispidMember,
							unsigned short wFlags)
		{
			// By default treat a VT_NULL as a default
			// value in all methods.
			return 	(wFlags & DISPATCH_METHOD);
		}

public:
        CDispatchHelp();
        virtual ~CDispatchHelp(void);
        void SetObj(IDispatch * pObj, GUID interfaceGuid, 
						GUID classGuid, LPWSTR objectName);
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    	STDMETHOD(GetTypeInfo)(
      		THIS_
		UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

	// IDispatchEx methods
        HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
		{ 
			UINT uArgErr;
			return Invoke(id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, &uArgErr); 
		}
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
		{ return S_FALSE; }

    // IProvideClassInfo methods
		HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);


	// Other methods
	void RaiseException (HRESULT hr);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\events.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemEventSource::CSWbemEventSource
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemEventSource::CSWbemEventSource(
	CSWbemServices *pService, 
	IEnumWbemClassObject *pIEnumWbemClassObject)
{
	m_Dispatch.SetObj (this, IID_ISWbemEventSource, 
					CLSID_SWbemEventSource, L"SWbemEventSource");
    m_cRef=0;
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

		if (pSecurity)
		{
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, 
									pSecurity);
			pSecurity->Release ();
		}
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemEventSource::~CSWbemEventSource
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemEventSource::~CSWbemEventSource(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_SecurityInfo)
		m_SecurityInfo->Release ();
}

//***************************************************************************
// HRESULT CSWbemEventSource::QueryInterface
// long CSWbemEventSource::AddRef
// long CSWbemEventSource::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemEventSource::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemEventSource==riid)
		*ppv = (ISWbemEventSource*)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
        *ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemEventSource::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemEventSource::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemEventSource::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemEventSource::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemEventSource == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemEventSource::NextEvent
//
//  DESCRIPTION:
//
//  Get the next event, or timeout
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or wbemTimeoutInfinite for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemEventSource::NextEvent (
	long lTimeout, 
	ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppObject = NULL;

		if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
								(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				IWbemClassObject *pIWbemClassObject = NULL;
				ULONG returned = 0;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Next (lTimeout, 1, &pIWbemClassObject, &returned);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				if (SUCCEEDED(hr) && (0 < returned) && pIWbemClassObject)
				{
					CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pIWbemClassObject,
													m_SecurityInfo);

					if (!pObject)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
											(PPVOID) ppObject)))
						delete pObject;

					pIWbemClassObject->Release ();
				}
				else if (WBEM_S_TIMEDOUT == hr)
				{
					/*
					 * Since a timeout would be indistinguishable from an end-of-enumeration
					 * in automation terms we flag it as a real error rather than an S-CODE.
					 */
					
					hr = wbemErrTimedout;
				}

				SetWbemError (m_pSWbemServices);
				pIEnumWbemClassObject->Release ();
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemEventSource::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemEventSource::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\enumvar.h ===
//***************************************************************************
//
//  enumvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CEnumVariant object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _ENUMVAR_H_
#define _ENUMVAR_H_

// This class implements the IEnumVARIANT interface

class CEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemObjectSet	*m_pEnumObject;

public:
	CEnumVar (CSWbemObjectSet *pEnumObject);
	CEnumVar (void);		// Empty enumerator
	virtual ~CEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\error.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ERROR.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the WBEM error cache implementation
//
//***************************************************************************

#include "precomp.h"

#define NULLBSTR(x) \
		SysFreeString (x);\
		x = NULL;

#define FREECOAUTH(x) \
		if (x)\
		{\
			WbemFreeAuthIdentity (x);\
			x = NULL;\
		}


//***************************************************************************
//
// CWbemErrorCache::CWbemErrorCache
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemErrorCache::CWbemErrorCache ()
{
	InitializeCriticalSection (&m_cs);
	headPtr = NULL;
}

//***************************************************************************
//
// CWbemErrorCache::~CWbemErrorCache
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemErrorCache::~CWbemErrorCache ()
{
	EnterCriticalSection (&m_cs);
	
	ThreadError	*pPtr = headPtr;

	while (pPtr)
	{
		if (pPtr->pErrorObject)
		{
			pPtr->pErrorObject->Release ();
			pPtr->pErrorObject = NULL;
		}

		if (pPtr->pService)
		{
			pPtr->pService->Release ();
			pPtr->pService = NULL;
		}

		NULLBSTR (pPtr->strNamespacePath);
		NULLBSTR (pPtr->strAuthority);
		NULLBSTR (pPtr->strPrincipal);
		FREECOAUTH (pPtr->pCoAuthIdentity)
		
		ThreadError *pTmp = pPtr;
		pPtr = pPtr->pNext;
		delete pTmp;
	}

	headPtr = NULL;

	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
//
// CWbemErrorCache::GetAndResetCurrentThreadError
//
// DESCRIPTION:
//
// Extract the WBEM error object (if any) from the current thread.  This
// is a once-only operation as the entry for that thread is cleared by this
// read.
//
//***************************************************************************

CSWbemObject *CWbemErrorCache::GetAndResetCurrentThreadError ()
{
	CSWbemObject *pObject = NULL;
	DWORD threadId = GetCurrentThreadId ();
	
	EnterCriticalSection (&m_cs);

	ThreadError	*pPtr = headPtr;

	while (pPtr)
	{
		if (threadId == pPtr->dwThreadId)
		{
			if (pPtr->pErrorObject)
			{
				CSWbemServices *pService = NULL;

				// Try and create a services object
				if (pPtr->pService)
				{
					pService = new CSWbemServices (pPtr->pService, pPtr->strNamespacePath,
											pPtr->pCoAuthIdentity, pPtr->strPrincipal,
											pPtr->strAuthority);

					if (pService)
						pService->AddRef ();
				}

				if (pPtr->pService)
				{
					pPtr->pService->Release ();
					pPtr->pService = NULL;
				}

				NULLBSTR (pPtr->strNamespacePath);
				NULLBSTR (pPtr->strAuthority);
				NULLBSTR (pPtr->strPrincipal);
				FREECOAUTH (pPtr->pCoAuthIdentity)

				pObject = new CSWbemObject (pService, pPtr->pErrorObject, NULL, true);
				pPtr->pErrorObject->Release ();
				pPtr->pErrorObject = NULL;

				if (pService)
					pService->Release ();

				// Unhook and delete the ThreadError

				if (pPtr == headPtr)
					headPtr = pPtr->pNext;

				if (pPtr->pNext)
					pPtr->pNext->pPrev = pPtr->pPrev;

				if (pPtr->pPrev)
					pPtr->pPrev->pNext = pPtr->pNext;

				delete pPtr;
			}

			break;
		}

		pPtr = pPtr->pNext;
	}


	LeaveCriticalSection (&m_cs);

	return pObject;
}

//***************************************************************************
//
// CWbemErrorCache::SetCurrentThreadError
//
// DESCRIPTION:
//
// Set the WBEM error object (if any) for the current thread.
//
//***************************************************************************

void CWbemErrorCache::SetCurrentThreadError (CSWbemServices *pService)
{
	IErrorInfo * pInfo = NULL;
    
	if(SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo)
	{
		// Is this a WBEM Error Object?
		IWbemClassObject * pObj = NULL;
			
		if(SUCCEEDED(pInfo->QueryInterface(IID_IWbemClassObject, (void **)&pObj)) && pObj)
		{
			DWORD threadId = GetCurrentThreadId ();
			EnterCriticalSection (&m_cs);

			ThreadError	*pPtr = headPtr;

			// Find the current entry (if any)

			while (pPtr)
			{
				if (threadId == pPtr->dwThreadId)
					break;
				
				pPtr = pPtr->pNext;
			}
			// Have a new error object - chain it into the list
			if (!pPtr)
			{
				// No entry for this thread - create one at the head
				ThreadError *pTmp = headPtr;
				headPtr = new ThreadError;

				if (headPtr)
				{
					headPtr->pPrev = NULL;
					headPtr->pNext = pTmp;

					if (pTmp)
						pTmp->pPrev = headPtr;

					headPtr->dwThreadId = threadId;
					headPtr->pErrorObject = pObj;
					headPtr->pService = NULL;
					headPtr->strAuthority = NULL;
					headPtr->strPrincipal = NULL;
					headPtr->pCoAuthIdentity = NULL;
					headPtr->strNamespacePath = NULL;

					if (pService)
					{
						headPtr->pService = pService->GetIWbemServices ();
						CSWbemSecurity *pSecurity = pService->GetSecurityInfo ();

						if (pSecurity)
						{
							headPtr->strAuthority = SysAllocString (pSecurity->GetAuthority ());
							headPtr->strPrincipal = SysAllocString (pSecurity->GetPrincipal ());
							headPtr->pCoAuthIdentity = pSecurity->GetCoAuthIdentity ();
							pSecurity->Release ();
						}

						headPtr->strNamespacePath = SysAllocString(pService->GetPath ());
					}
				}
			}
			else
			{
				// pPtr addresses the current entry for the thread
				/***************************************************
				* We should not actually do this any more as we 
				* remove the entry both when it is read and at the
				* start of the API call.  So at this point there should
				* not be any entries left for this thread
				****************************************************/
				if (pPtr->pErrorObject)
					pPtr->pErrorObject->Release ();
				
				pPtr->pErrorObject = pObj;

				if (pPtr->pService)
				{
					pPtr->pService->Release ();
					pPtr->pService = NULL;
				}

				NULLBSTR (pPtr->strNamespacePath);
				NULLBSTR (pPtr->strAuthority);
				NULLBSTR (pPtr->strPrincipal);
				FREECOAUTH (pPtr->pCoAuthIdentity)

				if (pService)
				{
					pPtr->pService = pService->GetIWbemServices ();
					
					CSWbemSecurity *pSecurity = pService->GetSecurityInfo ();

					if (pSecurity)
					{
						pPtr->strAuthority = SysAllocString (pSecurity->GetAuthority ());
						pPtr->strPrincipal = SysAllocString (pSecurity->GetPrincipal ());
						pPtr->pCoAuthIdentity = pSecurity->GetCoAuthIdentity ();
						pSecurity->Release ();
					}

					pPtr->strNamespacePath = SysAllocString(pService->GetPath ());
				}
			}
			LeaveCriticalSection (&m_cs);
		}

		pInfo->Release ();				// To balance the GetErrorInfo call
	}
}

//***************************************************************************
//
// CWbemErrorCache::ResetCurrentThreadError
//
// DESCRIPTION:
//
// If there is an entry for the current thread then remove it
//
//***************************************************************************

void CWbemErrorCache::ResetCurrentThreadError ()
{
	DWORD threadId = GetCurrentThreadId ();
	EnterCriticalSection (&m_cs);

	ThreadError	*pPtr = headPtr;

	// Find the current entry (if any)

	while (pPtr)
	{
		if (threadId == pPtr->dwThreadId)
			break;
		
		pPtr = pPtr->pNext;
	}

	if (pPtr)
	{
		// pPtr addresses the current entry for the thread
		if (pPtr->pErrorObject)
		{
			pPtr->pErrorObject->Release ();
			pPtr->pErrorObject = NULL;
		}
		

		if (pPtr->pService)
		{
			pPtr->pService->Release ();
			pPtr->pService = NULL;
		}

		NULLBSTR (pPtr->strNamespacePath);
		NULLBSTR (pPtr->strAuthority);
		NULLBSTR (pPtr->strPrincipal);
		FREECOAUTH (pPtr->pCoAuthIdentity)

		// Unhook and delete the ErrorInfo

		if (pPtr == headPtr)
			headPtr = pPtr->pNext;

		if (pPtr->pNext)
			pPtr->pNext->pPrev = pPtr->pPrev;

		if (pPtr->pPrev)
			pPtr->pPrev->pNext = pPtr->pNext;

		delete pPtr;
	}


	LeaveCriticalSection (&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\error.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  error.h
//
//  alanbos  29-Jun-98   Created.
//
//  Error record handling object
//
//***************************************************************************

#ifndef _ERROR_H_
#define _ERROR_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemErrorCache
//
//  DESCRIPTION:
//
//  Holds WBEM-style "last errors" on threads
//
//***************************************************************************

class CWbemErrorCache 
{
private:

	CRITICAL_SECTION		m_cs;

	typedef struct ThreadError
	{
		ThreadError			*pNext;
		ThreadError			*pPrev;
		DWORD				dwThreadId;	
		COAUTHIDENTITY		*pCoAuthIdentity;
		BSTR				strAuthority;
		BSTR				strPrincipal;
		BSTR				strNamespacePath;
		IWbemServices		*pService;
		IWbemClassObject	*pErrorObject;
	} ThreadError;


	ThreadError				*headPtr;
		
public:

    CWbemErrorCache ();
    virtual ~CWbemErrorCache ();
    
	CSWbemObject	*GetAndResetCurrentThreadError ();
	void			SetCurrentThreadError (CSWbemServices *pService);
	void			ResetCurrentThreadError ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\locator.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  locator.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemLocator definition.
//
//***************************************************************************

#ifndef _LOCATOR_H_
#define _LOCATOR_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemLocator
//
//  DESCRIPTION:
//
//  Implements the IWbemSLocator interface.  This class is what the client gets
//  when it initially hooks up to the Wbemprox.dll.  The ConnectServer function
//  is what get the communication between client and server started.
//
//***************************************************************************


class CSWbemLocator : public ISWbemLocator,
					  public IDispatchEx,
					  public IObjectSafety,
					  public ISupportErrorInfo,
					  public IProvideClassInfo
{
private:

	CWbemLocatorSecurity	*m_SecurityInfo;
	CComPtr<IWbemLocator>	m_pIWbemLocator;
	CDispatchHelp			m_Dispatch;		
	IServiceProvider		*m_pIServiceProvider;
	IUnsecuredApartment		*m_pUnsecuredApartment;

	static wchar_t			*s_pDefaultNamespace;

	static BSTR				BuildPath (BSTR Server, BSTR Namespace);
	static const wchar_t	*GetDefaultNamespace ();
	
protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemLocator(CSWbemPrivilegeSet *pPrivilegeSet = NULL);
	CSWbemLocator(CSWbemLocator &csWbemLocator);
    ~CSWbemLocator(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
    
	// ISWbemLocator methods

	HRESULT STDMETHODCALLTYPE  ConnectServer
	(
	    /*[in]*/	BSTR Server,           
        /*[in]*/   	BSTR Namespace,        
        /*[in]*/	BSTR User,
        /*[in]*/	BSTR Password,
		/*[in]*/   	BSTR Locale,
        /*[in]*/   	BSTR Authority,
		/*[in]*/	long lSecurityFlags,
        /*[in]*/ 	/*ISWbemNamedValueSet*/ IDispatch *pContext,
		/*[out]*/	ISWbemServices 	**ppNamespace
    );

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	static void				Shutdown ()
	{
		if (s_pDefaultNamespace)
		{
			delete [] s_pDefaultNamespace;
			s_pDefaultNamespace = NULL;
		}
	}

	CWbemLocatorSecurity	*GetSecurityInfo ()
	{
		return m_SecurityInfo;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\locator.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  LOCATOR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemLocator
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

#define WBEMS_DEFAULT_SERVER	L"."

extern CRITICAL_SECTION g_csErrorCache;
wchar_t *CSWbemLocator::s_pDefaultNamespace = NULL;

//***************************************************************************
//
//  CSWbemLocator::CSWbemLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemLocator::CSWbemLocator(CSWbemPrivilegeSet *pPrivilegeSet) :
		m_pUnsecuredApartment (NULL),
		m_pIServiceProvider (NULL),	
		m_cRef (0)
{
	// Initialize the underlying locators
	HRESULT result = CoCreateInstance(CLSID_WbemLocator, 0,
				CLSCTX_INPROC_SERVER, IID_IWbemLocator,
				(LPVOID *) &m_pIWbemLocator);

	EnsureGlobalsInitialized () ;

	m_Dispatch.SetObj((ISWbemLocator *)this, IID_ISWbemLocator,
						CLSID_SWbemLocator, L"SWbemLocator");

	m_SecurityInfo = new CWbemLocatorSecurity (pPrivilegeSet);

	if (m_SecurityInfo)
	{
		// Set the impersonation level by default in the locator - note
		// that this must be done after EnsureGlobalsInitialized is called
		m_SecurityInfo->put_ImpersonationLevel (CSWbemSecurity::GetDefaultImpersonationLevel ());
	}

    InterlockedIncrement(&g_cObj);
}

CSWbemLocator::CSWbemLocator(CSWbemLocator & csWbemLocator) :
		m_pUnsecuredApartment (NULL),
		m_pIServiceProvider (NULL),
		m_cRef (0)
{
	_RD(static char *me = "CSWbemLocator::CSWbemLocator()";)
	// This is a smart COM pointers so no explicit AddRef required
    m_pIWbemLocator = csWbemLocator.m_pIWbemLocator;
	
	m_Dispatch.SetObj((ISWbemLocator *)this,IID_ISWbemLocator,
						CLSID_SWbemLocator, L"SWbemLocator");
	m_SecurityInfo = new CWbemLocatorSecurity (csWbemLocator.m_SecurityInfo);

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemLocator::~CSWbemLocator
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemLocator::~CSWbemLocator(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_SecurityInfo)
	RELEASEANDNULL(m_pUnsecuredApartment)
}

//***************************************************************************
// HRESULT CSWbemLocator::QueryInterface
// long CSWbemLocator::AddRef
// long CSWbemLocator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemLocator::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemLocator==riid)
		*ppv = (ISWbemLocator *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)((ISWbemLocator *)this);
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemLocator::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemLocator::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemLocator::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemLocator::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  m_Dispatch.GetTypeInfoCount(pctinfo);}
STDMETHODIMP		CSWbemLocator::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemLocator::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
STDMETHODIMP		CSWbemLocator::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemLocator::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid);}
STDMETHODIMP		CSWbemLocator::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemLocator::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
					pdispparams, pvarResult, pexcepinfo, puArgErr);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemLocator::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemLocator::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetDispID(bstrName, grfdex, pid);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemLocator::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemLocator::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	/*
	 * Store away the service provider so that it can be accessed
	 * by calls that remote to CIMOM
	 */
	m_pIServiceProvider = pspCaller;

	hr = m_Dispatch.InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);

	m_pIServiceProvider = NULL;

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemLocator::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemLocator::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByDispID(id);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemLocator::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberProperties(id, grfdexFetch, pgrfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemLocator::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberName(id, pbstrName);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemLocator::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemLocator::GetNextDispID()";)
	HRESULT rc = S_FALSE;

	_RPrint(me, "Called", 0, "");
	if ((grfdex & fdexEnumAll) && pid) {
		if (DISPID_STARTENUM == id) {
			*pid = 1;
			rc = S_OK;
		} else if (1 == id) {
			*pid = 2;
		}
	}

	return rc;

}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemLocator::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetNameSpaceParent(ppunk);
}


//***************************************************************************
// HRESULT CSWbemLocator::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemLocator::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemLocator == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Initiate connection to namespace
//
//  PARAMETERS:
//
//	bsServer				The Server to which to connect
//	bsNamespace				The namespace to connect to (default is reg lookup)
//  bsUser					The user ("" implies default to logged-on user)
//  bsPassword				The password ("" implies default to logged-on user's
//							password if bsUser == "")
//	bsLocale				Requested locale
//	bsAuthority				Authority
//	lSecurityFlags			Currently 0 by default
//	pContext				If non-null, extra context info for the connection
//	ppNamespace				On successful return addresses the IWbemSServices
//								connection to the namespace.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemLocator::ConnectServer (
	BSTR bsServer,
    BSTR bsNamespace,
    BSTR bsUser,
	BSTR bsPassword,
	BSTR bsLocale,
    BSTR bsAuthority,
	long lSecurityFlags,
    /*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemServices 	**ppNamespace
)
{
	_RD(static char *me = "CSWbemLocator::ConnectServer";)
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamespace)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemLocator && m_SecurityInfo)
	{
		bool useDefaultUser = (NULL == bsUser) || (0 == wcslen(bsUser));
		bool useDefaultAuthority = (NULL != bsAuthority) && (0 == wcslen (bsAuthority));

		// Build the namespace path
		BSTR bsNamespacePath = BuildPath (bsServer, bsNamespace);

		// Get the context
		IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

		// Connect to the requested namespace
		IWbemServices	*pIWbemService = NULL;

		bool needToResetSecurity = false;
		HANDLE hThreadToken = NULL;

		if (m_SecurityInfo->SetSecurity (bsUser, needToResetSecurity, hThreadToken))
			hr = m_pIWbemLocator->ConnectServer (
				bsNamespacePath,
				(useDefaultUser) ? NULL : bsUser,
				(useDefaultUser) ? NULL : bsPassword,
				((NULL != bsLocale) && (0 < wcslen (bsLocale))) ? bsLocale : NULL,
				lSecurityFlags,
				(useDefaultAuthority) ? NULL : bsAuthority,
				pIContext,
				&pIWbemService);

		if (needToResetSecurity)
			m_SecurityInfo->ResetSecurity (hThreadToken);

		if (WBEM_S_NO_ERROR == hr)
		{
			// Create a new CSWbemServices using the IWbemServices interface
			// just returned.  This will AddRef pIWbemService.

			CSWbemServices *pService =
					new CSWbemServices (
							pIWbemService,
							bsNamespacePath,
							((NULL != bsAuthority) && (0 < wcslen (bsAuthority))) ? bsAuthority : NULL,
							(useDefaultUser) ? NULL : bsUser,
							(useDefaultUser) ? NULL : bsPassword,
							m_SecurityInfo,
							((NULL != bsLocale) && (0 < wcslen (bsLocale))) ? bsLocale : NULL
						);

			if (!pService)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pService->QueryInterface (IID_ISWbemServices,
										(PPVOID) ppNamespace)))
				delete pService;

			pIWbemService->Release ();
		}

		if (NULL != pIContext)
			pIContext->Release ();

		SysFreeString (bsNamespacePath);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::BuildPath
//
//  DESCRIPTION:
//
//  Build a namespace path from a server and namespace
//
//  PARAMETERS:
//
//	bsServer				The Server to which to connect
//	bsNamespace				The namespace to connect to (default is reg lookup)
//
//  RETURN VALUES:
//
//	The fully-formed namespace path
//
//***************************************************************************

BSTR CSWbemLocator::BuildPath (BSTR bsServer, BSTR bsNamespace)
{
	BSTR namespacePath = NULL;
	bool ok = false;
	CComBSTR bsPath;

	if ((NULL == bsServer) || (0 == wcslen(bsServer)))
		bsServer = WBEMS_DEFAULT_SERVER;

	// Use the default namespace if none supplied
	if ((NULL == bsNamespace) || (0 == wcslen(bsNamespace)))
	{
		const wchar_t *defaultNamespace = GetDefaultNamespace ();

		if (defaultNamespace)
		{
			CWbemPathCracker pathCracker;
			pathCracker.SetServer (bsServer);
			pathCracker.SetNamespacePath (defaultNamespace);
			ok = pathCracker.GetPathText (bsPath, false, true);
		}
	}
	else
	{
		CWbemPathCracker pathCracker;
		pathCracker.SetServer (bsServer);
		pathCracker.SetNamespacePath (bsNamespace);
		ok = pathCracker.GetPathText (bsPath, false, true);
	}

	if (ok)
		namespacePath = bsPath.Detach ();

	return namespacePath;
}


//***************************************************************************
//
//  SCODE CSWbemLocator::GetDefaultNamespace
//
//  DESCRIPTION:
//
//		Get the default namespace path
//
//  PARAMETERS:
//
//		None
//
//  RETURN VALUES:
//
//		The default Namespace.
//
//***************************************************************************

const wchar_t *CSWbemLocator::GetDefaultNamespace ()
{
	if (!s_pDefaultNamespace)
	{
		// Get the value from the registry key
		HKEY hKey;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					WBEMS_RK_SCRIPTING, 0, KEY_QUERY_VALUE, &hKey))
		{
			DWORD dataLen = 0;

			// Find out how much space to allocate first
			if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFNS,
						NULL, NULL, NULL,  &dataLen))
			{
				TCHAR *defNamespace = new TCHAR [dataLen];

				if (defNamespace)
				{
					if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFNS,
							NULL, NULL, (LPBYTE) defNamespace,  &dataLen))
					{
#ifndef UNICODE
						// Convert the multibyte value to its wide character equivalent
						int wDataLen = MultiByteToWideChar(CP_ACP, 0, defNamespace, -1, NULL, 0);
						s_pDefaultNamespace = new wchar_t [wDataLen];

						if (s_pDefaultNamespace)
							MultiByteToWideChar(CP_ACP, 0, defNamespace, -1, s_pDefaultNamespace, wDataLen);
#else
						s_pDefaultNamespace = new wchar_t [wcslen (defNamespace) + 1];

						if (s_pDefaultNamespace)
							wcscpy (s_pDefaultNamespace, defNamespace);
#endif
					}

					delete [] defNamespace;
				}
			}

			RegCloseKey (hKey);
		}

		// If we failed to read the registry OK, just use the default
		if (!s_pDefaultNamespace)
		{
#ifndef UNICODE
			int wDataLen = MultiByteToWideChar(CP_ACP, 0, WBEMS_DEFNS, -1, NULL, 0);
			s_pDefaultNamespace = new wchar_t [wDataLen];

			if (s_pDefaultNamespace)
				MultiByteToWideChar(CP_ACP, 0, WBEMS_DEFNS, -1, s_pDefaultNamespace, wDataLen);
#else
			s_pDefaultNamespace = new wchar_t [wcslen (WBEMS_DEFNS) + 1];

			if (s_pDefaultNamespace)
				wcscpy (s_pDefaultNamespace, WBEMS_DEFNS);
#endif
		}
	}

	return s_pDefaultNamespace;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemLocator::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			if (SUCCEEDED (m_SecurityInfo->QueryInterface (IID_ISWbemSecurity,
											(PPVOID) ppSecurity)))
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\events.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  events.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemEventSource definition
//
//***************************************************************************

#ifndef _EVENTS_H_
#define _EVENTS_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemEventSource
//
//  DESCRIPTION:
//
//  Implements the ISWbemEventSource interface.  
//
//***************************************************************************

class CSWbemEventSource : public ISWbemEventSource,
						  public ISupportErrorInfo,
						  public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemEventSource (CSWbemServices *pService, IEnumWbemClassObject *pEnum);
    ~CSWbemEventSource (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemEventSource methods

	HRESULT STDMETHODCALLTYPE NextEvent 
	(
		/* [in]  */ long iTimeout,
		/* [out] */ ISWbemObject **objEvent
	);

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\maindll.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"
#include "initguid.h"

// SWbemLocator registry strings
#define WBEMS_LOC_DESCRIPTION	_T("WBEM Scripting Locator")
#define WBEMS_LOC_PROGID		_T("WbemScripting.SWbemLocator")
#define WBEMS_LOC_PROGIDVER		_T("WbemScripting.SWbemLocator.1")
#define WBEMS_LOC_VERSION		_T("1.0")
#define WBEMS_LOC_VERDESC		_T("WBEM Scripting Locator 1.0")

// SWbemNamedValueSet registry strings
#define WBEMS_CON_DESCRIPTION	_T("WBEM Scripting Named Value Collection")
#define WBEMS_CON_PROGID		_T("WbemScripting.SWbemNamedValueSet")
#define WBEMS_CON_PROGIDVER		_T("WbemScripting.SWbemNamedValueSet.1")
#define WBEMS_CON_VERSION		_T("1.0")
#define WBEMS_CON_VERDESC		_T("WBEM Scripting Named Value Collection 1.0")

// SWbemObjectPath registry settings
#define WBEMS_OBP_DESCRIPTION	_T("WBEM Scripting Object Path")
#define WBEMS_OBP_PROGID		_T("WbemScripting.SWbemObjectPath")
#define WBEMS_OBP_PROGIDVER		_T("WbemScripting.SWbemObjectPath.1")
#define WBEMS_OBP_VERSION		_T("1.0")
#define WBEMS_OBP_VERDESC		_T("WBEM Scripting Object Path 1.0")

// SWbemParseDN registry settings
#define WBEMS_PDN_DESCRIPTION	_T("Wbem Scripting Object Path")
#define WBEMS_PDN_PROGID		_T("WINMGMTS")
#define WBEMS_PDN_PROGIDVER		_T("WINMGMTS.1")
#define WBEMS_PDN_VERSION		_T("1.0")
#define WBEMS_PDN_VERDESC		_T("Wbem Object Path 1.0")

// SWbemLastError registry settings
#define WBEMS_LER_DESCRIPTION	_T("Wbem Scripting Last Error")
#define WBEMS_LER_PROGID		_T("WbemScripting.SWbemLastError")
#define WBEMS_LER_PROGIDVER		_T("WbemScripting.SWbemLastError.1")
#define WBEMS_LER_VERSION		_T("1.0")
#define WBEMS_LER_VERDESC		_T("Wbem Last Error 1.0")

// SWbemSink registry strings
#define WBEMS_SINK_DESCRIPTION	_T("WBEM Scripting Sink")
#define WBEMS_SINK_PROGID		_T("WbemScripting.SWbemSink")
#define WBEMS_SINK_PROGIDVER	_T("WbemScripting.SWbemSink.1")
#define WBEMS_SINK_VERSION		_T("1.0")
#define WBEMS_SINK_VERDESC		_T("WBEM Scripting Sink 1.0")

// SWbemDateTime registry settings
#define WBEMS_DTIME_DESCRIPTION	_T("WBEM Scripting DateTime")
#define WBEMS_DTIME_PROGID		_T("WbemScripting.SWbemDateTime")
#define WBEMS_DTIME_PROGIDVER	_T("WbemScripting.SWbemDateTime.1")
#define WBEMS_DTIME_VERSION		_T("1.0")
#define WBEMS_DTIME_VERDESC		_T("WBEM Scripting DateTime 1.0")

// SWbemRefresher registry settings
#define WBEMS_REF_DESCRIPTION	_T("WBEM Scripting Refresher")
#define WBEMS_REF_PROGID		_T("WbemScripting.SWbemRefresher")
#define WBEMS_REF_PROGIDVER		_T("WbemScripting.SWbemRefresher.1")
#define WBEMS_REF_VERSION		_T("1.0")
#define WBEMS_REF_VERDESC		_T("WBEM Scripting Refresher 1.0")

// Standard registry key/value names
#define WBEMS_RK_SCC		_T("SOFTWARE\\CLASSES\\CLSID\\")
#define WBEMS_RK_SC			_T("SOFTWARE\\CLASSES\\")
#define WBEMS_RK_THRDMODEL	_T("ThreadingModel")
#define WBEMS_RV_APARTMENT	_T("Apartment")
#define WBEMS_RK_PROGID		_T("ProgID")
#define WBEMS_RK_VERPROGID	_T("VersionIndependentProgID")
#define WBEMS_RK_TYPELIB	_T("TypeLib")
#define WBEMS_RK_VERSION	_T("Version")
#define	WBEMS_RK_INPROC32	_T("InProcServer32")
#define WBEMS_RK_CLSID		_T("CLSID")
#define WBEMS_RK_CURVER		_T("CurVer")
#define WBEMS_RK_PROGRAMMABLE	_T("Programmable")

// Other values
#define WBEMS_RK_WBEM		_T("Software\\Microsoft\\Wbem")
#define WBEMS_SK_SCRIPTING	_T("Scripting")

#define GUIDSIZE	128

// Count number of objects and number of locks.

long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule = NULL;

// Used for error object storage
CWbemErrorCache *g_pErrorCache = NULL;

/*
 * This object is used to protect the global pointer:
 * 
 *	- g_pErrorCache 
 *
 * Note that it is the pointer variables that are protected by 
 * this CS, rather than the addressed objects.
 */
CRITICAL_SECTION g_csErrorCache;

// Used to protect security calls
CRITICAL_SECTION g_csSecurity;

// CLSID for our implementation of IParseDisplayName
// {172BDDF8-CEEA-11d1-8B05-00600806D9B6}
DEFINE_GUID(CLSID_SWbemParseDN, 
0x172bddf8, 0xceea, 0x11d1, 0x8b, 0x5, 0x0, 0x60, 0x8, 0x6, 0xd9, 0xb6);

// Forward defs
static void UnregisterTypeLibrary (unsigned short wVerMajor, unsigned short wVerMinor);

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	_RD(static char *me = "DllMain";)
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
		{
			_RPrint(me, "DLL_PROCESS_DETACH", 0, "");
			DeleteCriticalSection (&g_csErrorCache);
			DeleteCriticalSection (&g_csSecurity);
			CSWbemLocator::Shutdown ();
			CIWbemObjectSinkMethodCache::TidyUp ();
		}
			return TRUE;

		case DLL_THREAD_DETACH:
		{
			_RPrint(me, "DLL_THREAD_DETACH", 0, "");
		}
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			_RPrint(me, "DLL_PROCESS_DETACH", 0, "");
			if(ghModule == NULL)
				ghModule = hInstance;

			InitializeCriticalSection (&g_csErrorCache);
			InitializeCriticalSection (&g_csSecurity);
			CIWbemObjectSinkMethodCache::Initialize ();
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
			_RPrint(me, "DLL_THREAD_ATTACH", 0, "");
        }
			return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
	CSWbemFactory *pObj = NULL;

	if (CLSID_SWbemLocator == rclsid) 
        pObj=new CSWbemFactory(CSWbemFactory::LOCATOR);
	else if (CLSID_SWbemSink == rclsid)
        pObj=new CSWbemFactory(CSWbemFactory::SINK);
    else if (CLSID_SWbemNamedValueSet == rclsid) 
        pObj=new CSWbemFactory(CSWbemFactory::CONTEXT);
	else if (CLSID_SWbemObjectPath == rclsid)
        pObj=new CSWbemFactory(CSWbemFactory::OBJECTPATH);
	else if (CLSID_SWbemParseDN == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::PARSEDN);
	else if (CLSID_SWbemLastError == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::LASTERROR);
	else if (CLSID_SWbemDateTime == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::DATETIME);
	else if (CLSID_SWbemRefresher == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::REFRESHER);

    if(NULL == pObj)
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	// It is OK to unload if there are no objects or locks on the
    // class factory.

	HRESULT status = S_FALSE;
	_RD(static char *me = "DllCanUnloadNow";)
	_RPrint(me, "Called", 0, "");

	if (0L==g_cObj && 0L==g_cLock)
	{
		_RPrint(me, "Unloading", 0, "");
		/*
		 * Release the error object on this thread, if any
		 */
		status = S_OK;

		EnterCriticalSection (&g_csErrorCache);

		if (g_pErrorCache)
		{
			delete g_pErrorCache;
			g_pErrorCache = NULL;
		}

		LeaveCriticalSection (&g_csErrorCache);

		CSWbemSecurity::Uninitialize ();
	}

    return status;
}

//***************************************************************************
//
//  STDAPI RegisterProgID
//	STDAPI RegisterCoClass	
//	STDAPI RegisterTypeLibrary
//	STDAPI RegisterDefaultNamespace
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry setup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

STDAPI RegisterProgID (LPCTSTR wcID, LPCTSTR desc, LPCTSTR progid, 
						LPCTSTR descVer, LPCTSTR progidVer)
{
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;

    TCHAR		*szProgID = new TCHAR [_tcslen (WBEMS_RK_SC) + 
					_tcslen (progid) + 1];

	if (!szProgID)
		return E_OUTOFMEMORY;

	TCHAR		*szProgIDVer = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progidVer) + 1];

	if (!szProgIDVer)
	{
		delete [] szProgID;
		return E_OUTOFMEMORY;
	}

	_tcscpy (szProgID, WBEMS_RK_SC);
	_tcscat (szProgID, progid);
	
	_tcscpy (szProgIDVer, WBEMS_RK_SC);
	_tcscat (szProgIDVer, progidVer);
	
	// Add the ProgID (Version independent)
	if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szProgID, &hKey1))
	{
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (_tcslen(desc)+1) * sizeof(TCHAR));

		if(ERROR_SUCCESS == RegCreateKey(hKey1,WBEMS_RK_CLSID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID, 
										(_tcslen(wcID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}

		if(ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_CURVER, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progidVer, 
										(_tcslen(progidVer)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}
		RegCloseKey(hKey1);
	}

	// Add the ProgID (Versioned)
	if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szProgIDVer, &hKey1))
	{
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)descVer, (_tcslen(descVer)+1) * sizeof(TCHAR));

		if(ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_CLSID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID, 
										(_tcslen(wcID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}

		RegCloseKey(hKey1);
	}

	delete [] szProgID;
	delete [] szProgIDVer;
	
	return NOERROR;
}

STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc, LPCTSTR progid, LPCTSTR progidVer, 
					  LPCTSTR ver, LPCTSTR descVer)
{
	HRESULT		hr = S_OK;
	OLECHAR		wcID[GUIDSIZE];
	OLECHAR		tlID[GUIDSIZE];
	TCHAR		nwcID[GUIDSIZE];
	TCHAR		ntlID[GUIDSIZE];
    TCHAR		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

	TCHAR *szCLSID = new TCHAR [_tcslen (WBEMS_RK_SCC) + GUIDSIZE + 1];

	if (!szCLSID)
		return E_OUTOFMEMORY;

    // Create the path.
    if(0 ==StringFromGUID2(clsid, wcID, GUIDSIZE))
	{
		delete [] szCLSID;
		return ERROR;
	}

	_tcscpy (szCLSID, WBEMS_RK_SCC);

#ifndef UNICODE
	wcstombs(nwcID, wcID, GUIDSIZE);
#else
	_tcsncpy (nwcID, wcID, GUIDSIZE);
#endif

    _tcscat (szCLSID, nwcID);
	
	if (0 == StringFromGUID2 (LIBID_WbemScripting, tlID, GUIDSIZE))
	{
		delete [] szCLSID;
		return ERROR;
	}

#ifndef UNICODE
	wcstombs (ntlID, tlID, GUIDSIZE);	
#else
	_tcsncpy (ntlID, tlID, GUIDSIZE);
#endif
	
	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
	{
		delete [] szCLSID;
		return ERROR;
	}

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (_tcslen(desc)+1) * sizeof(TCHAR));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
										(_tcslen(szModule)+1) * sizeof(TCHAR));
			RegSetValueEx(hKey2, WBEMS_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WBEMS_RV_APARTMENT, 
                                        (_tcslen(WBEMS_RV_APARTMENT)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
		}

		// Give a link to the type library (useful for statement completion in scripting tools)
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_TYPELIB, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ntlID, (_tcslen(ntlID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
		}

		// Register the ProgID
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_PROGID ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progidVer, 
										(_tcslen(progidVer)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register the version-independent ProgID

		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_VERPROGID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progid, 
										(_tcslen(progid)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register the version
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_VERSION, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ver, (_tcslen(ver)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register this control as programmable
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_PROGRAMMABLE ,&hKey2))
		{
			RegCloseKey(hKey2);
        }

		RegCloseKey(hKey1);
	}
	else
	{
		delete [] szCLSID;
		return ERROR;
	}

	delete [] szCLSID;


	return RegisterProgID (nwcID, desc, progid, descVer, progidVer);
}

STDAPI RegisterTypeLibrary ()
{
	// AUTOMATION.  register type library
	TCHAR cPath[MAX_PATH];
	if(GetModuleFileName(ghModule,cPath,MAX_PATH))
	{
		// Replace final 3 characters "DLL" by "TLB"
		TCHAR *pExt = _tcsrchr (cPath, _T('.'));

		if (pExt && (0 == _tcsicmp (pExt, _T(".DLL"))))
		{
			_tcscpy (pExt + 1, _T("TLB"));
			OLECHAR wPath [MAX_PATH];
#ifndef UNICODE
			mbstowcs (wPath, cPath, MAX_PATH-1);
#else
			_tcsncpy (wPath, cPath, MAX_PATH-1);
#endif
			ITypeLib FAR* ptlib = NULL; 
			SCODE sc = LoadTypeLib(wPath, &ptlib);
			if(sc == 0 && ptlib)
			{
				sc = RegisterTypeLib(ptlib,wPath,NULL);
				ptlib->Release();

				// Unregister the previous library version(s)
				UnregisterTypeLibrary (1, 1);
				UnregisterTypeLibrary (1, 0);
			}
		}
	}
	
	return NOERROR;
}

STDAPI RegisterScriptSettings ()
{
	HKEY hKey;

	if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCRIPTING, &hKey))
		return ERROR;

	// Need to know what O/S we are to set up the right registry keys
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	GetVersionEx (&osVersionInfo);
	bool bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
	DWORD dwNTMajorVersion = osVersionInfo.dwMajorVersion;
		
	// Default namespace value - exists on all platforms
	RegSetValueEx(hKey, WBEMS_RV_DEFNS, 0, REG_SZ, (BYTE *)WBEMS_DEFNS, 
                                        (_tcslen(WBEMS_DEFNS)+1) * sizeof(TCHAR));

	// Enable for ASP - on NT 4.0 or less only
	if (bIsNT && (dwNTMajorVersion <= 4))
	{
		DWORD	defaultEnableForAsp = 0;
		RegSetValueEx(hKey, WBEMS_RV_ENABLEFORASP, 0, REG_DWORD, (BYTE *)&defaultEnableForAsp,
							sizeof (defaultEnableForAsp));
	}

	// Default impersonation level - NT only
	if (bIsNT)
	{
		DWORD	defaultImpersonationLevel = (DWORD) wbemImpersonationLevelImpersonate;
		RegSetValueEx(hKey, WBEMS_RV_DEFAULTIMPLEVEL, 0, REG_DWORD, (BYTE *)&defaultImpersonationLevel,
							sizeof (defaultImpersonationLevel));
	}

	RegCloseKey(hKey);

	return NOERROR;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	HRESULT hr;

	if (
		(NOERROR == (hr = RegisterScriptSettings ())) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemLocator, WBEMS_LOC_DESCRIPTION, 
			WBEMS_LOC_PROGID, WBEMS_LOC_PROGIDVER, WBEMS_LOC_VERSION, 
			WBEMS_LOC_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemSink,
			WBEMS_SINK_DESCRIPTION, WBEMS_SINK_PROGID, WBEMS_SINK_PROGIDVER, 
			WBEMS_SINK_VERSION, WBEMS_SINK_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemNamedValueSet,
			WBEMS_CON_DESCRIPTION, WBEMS_CON_PROGID, WBEMS_CON_PROGIDVER, 
			WBEMS_CON_VERSION, WBEMS_CON_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemParseDN,
					WBEMS_PDN_DESCRIPTION, WBEMS_PDN_PROGID, WBEMS_PDN_PROGIDVER, 
			WBEMS_PDN_VERSION, WBEMS_PDN_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemObjectPath,
					WBEMS_OBP_DESCRIPTION, WBEMS_OBP_PROGID, WBEMS_OBP_PROGIDVER, 
			WBEMS_OBP_VERSION, WBEMS_OBP_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemLastError,
					WBEMS_LER_DESCRIPTION, WBEMS_LER_PROGID, WBEMS_LER_PROGIDVER, 
			WBEMS_LER_VERSION, WBEMS_LER_VERDESC))) && 
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemDateTime,
					WBEMS_DTIME_DESCRIPTION, WBEMS_DTIME_PROGID, WBEMS_DTIME_PROGIDVER, 
			WBEMS_DTIME_VERSION, WBEMS_DTIME_VERDESC))) && 
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemRefresher,
					WBEMS_REF_DESCRIPTION, WBEMS_REF_PROGID, WBEMS_REF_PROGIDVER, 
			WBEMS_REF_VERSION, WBEMS_REF_VERDESC)))
	   )
				hr = RegisterTypeLibrary ();

	return hr;
}

//***************************************************************************
//
//  STDAPI UnregisterProgID
//	STDAPI UnregisterCoClass	
//	STDAPI UnregisterTypeLibrary
//	STDAPI UnregisterDefaultNamespace
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry cleanup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

void UnregisterProgID (LPCTSTR progid, LPCTSTR progidVer)
{
	HKEY hKey = NULL;

	TCHAR		*szProgID = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progid) + 1];
	TCHAR		*szProgIDVer = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progidVer) + 1];

	if (szProgID && szProgIDVer)
	{
		_tcscpy (szProgID, WBEMS_RK_SC);
		_tcscat (szProgID, progid);
		
		_tcscpy (szProgIDVer, WBEMS_RK_SC);
		_tcscat (szProgIDVer, progidVer);


		// Delete the subkeys of the versioned HKCR\ProgID entry
		if (NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szProgIDVer, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_CLSID);
			RegCloseKey(hKey);
		}

		// Delete the versioned HKCR\ProgID entry
		RegDeleteKey (HKEY_LOCAL_MACHINE, szProgIDVer);

		// Delete the subkeys of the HKCR\VersionIndependentProgID entry
		if (NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szProgID, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_CLSID);
			DWORD dwRet = RegDeleteKey(hKey, WBEMS_RK_CURVER);
			RegCloseKey(hKey);
		}

		// Delete the HKCR\VersionIndependentProgID entry
		RegDeleteKey (HKEY_LOCAL_MACHINE, szProgID);
	}

	if (szProgID)
		delete [] szProgID;

	if (szProgIDVer)
		delete [] szProgIDVer;
}


void UnregisterCoClass (REFGUID clsid, LPCTSTR progid, LPCTSTR progidVer)
{
	OLECHAR		wcID[GUIDSIZE];
    TCHAR		nwcID[GUIDSIZE];
    HKEY		hKey = NULL;

	TCHAR		*szCLSID = new TCHAR [_tcslen (WBEMS_RK_SCC) + GUIDSIZE + 1];

	if (szCLSID)
	{
		// Create the path using the CLSID

		if(0 != StringFromGUID2(clsid, wcID, GUIDSIZE))
		{
#ifndef UNICODE
			wcstombs(nwcID, wcID, GUIDSIZE);
#else
			_tcsncpy (nwcID, wcID, GUIDSIZE);
#endif
			_tcscpy (szCLSID, WBEMS_RK_SCC);
			_tcscat (szCLSID, nwcID);
		
			// First delete the subkeys of the HKLM\Software\Classes\CLSID\{GUID} entry
			if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey))
			{
				RegDeleteKey(hKey, WBEMS_RK_INPROC32);
				RegDeleteKey(hKey, WBEMS_RK_TYPELIB);
				RegDeleteKey(hKey, WBEMS_RK_PROGID);
				RegDeleteKey(hKey, WBEMS_RK_VERPROGID);
				RegDeleteKey(hKey, WBEMS_RK_VERSION);
				RegDeleteKey(hKey, WBEMS_RK_PROGRAMMABLE);
				RegCloseKey(hKey);
			}

			// Delete the HKLM\Software\Classes\CLSID\{GUID} key
			if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCC, &hKey))
			{
				RegDeleteKey(hKey, nwcID);
				RegCloseKey(hKey);
			}
		}

		delete [] szCLSID;
	}

	UnregisterProgID (progid, progidVer);
}

static void UnregisterTypeLibrary (unsigned short wVerMajor, unsigned short wVerMinor)
{
	//	Unregister the type library.  The UnRegTypeLib function is not available in
    //  in some of the older version of the ole dlls and so it must be loaded
    //  dynamically
    HRESULT (STDAPICALLTYPE *pfnUnReg)(REFGUID, WORD,
            WORD , LCID , SYSKIND);

    TCHAR path[ MAX_PATH+20 ];
    GetSystemDirectory(path, MAX_PATH);
    _tcscat(path, _T("\\oleaut32.dll"));

    HMODULE g_hOle32 = LoadLibraryEx(path, NULL, 0);

    if(g_hOle32 != NULL) 
    {
        (FARPROC&)pfnUnReg = GetProcAddress(g_hOle32, "UnRegisterTypeLib");
        if(pfnUnReg) 
            pfnUnReg (LIBID_WbemScripting, wVerMajor, wVerMinor, 0, SYS_WIN32);
        FreeLibrary(g_hOle32);
    }
}

void UnregisterScriptSettings ()
{
	HKEY hKey;
		
	if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_WBEM, &hKey))
	{
		RegDeleteKey(hKey, WBEMS_SK_SCRIPTING);
		RegCloseKey (hKey);
	}
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnregisterScriptSettings ();
	UnregisterCoClass (CLSID_SWbemLocator, WBEMS_LOC_PROGID, WBEMS_LOC_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemSink, WBEMS_SINK_PROGID, WBEMS_SINK_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemNamedValueSet, WBEMS_CON_PROGID, WBEMS_CON_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemLastError, WBEMS_LER_PROGID, WBEMS_LER_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemObjectPath, WBEMS_OBP_PROGID, WBEMS_OBP_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemParseDN, WBEMS_PDN_PROGID, WBEMS_PDN_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemDateTime, WBEMS_DTIME_PROGID, WBEMS_DTIME_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemRefresher, WBEMS_REF_PROGID, WBEMS_REF_PROGIDVER);
	UnregisterTypeLibrary (1, 2);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\methvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  METHVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines implementation of IEnumVARIANT for iterators of ISWbemMethodSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CMethodSetEnumVar::CMethodSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CMethodSetEnumVar::CMethodSetEnumVar(CSWbemMethodSet *pMethodSet,
									 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = 0;
	m_pMethodSet = pMethodSet;
	m_pMethodSet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CMethodSetEnumVar::~CMethodSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CMethodSetEnumVar::~CMethodSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pMethodSet)
		m_pMethodSet->Release ();
}

//***************************************************************************
// HRESULT CMethodSetEnumVar::QueryInterface
// long CMethodSetEnumVar::AddRef
// long CMethodSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CMethodSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CMethodSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CMethodSetEnumVar::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pMethodSet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemMethod *pMethod = NULL;
					
					if (SUCCEEDED(hRes2 = m_pMethodSet->Next (0, &pMethod)))
					{
						if (NULL == pMethod)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pMethod;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pMethodSet)
		{
			CMethodSetEnumVar *pEnum = new CMethodSetEnumVar (m_pMethodSet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pMethodSet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CMethodSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CMethodSetEnumVar::SeekCurrentPosition ()
{
	ISWbemMethod *pDummyObject = NULL;
	m_pMethodSet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pMethodSet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\method.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  method.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemMethod and CSWbemMethodSet definitions.
//
//***************************************************************************

#ifndef _METHOD_H_
#define _METHOD_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemMethod
//
//  DESCRIPTION:
//
//  Implements the ISWbemMethod interface.  
//
//***************************************************************************

class CSWbemMethod : public ISWbemMethod,
					 public ISupportErrorInfo,
					 public IProvideClassInfo
{
private:
	class CMethodDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};

	CSWbemServices		*m_pSWbemServices;
	IWbemClassObject	*m_pIWbemClassObject;
	CMethodDispatchHelp	m_Dispatch;
	BSTR				m_name;

protected:
	long				m_cRef;         //Object reference count

public:
    
    CSWbemMethod (CSWbemServices *pService, IWbemClassObject *pObject, 
					BSTR name);
    ~CSWbemMethod (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemProperty methods

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_Origin
	(
		/*[out]*/	BSTR *pOrigin
	);

	HRESULT STDMETHODCALLTYPE get_InParameters
	(
		/*[out]*/	ISWbemObject **ppInParameters
	);
	
	HRESULT STDMETHODCALLTYPE get_OutParameters
	(
		/*[out]*/	ISWbemObject **ppOutParameters
	);
	
	HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
		/*[out]*/	ISWbemQualifierSet **ppQualSet
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemMethodSet interface.  
//
//***************************************************************************

class CSWbemMethodSet : public ISWbemMethodSet,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CSWbemServices		*m_pSWbemServices;
	IWbemClassObject	*m_pIWbemClassObject;
	CDispatchHelp		m_Dispatch;
	long				m_Count;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemMethodSet (CSWbemServices *pService, IWbemClassObject *pObject);
    ~CSWbemMethodSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemMethod **ppMethod
    );        

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[in]*/	long *plCount
	);

    // ISWbemMethodSet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemMethod **ppMethod
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\method.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  METHOD.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemMethod
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemMethod::CSWbemMethod
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemMethod::CSWbemMethod(
	CSWbemServices *pService, 
	IWbemClassObject *pIWbemClassObject,
	BSTR name
)
{
	m_Dispatch.SetObj (this, IID_ISWbemMethod, 
							CLSID_SWbemMethod, L"SWbemMethod");
    m_cRef=1;
	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemClassObject->AddRef ();
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemMethod::~CSWbemMethod
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemMethod::~CSWbemMethod(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemMethod::QueryInterface
// long CSWbemMethod::AddRef
// long CSWbemMethod::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethod::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemMethod==riid)
		*ppv = (ISWbemMethod *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemMethod::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemMethod::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemMethod::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethod::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemMethod == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the method name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_InParameters
//
//  DESCRIPTION:
//
//  Retrieve the method in parameters signature
//
//  PARAMETERS:
//
//		ppInSignature		addresses the in signature on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_InParameters (
	ISWbemObject **ppInSignature
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppInSignature)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppInSignature = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemClassObject *pInSig = NULL;
			
			/*
			 * Note that if there are no in parameters, the following
			 * call will succeed but pInSig will be NULL.
			 */
			if ((WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod 
							(m_name, 0, &pInSig, NULL))) && pInSig)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pInSig);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppInSignature)))
					delete pObject;

				pInSig->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_OutParameters
//
//  DESCRIPTION:
//
//  Retrieve the method out parameters signature
//
//  PARAMETERS:
//
//		ppOutSignature		addresses the out signature on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_OutParameters (
	ISWbemObject **ppOutSignature
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppOutSignature)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppOutSignature = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemClassObject *pOutSig = NULL;
			
			/*
			 * Note that if there are no in parameters, the following
			 * call will succeed but pOutSig will be NULL.
			 */
			if ((WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod 
							(m_name, 0, NULL, &pOutSig))) && pOutSig)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pOutSig);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppOutSignature)))
					delete pObject;

				pOutSig->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Origin
//
//  DESCRIPTION:
//
//  Retrieve the method origin
//
//  PARAMETERS:
//
//		pOrigin		holds the origin class on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Origin (
	BSTR *pOrigin
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pOrigin)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		if (m_pIWbemClassObject)
			m_pIWbemClassObject->GetMethodOrigin (m_name, pOrigin);

		if (NULL == *pOrigin)
			*pOrigin = SysAllocString (OLESTR(""));
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Qualifiers_
//
//  DESCRIPTION:
//
//  Retrieve the method qualifier set
//
//  PARAMETERS:
//
//		ppQualSet		addresses the qualifier set on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet	
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemQualifierSet *pQualSet = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethodQualifierSet 
									(m_name, &pQualSet)))
		{
			if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet)))
				hr = WBEM_E_OUT_OF_MEMORY;

			pQualSet->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\methset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemMethodSet::CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemMethodSet::CSWbemMethodSet(CSWbemServices *pService, IWbemClassObject *pObject)
{
	m_Dispatch.SetObj (this, IID_ISWbemMethodSet, 
							CLSID_SWbemMethodSet, L"SWbemMethodSet");
	m_pIWbemClassObject = pObject;
	m_pIWbemClassObject->AddRef ();
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

    m_cRef=1;
    InterlockedIncrement(&g_cObj);

	// Set up the Count.  We can do this because this is a read-only interface
	m_Count = 0;
	pObject->BeginMethodEnumeration (0);
	BSTR bstrName = NULL;

	while (WBEM_S_NO_ERROR == pObject->NextMethod (0, &bstrName, NULL, NULL))
	{
		SysFreeString (bstrName);
		m_Count++;
	}

	pObject->EndMethodEnumeration ();
}

//***************************************************************************
//
//  CSWbemMethodSet::~CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemMethodSet::~CSWbemMethodSet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->EndMethodEnumeration ();
		m_pIWbemClassObject->Release ();
	}

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();
}

//***************************************************************************
// HRESULT CSWbemMethodSet::QueryInterface
// long CSWbemMethodSet::AddRef
// long CSWbemMethodSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethodSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemMethodSet==riid)
		*ppv = (ISWbemMethodSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemMethodSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemMethodSet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemMethodSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethodSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemMethodSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::Item
//
//  DESCRIPTION:
//
//  Get a method
//
//  PARAMETERS:
//
//		bsName			The name of the method
//		lFlags			Flags
//		ppProp			On successful return addresses the ISWbemMethod
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemMethodSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemMethod ** ppMethod
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethod)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethod = NULL;

		if (m_pIWbemClassObject)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod (bsName, lFlags, NULL, NULL)))
			{
				if (!(*ppMethod = 
						new CSWbemMethod (m_pSWbemServices, m_pIWbemClassObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;
			}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the methods
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemClassObject)
	{
		hr = m_pIWbemClassObject->EndEnumeration ();
		hr = m_pIWbemClassObject->BeginMethodEnumeration (0);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::Next
//
//  DESCRIPTION:
//
//  Get next method in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppMethod	Next method (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::Next (
	long lFlags,
	ISWbemMethod ** ppMethod
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethod)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethod = NULL;

		if (m_pIWbemClassObject)
		{
			BSTR bsName = NULL;
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->NextMethod (lFlags, &bsName, NULL, NULL)))
			{
				if (!(*ppMethod = new CSWbemMethod (m_pSWbemServices, m_pIWbemClassObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;

				SysFreeString (bsName);
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CMethodSetEnumVar *pEnum = new CMethodSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemMethodSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses value
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_Count;
		hr = S_OK;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\methvar.h ===
//***************************************************************************
//
//  methvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CMethodSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _METHVAR_H_
#define _METHVAR_H_

// This class implements the IEnumVARIANT interface

class CMethodSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemMethodSet		*m_pMethodSet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();

public:
	CMethodSetEnumVar (CSWbemMethodSet *pObject,
						ULONG initialPos = 0);
	~CMethodSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\objobjp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  objobjp.h
//
//  alanbos  13-Feb-98   Created.
//
//  Implementation of IWbemObjectPathEx for ISWbemObjectEx.
//
//***************************************************************************

#ifndef _OBJOBJP_H_
#define _OBJOBJP_H_

class CSWbemObjectObjectPathSecurity;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectPath interface for the 
//	ISWbemObject.Path_ property.  
//
//***************************************************************************

class CSWbemObjectObjectPath : public ISWbemObjectPath,
							   public ISupportErrorInfo,
							   public IProvideClassInfo
{
private:
	class CObjectObjectPathDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};
	IWbemClassObject				*m_pIWbemClassObject;
	CSWbemServices					*m_pSWbemServices;
	CObjectObjectPathDispatchHelp	m_Dispatch;
	CWbemSite						*m_pSite;
	CSWbemObjectObjectPathSecurity	*m_pSecurity;

	HRESULT STDMETHODCALLTYPE	GetStrVal (BSTR *value, LPWSTR name);

	HRESULT				RaiseReadOnlyException ()
	{
		m_Dispatch.RaiseException (WBEM_E_READ_ONLY);
		return WBEM_E_READ_ONLY;
	}

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectObjectPath(CSWbemServices *pSWbemServices, CSWbemObject *pSObject);
    ~CSWbemObjectObjectPath(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemObjectPath methods

    HRESULT STDMETHODCALLTYPE get_Path( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_Path( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_RelPath( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_RelPath( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_DisplayName( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_DisplayName( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Namespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_Namespace( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_ParentNamespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE get_Server( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Server( 
        /* [in] */ BSTR __RPC_FAR value)
	{
		return RaiseReadOnlyException ();
	}
    
    HRESULT STDMETHODCALLTYPE get_IsClass( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsClass()
	{
		return RaiseReadOnlyException ();
	}
   
    HRESULT STDMETHODCALLTYPE get_IsSingleton( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
       HRESULT STDMETHODCALLTYPE SetAsSingleton() 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Class( 
        /* [in] */ BSTR __RPC_FAR value) ;

	HRESULT STDMETHODCALLTYPE get_Keys(
		/* [out,retval] */ ISWbemNamedValueSet **objKeys);

	HRESULT STDMETHODCALLTYPE get_Security_(
		/* [out,retval] */ ISWbemSecurity **objKeys);

    HRESULT STDMETHODCALLTYPE get_Locale( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Locale( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Authority( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Authority( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectObjectPathSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for CSWbemObjectObjectPath.  
//
//***************************************************************************

class CSWbemObjectObjectPathSecurity : public ISWbemSecurity,
									   public ISupportErrorInfo,
									   public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	WbemImpersonationLevelEnum	m_dwImpLevel;
	WbemAuthenticationLevelEnum	m_dwAuthnLevel;
	BSTR						m_bsAuthority;

	HRESULT				RaiseReadOnlyException ()
	{
		m_Dispatch.RaiseException (WBEM_E_READ_ONLY);
		return WBEM_E_READ_ONLY;
	}

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectObjectPathSecurity (CSWbemServices *pSWbemServices);
	virtual ~CSWbemObjectObjectPathSecurity (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	)
	{
		return RaiseReadOnlyException ();
	}

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	)
	{
		return RaiseReadOnlyException ();
	}

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
	
	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}

	BSTR &GetAuthority ()
	{
		return m_bsAuthority;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\objobjp.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectPath for the ISWbemObjectEx 
//  interface
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectObjectPath::CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectObjectPath::CSWbemObjectObjectPath(
	CSWbemServices *pSWbemServices,
	CSWbemObject *pSObject) :
		m_pIWbemClassObject (NULL),
		m_pSWbemServices (pSWbemServices),
		m_pSite (NULL)
{
	InterlockedIncrement(&g_cObj);

	if (pSObject)
	{
		m_pIWbemClassObject = pSObject->GetIWbemClassObject ();
		m_pSite = new CWbemObjectSite (pSObject);
	}

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_pSecurity = new CSWbemObjectObjectPathSecurity (pSWbemServices);

	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");
    m_cRef=0;
}

//***************************************************************************
//
//  CSWbemObjectObjectPath::~CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectObjectPath::~CSWbemObjectObjectPath(void)
{
	if (m_pSWbemServices)
	{
		m_pSWbemServices->Release ();
		m_pSWbemServices = NULL;
	}

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->Release ();
		m_pIWbemClassObject = NULL;
	}

	if (m_pSite)
	{
		m_pSite->Release ();
		m_pSite = NULL;
	}

	if (m_pSecurity)
	{
		m_pSecurity->Release ();
		m_pSecurity = NULL;
	}

	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemObjectPath::QueryInterface
// long CSWbemObjectPath::AddRef
// long CSWbemObjectPath::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPath::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectPath==riid)
		*ppv = (ISWbemObjectPath *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPath::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPath::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPath::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPath::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectPath == riid) ? S_OK : S_FALSE;
}

// Methods of ISWbemObjectPath
STDMETHODIMP CSWbemObjectObjectPath::get_RelPath( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	return GetStrVal (value, WBEMS_SP_RELPATH);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	return GetStrVal (value, WBEMS_SP_PATH);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Server( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_SERVER);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Namespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_NAMESPACE);
}
        
STDMETHODIMP CSWbemObjectObjectPath::get_Class( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_CLASS);
}
        
        
STDMETHODIMP CSWbemObjectObjectPath::GetStrVal (
	BSTR *value,
	LPWSTR name)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = NULL;

		if ( m_pIWbemClassObject )
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (name, 0, &var, NULL, NULL))
			{
				if (VT_BSTR == var.vt)
				{
					*value = SysAllocString (var.bstrVal);
					hr = WBEM_S_NO_ERROR;
				}
				else if (VT_NULL == var.vt)
				{
					*value = SysAllocString (OLESTR(""));
					hr = WBEM_S_NO_ERROR;
				}
			}

			VariantClear (&var);

			if (NULL == *value)
				*value = SysAllocString (OLESTR(""));

		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_IsClass( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = true;

		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);
			BSTR genus = SysAllocString (WBEMS_SP_GENUS);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (genus, 0, &var, NULL, NULL))
			{
				*value = (var.lVal == WBEM_GENUS_CLASS) ? VARIANT_TRUE : VARIANT_FALSE;
				hr = WBEM_S_NO_ERROR;
			}

			VariantClear (&var);
			SysFreeString (genus);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_IsSingleton( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;
		*value = false;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			CWbemPathCracker pathCracker (path);
		
			*value = pathCracker.IsSingleton ();
			hr = WBEM_S_NO_ERROR;

			SysFreeString (path);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

        
STDMETHODIMP CSWbemObjectObjectPath::get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			wchar_t *securityStr = NULL;
			wchar_t *localeStr = NULL;
			
			if (m_pSWbemServices)
			{
				CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

				if (pSecurity)
				{
					BSTR bsAuthority = SysAllocString (pSecurity->GetAuthority ());
					enum WbemAuthenticationLevelEnum authnLevel;
					enum WbemImpersonationLevelEnum impLevel;

					if (SUCCEEDED(pSecurity->get_AuthenticationLevel (&authnLevel)) &&
						SUCCEEDED(pSecurity->get_ImpersonationLevel (&impLevel)))
					{
						CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

						if (pPrivilegeSet)
						{
							securityStr = CWbemParseDN::GetSecurityString (true, authnLevel, true, 
										impLevel, *pPrivilegeSet, bsAuthority);
							pPrivilegeSet->Release ();
						}
					}

					SysFreeString (bsAuthority);
					pSecurity->Release ();
				}

				localeStr = CWbemParseDN::GetLocaleString (m_pSWbemServices->GetLocale ());
			}

			size_t len = wcslen (path) + wcslen (WBEMS_PDN_SCHEME) +
							((securityStr) ? wcslen (securityStr) : 0) +
							((localeStr) ? wcslen (localeStr) : 0);

			// If security or locale specified, and we have a path, then need a separator
			if ( (securityStr || localeStr) && (0 < wcslen (path)) )
				len += wcslen (WBEMS_EXCLAMATION);

			OLECHAR *displayName = new OLECHAR [len + 1];
			
			if (displayName)
			{
				wcscpy (displayName, WBEMS_PDN_SCHEME) ;
				
				if (securityStr)
					wcscat (displayName, securityStr);

				if (localeStr)
					wcscat (displayName, localeStr);

				if ( (securityStr || localeStr) && (0 < wcslen (path)) )
					wcscat (displayName, WBEMS_EXCLAMATION);

				wcscat (displayName, path) ;
				displayName [len] = NULL;

				*value = SysAllocString (displayName);
				
				delete [] displayName ;
				hr = WBEM_S_NO_ERROR;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
			
			if (securityStr)
				delete [] securityStr;

			if (localeStr)
				delete [] localeStr;

			SysFreeString (path);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_ParentNamespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;
		*value = NULL;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			CWbemPathCracker pathCracker (path);
			CComBSTR bsNsPath;

			if (pathCracker.GetNamespacePath (bsNsPath, true))
			{
				*value = bsNsPath.Detach ();
				hr = WBEM_S_NO_ERROR;
			}
	
			SysFreeString (path);
		}

		if (NULL == *value)
			*value = SysAllocString (OLESTR(""));
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::put_Class( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value && m_pIWbemClassObject )
	{
		VARIANT var;
		VariantInit (&var);
		var.vt = VT_BSTR;
		var.bstrVal = SysAllocString (value);
		BSTR className = SysAllocString (WBEMS_SP_CLASS);
		
		hr = m_pIWbemClassObject->Put (className, 0, &var, NULL);
		
		VariantClear (&var);
		SysFreeString (className);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_Keys(
			/* [out, retval] */ ISWbemNamedValueSet **objKeys)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == objKeys)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*objKeys = NULL;
		BSTR bsPath = NULL;
	
		if (WBEM_S_NO_ERROR == get_Path (&bsPath))
		{
			CWbemPathCracker *pCWbemPathCracker  = new CWbemPathCracker (bsPath);

			if (!pCWbemPathCracker)
				hr = WBEM_E_OUT_OF_MEMORY;
			else
			{
				CSWbemNamedValueSet *pCSWbemNamedValueSet = 
						new CSWbemNamedValueSet (pCWbemPathCracker, false);

				if (!pCSWbemNamedValueSet)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (SUCCEEDED(pCSWbemNamedValueSet->QueryInterface 
									(IID_ISWbemNamedValueSet, (PPVOID) objKeys)))
					hr = WBEM_S_NO_ERROR;
				else
					delete pCSWbemNamedValueSet;
			}
							
			SysFreeString (bsPath);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;

}

STDMETHODIMP CSWbemObjectObjectPath::get_Security_(
			/* [out, retval] */ ISWbemSecurity **objSecurity)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (objSecurity)
	{
		*objSecurity = m_pSecurity;
		m_pSecurity->AddRef ();
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_Locale( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value )
	{
		if (m_pSWbemServices)
			*value = SysAllocString (m_pSWbemServices->GetLocale ()) ;
		else
			*value = SysAllocString (OLESTR(""));

		t_Result = S_OK ;
	}

	if (FAILED(t_Result))
		m_Dispatch.RaiseException (t_Result);

	return t_Result ;
}        

STDMETHODIMP CSWbemObjectObjectPath::get_Authority( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value )
	{
		if (m_pSecurity)
			*value = SysAllocString (m_pSecurity->GetAuthority ()) ;
		else
			*value = SysAllocString (OLESTR(""));

		t_Result = S_OK ;
	}

	if (FAILED(t_Result))
		m_Dispatch.RaiseException (t_Result);

	return t_Result ;
}        

// CSWbemObjectObjectPathSecurity methods

//***************************************************************************
//
// CSWbemObjectObjectPathSecurity::CSWbemObjectObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectObjectPathSecurity::CSWbemObjectObjectPathSecurity (
	CSWbemServices *pSWbemServices
) : m_pPrivilegeSet (NULL),
    m_bsAuthority (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
    m_cRef=1;
	InterlockedIncrement(&g_cObj);

	if (pSWbemServices)
	{
		CSWbemSecurity *pSecurity = pSWbemServices->GetSecurityInfo ();

		if (pSecurity)
		{
			// Set up authn and imp levels
			pSecurity->get_AuthenticationLevel (&m_dwAuthnLevel);
			pSecurity->get_ImpersonationLevel (&m_dwImpLevel);

			// Set up authority
			m_bsAuthority = SysAllocString (pSecurity->GetAuthority ());

			// Set up privileges
			CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

			if (pPrivilegeSet)
			{
				// Note we mark the privilege set as immutable
				m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet, false);
				pPrivilegeSet->Release ();
			}

			pSecurity->Release ();
		}
	}
}

//***************************************************************************
//
// CSWbemObjectObjectPathSecurity::~CSWbemObjectObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectObjectPathSecurity::~CSWbemObjectObjectPathSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->Release ();
		m_pPrivilegeSet = NULL;
	}

	if (m_bsAuthority)
	{
		SysFreeString (m_bsAuthority);
		m_bsAuthority = NULL;
	}
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPathSecurity::QueryInterface
// long CSWbemObjectObjectPathSecurity::AddRef
// long CSWbemObjectObjectPathSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPathSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *) this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPathSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPathSecurity::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPathSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPathSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pAuthenticationLevel = m_dwAuthnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}		

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pImpersonationLevel = m_dwImpLevel;
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\object.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  object.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemObject and CSWbemObjectSet definition.
//
//***************************************************************************

#ifndef _OBJECT_H_
#define _OBJECT_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObject
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectEx interface.  
//
//***************************************************************************

class CSWbemObject : public ISWbemObjectEx, 
					 public IDispatchEx,
					 public ISWbemInternalObject,
					 public IObjectSafety,
					 public ISupportErrorInfo,
					 public IProvideClassInfo
{
friend	CSWbemServices;

private:
	bool					m_isErrorObject;
	CSWbemServices			*m_pSWbemServices;
	IWbemClassObject		*m_pIWbemClassObject;
	CWbemDispatchMgr		*m_pDispatch;
	IServiceProvider		*m_pIServiceProvider;
	IWbemRefresher			*m_pIWbemRefresher;
	bool					m_bCanUseRefresher;

	// If an embedded object, we store the parent site
	CWbemSite				*m_pSite;

	bool					CastToScope (IDispatch *pContext, CComPtr<ISWbemServicesEx> &pISWbemServicesEx);

protected:
	long					m_cRef;         //Object reference count

public:
    
    CSWbemObject(CSWbemServices *pService, IWbemClassObject *pIWbemClassObject,
					CSWbemSecurity *pSecurity = NULL, bool isErrorObject = false);
    virtual ~CSWbemObject(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
    
	// ISWbemObject methods

	HRESULT STDMETHODCALLTYPE Put_
	(
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectPath **ppObject
    );

	HRESULT STDMETHODCALLTYPE Delete_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext
    );

	HRESULT STDMETHODCALLTYPE Instances_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Subclasses_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE ExecMethod_ 
	(
        /*[in]*/	BSTR methodName,
        /*[in]*/	/*ISWbemObject*/ IDispatch *pInParams,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObject **ppOutParams
    );

	HRESULT STDMETHODCALLTYPE Associators_
	(
		/*[in]*/	BSTR assocClass,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR resultRole,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredAssocQualifier,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE References_
	(
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE Clone_
	(
		/*[out]*/	ISWbemObject **ppCopy
    );

    HRESULT STDMETHODCALLTYPE GetObjectText_
	(
        /*[in]*/	long lFlags,
		/*[out]*/	BSTR *pObjectText
    );

    HRESULT STDMETHODCALLTYPE SpawnDerivedClass_
	(
	    /*[in]*/	long lFlags,
		/*[out]*/	ISWbemObject** ppNewClass
    );

    HRESULT STDMETHODCALLTYPE SpawnInstance_
	(
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemObject** ppNewInstance
    );

    HRESULT STDMETHODCALLTYPE CompareTo_
	(
        /*[in]*/	/*ISWbemObject*/ IDispatch *pCompareTo,
        /*[in]*/	long lFlags,
        /*[out]*/	VARIANT_BOOL *result
    );

    HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
        /*[out]*/	ISWbemQualifierSet **ppQualifierSet
    );

    HRESULT STDMETHODCALLTYPE get_Properties_
	(
		/*[out]*/	ISWbemPropertySet **ppPropertySet
    );

    HRESULT STDMETHODCALLTYPE get_Methods_
	(
		/*[out]*/	ISWbemMethodSet **ppMethodSet
    );

	HRESULT STDMETHODCALLTYPE get_Derivation_
	(
		/*[out]*/	VARIANT *pClassNames
    );

	HRESULT STDMETHODCALLTYPE get_Path_
	(
		/*[out]*/	ISWbemObjectPath **ppObjectPath
    );

	// Async methods

	HRESULT STDMETHODCALLTYPE PutAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE DeleteAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE InstancesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE SubclassesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE AssociatorsAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strAssocClass,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strResultRole,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE ReferencesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE ExecMethodAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strMethodName,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);


	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISWbemObjectEx methods

	HRESULT STDMETHODCALLTYPE Refresh_ (
		/*[ in ]*/ long iFlags,
        /*[ in ]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet
		);

    HRESULT STDMETHODCALLTYPE get_SystemProperties_
	(
		/*[out]*/	ISWbemPropertySet **ppPropertySet
    );

	HRESULT STDMETHODCALLTYPE GetText_ (
		/*[in]*/ WbemObjectTextFormatEnum iObjectTextFormat,
		/*[in]*/ long iFlags,
		/*[in]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ BSTR *bsText
		);

	HRESULT STDMETHODCALLTYPE SetFromText_ (
		/*[in]*/ BSTR bsText,
		/*[in]*/ WbemObjectTextFormatEnum iObjectTextFormat,
		/*[in]*/ long iFlags,
		/*[in]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet
		);

	// ISWbemInternalObject methods
	
	HRESULT STDMETHODCALLTYPE GetIWbemClassObject (IWbemClassObject **ppObject);
	HRESULT STDMETHODCALLTYPE SetSite (ISWbemInternalObject *pParentObject, 
									   BSTR propertyName, long index = -1);
	HRESULT STDMETHODCALLTYPE UpdateSite ();
	

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return (m_pDispatch) ? m_pDispatch->GetClassInfo (ppTI) : E_FAIL;
	};

	// Other methods
	static IWbemClassObject	*GetIWbemClassObject (IDispatch *pDispatch);

	IWbemClassObject*	GetIWbemClassObject () 
	{ 
		m_pIWbemClassObject->AddRef ();
		return m_pIWbemClassObject; 
	}

	void SetIWbemClassObject (IWbemClassObject *pIWbemClassObject);

	static void SetSite (IDispatch *pDispatch, 
							ISWbemInternalObject *pSObject, BSTR propertyName, long index = -1);

};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectSet interface.  
//
//***************************************************************************

class CSWbemObjectSet : public ISWbemObjectSet,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;
	bool					m_firstEnumerator;
	bool					m_bIsEmpty;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectSet(CSWbemServices *pService, IEnumWbemClassObject *pIEnumWbemClassObject,
					CSWbemSecurity *pSecurity = NULL);
	CSWbemObjectSet (void);
    ~CSWbemObjectSet(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemObject **ppObject
    );        

	// ISWbemObjectSet methods

	HRESULT STDMETHODCALLTYPE Reset 
	(
	);

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lTimeout,
        /*[out]*/	ISWbemObject **ppObject
    );

	HRESULT STDMETHODCALLTYPE Clone
	(
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Skip
	(
        /*[in]*/	ULONG lElements,
		/*[in]*/	long lTimeout
    );

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
	CSWbemServices *GetSWbemServices ()
	{
		return m_pSWbemServices;
	}

	HRESULT CloneObjectSet (CSWbemObjectSet **ppEnum);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\object.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJECT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectEx
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObject::CSWbemObject
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObject::CSWbemObject(CSWbemServices *pService, IWbemClassObject *pObject,
						   CSWbemSecurity *pSecurity,
						   bool isErrorObject) :
								m_pSWbemServices (NULL),
								m_pSite (NULL),
								m_pIWbemRefresher (NULL),
								m_bCanUseRefresher (true)
{
	m_cRef=0;
	m_isErrorObject = isErrorObject;
	m_pIWbemClassObject = pObject;
	m_pIWbemClassObject->AddRef ();
	m_pIServiceProvider = NULL;

	if (pService)
	{
		m_pSWbemServices = new CSWbemServices (pService, pSecurity);

		if (m_pSWbemServices)
			m_pSWbemServices->AddRef ();
	}

	m_pDispatch = new CWbemDispatchMgr (m_pSWbemServices, this);

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemObject::~CSWbemObject
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemObject::~CSWbemObject(void)
{
	InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pIWbemClassObject)
	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_pSite)
	RELEASEANDNULL(m_pIWbemRefresher)
	DELETEANDNULL(m_pDispatch);
}

//***************************************************************************
// HRESULT CSWbemObject::QueryInterface
// long CSWbemObject::AddRef
// long CSWbemObject::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

	/*
	 * Only acknowledge the last error or object safety
	 * interfaces if we are an error object.
	 */

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObject==riid)
        *ppv = (ISWbemObject *)this;
	else if (IID_ISWbemObjectEx==riid)
        *ppv = (ISWbemObjectEx *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)((ISWbemObjectEx *)this);
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISWbemInternalObject==riid)
		*ppv = (ISWbemInternalObject *) this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	else if (m_isErrorObject)
	{
		if (IID_ISWbemLastError==riid)
			*ppv = (ISWbemObject *) this;
		else if (IID_IObjectSafety==riid)
			*ppv = (IObjectSafety *) this;
	}
	else if (IID_IObjectSafety==riid)
	{
		/*
		 * Explicit check because we don't want
		 * this interface hijacked by a custom interface.
		 */
		*ppv = NULL;
	}

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObject::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObject::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemObject::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemObject::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  (m_pDispatch ? m_pDispatch->GetTypeInfoCount(pctinfo) : E_FAIL);}
STDMETHODIMP		CSWbemObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemObject::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetTypeInfo(itinfo, lcid, pptinfo) : E_FAIL);}
STDMETHODIMP		CSWbemObject::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemObject::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid) : E_FAIL);}
STDMETHODIMP		CSWbemObject::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemObject::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->Invoke(dispidMember, riid, lcid, wFlags,
		pdispparams, pvarResult, pexcepinfo, puArgErr) : E_FAIL);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemObject::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemObject::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetDispID(bstrName, grfdex, pid) : E_FAIL);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemObject::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemObject::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	/*
	 * Store away the service provider so that it can be accessed
	 * by calls that remote to CIMOM
	 */

	if (m_pDispatch)
	{
		m_pIServiceProvider = pspCaller;
		hr = m_pDispatch->InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
		m_pIServiceProvider = NULL;
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemObject::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_pDispatch->DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemObject::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->DeleteMemberByDispID(id) : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemObject::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetMemberProperties(id, grfdexFetch, pgrfdex) : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemObject::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetMemberName(id, pbstrName) : E_FAIL);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemObject::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemObject::GetNextDispID()";)
	_RPrint(me, "Called", 0, "");

	return S_FALSE;

}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemObject::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetNameSpaceParent(ppunk) : E_FAIL);
}

//***************************************************************************
// HRESULT CSWbemObject::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return ((IID_ISWbemObject == riid) ||
		    (IID_ISWbemObjectEx == riid)) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  CSWbemObject::GetIWbemClassObject
//
//  DESCRIPTION:
//
//  Return the IWbemClassObject interface corresponding to this
//	scriptable wrapper.
//
//  PARAMETERS:
//		ppObject		holds the IWbemClassObject pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::GetIWbemClassObject (IWbemClassObject **ppObject)
{
	HRESULT hr = E_FAIL;

	if (ppObject)
		*ppObject = NULL;

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->AddRef ();
		*ppObject = m_pIWbemClassObject;
		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  CSWbemObject::SetIWbemClassObject
//
//  DESCRIPTION:
//
//  Set a new IWbemClassObject interface inside this scriptable wrapper.
//
//  PARAMETERS:
//		pIWbemClassObject		- the new IWbemClassObject
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

void CSWbemObject::SetIWbemClassObject (
	IWbemClassObject *pIWbemClassObject
)
{
	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	m_pIWbemClassObject = pIWbemClassObject;
	
	if (m_pIWbemClassObject)
		m_pIWbemClassObject->AddRef ();
	
	if (m_pDispatch)
		m_pDispatch->SetNewObject (m_pIWbemClassObject);
};

//***************************************************************************
//
//  SCODE CSWbemObject::Put_
//
//  DESCRIPTION:
//
//  Save/commit this class or instance into a namespace
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppObjectPath	Object Path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Put_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			// Figure out whether this is a class or instance
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);
				IWbemServices	*pIService = m_pSWbemServices->GetIWbemServices ();
				IWbemCallResult *pResult = NULL;
				HRESULT hrCallResult = WBEM_E_FAILED;

				if (pIService)
				{
					CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

					if (pSecurity)
					{
						bool needToResetSecurity = false;
						HANDLE hThreadToken = NULL;

						if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
						{
							if (WBEM_GENUS_CLASS  == var.lVal)
								hrCallResult = pIService->PutClass
										(m_pIWbemClassObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
							else
								hrCallResult = pIService->PutInstance
										(m_pIWbemClassObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
						}

						if (needToResetSecurity)
							pSecurity->ResetSecurity (hThreadToken);

						pSecurity->Release ();
					}

					pIService->Release ();
				}

				/*
				 * Secure the IWbemCallResult interface
				 */

				if (WBEM_S_NO_ERROR == hrCallResult)
				{
					CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

					if (pSecurity)
						pSecurity->SecureInterface (pResult);

					if ((WBEM_S_NO_ERROR == (hrCallResult = pResult->GetCallStatus (INFINITE, &hr))) &&
						(WBEM_S_NO_ERROR == hr))
					{
						if (ppObjectPath)
						{
							ISWbemObjectPath *pObjectPath =
									new CSWbemObjectPath (pSecurity, m_pSWbemServices->GetLocale());

							if (!pObjectPath)
								hr = WBEM_E_OUT_OF_MEMORY;
							else
							{
								pObjectPath->AddRef ();
								pObjectPath->put_Path (m_pSWbemServices->GetPath ());
								
								if (WBEM_GENUS_CLASS == var.lVal)
								{
									VARIANT nameVar;
									VariantInit (&nameVar);

									/*
									 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
									 * the __CLASS property has not yet been set.
									 */

									if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
										&& (VT_BSTR == V_VT(&nameVar)))
									{
										pObjectPath->put_Class (nameVar.bstrVal);
										*ppObjectPath = pObjectPath;
									}
									else
										pObjectPath->Release ();

									VariantClear (&nameVar);
								}
								else
								{
									// Now get the relpath string from the call result
									BSTR resultString = NULL;

									if (WBEM_S_NO_ERROR == pResult->GetResultString (INFINITE, &resultString))
									{
										pObjectPath->put_RelPath (resultString);
										*ppObjectPath = pObjectPath;
										SysFreeString (resultString);
									}
									else
										pObjectPath->Release ();

								}
							}
						}
					}

					if (pSecurity)
						pSecurity->Release ();
				}
				else
					hr = hrCallResult;

				if (pResult)
					pResult->Release ();

				SetWbemError (m_pSWbemServices);

				if (pIContext)
					pIContext->Release ();
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::Delete_
//
//  DESCRIPTION:
//
//  Delete this class or instance from the namespace
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Delete_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->Delete (bsPath, lFlags, pContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::Instances_
//
//  DESCRIPTION:
//
//  returns instances of this class
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Instances_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	/*[out]*/	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->InstancesOf (bsPath, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Subclasses_
//
//  DESCRIPTION:
//
//  returns subclasses of this class
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Subclasses_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	/*[out]*/	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->SubclassesOf (bsPath, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Associators_
//
//  DESCRIPTION:
//
//  returns associators of this object
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Associators_ (
	BSTR assocClass,
	BSTR resultClass,
	BSTR resultRole,
	BSTR role,
	VARIANT_BOOL classesOnly,
	VARIANT_BOOL schemaOnly,
	BSTR requiredAssocQualifier,
	BSTR requiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->AssociatorsOf (bsPath, assocClass, resultClass,
						resultRole, role, classesOnly, schemaOnly,
						requiredAssocQualifier, requiredQualifier, lFlags, 
						pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::References_
//
//  DESCRIPTION:
//
//  returns references to this object
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::References_ (
	BSTR resultClass,
	BSTR role,
	VARIANT_BOOL classesOnly,
	VARIANT_BOOL schemaOnly,
	BSTR requiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		CComBSTR bsPath;
		
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ReferencesTo (bsPath, resultClass,
						role, classesOnly, schemaOnly,
						requiredQualifier, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::ExecMethod_
//
//  DESCRIPTION:
//
//  Executes a method of this class (or instance)
//
//  PARAMETERS:
//
//		bsMethod			The name of the method to call
//		pInParams			The in-parameters
//		lFlags				Flags
//		pContext			Any context information
//		ppOutParams			The out-parameters
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::ExecMethod_ (
	BSTR bsMethod,
	/*ISWbemObject*/ IDispatch *pInParams,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObject **ppOutParams
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ExecMethod (bsPath, bsMethod,
							pInParams, lFlags, pContext, ppOutParams);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Clone_
//
//  DESCRIPTION:
//
//  Clone object
//
//  PARAMETERS:
//		ppCopy		On successful return addresses the copy
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Clone_ (
	ISWbemObject **ppCopy
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppCopy)
		return WBEM_E_INVALID_PARAMETER;

	if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Clone (&pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else 
			{
				if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppCopy)))
					delete pObject;
			}

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::GetObjectText_
//
//  DESCRIPTION:
//
//  Get MOF Description of Object
//
//  PARAMETERS:
//		lFlags			flags
//		pObjectText		on successful return holds MOF text
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::GetObjectText_ (
	long	lFlags,
	BSTR	*pObjectText
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemClassObject)
		hr = m_pIWbemClassObject->GetObjectText (lFlags, pObjectText);

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::SpawnDerivedClass_
//
//  DESCRIPTION:
//
//  Create a subclass of this (class) object
//
//  PARAMETERS:
//		lFlags			Flags
//		ppNewClass		On successful return addresses the subclass
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SpawnDerivedClass_ (
	long lFlags,
	ISWbemObject **ppNewClass
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNewClass)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->SpawnDerivedClass (lFlags, &pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppNewClass)))
					delete pObject;

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::SpawnInstance_
//
//  DESCRIPTION:
//
//  Create an instance of this (class) object
//
//  PARAMETERS:
//		lFlags			Flags
//		ppNewInstance	On successful return addresses the instance
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SpawnInstance_ (
	long lFlags,
	ISWbemObject **ppNewInstance
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNewInstance)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->SpawnInstance (lFlags, &pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppNewInstance)))
					delete pObject;

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::CompareTo_
//
//  DESCRIPTION:
//
//  Compare this object against another
//
//  PARAMETERS:
//		pCompareTo		The object to compare this against
//		lFlags			Flags
//		pResult			On return contains the match status (TRUE/FALSE)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::CompareTo_ (
	/*ISWbemObject*/ IDispatch *pCompareTo,
    long lFlags,
    VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == pCompareTo) || (NULL == pResult))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pObject = CSWbemObject::GetIWbemClassObject (pCompareTo);

		if (NULL != pObject)
		{
			if (SUCCEEDED (hr = m_pIWbemClassObject->CompareTo (lFlags, pObject)))
				*pResult = (WBEM_S_SAME == hr) ? VARIANT_TRUE : VARIANT_FALSE;

			pObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Qualifiers_
//
//  DESCRIPTION:
//
//  retrieve the qualifier set for this object
//
//  PARAMETERS:
//
//		ppQualSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppQualSet = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemQualifierSet *pQualSet = NULL;

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetQualifierSet (&pQualSet)))
			{
				if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet, this)))
					hr = WBEM_E_OUT_OF_MEMORY;

				pQualSet->Release ();
			}
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Properties_
//
//  DESCRIPTION:
//
//  retrieve the property set for this object
//
//  PARAMETERS:
//
//		ppPropSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Properties_ (
	ISWbemPropertySet **ppPropSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPropSet)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPropSet = NULL;

		if (m_pIWbemClassObject)
		{
			if (!(*ppPropSet = new CSWbemPropertySet (m_pSWbemServices, this)))
				hr = WBEM_E_OUT_OF_MEMORY;
			else
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_SystemProperties_
//
//  DESCRIPTION:
//
//  retrieve the system property set for this object
//
//  PARAMETERS:
//
//		ppPropSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_SystemProperties_ (
	ISWbemPropertySet **ppPropSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPropSet)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPropSet = NULL;

		if (m_pIWbemClassObject)
		{
			if (!(*ppPropSet = new CSWbemPropertySet (m_pSWbemServices, this, true)))
				hr = WBEM_E_OUT_OF_MEMORY;
			else
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Methods_
//
//  DESCRIPTION:
//
//  retrieve the method set for this object
//
//  PARAMETERS:
//
//		ppMethodSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Methods_ (
	ISWbemMethodSet **ppMethodSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethodSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethodSet = NULL;

		if (m_pIWbemClassObject)
		{
			/*
			 * For classes the IWbemClassObject will contain the method
			 * definition, but for instances it will be empty.  In that
			 * case we need to try and get the underlying class.
			 */
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{
				if (WBEM_GENUS_CLASS  == var.lVal)
				{
					if (!(*ppMethodSet = new CSWbemMethodSet (m_pSWbemServices, m_pIWbemClassObject)))
						hr = WBEM_E_OUT_OF_MEMORY;
					else
						hr = WBEM_S_NO_ERROR;
				}
				else
				{
					if (m_pSWbemServices)
					{
						// An instance; try to get the class
						VariantClear (&var);

						/*
						 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
						 * the __CLASS property has not yet been set.
						 */

						if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &var, NULL, NULL))
							&& (VT_BSTR == V_VT(&var)))
						{
							IWbemServices *pIService = m_pSWbemServices->GetIWbemServices ();
							IWbemClassObject *pObject = NULL;

							if (pIService)
							{
								// Check privileges are set ok
								CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

								if (pSecurity)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;

									if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIService->GetObject (var.bstrVal,
												0, NULL, &pObject, NULL);

									if (SUCCEEDED(hr))
									{
										if (!(*ppMethodSet = 
												new CSWbemMethodSet (m_pSWbemServices, pObject)))
											hr = WBEM_E_OUT_OF_MEMORY;

										pObject->Release ();
									}

									if (needToResetSecurity)
										pSecurity->ResetSecurity (hThreadToken);

									pSecurity->Release ();
								}

								pIService->Release ();
							}
						}
					}
				}
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Path_
//
//  DESCRIPTION:
//
//  retrieve the object path for this object
//
//  PARAMETERS:
//
//		ppObjectPath		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Path_ (
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppObjectPath = NULL;

		if (m_pIWbemClassObject)
		{
			CSWbemObjectObjectPath *pObjectPath =
					new CSWbemObjectObjectPath (m_pSWbemServices, this);

			if (!pObjectPath)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObjectPath->QueryInterface (IID_ISWbemObjectPath,
														(PPVOID) ppObjectPath)))
				delete pObjectPath;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Derivation_
//
//  DESCRIPTION:
//
//  Get the class derivation array.
//
//  PARAMETERS:
//
//		ppNames				Holds the names on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Derivation_ (
    VARIANT *pNames
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pNames)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_DERIVATION, 0, &var, NULL, NULL))
			{
				/* The value should be a VT_BSTR|VT_ARRAY */
				if (((VT_ARRAY | VT_BSTR) == var.vt) && (NULL != var.parray))
				{
					// Make a safearray of VARIANTS from the array of BSTRs
					SAFEARRAYBOUND rgsabound;
					rgsabound.lLbound = 0;

					long lBound = 0, uBound = 0;
					SafeArrayGetUBound (var.parray, 1, &uBound);
					SafeArrayGetLBound (var.parray, 1, &lBound);

					rgsabound.cElements = uBound + 1 - lBound;
					SAFEARRAY *pArray = SafeArrayCreate (VT_VARIANT, 1, &rgsabound);
					BSTR bstrName = NULL;
					VARIANT nameVar;
					VariantInit (&nameVar);

					for (long i = 0; i <= uBound; i++)
					{
						SafeArrayGetElement (var.parray, &i, &bstrName);
						BSTR copy = SysAllocString (bstrName);
						nameVar.vt = VT_BSTR;
						nameVar.bstrVal = copy;
						SafeArrayPutElement (pArray, &i, &nameVar);
						SysFreeString (bstrName);
						VariantClear (&nameVar);
					}

					// Now plug this array into the VARIANT
					pNames->vt = VT_ARRAY | VT_VARIANT;
					pNames->parray = pArray;

					hr = S_OK;
				}
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_pSWbemServices)
		{
			*ppSecurity = m_pSWbemServices->GetSecurityInfo ();

			if (*ppSecurity)
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Refresh_
//
//  DESCRIPTION:
//
//  Refresh the current object
//
//  PARAMETERS:
//		lFlags				Flags
//		pContext			Operation context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Refresh_ (
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			CComPtr<IWbemContext>	pIContext;

			//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
			//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
			pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));

			// Order of preference:
			//	1. IWbemConfigureRefresher::AddObjectByTemplate
			//	2. IWbemServices::GetObject

			CComPtr<IWbemServices>	pIWbemServices = m_pSWbemServices->GetIWbemServices ();
		
			if (pIWbemServices)
			{
				bool bUseRefresher = false;
				bool bOperationFailed = false;
				// Is this a class or an instance?
				bool bIsClass = false;
				CComVariant var;

				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
					bIsClass = (WBEM_GENUS_CLASS  == var.lVal);

				/*
				 * IWbemConfigureRefresher cannot handle per-refresh context; if the caller
				 * gave us some context we'll have to drop down to loperf retrieval.
				 *
				 * Similarly the refresher cannot handle classes.
				 */
				if (bIsClass || (!pIContext))
				{
					if (m_bCanUseRefresher)
					{
						// If we don't have one get ourselves a refresher 
						if (NULL == m_pIWbemRefresher)
						{
							m_bCanUseRefresher = false;  // Until proven otherwise

							if (SUCCEEDED(CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, 
										IID_IWbemRefresher, (void**) &m_pIWbemRefresher )))
							{
								IWbemConfigureRefresher *pConfigureRefresher = NULL;

								// Get ourselves a refresher configurator
								if (SUCCEEDED(m_pIWbemRefresher->QueryInterface (IID_IWbemConfigureRefresher, 
													(void**) &pConfigureRefresher)))
								{
									CComPtr<IWbemClassObject>	pNewObject;
									long				lID = 0;

									// Add our object into it; we mask out all flag bits other 
									// than WBEM_FLAG_USE_AMENDED_QUALIFIERS.
									HRESULT hrRef = pConfigureRefresher->AddObjectByTemplate
											(pIWbemServices, m_pIWbemClassObject, 
											 iFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS, 
											 pIContext, &pNewObject, &lID);

									if (SUCCEEDED (hrRef))
									{
										m_bCanUseRefresher = true;	// Now we can use it

										// Swap in our refreshable object
										SetIWbemClassObject (pNewObject);

									}
									else if ((WBEM_E_INVALID_OPERATION != hrRef) &&
											 (WBEM_E_INVALID_PARAMETER != hrRef))
										bOperationFailed = true;	// A real refresh-independent failure

									pConfigureRefresher->Release ();
								}

								// If we can't use the refresher, release it now
								if (!m_bCanUseRefresher)
								{
									m_pIWbemRefresher->Release ();
									m_pIWbemRefresher = NULL;
								}
							}
						}

						bUseRefresher = m_bCanUseRefresher;
					}
				}

				// Having successfully set up a refresher/non-refresher scenario, let's go refresh
				if (!bOperationFailed)
				{
					if (bUseRefresher && m_pIWbemRefresher)
					{
						// Mask out all flags other than WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT 
						hr = m_pIWbemRefresher->Refresh (iFlags & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
					}
					else
					{
						// Bah - not even a refresher can we use. Just do a GetObject instead
						CComBSTR bsPath;

						if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
						{
							// Fall pack to the low-perf way of doing things
							CComPtr<IWbemClassObject> pNewObject;

							// Mask out the WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT flag
							if (SUCCEEDED(hr = pIWbemServices->GetObject (bsPath, 
													iFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT, 
													pIContext, &pNewObject, NULL)))
							{
								// Swap in the new object
								SetIWbemClassObject (pNewObject);
							}
						}
					}
				}
			}
		}
	}

	SetWbemError (m_pSWbemServices);

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::GetText_
//
//  DESCRIPTION:
//
//  Get the object text
//
//  PARAMETERS:
//		iObjectTextFormat		Text format
//		pContext				Context
//		pbsText					On return holds text
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::GetText_ (
	WbemObjectTextFormatEnum iObjectTextFormat,
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	BSTR *pbsText
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pbsText)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		*pbsText = NULL;
		CComPtr<IWbemContext>	pIContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
		pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));


		CComPtr<IWbemObjectTextSrc> pIWbemObjectTextSrc;
		
		if (SUCCEEDED(CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, 
						IID_IWbemObjectTextSrc, (PPVOID) &pIWbemObjectTextSrc)))
		{
			hr = pIWbemObjectTextSrc->GetText (iFlags, m_pIWbemClassObject, (ULONG) iObjectTextFormat,
							pIContext, pbsText);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
	
//***************************************************************************
//
//  SCODE CSWbemObject::SetFromText_
//
//  DESCRIPTION:
//
//  Set the object using the supplied text
//
//  PARAMETERS:
//		bsText					The text
//		iObjectTextFormat		Text format
//		pContext				Context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SetFromText_ (
	BSTR bsText,
	WbemObjectTextFormatEnum iObjectTextFormat,
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == bsText)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		CComPtr<IWbemContext>	pIContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));

		CComPtr<IWbemObjectTextSrc> pIWbemObjectTextSrc;

		if (SUCCEEDED(CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, 
						IID_IWbemObjectTextSrc, (PPVOID) &pIWbemObjectTextSrc)))
		{
			CComPtr<IWbemClassObject> pIWbemClassObject;

			if (SUCCEEDED(hr = pIWbemObjectTextSrc->CreateFromText (iFlags, bsText, (ULONG) iObjectTextFormat,
							pIContext, &pIWbemClassObject)))
			{
				// Set the new object into our object
				SetIWbemClassObject (pIWbemClassObject);
			}
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemObject::GetIWbemClassObject
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemObjectEx
//	interface, return the underlying IWbemClassObject interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemClassObject interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************
IWbemClassObject	*CSWbemObject::GetIWbemClassObject (
	IDispatch *pDispatch
)
{
	IWbemClassObject *pObject = NULL;
	ISWbemInternalObject *pIObject = NULL;

	if (NULL != pDispatch)
	{
		if (SUCCEEDED (pDispatch->QueryInterface
								(IID_ISWbemInternalObject, (PPVOID) &pIObject)))
		{
			pIObject->GetIWbemClassObject (&pObject);
			pIObject->Release ();
		}
	}

	return pObject;
}

//***************************************************************************
//
//  CSWbemObject::UpdateSite
//
//  DESCRIPTION:
//
//  If this object represents an embedded CIM object property value, then
//  as a result of changes to properties/qualifiers/path on this object it
//	is necessary to update the object in its parent.
//
//	This is to allow the following code to work:
//
//		Object.EmbeddedProperty.SimpleProperty = 3
//
//	i.e. so that the set to the value of SimpleProperty triggers an
//	automatic set of EmbeddedProperty to Object.
//
//  RETURN VALUES:
//		The underlying IWbemClassObject interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::UpdateSite ()
{
	// Update the site if it exists
	if (m_pSite)
		m_pSite->Update ();

	return S_OK;
}

//***************************************************************************
//
//  CSWbemObject::SetSite
//
//  DESCRIPTION:
//
//  Set the site of this object; this is used to anchor an embedded object
//	to a property (possibly indexed, if that property is an array).
//
//  PARAMETERS:
//		pParentObject	The parent of this object
//		propertyName	The property name for this object
//		index			The array index into the property (or -1)
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::SetSite (
	ISWbemInternalObject *pParentObject,
	BSTR propertyName,
	long index
)
{
	if (m_pSite)
	{
		m_pSite->Release ();
		m_pSite = NULL;
	}

	CSWbemProperty *pSProperty = new CSWbemProperty (m_pSWbemServices,
					pParentObject, propertyName);
	m_pSite = new CWbemPropertySite (pSProperty, m_pIWbemClassObject, index);

	if (pSProperty)
		pSProperty->Release ();

	return S_OK;
}

void CSWbemObject::SetSite (IDispatch *pDispatch,
							ISWbemInternalObject *pSObject, BSTR propertyName, long index)
{
	if (NULL != pDispatch)
	{
		ISWbemInternalObject *pObject = NULL;

		if (SUCCEEDED (pDispatch->QueryInterface
								(IID_ISWbemInternalObject, (PPVOID) &pObject)))
		{
			pObject->SetSite (pSObject, propertyName, index);
			pObject->Release ();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\nvalue.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  nvalue.h
//
//  alanbos  27-Mar-00   Created.
//
//  General purpose include file.
//
//***************************************************************************

#ifndef _NVALUE_H_
#define _NVALUE_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemNamedValueSetE interface.  
//
//***************************************************************************

class CSWbemNamedValueSet : public ISWbemNamedValueSet,
							public ISWbemInternalContext,
							public IObjectSafety,
							public ISupportErrorInfo,
							public IProvideClassInfo
{
private:
	class CContextDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	CSWbemServices			*m_pSWbemServices;
	IWbemContext			*m_pIWbemContext;
	CContextDispatchHelp	m_Dispatch;
	CWbemPathCracker		*m_pCWbemPathCracker;
	bool					m_bMutable;

	void					BuildContextFromKeyList ();
	HRESULT					SetValueIntoContext (BSTR bsName, VARIANT *pVal, ULONG lFlags);
	
protected:
	long            m_cRef;         //Object reference count

public:
    
	CSWbemNamedValueSet (void);
    CSWbemNamedValueSet (CSWbemServices *pService, IWbemContext *pIWbemContext);
	CSWbemNamedValueSet (CWbemPathCracker *pCWbemPathCracker, bool bMutable = true);
    ~CSWbemNamedValueSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// ISWbemInternalContext
	STDMETHODIMP GetIWbemContext (IWbemContext **pContext);

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	VARIANT *pValue,
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemNamedValue **ppNamedValue
    );        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemNamedValue **ppValue
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemNamedValueSet methods

	HRESULT STDMETHODCALLTYPE Clone
	(
		/*[out]*/	ISWbemNamedValueSet **pNewCopy
	);

    HRESULT STDMETHODCALLTYPE DeleteAll
	(
	);   
	
	// CSWbemNamedValueSet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
	);

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemNamedValue **ppNamedValue
    );

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}
	
	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
    static IWbemContext	*GetIWbemContext (IDispatch *pDispatch, IServiceProvider *pServiceProvider = NULL);
	static IDispatch *GetSWbemContext(IDispatch *pDispatch, 
									IServiceProvider *pServiceProvider, CSWbemServices *pServices);

	IWbemContext *GetIWbemContext ()
	{
		m_pIWbemContext->AddRef ();
		return m_pIWbemContext;
	}

	CWbemPathCracker *GetWbemPathCracker ()
	{
		CWbemPathCracker *pCWbemPathCracker = NULL;

		if (m_pCWbemPathCracker)
		{
			pCWbemPathCracker = m_pCWbemPathCracker;
			pCWbemPathCracker->AddRef ();
		}

		return pCWbemPathCracker;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Implements the ISWbemNamedValue interface.  
//
//***************************************************************************

class CSWbemNamedValue : public ISWbemNamedValue,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	class CNamedValueDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};

	CSWbemServices			*m_pSWbemServices;
	CSWbemNamedValueSet		*m_pCSWbemNamedValueSet;
	CNamedValueDispatchHelp	m_Dispatch;
	BSTR					m_name;
	bool					m_bMutable;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemNamedValue (CSWbemServices *pService, CSWbemNamedValueSet *pCSWbemNamedValueSet, 
						BSTR name, bool bMutable = true);
    ~CSWbemNamedValue (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemNamedValue methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\nvalue.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  NVALUE.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemNamedValue
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemNamedValue::CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValue::CSWbemNamedValue(
	CSWbemServices *pService, 
	CSWbemNamedValueSet *pCSWbemNamedValueSet, 
	BSTR name,
	bool bMutable
)
		: m_bMutable (bMutable),
		  m_cRef (1),
		  m_pCSWbemNamedValueSet (pCSWbemNamedValueSet),
		  m_pSWbemServices (pService)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValue, 
						CLSID_SWbemNamedValue, L"SWbemNamedValue");
    
	if (m_pCSWbemNamedValueSet)
		m_pCSWbemNamedValueSet->AddRef ();
	
	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValue::~CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemNamedValue::~CSWbemNamedValue(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemNamedValueSet)
	{
		m_pCSWbemNamedValueSet->Release ();
		m_pCSWbemNamedValueSet = NULL;
	}

	if (m_pSWbemServices)
	{
		m_pSWbemServices->Release ();
		m_pSWbemServices = NULL;
	}

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemNamedValue::QueryInterface
// long CSWbemNamedValue::AddRef
// long CSWbemNamedValue::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValue::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemNamedValue==riid)
		*ppv = (ISWbemNamedValue *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemNamedValue::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemNamedValue::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemNamedValue::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValue::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemNamedValue == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		VariantClear (pValue);
		IWbemContext *pIWbemContext = m_pCSWbemNamedValueSet->GetIWbemContext ();

		if (pIWbemContext)
		{
			hr = pIWbemContext->GetValue (m_name, 0, pValue);
			pIWbemContext->Release ();
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::put_Value
//
//  DESCRIPTION:
//
//  Set the value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pVal)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else 
	{
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
		pIWbemContext.Attach(m_pCSWbemNamedValueSet->GetIWbemContext ());

		if (pIWbemContext)
		{
			CWbemPathCracker *pPathCracker = m_pCSWbemNamedValueSet->GetWbemPathCracker ();
			CIMTYPE newCimType = CIM_ILLEGAL;

			if (VT_BYREF & V_VT(pVal))
			{
				// We must dereference all byref's
				VARIANT var;
				VariantInit (&var);

				if (VT_ARRAY & V_VT(pVal))
				{
					var.vt = V_VT(pVal) & ~VT_BYREF;
					hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
				}
				else
					hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

				if (SUCCEEDED(hr))
				{
					// Here the oldCimType is a "serving suggestion" - if
					// we need a different cimtype to match the new value
					// so be it, even if it's CIM_ILLEGAL
					newCimType = MapVariantTypeToCimType (&var, CIM_ILLEGAL);
					
					bool ok = true;

					// If we have a keylist, must ensure we can set it in the
					// keylist first
					if (pPathCracker)
					{
						if (pPathCracker->SetKey (m_name, (WbemCimtypeEnum) newCimType, var))
							ok = false;
					}
					
					if (ok)
					{
						// Finally set it in the context itself
						hr = pIWbemContext->SetValue (m_name, 0, &var);
					}
					else
						hr = WBEM_E_FAILED;
				}
				
				VariantClear (&var);
			}
			else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
			{
				// Treat as NULL assignment
				pVal->vt = VT_NULL;
				
				// NULL assigments not valid for keylists
				if (pPathCracker)
					hr = WBEM_E_FAILED;
				else
				{
					hr = pIWbemContext->SetValue (m_name, 0, pVal);
				}	
			}
			else
			{
				// Here the oldCimType is a "serving suggestion" - if
				// we need a different cimtype to match the new value
				// so be it, even if it's CIM_ILLEGAL
				newCimType = MapVariantTypeToCimType (pVal, CIM_ILLEGAL);
				
				bool ok = true;

				// If we have a keylist, must ensure we can set it in the
				// keylist first
				if (pPathCracker)
				{
					if (pPathCracker->SetKey (m_name, (WbemCimtypeEnum) newCimType, *pVal))
						ok = false;
				}
				
				if (ok)
				{
					// Finally set it in the context itself
					hr = pIWbemContext->SetValue (m_name, 0, pVal);
				}
				else
					hr = WBEM_E_FAILED;
			}

			if (pPathCracker)
				pPathCracker->Release ();
		}
	}		

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the value name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemNamedValue::CNamedValueDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::CNamedValueDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Value property) which
	 * supplied an argument.  Since the Value property is of type VARIANT, this may
	 * be legal but undetectable by the standard Dispatch mechanism, because in the
	 * the case that the named value happens to be an array type, it is meaningful to
	 * pass an index (the interpretation is that the index specifies an offset in
	 * the VT_ARRAY|VT_VARIANT structure that represents the named value).
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		// Looks promising - get the object to try and resolve this
			
		ISWbemNamedValue *pNamedValue = NULL;

		// This tells us where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemNamedValue, (PPVOID) &pNamedValue)))
		{
			// Extract the current named value
			VARIANT vNVal;
			VariantInit (&vNVal);

			if (SUCCEEDED(pNamedValue->get_Value (&vNVal)) && V_ISARRAY(&vNVal))
			{
				VARIANT indexVar;
				VariantInit (&indexVar);

				// Attempt to coerce the index argument into a value suitable for an array index
				if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
				{
					long lArrayPropInx = V_I4(&indexVar);

					// Is this a Get? There should be one argument (the array index)
					if (DISPATCH_PROPERTYGET & wFlags)
					{
						if (1 == pdispparams->cArgs)
						{
							// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
							// VARIANT

							VariantInit (pvarResult);
							hr = SafeArrayGetElement (vNVal.parray, &lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_BADPARAMCOUNT;
					}
					else if (DISPATCH_PROPERTYPUT & wFlags) 
					{
						if (2 == pdispparams->cArgs)
						{
							/*
							 * Try to interpret this as an array member set operation. For
							 * this the first argument passed is the new value, and the second
							 * is the array index.
							 */
						
							VARIANT vNewVal;
							VariantInit(&vNewVal);

							if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
							{
								// Check the index is not out of bounds and, if it is, grow
								// the array accordingly
								CheckArrayBounds (vNVal.parray, lArrayPropInx);

								// How do we decide on the type - try to access an array
								// member and use that type
								VARTYPE expectedVarType = VT_ILLEGAL;
								VARIANT dummyVar;
								VariantInit (&dummyVar);
								long lBound;
								SafeArrayGetLBound (vNVal.parray, 1, &lBound);

								if (SUCCEEDED (SafeArrayGetElement (vNVal.parray, &lBound, &dummyVar)))
									expectedVarType = V_VT(&dummyVar);

								VariantClear (&dummyVar);

								if (S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, expectedVarType))
								{
									// Set the value into the relevant index of the named value array
									if (S_OK == (hr = 
										SafeArrayPutElement (vNVal.parray, &lArrayPropInx, &vNewVal)))
									{
										// Set the entire property value
										if (SUCCEEDED (pNamedValue->put_Value (&vNVal)))
											hr = S_OK;
										else
										{
											hr = DISP_E_TYPEMISMATCH;
											if (puArgErr)
												*puArgErr = 0;
										}
									}
								}
								else
								{
									hr = DISP_E_TYPEMISMATCH;
									if (puArgErr)
										*puArgErr = 0;
								}
								
								VariantClear (&vNewVal);
							}
						}
						else 
							hr = DISP_E_BADPARAMCOUNT;
					}
				}
				else
				{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = indexArg;
				}

				VariantClear (&indexVar);
			}	

			VariantClear (&vNVal);
		}

		pNamedValue->Release ();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\objsink.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  objsink.cpp
//
//  rogerbo  22-May-98   Created.
//
//  Defines the implementation of IWbemObjectSink
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

DWORD CIWbemObjectSinkMethodCache::sm_dwTlsForInterfaceCache = -1;

// Encryption/Decryption helpers
void EncryptString(BSTR bsString)
{
	ULONG len = 0;

    if (bsString && (0 < wcslen (bsString)))
    {
        for ( ULONG x = 0; x < len; x++ )
        {
            bsString[x] += 1;
        }
    }
}

void DecryptString(BSTR bsString)
{
    ULONG len = 0;

    if (bsString && (0 < wcslen (bsString)))
    {
        for ( ULONG x = 0; x < len; x++ )
        {
            bsString[x] -= 1;
        }
    }
}


CWbemObjectSink::CWbemObjectSink(CSWbemServices *pServices, IDispatch *pSWbemSink, IDispatch *pContext,
								 bool putOperation, BSTR bsClassName) :
				m_pServices (NULL),
				m_pUnsecuredApartment (NULL),
				m_bsNamespace (NULL),
				m_bsUser (NULL),
				m_bsPassword (NULL),
				m_bsLocale (NULL)
{
	_RD(static char *me = "CWbemObjectSink::CWbemObjectSink";)
	_RPrint(me, "Called", 0, "");

	CIWbemObjectSinkMethodCache::AddRefForThread();
	m_cRef = 0;

	m_pObjectStub = NULL;
	m_pSWbemSink = NULL;
	m_putOperation = putOperation;
	m_pContext = pContext;
	m_bsClassName = NULL;

	m_operationInProgress = TRUE;
	m_setStatusCompletedCalled = FALSE;

	if (pSWbemSink)
	{
		ISWbemPrivateSinkLocator *pSinkLocator = NULL;
		HRESULT hr = pSWbemSink->QueryInterface(IID_ISWbemPrivateSinkLocator, (PPVOID)&pSinkLocator);
		if(SUCCEEDED(hr) && pSinkLocator)
		{
			IUnknown *pUnk = NULL;
			hr = pSinkLocator->GetPrivateSink(&pUnk);
			if(SUCCEEDED(hr) && pUnk)
			{
				pUnk->QueryInterface(IID_ISWbemPrivateSink, (PPVOID)&m_pSWbemSink);
				pUnk->Release();
			}
			pSinkLocator->Release();
		}
	}

	if (bsClassName)
		m_bsClassName = SysAllocString(bsClassName);

	/*
	 * Copy the services proxy to ensure independence of security attributes
	 * from the parent CSWbemServices.
	 */
	if (pServices)
	{
		m_pServices = new CSWbemServices (pServices, NULL);

		if (m_pServices)
			m_pServices->AddRef ();

		m_pUnsecuredApartment = pServices->GetCachedUnsecuredApartment ();
	}

	if (m_pContext)
		m_pContext->AddRef();

	InterlockedIncrement(&g_cObj);
}


CWbemObjectSink::~CWbemObjectSink(void) 
{
	_RD(static char *me = "CWbemObjectSink::~CWbemObjectSink";)
	_RPrint(me, "Called", 0, "");

	CIWbemObjectSinkMethodCache::ReleaseForThread();
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pServices)
	RELEASEANDNULL(m_pUnsecuredApartment)
	RELEASEANDNULL(m_pSWbemSink)
	RELEASEANDNULL(m_pContext)
	FREEANDNULL(m_bsClassName)
	FREEANDNULL(m_bsNamespace)
	FREEANDNULL(m_bsUser)
	FREEANDNULL(m_bsPassword)
	FREEANDNULL(m_bsLocale)
}

IWbemObjectSink *CWbemObjectSink::CreateObjectSink (CWbemObjectSink **pWbemObjectSink,
													CSWbemServices *pServices, 
												    IDispatch *pSWbemSink, 
													IDispatch *pContext,
												    bool putOperation, 
													BSTR bsClassName)
{
	IWbemObjectSink *pIWbemObjectSink = NULL;
	CWbemObjectSink *pTmpSink = NULL;

	if (pSWbemSink)
	{
		pTmpSink = new CWbemObjectSink(pServices, pSWbemSink, pContext, putOperation, bsClassName);

		if (pTmpSink)
		{
			pIWbemObjectSink = pTmpSink->GetObjectStub();
			if (pIWbemObjectSink && FAILED(pTmpSink->AddObjectSink(pIWbemObjectSink)))
				pIWbemObjectSink = NULL;

			if (!pIWbemObjectSink)
			{
				delete pTmpSink;
				pTmpSink = NULL;
			}
		}
	}

	*pWbemObjectSink = pTmpSink;
	return pIWbemObjectSink;
}

void CWbemObjectSink::ReleaseTheStubIfNecessary(HRESULT hResult) {

	/*
	 * If we failed locally and SetStatus has not been called
	 * then we need to remove object from list of outstanding sinks
	 */
	if (FAILED(hResult) && !m_setStatusCompletedCalled)
		RemoveObjectSink();

	/* 
	 * SetStatus can be called whilst we were in the async op.
	 * if this happens then SetStatus will not release the sink
	 * but will set a flag (m_setStatusCompletedCalled).  In this
	 * case we will need to release the stub here (the call has completed)
	 * Of course we could have also failed locally (regardless of whether 
	 * SetStatus has been called or not) - in this case we must also 
	 * release the stub.
	 */
	if (m_pObjectStub && (FAILED(hResult) || m_setStatusCompletedCalled)) {
		//  Call to release is same as (delete this !)
		IWbemObjectSink *tmpSink = m_pObjectStub;
		m_pObjectStub = NULL;
		tmpSink->Release();
	} else {
		m_operationInProgress = FALSE;
	}
}

//***************************************************************************
// HRESULT CWbemObjectSink::QueryInterface
// long CWbemObjectSink::AddRef
// long CWbemObjectSink::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemObjectSink::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemObjectSink==riid)
		*ppv = (IWbemObjectSink *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemObjectSink::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemObjectSink::Release(void)
{
	_RD(static char *me = "CWbemObjectSink::Release";)
    InterlockedDecrement(&m_cRef);
	_RPrint(me, "After decrement", m_cRef, "RefCount: ");
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

#ifdef __RTEST_RPC_FAILURE
int __Rx = 0;
bool __Rdone = true;
#endif

HRESULT STDMETHODCALLTYPE CWbemObjectSink::Indicate( 
	/* [in] */ long lObjectCount,
	/* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
{
	_RD(static char *me = "CWbemObjectSink::Indicate";)
	_RPrint(me, "Called", 0, "");

	// See if we need to cache this method call if we are already in another
	// IWbemObjectSink interface method
	CIWbemObjectSinkMethodCache *pSinkMethodCache = CIWbemObjectSinkMethodCache::GetThreadsCache();
	
	if(pSinkMethodCache && !pSinkMethodCache->TestOkToRunIndicate(this, lObjectCount, apObjArray))
	{
		_RPrint(me, ">>>Re-entrant Indicate call", 0, "");
		return S_OK;
	}

	//------------------------------
	// walk though the classObjects...
	for (int i = 0; i < lObjectCount; i++)
	{
#ifdef __RTEST_RPC_FAILURE
		__Rx++;
#endif
		/*
		 * NB: Although the CSWbemObject constructor has AddRef'd the
		 * apObjArray[i] above, we do not balance this with a Release call
		 * before leaving this function.  According to CIMOM documentation
		 * this is correct behavior if it cannot be gauranteed that the 
		 * objects will not be used after this call has returned.
		 *
		 * Also it appears the case that when calling into the OnObjectReady
		 * function, the ISWbemObject should have a RefCount of 0 to be
		 * garbage collected properly.
		 */

		CSWbemObject *pObject = new CSWbemObject(m_pServices, apObjArray[i]);
		
		if (pObject)
		{
			CComPtr<IDispatch> pObjDisp;

			if (SUCCEEDED(pObject->QueryInterface(IID_IDispatch, (PPVOID)&pObjDisp)))
			{
				if (m_pSWbemSink)
					m_pSWbemSink->OnObjectReady(pObjDisp, m_pContext);
			}
		}

	} // endfor


#ifdef __RTEST_RPC_FAILURE
	if ((__Rx >= 15) && !__Rdone)
	{
		__Rdone = true;
		return RPC_E_SERVERFAULT;
	}
#endif

	// Recall any cached interface methods if nested calls were received
	if (pSinkMethodCache)
		pSinkMethodCache->Cleanup();

	return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CWbemObjectSink::SetStatus( 
	/* [in] */ long lFlags,
	/* [in] */ HRESULT hResult,
	/* [in] */ BSTR strParam,
	/* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{
	// See if we need to cache this method call if we are already in another
	// IWbemObjectSink interface method
	CIWbemObjectSinkMethodCache *pSinkMethodCache = CIWbemObjectSinkMethodCache::GetThreadsCache();

	if(pSinkMethodCache && !pSinkMethodCache->TestOkToRunSetStatus(this, lFlags, hResult, strParam, pObjParam))
		return S_OK;

	if (lFlags == WBEM_STATUS_COMPLETE) 
	{
		IDispatch *pCSWbemObjectDisp = NULL;
		IDispatch *pObjectPathDisp = NULL;

		if (pObjParam)
		{
			/*
			 * NB: Although the CSWbemObject constructor has AddRef'd the
			 * pObjParam above, we do not balance this with a Release call
			 * before leaving this function.  According to CIMOM documentation
			 * this is correct behavior if it cannot be gauranteed that the 
			 * objects will not be used after this call has returned.
			 * Also it appears the case that when calling into the OnObjectReady
			 * function, the ISWbemObject should have a RefCount of 0 to be
			 * garbage collected properly.
		 	 */			

			CSWbemObject *pCSWbemObject = new CSWbemObject(m_pServices, pObjParam);

			if (pCSWbemObject)
			{
				if (FAILED(pCSWbemObject->QueryInterface(IID_IDispatch, (PPVOID)&pCSWbemObjectDisp)))
				{
					delete pCSWbemObject;
					pCSWbemObjectDisp = NULL;
				}
			}
		}

		if (m_putOperation && m_pServices)
		{
			CSWbemSecurity *pSecurity = m_pServices->GetSecurityInfo ();
			ISWbemObjectPath *pObjectPath = new CSWbemObjectPath (pSecurity);

			if (pSecurity)
				pSecurity->Release ();

			if (pObjectPath)
			{
				if (SUCCEEDED(pObjectPath->QueryInterface(IID_IDispatch, (PPVOID)&pObjectPathDisp)))
				{
					pObjectPath->put_Path (m_pServices->GetPath ());

					if (m_bsClassName)
						pObjectPath->put_RelPath (m_bsClassName);
					else if (strParam)
						pObjectPath->put_RelPath (strParam);
				}
				else
				{
					delete pObjectPath;
					pObjectPathDisp = NULL;
				}
			}
		}

		RemoveObjectSink();

		// Transform the error code if need be
		if (WBEM_S_ACCESS_DENIED == hResult)
			hResult = wbemErrAccessDenied;
		else if (WBEM_S_OPERATION_CANCELLED == hResult)
			hResult = wbemErrCallCancelled;
		else if (SUCCEEDED(hResult))
			hResult = wbemNoErr;  // Ignore the other success codes for now. 

		if (m_pSWbemSink)
			m_pSWbemSink->OnCompleted((WbemErrorEnum)hResult, pCSWbemObjectDisp, pObjectPathDisp, m_pContext);

		// Release the stub but only if an op is not in progress
		// If an op is in progress, stub will be removed on exit from op
		// If op is in Progress - stash hResult for later
		if (m_pObjectStub && !m_operationInProgress) {
			IWbemObjectSink *tmpStub = m_pObjectStub;
			m_pObjectStub = NULL;
			tmpStub->Release();
		}
		else {
			m_setStatusCompletedCalled = TRUE;
		}

		if (pCSWbemObjectDisp)
			pCSWbemObjectDisp->Release();

		if (pObjectPathDisp)
			pObjectPathDisp->Release();

	} else if (lFlags & WBEM_STATUS_PROGRESS)
	{
		if (m_pSWbemSink)
			m_pSWbemSink->OnProgress(HIWORD(hResult), LOWORD(hResult), strParam, m_pContext);
	}

	// Recall any cached interface methods if nested calls were received
	if (pSinkMethodCache)
		pSinkMethodCache->Cleanup();

	return S_OK;
}

IWbemObjectSink *CWbemObjectSink::GetObjectStub()
{
	HRESULT hr = S_OK;

	if (!m_pObjectStub && m_pUnsecuredApartment)
	{
		// Create the object stub using unsecapp
		IUnknown *pSubstitute = NULL;

		// If we are called before this object has been handed out
		// we'd better protect our ref count
		bool bBumpUpRefCount = false;

		if (0 == m_cRef)
		{
			m_cRef++;
			bBumpUpRefCount = true;
		}

		if (SUCCEEDED (hr = m_pUnsecuredApartment->CreateObjectStub(this, &pSubstitute)))
		{
			// Ensure we QI for IWbemObjectSink
			hr = pSubstitute->QueryInterface (IID_IWbemObjectSink, (PPVOID) &m_pObjectStub);
			if (FAILED(hr))
				m_pObjectStub = NULL;

			// Now we're done with the returned stub
			pSubstitute->Release ();
		}

		if (bBumpUpRefCount)
			m_cRef--;
	}

	return m_pObjectStub;
}

HRESULT CWbemObjectSink::AddObjectSink(IWbemObjectSink *pSink)
{
	HRESULT hr = S_OK;

	if (m_pSWbemSink)
	{
		if(m_pServices)
		{
			CComPtr<IWbemServices> pIWbemServices = m_pServices->GetIWbemServices ();

			// Is AddObjectSink assuming these 2 args have been AddRef'd already??
			m_pSWbemSink->AddObjectSink(pSink, pIWbemServices);
		}
	}
	return hr;
}

void CWbemObjectSink::RemoveObjectSink()
{
	if (m_pSWbemSink)
		m_pSWbemSink->RemoveObjectSink(GetObjectStub());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\parsedn.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       parsedn.h
//
//	Description :
//				The implementation of IParseDisplayName
//
//***************************************************************************


#ifndef _PARSEDN_H_
#define _PARSEDN_H_

//***************************************************************************
//
//  Class :	CWbemParseDN
//
//  Description :
//			Implements the IParseDisplayName interface, which parses
//			CIM object paths and returns a pointer to the requested object
//
//  Public Methods :
//			IUnknown Methods
//			IParseDisplayName Methods
//			Constructor, Destructor
//			CreateProvider - creates an object of this class
//			
//	Public Data Members :
//
//***************************************************************************

class CWbemParseDN :  public IParseDisplayName
{
private:
	long m_cRef;

	static bool ParseAuthAndImpersonLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				bool &authnSpecified,
				enum WbemAuthenticationLevelEnum *lpeAuthLevel,
				bool &impSpecified,
				enum WbemImpersonationLevelEnum *lpeImpersonLevel,
				CSWbemPrivilegeSet &privilegeSet,
				BSTR &bsAuthority);

	static bool ParseImpersonationLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				enum WbemImpersonationLevelEnum *lpeImpersonLevel);

	static bool ParseAuthenticationLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				enum WbemAuthenticationLevelEnum *lpeAuthLevel);

	static bool	ParsePrivilegeSet (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				CSWbemPrivilegeSet &privilegeSet);

	static bool ParseAuthority (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				BSTR &bsAuthority);

public:

	//IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	//IParseDisplayName members
    STDMETHODIMP		ParseDisplayName (IBindCtx* pbc,
                                      LPOLESTR szDisplayName,
                                      ULONG* pchEaten,
                                      IMoniker** ppmk);

    CWbemParseDN::CWbemParseDN();
    virtual CWbemParseDN::~CWbemParseDN();

	// Used for parsing the authentication and impersonation levels.
	static bool ParseSecurity (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				bool &authnSpecified,
				enum WbemAuthenticationLevelEnum *lpeAuthLevel,
				bool &impSpecified,
				enum WbemImpersonationLevelEnum *lpeImpersonLevel,
				CSWbemPrivilegeSet &privilegeSet,
				BSTR &bsAuthority);

	// Used for parsing the locale setting.
	static bool ParseLocale (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				BSTR &bsLocale);

	// Used to return security specification as a string
	static wchar_t *GetSecurityString (
					bool authnSpecified, 
					enum WbemAuthenticationLevelEnum authnLevel, 
					bool impSpecified, 
					enum WbemImpersonationLevelEnum impLevel,
					CSWbemPrivilegeSet &privilegeSet,
					BSTR &bsAuthority
				 );

	// Used to return locale specification as a string
	static wchar_t *GetLocaleString (
					BSTR bsLocale
				 );
};


#endif //_PARSEDN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pathcmps.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SOBJPATH.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectPathEx
//
//***************************************************************************

#include "precomp.h"

///***************************************************************************
//
//  CSWbemObjectPathComponents::CSWbemObjectPathComponents
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectPathComponents::CSWbemObjectPathComponents(
	CWbemPathCracker *pCWbemPathCracker,
	bool bMutable
)				: m_cRef (0),
				  m_pCWbemPathCracker (pCWbemPathCracker),
				  m_bMutable (bMutable)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectPathComponents, 
					CLSID_SWbemObjectPathComponents, L"SWbemObjectPathComponents");

	if (m_pCWbemPathCracker)
		m_pCWbemPathCracker->AddRef ();

    InterlockedIncrement(&g_cObj);
}

CSWbemObjectPathComponents::CSWbemObjectPathComponents(
	const BSTR & bsPath,
	bool bMutable
)				: m_cRef (0),
				  m_pCWbemPathCracker (NULL),
				  m_bMutable (bMutable)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectPathComponents, 
					CLSID_SWbemObjectPathComponents, L"SWbemObjectPathComponents");

	m_pCWbemPathCracker = new CWbemPathCracker (bsPath);

	if (m_pCWbemPathCracker)
		m_pCWbemPathCracker->AddRef ();

    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemObjectPathComponents::~CSWbemObjectPathComponents
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectPathComponents::~CSWbemObjectPathComponents(void)
{
	RELEASEANDNULL(m_pCWbemPathCracker)

    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemObjectPathComponents::QueryInterface
// long CSWbemObjectPathComponents::AddRef
// long CSWbemObjectPathComponents::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPathComponents::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectPathComponents==riid)
		*ppv = (ISWbemObjectPathComponents *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectPathComponents::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectPathComponents::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumObjectPathComponent *pEnumObjectPathComponent = 
							new CEnumObjectPathComponent (m_pCWbemPathCracker, m_bMutable);

		if (!pEnumObjectPathComponent)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumObjectPathComponent->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
				delete pEnumObjectPathComponent;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL == plCount)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCWbemPathCracker)
	{
		ULONG lCount = 0;

		if (m_pCWbemPathCracker->GetComponentCount (lCount))
		{
			*plCount = lCount;
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::Add
//
//  DESCRIPTION:
//
//  Add a single scope element to the list
//
//  PARAMETERS:
//
//		bsScopePath		path form of scope element
//		iIndex			index for insertion (-1 is at the end)
//		ppISWbemScopeElement	addresses the SWbemScopeElement on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::Add (
	BSTR bsComponent,
	long iIndex
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == bsComponent)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pCWbemPathCracker)
	{
		if (m_pCWbemPathCracker->AddComponent (iIndex, bsComponent))
			hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::Set
//
//  DESCRIPTION:
//
//  Change an existing component in the list
//
//  PARAMETERS:
//
//		bsScopePath		path form of component
//		iIndex			index (-1 is at the end)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::Set (
	BSTR bsComponent,
	long iIndex
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == bsComponent)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pCWbemPathCracker)
	{
		if (m_pCWbemPathCracker->SetComponent (iIndex, bsComponent))
			hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::Remove
//
//  DESCRIPTION:
//
//  Remove element from scope list
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve (default -1)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::Remove (
	long iIndex
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pCWbemPathCracker)
	{
		if (m_pCWbemPathCracker->RemoveComponent (iIndex))
			hr = WBEM_S_NO_ERROR;
		else
			hr = wbemErrValueOutOfRange;
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all elements from the scope
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::DeleteAll (
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pCWbemPathCracker)
	{
		if (m_pCWbemPathCracker->RemoveAllComponents ())
			hr = WBEM_S_NO_ERROR;
	}
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPathComponents::Item
//
//  DESCRIPTION:
//
//  Get element from the list by index.  
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve
//		lFlags			Flags
//		ppSWbemScopeElement	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPathComponents::Item (
	long iIndex, 
	BSTR *pbsComponent
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	ResetLastErrors ();

	if ((NULL == pbsComponent) || (0 > iIndex))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCWbemPathCracker)
	{
		CComBSTR bsComponent;

		if (m_pCWbemPathCracker->GetComponent (iIndex, bsComponent))
		{
			*pbsComponent = bsComponent.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

// CEnumObjectPathComponent Methods

//***************************************************************************
//
//  CEnumObjectPathComponent::CEnumObjectPathComponent
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumObjectPathComponent::CEnumObjectPathComponent(
	CWbemPathCracker *pCWbemPathCracker,
	bool bMutable
)
			: m_cRef (0),
			  m_iIndex (0),
			  m_pCWbemPathCracker (pCWbemPathCracker),
			  m_bMutable (bMutable)
{
	if (m_pCWbemPathCracker)
		m_pCWbemPathCracker->AddRef ();

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumObjectPathComponent::~CEnumObjectPathComponent
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumObjectPathComponent::~CEnumObjectPathComponent(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pCWbemPathCracker)
}

//***************************************************************************
// HRESULT CEnumObjectPathComponent::QueryInterface
// long CEnumObjectPathComponent::AddRef
// long CEnumObjectPathComponent::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumObjectPathComponent::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumObjectPathComponent::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumObjectPathComponent::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumObjectPathComponent::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumObjectPathComponent::Reset ()
{
	m_iIndex = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CEnumObjectPathComponent::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumObjectPathComponent::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pCWbemPathCracker))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			CComBSTR bsName;

			if (m_pCWbemPathCracker->GetComponent (m_iIndex, bsName))
			{
				pVar[l2].vt = VT_BSTR;
				pVar[l2].bstrVal = bsName.Detach ();
				m_iIndex++;
			}
			else
				break;
		}

		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumObjectPathComponent::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumObjectPathComponent::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pCWbemPathCracker)
		{
			CEnumObjectPathComponent *pEnum = 
					new CEnumObjectPathComponent (m_pCWbemPathCracker, m_bMutable);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumObjectPathComponent::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumObjectPathComponent::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pCWbemPathCracker)
	{
		// Get the count
		ULONG lComponentCount = 0;

		if (m_pCWbemPathCracker->GetComponentCount (lComponentCount))
		{
			if (m_iIndex + cElements < lComponentCount)
			{
				hr = S_OK;
				m_iIndex += cElements;
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\objsink.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  objsink.h
//
//  rogerbo  22-May-98   Created.
//
//  Implementation of IWbemObjectSink for async stuff
//
//***************************************************************************

#ifndef _OBJSINK_H_
#define _OBJSINK_H_

// CIWbemObjectSinkCachedMethodItem is the base class of link list items
// representing cached method calls to IWbemObjectSink.  Whenever we are inside
// an IWbemObjectSink method, and we receive a nested call to IWbemObjectSink,
// we store the parameters to the nested call and redo the call just before the
// original method returns.  It is important to cache all methods on the sink to
// preserve the order that they are seen by the client.  This means that
// if calls to SetStatus come in during a call to Indicate, it must be cached.
// In addition, we cache calls across all instances of IWbemObjectSink.  In
// other words, suppose we have two async requests (request1 and request2).  If
// we are processing an Indicate for request1 and get an Indicate for request2,
// we have to cache the nested Indicate (including the this pointer for the
// IWbemObjectSink), and call the recall the nested Indicate at the end of the
// Indicate for request1.
class CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedMethodItem(IWbemObjectSink *pSink) : 
					m_pSink (pSink),
					m_pNext (NULL)
	{
		if (m_pSink)
			m_pSink->AddRef();
	}

	virtual ~CIWbemObjectSinkCachedMethodItem()
	{
		if (m_pSink)
			m_pSink->Release();
	}

	// DoCallAgain is to be overridden in derived classes to recall cached
	// methods.
	virtual void DoCallAgain() = 0;

	// This is a pointer to the next cached interface call
	CIWbemObjectSinkCachedMethodItem *m_pNext;

protected:
	// Pointer to the original IWbemObjectSink for the cached call
	IWbemObjectSink *m_pSink;
};

// CIWbemObjectSinkCachedIndicate represents a cached call to Indicate
class CIWbemObjectSinkCachedIndicate : public CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedIndicate(IWbemObjectSink *pSink, long lObjectCount, IWbemClassObject **apObjArray) 
			: CIWbemObjectSinkCachedMethodItem (pSink)
	{
		_RD(static char *me = "CIWbemObjectSinkCachedIndicate::CIWbemObjectSinkCachedIndicate";)
		_RPrint(me, "", 0, "");

		// Store the original parameters to the Indicate call
		// TODO: What if lObjectCount = 0 ?
		m_lObjectCount = lObjectCount;
		m_apObjArray = new IWbemClassObject*[lObjectCount];

		if (m_apObjArray)
		{
			for(int i=0;i<lObjectCount;i++)
			{
				apObjArray[i]->AddRef();
				m_apObjArray[i] = apObjArray[i];
			}
		}
	}

	~CIWbemObjectSinkCachedIndicate()
	{
		_RD(static char *me = "CIWbemObjectSinkCachedIndicate::~CIWbemObjectSinkCachedIndicate";)
		_RPrint(me, "", 0, "");

		// Free memory used to store original parameters to Indicate
		if (m_apObjArray)
		{
			for(int i=0;i<m_lObjectCount;i++)
			{
				RELEASEANDNULL(m_apObjArray[i])
			}

			delete [] m_apObjArray;
		}
	}

	void DoCallAgain()
	{
		// Recall the Indicate method with the cached parameters
		if (m_pSink && m_apObjArray)
			m_pSink->Indicate(m_lObjectCount, m_apObjArray);
	}

private:
	// Parameters to Indicate that we must store
	long m_lObjectCount;
	IWbemClassObject **m_apObjArray;
};

// CIWbemObjectSinkCachedSetStatus represents a cached call to SetStatus
class CIWbemObjectSinkCachedSetStatus : public CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedSetStatus(
		IWbemObjectSink *pSink, 
		long lFlags, 
		HRESULT hResult, 
		BSTR strParam, 
		IWbemClassObject *pObjParam)  : 
				CIWbemObjectSinkCachedMethodItem (pSink), 
				m_lFlags (lFlags),
				m_hResult (hResult),
				m_strParam (NULL),
				m_pObjParam (pObjParam)
	{
		_RD(static char *me = "CIWbemObjectSinkCachedSetStatus::CIWbemObjectSinkCachedSetStatus";)
		_RPrint(me, "", 0, "");

		if(strParam)
			m_strParam = SysAllocString(strParam);

		if(m_pObjParam)
			m_pObjParam->AddRef();
	}

	~CIWbemObjectSinkCachedSetStatus()
	{
		_RD(static char *me = "CIWbemObjectSinkCachedSetStatus::~CIWbemObjectSinkCachedSetStatus";)
		_RPrint(me, "", 0, "");

		// Free memory used to store original parameters to SetStatus
		FREEANDNULL(m_strParam)
		RELEASEANDNULL(m_pObjParam)
	}

	void DoCallAgain()
	{
		// Recall the SetStatus method with the cached parameters
		if (m_pSink)
			m_pSink->SetStatus(m_lFlags, m_hResult, m_strParam, m_pObjParam);
	}

private:
	// Parameters to SetStatus that we must store
	long m_lFlags;
	HRESULT m_hResult;
	BSTR m_strParam;
	IWbemClassObject *m_pObjParam;
};

// This is the class that manages all cached calls to IWbemObjectSink.  To
// cache the interface method calls, each interface method should call
// TestOkToRunXXX where XXX is the method name.  If this function returns
// FALSE, it means that we are already inside another method call.  The
// parameters will have been cached, the the method should return immediately.
// At the end of the method, Cleanup should be called so that all cached method
// calls can be recalled.
class CIWbemObjectSinkMethodCache
{
protected:
	// Constructor/destructor are protected since this object should only be
	// created/destroyed by the static methods AddRefForThread/ReleaseForThread
	CIWbemObjectSinkMethodCache() :
		m_fInInterface (FALSE),
		m_pFirst (NULL),
		m_pLast (NULL),
		m_fOverrideTest (FALSE),
		m_fOverrideCleanup (FALSE),
		m_dwRef (1)
	{
		_RD(static char *me = "CIWbemObjectSinkMethodCache::CIWbemObjectSinkMethodCache";)
		_RPrint(me, "", 0, "");
	}

	~CIWbemObjectSinkMethodCache()
	{
		_RD(static char *me = "CIWbemObjectSinkMethodCache::~CIWbemObjectSinkMethodCache";)
		_RPrint(me, "", 0, "");
		_RPrint(me, "m_pFirst: ", long(m_pFirst), "");
		_RPrint(me, "m_pLast: ", long(m_pLast), "");

		// TODO: ASSERT that m_pFirst and m_pLast are NULL.  In other words,
		// as long as Cleanup is called at the end of each interface method,
		// the internal link list should be completely empty.
	}

public:
	// Public Methods

	static void Initialize () {
		sm_dwTlsForInterfaceCache = TlsAlloc();
	}

	static void TidyUp () {
		if (-1 != sm_dwTlsForInterfaceCache)
		{
			TlsFree (sm_dwTlsForInterfaceCache);
			sm_dwTlsForInterfaceCache = -1;
		}
	}

	static void AddRefForThread()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return; // We failed the original alloc

		// The Tls value for sm_dwTlsForInterfaceCache is guaranteed to
		// initialize to NULL
		CIWbemObjectSinkMethodCache *pSinkMethodCache = (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
		
		if(NULL == pSinkMethodCache)
			TlsSetValue(sm_dwTlsForInterfaceCache, new CIWbemObjectSinkMethodCache);
		else
			pSinkMethodCache->AddRef();
	}

	static void ReleaseForThread()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return; // We failed the original alloc

		CIWbemObjectSinkMethodCache *pSinkMethodCache = (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
		if(NULL != pSinkMethodCache)
		{
			DWORD dwCount = pSinkMethodCache->Release();
			if(dwCount == 0)
			{
				delete pSinkMethodCache;
				TlsSetValue(sm_dwTlsForInterfaceCache, NULL);
			}
		}
	}

	static CIWbemObjectSinkMethodCache *GetThreadsCache()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return NULL; // We failed the original alloc
		return (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
	}

protected:
	// TLS slot for Interface Cache pointer
	static DWORD sm_dwTlsForInterfaceCache;

public:
	// Public Instance Methods

	// Call this method at the start of the Indicate method.  If this method
	// returns TRUE, Indicate should return immediately.
	BOOL TestOkToRunIndicate(IWbemObjectSink *pSink, long lObjectCount, IWbemClassObject **apObjArray)
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return TRUE;

		// If m_fOverrideTest is TRUE, it means that we are recalling a cached
		// call to Indicate.  We therefore must complete the body of Indicate.
		if(m_fOverrideTest)
		{
			m_fOverrideTest = FALSE;
			return TRUE;
		}

		// If we are already in an interface method, cache this call
		if(m_fInInterface)
		{
			CIWbemObjectSinkCachedIndicate *pItem = new CIWbemObjectSinkCachedIndicate(pSink, lObjectCount, apObjArray);
			// TODO: What if allocation fails?
			if(pItem)
				AddItem(pItem);
			return FALSE;
		}

		// We are not already in another interface method, but we set
		// m_fInInterface to TRUE to prevent nested calls
		m_fInInterface = TRUE;
		return TRUE;
	}

	// Call this method at the start of the SetStatus method.  If this method
	// returns TRUE, SetStatus should return immediately.
	BOOL TestOkToRunSetStatus(IWbemObjectSink *pSink, long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject *pObjParam)
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return TRUE;

		// If m_fOverrideTest is TRUE, it means that we are recalling a cached
		// call to SetStatus.  We therefore must complete the body of SetStatus.
		if(m_fOverrideTest)
		{
			m_fOverrideTest = FALSE;
			return TRUE;
		}

		// If we are already in an interface method, cache this call
		if(m_fInInterface)
		{
			CIWbemObjectSinkCachedSetStatus *pItem = new CIWbemObjectSinkCachedSetStatus(pSink, lFlags, hResult, strParam, pObjParam);
			// TODO: What if allocation fails?
			if(pItem)
				AddItem(pItem);
			return FALSE;
		}

		// We are not already in another interface method, but we set
		// m_fInInterface to TRUE to prevent nested calls
		m_fInInterface = TRUE;
		return TRUE;
	}

	// At the end of every IWbemObjectSink method, Cleanup should be called.
	// This will recall any cached method parameters
	void Cleanup()
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return;

		// If m_fOverridCleanup is TRUE, we are in an interface method because
		// we are recalling it.  There is nothing more that Cleanup should do
		if(m_fOverrideCleanup)
		{
			m_fOverrideCleanup = FALSE;
			return;
		}

		// While there are any items in the link list, recall the methods.
		// NOTE: It is possible that new items will be added to the end of the
		// link list during DoCallAgain, but when this 'while' loop finishes
		// we will be in a state where all cached methods have been called
		while(m_pFirst)
		{
			// Set override flags so that the interface methods know that they
			// are not receiving a nested call
			m_fOverrideTest = TRUE;
			m_fOverrideCleanup = TRUE;

			// Recall the cached method
			m_pFirst->DoCallAgain();

			// Remove this item from the start of the link list
			CIWbemObjectSinkCachedMethodItem *pItem = m_pFirst;
			m_pFirst = pItem->m_pNext;
			delete pItem;
		}

		// The link list is empty
		m_pLast = NULL;

		// We are about to leave the interface method
		m_fInInterface = FALSE;
	}

protected:

	// Add cached method information to the link list
	void AddItem(CIWbemObjectSinkCachedMethodItem *pItem)
	{
		if(NULL == m_pLast)
		{
			m_pFirst = pItem;
			m_pLast = pItem;
		}
		else
		{
			m_pLast->m_pNext = pItem;
			m_pLast = pItem;
		}
	}

protected:
	// Reference counting of thread local object
	void AddRef()
	{
		m_dwRef++;
	}
	int Release()
	{
		m_dwRef--;
		return m_dwRef;
	}
	DWORD m_dwRef;

protected:
	// Member Variables

	// Flag that specifies if we are currently processing an interface method
	BOOL m_fInInterface;

	// Pointer to the first and last items of the link list of cached methods
	CIWbemObjectSinkCachedMethodItem *m_pFirst;
	CIWbemObjectSinkCachedMethodItem *m_pLast;

	// Flags to tell interface method implementations that they are being called
	// to recall a cached method as opposed to receiving a nested call.
	BOOL m_fOverrideTest;
	BOOL m_fOverrideCleanup;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemObjectSink
//
//  DESCRIPTION:
//
//  Implements the IWbemObjectSink interface.  
//
//***************************************************************************

class CWbemObjectSink : public IWbemObjectSink
{

private:

	CSWbemServices		*m_pServices;
	IUnsecuredApartment *m_pUnsecuredApartment;
	ISWbemPrivateSink	*m_pSWbemSink;
	IDispatch			*m_pContext;
	IWbemObjectSink		*m_pObjectStub;
	BSTR m_bsClassName;
	bool m_putOperation;
	bool m_operationInProgress;
	bool m_setStatusCompletedCalled;

	// Members required for just-in-time initialization of m_pServices
	BSTR m_bsNamespace;
	BSTR m_bsUser;
	BSTR m_bsPassword;
	BSTR m_bsLocale;

	void RemoveObjectSink();
	HRESULT AddObjectSink(IWbemObjectSink *pSink);

protected:
	long            m_cRef;         //Object reference count

public:
	CWbemObjectSink(CSWbemServices *pServices, IDispatch *pSWbemSink, IDispatch *pContext, 
												bool putOperation = false, BSTR bsClassName = NULL);
	~CWbemObjectSink(void);

	static IWbemObjectSink *CreateObjectSink(CWbemObjectSink **pWbemObjectSink, 
											 CSWbemServices *pServices, 
											 IDispatch *pSWbemSink, 
											 IDispatch *pContext, 
											 bool putOperation = false, 
											 BSTR bsClassName = NULL);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  E_NOTIMPL;}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return E_NOTIMPL;}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return E_NOTIMPL;}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return E_NOTIMPL;}
    
	// IWbemObjectSink methods

        HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
        
        HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);

	IWbemObjectSink *GetObjectStub();

	void ReleaseTheStubIfNecessary(HRESULT hResult);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pathcmps.h ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  scope.h
//
//  alanbos  16-Feb-00   Created.
//
//  Path component helper implementation.
//
//***************************************************************************

#ifndef _PATHCMPS_H_
#define _PATHCMPS_H_

class CSWbemObjectPathComponents;
class CEnumObjectPathComponent;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectPathComponents
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectPathComponents interface.  
//
//***************************************************************************

class CSWbemObjectPathComponents : public ISWbemObjectPathComponents,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
friend CEnumObjectPathComponent;
private:
	CDispatchHelp		m_Dispatch;
	CWbemPathCracker	*m_pCWbemPathCracker;
	bool				m_bMutable;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectPathComponents(CWbemPathCracker *pCWbemPathCracker, bool bMutable = true);
	CSWbemObjectPathComponents (const BSTR & bsPath, bool bMutable = true);
    virtual ~CSWbemObjectPathComponents(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemObjectPathComponents methods

    HRESULT STDMETHODCALLTYPE get__NewEnum (
		/*[out, retval]*/ IUnknown **pUnk
		);

	HRESULT STDMETHODCALLTYPE Item (
		/*[in]*/ long iIndex, 
		/*[out, retval]*/ BSTR *bsComponent
		);

	HRESULT STDMETHODCALLTYPE get_Count (
		/*[out, retval]*/ long *iCount
		);

	HRESULT STDMETHODCALLTYPE Add (
		/*[in]*/ BSTR bsComponent,
		/*[in, defaultvalue(-1)]*/ long iIndex
		);

	HRESULT STDMETHODCALLTYPE Remove (
		/*[in]*/ long iIndex
		);

	HRESULT STDMETHODCALLTYPE DeleteAll (
		);

	HRESULT STDMETHODCALLTYPE Set (
		/*[in]*/ BSTR bsComponent,
		/*[in, defaultvalue(-1)]*/ long iIndex
		);
    
    // ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemObjectPathComponents == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumObjectPathComponent
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for ISWbemObjectPathComponents
//
//***************************************************************************

class CEnumObjectPathComponent : public IEnumVARIANT
{
private:
	long				m_cRef;
	unsigned long		m_iIndex;
	CWbemPathCracker	*m_pCWbemPathCracker;
	bool				m_bMutable;

public:
	CEnumObjectPathComponent (CWbemPathCracker *pCWbemPathCracker, bool bMutable = true);
	virtual ~CEnumObjectPathComponent (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

#endif // _SCOPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pathcrak.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  PATHCRAK.CPP
//
//  alanbos  28-Mar-00   Created.
//
//  Defines the implementation of CWbemPathCracker
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker() :
		m_cRef (0),
		m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
}

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Copy Constructor
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker(CWbemPathCracker & pathCracker) :
		m_cRef (0),
		m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
	
	CComBSTR bsPath;
	if (pathCracker.GetPathText(bsPath, false, true))
		SetText (bsPath);
}

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Constructor
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker (const CComBSTR & bsPath) :
			m_pIWbemPath (NULL),
			m_cRef (0),
			m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
	SetText (bsPath);
}

//***************************************************************************
//
//  CWbemPathCracker::~CWbemPathCracker
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemPathCracker::~CWbemPathCracker(void)
{
	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CWbemPathCracker::QueryInterface
// long CWbemPathCracker::AddRef
// long CWbemPathCracker::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemPathCracker::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = (IUnknown*)(this);
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemPathCracker::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemPathCracker::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

void CWbemPathCracker::CreateParsers ()
{
	m_pIWbemPath.Release ();

	CoCreateInstance (CLSID_WbemDefPath, NULL,
					CLSCTX_INPROC_SERVER, IID_IWbemPath, (PPVOID) &m_pIWbemPath);
}

void CWbemPathCracker::SetText (const CComBSTR & bsPath, bool bForceAsNamespace)
{
	WbemPathType type = GetTypeFromText (bsPath);

	switch (type)
	{
		case wbemPathTypeWmi:
		{
			int iCreateFlags = WBEMPATH_CREATE_ACCEPT_ALL;

			// Check if we want single tokens to be interpreted as a namespace (e.g. "root")
			if (bForceAsNamespace)
				iCreateFlags |= WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;

			if (m_pIWbemPath)
			{
				// The path parser should handle this, but doesn't!
				// If we have extracted this path from a V2-style reference
				// property it may be enclosed on "{" and "}". For now we strip
				// these off before parsing.

				if ((1 < bsPath.Length ()) && (L'{' == bsPath[0])
						&& (L'}' == bsPath [bsPath.Length () -1]))
				{
					// Take off the first and last characters
					CComBSTR bsPath2 (bsPath + 1);
					bsPath2 [bsPath2.Length() - 1] = NULL;
					
					if (SUCCEEDED(m_pIWbemPath->SetText (iCreateFlags, bsPath2)))
						m_type = type;
				}
				else if (SUCCEEDED(m_pIWbemPath->SetText (iCreateFlags, bsPath)))
					m_type = type;
			}
		}
			break;

		case wbemPathTypeError:
			m_type = type;
			break;
	}
}

//***************************************************************************
//
//  WbemPathType CWbemPathCracker::GetTypeFromText
//
//  DESCRIPTION:
//
//  Get the path type of the supplied string
//
//  PARAMETERS:
//		bsPath		the supplied string
//
//  RETURN VALUES:
//		A WbemPathType
//
//***************************************************************************

CWbemPathCracker::WbemPathType CWbemPathCracker::GetTypeFromText (
	const CComBSTR & bsPath
)
{
	WbemPathType type = wbemPathTypeError;

	// Try parsing it as a WMI path
	CComPtr<IWbemPath> pIWbemPath;

	if (SUCCEEDED(CoCreateInstance (CLSID_WbemDefPath, NULL,
				CLSCTX_INPROC_SERVER, IID_IWbemPath, (PPVOID) &pIWbemPath)))
	{
		if (SUCCEEDED(pIWbemPath->SetText (WBEMPATH_CREATE_ACCEPT_ALL, bsPath)))
			type = wbemPathTypeWmi;
	}

	return type;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetPathText
//
//  DESCRIPTION:
//
//  Get the text of the path
//
//  PARAMETERS:
//		bsPath			the supplied string for holding the path
//		bRelativeOnly	whether we only want the relpath
//		bIncludeServer	whether to include the server
//		bNamespaceOnly	whether we only want the namespace path
//
//  RETURN VALUES:
//		true iff successful
//
//***************************************************************************
 
bool CWbemPathCracker::GetPathText (
	CComBSTR & bsPath,
	bool bRelativeOnly,
	bool bIncludeServer,
	bool bNamespaceOnly
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lFlags = 0;

				if (bIncludeServer)
					lFlags |= WBEMPATH_GET_SERVER_TOO;
				else if (bRelativeOnly)
					lFlags |= WBEMPATH_GET_RELATIVE_ONLY;
				else if (bNamespaceOnly)
					lFlags |= WBEMPATH_GET_NAMESPACE_ONLY;

				// Find out our required buffer size
				ULONG lBuflen = 0;
				m_pIWbemPath->GetText (lFlags, &lBuflen, NULL);

				if (lBuflen)
				{
					LPWSTR pszText = new wchar_t [lBuflen + 1];

					if (pszText)
					{
						pszText [lBuflen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetText (lFlags, &lBuflen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}

						delete [] pszText;
					}
				}
				else
				{
					// No text yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;

	}


	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::operator =
//
//  DESCRIPTION:
//
//  Assigment operator
//
//  PARAMETERS:
//		bsPath		the supplied string
//
//  RETURN VALUES:
//		A WbemPathType
//
//***************************************************************************
		
bool CWbemPathCracker::operator = (const CComBSTR & bsPath)
{
	bool result = false;

	// The parsers seem incapable of dealing with empty strings
	if (0 == bsPath.Length ())
	{
		CreateParsers ();
		result = true;
	}
	else
	{
		// Before we blat our object, check it.
		CWbemPathCracker pathCracker (bsPath);

		if (wbemPathTypeError != pathCracker.GetType ())
		{
			SetText (bsPath);
			result = true;
		}
	}

	return result;
}

const CWbemPathCracker & CWbemPathCracker::operator = (CWbemPathCracker & path)
{
	CComBSTR bsPath;

	if (path.GetPathText (bsPath, false, true))
		*this = bsPath;

	return *this;
}

bool CWbemPathCracker::operator += (const CComBSTR & bsObjectPath)
{
	return AddComponent (-1, bsObjectPath);
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetRelativePath
//
//  DESCRIPTION:
//
//  Set the relpath as a string
//
//  PARAMETERS:
//		value		new relpath
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetRelativePath( 
    const CComBSTR & bsRelPath
)
{
	bool result = false;
	
	// Parse the new path
	CWbemPathCracker pathCracker (bsRelPath);

	if (CopyServerAndNamespace (pathCracker))
	{
		*this = pathCracker;

		if (wbemPathTypeError != GetType())
			result = true;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::CopyServerAndNamespace
//
//  DESCRIPTION:
//
//  Copy the server and namespace from this path to the
//	supplied path
//
//	Note that it is assumed that the passed in path has no
//	namespace components.
//
//  PARAMETERS:
//		pIWbemPath		path into which info to be copied
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::CopyServerAndNamespace (
	CWbemPathCracker &pathCracker
)
{
	bool result = false;

	CComBSTR bsServer;

	if (GetServer (bsServer) && pathCracker.SetServer (bsServer))
	{
		pathCracker.ClearNamespace ();
		ULONG lNsCount = 0;

		if (GetNamespaceCount (lNsCount))
		{
			bool ok = true;

			for (ULONG i = 0; (i < lNsCount) && ok; i++)
			{
				// Copy over this component
				CComBSTR bsNamespace;

				ok = GetNamespaceAt (i, bsNamespace) && 
							pathCracker.SetNamespaceAt (i, bsNamespace);
			}

			result = ok;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetNamespaceAt
//
//  DESCRIPTION:
//
//  Copy the server and namespace from this path to the
//	supplied path
//
//	Note that it is assumed that the passed in path has no
//	namespace components.
//
//  PARAMETERS:
//		pIWbemPath		path into which info to be copied
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetNamespaceAt (
	ULONG iIndex,
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;
				m_pIWbemPath->GetNamespaceAt (iIndex, &lBufLen, NULL);

				wchar_t *pszText = new wchar_t [lBufLen + 1];

				if (pszText)
				{
					pszText [lBufLen] = NULL;

					if (SUCCEEDED(m_pIWbemPath->GetNamespaceAt (iIndex, &lBufLen, pszText)))
					{
						if (bsPath.m_str = SysAllocString (pszText))
							result = true;
					}

					delete [] pszText;
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::SetNamespaceAt (
	ULONG iIndex,
	const CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->SetNamespaceAt (iIndex, bsPath)))
					result = true;
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetServer
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetServer (
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;

				m_pIWbemPath->GetServer (&lBufLen, NULL);

				if (lBufLen)
				{
					wchar_t *pszText = new wchar_t [lBufLen + 1];

					if (pszText)
					{
						pszText [lBufLen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetServer (&lBufLen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}

						delete [] pszText;
					}
				}
				else
				{
					// No server component yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;

	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetServer
//
//  DESCRIPTION:
//
//  Set the server name as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetServer( 
    const CComBSTR & bsPath
)
{
	bool result = false;
	
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				/*
				 * The observant reader will notice we check for an empty path and
				 * transform it to a NULL. This is to defensively code against behavior
				 * in the parsers which actually treat an empty server path as NOT
				 * being equivalent to NULL. 
				 */

				if (0 < bsPath.Length())
					result = SUCCEEDED(m_pIWbemPath->SetServer (bsPath));
				else
					result = SUCCEEDED(m_pIWbemPath->SetServer (NULL));
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetNamespacePath
//
//  DESCRIPTION:
//
//  Get the namespace path (excluding server) as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//		bParentOnly	whether to strip off leaf namespace
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetNamespacePath( 
            CComBSTR & bsPath,
			bool bParentOnly)
{
	bool result = false;

	// Build up the namespace value
	ULONG lNsCount = 0;

	if (GetNamespaceCount (lNsCount))
	{
		if ((bParentOnly && (1 < lNsCount)) || (!bParentOnly && (0 < lNsCount)))
		{
			// Get the full path and remove the server and objectref pieces
			CComBSTR bsNamespacePath;

			if (GetPathText (bsNamespacePath, false, false, true))
			{
				wchar_t *ptrStart = bsNamespacePath;

				if (IsClassOrInstance ())
				{
					// We have an object ref so look for the first ":"
					wchar_t *ptrEnd = wcschr (ptrStart, L':');

					if (ptrEnd)
						*ptrEnd = NULL;
				}

				// Getting here means we have just the namespace path left 
				// in ptrStart. Final step is to possibly remove the last
				// component

				if (bParentOnly)
				{
					wchar_t *ptrEnd = NULL;
					wchar_t *ptrEnd1 = wcsrchr (ptrStart, L'/');
					wchar_t *ptrEnd2 = wcsrchr (ptrStart, L'\\');

					if (ptrEnd1 && ptrEnd2)
						ptrEnd = (ptrEnd1 < ptrEnd2) ? ptrEnd2 : ptrEnd1;
					else if (!ptrEnd1 && ptrEnd2)
						ptrEnd = ptrEnd2;
					else if (ptrEnd1 && !ptrEnd2)
						ptrEnd = ptrEnd1;

					if (ptrEnd)
						*ptrEnd = NULL;
				}

				bsPath.m_str = SysAllocString (ptrStart);
				result = true;
			}
		}
		else
		{
			// Degenerate case - no namespace portion
			bsPath.m_str = SysAllocString (L"");
			result = true;
		}
	}

	return result;
}


bool CWbemPathCracker::IsClassOrInstance ()
{
	return (IsClass () || IsInstance ());
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetNamespacePath
//
//  DESCRIPTION:
//
//  Put the namespace as a string
//
//  PARAMETERS:
//		bsPath		new namespace path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetNamespacePath (
	const CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CWbemPathCracker newPath;
				newPath.SetText (bsPath, true);

				if(wbemPathTypeError != newPath.GetType ())
				{
					// Copy the namespace info into our current path
					unsigned long lNsCount = 0;

					if (newPath.GetNamespaceCount (lNsCount))
					{
						// Scratch the old namespace part
						ClearNamespace ();

						if (0 < lNsCount)
						{
							// Fill in using the new part
							bool ok = true;

							for (ULONG i = 0; (i <lNsCount) && ok; i++) 
							{
								CComBSTR bsNs;

								if (!(newPath.GetNamespaceAt (i, bsNs)) ||
									FAILED(m_pIWbemPath->SetNamespaceAt (i, bsNs)))
									ok = false;						
							}

							if (ok)
								result = true;
						}
					}
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetNamespaceCount (
	unsigned long & lCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				if (SUCCEEDED(m_pIWbemPath->GetNamespaceCount (&lCount)))
					result = true;
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveNamespace (
	ULONG iIndex
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				if (SUCCEEDED(m_pIWbemPath->RemoveNamespaceAt (iIndex)))
					result = true;
		}
			break;
	}

	return result;
}

void CWbemPathCracker::ClearNamespace()
{
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				m_pIWbemPath->RemoveAllNamespaces ();
		}
			break;
	}

}

//***************************************************************************
//
//  bool CWbemPathCracker::IsClass
//
//  DESCRIPTION:
//
//  Get whether the path is to a class
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::IsClass ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_CLASS_REF*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_CLASS_REF & lInfo) ? true : false;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::IsSingleton ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_SINGLETON*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_SINGLETON & lInfo) ? true : false;
			}
		}
			break;
	}
					
	return result;
}
 
bool CWbemPathCracker::IsInstance ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_CLASS_REF*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_INST_REF & lInfo) ? true : false;
			}
		}
			break;

	}

	return result;
}       


//***************************************************************************
//
//  bool CWbemPathCracker::SetAsClass
//
//  DESCRIPTION:
//
//  Set the path as a class path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetAsClass()
{
	return ClearKeys ();
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetAsSingleton
//
//  DESCRIPTION:
//
//  Set the path as a singleton instance path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetAsSingleton()
{
	return ClearKeys (false);
}

//***************************************************************************
//
//  SCODE CWbemPathCracker::get_Class
//
//  DESCRIPTION:
//
//  Get the class name from the path
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetClass (
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;
				m_pIWbemPath->GetClassName (&lBufLen, NULL);

				if (lBufLen)
				{
					wchar_t *pszText = new wchar_t [lBufLen + 1];

					if (pszText)
					{
						pszText [lBufLen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetClassName (&lBufLen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}
						
						delete [] pszText;
					}
				}
				else
				{
					// No class defined yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetComponent (
	ULONG iIndex,
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lScopeCount = 0;

				if (SUCCEEDED(m_pIWbemPath->GetScopeCount (&lScopeCount)))
				{
					if (-1 == iIndex)
						iIndex = lScopeCount - 1;

					if (iIndex < lScopeCount)
					{
						ULONG lBufLen = 0;
						m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, NULL);

						wchar_t *pszText = new wchar_t [lBufLen + 1];

						if (pszText)
						{
							pszText [lBufLen] = NULL;

							if (SUCCEEDED(m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, pszText)))
							{
								if (bsPath.m_str = SysAllocString (pszText))
									result = true;
							}

							delete [] pszText;	
						}
					}
				}
			}
		}
			break;
	}
			

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetClass
//
//  DESCRIPTION:
//
//  Set the class name in the path
//
//  PARAMETERS:
//		value		new class name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetClass( 
    const CComBSTR & bsClass)
{
	bool result = false;
	
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->SetClassName (bsClass)))
					result = true;
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Keys
//
//  DESCRIPTION:
//
//  Get the keys collection from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemNamedValueSet returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetKeys(
	ISWbemNamedValueSet **objKeys
)
{
	bool result = false;

	if (objKeys)
	{
		*objKeys = NULL;
		
		CSWbemNamedValueSet *pCSWbemNamedValueSet = new CSWbemNamedValueSet (this);

		if (pCSWbemNamedValueSet)
		{
			if (SUCCEEDED(pCSWbemNamedValueSet->QueryInterface (IID_ISWbemNamedValueSet,
								(PPVOID) objKeys)))
				result = true;
			else
				delete pCSWbemNamedValueSet;
		}
	}

	return result;
}

bool CWbemPathCracker::SetKey (
	const CComBSTR & bsName,
	WbemCimtypeEnum cimType,
	VARIANT &var
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					&& SUCCEEDED(pIWbemPathKeyList->SetKey2 (bsName, 0, cimType, &var)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetKeyCount (
	ULONG & iCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;
				iCount = 0;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->GetCount (&iCount)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveAllKeys ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->RemoveAllKeys (0)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveKey (
	const CComBSTR &bsName
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->RemoveKey (bsName, 0)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetComponentCount (
	ULONG & iCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				result = SUCCEEDED(m_pIWbemPath->GetScopeCount (&iCount));
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::AddComponent (
	ULONG iIndex,
	const CComBSTR & bsComponent
)
{
	bool result = false;
	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount;

		if (iIndex <= lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (iIndex < lComponentCount)
						{
							// need to do an insertion - we will have to move
							// all subsequent elements up by one
							for (ULONG i = lComponentCount-1; i >= iIndex; i--)
							{
								ULONG lBufLen = 0;
								m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, NULL);

								wchar_t *pszText = new wchar_t [lBufLen + 1];

								if (pszText)
								{
									pszText [lBufLen] = NULL;

									if (SUCCEEDED(m_pIWbemPath->GetScopeAsText (i, &lBufLen, pszText)))
										m_pIWbemPath->SetScopeFromText (i + 1, pszText);

									delete [] pszText;
								}
							}

							if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
								result = true;
						}
						else
						{
							// just add it to the end
							if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
								result = true;
						}
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::SetComponent (
	ULONG iIndex,
	const CComBSTR & bsComponent
)
{
	bool result = false;
	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount) & (0 < lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount - 1;

		// Is our index in range
		if (iIndex < lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
							result = true;
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::RemoveComponent (
	ULONG iIndex
)
{
	bool result = false;

	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount) & (0 < lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount - 1;

		// Is our index in range
		if (iIndex < lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (SUCCEEDED(m_pIWbemPath->RemoveScope (iIndex)))
							result = true;
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::RemoveAllComponents ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->RemoveAllScopes ()))
					result = true;
			}
		}
			break;
	}

	return result;
}
	
//***************************************************************************
//
//  SCODE CSWbemObjectPath::GetParent
//
//  DESCRIPTION:
//
//  Get the parent path
//
//  PARAMETERS:
//		ppISWbemObjectPath	- parent path on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetParent( 
	CWbemPathCracker & pathCracker)
{	
	pathCracker = *this;
	
	return pathCracker.SetAsParent ();
}

bool CWbemPathCracker::SetAsParent ()
{
	bool result = false;
	
	ULONG lComponents;

	if (GetComponentCount (lComponents))
	{
		if (0 == lComponents)
		{
			// No components - do we have any Namespaces
			ULONG lNamespaces = 0;

			if (GetNamespaceCount (lNamespaces))
			{
				if (0 == lNamespaces)
				{
					// No namespace - do nothing
					result = true;
				}
				else
					result = RemoveNamespace (lNamespaces-1);
			}
		}
		else
		{
			// Remove the last component
			result = RemoveComponent (-1);
		}
	}
		
	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::ClearKeys
//
//  DESCRIPTION:
//
//  Zap the keys from the path parser
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//
//***************************************************************************

bool CWbemPathCracker::ClearKeys (bool bTreatAsClass)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList)))
				{
					if (SUCCEEDED(pIWbemPathKeyList->RemoveAllKeys (0)))
					{
						if (SUCCEEDED(pIWbemPathKeyList->MakeSingleton ((bTreatAsClass) ? FALSE : TRUE)))
							result = true;
					}
				}
				else
				{
					// If no keys, we assume this is done.
					result = true;
				}
			}
		}
			break;
	}

	return result;
}
     
bool CWbemPathCracker::GetKey (
	ULONG	iIndex,
	CComBSTR &bsName,
	VARIANT	&var,
	WbemCimtypeEnum &cimType
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList)))
				{
					if (pIWbemPathKeyList)
					{
						ULONG lBufLen = 0;
						ULONG lCimType;
								
						pIWbemPathKeyList->GetKey2 (iIndex, 0, &lBufLen, NULL, &var, &lCimType);

						wchar_t *pszText = new wchar_t [lBufLen + 1];

						if (pszText)
						{
							pszText [lBufLen] = NULL;

							if (SUCCEEDED(pIWbemPathKeyList->GetKey2 (iIndex, 0, &lBufLen, pszText,
															&var, &lCimType)))
							{
								bsName.m_str = SysAllocString (pszText);
								cimType = (WbemCimtypeEnum) lCimType;
								result = true;
							}

							delete [] pszText;
						}
					}
				}
			}
		}
			break;
	}
	
	return result;
}
  
static bool KeyMatch (CComVariant & var1, CComVariant & var2)
{
	bool keyMatch = false;

	if (var1 == var2)
		keyMatch = true;
	else
	{
		// Check for string key values that are case-insensitive
		if ((var1.vt == var2.vt) && (VT_BSTR == var1.vt))
			keyMatch = var1.bstrVal && var2.bstrVal && 
							(0 == _wcsicmp (var1.bstrVal,
										  var2.bstrVal));
	}

	return keyMatch;
}

bool CWbemPathCracker::operator == (const CComBSTR & path)
{
	bool result = false;
	
	CWbemPathCracker otherPath (path);

	if (GetType () == otherPath.GetType ())
	{
		switch (GetType ())
		{
			case wbemPathTypeWmi:
			{
				if (IsClassOrInstance () && otherPath.IsClassOrInstance ())
				{
					// Do we have matching class names?
					CComBSTR thisClass, otherClass;

					if (GetClass (thisClass) && (otherPath.GetClass (otherClass))
							&& (0 == _wcsicmp (thisClass, otherClass)))
					{
						// Are they both singletons?
						if (IsSingleton () == otherPath.IsSingleton ())
						{
							if (IsSingleton ())
							{
								result = true;
							}
							else if (IsClass () && otherPath.IsClass ())
							{
								result = true;
							}
							else if (IsInstance () && otherPath.IsInstance ())
							{
								// Now we need to keymatch
								ULONG thisKeyCount, otherKeyCount;

								if (GetKeyCount (thisKeyCount) && otherPath.GetKeyCount (otherKeyCount)
									&& (thisKeyCount == otherKeyCount))
								{
									if (1 == thisKeyCount)
									{
										// Need to allow defaulted key names
										CComBSTR keyName, otherKeyName;
										CComVariant value, otherValue;
										WbemCimtypeEnum cimType, otherCimType;

										if (GetKey (0, keyName, value, cimType) &&
											otherPath.GetKey (0, otherKeyName, otherValue, otherCimType))
										{
											if ((0 == keyName.Length ()) || (0 == otherKeyName.Length ()) ||
												(0 == _wcsicmp (keyName, otherKeyName)))
												result = KeyMatch (value, otherValue);
										}
									}
									else
									{
										// Both non-singleton instances - have to check
										// key values are the same in some order
										bool ok = true;
																	
										for (DWORD i = 0; ok && (i < thisKeyCount); i++)
										{
											CComBSTR keyName;
											CComVariant value;
											WbemCimtypeEnum cimType;

											if (GetKey (i, keyName, value, cimType) && (0 < keyName.Length ()))
											{
												// Look for a matching key (case-insensitive)
												CComBSTR otherKeyName;
												CComVariant otherValue;
												WbemCimtypeEnum otherCimType;

												for (DWORD j = 0; ok && (j < thisKeyCount); j++)
												{
													if (otherPath.GetKey (j, otherKeyName, otherValue, otherCimType) 
															&& (0 < otherKeyName.Length ()))
													{
														if ((0 == _wcsicmp(keyName, otherKeyName)) && KeyMatch (value, otherValue))
															break;
													}
													else 
														ok = false;
												}

												if (ok && (j < thisKeyCount))
												{
													// Got a match
													continue;
												}
												else
													ok = false;
											}
											else
												ok = false;
										}

										if (ok)
											result = true;		// all keys have matched
									}
								}
							}
						}
					}
				}
			}
				break;

		}
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\parsedn.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  File:  parsedn.cxx
//
//	Description :
//				Parses CIM paths to objects and returns the requested object
//***************************************************************************

#include "precomp.h"

#define CURRENTSTR (lpszInputString + *pchEaten)

#define SKIPWHITESPACE \
	while (*CURRENTSTR && _istspace( *CURRENTSTR ) ) \
			(*pchEaten)++;

#define WBEMS_STR_OWNER		L"O"
#define	WBEMS_STR_GROUP		L"G"
#define WBEMS_STR_DACL		L"D"
#define WBEMS_STR_SACL		L"S"

static void SecureProxy (bool authnSpecified, enum WbemAuthenticationLevelEnum eAuthLevel,
						 bool impSpecified, enum WbemImpersonationLevelEnum eImpersonLevel,
						 ISWbemServices *pService)
{
	// Secure the proxy using the specified security settings (if any)
	CComPtr<ISWbemSecurity> pSecurity;
	
	if (authnSpecified || impSpecified)
	{
		if (SUCCEEDED(pService->get_Security_(&pSecurity)))
		{
			if (authnSpecified)
				pSecurity->put_AuthenticationLevel (eAuthLevel);

			if (impSpecified)
				pSecurity->put_ImpersonationLevel (eImpersonLevel);
		}
	}
}

static void SecureProxy (bool authnSpecified, enum WbemAuthenticationLevelEnum eAuthLevel,
						 bool impSpecified, enum WbemImpersonationLevelEnum eImpersonLevel,
						 ISWbemObject *pObject)
{
	// Secure the proxy using the specified security settings (if any)
	CComPtr<ISWbemSecurity> pSecurity;
	
	if (authnSpecified || impSpecified)
	{
		if (SUCCEEDED(pObject->get_Security_(&pSecurity)))
		{
			if (authnSpecified)
				pSecurity->put_AuthenticationLevel (eAuthLevel);

			if (impSpecified)
				pSecurity->put_ImpersonationLevel (eImpersonLevel);
		}
	}
}

//***************************************************************************
//
//  CWbemParseDN::CWbemParseDN
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemParseDN::CWbemParseDN():
			m_cRef(0)
{
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CWbemParseDN::~CWbemParseDN
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemParseDN::~CWbemParseDN(void)
{
	InterlockedDecrement(&g_cObj);
}			

//***************************************************************************
// HRESULT CWbemParseDN::QueryInterface
// long CWbemParseDN::AddRef
// long CWbemParseDN::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemParseDN::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = (IUnknown *)this;
	else if (IID_IParseDisplayName==riid)
        *ppv = (IParseDisplayName *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWbemParseDN::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemParseDN::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CWbemParseDN::ParseDisplayName
//
//  DESCRIPTION:
//
//  Take a CIM object path and return a suitable ISWbem... object 
//
//  PARAMETERS:
//
//	pCtx					The binding context (not used)
//	szDisplayName			The display name to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//  ppmk					On return will address the moniker pointer
//
//  RETURN VALUES:
//
//  E_FAIL					misery
//
//	Other CreateMoniker codes are returned.
//
//***************************************************************************
STDMETHODIMP CWbemParseDN::ParseDisplayName(
	IBindCtx* pCtx, 
	LPOLESTR szDisplayName, 
	ULONG* pchEaten, 
	IMoniker** ppmk)
{
    HRESULT hr = E_FAIL;
    LPUNKNOWN pUnknown = NULL;
	ULONG lTemp = 0;
	
	enum WbemAuthenticationLevelEnum eAuthLevel;
	enum WbemImpersonationLevelEnum eImpersonLevel;
	bool authnSpecified = false;
	bool impSpecified = false;
	BSTR bsAuthority = NULL;
		
	//Check input parameters
	*ppmk = NULL;
    if (NULL != pchEaten)
        *pchEaten = 0;

	if (NULL == szDisplayName)
		return E_FAIL;

	/*
	 *  moniker :  wmiMoniker 
	 *
	 *	wmiMoniker : ["winmgmts:" | "wmi:"] securitySetting ["[" localeSetting "]"] ["!" objectPath]
	 *					| ["winmgmts:" | "wmi:"] "[" localeSetting "]" ["!" objectPath]
	 *					| ["winmgmts:" | "wmi:"] [objectPath]
	 *					| [nativePath]
	 *
	 *	localeSetting    : "locale" <ows> "=" <ows> localeID
	 *
	 *	localeID        : a value of the form "ms_xxxx" where xxxx is a hex LCID value e.g. "ms_0x409".
	 *
	 *	objectPath     : a valid WMI Object Path
	 *
	 *	securitySetting : "{" <ows> authAndImpersonSettings [<ows> "," <ows> privilegeOverrides]
	 *				| "{" <ows> authAndImpersonSettings [<ows> "," <ows> privilegeOverrides] <ows> "}" <ows>
	 *				| "{" <ows> privilegeOverrides <ows> "}" <ows>
	 *				
	 *
	 *	authAndImpersonSettings : 
	 *			authenticationLevel 
	 *			| impersonationLevel
	 *			| authority 
	 *			| authenticationLevel <ows> "," <ows> impersonationLevel [<ows> "," <ows> authority]
	 *			| authenticationLevel <ows> "," <ows> authority [<ows> "," <ows> impersonationLevel]
	 *			| impersonationLevel <ows> "," <ows> authenticationLevel [<ows> "," <ows> authority]
	 *			| impersonationLevel <ows> "," <ows> authority [<ows> "," <ows> authenticationLevel]
	 *			| authority <ows> "," <ows> impersonationLevel [<ows> "," <ows> authenticationLevel]
	 *			| authority <ows> "," <ows> authenticationLevel [<ows> "," <ows> impersonationLevel]
     *               
	 *
	 *	authority : "authority" <ows> "=" <ows> authorityValue
	 *
	 *	authorityValue :    Any valid WMI authority string e.g. "kerberos:mydomain\server" or "ntlmdomain:mydomain".   Note that backslashes need to be escaped in JScript.
	 *
	 *	authenticationLevel : "authenticationLevel" <ows> "=" <ows> authenticationValue 
	 *
	 *	authenticationValue : "default" | "none" | "connect" | "call" | "pkt" | "pktIntegrity" | "pktPrivacy" 
	 *
	 *	impersonationLevel : "impersonationLevel" <ows> "=" <ows> impersonationValue 
	 *
	 *	impersonationValue : "anonymous" | "identify" | "impersonate" | "delegate"
	 *
	 *	privilegeOverrides : "(" <ows> privileges <ows> ")"
	 *
	 *	privileges : privilege [<ows> "," <ows> privileges <ows>]*
	 *
	 *	privilege : ["!"] privilegeName
	 *
	 *	privilegeName : "CreateToken" | "PrimaryToken" | "LockMemory" | "IncreaseQuota" 
	 *						| "MachineAccount" | "Tcb" | "Security" | "TakeOwnership" 
	 *						| "LoadDriver" | "SystemProfile" | "SystemTime" 
	 *						| "ProfileSingleProcess" | "IncreaseBasePriority" 
	 *						| "CreatePagefile" | "CreatePermanent" | "Backup" | "Restore" 
	 *						| "Shutdown" | "Debug" | "Audit" | "SystemEnvironment" | "ChangeNotify" 
	 *						| "RemoteShutdown"
	 *
	 */

	// It had better start with our scheme name
	bool bCheckContext = false;

	if (0 == _wcsnicmp (szDisplayName, WBEMS_PDN_SCHEME, wcslen (WBEMS_PDN_SCHEME)))
	{
		*pchEaten += wcslen (WBEMS_PDN_SCHEME);
		bCheckContext = (pCtx && (wcslen (szDisplayName) == wcslen (WBEMS_PDN_SCHEME)));
	}
	else
		return E_FAIL;

	// One more check - if it was just the scheme and no more check for extra info in the context
	if (bCheckContext)
	{
		IUnknown *pUnk = NULL;

		if (SUCCEEDED (pCtx->GetObjectParam (L"WmiObject", &pUnk)) && pUnk)
		{
			// Is it an IWbemClassObject?
			IWbemClassObject *pIWbemClassObject = NULL;
			// Or is it an IWbemContext?
			IWbemContext *pIWbemContext = NULL;
			// Or is it an IWbemServices?
			IWbemServices *pIWbemServices = NULL;

			if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemClassObject, (void **) &pIWbemClassObject)))
			{
				CSWbemObject *pSWbemObject = new CSWbemObject (NULL, pIWbemClassObject);

				if (!pSWbemObject)
					hr = E_OUTOFMEMORY;
				else
				{
					CComPtr<ISWbemObjectEx> pISWbemObjectEx;
						
					if (SUCCEEDED (pSWbemObject->QueryInterface (IID_ISWbemObjectEx, (void **) &pISWbemObjectEx)))
						hr = CreatePointerMoniker (pISWbemObjectEx, ppmk);
				}

				pIWbemClassObject->Release ();
			} 
			else if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemContext, (void **) &pIWbemContext)))
			{
				CSWbemNamedValueSet *pSWbemNamedValueSet = new CSWbemNamedValueSet (NULL, pIWbemContext);

				if (!pSWbemNamedValueSet)
					hr = E_OUTOFMEMORY;
				else
				{
					CComPtr<ISWbemNamedValueSet> pISWbemNamedValueSet;
						
					if (SUCCEEDED (pSWbemNamedValueSet->QueryInterface (IID_ISWbemNamedValueSet, 
														(PPVOID)&pISWbemNamedValueSet)))
						hr = CreatePointerMoniker (pISWbemNamedValueSet, ppmk);
				}
					
				pIWbemContext->Release ();
			} 
			else if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemServices, (void **) &pIWbemServices)))
			{
				// In this case we must get passed the object path as well
				CComPtr<IUnknown> pUnkPath;

				if (SUCCEEDED (pCtx->GetObjectParam (L"WmiObjectPath", &pUnkPath)) && pUnkPath)
				{
					CComPtr<ISWbemObjectPath> pISWbemObjectPath;
					
					if (SUCCEEDED (pUnkPath->QueryInterface (IID_ISWbemObjectPath, (void **) &pISWbemObjectPath)))
					{
						// Dig the path out to initialize 
						CComBSTR bsNamespace = NULL;

						pISWbemObjectPath->get_Path (&bsNamespace);

						CSWbemServices *pSWbemServices = new CSWbemServices (pIWbemServices, 
														bsNamespace, (BSTR) NULL, NULL, NULL);

						if (!pSWbemServices)
							hr = E_OUTOFMEMORY;
						else
						{
							CComQIPtr<ISWbemServicesEx>
											pISWbemServicesEx (pSWbemServices);
							
							if (pISWbemServicesEx)
								hr = CreatePointerMoniker (pISWbemServicesEx, ppmk);
						}
					}
				}
				pIWbemServices->Release ();
			}

			pUnk->Release ();
		}

		// If this worked return now - o/w revert to regular parsing
		if (SUCCEEDED (hr))
			return hr;
	}
	
	// Check for the optional security info
	CSWbemPrivilegeSet	privilegeSet;

	if (ParseSecurity(szDisplayName + *pchEaten, &lTemp, authnSpecified, &eAuthLevel, 
										impSpecified, &eImpersonLevel, privilegeSet,
										bsAuthority))
		*pchEaten += lTemp;

	// If no impersonation level was specified, get the default from the registry
	if (!impSpecified)
	{
		eImpersonLevel = CSWbemSecurity::GetDefaultImpersonationLevel ();
		impSpecified = true;
	}

	// Create a locator
	CSWbemLocator *pCSWbemLocator = new CSWbemLocator(&privilegeSet);

	if (!pCSWbemLocator)
		hr = E_OUTOFMEMORY;
	else
	{
		CComQIPtr<ISWbemLocator> pISWbemLocator (pCSWbemLocator);

		if (pISWbemLocator)
		{
			// Parse the locale information (if present)
			lTemp = 0;
			BSTR bsLocale = NULL;

			if (ParseLocale (szDisplayName + *pchEaten, &lTemp, bsLocale))
			{
				*pchEaten += lTemp;

				// Skip over the "!" separator if there is one
				if(*(szDisplayName + *pchEaten) != NULL)
					if (0 == _wcsnicmp (szDisplayName + *pchEaten, WBEMS_EXCLAMATION, wcslen (WBEMS_EXCLAMATION)))
						*pchEaten += wcslen (WBEMS_EXCLAMATION);

				// Now ready to parse the path - check if we have the degenerate cases
				if (0 == wcslen (szDisplayName + *pchEaten))
				{		
					// Need to return connection to default namespace on local machine
					CComPtr<ISWbemServices> pISWbemServices;
					if (SUCCEEDED( hr = pISWbemLocator->ConnectServer (NULL, NULL, NULL, NULL,
								bsLocale, bsAuthority, 0, NULL, &pISWbemServices)) )
					{
						SecureProxy (authnSpecified, eAuthLevel, impSpecified, eImpersonLevel, pISWbemServices);
						hr = CreatePointerMoniker(pISWbemServices, ppmk);
					}
				}
				else
				{
					/*
					 * Check the path to see if we are dealing with a class or an instance.
					 * Note that we construct the parser with a flag indicating that relative
					 * namespace paths are OK (not the default behavior).
					 */
					CWbemPathCracker	pathCracker (szDisplayName + *pchEaten);

					if (CWbemPathCracker::WbemPathType::wbemPathTypeError != pathCracker.GetType ())
					{
						CComBSTR bsNamespacePath, bsServerPath;

						if (pathCracker.GetNamespacePath (bsNamespacePath)
							&& pathCracker.GetServer (bsServerPath))
						{
							// Success - begin by connecting to the namespace.
							CComPtr<ISWbemServices> pISWbemServices;
							
							if (SUCCEEDED( hr = pISWbemLocator->ConnectServer (bsServerPath, 
									bsNamespacePath, NULL, NULL, bsLocale, bsAuthority, 0, NULL, &pISWbemServices)) )
							{
								// Secure the proxy using the specified security settings (if any)
								SecureProxy (authnSpecified, eAuthLevel, impSpecified, eImpersonLevel, pISWbemServices);
							
								// Successful connection - now work out if we have a class or instance
								// component. 
								if (pathCracker.IsClassOrInstance())
								{
									CComPtr<ISWbemObject> pISWbemObject;

									// Now get it
									CComBSTR bsRelPath;
									
									if (pathCracker.GetPathText (bsRelPath, true))
									{
										long lFlags = 0; 

										// Note that when we retrieve the object we will retrieve
										// the localized version if a locale was specified in the moniker
										if ((NULL != bsLocale) && (0 < wcslen (bsLocale)))
											lFlags |= wbemFlagUseAmendedQualifiers;

										if (SUCCEEDED( hr = pISWbemServices->Get (bsRelPath,
														lFlags, NULL, &pISWbemObject)) )
											hr = CreatePointerMoniker (pISWbemObject, ppmk);
									}
								}
								else
								{
									// Just a namespace
									hr = CreatePointerMoniker(pISWbemServices, ppmk);				
								}
							}
						}
						else
							hr = WBEM_E_INVALID_SYNTAX;	// Parse failure - abandon ship
					}
					else
						hr = WBEM_E_INVALID_SYNTAX;	// Parse failure - abandon ship
				}
			}
			else
			{
				// Parse failure
				hr = WBEM_E_INVALID_SYNTAX;
			}

			SysFreeString (bsLocale);
		}
	}

	SysFreeString (bsAuthority);

	if (FAILED (hr))
		*pchEaten = 0;
	else
		*pchEaten = wcslen(szDisplayName);

	return hr;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseSecurity
//
//  DESCRIPTION:
//
//  Take an authentication and impersonlation level string as described by the 
//	non-terminal authAndImpersonLevel and parse it into the authentication
// and impersonation levels
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	authnSpecified			Whether the Moniker specifies a non-default 
//							authn levl
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//	impSpecified			Whether the Moniker specifies a non-default imp 
//							level
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//	privilegeSet			On return contains the specified privileges
//	bsAuthority				On return contains the specified authority
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel and 
//							lpeImpersonLevel arguments have valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseSecurity (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	bool &authnSpecified,
	enum WbemAuthenticationLevelEnum *lpeAuthLevel,
	bool &impSpecified,
	enum WbemImpersonationLevelEnum *lpeImpersonLevel,
	CSWbemPrivilegeSet	&privilegeSet,
	BSTR &bsAuthority)
{
	bool status = false;

	// Set the default authentication and impersonation levels. 
	*lpeAuthLevel = wbemAuthenticationLevelNone;
	*lpeImpersonLevel = wbemImpersonationLevelImpersonate;

	// Initialize the number of consumed characters
	*pchEaten = 0;

	// Parse the contents

	if (ParseAuthAndImpersonLevel (lpszInputString, pchEaten, authnSpecified, lpeAuthLevel,
					impSpecified, lpeImpersonLevel, privilegeSet, bsAuthority))
		status = true;
	else
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseLocale
//
//  DESCRIPTION:
//
//  Take locale setting string as described by the non-terminal localeSetting 
//	and parse it.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	bsLocale				Reference to BSTR to hold parsed locale setting
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseLocale (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	BSTR &bsLocale)
{
	bool status = true;

	// Initialize the number of consumed characters
	*pchEaten = 0;

	// The first character should be '[' - if not we are done
	if (0 == _wcsnicmp (lpszInputString, WBEMS_LEFT_SQBRK, wcslen (WBEMS_LEFT_SQBRK)))
	{
		status = false;

		*pchEaten += wcslen (WBEMS_LEFT_SQBRK);

		// Parse the locale setting
		SKIPWHITESPACE

		// The next string should be "locale"
		if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_LOCALE, wcslen(WBEMS_LOCALE)))
		{
			*pchEaten += wcslen (WBEMS_LOCALE);

			SKIPWHITESPACE

			// Next should be "="
			if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EQUALS, wcslen(WBEMS_EQUALS)))
			{
				*pchEaten += wcslen (WBEMS_EQUALS);

				SKIPWHITESPACE

				// Now we should have a character not equal to "]" (i.e. must specify locale ID string)
				if (0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
				{
					// Consume everything up to the next space or "]"
					LPWSTR cStr = CURRENTSTR;
					ULONG lEaten = 0;	// How many characters we consume
					ULONG lLocale = 0;	// The actual length of the locale ID
					
					while (*(cStr + lEaten))
					{
						if (_istspace(*(cStr + lEaten)))
						{
							lEaten++;

							// Hit white space - now skip until we find the "]"
							SKIPWHITESPACE

							// Now we must have a "]"
							if 	(0 == _wcsnicmp 
									(cStr + lEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
							{
								// Success - we are done
								lEaten += wcslen (WBEMS_RIGHT_SQBRK);
							}

							break;
						}
						else if (0 == _wcsnicmp (cStr + lEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
						{
							// Hit closing "]" - we are done
							lEaten += wcslen (WBEMS_RIGHT_SQBRK);
							break;
						}
						else	// Consumed a locale character - keep on truckin'
						{
							lLocale++;
							lEaten++;
						}
					}

					// If we terminated correctly, save the locale setting
					if ((lEaten > 1) && (lLocale > 0))
					{
						status = true;

						LPWSTR pLocaleStr = new WCHAR [lLocale + 1];

						if (pLocaleStr)
						{
							wcsncpy (pLocaleStr, lpszInputString + *pchEaten, lLocale);
							pLocaleStr [lLocale] = NULL;
							bsLocale = SysAllocString (pLocaleStr);

							delete [] pLocaleStr;
							*pchEaten += lEaten;
						}
						else
							status = false;
					}
				}
			}
		}
	}

	if (!status)
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthAndImpersonLevel
//
//  DESCRIPTION:
//
//  Take an authentication/impersonlation/authority level string as described by the 
//	non-terminal authAndImpersonLevel and parse it into the authentication
//	and impersonation levels and the authority string
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	authnSpecified			Whether the Moniker specifies a non-default 
//							authn levl
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//	impSpecified			Whether the Moniker specifies a non-default imp 
//							level
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//	privilegeSet			On return holds the privileges
//	bsAuthority				On retunr holds the authority string (if any)
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel and 
//							lpeImpersonLevel arguments have valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthAndImpersonLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	bool &authnSpecified,
	enum WbemAuthenticationLevelEnum *lpeAuthLevel,
	bool &impSpecified,
	enum WbemImpersonationLevelEnum *lpeImpersonLevel,
	CSWbemPrivilegeSet &privilegeSet,
	BSTR &bsAuthority)
{
	// The first character should be '{'
	if (0 != _wcsnicmp (lpszInputString, WBEMS_LEFT_CURLY, wcslen (WBEMS_LEFT_CURLY)))
		return FALSE;
	else
		*pchEaten += wcslen (WBEMS_LEFT_CURLY);

	bool	authoritySpecified = false;
	bool	privilegeSpecified = false;
	bool	done = false;
	bool	error = false;

	while (!done)
	{
		bool parsingAuthenticationLevel = false;	// Which token are we parsing?
		bool parsingPrivilegeSet = false;
		bool parsingAuthority = false;

		SKIPWHITESPACE
		
		// The next string should be one of "authenticationLevel", "impersonationLevel",
		// "authority", the privilege collection start marker "(", or the security
		// descriptor start marker "<"
		if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_LEVEL, wcslen(WBEMS_AUTH_LEVEL)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (authnSpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingAuthenticationLevel = true;
				*pchEaten += wcslen (WBEMS_AUTH_LEVEL);
			}
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_LEVEL, wcslen(WBEMS_IMPERSON_LEVEL)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (impSpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
				*pchEaten += wcslen (WBEMS_IMPERSON_LEVEL) ;
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTHORITY, wcslen(WBEMS_AUTHORITY)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (authoritySpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingAuthority = true;
				*pchEaten += wcslen (WBEMS_AUTHORITY) ;
			}
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_LEFT_PAREN, wcslen(WBEMS_LEFT_PAREN)))
		{
			// Error if we have already done this
			if (privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingPrivilegeSet = true;
				*pchEaten += wcslen (WBEMS_LEFT_PAREN);
			}
		}
		else
		{
			// Unrecognized token or NULL
			error = true;
			break;
		}

		// Getting here means we have something to parse
		SKIPWHITESPACE

		if (parsingPrivilegeSet)
		{
			ULONG chEaten = 0;

			if (ParsePrivilegeSet (lpszInputString + *pchEaten, &chEaten, privilegeSet))
			{
				privilegeSpecified = true;
				*pchEaten += chEaten;

				// If the next token is "}" we are done
				if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen(WBEMS_RIGHT_CURLY)))
				{
					*pchEaten += wcslen (WBEMS_RIGHT_CURLY);
					done = true;
				}
			}
			else
			{
				error = true;
				break;
			}
		}
		else
		{
			// Parsing authentication, impersonation or authority. The next character should be '='
			if(0 != _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EQUALS, wcslen(WBEMS_EQUALS)))
			{
				error = true;
				break;
			}
			else
			{
				*pchEaten += wcslen (WBEMS_EQUALS);
				SKIPWHITESPACE

				if (parsingAuthenticationLevel)
				{
					if (!ParseAuthenticationLevel (lpszInputString, pchEaten, lpeAuthLevel))
					{
						error = true;
						break;
					}
					else
						authnSpecified = true;
				}
				else if (parsingAuthority)
				{
					// Get the authority string
					if (!ParseAuthority (lpszInputString, pchEaten, bsAuthority))
					{
						error = true;
						break;
					}
					else
						authoritySpecified = true;
				}
				else
				{
					// Must be parsing impersonation level
					
					if (!ParseImpersonationLevel (lpszInputString, pchEaten, lpeImpersonLevel))
					{
						error = true;
						break;
					}
					else
						impSpecified = true;
				}

				SKIPWHITESPACE
					
				// The next token should be "}" or ","
				if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen(WBEMS_RIGHT_CURLY)))
				{
					*pchEaten += wcslen (WBEMS_RIGHT_CURLY);
					done = true;
				}
				else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_COMMA, wcslen(WBEMS_COMMA)))
				{
					// If we have parsed all expected tokens this is an error
					if (authnSpecified && impSpecified && authoritySpecified && privilegeSpecified)
					{
						error = true;
						break;
					}
					else
					{
						*pchEaten += wcslen (WBEMS_COMMA);
						// Loop round again for the next token
					}
				}
				else
				{
					// Unrecognized token
					error = true;
					break;
				}
			}
		}
	}

	if (error)
	{
		impSpecified = authnSpecified = false;
		*pchEaten = 0;
		return false;
	}

	return true;		// success
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseImpersonationLevel
//
//  DESCRIPTION:
//
//  Parse the string specification of an impersonation level into a
//	symbolic constant value.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeImpersonLevel 
//							argument has valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseImpersonationLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	enum WbemImpersonationLevelEnum *lpeImpersonLevel
)
{
	bool status = true;	
	
	if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_ANON, wcslen(WBEMS_IMPERSON_ANON)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelAnonymous;
		*pchEaten += wcslen (WBEMS_IMPERSON_ANON);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_IDENTIFY, wcslen(WBEMS_IMPERSON_IDENTIFY)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelIdentify;
		*pchEaten += wcslen (WBEMS_IMPERSON_IDENTIFY);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_IMPERSON, wcslen(WBEMS_IMPERSON_IMPERSON)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelImpersonate;
		*pchEaten += wcslen (WBEMS_IMPERSON_IMPERSON);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_DELEGATE, wcslen(WBEMS_IMPERSON_DELEGATE)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelDelegate;
		*pchEaten += wcslen (WBEMS_IMPERSON_DELEGATE);
	}
	else
		status = false;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthenticationLevel
//
//  DESCRIPTION:
//
//  Parse the string specification of an authentication level into a
//	symbolic constant value.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel 
//							argument has valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthenticationLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	enum WbemAuthenticationLevelEnum *lpeAuthLevel
)
{
	bool status = true;	
	
	if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_DEFAULT, wcslen(WBEMS_AUTH_DEFAULT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelDefault;
		*pchEaten += wcslen (WBEMS_AUTH_DEFAULT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_NONE, wcslen(WBEMS_AUTH_NONE)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelNone;
		*pchEaten += wcslen (WBEMS_AUTH_NONE);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_CONNECT, wcslen(WBEMS_AUTH_CONNECT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelConnect;
		*pchEaten += wcslen (WBEMS_AUTH_CONNECT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_CALL, wcslen(WBEMS_AUTH_CALL)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelCall;
		*pchEaten += wcslen (WBEMS_AUTH_CALL);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT_INT, wcslen(WBEMS_AUTH_PKT_INT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPktIntegrity;
		*pchEaten += wcslen (WBEMS_AUTH_PKT_INT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT_PRIV, wcslen(WBEMS_AUTH_PKT_PRIV)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPktPrivacy;
		*pchEaten += wcslen (WBEMS_AUTH_PKT_PRIV);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT, wcslen(WBEMS_AUTH_PKT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPkt;
		*pchEaten += wcslen (WBEMS_AUTH_PKT);
	}
	else
		status = false;
	
	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthority
//
//  DESCRIPTION:
//
//  Take authority setting string as described by the non-terminal localeSetting 
//	and parse it.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	bsAuthority				Reference to BSTR to hold parsed authority string
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthority (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	BSTR &bsAuthority)
{
	bool status = false;

	// Now we should have a character not equal to "," or "}" (i.e. must specify authority string)
	if ((0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_COMMA, wcslen (WBEMS_COMMA))) &&
		(0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen (WBEMS_RIGHT_CURLY))))
	{
		// Consume everything up to the next space, "," or "]"
		LPWSTR cStr = CURRENTSTR;
		ULONG lEaten = 0;		// Number of characters consumed
		ULONG lAuthority = 0;	// Actual length of the authority string
		
		while (*(cStr + lEaten))
		{
			if (_istspace(*(cStr + lEaten)))
			{
				// Hit white space - stop now
				break;
			}
			else if ((0 == _wcsnicmp (cStr + lEaten, WBEMS_RIGHT_CURLY, wcslen (WBEMS_RIGHT_CURLY))) ||
					 (0 == _wcsnicmp (cStr + lEaten, WBEMS_COMMA, wcslen (WBEMS_COMMA))))
			{
				// Hit closing "}" or "," - we are done; unpop the "}" or "," as that will be handled
				// in the calling function
				break;
			}
			else	// Keep on truckin'
			{
				lAuthority++;
				lEaten++;
			}
		}

		// If we terminated correctly, save the locale setting
		if ((lEaten > 1) && (lAuthority > 0))
		{
			status = true;

			LPWSTR pAuthorityStr = new WCHAR [lAuthority + 1];

			if (pAuthorityStr)
			{
				wcsncpy (pAuthorityStr, lpszInputString + *pchEaten, lAuthority);
				pAuthorityStr [lAuthority] = NULL;
				bsAuthority = SysAllocString (pAuthorityStr);

				delete [] pAuthorityStr;
				*pchEaten += lEaten;
			}
			else
				status = false;
		}
	}
	
	if (!status)
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParsePrivilegeSet
//
//  DESCRIPTION:
//
//  Parse the string specification of privilege settings.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	privilegeSet			The container into which the parsed privileges
//							are stored.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParsePrivilegeSet (
	LPWSTR lpszInputString,
	ULONG *pchEaten, 
	CSWbemPrivilegeSet &privilegeSet
)
{
	// We have consumed the initial "(".  Now we are looking for
	// a list of privileges, followed by a final ")"

	bool status = true;
	ULONG chEaten = *pchEaten;		// In case we need to roll back
	bool done = false;
	bool firstPrivilege = true;

	SKIPWHITESPACE

	while (!done)
	{
		VARIANT_BOOL bEnabled = VARIANT_TRUE;

		// If not the first privilege we are expecting a ","
		if (!firstPrivilege)
		{
			if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_COMMA, wcslen(WBEMS_COMMA)))
			{
				*pchEaten += wcslen (WBEMS_COMMA);
				SKIPWHITESPACE
			}
			else
			{
				status = false;
				break;
			}
		}

		// Next token may be a "!" to indicate a disabled privilege
		if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EXCLAMATION, wcslen(WBEMS_EXCLAMATION)))
		{
			*pchEaten += wcslen (WBEMS_EXCLAMATION);
			bEnabled = VARIANT_FALSE;
			SKIPWHITESPACE
		}

		// Next token must be a valid privilege moniker name
		WbemPrivilegeEnum	iPrivilege;

		if (CSWbemPrivilege::GetIdFromMonikerName (lpszInputString + *pchEaten, iPrivilege))
		{
			ISWbemPrivilege *pDummy = NULL;

			if (SUCCEEDED (privilegeSet.Add (iPrivilege, bEnabled, &pDummy)))
			{
				*pchEaten += wcslen (CSWbemPrivilege::GetMonikerNameFromId (iPrivilege));
				pDummy->Release ();
			}
			else
			{
				status = false;
				break;
			}
		}
		else
		{
			// Didn't recognize the privilege name
			status = false;
			break;
		}
		
		SKIPWHITESPACE

		// Finally if we meet a ")" we are truly done with no error
		if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_PAREN, wcslen(WBEMS_RIGHT_PAREN)))
		{
			*pchEaten += wcslen (WBEMS_RIGHT_PAREN);
			done = true;
			SKIPWHITESPACE
		}

		firstPrivilege = false;
		SKIPWHITESPACE
	}

	if (!status)
	{
		// Misery - blow away any privileges we might have accrued
		*pchEaten = chEaten;
		privilegeSet.DeleteAll ();
	}

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::GetSecurityString
//
//  DESCRIPTION:
//
//  Take an authentication and impersonlation level and convert it into 
//	a security specifier string.
//
//  PARAMETERS:
//
//	authnSpecified		Whether a nondefault authn levl is specified.
//	authnLevel			The authentication level.
//	impSpecified		Whether a non-default imp level is specified.
//	impLevel			The impersonation level.
//	privilegeSet		Privileges
//	bsAuthority			Authority
//	
//
//  RETURN VALUES:
//		the newly created string (which the caller must free) or NULL
//
//***************************************************************************

wchar_t *CWbemParseDN::GetSecurityString (
	bool authnSpecified, 
	enum WbemAuthenticationLevelEnum authnLevel, 
	bool impSpecified, 
	enum WbemImpersonationLevelEnum impLevel,
	CSWbemPrivilegeSet &privilegeSet,
	BSTR &bsAuthority
)
{
	wchar_t *pResult = NULL;
	long lPrivilegeCount = 0;
	privilegeSet.get_Count (&lPrivilegeCount);
	ULONG lNumDisabled = privilegeSet.GetNumberOfDisabledElements ();
	PrivilegeMap privMap = privilegeSet.GetPrivilegeMap ();
	bool authoritySpecified = ((NULL != bsAuthority) && (0 < wcslen (bsAuthority)));

	// Degenerate case - no security info
	if (!authnSpecified && !impSpecified && (0 == lPrivilegeCount)
		&& !authoritySpecified)
		return NULL;

	// Must have at least these 2 tokens
	size_t len = wcslen (WBEMS_LEFT_CURLY) + wcslen (WBEMS_RIGHT_CURLY);
	
	if (authnSpecified)
	{
		len += wcslen(WBEMS_AUTH_LEVEL) + wcslen (WBEMS_EQUALS);

		switch (authnLevel)
		{
			case wbemAuthenticationLevelDefault:
				len += wcslen (WBEMS_AUTH_DEFAULT);
				break;

			case wbemAuthenticationLevelNone:
				len += wcslen (WBEMS_AUTH_NONE);
				break;

			case wbemAuthenticationLevelConnect:
				len += wcslen (WBEMS_AUTH_CONNECT);
				break;

			case wbemAuthenticationLevelCall:
				len += wcslen (WBEMS_AUTH_CALL);
				break;

			case wbemAuthenticationLevelPkt:
				len += wcslen (WBEMS_AUTH_PKT);
				break;

			case wbemAuthenticationLevelPktIntegrity:
				len += wcslen (WBEMS_AUTH_PKT_INT);
				break;

			case wbemAuthenticationLevelPktPrivacy:
				len += wcslen (WBEMS_AUTH_PKT_PRIV);
				break;

			default:
				return NULL;	// Bad level
		}

		if (impSpecified || authoritySpecified)
			len += wcslen (WBEMS_COMMA);
	}

	if (impSpecified)
	{
		len += wcslen(WBEMS_IMPERSON_LEVEL) + wcslen (WBEMS_EQUALS);

		switch (impLevel)
		{
			case wbemImpersonationLevelAnonymous:
				len += wcslen (WBEMS_IMPERSON_ANON);
				break;

			case wbemImpersonationLevelIdentify:
				len += wcslen (WBEMS_IMPERSON_IDENTIFY);
				break;

			case wbemImpersonationLevelImpersonate:
				len += wcslen (WBEMS_IMPERSON_IMPERSON);
				break;

			case wbemImpersonationLevelDelegate:
				len += wcslen (WBEMS_IMPERSON_DELEGATE);
				break;

			default:
				return NULL;	// Bad level
		}

		if (authoritySpecified)
			len += wcslen (WBEMS_COMMA);
	}

	if (authoritySpecified)
		len += wcslen(WBEMS_AUTHORITY) + wcslen (WBEMS_EQUALS) + wcslen (bsAuthority);

	if (0 < lPrivilegeCount)
	{
		// If imp, authn or authority also specified, we need another separator
		if (authnSpecified || impSpecified || authoritySpecified)
			len += wcslen (WBEMS_COMMA);

		// Need these boundary tokens
		len += wcslen (WBEMS_LEFT_PAREN) + wcslen (WBEMS_RIGHT_PAREN);

		// Need a separator between each privilege
		if (1 < lPrivilegeCount)
			len += (lPrivilegeCount - 1) * wcslen (WBEMS_COMMA);

		// Need to specify false values with "!"
		if (lNumDisabled)
			len += lNumDisabled * wcslen (WBEMS_EXCLAMATION);

		// Now add the privilege strings
		PrivilegeMap::iterator next = privMap.begin ();

		while (next != privMap.end ())
		{
			OLECHAR *sMonikerName = CSWbemPrivilege::GetMonikerNameFromId ((*next).first);
			
			if (sMonikerName)
				len += wcslen (sMonikerName);

			next++;
		}
	}

	pResult = new wchar_t [len + 1];

	if (pResult)
	{
		// Now build the string
		wcscpy (pResult, WBEMS_LEFT_CURLY);
		
		if (authnSpecified)
		{
			wcscat (pResult, WBEMS_AUTH_LEVEL);
			wcscat (pResult, WBEMS_EQUALS);

			switch (authnLevel)
			{
				case wbemAuthenticationLevelDefault:
					wcscat (pResult, WBEMS_AUTH_DEFAULT);
					break;

				case wbemAuthenticationLevelNone:
					wcscat (pResult, WBEMS_AUTH_NONE);
					break;

				case wbemAuthenticationLevelConnect:
					wcscat (pResult, WBEMS_AUTH_CONNECT);
					break;

				case wbemAuthenticationLevelCall:
					wcscat (pResult, WBEMS_AUTH_CALL);
					break;

				case wbemAuthenticationLevelPkt:
					wcscat (pResult, WBEMS_AUTH_PKT);
					break;

				case wbemAuthenticationLevelPktIntegrity:
					wcscat (pResult, WBEMS_AUTH_PKT_INT);
					break;

				case wbemAuthenticationLevelPktPrivacy:
					wcscat (pResult, WBEMS_AUTH_PKT_PRIV);
					break;
			}

			if (impSpecified || authoritySpecified || (0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (impSpecified)
		{
			wcscat (pResult, WBEMS_IMPERSON_LEVEL);
			wcscat (pResult, WBEMS_EQUALS);

			switch (impLevel)
			{
				case wbemImpersonationLevelAnonymous:
					wcscat (pResult, WBEMS_IMPERSON_ANON);
					break;

				case wbemImpersonationLevelIdentify:
					wcscat (pResult, WBEMS_IMPERSON_IDENTIFY);
					break;

				case wbemImpersonationLevelImpersonate:
					wcscat (pResult, WBEMS_IMPERSON_IMPERSON);
					break;

				case wbemImpersonationLevelDelegate:
					wcscat (pResult, WBEMS_IMPERSON_DELEGATE);
					break;

				default:
					return NULL;	// Bad level
			}

			if (authoritySpecified || (0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (authoritySpecified)
		{
			wcscat (pResult, WBEMS_AUTHORITY);
			wcscat (pResult, WBEMS_EQUALS);
			wcscat (pResult, bsAuthority);

			if ((0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (lPrivilegeCount)
		{
			wcscat (pResult, WBEMS_LEFT_PAREN);
			
			// Now add the privilege strings
			PrivilegeMap::iterator next = privMap.begin ();
			bool firstPrivilege = true;

			while (next != privMap.end ())
			{
				if (!firstPrivilege)
					wcscat (pResult, WBEMS_COMMA);

				firstPrivilege = false;
			
				CSWbemPrivilege *pPrivilege = (*next).second;
				VARIANT_BOOL bValue;
				if (SUCCEEDED (pPrivilege->get_IsEnabled (&bValue)) &&
							(VARIANT_FALSE == bValue))
					wcscat (pResult, WBEMS_EXCLAMATION);

				OLECHAR *sMonikerName = CSWbemPrivilege::GetMonikerNameFromId ((*next).first);
				wcscat (pResult, sMonikerName);

				next++;
			}

			wcscat (pResult, WBEMS_RIGHT_PAREN);
		}

		wcscat (pResult, WBEMS_RIGHT_CURLY);
		
		pResult [len] = NULL;
	}

	return pResult;
}


//***************************************************************************
//
//  BOOLEAN CWbemParseDN::GetLocaleString
//
//  DESCRIPTION:
//
//  Take a locale value and convert it into a locale specifier string.
//
//  PARAMETERS:
//
//	bsLocale		The value (if any)
//
//  RETURN VALUES:
//		the newly created string (which the caller must free) or NULL
//
//***************************************************************************

wchar_t *CWbemParseDN::GetLocaleString (
	BSTR bsLocale
)
{
	wchar_t *pResult = NULL;
	
	// Degenerate case - no locale info
	if (!bsLocale || (0 == wcslen (bsLocale)))
		return NULL;

	// Calculate length of string
	size_t len = wcslen (WBEMS_LEFT_SQBRK) + wcslen (WBEMS_LOCALE) +
			wcslen (WBEMS_EQUALS) + wcslen (bsLocale) + wcslen (WBEMS_RIGHT_SQBRK);
	
	pResult = new wchar_t [len + 1];

	if (pResult)
	{
		// Now build the string
		wcscpy (pResult, WBEMS_LEFT_SQBRK);
		wcscat (pResult, WBEMS_LOCALE);
		wcscat (pResult, WBEMS_EQUALS);
		wcscat (pResult, bsLocale);
		wcscat (pResult, WBEMS_RIGHT_SQBRK);
			
		pResult [len] = NULL;
	}

	return pResult;
}


#undef CURRENTSTR
#undef SKIPWHITESPACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pathcrak.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  pathcrak.h
//
//  alanbos  27-Mar-00   Created.
//
//  CWbemPathCracker definition
//
//***************************************************************************

#ifndef _PATHCRAK_H_
#define _PATHCRAK_H_

class CWbemPathCracker : public IUnknown
{
public:
	CWbemPathCracker (const CComBSTR & bsPath);
	CWbemPathCracker (CWbemPathCracker & path);
	CWbemPathCracker (void);
	virtual ~CWbemPathCracker (void);

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	typedef enum {
		wbemPathTypeError = 0,
		wbemPathTypeWmi,
	}	WbemPathType;

	WbemPathType	GetType ()	const 
	{
		return m_type;
	}

	bool		GetParent (CWbemPathCracker & path);	

	bool operator == (const CComBSTR & path);
	const CWbemPathCracker & operator = (CWbemPathCracker & path);

	bool operator = (const CComBSTR & path);

	// Path composition
	bool operator += (const CComBSTR & bsObjectPath);

	// Server
	bool		GetServer (CComBSTR & bsPath);
	bool		SetServer (const CComBSTR & bsPath);

	// Namespace
	bool		GetNamespacePath (CComBSTR & bsPath, bool bParentOnly = false);
	bool		SetNamespacePath (const CComBSTR & bsPath);
	bool		GetNamespaceCount (unsigned long & lCount);

	// Component
	bool		GetComponent (ULONG iIndex, CComBSTR & bsPath);
	bool		GetComponentCount (ULONG & iCount);
	bool		AddComponent (ULONG iIndex, const CComBSTR &bsComponent);
	bool		SetComponent (ULONG iIndex, const CComBSTR &bsComponent);
	bool		RemoveComponent (ULONG iIndex);
	bool		RemoveAllComponents ();

	// Keys
	bool		GetKeys(ISWbemNamedValueSet **objKeys);
	bool		GetKey (ULONG iIndex, CComBSTR & bsName, VARIANT & var, WbemCimtypeEnum &cimType);
	bool		GetKeyCount (ULONG & iCount);
	bool		SetKey (const CComBSTR & bsName, WbemCimtypeEnum cimType, VARIANT & var);
	bool		RemoveKey (const CComBSTR & bsName);
	bool		RemoveAllKeys ();

	// Class & Instance
	bool		IsClassOrInstance ();
	bool		IsClass ();
	bool		IsInstance ();
	bool		IsSingleton ();
	bool		SetAsClass ();
	bool		SetAsSingleton ();

	bool		IsRelative ();
	bool		GetPathText (CComBSTR & bsPath, bool bRelativeOnly = false,
								bool bIncludeServer = false, bool bNamespaceOnly = false);
	bool		SetRelativePath (const CComBSTR & bsPath);

	bool		GetClass (CComBSTR & bsPath);
	bool		SetClass (const CComBSTR &bsPath);


private:
	CComPtr<IWbemPath>	m_pIWbemPath;
	CComBSTR			m_bsNativePath;
	long				m_cRef;
	WbemPathType		m_type;

	void				CreateParsers ();
	void				SetText (const CComBSTR & bsPath, bool bForceAsNamespace = false);

	static WbemPathType		GetTypeFromText (const CComBSTR & bsPath);
	
	bool					CopyServerAndNamespace (CWbemPathCracker &pathCracker);

	bool					GetNamespaceAt (ULONG iIndex, CComBSTR & bsPath);
	bool					SetNamespaceAt (ULONG iIndex, const CComBSTR & bsPath);
	bool					RemoveNamespace (ULONG iIndex);
	void					ClearNamespace ();

	bool					SetAsParent ();
	bool					ClearKeys (bool bTreatAsClass = true);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\precomp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  precomp.h
//
//  alanbos  04-Mar-98   Created.
//
//  Master include file.
//
//***************************************************************************

#pragma warning(disable:4786)
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <objbase.h>
#include <objsafe.h>
#include <ocidl.h>
#include <memory.h>
#include <wbemidl.h>
#include <cominit.h>
#include <map>
#include <vector>
#include <atlbase.h>
#include <wmiutils.h>
#include "wbemdisp.h"
#include "disphlp.h"
#include "cwbemdsp.h"
#include "dispi.h"
#include "site.h"
#include "pxycache.h"
#include "privilege.h"
#include "security.h"
#include "locator.h"
#include "services.h"
#include "object.h"
#include "pathcrak.h"
#include "sobjpath.h"
#include "nvalue.h"
#include "qualifier.h"
#include "property.h"
#include "method.h"
#include "events.h"
#include "sink.h"
#include "util.h"
#include "enumvar.h"
#include "parsedn.h"
#include "classfac.h"
#include "contvar.h"
#include "qualvar.h"
#include "propvar.h"
#include "objobjp.h"
#include "methvar.h"
#include "error.h"
#include "datetime.h"
#include "refresher.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\privilege.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.H
//
//  alanbos  30-Sep-98   Created.
//
//  Define Privilege classes.
//
//***************************************************************************

#ifndef _PRIVILEGE_H_
#define _PRIVILEGE_H_

using namespace std;

class CEnumPrivilegeSet;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilege
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilege interface.  
//
//***************************************************************************

class CSWbemPrivilege : public ISWbemPrivilege,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CDispatchHelp		m_Dispatch;
	LUID				m_Luid;
	bool				m_bIsEnabled;
	WbemPrivilegeEnum	m_privilege;
	
protected:
	long            m_cRef;         //Object reference count

public:
    CSWbemPrivilege (WbemPrivilegeEnum privilege, LUID &luid, bool bIsEnabled);
	virtual ~CSWbemPrivilege (void);

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
	STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
	STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
						  lcid,
						  rgdispid);}
	STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
						pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemPrivilege methods

	HRESULT STDMETHODCALLTYPE get_IsEnabled 
	(
		/* [out] */ VARIANT_BOOL *bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE put_IsEnabled
	(
		/* [in] */ VARIANT_BOOL bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE get_Name 
	(
		/* [out] */ BSTR *bsName
	);

	HRESULT STDMETHODCALLTYPE get_DisplayName 
	(
		/* [out] */ BSTR *bsDisplayName
	);

	HRESULT STDMETHODCALLTYPE get_Identifier 
	(
		/* [out] */ WbemPrivilegeEnum *iPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// CSWbemPrivilege methods
	void	GetLUID (PLUID pLuid);

	static	TCHAR	*GetNameFromId (WbemPrivilegeEnum iPrivilege);
	static	OLECHAR *GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege);
	static	bool GetIdFromMonikerName (OLECHAR *name, WbemPrivilegeEnum &iPrivilege);
	static	bool GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege);
};

typedef map< WbemPrivilegeEnum,CSWbemPrivilege*,less<int> > PrivilegeMap;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilegeSet interface.  
//
//***************************************************************************

class CSWbemPrivilegeSet : public ISWbemPrivilegeSet,
						   public ISupportErrorInfo,
						   public IProvideClassInfo
{
friend CEnumPrivilegeSet;
friend CSWbemSecurity;

private:
	bool			m_bMutable;
	CDispatchHelp	m_Dispatch;
	PrivilegeMap	m_PrivilegeMap;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemPrivilegeSet ();
	CSWbemPrivilegeSet (const CSWbemPrivilegeSet &privSet,
						bool bMutable = true);
	CSWbemPrivilegeSet (ISWbemPrivilegeSet *pISWbemPrivilegeSet);
    virtual ~CSWbemPrivilegeSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	WbemPrivilegeEnum privilege,
        /*[out]*/	ISWbemPrivilege **ppPrivilege
    );        

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[in]*/	long *plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
		/*[in]*/	WbemPrivilegeEnum privilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	HRESULT STDMETHODCALLTYPE Remove 
	(
		/*[in]*/	WbemPrivilegeEnum privilege
	);

	
    // CSWbemPrivilegeSet methods

    HRESULT STDMETHODCALLTYPE DeleteAll
	(
    );

	HRESULT STDMETHODCALLTYPE AddAsString
	(
		/*[in]*/	BSTR strPrivilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
	ULONG			GetNumberOfDisabledElements ();

	PrivilegeMap	&GetPrivilegeMap ()
	{
		return m_PrivilegeMap;
	}

	void			Reset (CSWbemPrivilegeSet &privSet);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for Privilege collections.  
//
//***************************************************************************

class CEnumPrivilegeSet : public IEnumVARIANT
{
private:
	long					m_cRef;
	CSWbemPrivilegeSet		*m_pPrivilegeSet;
	PrivilegeMap::iterator	m_Iterator;

public:
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet);
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet, 
				PrivilegeMap::iterator iterator);

	virtual ~CEnumPrivilegeSet (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\privilege.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.CPP
//
//  alanbos  30-Sep-98   Created.
//
//  Defines the implementation of CSWbemPrivilege
//
//***************************************************************************

#include "precomp.h"

#ifndef _UNICODE
#include <mbstring.h>
#endif

typedef struct PrivilegeDef {
	WbemPrivilegeEnum	privilege;
	TCHAR				*tName;
	OLECHAR				*monikerName;
} PrivilegeDef;

#define WBEMS_MAX_NUM_PRIVILEGE	27

static PrivilegeDef s_privilegeDefMap [WBEMS_MAX_NUM_PRIVILEGE] = {
	{ wbemPrivilegeCreateToken, SE_CREATE_TOKEN_NAME, L"CreateToken" },
	{ wbemPrivilegePrimaryToken, SE_ASSIGNPRIMARYTOKEN_NAME, L"PrimaryToken" },
	{ wbemPrivilegeLockMemory, SE_LOCK_MEMORY_NAME, L"LockMemory" },
	{ wbemPrivilegeIncreaseQuota, SE_INCREASE_QUOTA_NAME, L"IncreaseQuota" },
	{ wbemPrivilegeMachineAccount, SE_MACHINE_ACCOUNT_NAME, L"MachineAccount" },
	{ wbemPrivilegeTcb, SE_TCB_NAME, L"Tcb" },
	{ wbemPrivilegeSecurity, SE_SECURITY_NAME, L"Security" },
	{ wbemPrivilegeTakeOwnership, SE_TAKE_OWNERSHIP_NAME, L"TakeOwnership" },
	{ wbemPrivilegeLoadDriver, SE_LOAD_DRIVER_NAME, L"LoadDriver" },
	{ wbemPrivilegeSystemProfile, SE_SYSTEM_PROFILE_NAME, L"SystemProfile" },
	{ wbemPrivilegeSystemtime, SE_SYSTEMTIME_NAME, L"SystemTime" },
	{ wbemPrivilegeProfileSingleProcess, SE_PROF_SINGLE_PROCESS_NAME, L"ProfileSingleProcess" },
	{ wbemPrivilegeIncreaseBasePriority, SE_INC_BASE_PRIORITY_NAME, L"IncreaseBasePriority" },
	{ wbemPrivilegeCreatePagefile, SE_CREATE_PAGEFILE_NAME, L"CreatePagefile" },
	{ wbemPrivilegeCreatePermanent, SE_CREATE_PERMANENT_NAME, L"CreatePermanent" },
	{ wbemPrivilegeBackup, SE_BACKUP_NAME, L"Backup" },
	{ wbemPrivilegeRestore, SE_RESTORE_NAME, L"Restore" },
	{ wbemPrivilegeShutdown, SE_SHUTDOWN_NAME, L"Shutdown" },
	{ wbemPrivilegeDebug, SE_DEBUG_NAME, L"Debug" },
	{ wbemPrivilegeAudit, SE_AUDIT_NAME, L"Audit" },
	{ wbemPrivilegeSystemEnvironment, SE_SYSTEM_ENVIRONMENT_NAME, L"SystemEnvironment" },
	{ wbemPrivilegeChangeNotify, SE_CHANGE_NOTIFY_NAME, L"ChangeNotify" },
	{ wbemPrivilegeRemoteShutdown, SE_REMOTE_SHUTDOWN_NAME, L"RemoteShutdown" },
	{ wbemPrivilegeUndock, SE_UNDOCK_NAME, L"Undock" },
	{ wbemPrivilegeSyncAgent, SE_SYNC_AGENT_NAME, L"SyncAgent" },
	{ wbemPrivilegeEnableDelegation, SE_ENABLE_DELEGATION_NAME, L"EnableDelegation" },
	{ wbemPrivilegeManageVolume, SE_MANAGE_VOLUME_NAME, L"ManageVolume" }
};

TCHAR *CSWbemPrivilege::GetNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].tName : NULL;
}

OLECHAR *CSWbemPrivilege::GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].monikerName : NULL;
}

bool CSWbemPrivilege::GetIdFromMonikerName (OLECHAR *pName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (pName)
	{
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsnicmp (pName, s_privilegeDefMap [i].monikerName,
								wcslen (s_privilegeDefMap [i].monikerName)))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
	}

	return status;
}

bool CSWbemPrivilege::GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (bsName)
	{
#ifdef _UNICODE
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsicmp (bsName, s_privilegeDefMap [i].tName))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
#else
		// Convert bsName to a multibyte string
		size_t mbsNameLen = wcstombs (NULL, bsName, 0);
		char *mbsName = new char [mbsNameLen + 1];

		if (mbsName)
		{
			wcstombs (mbsName, bsName, mbsNameLen);
			mbsName [mbsNameLen] = NULL;

			for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
			{
				if (0 == _mbsicmp ((unsigned char *)mbsName, (unsigned char *)(s_privilegeDefMap [i].tName)))
				{
					// Success 
					iPrivilege = s_privilegeDefMap [i].privilege;
					status = true;
					break;
				}
			}

			delete [] mbsName;
		}
#endif
	}

	return status;
}

//***************************************************************************
//
// CSWbemPrivilege::CSWbemPrivilege
//
// CONSTRUCTOR 
//
//***************************************************************************

CSWbemPrivilege::CSWbemPrivilege (
	WbemPrivilegeEnum iPrivilege,
	LUID &luid, 
	bool bIsEnabled
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilege, 
						CLSID_SWbemPrivilege, L"SWbemPrivilege");
	m_cRef=1;

	m_privilege = iPrivilege;
	m_Luid = luid;
	m_bIsEnabled = bIsEnabled;

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemPrivilege::~CSWbemPrivilege
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemPrivilege::~CSWbemPrivilege (void)
{
	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilege::QueryInterface
// long CSWbemPrivilege::AddRef
// long CSWbemPrivilege::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilege==riid)
		*ppv = (ISWbemPrivilege *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilege::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilege == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Identifier
//
//  DESCRIPTION:
//
//  Retrieve the privilege identifier 
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Identifier (
	WbemPrivilegeEnum *pPrivilege
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pPrivilege = m_privilege;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_IsEnabled
//
//  DESCRIPTION:
//
//  Retrieve the override state
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_IsEnabled (
	VARIANT_BOOL *pIsEnabled
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pIsEnabled)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pIsEnabled = (m_bIsEnabled) ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::put_IsEnabled
//
//  DESCRIPTION:
//
//  Set the override state
//
//  PARAMETERS:
//
//		bIsEnabled		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::put_IsEnabled (
	VARIANT_BOOL bIsEnabled
)
{
	m_bIsEnabled = (bIsEnabled) ? true : false;
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the privilege name
//
//  PARAMETERS:
//
//		pName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{
			// Have a valid name - now copy it to a BSTR
			
#ifdef _UNICODE
			if (*pName = SysAllocString (tName))
				hr = WBEM_S_NO_ERROR;
			else
				hr = WBEM_E_OUT_OF_MEMORY;
#else
			size_t tNameLen = strlen (tName);
			OLECHAR *nameW = new OLECHAR [tNameLen + 1];

			if (nameW)
			{
				mbstowcs (nameW, tName, tNameLen);
				nameW [tNameLen] = NULL;
				*pName = SysAllocString (nameW);
				delete [] nameW;
				hr = WBEM_S_NO_ERROR;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
#endif
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_DisplayName
//
//  DESCRIPTION:
//
//  Retrieve the privilege display name
//
//  PARAMETERS:
//
//		pDisplayName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_DisplayName (
	BSTR *pDisplayName
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pDisplayName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{	
			CSWbemSecurity::LookupPrivilegeDisplayName (tName, pDisplayName);
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


void CSWbemPrivilege::GetLUID (PLUID pLuid)
{
	if (pLuid)
		*pLuid = m_Luid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\propvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines implementation of IEnumVARIANT for iterators of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CPropSetEnumVar::CPropSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CPropSetEnumVar::CPropSetEnumVar(CSWbemPropertySet *pPropSet,
								 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pPropertySet = pPropSet;
	m_pPropertySet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CPropSetEnumVar::~CPropSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CPropSetEnumVar::~CPropSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pPropertySet)
		m_pPropertySet->Release ();
}

//***************************************************************************
// HRESULT CPropSetEnumVar::QueryInterface
// long CPropSetEnumVar::AddRef
// long CPropSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CPropSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CPropSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CPropSetEnumVar::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CPropSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CPropSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pPropertySet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemProperty *pProperty = NULL;
					
					if (SUCCEEDED(hRes2 = m_pPropertySet->Next (0, &pProperty)))
					{
						if (NULL == pProperty)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pProperty;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CPropSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pPropertySet)
		{
			CPropSetEnumVar *pEnum = new CPropSetEnumVar (m_pPropertySet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CPropSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pPropertySet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CPropSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CPropSetEnumVar::SeekCurrentPosition ()
{
	ISWbemProperty *pDummyObject = NULL;
	m_pPropertySet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pPropertySet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\propset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemPropertySet::CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemPropertySet::CSWbemPropertySet(
	CSWbemServices *pService, 
	CSWbemObject *pObject,
	bool bSystemProperties) :
		m_bSystemProperties (bSystemProperties)
{
	m_Dispatch.SetObj (this, IID_ISWbemPropertySet, 
					CLSID_SWbemPropertySet, L"SWbemPropertySet");
	m_pSWbemObject = pObject;
	m_pSWbemObject->AddRef ();
	m_pIWbemClassObject = m_pSWbemObject->GetIWbemClassObject ();

	m_pSite = new CWbemObjectSite (m_pSWbemObject);

	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_cRef=1;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemPropertySet::~CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemPropertySet::~CSWbemPropertySet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemObject)
		m_pSWbemObject->Release ();

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->EndEnumeration ();
		m_pIWbemClassObject->Release ();
	}

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_pSite)
		m_pSite->Release ();
}

//***************************************************************************
// HRESULT CSWbemPropertySet::QueryInterface
// long CSWbemPropertySet::AddRef
// long CSWbemPropertySet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPropertySet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPropertySet==riid)
		*ppv = (ISWbemPropertySet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPropertySet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemPropertySet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPropertySet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPropertySet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPropertySet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Item
//
//  DESCRIPTION:
//
//  Get a property
//
//  PARAMETERS:
//
//		bsName			The name of the property
//		lFlags			Flags
//		ppProp			On successful return addresses the ISWbemProperty
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemPropertySet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemProperty ** ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppProp)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			long flavor = 0; 

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get (bsName, lFlags, NULL, NULL, &flavor)))
			{
				// First we check if this is a system property.

				if (((WBEM_FLAVOR_ORIGIN_SYSTEM == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) && m_bSystemProperties) ||
					((WBEM_FLAVOR_ORIGIN_SYSTEM != (flavor & WBEM_FLAVOR_MASK_ORIGIN)) && !m_bSystemProperties))
				{
						if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
							hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
					hr = WBEM_E_NOT_FOUND;
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Add
//
//  DESCRIPTION:
//
//  Add a property.		Note that the property is created with a NULL value.
//						If a non-NULL value is required, SetValue should
//						be called on the returned ISWbemProperty.
//
//  PARAMETERS:
//
//		bsName			The name of the property
//		cimType			The CIMTYPE (only needed for new properties, o/w
//						should be CIM_EMPTY).
//		flavor			Flavor
//
//  RETURN VALUES:
//	
//		The new property (if successful)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Add (
	BSTR bsName,
	WbemCimtypeEnum cimType,
	VARIANT_BOOL	bIsArray,
	long lFlags,
	ISWbemProperty **ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppProp) || (NULL == bsName))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			/*
			 * If we are a system property collection we 
			 * check if the name begins "__"
			 */
			if (!m_bSystemProperties || (0 == _wcsnicmp (L"__", bsName, 2)))
			{
				/*
				 * Create the property with the required cimtype and no value.
				 */

				CIMTYPE cimomType = (CIMTYPE) cimType;

				if (bIsArray)
					cimomType |= CIM_FLAG_ARRAY;

				if (SUCCEEDED(hr = m_pIWbemClassObject->Put (bsName, 0, NULL, cimomType)))
				{
					if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
						hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Remove
//
//  DESCRIPTION:
//
//  Delete a property
//
//  PARAMETERS:
//
//		bsName			The name of the property
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == bsName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		if (m_pIWbemClassObject)
			hr = m_pIWbemClassObject->Delete (bsName);

		// Translate default reset case to an error
		if (WBEM_S_RESET_TO_DEFAULT == hr)
			hr = wbemErrResetToDefault;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	if (SUCCEEDED(hr) || (wbemErrResetToDefault == hr))
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the properties
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::BeginEnumeration ()
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	/*
	 * Note that we do not expose system properties through this
	 * API via the property set, so we supress them here.
	 */

	if (m_pIWbemClassObject)
	{
		hr = m_pIWbemClassObject->EndEnumeration ();
		hr = m_pIWbemClassObject->BeginEnumeration (m_bSystemProperties ?
						WBEM_FLAG_SYSTEM_ONLY : WBEM_FLAG_NONSYSTEM_ONLY);
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Next
//
//  DESCRIPTION:
//
//  Get next property in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppProp		Next property (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Next (
	long lFlags,
	ISWbemProperty ** ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppProp)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			BSTR bsName = NULL;
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Next (lFlags, &bsName, NULL, NULL, NULL)))
			{
				if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;

				SysFreeString (bsName);
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CPropSetEnumVar *pEnum = new CPropSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemPropertySet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_pIWbemClassObject)
		{
			if (m_bSystemProperties)
			{
				// Rats - have to enumerate
				SAFEARRAY	*pArray = NULL;

				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->GetNames (NULL,
										WBEM_FLAG_SYSTEM_ONLY, NULL, &pArray))
				{
					long lUBound = 0, lLBound = 0;
					SafeArrayGetUBound (pArray, 1, &lUBound);
					SafeArrayGetLBound (pArray, 1, &lLBound);
					*plCount = lUBound - lLBound + 1;
					SafeArrayDestroy (pArray);
					hr = S_OK;
				}
			}
			else
			{
				// S'easy - just use __PROPERTY_COUNT
				VARIANT var;
				VariantInit (&var);
				BSTR propCount = SysAllocString (OLESTR("__PROPERTY_COUNT"));
				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (propCount, 0, &var, NULL, NULL))
				{
					*plCount = var.lVal;
					hr = S_OK;
				}

				VariantClear (&var);
				SysFreeString (propCount);
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::CPropertySetDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::CPropertySetDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a property (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemPropertySet *pPropertySet = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemPropertySet, (PPVOID) &pPropertySet)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);

			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);

				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemProperty *pProperty = NULL;

						if (SUCCEEDED (pPropertySet->Item (V_BSTR(&nameVar), 0, &pProperty)))
						{
							// Try and put the value
							if (SUCCEEDED (pProperty->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pProperty->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pPropertySet->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\property.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  PROPERTY.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemProperty
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemProperty::CSWbemProperty
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemProperty::CSWbemProperty(
	CSWbemServices *pService,
	ISWbemInternalObject *pSWbemObject,
	BSTR name) 
{
	m_Dispatch.SetObj (this, IID_ISWbemProperty, 
					CLSID_SWbemProperty, L"SWbemProperty");
    m_cRef=1;

	m_pSWbemObject = pSWbemObject;
	m_pSWbemObject->AddRef ();
	m_pSWbemObject->GetIWbemClassObject (&m_pIWbemClassObject);

	m_pSite = new CWbemObjectSite (m_pSWbemObject);

	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemProperty::~CSWbemProperty
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemProperty::~CSWbemProperty(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemObject)
		m_pSWbemObject->Release ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_pSite)
		m_pSite->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemProperty::QueryInterface
// long CSWbemProperty::AddRef
// long CSWbemProperty::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProperty::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemProperty==riid)
		*ppv = (ISWbemProperty *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemProperty::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemProperty::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemProperty::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProperty::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemProperty == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the property value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		VariantClear (pValue);

		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get 
						(m_name, 0, &var, NULL, NULL)))
			{
				MapFromCIMOMObject(m_pSWbemServices, &var, 
									m_pSWbemObject, m_name);

				if(var.vt & VT_ARRAY)
				{
					hr = ConvertArrayRev(pValue, &var);
				}
				else
				{
					hr = VariantCopy (pValue, &var);
				}

				VariantClear(&var);
			}		
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::put_Value
//
//  DESCRIPTION:
//
//  Set the property value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	/*
	 * We can only _change_ the value, not the type.  When dealing with
	 * CIMOM interfaces 2 golden rules must be obeyed.
	 * (1) For instance-level Put's, you can specify the CIMTYPE (provided
	 *     you get it right), but can also specify 0.
	 * (2) For class-level Put's, always specify the CIMTYPE
	 */

	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType = CIM_EMPTY;

		if (SUCCEEDED(hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL)))
		{
			VARIANT vWMI;
			VariantInit (&vWMI);

			if (SUCCEEDED(WmiVariantChangeType(vWMI, pVal, cimType)))
				hr = m_pIWbemClassObject->Put (m_name, 0, &vWMI, cimType);

			VariantClear (&vWMI);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Did we save an embedded object value?  If so make sure the
		// site is correctly set to this property.
		SetSite (pVal, m_pSWbemObject, m_name);

		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}


	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the property name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_CIMType
//
//  DESCRIPTION:
//
//  Retrieve the property base CIM type (i.e. without the array type)
//
//  PARAMETERS:
//
//		pType		holds the type on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_CIMType (
	WbemCimtypeEnum *pType
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pType)
		return WBEM_E_INVALID_PARAMETER;

	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType;
		hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
		*pType = (WbemCimtypeEnum)(cimType & ~CIM_FLAG_ARRAY);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_IsArray
//
//  DESCRIPTION:
//
//  Retrieve whether the property is an array type
//
//  PARAMETERS:
//
//		pIsArray		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_IsArray (
	VARIANT_BOOL *pIsArray
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pIsArray)
		return WBEM_E_INVALID_PARAMETER;

	*pIsArray = FALSE;

	if (m_pIWbemClassObject)
	{
		CIMTYPE	cimType = CIM_EMPTY;
		hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
		*pIsArray = (0 != (cimType & CIM_FLAG_ARRAY)) 
				? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_IsLocal
//
//  DESCRIPTION:
//
//  Retrieve the property flavor
//
//  PARAMETERS:
//
//		pFlavor		holds the flavor on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_IsLocal (
	VARIANT_BOOL *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemClassObject)
		{
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get (m_name, 0, NULL, NULL, &flavor)))
				*pValue = (WBEM_FLAVOR_ORIGIN_LOCAL == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) ?
						VARIANT_TRUE : VARIANT_FALSE;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Origin
//
//  DESCRIPTION:
//
//  Retrieve the property origin
//
//  PARAMETERS:
//
//		pOrigin		holds the origin class on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Origin (
	BSTR *pOrigin
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pOrigin)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		if (m_pIWbemClassObject)
			m_pIWbemClassObject->GetPropertyOrigin (m_name, pOrigin);

		if (NULL == *pOrigin)
			*pOrigin = SysAllocString (OLESTR(""));
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Qualifiers_
//
//  DESCRIPTION:
//
//  Retrieve the property qualifier set
//
//  PARAMETERS:
//
//		ppQualSet		addresses the qualifier set on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet	
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppQualSet = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemQualifierSet *pQualSet = NULL;

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetPropertyQualifierSet 
										(m_name, &pQualSet)))
			{
				if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet, m_pSWbemObject)))
					hr = WBEM_E_OUT_OF_MEMORY;

				pQualSet->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}



//***************************************************************************
//
//  SCODE CSWbemProperty::UpdateEmbedded
//
//  DESCRIPTION:
//
//  Given a variant representing an embedded value, set the value
//	and update the parent object.
//
//  PARAMETERS:
//
//		var		embedded value (VT_UNKNOWN)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

void CSWbemProperty::UpdateEmbedded (VARIANT &vNewVal, long index)
{
	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType = CIM_EMPTY;

		if (-1 == index)
		{
			m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
			m_pIWbemClassObject->Put (m_name, 0, &vNewVal, cimType);
		}
		else
		{
			VARIANT vPropVal;
			VariantInit(&vPropVal);
							
			if (SUCCEEDED (m_pIWbemClassObject->Get (m_name, 0, &vPropVal, &cimType, NULL)) 
					&& ((VT_UNKNOWN|VT_ARRAY) == V_VT(&vPropVal)))
			{

				// Set the value into the relevant index of the property value array
				if (S_OK == SafeArrayPutElement (vPropVal.parray, &index, V_UNKNOWN(&vNewVal)))
				{
					// Set the entire property value
					m_pIWbemClassObject->Put (m_name, 0, &vPropVal, cimType);
				}
			}

			VariantClear (&vPropVal);
		}
	}
}

void CSWbemProperty::UpdateSite ()
{
	// Update the parent site if it exists
	if (m_pSite)
		m_pSite->Update ();
}


//***************************************************************************
//
//  SCODE CSWbemProperty::CPropertyDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::CPropertyDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		/*
		 * We are looking for calls on the default member (the Value property) which
		 * supplied an argument.  Since the Value property is of type VARIANT, this may
		 * be legal but undetectable by the standard Dispatch mechanism, because in the
		 * the case that the property happens to be an array type, it is meaningful to
		 * pass an index (the interpretation is that the index specifies an offset in
		 * the VT_ARRAY|VT_VARIANT structure that represents the property value).
		 */
			
		WbemCimtypeEnum cimtype;
		VARIANT_BOOL isArray = FALSE;
		ISWbemProperty *pProperty = NULL;

		// This tells use where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemProperty, (PPVOID) &pProperty)))
		{
			if (SUCCEEDED(pProperty->get_CIMType (&cimtype)) &&
				SUCCEEDED(pProperty->get_IsArray (&isArray)) && (isArray))
			{
				// Extract the current property value
				VARIANT vPropVal;
				VariantInit(&vPropVal);
						
				if (SUCCEEDED (pProperty->get_Value (&vPropVal)) && V_ISARRAY(&vPropVal))
				{
					VARIANT indexVar;
					VariantInit (&indexVar);

					// Attempt to coerce the index argument into a value suitable for an array index
					if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
					{
						long lArrayPropInx = V_I4(&indexVar);

						// Is this a Get? There should be one argument (the array index)
						if (DISPATCH_PROPERTYGET & wFlags)
						{
							if (1 == pdispparams->cArgs)
							{
								// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
								// VARIANT element we require

								VariantInit (pvarResult);
								hr = SafeArrayGetElement (vPropVal.parray, &lArrayPropInx, pvarResult);
							}
							else
								hr = DISP_E_BADPARAMCOUNT;
						}
						else if (DISPATCH_PROPERTYPUT & wFlags) 
						{
							if (2 == pdispparams->cArgs)
							{
								/*
								 * Try to interpret this as an array member set operation. For
								 * this the first argument passed is the new value, and the second
								 * is the array index.
								 */
							
								VARIANT vNewVal;
								VariantInit(&vNewVal);

								if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
								{
									// Coerce the value if necessary (unless it's embedded)
									
									if ((wbemCimtypeObject == cimtype) ||
										(S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, CimTypeToVtType (cimtype))))
									{
										// Check the index is not out of bounds and, if it is, grow
										// the array accordingly
										CheckArrayBounds (vPropVal.parray, lArrayPropInx);

										// Set the value into the relevant index of the property value array
										if (S_OK == (hr = 
											SafeArrayPutElement (vPropVal.parray, &lArrayPropInx, &vNewVal)))
										{
											// Set the entire property value
											if (SUCCEEDED (pProperty->put_Value (&vPropVal)))
											{
												hr = S_OK;
												// Upcast is OK here because m_pObj is really a (CSWbemProperty*)
												CSWbemProperty *pSProperty = (CSWbemProperty *)m_pObj;

												// Did we save an embedded object value?  If so make sure the
												// site is correctly set to this property.
												SetSite (&pdispparams->rgvarg[0], 
															pSProperty->m_pSWbemObject, pSProperty->m_name,
															lArrayPropInx);

												// Propagate the change to the owning site
												pSProperty->UpdateSite ();
											}
											else
											{
												hr = DISP_E_TYPEMISMATCH;
												if (puArgErr)
													*puArgErr = 0;
											}
										}
									}
									else
									{
										hr = DISP_E_TYPEMISMATCH;
										if (puArgErr)
											*puArgErr = 0;
									}
									
									VariantClear (&vNewVal);
								}
							}
							else 
								hr = DISP_E_BADPARAMCOUNT;
						}
					}
					else
					{
							hr = DISP_E_TYPEMISMATCH;
							if (puArgErr)
								*puArgErr = indexArg;
					}

					VariantClear (&indexVar);
				}	

				VariantClear (&vPropVal);
			}

			pProperty->Release ();
		}
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\property.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  property.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemProperty and CSWbemPropertySet definitions.
//
//***************************************************************************

#ifndef _PROPERTY_H_
#define _PROPERTY_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemProperty
//
//  DESCRIPTION:
//
//  Implements the ISWbemProperty interface.  
//
//***************************************************************************

class CSWbemProperty : public ISWbemProperty,
					   public ISupportErrorInfo,
					   public IProvideClassInfo
{
private:
	class CPropertyDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags
					)
			{
				return false;
			}
	};

friend CPropertyDispatchHelp;

	CSWbemServices*			m_pSWbemServices;
	ISWbemInternalObject*	m_pSWbemObject;
	IWbemClassObject		*m_pIWbemClassObject;
	CPropertyDispatchHelp	m_Dispatch;
	BSTR					m_name;
	CWbemSite				*m_pSite;

	HRESULT					DeleteValuesByHand (
								VARIANT & varMatchingValues,
								long iFlags,
								long iStartIndex,
								long iEndIndex 
								);

	HRESULT					AddValuesByHand (
								VARIANT & varValues,
								long iFlags, 
								long iStartIndex 
								);	

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemProperty (CSWbemServices *pService, ISWbemInternalObject *pObject, 
					BSTR name);
    ~CSWbemProperty (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemProperty methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_IsLocal
	(
		/*[out]*/	VARIANT_BOOL *local
	);

	HRESULT STDMETHODCALLTYPE get_Origin
	(
		/*[out]*/	BSTR *origin
	);
	
	HRESULT STDMETHODCALLTYPE get_CIMType
	(
		/*[out]*/	WbemCimtypeEnum *cimType
	);
	
	HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
		/*[out]*/	ISWbemQualifierSet **ppQualSet
	);

	HRESULT STDMETHODCALLTYPE get_IsArray
	(
		/*[out]*/	VARIANT_BOOL *pIsArray
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other Methods
	void	UpdateEmbedded (VARIANT &var, long index);
	void	UpdateSite ();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Implements the ISWbemPropertySet interface.  
//
//***************************************************************************

class CSWbemPropertySet : public ISWbemPropertySet,
						  public ISupportErrorInfo,
						  public IProvideClassInfo
{
private:
	class CPropertySetDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	CSWbemServices*				m_pSWbemServices;
	CSWbemObject*				m_pSWbemObject;
	IWbemClassObject*			m_pIWbemClassObject;			
	CPropertySetDispatchHelp	m_Dispatch;
	CWbemSite					*m_pSite;
	bool						m_bSystemProperties;

	
protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemPropertySet (CSWbemServices *pService, CSWbemObject *pObject,
						bool bSystemProperties = false);
    ~CSWbemPropertySet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR name,
		/*[in]*/	WbemCimtypeEnum cimType,
		/*[in]*/	VARIANT_BOOL isArray,
		/*[in]*/	long lFlags,
		/*[out]*/	ISWbemProperty **ppProperty
	);        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemProperty **ppProperty
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemPropertySet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemProperty **ppProperty
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\qualifier.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  QUALIFIER.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemQualifier
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemQualifier::CSWbemQualifier
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemQualifier::CSWbemQualifier(IWbemQualifierSet *pIWbemQualifierSet, BSTR name,
								 CWbemSite *pSite) :
					m_pSite (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemQualifier, 
					CLSID_SWbemQualifier, L"SWbemQualifier");
    m_cRef=1;
	m_pIWbemQualifierSet = pIWbemQualifierSet;
	m_pIWbemQualifierSet->AddRef ();

	if (pSite)
	{
		m_pSite = pSite;
		m_pSite->AddRef ();
	}

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemQualifier::~CSWbemQualifier
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemQualifier::~CSWbemQualifier(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemQualifierSet)
		m_pIWbemQualifierSet->Release ();

	if (m_pSite)
		m_pSite->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemQualifier::QueryInterface
// long CSWbemQualifier::AddRef
// long CSWbemQualifier::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifier::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemQualifier==riid)
		*ppv = (ISWbemQualifier *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemQualifier::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemQualifier::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemQualifier::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifier::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemQualifier == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the qualifier value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();
	
	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		VariantClear (pValue);

		if (m_pIWbemQualifierSet)
		{
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get 
										(m_name, 0, &var, NULL)))
			{	
				if(var.vt & VT_ARRAY)
					hr = ConvertArrayRev(pValue, &var);
				else
					hr = VariantCopy (pValue, &var);
			}

			VariantClear(&var);
		}		
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_Value
//
//  DESCRIPTION:
//
//  Set the qualifier value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pVal)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		/*
		 * We can only change the value, not the flavor.  We have to read the
		 * flavor first to avoid changing it.
		 */
		if (m_pIWbemQualifierSet)
		{
			long flavor = 0;
			VARIANT curValue;
			VariantInit (&curValue);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &curValue, &flavor)))
			{
				// Mask out the origin bits from the flavor as those are read-only
				flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

				// Make sure we have a decent qualifier value to use
				if(((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
				   ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
				{
					VARIANT vTemp;
					VariantInit (&vTemp);

					if (S_OK == ConvertArray(&vTemp, pVal, true, curValue.vt & ~VT_ARRAY))
						hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);
					
					VariantClear (&vTemp); 
				}
				else if ((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal)))
				{
					// Could be a JScript IDispatchEx array
					VARIANT vTemp;
					VariantInit (&vTemp);

					if (S_OK == ConvertDispatchToArray (&vTemp, pVal, CIM_ILLEGAL, true,
														curValue.vt & ~VT_ARRAY))
						hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);

					VariantClear (&vTemp);
				}
				else
				{
					// Only certain types, I4, R8, BOOL and BSTR are acceptable qualifier
					// values.  Convert the data if need be

					VARTYPE vtOK = GetAcceptableQualType(V_VT(pVal));

					if(vtOK != V_VT(pVal))
					{
						VARIANT vTemp;
						VariantInit(&vTemp);

						if (S_OK == QualifierVariantChangeType (&vTemp, pVal, vtOK))
							hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);

						VariantClear(&vTemp);
					}
					else
						hr = m_pIWbemQualifierSet->Put (m_name, pVal, flavor);
				}
			}

			VariantClear (&curValue);
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the qualifier name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;

	ResetLastErrors ();

	if (NULL != pName)
	{
		*pName = SysAllocString (m_name);
		hr = WBEM_S_NO_ERROR;
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsLocal
//
//  DESCRIPTION:
//
//  Determine whether the qualifier is local to this object
//
//  PARAMETERS:
//
//		pIsLocal		addresses whether the qualifier is local
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsLocal (
	VARIANT_BOOL *pIsLocal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pIsLocal)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pIsLocal = (WBEM_FLAVOR_ORIGIN_LOCAL == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) ?
						VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_PropagatesToSubclass
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be propagated to subclasses
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_PropagatesToSubclass (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS & (flavor & WBEM_FLAVOR_MASK_PROPAGATION))
							? VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_PropagatesToSubclass
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_PropagatesToSubclass (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
			else
				flavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_PropagatesToInstance
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be propagated to instances
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_PropagatesToInstance (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & (flavor & WBEM_FLAVOR_MASK_PROPAGATION))
								? VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_PropagatesToInstance
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_PropagatesToInstance (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
			else
				flavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsOverridable
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be overriden
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsOverridable (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_OVERRIDABLE == (flavor & WBEM_FLAVOR_MASK_PERMISSIONS))
								? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_IsOverridable
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_IsOverridable (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor &= ~WBEM_FLAVOR_NOT_OVERRIDABLE;
			else
				flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE ;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsAmended
//
//  DESCRIPTION:
//
//  Determine whether the qualifier value has been amended
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsAmended (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_AMENDED == (flavor & WBEM_FLAVOR_MASK_AMENDED))
								? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::CQualifierDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::CQualifierDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Value property) which
	 * supplied an argument.  Since the Value property is of type VARIANT, this may
	 * be legal but undetectable by the standard Dispatch mechanism, because in the
	 * the case that the qualifier happens to be an array type, it is meaningful to
	 * pass an index (the interpretation is that the index specifies an offset in
	 * the VT_ARRAY|VT_VARIANT structure that represents the property value).
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		// Looks promising - get the object to try and resolve this
			
		ISWbemQualifier *pQualifier = NULL;

		// This tells use where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemQualifier, (PPVOID) &pQualifier)))
		{
			// Extract the current qualifier value
			VARIANT vQualVal;
			VariantInit (&vQualVal);

			if (SUCCEEDED(pQualifier->get_Value (&vQualVal)) && V_ISARRAY(&vQualVal))
			{
				VARIANT indexVar;
				VariantInit (&indexVar);

				// Attempt to coerce the index argument into a value suitable for an array index
				if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
				{
					long lArrayPropInx = V_I4(&indexVar);

					// Is this a Get? There should be one argument (the array index)
					if (DISPATCH_PROPERTYGET & wFlags)
					{
						if (1 == pdispparams->cArgs)
						{
							// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
							// VARIANT

							VariantInit (pvarResult);
							hr = SafeArrayGetElement (vQualVal.parray, &lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_BADPARAMCOUNT;
					}
					else if (DISPATCH_PROPERTYPUT & wFlags) 
					{
						if (2 == pdispparams->cArgs)
						{
							/*
							 * Try to interpret this as an array member set operation. For
							 * this the first argument passed is the new value, and the second
							 * is the array index.
							 */
						
							VARIANT vNewVal;
							VariantInit(&vNewVal);
							
							if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
							{
								// Coerce the value if necessary
								VARTYPE expectedVarType = GetAcceptableQualType (V_VT(&vNewVal));

								if (S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, expectedVarType))
								{
									// Check the index is not out of bounds and, if it is, grow
									// the array accordingly
									CheckArrayBounds (vQualVal.parray, lArrayPropInx);

									// Set the value into the relevant index of the property value array
									if (S_OK == (hr = 
										SafeArrayPutElement (vQualVal.parray, &lArrayPropInx, &vNewVal)))
									{
										// Set the entire property value
										if (SUCCEEDED (pQualifier->put_Value (&vQualVal)))
											hr = S_OK;
										else
										{
											hr = DISP_E_TYPEMISMATCH;
											if (puArgErr)
												*puArgErr = 0;
										}
									}
								}
								else
								{
									hr = DISP_E_TYPEMISMATCH;
									if (puArgErr)
										*puArgErr = 0;
								}
								
								VariantClear (&vNewVal);
							}
						}
						else 
							hr = DISP_E_BADPARAMCOUNT;
					}
				}
				else
				{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = indexArg;
				}

				VariantClear (&indexVar);
			}	

			VariantClear (&vQualVal);
		}

		pQualifier->Release ();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pxycache.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  pxycache.h
//
//  alanbos  22-Sep-98   Created.
//
//  Definition of proxy cache class
//
//***************************************************************************

#ifndef _PXYCACHE_H_
#define _PXYCACHE_H_

#define WBEMS_MAX_AUTHN_LEVEL	6
#define WBEMS_MIN_AUTHN_LEVEL	0
#define WBEMS_MAX_IMP_LEVEL		4
#define WBEMS_MIN_IMP_LEVEL		1

class CWbemLocatorSecurity;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemProxyCache
//
//  DESCRIPTION:
//
//  A proxy cache for remoted CIMOM interfaces  
//
//***************************************************************************

class CSWbemProxyCache : public IUnknown
{
private:
	long				m_cRef;  //Object reference count
	CRITICAL_SECTION	m_cs;

	// Array of proxies
	IUnknown		*pUnkArray [WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL] 
							   [WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL];

	// Security data
	COAUTHIDENTITY				*m_pCoAuthIdentity;
	BSTR						m_bsPrincipal;
	BSTR						m_bsAuthority;
	BSTR						m_bsUser;
	BSTR						m_bsPassword;
	bool						m_bUseDefaultInfo;
	bool						m_bUsingExplicitUserName;

	WbemAuthenticationLevelEnum	m_dwInitialAuthnLevel;
	WbemImpersonationLevelEnum	m_dwInitialImpLevel;

	void	InitializeCache (IUnknown *pUnk, ISWbemSecurity *pSecurity = NULL,
					bool bPropagateAuthentication = true,
					bool bPropagateImpersonation = true);

	static bool	DetermineBlanketOptions (IUnknown *pUnk);

	DWORD	GetCapabilities ();
	void	ClearCredentials ();
	void	InitializeMembers (IUnknown *pUnk);

public:

	CSWbemProxyCache (IUnknown *pUnk, BSTR bsAuthority, BSTR bsUser,
						BSTR bsPassword, CWbemLocatorSecurity *pSecurity);
	CSWbemProxyCache (IUnknown *pUnk, COAUTHIDENTITY *pCoAuthIdentity,
						BSTR bsPrincipal, BSTR bsAuthority);
	CSWbemProxyCache (IUnknown *pUnk, CSWbemSecurity *pSecurity);
	
	virtual ~CSWbemProxyCache ();

	//Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


	// Other methods
	IUnknown	*GetProxy (WbemAuthenticationLevelEnum authnLevel,
							WbemImpersonationLevelEnum impLevel,
							bool forceResecure = false);

	void	SecureProxy (IUnknown *pUnk,
							WbemAuthenticationLevelEnum authnLevel,
							WbemImpersonationLevelEnum impLevel);

	WbemAuthenticationLevelEnum	GetInitialAuthnLevel () { return m_dwInitialAuthnLevel; }
	WbemImpersonationLevelEnum	GetInitialImpLevel () { return m_dwInitialImpLevel; }

	COAUTHIDENTITY *GetCoAuthIdentity ();
	BSTR			GetAuthority () { return m_bsAuthority; }
	BSTR			GetPrincipal () { return m_bsPrincipal; }
	bool			IsUsingExplicitUserName () { return m_bUsingExplicitUserName; }

	IUnknown *GetInitialProxy ()
	{
		return GetProxy (m_dwInitialAuthnLevel, m_dwInitialImpLevel);
	}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\pxycache.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PXYCACHE.CPP
//
//  alanbos  22-Sep-98   Created.
//
//  Defines the CSWbemProxyCache class
//
//***************************************************************************

#include "precomp.h"

// Need to try and figure out the domain
static BSTR BuildDomainUser (BSTR bsSimpleUser)
{
	BSTR bsDomainUser = NULL;
	HANDLE hToken = NULL;

	if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, TRUE, &hToken) ||
		OpenProcessToken (GetCurrentProcess (), TOKEN_READ, &hToken))
	{
		// Get the user sid
		TOKEN_USER tu;
		DWORD dwLen = 0;

		GetTokenInformation (hToken, TokenUser, &tu, sizeof(tu), &dwLen);

		if (0 < dwLen)
		{
			BYTE* pTemp = new BYTE[dwLen];

			if (pTemp)
			{
				DWORD dwRealLen = dwLen;

				if (GetTokenInformation (hToken, TokenUser, pTemp, dwRealLen, &dwLen))
				{
					PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;

					// Do the first lookup to get the buffer sizes required.
					DWORD  dwNameLen = 0;
					DWORD  dwDomainLen = 0;
					LPWSTR pUser = 0;
					LPWSTR pDomain = 0;
					SID_NAME_USE Use;

					LookupAccountSidW (NULL, pSid, pUser, &dwNameLen,
											pDomain, &dwDomainLen, &Use);

					DWORD dwLastErr = GetLastError();

					if (ERROR_INSUFFICIENT_BUFFER == dwLastErr)
					{
						// Allocate the required buffers and look them up again.
						pUser = new WCHAR [dwNameLen + 1];

						if (pUser)
						{
							pDomain = new WCHAR [dwDomainLen + wcslen (bsSimpleUser) + 2];

							if (pDomain)
							{
								if (LookupAccountSidW (NULL, pSid, pUser, &dwNameLen,
													pDomain, &dwDomainLen, &Use))
								{
									// Now get the domain out
									if (pDomain)
									{
										wcscat (pDomain, L"\\");
										wcscat (pDomain, bsSimpleUser);
										bsDomainUser = SysAllocString (pDomain);
									}
								}
								
								delete [] pDomain;
							}

							delete [] pUser;
						}
					}
    			}
				
				delete [] pTemp;
			}
		}
		
		CloseHandle(hToken);
	}

	return bsDomainUser;
}

//***************************************************************************
//
// CSWbemProxyCache::CSWbemProxyCache
//
// CONSTRUCTOR
//		Create a new proxy cache based on the supplied proxy and 
//		authentication parameters.
//
//***************************************************************************

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	BSTR bsAuthority,
	BSTR bsUser,
	BSTR bsPassword,
	CWbemLocatorSecurity *pLocatorSecurity) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);
	
/*
// Don't need this any more - the scenario this was fixing (see SMS Bug DB #53347) works in Whistler
// without this workaround. Also, this is causing Scripting to fail with UPN names since DetermineLoginTypeEx
// below doesn't recognize UPN user names.

	if (CSWbemSecurity::IsNT() && bsUser && (0 < wcslen (bsUser)))
	{
		// On NT make sure we have a valid domain name if one is not specified
		BSTR bsDomain = NULL;
		BSTR bsSimpleUser = NULL;
		BSTR bsPrincipalDummy = NULL;

		if (SUCCEEDED (DetermineLoginTypeEx (bsDomain, bsSimpleUser, bsPrincipalDummy,
											 bsAuthority, bsUser)))
		{
			if (!bsDomain || (0 == wcslen (bsDomain)))
				m_bsUser = BuildDomainUser (bsSimpleUser);
		}

		SysFreeString (bsPrincipalDummy);
        SysFreeString (bsSimpleUser);
		SysFreeString (bsDomain);
	}
*/

	// Unless we've already set this, do it now
	if (!m_bsUser)
		m_bsUser = SysAllocString (bsUser);

	m_bsAuthority = SysAllocString (bsAuthority);
	m_bsPassword = SysAllocString (bsPassword);

	m_bUsingExplicitUserName = m_bsUser && (0 < wcslen (m_bsUser));

	InitializeCache (pUnk, pLocatorSecurity,
			(pLocatorSecurity) && pLocatorSecurity->IsAuthenticationSet (),
			(pLocatorSecurity) && pLocatorSecurity->IsImpersonationSet ());
	
	// No longer need the credentials at this point - zap 'em
	ClearCredentials ();

	LeaveCriticalSection (&m_cs);
}

//***************************************************************************
//
// CSWbemProxyCache::CSWbemProxyCache
//
// CONSTRUCTOR
//		Create a new proxy cache based on the supplied proxy and 
//		authentication parameters.
//
//***************************************************************************

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);

	if (bsAuthority)
		m_bsAuthority = SysAllocString (bsAuthority);

	if (bsPrincipal)
		m_bsPrincipal = SysAllocString (bsPrincipal);

	if (pCoAuthIdentity)
		WbemAllocAuthIdentity (pCoAuthIdentity->User, pCoAuthIdentity->Password,
								pCoAuthIdentity->Domain, &m_pCoAuthIdentity);
	
	m_bUsingExplicitUserName = m_pCoAuthIdentity && m_pCoAuthIdentity->User &&
								(0 < wcslen (m_pCoAuthIdentity->User));

	InitializeCache (pUnk);
	
	LeaveCriticalSection (&m_cs);
}

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	CSWbemSecurity *pSecurity) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);	

	if (pSecurity)
	{
		m_pCoAuthIdentity = pSecurity->GetCoAuthIdentity ();
		m_bsPrincipal = SysAllocString (pSecurity->GetPrincipal ());
		m_bsAuthority = SysAllocString (pSecurity->GetAuthority ());
		m_bUsingExplicitUserName = pSecurity->IsUsingExplicitUserName ();
	}

	InitializeCache (pUnk, pSecurity);
	LeaveCriticalSection (&m_cs);
}

void CSWbemProxyCache::InitializeMembers (IUnknown *pUnk)
{
	m_cRef = 1;
	m_pCoAuthIdentity = NULL;
	m_bsPrincipal = NULL;
	m_bsAuthority = NULL;
	m_bsUser = NULL;
	m_bsPassword = NULL;
	m_bUsingExplicitUserName = false;
	m_bUseDefaultInfo = DetermineBlanketOptions (pUnk);
}

//***************************************************************************
//
// CSWbemProxyCache::~CSWbemProxyCache
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemProxyCache::~CSWbemProxyCache ()
{
	EnterCriticalSection (&m_cs);

	ClearCredentials ();

	if (m_bsAuthority)
		SysFreeString (m_bsAuthority);

	if (m_bsPrincipal)
		SysFreeString (m_bsPrincipal);

	if (m_pCoAuthIdentity)
	{
		WbemFreeAuthIdentity (m_pCoAuthIdentity);
		m_pCoAuthIdentity = NULL;
	}

	for (int i = 0; i < WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL; i++)
		for (int j = 0; j < WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL; j++)
			if (pUnkArray [i][j])
			{
				pUnkArray [i][j] -> Release ();
				pUnkArray [i] [j] = NULL;
			}
	
	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
// HRESULT CSWbemProxyCache::QueryInterface
// long CSWbemProxyCache::AddRef
// long CSWbemProxyCache::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProxyCache::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemProxyCache::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemProxyCache::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CSWbemProxyCache::SetBlanketOptions
//
//  DESCRIPTION:
//
//  Called from constructor only to set up interaction mode with
//	SetBlanket calls.
//
//***************************************************************************

bool CSWbemProxyCache::DetermineBlanketOptions (IUnknown *pUnk)
{
	bool result = false; 

	if (CSWbemSecurity::IsNT() && (4 < CSWbemSecurity::GetNTMajorVersion ()))
	{
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hToken))
		{
			// Certainly a candidate to use default settings for
			// authorization and authentication service on the blanket.
			// Check if we are delegating.

			DWORD dwBytesReturned = 0;
			SECURITY_IMPERSONATION_LEVEL impLevel;

			if (GetTokenInformation(hToken, TokenImpersonationLevel, &impLevel,
							sizeof(SECURITY_IMPERSONATION_LEVEL), &dwBytesReturned) &&
									(SecurityDelegation == impLevel))
			{
				// Looks promising - now check for whether we are using kerberos
				IClientSecurity *pSec;
				DWORD dwAuthnSvc, dwAuthzSvc, dwImp, dwAuth, dwCapabilities;

				if (pUnk && SUCCEEDED(pUnk->QueryInterface(IID_IClientSecurity, (void **) &pSec)))
				{
					if (SUCCEEDED (pSec->QueryBlanket(pUnk, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            &dwAuth, &dwImp,
                                            NULL, &dwCapabilities)))
					{
						if (RPC_C_AUTHN_WINNT != dwAuthnSvc) 
							result = true;
					}

					pSec->Release ();
				}
			}

			CloseHandle (hToken);
		}
	}

	return result;
}

//***************************************************************************
//
//  CSWbemProxyCache::InitializeCache
//
//  DESCRIPTION:
//
//  Called from constructor only to set up cache and initial pUnk..
//
//  PARAMETERS:
//
//		pUnk			"seed" pUnk
//		pSecurity		if specified, is an ISWbemSecurity used to
//						override the intial authn/imp/etc. settings
//
//***************************************************************************

void CSWbemProxyCache::InitializeCache (
	IUnknown *pUnk,
	ISWbemSecurity *pSecurity,
	bool bPropagateAuthentication,
	bool bPropagateImpersonation
)
{
	for (int i = 0; i < WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL; i++)
		for (int j = 0; j < WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL; j++)
			pUnkArray [i] [j] = NULL;

	if (pUnk)
	{
		DWORD dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
		DWORD dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE; 
		
		HRESULT hr = GetAuthImp (pUnk, &dwAuthnLevel, &dwImpLevel);

		/*
		 * If we have been passed a "seed" Security object, use the auth/imp
		 * settings of that Seed as our initial setting.  Otherwise 
		 * use the settings supplied in the current proxy.
		 */
		if (pSecurity)
		{
			if (!bPropagateImpersonation || FAILED(pSecurity->get_ImpersonationLevel (&m_dwInitialImpLevel)))
				m_dwInitialImpLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			
			if (!bPropagateAuthentication || FAILED(pSecurity->get_AuthenticationLevel (&m_dwInitialAuthnLevel)))
				m_dwInitialAuthnLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;

			/*
			 * If settings are identical, use the proxy we have but set the
			 * blanket to ensure user/password/authority are set.
			 */

			if (((WbemImpersonationLevelEnum) dwImpLevel == m_dwInitialImpLevel) &&
				((WbemAuthenticationLevelEnum) dwAuthnLevel == m_dwInitialAuthnLevel))
			{
				SecureProxy (pUnk, m_dwInitialAuthnLevel, m_dwInitialImpLevel);
				
				pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
					  [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;
				pUnk->AddRef ();
			}
			else
			{
				// Need to create a new proxy
				IClientSecurity *pCliSec = NULL;

				if (S_OK == pUnk->QueryInterface (IID_IClientSecurity, (PPVOID) &pCliSec))
				{
					IUnknown *pNewUnk = NULL;

					// If successful this AddRef's pUnk
					HRESULT sc = pCliSec->CopyProxy(pUnk, &pNewUnk);

					if (S_OK == sc)
					{
						SecureProxy (pNewUnk, m_dwInitialAuthnLevel, m_dwInitialImpLevel);

						pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
								[m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pNewUnk;
						// NB: pNewUnk already AddRef'd above by CopyProxy
					}

					pCliSec->Release ();
				}
			}
		}
		else
		{
			m_dwInitialAuthnLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;
			m_dwInitialImpLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
					  [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;
			pUnk->AddRef ();
		}
	}
}

//***************************************************************************
//
//  CSWbemProxyCache::GetProxy
//
//  DESCRIPTION:
//
//  Return a proxy from the cache with the desired authentication and
//	impersonation level.
//
//  PARAMETERS:
//
//		authnLevel		required authentication level
//		impLevel		required impersonation level
//		forceResecure	whether to force a resecure of an extant proxy
//
//  RETURN VALUES:
//		Pointer to copied proxy, or NULL.  If not NULL, caller must Release.
//
//***************************************************************************

IUnknown *CSWbemProxyCache::GetProxy (
	WbemAuthenticationLevelEnum authnLevel,
	WbemImpersonationLevelEnum impLevel,
	bool forceResecure)
{
	EnterCriticalSection (&m_cs);

	IUnknown *pUnk = pUnkArray [authnLevel - WBEMS_MIN_AUTHN_LEVEL] 
							   [impLevel - WBEMS_MIN_IMP_LEVEL];

	if (pUnk)
	{
		// Already cached this proxy - reuse
		pUnk->AddRef ();

		// Force a resecure? This is useful if we have just changed the 
		// privileges in the current token and need to stim RPC to pick 
		// them up.	
		if (forceResecure)
			SecureProxy (pUnk, authnLevel, impLevel);
	}
	else
	{
		// Need to create a copy of the proxy; use the first
		// created element as a base

		IUnknown *pUnkFirst = pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL]
									    [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL];

		if (pUnkFirst)
		{
			// Now copy the proxy
			IClientSecurity *pCliSec = NULL;

			if (S_OK == pUnkFirst->QueryInterface (IID_IClientSecurity, (PPVOID) &pCliSec))
			{
				// If successful this AddRef's pUnk
				HRESULT sc = pCliSec->CopyProxy(pUnkFirst, &pUnk);

				if (S_OK == sc)
				{
					SecureProxy (pUnk, authnLevel, impLevel);

					pUnkArray [authnLevel - WBEMS_MIN_AUTHN_LEVEL] 
							  [impLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;

					// AddRef because we are handing pUnk back
					pUnk->AddRef ();
				}

				pCliSec->Release ();
			}
		}
	}

	LeaveCriticalSection (&m_cs);

	return pUnk;
}

//***************************************************************************
//
//  CSWbemProxyCache::SecureProxy
//
//  DESCRIPTION:
//
//  Secure the given proxy using the provided settings
//
//  PARAMETERS:
//
//		authnLevel		authentication level of proxy
//		impLevel		impersonation level of proxy
//
//  RETURN VALUES:
//		none
//
//***************************************************************************

void CSWbemProxyCache::SecureProxy (
	IUnknown *pUnk,
	WbemAuthenticationLevelEnum authnLevel,
	WbemImpersonationLevelEnum impLevel)
{
	/* 
	 * Due to the vagaries of the IClientSecurity::SetBlanket call,
	 * any COAUTHIDENTITY pointer passed into that call must remain
	 * valid either until SetBlanket is called again or all proxies
	 * on the object are released.  So we need to store any returned
	 * COAUTHIDENTITY so that it remains valid for the lifetime
	 * of this cache.
	 */
		
	EnterCriticalSection (&m_cs);

	if (pUnk)
	{
		/*
		 * Note that our implicit assumption is that we only ever
		 * need one COAUTHIDENTITY per cache.  This is because
		 * the ingredients of the structure (user, password and
		 * authority) are set at cache initialization time and
		 * never change thereafter.
		 */
		if (m_pCoAuthIdentity)
		{
			SetInterfaceSecurityDecrypt (pUnk, m_pCoAuthIdentity, m_bsPrincipal,
									authnLevel, impLevel, GetCapabilities (), 
									m_bUseDefaultInfo);
		}
		else
		{
			// See if we get one
			BSTR bsPrincipal = NULL;
	
			SetInterfaceSecurityEncrypt (pUnk, m_bsAuthority, m_bsUser, m_bsPassword,
					authnLevel, impLevel, GetCapabilities (),
					&m_pCoAuthIdentity, &bsPrincipal, m_bUseDefaultInfo);

			if (bsPrincipal)
			{
				if (m_bsPrincipal)
					SysFreeString (m_bsPrincipal);

				m_bsPrincipal = bsPrincipal;
			}
		}
	}

	LeaveCriticalSection (&m_cs);

	return;
}

//***************************************************************************
//
//  CSWbemProxyCache::GetCapabilities
//
//  DESCRIPTION:
//
//  Return the EOAC capabilities value depending on the OS platform and
//	user credentials (or absence thereof).
//
//  RETURN VALUES:
//
//	The determined capabilities.
//
//***************************************************************************

DWORD CSWbemProxyCache::GetCapabilities ()
{
	/*
	 * For NT5 (and presumably greater) we enable Static
	 * Cloaking on the proxy.  This allows RPC to use the
	 * Privilege settings in the Impersonation token.  
	 *
	 * Note that we use static cloaking so that thread identity
	 * is only used during CoSetProxyBlanket calls; dynamic
	 * cloaking forces it to be used on all calls to the proxy,
	 * so is much less efficient. Since we don't allow different
	 * users to access the same proxy, static cloaking is sufficient.
	 * 
	 * It makes no sense to explicitly supply a User/Password and specify
	 * cloaking, as DCOM authentication of proxy uses either 
	 * an explicit SEC_WINNT_AUTH_IDENTITY (for User & Password)
	 * or the current proxy identity (in the process token or 
	 * impersonation token).  Requesting cloaking implies that the
	 * proxy identity in the impersonation token is to be used, and
	 * therefore that any User/Password is irrelevant (and vice-versa).
	 *
	 * See MSDN documentation on CoSetProxyBlanket for more info.
	 */
	DWORD dwCapabilities = EOAC_NONE;
	
	if (CSWbemSecurity::IsNT () && (4 < CSWbemSecurity::GetNTMajorVersion ()) &&
				!m_bUsingExplicitUserName)
		dwCapabilities |= EOAC_STATIC_CLOAKING;

	return dwCapabilities ;
}

COAUTHIDENTITY *CSWbemProxyCache::GetCoAuthIdentity ()
{
	HRESULT hr = E_FAIL;
	COAUTHIDENTITY *pAuthIdent = NULL;

	if (m_pCoAuthIdentity)
		hr = WbemAllocAuthIdentity (m_pCoAuthIdentity->User, 
					m_pCoAuthIdentity->Password, m_pCoAuthIdentity->Domain, &pAuthIdent);

	return pAuthIdent;
}

void CSWbemProxyCache::ClearCredentials ()
{
	if (m_bsUser)
	{
		_wcsnset (m_bsUser, L'0', wcslen (m_bsUser));
		SysFreeString (m_bsUser);
		m_bsUser = NULL;
	}

	if (m_bsPassword)
	{
		_wcsnset (m_bsPassword, L'0', wcslen (m_bsPassword));
		SysFreeString (m_bsPassword);
		m_bsPassword = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\propvar.h ===
//***************************************************************************
//
//  propvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CPropSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _PROPVAR_H_
#define _PROPVAR_H_

// This class implements the IEnumVARIANT interface

class CPropSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemPropertySet	*m_pPropertySet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();

public:
	CPropSetEnumVar (CSWbemPropertySet *pObject, ULONG initialPos = 0);
	~CPropSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\qualifier.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  qualifier.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemQualifier and CSWbemQualifierSet definitions.
//
//***************************************************************************

#ifndef _QUALIFIER_H_
#define _QUALIFIER_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemQualifier
//
//  DESCRIPTION:
//
//  Implements the ISWbemQualifier interface.  
//
//***************************************************************************

class CSWbemQualifier : public ISWbemQualifier,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	class CQualifierDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags
					)
			{
				return false;
			}
	};

	IWbemQualifierSet		*m_pIWbemQualifierSet;
	CQualifierDispatchHelp	m_Dispatch;
	BSTR					m_name;
	CWbemSite						*m_pSite;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemQualifier (IWbemQualifierSet *pQualSet, BSTR name,
						CWbemSite *pSite = NULL);
    ~CSWbemQualifier (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemQualifier methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_IsLocal
	(
		/*[out]*/	VARIANT_BOOL *local
	);

	HRESULT STDMETHODCALLTYPE get_PropagatesToSubclass
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_PropagatesToSubclass
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_PropagatesToInstance
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_PropagatesToInstance
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_IsOverridable
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_IsOverridable
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_IsAmended
	(
		/*[out]*/	VARIANT_BOOL *value
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemQualifierSet interface.  
//
//***************************************************************************

class CSWbemQualifierSet : public ISWbemQualifierSet,
						   public ISupportErrorInfo,
						   public IProvideClassInfo
{
private:
	class CQualifierSetDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	IWbemQualifierSet				*m_pIWbemQualifierSet;
	CQualifierSetDispatchHelp		m_Dispatch;
	CWbemSite						*m_pSite;

protected:
	long				m_cRef;         //Object reference count

public:
    
    CSWbemQualifierSet (IWbemQualifierSet *pQualSet, 
						ISWbemInternalObject *pObject = NULL);
    ~CSWbemQualifierSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long *plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR name,
		/*[in]*/	VARIANT *pVal,
		/*[in]*/	VARIANT_BOOL propagatesToSubclasses,
		/*[in]*/	VARIANT_BOOL propagatesToInstances,
		/*[in]*/	VARIANT_BOOL overridable,
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemQualifier **ppQualifier
	);        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemQualifier **ppQualifier
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemQualifierSet methods

    HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemQualifier **ppQualifier
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\qualset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  QUALSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemQualifierSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemQualifierSet::CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemQualifierSet::CSWbemQualifierSet(IWbemQualifierSet *pQualSet,
									   ISWbemInternalObject *pSWbemObject) :
								m_pSite (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemQualifierSet, 
					CLSID_SWbemQualifierSet, L"SWbemQualifierSet");
	m_pIWbemQualifierSet = pQualSet;
	m_pIWbemQualifierSet->AddRef ();

	if (pSWbemObject)
		m_pSite = new CWbemObjectSite (pSWbemObject);

    m_cRef=1;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemQualifierSet::~CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemQualifierSet::~CSWbemQualifierSet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemQualifierSet)
	{
		m_pIWbemQualifierSet->EndEnumeration ();
		m_pIWbemQualifierSet->Release ();
	}

	if (m_pSite)
		m_pSite->Release ();
}

//***************************************************************************
// HRESULT CSWbemQualifierSet::QueryInterface
// long CSWbemQualifierSet::AddRef
// long CSWbemQualifierSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifierSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemQualifierSet==riid)
		*ppv = (ISWbemQualifierSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemQualifierSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemQualifierSet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemQualifierSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifierSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemQualifierSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Item
//
//  DESCRIPTION:
//
//  Get a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//		lFlags			Flags
//		ppQual			On successful return addresses the ISWbemQualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemQualifier ** ppQual
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQual)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (bsName, lFlags, NULL, NULL)))
		{
			if (!(*ppQual = new CSWbemQualifier (m_pIWbemQualifierSet, bsName, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Add
//
//  DESCRIPTION:
//
//  Put a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//		pVal			Pointer to new value
//		flavor			Flavor
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Add (
	BSTR bsName,
	VARIANT *pVal,
	VARIANT_BOOL propagatesToSubclasses,
	VARIANT_BOOL propagatesToInstances,
	VARIANT_BOOL overridable,
    long lFlags,
	ISWbemQualifier **ppQualifier
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == pVal) || (NULL == ppQualifier))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		long flavor = 0;

		if (propagatesToSubclasses)
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

		if (propagatesToInstances)
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

		if (!overridable)
			flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;

		// Make sure we have a decent qualifier value to use
		if(((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
		   ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
		{
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertArray(&vTemp, pVal, TRUE))
				hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);
			
			VariantClear(&vTemp);    
		}
		else if ((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal)))
		{
			// Could be a JScript IDispatchEx array
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertDispatchToArray (&vTemp, pVal, CIM_ILLEGAL, true))
				hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);

			VariantClear (&vTemp);
		}
		else
		{
			// Only certain types, I4, R8, BOOL and BSTR are acceptable qualifier
			// values.  Convert the data if need be

			VARTYPE vtOK = GetAcceptableQualType(pVal->vt);

			if(vtOK != pVal->vt)
			{
				VARIANT vTemp;
				VariantInit(&vTemp);

				if (S_OK == QualifierVariantChangeType (&vTemp, pVal, vtOK))
					hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);

				VariantClear(&vTemp);
			}
			else
				hr = m_pIWbemQualifierSet->Put (bsName, pVal, flavor);
		}

		if (SUCCEEDED (hr))
		{
			if (!(*ppQualifier = new CSWbemQualifier (m_pIWbemQualifierSet, bsName, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Remove
//
//  DESCRIPTION:
//
//  Delete a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemQualifierSet)
		hr = m_pIWbemQualifierSet->Delete (bsName);

	// Translate default reset case to an error
	if (WBEM_S_RESET_TO_DEFAULT == hr)
		hr = wbemErrResetToDefault;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	if (SUCCEEDED(hr) || (wbemErrResetToDefault == hr))
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the qualifiers
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemQualifierSet)
	{
		hr = m_pIWbemQualifierSet->EndEnumeration ();
		hr = m_pIWbemQualifierSet->BeginEnumeration (0);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Next
//
//  DESCRIPTION:
//
//  Get next qualifier in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppQual		Next qualifier (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Next (
	long lFlags,
	ISWbemQualifier ** ppQual
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQual)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		BSTR name = NULL;
		
		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Next (lFlags, &name, NULL, NULL)))
		{
			if (!(*ppQual = new CSWbemQualifier (m_pIWbemQualifierSet, name, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;

			SysFreeString (name);
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CQualSetEnumVar *pEnum = new CQualSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemQualifierSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses cardinality
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		/*
		 * This is not the most efficient way of obtaining the count,
		 * but it is the only way that is:
		 *	(a) Supported by the underlying interface
		 *	(b) Does not require access to any other interface
		 *	(c) Does not affect the current enumeration position
		 */

		if (m_pIWbemQualifierSet)
		{
			SAFEARRAY	*pArray = NULL;

			if (WBEM_S_NO_ERROR == m_pIWbemQualifierSet->GetNames (0, &pArray))
			{
				long lUBound = 0, lLBound = 0;
				SafeArrayGetUBound (pArray, 1, &lUBound);
				SafeArrayGetLBound (pArray, 1, &lLBound);
				*plCount = lUBound - lLBound + 1;
				SafeArrayDestroy (pArray);
				hr = S_OK;
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::CQualifierSetDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::CQualifierSetDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a qualifier (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemQualifierSet *pQualifierSet = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemQualifierSet, (PPVOID) &pQualifierSet)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);
			
			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);
			
				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemQualifier *pQualifier = NULL;

						if (SUCCEEDED (pQualifierSet->Item (V_BSTR(&nameVar), 0, &pQualifier)))
						{
							// Try and put the value
							if (SUCCEEDED (pQualifier->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pQualifier->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pQualifierSet->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\qualvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  CONTENUM.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT for iterators over ISWbemQualifierSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CQualSetEnumVar::CQualSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CQualSetEnumVar::CQualSetEnumVar(CSWbemQualifierSet *pQualSet,
								 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pQualifierSet = pQualSet;
	m_pQualifierSet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CQualSetEnumVar::~CQualSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CQualSetEnumVar::~CQualSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pQualifierSet)
		m_pQualifierSet->Release ();
}

//***************************************************************************
// HRESULT CQualSetEnumVar::QueryInterface
// long CQualSetEnumVar::AddRef
// long CQualSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CQualSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CQualSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CQualSetEnumVar::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CQualSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CQualSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pQualifierSet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemQualifier *pQualifier = NULL;
					
					if (SUCCEEDED(hRes2 = m_pQualifierSet->Next (0, &pQualifier)))
					{
						if (NULL == pQualifier)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pQualifier;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CQualSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pQualifierSet)
		{
			CQualSetEnumVar *pEnum = new CQualSetEnumVar (m_pQualifierSet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CQualSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pQualifierSet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CQualSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CQualSetEnumVar::SeekCurrentPosition ()
{
	ISWbemQualifier *pDummyObject = NULL;
	m_pQualifierSet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pQualifierSet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\security.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SECURITY.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the implementation of CSWbemSecurity
//
//***************************************************************************

#include "precomp.h"

// Used to protect security calls
extern CRITICAL_SECTION g_csSecurity;

bool		CSWbemSecurity::s_bInitialized = false;
bool		CSWbemSecurity::s_bIsNT = false;
DWORD		CSWbemSecurity::s_dwNTMajorVersion = 0;
HINSTANCE	CSWbemSecurity::s_hAdvapi = NULL;
bool		CSWbemSecurity::s_bCanRevert = false;
WbemImpersonationLevelEnum	CSWbemSecurity::s_dwDefaultImpersonationLevel 
					= wbemImpersonationLevelIdentify;

// Declarations for function pointers that won't exist on Win9x
BOOL (STDAPICALLTYPE *s_pfnDuplicateTokenEx) (
	HANDLE, 
	DWORD, 
	LPSECURITY_ATTRIBUTES,
	SECURITY_IMPERSONATION_LEVEL, 
	TOKEN_TYPE,
	PHANDLE
) = NULL; 

//***************************************************************************
//
//  SCODE CSWbemSecurity::Initialize
//
//  DESCRIPTION:
//
//  This static function is caused on DLL attachment to the process; it
//	sets up the function pointers for advanced API privilege functions.
//	On Win9x these functions are not supported which is why we need to
//	indirect through GetProcAddress.
//
//***************************************************************************
 
void CSWbemSecurity::Initialize ()
{
	EnterCriticalSection (&g_csSecurity);

	if (!s_bInitialized)
	{
		// Get OS info
		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		GetVersionEx (&osVersionInfo);
		s_bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
		s_dwNTMajorVersion = osVersionInfo.dwMajorVersion;

		if (s_bIsNT)
		{
			HKEY hKey;

			// Security values are relevant for NT only - for Win9x leave as default
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
					WBEMS_RK_SCRIPTING, 0, KEY_QUERY_VALUE, &hKey))
			{
				DWORD dwDummy = 0;

				// Get revert flag value from registry - NT 4.0 or less only
				if (s_dwNTMajorVersion <= 4)
				{
					DWORD dwEnableForAsp = 0;
					dwDummy = sizeof (dwEnableForAsp);
				
					if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_ENABLEFORASP, 
							NULL, NULL, (BYTE *) &dwEnableForAsp,  &dwDummy))
						s_bCanRevert = (0 != dwEnableForAsp);
				}

				// Get default impersonation level from registry
				DWORD dwImpLevel = 0;
				dwDummy = sizeof (dwImpLevel);
			
				if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFAULTIMPLEVEL, 
							NULL, NULL, (BYTE *) &dwImpLevel,  &dwDummy))
					s_dwDefaultImpersonationLevel = (WbemImpersonationLevelEnum) dwImpLevel;

				RegCloseKey (hKey);
			}

			// Set up security function pointers for NT
			if (!s_hAdvapi)
			{
				TCHAR	dllName [] = _T("\\advapi32.dll");
				LPTSTR  pszSysDir = new TCHAR[ MAX_PATH + _tcslen (dllName) + 1];

				if (pszSysDir)
				{
					pszSysDir[0] = NULL;
					UINT    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
					
					if(uSize > MAX_PATH) {
						delete[] pszSysDir;
						pszSysDir = new TCHAR[ uSize + _tcslen (dllName) + 1];
        				
						if (pszSysDir)
						{
							pszSysDir[0] = NULL;
							uSize = GetSystemDirectory(pszSysDir, uSize);
						}
					}

					if (pszSysDir)
					{
						_tcscat (pszSysDir, dllName);
						s_hAdvapi = LoadLibraryEx (pszSysDir, NULL, 0);
						
						if (s_hAdvapi)
							(FARPROC&) s_pfnDuplicateTokenEx = GetProcAddress(s_hAdvapi, "DuplicateTokenEx");

						delete [] pszSysDir;
					}
				}
			}
		}

		s_bInitialized = true;
	}
	
	LeaveCriticalSection (&g_csSecurity);
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::Uninitialize
//
//  DESCRIPTION:
//
//  This static function is caused on DLL detachment to the process; it
//	unloads the API loaded by Initialize (above) to obtain function pointers.
//
//***************************************************************************

void CSWbemSecurity::Uninitialize ()
{
	EnterCriticalSection (&g_csSecurity);
	
	if (s_hAdvapi)
	{
		s_pfnDuplicateTokenEx = NULL;
		FreeLibrary (s_hAdvapi);
		s_hAdvapi = NULL;
	}

	LeaveCriticalSection (&g_csSecurity);
}


//***************************************************************************
//
//  SCODE CSWbemSecurity::LookupPrivilegeValue
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeValue function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		lpName		the privilege name
//		lpLuid		holds the LUID on successful return
//
//  RETURN VALUES:
//
//		true		On NT this means we found the privilege. On Win9x we
//					always return this.
//
//		false		On NT this means the privilege is not recognized.  This
//					is never returned on Win9x.
//
//***************************************************************************
 
BOOL CSWbemSecurity::LookupPrivilegeValue (
	LPCTSTR lpName, 
	PLUID lpLuid
)
{
	// Allows any name to map to 0 LUID on Win9x - this aids script portability
	if (IsNT ())
		return ::LookupPrivilegeValue(NULL, lpName, lpLuid);
	else
		return true;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::LookupPrivilegeDisplayName
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeDisplayName function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		tName			the privilege name
//		pDisplayName	holds the display name on successful return
//
//***************************************************************************

void CSWbemSecurity::LookupPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName)
{
	if (pDisplayName)
	{
		// Can't return display name on Win9x (no privilege support)
		if (IsNT ())
		{
			DWORD dwLangID;
			DWORD dwSize = 1;
			TCHAR dummy [1];
					
			// Get size of required buffer
			::LookupPrivilegeDisplayName (NULL, lpName, dummy, &dwSize, &dwLangID);
			LPTSTR dname = new TCHAR[dwSize + 1];

			if (dname)
			{
				if (::LookupPrivilegeDisplayName (_T(""), lpName, dname, &dwSize, &dwLangID))
				{
					// Have a valid name - now copy it to a BSTR
#ifdef _UNICODE 
					*pDisplayName = SysAllocString (dname);
#else
					size_t dnameLen = strlen (dname);
					OLECHAR *nameW = new OLECHAR [dnameLen + 1];

					if (nameW)
					{
						mbstowcs (nameW, dname, dnameLen);
						nameW [dnameLen] = NULL;
						*pDisplayName = SysAllocString (nameW);
						delete [] nameW;
					}
#endif
				}

				delete [] dname;
			}
		}

		// If we failed, just set an empty string
		if (!(*pDisplayName))
			*pDisplayName = SysAllocString (L"");
	}
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM 
//		remoted interface where no previous security has been applied.  
//		It is only used to secure IWbemServices interfaces.
//		Note that the Locator may have security settings so these are
//		transferred if present.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	BSTR bsAuthority ,
	BSTR bsUser, 
	BSTR bsPassword,
	CWbemLocatorSecurity *pLocatorSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
				CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
		
	m_pProxyCache = new CSWbemProxyCache (pUnk, bsAuthority,
							bsUser, bsPassword, pLocatorSecurity);

	if (m_pProxyCache)
		m_pCurProxy = m_pProxyCache->GetInitialProxy ();

	if (pLocatorSecurity)
	{
		// Clone the privilege set

		CSWbemPrivilegeSet *pPrivilegeSet = pLocatorSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
	}
	else
	{
		// Create a new privilege set
	
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM 
//		remoted interface where no previous security has been applied,
//		and where the user credentials are expressed in the form of an
//		encrypted COAUTHIDENTITY plus principal and authority.  
//		It is only used to secure IWbemServices interfaces.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
		
	m_pProxyCache = new CSWbemProxyCache (pUnk, pCoAuthIdentity,
							bsPrincipal, bsAuthority);

	if (m_pProxyCache)
		m_pCurProxy = m_pProxyCache->GetInitialProxy ();

	// Create a new privilege set
	m_pPrivilegeSet = new CSWbemPrivilegeSet;

	InterlockedIncrement(&g_cObj);
}
//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM interface
//		non-remoted interface using the security attributes attached to another 
//		(already secured) remoted interface; a non-remoted interface is secured
//		by virtue of securing a new proxy on an underlying remoted interface.  
//		It is used to "secure" an ISWbemObjectEx interface using the security 
//		settings of an IWbemServices interface.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;

	// Clone the privilege set
	if (pSecurity)
	{
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		else
		{
			// Create a new one
			m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		}

		m_pProxyCache = pSecurity->GetProxyCache ();
		m_pCurProxy = pSecurity->GetProxy ();
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	ISWbemInternalSecurity *pISWbemInternalSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;

	if (pISWbemInternalSecurity)
	{
		// Clone the privilege set
		ISWbemSecurity *pISWbemSecurity = NULL;

		if (SUCCEEDED(pISWbemInternalSecurity->QueryInterface (IID_ISWbemSecurity,
							(void**) &pISWbemSecurity)))
		{
			ISWbemPrivilegeSet *pISWbemPrivilegeSet = NULL;

			if (SUCCEEDED(pISWbemSecurity->get_Privileges (&pISWbemPrivilegeSet)))
			{
				// Build the privilege set
				m_pPrivilegeSet = new CSWbemPrivilegeSet (pISWbemPrivilegeSet);

				// Build the proxy cache
				BSTR bsAuthority = NULL;
				BSTR bsPrincipal = NULL;
				BSTR bsUser = NULL;
				BSTR bsPassword = NULL;
				BSTR bsDomain = NULL;
				
				pISWbemInternalSecurity->GetAuthority (&bsAuthority);
				pISWbemInternalSecurity->GetPrincipal (&bsPrincipal);
				pISWbemInternalSecurity->GetUPD (&bsUser, &bsPassword, &bsDomain);
				
				COAUTHIDENTITY *pCoAuthIdentity = NULL;

				// Decide if we need a COAUTHIDENTITY
				if ((bsUser && (0 < wcslen (bsUser))) ||
					(bsPassword && (0 < wcslen (bsPassword))) ||
					(bsDomain && (0 < wcslen (bsDomain))))
					WbemAllocAuthIdentity (bsUser, bsPassword, bsDomain, &pCoAuthIdentity);

				m_pProxyCache = new CSWbemProxyCache (pUnk, pCoAuthIdentity,
									bsPrincipal, bsAuthority);

				if (pCoAuthIdentity)
					WbemFreeAuthIdentity (pCoAuthIdentity);

				if (bsAuthority)
					SysFreeString (bsAuthority);

				if (bsPrincipal)
					SysFreeString (bsPrincipal);

				if (bsUser)
					SysFreeString (bsUser);

				if (bsPassword)
					SysFreeString (bsPassword);

				if (bsDomain)
					SysFreeString (bsDomain);

				if (m_pProxyCache)
					m_pCurProxy = m_pProxyCache->GetInitialProxy ();
			}

			pISWbemPrivilegeSet->Release ();
		}

		pISWbemSecurity->Release ();
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM remoted
//		interface interface using the security attributes attached to another 
//		(already secured) remoted interface.
//		It is used to "secure" an ISWbemObjectSet interface using the security 
//		settings of an IWbemServices interface.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
						CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
	InterlockedIncrement(&g_cObj);

	if (pSecurity)
	{
		// Clone the privilege set
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		
		m_pProxyCache = new CSWbemProxyCache (pUnk, pSecurity);

		if (m_pProxyCache)
			m_pCurProxy = m_pProxyCache->GetInitialProxy ();
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_pProxyCache = new CSWbemProxyCache (pUnk, NULL);

		if (m_pProxyCache)
			m_pCurProxy = m_pProxyCache->GetInitialProxy ();
	}
}

//***************************************************************************
//
// CSWbemSecurity::~CSWbemSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemSecurity::~CSWbemSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pCurProxy)
		m_pCurProxy->Release ();

	if (m_pProxyCache)
		m_pProxyCache->Release ();

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CSWbemSecurity::QueryInterface
// long CSWbemSecurity::AddRef
// long CSWbemSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_ISWbemInternalSecurity==riid)
		*ppv = (ISWbemInternalSecurity *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemSecurity::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			*pAuthenticationLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy && m_pProxyCache)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			// Only refressh from cache if settings have changed
			if (authenticationLevel != (WbemAuthenticationLevelEnum) dwAuthnLevel)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;

				m_pCurProxy = m_pProxyCache->GetProxy 
								(authenticationLevel, (WbemImpersonationLevelEnum) dwImpLevel);
			}
			
			hr = WBEM_S_NO_ERROR;
		}
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			*pImpersonationLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy && m_pProxyCache)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			// Only refressh from cache if settings have changed
			if (impersonationLevel != (WbemImpersonationLevelEnum) dwImpLevel)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;

				m_pCurProxy = m_pProxyCache->GetProxy 
							((WbemAuthenticationLevelEnum) dwAuthnLevel, impersonationLevel);
			}
			
			hr = WBEM_S_NO_ERROR;
		}
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  CSWbemSecurity::SecureInterface
//
//  DESCRIPTION:
//
//  Set the security on the specified interface using the security settings
//	on this interface.
//
//  PARAMETERS:
//
//		pUnk		The interface to secure
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemSecurity::SecureInterface (IUnknown *pUnk)
{
	if(pUnk)
	{
		if (m_pCurProxy)
		{
			DWORD dwAuthnLevel;
			DWORD dwImpLevel;

			if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
				if (m_pProxyCache)
					m_pProxyCache->SecureProxy (pUnk, 
							(WbemAuthenticationLevelEnum) dwAuthnLevel, 
							(WbemImpersonationLevelEnum) dwImpLevel);
		}
	}
}


//***************************************************************************
//
//  CSWbemSecurity::SecureInterfaceRev
//
//  DESCRIPTION:
//
//  Set the security on this interface using the security settings
//	on the specified interface.
//
//  PARAMETERS:
//
//		pUnk		The interface whose security settings we will 
//					use to set this interface
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemSecurity::SecureInterfaceRev (IUnknown *pUnk)
{
	if (pUnk)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (pUnk, &dwAuthnLevel, &dwImpLevel))
		{
			if (m_pCurProxy)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;
			}

			if (m_pProxyCache)
			{
				m_pCurProxy = m_pProxyCache->GetProxy 
						((WbemAuthenticationLevelEnum) dwAuthnLevel, 
						 (WbemImpersonationLevelEnum) dwImpLevel);
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemSecurity::AdjustTokenPrivileges
//
//  DESCRIPTION:
//
//  Adjust the Privileges on the specified token without allowing a future
//	restore of the current settings..
//
//  PARAMETERS:
//
//		hHandle			Handle of the token on which to adjust privileges
//		pPrivilegeSet	Specified privilege adjustments
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemSecurity::AdjustTokenPrivileges (
	HANDLE hHandle, 
	CSWbemPrivilegeSet *pPrivilegeSet
)
{
	DWORD lastErr = 0;

	if (pPrivilegeSet)
	{
		pPrivilegeSet->AddRef ();

		long lNumPrivileges = 0;
		pPrivilegeSet->get_Count (&lNumPrivileges);

		if (lNumPrivileges)
		{
			DWORD dwPrivilegeIndex = 0;

			/*
			 * Set up the token privileges array. Note that some jiggery-pokery
			 * is required here because the Privileges field is an [ANYSIZE_ARRAY]
			 * type.
			 */
			TOKEN_PRIVILEGES *pTokenPrivileges = (TOKEN_PRIVILEGES *) 
						new BYTE [sizeof(TOKEN_PRIVILEGES) + (lNumPrivileges * sizeof (LUID_AND_ATTRIBUTES [1]))];

			if (pTokenPrivileges)
			{
				// Get the iterator
				PrivilegeMap::iterator next = pPrivilegeSet->m_PrivilegeMap.begin ();

				while (next != pPrivilegeSet->m_PrivilegeMap.end ())
				{
					CSWbemPrivilege *pPrivilege = (*next).second;
					pPrivilege->AddRef ();
					LUID luid;
					pPrivilege->GetLUID (&luid);
					VARIANT_BOOL vBool;
					pPrivilege->get_IsEnabled (&vBool);

					pTokenPrivileges->Privileges [dwPrivilegeIndex].Luid = luid;

					/*
					 * Note that any setting other than SE_PRIVILEGE_ENABLED
					 * is interpreted by AdjustTokenPrivileges as a DISABLE
					 * request for that Privilege.
					 */
					pTokenPrivileges->Privileges [dwPrivilegeIndex].Attributes
						= (VARIANT_TRUE == vBool) ?
						SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT;

					dwPrivilegeIndex++;
					pPrivilege->Release ();
					next++;
				}

				// Now we should have recorded the number of privileges that were OK

				if (0 < dwPrivilegeIndex)
				{
					pTokenPrivileges->PrivilegeCount = dwPrivilegeIndex;

					BOOL result = ::AdjustTokenPrivileges (hHandle, FALSE, pTokenPrivileges, 0, NULL, NULL);
					lastErr = GetLastError ();
				}

				delete [] pTokenPrivileges;
			}
		}

		pPrivilegeSet->Release ();
	}
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::SetSecurity
//
//  DESCRIPTION:
//
//  Set Privileges on the Thread Token.
//
//***************************************************************************

BOOL CSWbemSecurity::SetSecurity (
	bool &needToResetSecurity, 
	HANDLE &hThreadToken
)
{
	BOOL	result = TRUE;		// Default is success
	DWORD lastErr = 0;
	hThreadToken = NULL;			// Default assume we'll modify process token
	needToResetSecurity = false;	// Default assume we changed no privileges

	// Win9x has no security support
	if (IsNT ())
	{
		// Start by checking whether we are being impersonated.  On an NT4
		// box (which has no cloaking, and therefore cannot allow us to
		// pass on this impersonation to Winmgmt) we should RevertToSelf
		// if we have been configured to allow this.  If we haven't been
		// configured to allow this, bail out now.
		if (4 >= GetNTMajorVersion ())
		{
			if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_IMPERSONATE, true, &hThreadToken))
			{
				// We are being impersonated
				if (s_bCanRevert)
				{
					if (result = RevertToSelf())
						needToResetSecurity = true;
				}
				else
				{
					// Error - cannot do this!  Time to bail out
					CloseHandle (hThreadToken);
					hThreadToken = NULL;
					result = FALSE;
				}
			}
		}
		else
		{
#ifdef WSCRPDEBUG
			HANDLE hToken = NULL;

			if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
			{
				PrintPrivileges (hToken);
				CloseHandle (hToken);
			}
#endif
		}

		if (result)
		{
			// Now we check if we need to set privileges
			bool bIsUsingExplicitUserName = false;
		
			if (m_pProxyCache)
				bIsUsingExplicitUserName = m_pProxyCache->IsUsingExplicitUserName ();

			/*
			 * Specifying a user only makes sense for remote operations, and we
			 * don't need to mess with privilege for remote operations since
			 * they are set up by server logon anyway.
			 */
			if (!bIsUsingExplicitUserName && m_pPrivilegeSet)
			{
				// Nothing to do unless some privilege overrides have been set
				long lCount = 0;
				m_pPrivilegeSet->get_Count (&lCount);

				if (0 < lCount)
				{
					if (4 < GetNTMajorVersion ())
					{
						/*
						 * On NT5 we try to open the Thread token.  If the client app
						 * is calling into us on an impersonated thread (as IIS may be,
						 * for example), this will succeed.
						 */
						HANDLE hToken;
						SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
						
						if (!(result =  OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE, true, &hToken)))
						{
							// No thread token - go for the Process token instead
							HANDLE hProcess = GetCurrentProcess ();
							result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_DUPLICATE, &hToken);
							CloseHandle (hProcess);
						}
						else
						{
							// We are working with a thread token
							hThreadToken = hToken;		

							// Try and get the impersonation level of this token
							DWORD dwReturnLength  = 0;

							BOOL thisRes = GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
											sizeof (SECURITY_IMPERSONATION_LEVEL), &dwReturnLength);
						}

						if (result)
						{
							/*
							 * Getting here means we have a valid token, be it process or thread. We
							 * now attempt to duplicate it before Adjusting the Privileges.
							 */
#ifdef WSCRPDEBUG
							PrintPrivileges (hToken);
#endif
							HANDLE hDupToken;

							EnterCriticalSection (&g_csSecurity);

							result = s_pfnDuplicateTokenEx &&
								s_pfnDuplicateTokenEx (hToken, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE, NULL,
											secImpLevel, TokenImpersonation, &hDupToken);

							LeaveCriticalSection (&g_csSecurity);

							if (result)
							{
								CSWbemSecurity::AdjustTokenPrivileges (hDupToken, m_pPrivilegeSet);

								// Now use this token on the current thread
								if (SetThreadToken(NULL, hDupToken))
								{
									needToResetSecurity = true;
#ifdef WSCRPDEBUG
									CSWbemSecurity::PrintPrivileges (hDupToken);
#endif

									// Reset the blanket for the benefit of RPC
									DWORD	dwAuthnLevel, dwImpLevel;
									
									if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
									{
										// Force the cache to resecure the proxy
										IUnknown *pNewProxy = m_pProxyCache->GetProxy 
																((WbemAuthenticationLevelEnum) dwAuthnLevel, 
																 (WbemImpersonationLevelEnum) dwImpLevel, true);

										if (pNewProxy)
										{
											if (m_pCurProxy)
												m_pCurProxy->Release ();
											
											m_pCurProxy = pNewProxy;
										}
									}							
								}

								CloseHandle (hDupToken);
							}
							else
							{
								lastErr = GetLastError ();
							}
							
							/*
							 * If we are not using a thread token, close the token now. Otherwise
							 * the handle will be closed in the balanced call to RestorePrivileges ().
							 */
							if (!hThreadToken)
								CloseHandle (hToken);
						}
					}
					else
					{
						// For NT4 we adjust the privileges in the process token
						HANDLE hProcessToken = NULL;
						
						HANDLE hProcess = GetCurrentProcess ();
						result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken); 
						CloseHandle (hProcess);
						
						// Adjust privilege on the process
						if (result)
						{
#ifdef WSCRPDEBUG
							CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
							CSWbemSecurity::AdjustTokenPrivileges (hProcessToken, m_pPrivilegeSet);
#ifdef WSCRPDEBUG
							CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
							CloseHandle (hProcessToken);
						}
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::ResetSecurity
//
//  DESCRIPTION:
//
//  Restore Privileges on the Thread Token.
//
//***************************************************************************

void	CSWbemSecurity::ResetSecurity (
	HANDLE hThreadToken
)
{
	// Win9x has no security palaver
	if (IsNT ())
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		BOOL result = SetThreadToken (NULL, hThreadToken);
		DWORD error = 0;

		if (!result)
			error = GetLastError ();
			
#ifdef WSCRPDEBUG
		// Print out the current privileges to see what's changed
		HANDLE hToken = NULL;

		if (!OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
		{
			// No thread token - go for the Process token instead
			HANDLE hProcess = GetCurrentProcess ();
			OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
			CloseHandle (hProcess);
		}

		if (hToken)
		{
			PrintPrivileges (hToken);
			CloseHandle (hToken);
		}
#endif	
		if (hThreadToken)
				CloseHandle (hThreadToken);
	}
}

bool CSWbemSecurity::IsImpersonating (bool useDefaultUser, bool useDefaultAuthority)
{
	bool result = false;

	if (useDefaultUser && useDefaultAuthority && CSWbemSecurity::IsNT () && 
				(4 < CSWbemSecurity::GetNTMajorVersion ()))
	{
		// A suitable candidate - find out if we are running on an impersonated thread
		HANDLE hThreadToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hThreadToken))
		{
			// Check we have an impersonation token
			SECURITY_IMPERSONATION_LEVEL secImpLevel;

			DWORD dwReturnLength  = 0;
			if (GetTokenInformation (hThreadToken, TokenImpersonationLevel, &secImpLevel, 
									sizeof (SECURITY_IMPERSONATION_LEVEL), &dwReturnLength))
				result = ((SecurityImpersonation == secImpLevel) || (SecurityDelegation == secImpLevel));

			CloseHandle (hThreadToken);
		}
	}

	return result;
}

HRESULT CSWbemSecurity::GetAuthority (BSTR *bsAuthority)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		*bsAuthority = SysAllocString(m_pProxyCache->GetAuthority ());
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSecurity::GetUPD (BSTR *bsUser, BSTR *bsPassword, BSTR *bsDomain)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		COAUTHIDENTITY *pCoAuthIdentity = m_pProxyCache->GetCoAuthIdentity ();

		if (pCoAuthIdentity)
		{
			*bsUser = SysAllocString (pCoAuthIdentity->User);
			*bsPassword = SysAllocString (pCoAuthIdentity->Password);
			*bsDomain = SysAllocString (pCoAuthIdentity->Domain);
			WbemFreeAuthIdentity (pCoAuthIdentity);
		}
		
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSecurity::GetPrincipal (BSTR *bsPrincipal)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		*bsPrincipal = SysAllocString(m_pProxyCache->GetPrincipal ());
		hr = S_OK;
	}

	return hr;
}

// CWbemLocatorSecurity methods

//***************************************************************************
//
// CSWbemLocatorSecurity::CSWbemLocatorSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CWbemLocatorSecurity::CWbemLocatorSecurity (CSWbemPrivilegeSet *pPrivilegeSet) :
	m_cRef (1),
	m_impLevelSet (false),
	m_authnLevelSet (false),
	m_pPrivilegeSet (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	InterlockedIncrement(&g_cObj);

	if (pPrivilegeSet)
		m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
	else
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
}

CWbemLocatorSecurity::CWbemLocatorSecurity (CWbemLocatorSecurity *pCWbemLocatorSecurity) :
	m_cRef (1),
	m_impLevelSet (false),
	m_authnLevelSet (false),
	m_pPrivilegeSet (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	InterlockedIncrement(&g_cObj);

	if (pCWbemLocatorSecurity)
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet (pCWbemLocatorSecurity->m_pPrivilegeSet);
		
		m_impLevelSet = pCWbemLocatorSecurity->m_impLevelSet;
		m_authnLevelSet = pCWbemLocatorSecurity->m_authnLevelSet;
		
		if (m_impLevelSet)
			m_impLevel = pCWbemLocatorSecurity->m_impLevel;

		if (m_authnLevelSet)
			m_authnLevel = pCWbemLocatorSecurity->m_authnLevel;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
		m_impLevelSet = false;
		m_authnLevelSet = false;
	}
}

//***************************************************************************
//
// CWbemLocatorSecurity::CWbemLocatorSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CWbemLocatorSecurity::~CWbemLocatorSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CWbemLocatorSecurity::QueryInterface
// long CWbemLocatorSecurity::AddRef
// long CWbemLocatorSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemLocatorSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemLocatorSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CWbemLocatorSecurity::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemLocatorSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CWbemLocatorSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_authnLevelSet)
	{
		*pAuthenticationLevel = m_authnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		m_authnLevel = authenticationLevel;
		m_authnLevelSet = true;
		hr = WBEM_S_NO_ERROR;
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_impLevelSet)
	{
		*pImpersonationLevel = m_impLevel;
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		m_impLevel = impersonationLevel;
		m_impLevelSet = true;
		hr = WBEM_S_NO_ERROR;
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::SetSecurity
//
//  DESCRIPTION:
//
//  Set Privileges on the Process Token.
//
//***************************************************************************

BOOL CWbemLocatorSecurity::SetSecurity (
	BSTR bsUser,
	bool &needToResetSecurity,
	HANDLE &hThreadToken
)
{
	BOOL result = TRUE;
	needToResetSecurity = false;
	hThreadToken = NULL;

	/*
	 * NT5 supports the concept of dynamic cloaking, which means
	 * we can set privileges temporarily on a thread (impersonation)
	 * token basis immediately before a call to a remoted proxy.  
	 *
	 * Setting prior to locator.connectserver therefore makes no 
	 * sense for NT5.
	 *
	 * Oh and Win9x has no security support
	 */
	if (CSWbemSecurity::IsNT () && (4 >= CSWbemSecurity::GetNTMajorVersion ()))
	{
		/*
		 * Start by checking whether we are being impersonated.  On an NT4
		 * box (which has no cloaking, and therefore cannot allow us to
		 * pass on this impersonation to Winmgmt) we should RevertToSelf
		 * if we have been configured to allow this.  If we haven't been
		 * configured to allow this, bail out now.
		 */
		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_IMPERSONATE, false, &hThreadToken))
		{
			// We are being impersonated
			if (CSWbemSecurity::CanRevertToSelf ())
			{
				if (result = RevertToSelf())
					needToResetSecurity = true;
			}
			else
			{
				// Error - cannot do this!  Time to bail out
				CloseHandle (hThreadToken);
				hThreadToken = NULL;
				result = FALSE;
			}
		}

		if (result && m_pPrivilegeSet)
		{
			/*
			 * Specifying a user only makes sense for remote operations, and we
			 * don't need to mess with privilege for remote operations since
			 * they are set up by server logon anyway.
			 */
			if (!bsUser || (0 == wcslen(bsUser)))
			{
				// Nothing to do unless some privilege overrides have been set
				long lCount = 0;
				m_pPrivilegeSet->get_Count (&lCount);

				if (0 < lCount)
				{
					/*
					 * For NT4 privilege settings on impersonation tokens are ignored
					 * by DCOM/RPC.  Hence we have to set this on the process token.
					 *
					 * On NT4 we must set the configured privileges on the Process
					 * Token before the first call to RPC (i.e. IWbemLocator::ConnectServer)
					 * if we need to guarantee privilege settings will be communicated to
					 * the server.  
					 *
					 * This is because (a) NT4 does not support cloaking to allow the 
					 * impersonation (i.e. thread) token privilege setting to propagate
					 * on a per-DCOM call basis, (b) changes to Process-token level
					 * privileges _may_ be ignored after the first remote DCOM call due
					 * to RPC caching behavior.
					 *
					 * Note that this is a non-reversible operation, and is highly discouraged
					 * on apps (such as IE and IIS) which host multiple "tasks" since it adjusts
					 * the Privilege set for all of the other threads in the process.
					 */

					HANDLE hProcess = GetCurrentProcess ();
					HANDLE hProcessToken = NULL;
					result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken); 
					CloseHandle (hProcess);
					
					if (result)
					{
#ifdef WSCRPDEBUG
						CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
						CSWbemSecurity::AdjustTokenPrivileges (hProcessToken, m_pPrivilegeSet);
#ifdef WSCRPDEBUG
						CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
						CloseHandle (hProcessToken);
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::ResetSecurity
//
//  DESCRIPTION:
//
//  Restore Privileges on the Thread Token.
//
//***************************************************************************

void	CWbemLocatorSecurity::ResetSecurity (
	HANDLE hThreadToken
)
{
	// Win9x has no concept of impersonation
	// On NT5 we never set privileges through this class anyway
	if (CSWbemSecurity::IsNT () && (4 >= CSWbemSecurity::GetNTMajorVersion ()) 
				&& hThreadToken)
	{
		/* 
		 * Set the supplied token back into
		 * the current thread.
		 */
		BOOL result = SetThreadToken (NULL, hThreadToken);
		
#ifdef WSCRPDEBUG
		// Print out the current privileges to see what's changed
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
		{
			// No thread token - go for the Process token instead
			HANDLE hProcess = GetCurrentProcess ();
			OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
			CloseHandle (hProcess);
		}

		if (hToken)
		{
			CSWbemSecurity::PrintPrivileges (hToken);
			CloseHandle (hToken);
		}
#endif	
		CloseHandle (hThreadToken);
	}
}


#ifdef WSCRPDEBUG

//***************************************************************************
//
//  SCODE CSWbemSecurity::PrintPrivileges
//
//  DESCRIPTION:
//
//  Debug logging for privileges and other token info
//
//***************************************************************************

void CSWbemSecurity::PrintPrivileges (HANDLE hToken)
{
	DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
	TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

	if (!tp)
	{
		return;
	}

	DWORD dwRequiredSize = 0;
	DWORD dwLastError = 0;
	FILE *fDebug = fopen ("C:/temp/wmidsec.txt", "a+");
	fprintf (fDebug, "\n\n***********************************************\n\n");
	bool status = false;

	// Step 0 - get impersonation level
	SECURITY_IMPERSONATION_LEVEL secImpLevel;
	if (GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
											sizeof (SECURITY_IMPERSONATION_LEVEL), &dwRequiredSize))
	{
		switch (secImpLevel)
		{
			case SecurityAnonymous:
				fprintf (fDebug, "IMPERSONATION LEVEL: Anonymous\n");
				break;
			
			case SecurityIdentification:
				fprintf (fDebug, "IMPERSONATION LEVEL: Identification\n");
				break;
			
			case SecurityImpersonation:
				fprintf (fDebug, "IMPERSONATION LEVEL: Impersonation\n");
				break;

			case SecurityDelegation:
				fprintf (fDebug, "IMPERSONATION LEVEL: Delegation\n");
				break;

			default:
				fprintf (fDebug, "IMPERSONATION LEVEL: Unknown!\n");
				break;
		}
	
		fflush (fDebug);
	}

	DWORD dwUSize = sizeof (TOKEN_USER);
	TOKEN_USER *tu = (TOKEN_USER *) new BYTE [dwUSize];

	if (!tu)
	{
		delete [] tp;
		fclose (fDebug);
		return;
	}

	// Step 1 - get user info
	if (0 ==  GetTokenInformation (hToken, TokenUser, 
						(LPVOID) tu, dwUSize, &dwRequiredSize))
	{
		delete [] tu;
		dwUSize = dwRequiredSize;
		dwRequiredSize = 0;
		tu = (TOKEN_USER *) new BYTE [dwUSize];

		if (!tu)
		{
			delete [] tp;
			fclose (fDebug);
			return;
		}

		if (!GetTokenInformation (hToken, TokenUser, (LPVOID) tu, dwUSize, 
							&dwRequiredSize))
			dwLastError = GetLastError ();
		else
			status = true;
	}

	if (status)
	{
		// Dig out the user info
		dwRequiredSize = BUFSIZ;
		char *userName = new char [dwRequiredSize];
		char *domainName = new char [dwRequiredSize];

		if (!userName || !domainName)
		{
			delete [] tp;
			delete [] tu;
			delete [] userName;
			delete [] domainName;
			return;
		}

		SID_NAME_USE eUse;

		LookupAccountSid (NULL, (tu->User).Sid, userName, &dwRequiredSize,
								domainName, &dwRequiredSize, &eUse);

		fprintf (fDebug, "USER: [%s\\%s]\n", domainName, userName);
		fflush (fDebug);
		delete [] userName;
		delete [] domainName;
	}
	else
	{
		fprintf (fDebug, " FAILED : %d\n", dwLastError);
		fflush (fDebug);
	}
	
	delete [] tu;
	status = false;
	dwRequiredSize = 0;

	// Step 2 - get privilege info
	if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
	{
		delete [] tp;
		dwSize = dwRequiredSize;
		dwRequiredSize = 0;

		tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

		if (!tp)
		{
			fclose (fDebug);
			return;
		}

		if (!GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
		{
			dwLastError = GetLastError ();
		}
		else
			status = true;
	}
	else
		status = true;

	if (status)
	{
		fprintf (fDebug, "PRIVILEGES: [%d]\n", tp->PrivilegeCount);
		fflush (fDebug);
	
		for (DWORD i = 0; i < tp->PrivilegeCount; i++)
		{
			DWORD dwNameSize = 256;
			LPTSTR name = new TCHAR [dwNameSize + 1];

			if (!name)
			{
				delete [] tp;
				fclose (fDebug);
				return;
			}

			DWORD dwRequiredSize = dwNameSize;

			if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
			{
				BOOL enabDefault = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT);
				BOOL enabled = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED);
				BOOL usedForAccess (tp->Privileges [i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS);

				fprintf (fDebug, " %s: enabledByDefault=%d enabled=%d usedForAccess=%d\n", 
							name, enabDefault, enabled, usedForAccess);
				fflush (fDebug);
			}
			else
			{
				dwLastError = GetLastError ();
				delete [] name;
				dwNameSize = dwRequiredSize;
				name = new TCHAR [dwRequiredSize];

				if (!name)
				{
					delete [] tp;
					fclose (fDebug);
					return;
				}

				if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
				{
					BOOL enabDefault = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT);
					BOOL enabled = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED);
					BOOL usedForAccess (tp->Privileges [i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS);
					fprintf (fDebug, " %s: enabledByDefault=%d enabled=%d usedForAccess=%d\n", 
							name, enabDefault, enabled, usedForAccess);
					fflush (fDebug);
				}
				else
					dwLastError = GetLastError ();
			}

			delete [] name;
		}
	}
	else
	{
		fprintf (fDebug, " FAILED : %d\n", dwLastError);
		fflush (fDebug);
	}

	delete [] tp;
	fclose (fDebug);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\services.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SERVICES.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemServicesEx
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pService,
	BSTR bsNamespacePath,
	BSTR bsAuthority,
	BSTR bsUser,
	BSTR bsPassword,
	CWbemLocatorSecurity *pSecurityInfo,
	BSTR bsLocale)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	m_SecurityInfo = new CSWbemSecurity (pService,
					bsAuthority, bsUser, bsPassword, pSecurityInfo);

	if (bsLocale)
		m_bsLocale = SysAllocString (bsLocale);

	if (bsNamespacePath)
		m_bsNamespacePath = bsNamespacePath;
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pService,
	BSTR bsNamespacePath,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	m_SecurityInfo = new CSWbemSecurity (pService, pCoAuthIdentity,
					bsPrincipal, bsAuthority);

	if (bsNamespacePath)
		m_bsNamespacePath = bsNamespacePath;
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to clone a new CSWbemServices from an exisiting
//	instance.  The security info object is copied from the original instance
//	(which clones the underlying proxy), and the security settings are modified
//	appropriately if an override security instance is also passed in.  This
//	constructor is used when creating a CSWbemObject.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	CSWbemServices *pService,
	CSWbemSecurity *pSecurity)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);
	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	if (pService)
	{
		/*
		 * Make a new security object from the one contained in the original
		 * CSWbemServices.  Note that this will copy the IWbemServices proxy
		 * so we have an independently securable proxy for this new object.
		 */
		CSWbemSecurity *pServiceSecurity = pService->GetSecurityInfo ();

		if (pServiceSecurity)
		{
			m_SecurityInfo = new CSWbemSecurity (pServiceSecurity);
			pServiceSecurity->Release ();
		}

		/*
		 * If an overriding security pointer was passed in, use its' settings to
		 * modify our local security pointer.
		 */
		if (pSecurity)
		{
			IUnknown *pUnk = pSecurity->GetProxy ();

			if (pUnk)
			{
				if (m_SecurityInfo)
					m_SecurityInfo->SecureInterfaceRev (pUnk);

				pUnk->Release ();
			}
		}

		// Copy the locale
		m_bsLocale = SysAllocString (pService->GetLocale ());

		// Copy the path
		m_bsNamespacePath = pService->GetPath ();
	}
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to clone a new CSWbemServices from an exisiting
//	ISWbemInternalServices interface.  The security info object is copied from 
//	the original instance (which clones the underlying proxy).  This
//	constructor is used when creating a CSWbemRefreshableItem.
//
//***************************************************************************

CSWbemServices::CSWbemServices (
	ISWbemInternalServices *pISWbemInternalServices)
	: m_SecurityInfo (NULL), 
	  m_pUnsecuredApartment (NULL), 
	  m_bsLocale (NULL),
	  m_cRef (0),
	  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);
	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	if (pISWbemInternalServices)
	{
		// Copy the locale
		pISWbemInternalServices->GetLocale (&m_bsLocale);

		// Copy the path
		pISWbemInternalServices->GetNamespacePath (&m_bsNamespacePath);

		/*
		 * Make a new security object from the one contained in the original
		 * ISWbemServices.  Note that this will copy the IWbemServices proxy
		 * so we have an independently securable proxy for this new object.
		 */
		ISWbemInternalSecurity *pISWbemInternalSecurity = NULL;
		pISWbemInternalServices->GetISWbemInternalSecurity (&pISWbemInternalSecurity);

		if (pISWbemInternalSecurity)
		{
			CComPtr<IWbemServices>	pIWbemServices;

			if (SUCCEEDED(pISWbemInternalServices->GetIWbemServices (&pIWbemServices)))
			{
				m_SecurityInfo = new CSWbemSecurity (pIWbemServices, 
											pISWbemInternalSecurity);
				pISWbemInternalSecurity->Release ();
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to build a new CSWbemServices from an IWbemServices
//	and a existing CSWbemServices
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pIWbemServices,
	CSWbemServices	*pCSWbemServices
	) : m_SecurityInfo (NULL), 
	    m_pUnsecuredApartment(NULL), 
	    m_bsLocale (NULL),
		m_cRef (0),
		m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServices *)this, IID_ISWbemServices, 
					CLSID_SWbemServices, L"SWbemServices");
    
	if (pIWbemServices) 
	{
		// Make a new security cache based on the proxy passed in, but use the
		// settings from the existing object
		CSWbemSecurity *pSecurity = NULL;
		
		if (pCSWbemServices)
			pSecurity = pCSWbemServices->GetSecurityInfo ();
		
		m_SecurityInfo = new CSWbemSecurity (pIWbemServices, pSecurity);

		if (pSecurity)
			pSecurity->Release ();

		// Copy the locale and path
		if (pCSWbemServices)
		{
			m_bsLocale = SysAllocString (pCSWbemServices->GetLocale ());
			m_bsNamespacePath = pCSWbemServices->GetPath ();
		}
	}
}

//***************************************************************************
//
//  CSWbemServices::~CSWbemServices
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemServices::~CSWbemServices(void)
{
	RELEASEANDNULL(m_SecurityInfo)
	FREEANDNULL(m_bsLocale)
	RELEASEANDNULL(m_pUnsecuredApartment)

	InterlockedDecrement(&g_cObj);
}

IUnsecuredApartment *CSWbemServices::GetCachedUnsecuredApartment()
{
	// If we have one just return with it.  If not create one. 
	// This is released in the destructor
	if (!m_pUnsecuredApartment) 
	{
		HRESULT hr;
		 hr = CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
												 IID_IUnsecuredApartment, (LPVOID *) &m_pUnsecuredApartment);
		if (FAILED(hr))
			m_pUnsecuredApartment = NULL;
	}

	// AddRef so caller must release
	if (m_pUnsecuredApartment)
		m_pUnsecuredApartment->AddRef ();

	return m_pUnsecuredApartment;
}

//***************************************************************************
// HRESULT CSWbemServices::QueryInterface
// long CSWbemServices::AddRef
// long CSWbemServices::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
	*ppv = NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemServices==riid)
		*ppv = (ISWbemServices *)this;
	else if (IID_ISWbemServicesEx==riid)
		*ppv = (ISWbemServicesEx *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)((ISWbemServicesEx *)this);
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISupportErrorInfo==riid)
        *ppv = (ISupportErrorInfo *)this;
	else if (IID_ISWbemInternalServices==riid)
		*ppv = (ISWbemInternalServices *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemServices::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemServices::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemServices::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemServices::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  m_Dispatch.GetTypeInfoCount(pctinfo);}
STDMETHODIMP		CSWbemServices::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemServices::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
STDMETHODIMP		CSWbemServices::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemServices::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid);}
STDMETHODIMP		CSWbemServices::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemServices::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
					pdispparams, pvarResult, pexcepinfo, puArgErr);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemServices::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemServices::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetDispID(bstrName, grfdex, pid);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemServices::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemServices::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	m_pIServiceProvider = pspCaller;

	hr = m_Dispatch.InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);

	m_pIServiceProvider = NULL;

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemServices::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemServices::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByDispID(id);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemServices::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberProperties(id, grfdexFetch, pgrfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemServices::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberName(id, pbstrName);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemServices::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemServices::GetNextDispID()";)
	_RPrint(me, "Called", 0, "");

	return m_Dispatch.GetNextDispID(grfdex, id, pid);

}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemServices::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetNameSpaceParent(ppunk);
}


//***************************************************************************
// HRESULT CSWbemServices::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return ((IID_ISWbemServices == riid) ||
		    (IID_ISWbemServicesEx == riid)) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Get
//
//  DESCRIPTION:
//
//  Get an instance or class from a namespace
//
//  PARAMETERS:
//
//		bsObjectPath		Relative object path to class or instance
//		lFlags				Flags
//		pContext			If specified, additional context
//		ppObject			On successful return addresses an
//							ISWbemObject
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Get (
	BSTR objectPath,
	long lFlags,
    /*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObject **ppObject
)
{
	_RD(static char *me = "CSWbemServices::Get";)
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pIWbemClassObject = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			_RPrint(me, "Called - context: ", (long)pIContext, "");
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->GetObject (
						(objectPath && (0 < wcslen(objectPath))) ? objectPath : NULL,
						lFlags,
						pIContext,
						&pIWbemClassObject,
						NULL);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				// Create a new CSWbemObject using the IWbemClassObject interface
				// just returned.

				CSWbemObject *pObject = new CSWbemObject (this, pIWbemClassObject);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
												(PPVOID) ppObject)))
					delete pObject;

				pIWbemClassObject->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Delete
//
//  DESCRIPTION:
//
//  Delete an instance or class from a namespace
//
//  PARAMETERS:
//
//		bsObjectPath	Relative path of class or instance
//		pKeyValue		Single key value
//		lFlags			Flags
//		pContext		Any context info
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Delete (
	BSTR bsObjectPath,
    long lFlags,
    /*ISWbemValueBag*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();
	
	if (m_SecurityInfo)
	{
		CWbemPathCracker pathCracker (bsObjectPath);

		if ((CWbemPathCracker::WbemPathType::wbemPathTypeError != pathCracker.GetType ()) &&
			pathCracker.IsClassOrInstance ())
		{
			CComPtr<IWbemServices> pIWbemServices = GetIWbemServices ();

			if (pIWbemServices)
			{
				// Get the context
				IWbemContext *pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;

				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				{
					if (pathCracker.IsInstance ())
						hr = pIWbemServices->DeleteInstance (bsObjectPath, lFlags, pIContext, NULL);
					else
						hr = pIWbemServices->DeleteClass (bsObjectPath, lFlags, pIContext, NULL);
				}
				
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			}
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::InstancesOf
//
//  DESCRIPTION:
//
//  Create an enumerator for instances
//
//  PARAMETERS:
//
//		bsClass			Underlying class basis for enumeration
//		lFlags			Flags
//		pContext		Any context info
//		ppEnum			On successful return holds the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::InstancesOf	(
	BSTR bsClass,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CreateInstanceEnum (bsClass, lFlags, pIContext, &pIEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecQuery
//
//  DESCRIPTION:
//
//  Execute a query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecQuery (
	BSTR bsQuery,
	BSTR bsQueryLanguage,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();
#ifdef __RTEST_RPC_FAILURE
	extern int __Rx;
	extern bool __Rdone;

	__Rx = 0;
	__Rdone = false;
#endif

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}


	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::AssociatorsOf
//
//  DESCRIPTION:
//
//  Return the associators of a class or instance
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::AssociatorsOf (
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppEnum) || (NULL == strObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			// Format the query string
			BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
			BSTR bsQuery = FormatAssociatorsQuery (strObjectPath, strAssocClass, strResultClass, strResultRole,
								strRole, bClassesOnly, bSchemaOnly, strRequiredAssocQualifier, strRequiredQualifier);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}


			SetWbemError (this);

			SysFreeString (bsQuery);
			SysFreeString (bsQueryLanguage);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemServices::ReferencesTo
//
//  DESCRIPTION:
//
//  Return the references to a class or instance
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ReferencesTo (
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppEnum) || (NULL == strObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			// Format the query string
			BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
			BSTR bsQuery = FormatReferencesQuery (strObjectPath, strResultClass, strRole,
							bClassesOnly, bSchemaOnly, strRequiredQualifier);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			SysFreeString (bsQuery);
			SysFreeString (bsQueryLanguage);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecNotificationQuery
//
//  DESCRIPTION:
//
//  Execute a notification query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEvents			Returns the events iterator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecNotificationQuery (
	BSTR bsQuery,
	BSTR bsQueryLanguage,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemEventSource **ppEvents)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEvents)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecNotificationQuery
						(bsQueryLanguage, bsQuery, lFlags, pIContext, &pIEnum);

			if (SUCCEEDED(hr))
			{
				CSWbemEventSource *pEvents = new CSWbemEventSource (this, pIEnum);

				if (!pEvents)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEvents->QueryInterface (IID_ISWbemEventSource, (PPVOID) ppEvents)))
					delete pEvents;

				pIEnum->Release ();
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecMethod
//
//  DESCRIPTION:
//
//  Execute a method
//
//  PARAMETERS:
//
//		bsObjectPath		Relative path to object
//		bsMethod			The name of the method to call
//		pInParams			The in-parameters
//		lFlags				Flags
//		pContext			Any context information
//		ppOutParams			The out-parameters
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecMethod (
	BSTR bsObjectPath,
	BSTR bsMethod,
	/*ISWbemObject*/ IDispatch *pInParams,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObject **ppOutParams
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pIInParams = CSWbemObject::GetIWbemClassObject (pInParams);
			IWbemClassObject *pIOutParams = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecMethod
						(bsObjectPath, bsMethod, lFlags, pIContext, pIInParams, &pIOutParams, NULL);

			if (SUCCEEDED(hr))
			{
				if (pIOutParams)
				{
					if (ppOutParams)
					{
						CSWbemObject *pObject = new CSWbemObject (this, pIOutParams);

						if (!pObject)
							hr = WBEM_E_OUT_OF_MEMORY;
						else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
											(PPVOID) ppOutParams)))
							delete pObject;

					}

					pIOutParams->Release ();
				}
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			if (pIInParams)
				pIInParams->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::SubclassesOf
//
//  DESCRIPTION:
//
//  Create an enumerator for classes
//
//  PARAMETERS:
//
//		bsSuperClass	Underlying class basis for enumeration
//		lFlags			Flags
//		pContext		Any context info
//		ppEnum			On successful return holds the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::SubclassesOf	(
	BSTR bsSuperClass,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CreateClassEnum
						(bsSuperClass, lFlags, pIContext, &pIEnum);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Put
//
//  DESCRIPTION:
//
//  Save/commit a class or instance into this namespace
//
//  PARAMETERS:
//
//		objWbemObject	Class/Instance to be saved
//		lFlags			Flags
//		pContext		Context
//		ppObjectPath	Object Path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Put (
	ISWbemObjectEx *objWbemObject,
    long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == objWbemObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pObject = CSWbemObject::GetIWbemClassObject (objWbemObject);
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			if (NULL != pObject)
			{
				// Figure out whether this is a class or instance
				VARIANT var;
				VariantInit (&var);

				if (WBEM_S_NO_ERROR == pObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
				{
					IWbemCallResult *pResult = NULL;
					HRESULT hrCallResult = WBEM_E_FAILED;

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;

					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (WBEM_GENUS_CLASS  == var.lVal)
								hrCallResult = pIWbemServices->PutClass
										(pObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
							else
								hrCallResult = pIWbemServices->PutInstance
										(pObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
						if (needToResetSecurity)
							m_SecurityInfo->ResetSecurity (hThreadToken);
					}

					if (WBEM_S_NO_ERROR == hrCallResult)
					{
						//Secure the IWbemCallResult interface
						m_SecurityInfo->SecureInterface (pResult);

						if ((WBEM_S_NO_ERROR == (hrCallResult = pResult->GetCallStatus (INFINITE, &hr))) &&
							(WBEM_S_NO_ERROR == hr))
						{
							if (ppObjectPath)
							{
								ISWbemObjectPath *pObjectPath =	new CSWbemObjectPath (m_SecurityInfo, GetLocale());

								if (!pObjectPath)
									hr = WBEM_E_OUT_OF_MEMORY;
								else
								{
									pObjectPath->AddRef ();
									pObjectPath->put_Path (GetPath ());
									
									if (WBEM_GENUS_CLASS == var.lVal)
									{
										VARIANT nameVar;
										VariantInit (&nameVar);

										/*
										 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
										 * the __CLASS property has not yet been set.
										 */

										if ((WBEM_S_NO_ERROR == pObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
											&& (VT_BSTR == V_VT(&nameVar)))
										{
											pObjectPath->put_Class (nameVar.bstrVal);
											*ppObjectPath = pObjectPath;
										}

										VariantClear (&nameVar);
									}
									else
									{
										// Now get the relpath string from the call result
										BSTR resultString = NULL;

										if (WBEM_S_NO_ERROR == pResult->GetResultString (INFINITE, &resultString))
										{
											pObjectPath->put_RelPath (resultString);
											*ppObjectPath = pObjectPath;
											SysFreeString (resultString);
										}
									}
								}
							}
						}
					}
					else
						hr = hrCallResult;

					if (pResult)
						pResult->Release ();
				}

				if (pIContext)
					pIContext->Release ();

				pObject->Release ();

				VariantClear (&var);
			}
		
			SetWbemError (this);
			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemServices::GetIWbemServices
//
//  DESCRIPTION:
//
//  Return the IWbemServices interface corresponding to this
//	scriptable wrapper.
//
//  PARAMETERS:
//		ppServices		holds the IWbemServices pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::GetIWbemServices (IWbemServices **ppServices)
{
	HRESULT hr = E_FAIL;

	if (ppServices)
	{
		*ppServices = GetIWbemServices ();
		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  CSWbemServices::GetIWbemServices
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemServicesEx
//	interface, return the underlying IWbemServices interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemServices interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

IWbemServices	*CSWbemServices::GetIWbemServices (
	IDispatch *pDispatch
)
{
	IWbemServices *pServices = NULL;
	ISWbemInternalServices *pIServices = NULL;

	if (pDispatch)
	{
		if (SUCCEEDED (pDispatch->QueryInterface 
								(IID_ISWbemInternalServices, (PPVOID) &pIServices)))
		{
			pIServices->GetIWbemServices (&pServices);
			pIServices->Release ();
		}
	}

	return pServices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\security.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  security.h
//
//  alanbos  25-Sep-98   Created.
//
//  Defines the CSWbemSecurity and subsiduary objects
//
//***************************************************************************

#ifndef _SECURITY_H_
#define _SECURITY_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemLocatorSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for SWbemLocator objects.  
//
//***************************************************************************

class CWbemLocatorSecurity : public ISWbemSecurity,
							 public ISupportErrorInfo,
							 public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	bool						m_impLevelSet;
	WbemImpersonationLevelEnum	m_impLevel;
	bool						m_authnLevelSet;
	WbemAuthenticationLevelEnum m_authnLevel;
	
protected:
	long            m_cRef;         //Object reference count

public:
    CWbemLocatorSecurity (CSWbemPrivilegeSet *pPrivilegeSet);
	CWbemLocatorSecurity (CWbemLocatorSecurity *pCWbemLocatorSecurity);
	virtual ~CWbemLocatorSecurity (void);

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
	STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
	STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
						  lcid,
						  rgdispid);}
	STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
						pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// CWbemLocatorSecurity methods
	bool IsImpersonationSet () { return m_impLevelSet; }
	bool IsAuthenticationSet () { return m_authnLevelSet; }
	BOOL SetSecurity (BSTR bsUser, bool &needToResetSecurity, HANDLE &hThreadToken);
	void ResetSecurity (HANDLE hThreadToken);

	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}
};
	
//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for non-SWbemLocator objects.  
//
//***************************************************************************

class CSWbemSecurity : public ISWbemSecurity,
					   public ISupportErrorInfo,
					   public ISWbemInternalSecurity,
					   public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	CSWbemProxyCache			*m_pProxyCache;
	IUnknown					*m_pCurProxy;

	CSWbemProxyCache	*GetProxyCache ()
	{
		CSWbemProxyCache *pCache = m_pProxyCache;

		if (pCache)
			pCache->AddRef ();

		return pCache;
	}

	// Sundry statics
	static bool			s_bInitialized;
	static bool			s_bIsNT;
	static DWORD		s_dwNTMajorVersion;
	static HINSTANCE	s_hAdvapi;
	static bool			s_bCanRevert;
	static WbemImpersonationLevelEnum s_dwDefaultImpersonationLevel;
	
protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemSecurity (IUnknown *pUnk,
					BSTR bsAuthority = NULL,
					BSTR bsUser = NULL, BSTR bsPassword = NULL,
					CWbemLocatorSecurity *pSecurity = NULL);
	CSWbemSecurity (IUnknown *pUnk,
					COAUTHIDENTITY *pCoAuthIdentity,
					BSTR bsPrincipal,
					BSTR bsAuthority);
	CSWbemSecurity (CSWbemSecurity *pSecurity);
	CSWbemSecurity (IUnknown *pUnk,
					CSWbemSecurity *pSecurity);
	CSWbemSecurity (IUnknown *pUnk,
					ISWbemInternalSecurity *pSecurity);
    virtual ~CSWbemSecurity (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);
	
	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// ISWbemInternalSecurity methods
	HRESULT STDMETHODCALLTYPE GetAuthority (BSTR *bsAuthority);
	HRESULT STDMETHODCALLTYPE GetUPD (BSTR *bsUser, BSTR *bsPassword, BSTR *bsDomain);
	HRESULT STDMETHODCALLTYPE GetPrincipal (BSTR *bsPrincipal);
	
	// CSWbemSecurity methods

	COAUTHIDENTITY *GetCoAuthIdentity () { return (m_pProxyCache ? m_pProxyCache->GetCoAuthIdentity () : NULL); }
	BSTR GetPrincipal () { return (m_pProxyCache ? m_pProxyCache->GetPrincipal (): NULL); }
	BSTR GetAuthority () { return (m_pProxyCache ? m_pProxyCache->GetAuthority (): NULL); }
	bool IsUsingExplicitUserName () { return (m_pProxyCache ? m_pProxyCache->IsUsingExplicitUserName (): false); }

	IUnknown *GetProxy () 
	{
		IUnknown *pProxy = m_pCurProxy;

		if (pProxy)
			pProxy->AddRef ();

		return pProxy;
	}

	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}

	void SecureInterface (IUnknown *pUnk);
	void SecureInterfaceRev (IUnknown *pUnk);

	// Sundry Privilege-related functions
	static void AdjustTokenPrivileges (HANDLE hHandle, CSWbemPrivilegeSet *pPrivilegeSet);
	static BOOL LookupPrivilegeValue (LPCTSTR lpName, PLUID pLuid);
	static void LookupPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName);
	
	BOOL	SetSecurity (bool &needToResetSecurity, HANDLE &hThreadToken);
	void	ResetSecurity (HANDLE hThreadToken);

	// Used to define resources
	static	void Initialize ();
	static	void Uninitialize ();

	// Sundry OS versioning helper routines
	static bool	 IsNT () { return s_bIsNT; }
	static DWORD GetNTMajorVersion () { return s_dwNTMajorVersion; }
	static bool	 CanRevertToSelf () { return s_bCanRevert; }
	static WbemImpersonationLevelEnum GetDefaultImpersonationLevel () 
				{ return s_dwDefaultImpersonationLevel; }
	static bool	 IsImpersonating (bool useDefaultUser, bool useDefaultAuthority);

#ifdef WSCRPDEBUG
	static void PrintPrivileges (HANDLE hToken);
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\qualvar.h ===
//***************************************************************************
//
//  qualvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CQualSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _QUALVAR_H_
#define _QUALVAR_H_

// This class implements the IEnumVARIANT interface

class CQualSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemQualifierSet	*m_pQualifierSet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();;

public:
	CQualSetEnumVar (CSWbemQualifierSet *pContext, 
					 ULONG initialPos = 0);
	~CQualSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\refresher.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  REFRESHER.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemRefresher and ISWbemRefreshableItem
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemRefresher::CSWbemRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemRefreshableItem::CSWbemRefreshableItem(
			ISWbemRefresher *pRefresher, 
			long iIndex,
			IDispatch *pServices,
			IWbemClassObject *pObject, 
			IWbemHiPerfEnum *pObjectSet
)
				: m_pISWbemRefresher (pRefresher),
				  m_iIndex (iIndex),
				  m_bIsSet (VARIANT_FALSE),
				  m_pISWbemObjectEx (NULL),
				  m_pISWbemObjectSet (NULL),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemRefreshableItem, 
					CLSID_SWbemRefreshableItem, L"SWbemRefreshableItem");

	// Note that we do NOT AddRef m_pISWbemRefresher. To do so would create
	// a circular reference between this object and the refresher, since the
	// refresher's map already holds a reference to this object. 
	
	if (pServices)
	{
		CComQIPtr<ISWbemInternalServices>  pISWbemInternalServices (pServices);

		if (pISWbemInternalServices)
		{
			CSWbemServices *pCSWbemServices = new CSWbemServices (pISWbemInternalServices);

			if (pCSWbemServices)
				pCSWbemServices->AddRef ();
			
			if (pObject)
			{
				// Create a new CSWbemObject for ourselves
				CSWbemObject *pCSWbemObject = new CSWbemObject (pCSWbemServices, pObject);

				if (pCSWbemObject)
					pCSWbemObject->QueryInterface (IID_ISWbemObjectEx, (void**) &m_pISWbemObjectEx);
			}

			if (pObjectSet)
			{
				// Create a new CSWbemHiPerfObjectSet for ourselves
				CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet = 
							new CSWbemHiPerfObjectSet (pCSWbemServices, pObjectSet);
				
				if (pCSWbemHiPerfObjectSet)
				{
					pCSWbemHiPerfObjectSet->QueryInterface (IID_ISWbemObjectSet, (void**) &m_pISWbemObjectSet);
					m_bIsSet = VARIANT_TRUE;
				}
			}

			if (pCSWbemServices)
				pCSWbemServices->Release ();
		}
	}

    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemRefreshableItem::~CSWbemRefreshableItem
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemRefreshableItem::~CSWbemRefreshableItem(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pISWbemObjectEx)
	{
		m_pISWbemObjectEx->Release ();
		m_pISWbemObjectEx = NULL;
	}

	if (m_pISWbemObjectSet)
	{
		m_pISWbemObjectSet->Release ();
		m_pISWbemObjectSet = NULL;
	}
}

//***************************************************************************
// HRESULT CSWbemRefreshableItem::QueryInterface
// long CSWbemRefreshableItem::AddRef
// long CSWbemRefreshableItem::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemRefreshableItem::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemRefreshableItem==riid)
		*ppv = (ISWbemRefresher *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemRefreshableItem::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemRefreshableItem::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CSWbemRefresher::CSWbemRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemRefresher::CSWbemRefresher()
				: m_iCount (0),
				  m_bAutoReconnect (VARIANT_TRUE),
				  m_pIWbemConfigureRefresher (NULL),
				  m_pIWbemRefresher (NULL),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemRefresher, 
					CLSID_SWbemRefresher, L"SWbemRefresher");
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemRefresher::~CSWbemRefresher
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemRefresher::~CSWbemRefresher(void)
{
    InterlockedDecrement(&g_cObj);

	// Remove all items from the refresher
	DeleteAll ();

	if (m_pIWbemConfigureRefresher)
		m_pIWbemConfigureRefresher->Release ();

	if (m_pIWbemRefresher)
		m_pIWbemRefresher->Release ();
}

//***************************************************************************
// HRESULT CSWbemRefresher::QueryInterface
// long CSWbemRefresher::AddRef
// long CSWbemRefresher::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemRefresher::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemRefresher==riid)
		*ppv = (ISWbemRefresher *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemRefresher::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemRefresher::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumRefresher *pEnumRefresher = new CEnumRefresher (this);

		if (!pEnumRefresher)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumRefresher->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnumRefresher;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_ObjectMap.size ();
		hr = S_OK;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Add
//
//  DESCRIPTION:
//
//  Add a single instance to the refresher  
//
//  PARAMETERS:
//
//		pISWbemServicesEx		the SWbemServicesEx to use
//		bsInstancePath			the relative path of the instance
//		iFlags					flags
//		pSWbemContext			context
//		ppSWbemRefreshableItem	addresses the SWbemRefreshableItem on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Add (
	ISWbemServicesEx *pISWbemServicesEx,
	BSTR bsInstancePath,
	long iFlags,
	IDispatch *pSWbemContext,
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppSWbemRefreshableItem) || (NULL == pISWbemServicesEx) || (NULL == bsInstancePath))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		// Extract the context
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIWbemContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pSWbemContext));

		// Extract the IWbemServices
		CComPtr<IWbemServices> pIWbemServices = CSWbemServices::GetIWbemServices (pISWbemServicesEx);

		if (pIWbemServices)
		{
			// Get our refresher - may need to create on demand	
			if (NULL == m_pIWbemConfigureRefresher)
				CreateRefresher ();

			if (m_pIWbemConfigureRefresher)
			{
				IWbemClassObject *pObject = NULL;
				long iIndex = 0;

				if (SUCCEEDED(hr = m_pIWbemConfigureRefresher->AddObjectByPath (pIWbemServices,
							bsInstancePath, iFlags, pIWbemContext, &pObject, &iIndex)))
				{
					CSWbemRefreshableItem *pRefreshableItem = new
											CSWbemRefreshableItem (this, iIndex,
												pISWbemServicesEx, pObject, NULL);

					if (!pRefreshableItem)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr =pRefreshableItem->QueryInterface (IID_ISWbemRefreshableItem, 
										(void**) ppSWbemRefreshableItem)))
					{
						m_ObjectMap [iIndex] = pRefreshableItem;
						pRefreshableItem->AddRef ();
					}
					else
						delete pRefreshableItem;
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::AddEnum
//
//  DESCRIPTION:
//
//  Add a single enum (shallow instance) to the refresher  
//
//  PARAMETERS:
//
//		pISWbemServicesEx		the SWbemServicesEx to use
//		bsClassName				the name of the class
//		iFlags					flags
//		pSWbemContext			context
//		ppSWbemRefreshableItem	addresses the SWbemRefreshableItem on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::AddEnum (
	ISWbemServicesEx *pISWbemServicesEx,
	BSTR bsClassName,
	long iFlags,
	IDispatch *pSWbemContext,
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppSWbemRefreshableItem) || (NULL == pISWbemServicesEx) 
			|| (NULL == bsClassName))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		// Extract the context
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIWbemContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pSWbemContext));

		// Extract the IWbemServices
		CComPtr<IWbemServices> pIWbemServices = CSWbemServices::GetIWbemServices (pISWbemServicesEx);

		if (pIWbemServices)
		{
			// Get our refresher - may need to create on demand	
			if (NULL == m_pIWbemConfigureRefresher)
				CreateRefresher ();

			if (m_pIWbemConfigureRefresher)
			{
				IWbemHiPerfEnum *pIWbemHiPerfEnum = NULL;
				long iIndex = 0;

				if (SUCCEEDED(hr = m_pIWbemConfigureRefresher->AddEnum (pIWbemServices,
							bsClassName, iFlags, pIWbemContext, &pIWbemHiPerfEnum, &iIndex)))
				{
					CSWbemRefreshableItem *pRefreshableItem = new
											CSWbemRefreshableItem (this, iIndex,
												pISWbemServicesEx, NULL, pIWbemHiPerfEnum);

					if (!pRefreshableItem)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr =pRefreshableItem->QueryInterface (IID_ISWbemRefreshableItem, 
										(void**) ppSWbemRefreshableItem)))
					{
						m_ObjectMap [iIndex] = pRefreshableItem;
						pRefreshableItem->AddRef ();
					}
					else
						delete pRefreshableItem;
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Remove
//
//  DESCRIPTION:
//
//  Remove object from refresher  
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve
//		iFlags			Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Remove (
	long iIndex, 
	long iFlags
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pIWbemConfigureRefresher)
	{
		if (0 != iFlags)
			hr = WBEM_E_INVALID_PARAMETER;
		else
		{
			hr = m_pIWbemConfigureRefresher->Remove (iIndex,
						(VARIANT_TRUE == m_bAutoReconnect) ? 
							WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
							WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);

			if (WBEM_S_FALSE == hr)
				hr = WBEM_E_NOT_FOUND;

			if (SUCCEEDED(hr))
			{
				// Now remove from our collection
				RefreshableItemMap::iterator theIterator = m_ObjectMap.find (iIndex);

				if (theIterator != m_ObjectMap.end ())
					EraseItem (theIterator);
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all items from refresher  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::DeleteAll (
)
{
	ResetLastErrors ();
	RefreshableItemMap::iterator next; 
		
	while ((next = m_ObjectMap.begin ()) != m_ObjectMap.end ())
	{
		CSWbemRefreshableItem *pRefreshableItem = (*next).second;
		long iIndex = 0;

		if (m_pIWbemConfigureRefresher && pRefreshableItem &&
				SUCCEEDED(pRefreshableItem->get_Index (&iIndex)))
		{
			HRESULT hr = m_pIWbemConfigureRefresher->Remove (iIndex,
						(VARIANT_TRUE == m_bAutoReconnect) ? 
							WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
							WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
		}

		EraseItem (next);
	}
	
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Refresh
//
//  DESCRIPTION:
//
//  Refresh all objects in this refresher.  
//
//  PARAMETERS:
//
//		lFlags			Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Refresh (
	long iFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (0 != iFlags) 
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemRefresher)
	{
		hr = m_pIWbemRefresher->Refresh ((VARIANT_TRUE == m_bAutoReconnect) ? 
						WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
						WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by index.  
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve
//		lFlags			Flags
//		ppSWbemRefreshableItem	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Item (
	long iIndex, 
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (NULL == ppSWbemRefreshableItem)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppSWbemRefreshableItem = NULL;
		RefreshableItemMap::iterator theIterator;
		theIterator = m_ObjectMap.find (iIndex);

		if (theIterator != m_ObjectMap.end ())
		{
			CSWbemRefreshableItem *pRefreshableItem = (*theIterator).second;

			if (SUCCEEDED(pRefreshableItem->QueryInterface 
					(IID_ISWbemRefreshableItem, (PPVOID) ppSWbemRefreshableItem)))
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  void CSWbemRefresher::CreateRefresher
//
//  DESCRIPTION:
//
//  Create the underlying WMI refresher objects.  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//		none
//***************************************************************************

void CSWbemRefresher::CreateRefresher ()
{
	HRESULT hr;

	if (NULL == m_pIWbemRefresher)
	{
		if (SUCCEEDED(hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, 
										IID_IWbemRefresher, (void**) &m_pIWbemRefresher )))
		{
			IWbemConfigureRefresher *pConfigureRefresher = NULL;

			// Get ourselves a refresher configurator
			hr = m_pIWbemRefresher->QueryInterface (IID_IWbemConfigureRefresher, 
													(void**) &m_pIWbemConfigureRefresher);
		}
	}
}

//***************************************************************************
//
//  void CSWbemRefresher::EraseItem
//
//  DESCRIPTION:
//
//  Scrub out an item.  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//		none
//***************************************************************************

void CSWbemRefresher::EraseItem (RefreshableItemMap::iterator iterator)
{
	CSWbemRefreshableItem *pRefresherObject = (*iterator).second;

	// Remove from the map
	m_ObjectMap.erase (iterator);

	// Ensure the item is unhooked from the parent. 
	pRefresherObject->UnhookRefresher ();

	// Release the item as it is no longer in the map
	pRefresherObject->Release ();
}

// CEnumRefresher Methods

//***************************************************************************
//
//  CEnumRefresher::CEnumRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumRefresher::CEnumRefresher(CSWbemRefresher *pRefresher)
{
	m_cRef=0;
	m_pCSWbemRefresher = pRefresher;
	m_pCSWbemRefresher->AddRef ();

	m_Iterator = m_pCSWbemRefresher->m_ObjectMap.begin ();
	InterlockedIncrement(&g_cObj);
}

CEnumRefresher::CEnumRefresher(CSWbemRefresher *pRefresher,
							 RefreshableItemMap::iterator iterator) :
		m_Iterator (iterator)
{
	m_cRef=0;
	m_pCSWbemRefresher = pRefresher;
	m_pCSWbemRefresher->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumRefresher::~CEnumRefresher
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumRefresher::~CEnumRefresher(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemRefresher)
		m_pCSWbemRefresher->Release ();
}

//***************************************************************************
// HRESULT CEnumRefresher::QueryInterface
// long CEnumRefresher::AddRef
// long CEnumRefresher::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumRefresher::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumRefresher::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumRefresher::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumRefresher::Reset ()
{
	HRESULT hr = S_FALSE;
	m_Iterator = m_pCSWbemRefresher->m_ObjectMap.begin ();
	return hr;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumRefresher::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pCSWbemRefresher))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pCSWbemRefresher->m_ObjectMap.end ())
			{
				CSWbemRefreshableItem *pCSWbemRefreshableItem = (*m_Iterator).second;
				m_Iterator++;

				ISWbemRefreshableItem *pISWbemRefreshableItem = NULL;

				if (SUCCEEDED(pCSWbemRefreshableItem->QueryInterface 
						(IID_ISWbemRefreshableItem, (PPVOID) &pISWbemRefreshableItem)))
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the QI() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pISWbemRefreshableItem;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumRefresher::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pCSWbemRefresher)
		{
			CEnumRefresher *pEnum = new CEnumRefresher (m_pCSWbemRefresher, m_Iterator);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumRefresher::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pCSWbemRefresher)
	{
		ULONG l2;

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pCSWbemRefresher->m_ObjectMap.end ())
				m_Iterator++;
			else
				break;
		}

		if (l2 == cElements)
			hr = S_OK;
	}

	return hr;
}

// CSWbemHiPerfObjectSet methods

//***************************************************************************
//
//  CSWbemHiPerfObjectSet::CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemHiPerfObjectSet::CSWbemHiPerfObjectSet(CSWbemServices *pService, 
								 IWbemHiPerfEnum *pIWbemHiPerfEnum)
				: m_SecurityInfo (NULL),
				  m_pSWbemServices (pService),
				  m_pIWbemHiPerfEnum (pIWbemHiPerfEnum),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
					CLSID_SWbemObjectSet, L"SWbemObjectSet");
    
	if (m_pIWbemHiPerfEnum)
		m_pIWbemHiPerfEnum->AddRef ();

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		// Use the SWbemServices security object here since
		// IWbemHiPerfEnum is not a remote interface
		CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();
		m_SecurityInfo = new CSWbemSecurity (pSecurity);

		if (pSecurity)
			pSecurity->Release ();
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemHiPerfObjectSet::~CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemHiPerfObjectSet::~CSWbemHiPerfObjectSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_SecurityInfo)
		m_SecurityInfo->Release ();

	if (m_pIWbemHiPerfEnum)
		m_pIWbemHiPerfEnum->Release ();
}

//***************************************************************************
// HRESULT CSWbemHiPerfObjectSet::QueryInterface
// long CSWbemHiPerfObjectSet::AddRef
// long CSWbemHiPerfObjectSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemHiPerfObjectSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectSet==riid)
		*ppv = (ISWbemObjectSet *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemHiPerfObjectSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemHiPerfObjectSet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::ReadObjects
//
//  DESCRIPTION:
//
//  Gets the objects out of the enumerator
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

IWbemObjectAccess **CSWbemHiPerfObjectSet::ReadObjects (
	unsigned long & iCount
)
{
	IWbemObjectAccess **ppIWbemObjectAccess = NULL;
	iCount = 0;

	if (m_pIWbemHiPerfEnum)
	{
		HRESULT hr;

		// Start by getting the object count
		if (WBEM_E_BUFFER_TOO_SMALL == (hr = m_pIWbemHiPerfEnum->GetObjects (0L, 0L,
						NULL, &iCount)))
		{
			ppIWbemObjectAccess = new IWbemObjectAccess*[iCount];

			if (ppIWbemObjectAccess)
			{
				ZeroMemory( ppIWbemObjectAccess, iCount * sizeof(IWbemObjectAccess*) );
				unsigned long dummy = 0;
				hr = m_pIWbemHiPerfEnum->GetObjects ( 0L, iCount, ppIWbemObjectAccess, &dummy );
			}
		}
	}

	return ppIWbemObjectAccess;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumVarHiPerf	*pEnumVar = new CEnumVarHiPerf (this);

		if (!pEnumVar)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumVar->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
				delete pEnumVar;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL == plCount)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		unsigned long iCount = 0;
		IWbemObjectAccess **ppIWbemObjectAccess = ReadObjects (iCount);
		*plCount = iCount;
		hr = WBEM_S_NO_ERROR;
		
		if (ppIWbemObjectAccess)
			delete [] ppIWbemObjectAccess;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppObject) || (NULL == bsObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		CWbemPathCracker objectPath;

		if (objectPath = bsObjectPath)
		{
			unsigned long iCount = 0;
			IWbemObjectAccess **ppIWbemObjectAccess = ReadObjects (iCount);
			bool found = false;

			for (unsigned long i = 0; !found && (i < iCount); i++)
			{
				CComPtr<IWbemClassObject> pIWbemClassObject;
				hr = WBEM_E_NOT_FOUND;
				
				// Iterate through the enumerator to try to find the element with the
				// specified path.
				if (SUCCEEDED(ppIWbemObjectAccess [i]->QueryInterface (IID_IWbemClassObject,
									(void**) &pIWbemClassObject)))
				{
					if (CSWbemObjectPath::CompareObjectPaths (pIWbemClassObject, objectPath))
					{
						// Found it - assign to passed interface and break out
						found = true;
						CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, 
										pIWbemClassObject, m_SecurityInfo);

						if (!pObject)
							hr = WBEM_E_OUT_OF_MEMORY;
						else if (FAILED(pObject->QueryInterface (IID_ISWbemObject, 
								(PPVOID) ppObject)))
						{
							hr = WBEM_E_FAILED;
							delete pObject;
						}
					}
				}
			}

			if (found)
				hr = S_OK;

			if (ppIWbemObjectAccess)
				delete [] ppIWbemObjectAccess;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

// CEnumVarHiPerfHiPerf methods

//***************************************************************************
//
//  CEnumVarHiPerf::CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumVarHiPerf::CEnumVarHiPerf(CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet) :
			m_cRef (0),
			m_iCount (0),
			m_iPos (0),
			m_ppIWbemObjectAccess (NULL),
			m_pCSWbemHiPerfObjectSet (NULL)
{
	if (pCSWbemHiPerfObjectSet)
	{
		m_pCSWbemHiPerfObjectSet = pCSWbemHiPerfObjectSet;
		m_pCSWbemHiPerfObjectSet->AddRef ();
		m_ppIWbemObjectAccess = pCSWbemHiPerfObjectSet->ReadObjects (m_iCount);	
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumVarHiPerf::~CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumVarHiPerf::~CEnumVarHiPerf(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemHiPerfObjectSet)
		m_pCSWbemHiPerfObjectSet->Release ();

	if (m_ppIWbemObjectAccess)
		delete [] m_ppIWbemObjectAccess;
}

//***************************************************************************
// HRESULT CEnumVarHiPerf::QueryInterface
// long CEnumVarHiPerf::AddRef
// long CEnumVarHiPerf::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumVarHiPerf::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumVarHiPerf::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumVarHiPerf::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			CComPtr<IWbemClassObject> pIWbemClassObject;
			
			if (m_iPos < m_iCount)
			{
				if (SUCCEEDED(hr = m_ppIWbemObjectAccess [m_iPos]->QueryInterface 
									(IID_IWbemClassObject, (void**) &pIWbemClassObject)))
				{
					m_iPos++;

					// Make a new ISWbemObjectEx
					CSWbemObject *pCSWbemObject = new CSWbemObject 
									(m_pCSWbemHiPerfObjectSet->GetSWbemServices (), 
										pIWbemClassObject);

					ISWbemObjectEx *pISWbemObjectEx = NULL;

					if (!pCSWbemObject)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr = pCSWbemObject->QueryInterface (IID_ISWbemObjectEx, 
										(PPVOID) &pISWbemObjectEx)))
					{
						// Set the object into the variant array
						pVar[l2].vt = VT_DISPATCH;
						pVar[l2].pdispVal = pISWbemObjectEx;	
					}
					else
					{
						delete pCSWbemObject;
						hr = WBEM_E_FAILED;
					}
				}

				if (FAILED(hr))
						break;
			}
			else
				break; // No more elements
		}

		if (NULL != pcElementFetched)
			*pcElementFetched = l2;

		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;
		CEnumVarHiPerf *pEnumVar = new CEnumVarHiPerf (m_pCSWbemHiPerfObjectSet);

		if (!pEnumVar)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
			delete pEnumVar;

		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_iPos + cElements > m_iCount)
		m_iPos = m_iCount;
	else 
	{
		m_iPos += cElements;
		hr = S_OK;
	}

	SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\services.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  services.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemServices definition.
//
//***************************************************************************

#ifndef _SERVICES_H_
#define _SERVICES_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemServices
//
//  DESCRIPTION:
//
//  Implements the IWbemSServices interface.  
//
//***************************************************************************

class CSWbemServices : public ISWbemServicesEx,
					   public IDispatchEx,
					   public ISupportErrorInfo,
					   public ISWbemInternalServices,
					   public IProvideClassInfo
{
private:

	CComBSTR				m_bsNamespacePath;
	BSTR					m_bsLocale;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity*			m_SecurityInfo;
	IServiceProvider		*m_pIServiceProvider;
	IUnsecuredApartment		*m_pUnsecuredApartment;

	static BSTR			BuildPath (BSTR bsClassName, VARIANT *pKeyValue);
	static BSTR			BuildPath (BSTR bsClassName, 
							/*ISWbemNamedValueSet*/ IDispatch *pCompoundKeys);

protected:
	long            m_cRef;         //Object reference count

public:
    
	CSWbemServices (IWbemServices *pIWbemServices, 
					BSTR bsNamespacePath,
					BSTR bsAuthority, BSTR bsUser, BSTR bsPassword,
					CWbemLocatorSecurity *pSecurity = NULL,
					BSTR bsLocale = NULL);

	CSWbemServices (IWbemServices *pIWbemServices,
					BSTR bsNamespacePath,
					COAUTHIDENTITY *pCoAuthIdentity,
					BSTR bsPrincipal,
					BSTR bsAuthority);

	CSWbemServices (CSWbemServices *pService, CSWbemSecurity *pSecurity);

	CSWbemServices (ISWbemInternalServices *pService);

	CSWbemServices (IWbemServices *pIWbemServices, CSWbemServices *pServiceb);

	IUnsecuredApartment *GetCachedUnsecuredApartment();

    ~CSWbemServices(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
	
    
	// ISWbemInternalServices methods
	STDMETHODIMP GetIWbemServices (IWbemServices **ppService);

	STDMETHODIMP GetNamespacePath (BSTR *bsNamespacePath)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (bsNamespacePath) 
			hr = m_bsNamespacePath.CopyTo (bsNamespacePath);
		
		return hr;
	}

	STDMETHODIMP GetLocale (BSTR *bsLocale)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (bsLocale)
		{
			*bsLocale = SysAllocString (GetLocale ());
			hr = S_OK;
		}

		return hr;
	}

	STDMETHODIMP GetISWbemInternalSecurity (ISWbemInternalSecurity **ppISWbemInternalSecurity)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (ppISWbemInternalSecurity && m_SecurityInfo)
		{
			m_SecurityInfo->QueryInterface (IID_ISWbemInternalSecurity, (void**) ppISWbemInternalSecurity);
			hr = S_OK;
		}

		return hr;
	}
					   
	// ISWbemServices methods

	HRESULT STDMETHODCALLTYPE  Get
	(
        /*[in]*/	BSTR objectPath,
		/*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	    /*[out]*/	ISWbemObject **ppObject
    );

	HRESULT STDMETHODCALLTYPE Delete
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext
    );

	HRESULT STDMETHODCALLTYPE InstancesOf
	(
        /*[in]*/	BSTR className,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE ExecQuery 
	(
        /*[in]*/	BSTR Query,
        /*[in]*/	BSTR QueryLanguage,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
		/*[out]*/	ISWbemObjectSet **ppEnum
    );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery
	(
        /*[in]*/	BSTR Query,
        /*[in]*/	BSTR QueryLanguage,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemEventSource **ppEnum
    );

	HRESULT STDMETHODCALLTYPE AssociatorsOf
	(
		/*[in]*/	BSTR objectPath,
		/*[in]*/	BSTR assocClass,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR resultRole,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredAssocQualifier,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE ReferencesTo
	(
		/*[in]*/	BSTR objectPath,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE ExecMethod 
	(
        /*[in]*/	BSTR className,
        /*[in]*/	BSTR methodName,
        /*[in]*/	/*ISWbemObject*/ IDispatch *pInParams,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObject **ppOutParams
    );

    HRESULT STDMETHODCALLTYPE SubclassesOf
	(
        /*[in]*/	BSTR superclass,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );


	HRESULT STDMETHODCALLTYPE GetAsync
	(
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE DeleteAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE InstancesOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strClass,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE SubclassesOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strSuperclass,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecQueryAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR Query,
		/* [defaultvalue][optional][in] */ BSTR QueryLanguage,
		/* [defaultvalue][optional][in] */ long lFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE AssociatorsOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ BSTR strAssocClass,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strResultRole,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ReferencesToAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR objectPath,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR Query,
		/* [defaultvalue][optional][in] */ BSTR strQueryLanguage,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecMethodAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [in] */ BSTR strMethodName,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISWbemServicesEx methods
	
	HRESULT STDMETHODCALLTYPE Put(
		/* [in] */ ISWbemObjectEx *objWbemObject,
       	/* [in] */ long iFlags,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/* [out, retval] */ ISWbemObjectPath **objWbemObjectPath
        );

	HRESULT STDMETHODCALLTYPE PutAsync(
		/* [in] */ ISWbemSink *objWbemSink,
		/* [in] */ ISWbemObjectEx *objWbemObject,
       	/* [in] */ long iFlags,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemAsyncContext
        );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods

	CSWbemSecurity *GetSecurityInfo ()
	{
		CSWbemSecurity *pInfo = NULL;

		if (m_SecurityInfo)
		{
			pInfo = m_SecurityInfo;
			pInfo->AddRef ();
		}

		return pInfo;
	}

	BSTR GetLocale ()
	{
		return m_bsLocale;
	}

	const CComBSTR & GetPath ()
	{
		return m_bsNamespacePath;
	}

	HRESULT CancelAsyncCall(IWbemObjectSink *sink);

	IWbemServices *GetIWbemServices ()
	{
		IWbemServices *pService = NULL;
		
		if (m_SecurityInfo)
			pService = (IWbemServices *) m_SecurityInfo->GetProxy ();

		return pService;
	}

	static IWbemServices	*GetIWbemServices (IDispatch *pDispatch);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\refresher.h ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  refresher.h
//
//  alanbos  02-Feb-00   Created.
//
//  Refresher helper implementation.
//
//***************************************************************************

#ifndef _REFRESHER_H_
#define _REFRESHER_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemRefreshableItem
//
//  DESCRIPTION:
//
//  Implements the ISWbemRefreshableItem interface.  
//
//***************************************************************************

class CSWbemRefreshableItem : public ISWbemRefreshableItem,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	CDispatchHelp		m_Dispatch;
	ISWbemRefresher		*m_pISWbemRefresher;
	long				m_iIndex;
	VARIANT_BOOL		m_bIsSet;
	ISWbemObjectEx		*m_pISWbemObjectEx;
	ISWbemObjectSet		*m_pISWbemObjectSet;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemRefreshableItem(ISWbemRefresher *pRefresher, long iIndex,
							IDispatch *pServices, 
							IWbemClassObject *pObject, 
							IWbemHiPerfEnum *pObjectSet);
    virtual ~CSWbemRefreshableItem(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// ISWbemRefreshableItem methods
	HRESULT STDMETHODCALLTYPE get_Index (
		/*[out, retval]*/ long *iIndex
		)
	{
		ResetLastErrors ();
		*iIndex = m_iIndex;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_Refresher (
		/*[out, retval]*/ ISWbemRefresher **objWbemRefresher
		)
	{
		ResetLastErrors ();
		*objWbemRefresher = m_pISWbemRefresher;

		if (m_pISWbemRefresher)
			m_pISWbemRefresher->AddRef();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_IsSet (
		/*[out, retval]*/ VARIANT_BOOL *bIsSet
		)
	{
		ResetLastErrors ();
		*bIsSet = m_bIsSet;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_Object (
		/*[out, retval]*/ ISWbemObjectEx **objWbemObject
		)
	{
		ResetLastErrors ();
		*objWbemObject = m_pISWbemObjectEx;

		if (*objWbemObject)
			(*objWbemObject)->AddRef ();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_ObjectSet (
		/*[out, retval]*/ ISWbemObjectSet **objWbemObjectSet
		)
	{
		ResetLastErrors ();
		*objWbemObjectSet = m_pISWbemObjectSet;

		if (*objWbemObjectSet)
			(*objWbemObjectSet)->AddRef ();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE Remove (
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		)
	{
		HRESULT hr = WBEM_E_FAILED;
		ResetLastErrors ();

		if (m_pISWbemRefresher)
			hr = m_pISWbemRefresher->Remove (m_iIndex, 0);

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemRefreshableItem == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	void UnhookRefresher ()
	{
		if (m_pISWbemRefresher)
			m_pISWbemRefresher = NULL;
	}
};

typedef map<long, CSWbemRefreshableItem*, less<long> > RefreshableItemMap;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemRefresher
//
//  DESCRIPTION:
//
//  Implements the ISWbemRefresher interface.  
//
//***************************************************************************
class CEnumRefresher;

class CSWbemRefresher : public ISWbemRefresher,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
friend CEnumRefresher;
private:
	CDispatchHelp		m_Dispatch;
	long				m_iCount;
	VARIANT_BOOL		m_bAutoReconnect;

	IWbemConfigureRefresher	*m_pIWbemConfigureRefresher;
	IWbemRefresher			*m_pIWbemRefresher;

	RefreshableItemMap	m_ObjectMap;

	void				CreateRefresher ();
	void				EraseItem (RefreshableItemMap::iterator iterator);
	
protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemRefresher(void);
    virtual ~CSWbemRefresher(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemRefresher methods

    HRESULT STDMETHODCALLTYPE get__NewEnum (
		/*[out, retval]*/ IUnknown **pUnk
		);

	HRESULT STDMETHODCALLTYPE Item (
		/*[in]*/ long iIndex, 
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE get_Count (
		/*[out, retval]*/ long *iCount
		);

	HRESULT STDMETHODCALLTYPE Add (
		/*[in]*/ ISWbemServicesEx *objWbemServices,
		/*[in]*/ BSTR bsInstancePath,
		/*[in, optional, defaultvalue(0)]*/ long iFlags,
		/*[in, optional, defaultvalue(0)]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE AddEnum (
		/*[in]*/ ISWbemServicesEx *objWbemServices,
		/*[in]*/ BSTR bsClassName,
		/*[in, optional, defaultvalue(0)]*/ long iFlags,
		/*[in, optional, defaultvalue(0)]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE Remove (
		/*[in]*/ long iIndex,
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		);

	HRESULT STDMETHODCALLTYPE Refresh (
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		);
		
	HRESULT STDMETHODCALLTYPE get_AutoReconnect (
		/*[out, retval]*/ VARIANT_BOOL *bAutoReconnect
		)
	{
		ResetLastErrors ();
		*bAutoReconnect = m_bAutoReconnect;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE put_AutoReconnect (
		/*[in]*/ VARIANT_BOOL bAutoReconnect
		)
	{
		ResetLastErrors ();
		m_bAutoReconnect = bAutoReconnect;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE DeleteAll (
		);
    
    // IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemRefresher == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumRefresher
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for ISWbemRefresher
//
//***************************************************************************

class CEnumRefresher : public IEnumVARIANT
{
private:
	long							m_cRef;
	CSWbemRefresher					*m_pCSWbemRefresher;
	RefreshableItemMap::iterator	m_Iterator;

public:
	CEnumRefresher (CSWbemRefresher *pCSWbemRefresher);
	CEnumRefresher (CSWbemRefresher *pCSWbemRefresher,
						RefreshableItemMap::iterator iterator);
	virtual ~CEnumRefresher (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectSet interface for IWbemHiPerfEnum
//
//***************************************************************************

class CSWbemHiPerfObjectSet : public ISWbemObjectSet,
					    	  public ISupportErrorInfo,
							  public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;
	IWbemHiPerfEnum			*m_pIWbemHiPerfEnum;
	
protected:
	long            m_cRef;         //Object reference count

public:
    
   	CSWbemHiPerfObjectSet(CSWbemServices *pService, IWbemHiPerfEnum *pIWbemHiPerfEnum);
    ~CSWbemHiPerfObjectSet(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemObject **ppObject
    );        

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemObjectSet == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	IWbemObjectAccess **ReadObjects (
							unsigned long & iCount
							);
	// Other methods
	CSWbemServices *GetSWbemServices ()
	{
		return m_pSWbemServices;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for IWbemHiPerfEnum
//
//***************************************************************************

class CEnumVarHiPerf : public IEnumVARIANT
{
private:
	long					m_cRef;
	unsigned long			m_iCount;
	unsigned long			m_iPos;
	IWbemObjectAccess		**m_ppIWbemObjectAccess;
	CSWbemHiPerfObjectSet	*m_pCSWbemHiPerfObjectSet;

public:
	CEnumVarHiPerf (CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet);
	virtual ~CEnumVarHiPerf (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);
	
	STDMETHODIMP Reset()
	{
		m_iPos = 0;
		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
		return WBEM_S_NO_ERROR;
	}
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

#endif // _REFRESHER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\sink.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SINK.CPP
//
//  rogerbo  21-May-98   Created.
//
//  Defines the implementation of ISWbemSink
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"
#include <olectl.h>

#define NUM_ON_OBJECT_READY_ARGS			2
#define NUM_ON_CONNECTION_READY_ARGS		2
#define NUM_ON_COMPLETED_ARGS				3
#define NUM_ON_PROGRESS_ARGS				4
#define NUM_ON_OBJECT_PUT_ARGS				2
#define NUM_ON_OBJECT_SECURITY_READY_ARGS	2

#define SINKS_MAX 2


//***************************************************************************
//
//  CSWbemSink::CSWbemSink
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************


CSWbemSink::CSWbemSink()
{
	_RD(static char *me = "CSwbemSink::CSWbemSink";)

	m_pPrivateSink = NULL;
	m_nSinks = 0;
	m_nMaxSinks = SINKS_MAX;
    m_cRef=0;
	m_Dispatch.SetObj(this, IID_ISWbemSink, CLSID_SWbemSink, L"SWbemSink");

	_RPrint(me, "===============================================", 0, "");
	_RPrint(me, "", 0, "");

	// Allocate list of CWbemObjectSink 
	m_rgpCWbemObjectSink = (WbemObjectListEntry *)malloc(m_nMaxSinks * sizeof(WbemObjectListEntry));

	if (m_rgpCWbemObjectSink)
	{
		for(int count = 0; count < m_nMaxSinks; count++)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_rgpCWbemObjectSink[count].pServices = NULL;
		}
	}

    // Initialize all the connection points to NULL
	for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
        m_rgpConnPt[count] = NULL;

	// Create our connection point
	if (m_rgpConnPt[0] = new CConnectionPoint(this, DIID_ISWbemSinkEvents))
		m_rgpConnPt[0]->AddRef();

	// Additional connection points could be instantiated here

    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemSink::~CSWbemSink
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemSink::~CSWbemSink(void)
{
	_RD(static char *me = "CSWbemSink::~CSWbemSink";)
	_RPrint(me, "", 0, "");

	if (m_pPrivateSink)
	{
		// Make sure we don't hook back to ourselves any more
		// as this CSWbemSink is about to expire
		m_pPrivateSink->Detach ();

		// Release our hold on the private sink
		m_pPrivateSink->Release ();
		m_pPrivateSink = NULL;
	}

    for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
        if(m_rgpConnPt[count] != NULL)
	        delete m_rgpConnPt[count];

	free(m_rgpCWbemObjectSink);

    InterlockedDecrement(&g_cObj);
	_RPrint(me, "After decrement count is", (long)g_cObj, "");
}

//***************************************************************************
// HRESULT CSWbemSink::QueryInterface
// long CSWbemSink::AddRef
// long CSWbemSink::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSink::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid) 
		*ppv = reinterpret_cast<IUnknown *>(this);
	else if (IID_ISWbemSink==riid)
		*ppv = (ISWbemSink *)this;
	else if (IID_IDispatch==riid) 
		*ppv = (IDispatch *) this;
	else if (IID_IConnectionPointContainer==riid)
		*ppv = (IConnectionPointContainer *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	else if (IID_IProvideClassInfo2==riid)
		*ppv = (IProvideClassInfo2 *)this;
//	else if (IID_ISWbemPrivateSink==riid)
//		*ppv = (ISWbemPrivateSink *)(&m_privateSink); // Private I/F counting
	else if (IID_ISWbemPrivateSinkLocator==riid)
		*ppv = (ISWbemPrivateSinkLocator *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemSink::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemSink::Release(void)
{
	_RD(static char *me = "CSWbemSink::Release";)

	/*
	 * If the only refs that are left are those from 
	 * CWbemPrivateSink then initiate a cancel on all 
	 * remaining sinks.  This is because there are no 
	 * client refs to CSWbemSinks left, therefore queries
	 * in progress can be of no use.  First make sure we
	 * do an Unadvise for all the connection points.  
	 */
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
	{
        return m_cRef;
	}
	else
	{
		// We are about to blow away this SWbemSink, so
		// make sure we clean up any orphaned IWbemObjectSink's
		// by unadvising and cancelling the underlying WMI calls
		if(m_pPrivateSink)
			m_pPrivateSink->Detach();

		if (m_rgpConnPt[0])
		{
			m_rgpConnPt[0]->UnadviseAll();
		}

   		Cancel();
	}

    delete this;
    return 0;
}
		
//***************************************************************************
// HRESULT CSWbemSink::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSink::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSink == riid) ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::Cancel()
{
	_RD(static char *me = "CSWbemSink::Cancel";)

	ResetLastErrors ();

	if (!m_nSinks)
		return S_OK;

	_RPrint(me, "!!!Cancel called", 0, "");

	/* 
	 * Take a copy of the sinks, this can change under our feet
	 * As the Cancel can cause us to be re-entered.  No need to 
	 * take a copy of m_nMaxSinks as this isn't used when cancels
	 * are occuring.
	 * Make sure we AddRef the sink so that it can't be blown away 
	 * under our feet by a re-entrant call to OnCompleted
	 */
	HRESULT hr = WBEM_E_FAILED;
	int nSinks = m_nSinks;
	WbemObjectListEntry *rgpCWbemObjectSink = 
				(WbemObjectListEntry *)malloc(nSinks * sizeof(WbemObjectListEntry));

	if (!rgpCWbemObjectSink)
		hr = WBEM_E_OUT_OF_MEMORY;
	else
	{
		int actual = 0;
		for (int i = 0; i < m_nMaxSinks; i++)
		{
			if (m_rgpCWbemObjectSink[i].pWbemObjectWrapper)
			{
				m_rgpCWbemObjectSink[i].pWbemObjectWrapper->AddRef();

				if (m_rgpCWbemObjectSink[i].pServices)
					m_rgpCWbemObjectSink[i].pServices->AddRef();

				rgpCWbemObjectSink[actual++] = m_rgpCWbemObjectSink[i];
			}
		}


		/*
		 * Now do the actual cancel  
		 */
		for (i = 0; i < nSinks; i++) {
			if (rgpCWbemObjectSink[i].pWbemObjectWrapper) {
				IWbemObjectSink *pSink = NULL;
				if (SUCCEEDED(rgpCWbemObjectSink[i].pWbemObjectWrapper->QueryInterface
													(IID_IWbemObjectSink, (PPVOID)&pSink)))
				{
					if (rgpCWbemObjectSink[i].pServices)
						rgpCWbemObjectSink[i].pServices->CancelAsyncCall(pSink);

					pSink->Release();
				}
				rgpCWbemObjectSink[i].pWbemObjectWrapper->Release();

				if (rgpCWbemObjectSink[i].pServices)
					rgpCWbemObjectSink[i].pServices->Release();
			}
		}
		free(rgpCWbemObjectSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSink::EnumConnectionPoints(IEnumConnectionPoints** ppEnum)
{
	HRESULT hr = E_FAIL;

	if (!ppEnum)
		hr = E_POINTER;
	else
	{
		CEnumConnectionPoints* pEnum = new CEnumConnectionPoints(reinterpret_cast<IUnknown*>(this), (void**)m_rgpConnPt);

		if (!pEnum)
			hr = E_OUTOFMEMORY;
		else if (FAILED(hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum)))
			delete pEnum;
	}

	return hr;
}

HRESULT CSWbemSink::FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP)
{
	HRESULT hr = E_FAIL;

	if(riid == DIID_ISWbemSinkEvents)
	{
		if (!ppCP)
			hr = E_POINTER;
		else if (m_rgpConnPt [0])
			hr = m_rgpConnPt[0]->QueryInterface(IID_IConnectionPoint, (void**)ppCP);
	}
	else
		hr = E_NOINTERFACE;

	return hr;
}

HRESULT CSWbemSink::GetClassInfo(ITypeInfo** pTypeInfo)
{
	HRESULT hr = E_FAIL;

	if (!pTypeInfo)
		hr = E_POINTER;
	else
	{
		CComPtr<ITypeLib> pTypeLib;

		if (SUCCEEDED(LoadRegTypeLib(LIBID_WbemScripting, 1, 0, LANG_NEUTRAL, &pTypeLib)))
			hr = pTypeLib->GetTypeInfoOfGuid(CLSID_SWbemSink, pTypeInfo);
	}

	return hr;
}

HRESULT CSWbemSink::GetGUID(DWORD dwGuidKind, GUID* pGUID)
{
	if(pGUID == NULL)
		return E_INVALIDARG;
	*pGUID = DIID_ISWbemSinkEvents;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::AddObjectSink(
							/* [in] */ IUnknown __RPC_FAR *pSink,
							/* [in] */ IWbemServices __RPC_FAR *pServices)
{
	if(m_nSinks == m_nMaxSinks)
	{
		// Expand the size of the sink list
		m_rgpCWbemObjectSink = (WbemObjectListEntry *)realloc(m_rgpCWbemObjectSink, 
														(m_nMaxSinks + SINKS_MAX) * sizeof(WbemObjectListEntry));

		// Initialize new bit
		for(int count = m_nMaxSinks; count < (m_nMaxSinks + SINKS_MAX); count++)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_rgpCWbemObjectSink[count].pServices = NULL;
		}

		m_nMaxSinks += SINKS_MAX;
	}

	for(int count = 0; count < m_nMaxSinks; count++)
		if(m_rgpCWbemObjectSink[count].pWbemObjectWrapper == NULL)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = pSink;
			m_rgpCWbemObjectSink[count].pServices = pServices;
			break;
		}
	m_nSinks++;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::RemoveObjectSink(/* [in] */ IUnknown __RPC_FAR *pSink)
{
	for(int count = 0; count < m_nMaxSinks; count++)
		if(pSink == m_rgpCWbemObjectSink[count].pWbemObjectWrapper)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_nSinks--;
		}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{ 
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnObjectReady(pObject, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnCompleted(hResult, pErrorObject, path, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}
        
HRESULT STDMETHODCALLTYPE CSWbemSink::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnProgress(upperBound, current, message, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::GetPrivateSink(
		/* [out] */ IUnknown **objWbemPrivateSink)
{
	HRESULT hr = E_FAIL;

	if (objWbemPrivateSink)
	{
		if(!m_pPrivateSink)
		{
			if (m_pPrivateSink = new CSWbemPrivateSink(this))
				m_pPrivateSink->AddRef ();		// Released in destructor
		}

		if (m_pPrivateSink)
			hr = m_pPrivateSink->QueryInterface(IID_IUnknown, (PPVOID)objWbemPrivateSink);
	}
	else
		hr = E_POINTER;

	return hr;
}

// void** rpgCP is used so that this constructor can accept either CConnectionPoint**
// from CSWbemSink::EnumConnectionPoints or IConnectionPoint** from CEnumConnectionPoints::Clone
// This could also be done by overloading the constructor and duplicating some of this code
CEnumConnectionPoints::CEnumConnectionPoints(IUnknown* pUnkRef, void** rgpCP) : m_cRef(0)
{
	m_iCur = 0;
    m_pUnkRef = pUnkRef;

	// m_rgpCP is a pointer to an array of IConnectionPoints or CConnectionPoints
	for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
		((IUnknown*)rgpCP[count])->QueryInterface(IID_IConnectionPoint, (void**)&m_rgpCP[count]);
    InterlockedIncrement(&g_cObj);
}

CEnumConnectionPoints::~CEnumConnectionPoints()
{
	if(m_rgpCP != NULL)
		for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
			m_rgpCP[count]->Release();

    InterlockedDecrement(&g_cObj);
}

ULONG CEnumConnectionPoints::AddRef()
{
	m_pUnkRef->AddRef();
	return ++m_cRef;
}

ULONG CEnumConnectionPoints::Release()
{
	m_pUnkRef->Release();
	if(--m_cRef != 0)
        return m_cRef;
    delete this;
    return 0;
}

HRESULT CEnumConnectionPoints::QueryInterface(REFIID riid, void** ppv)
{
	if(riid == IID_IUnknown || riid == IID_IEnumConnectionPoints)
		*ppv = (IEnumConnectionPoints*)this;
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

HRESULT CEnumConnectionPoints::Next(ULONG cConnections, IConnectionPoint** rgpcn, ULONG* pcFetched)
{
	if(rgpcn == NULL)
		return E_POINTER;
	if(pcFetched == NULL && cConnections != 1)
		return E_INVALIDARG;
	if(pcFetched != NULL)
		*pcFetched = 0;

	while(m_iCur < NUM_CONNECTION_POINTS && cConnections > 0)
	{
		*rgpcn = m_rgpCP[m_iCur++];
		if(*rgpcn != NULL)
			(*rgpcn)->AddRef();
		if(pcFetched != NULL)
			(*pcFetched)++;
		cConnections--;
		rgpcn++;
	}
	return S_OK;
}

HRESULT CEnumConnectionPoints::Skip(ULONG cConnections)
{
	if(m_iCur + cConnections >= NUM_CONNECTION_POINTS)
		return S_FALSE;
    m_iCur += cConnections;
    return S_OK;
}

HRESULT CEnumConnectionPoints::Reset()
{
    m_iCur = 0;
    return S_OK;
}

HRESULT CEnumConnectionPoints::Clone(IEnumConnectionPoints** ppEnum)
{
	if(ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;

    // Create the clone
    CEnumConnectionPoints* pNew = new CEnumConnectionPoints(m_pUnkRef, (void**)m_rgpCP);
    if(pNew == NULL)
        return E_OUTOFMEMORY;

    pNew->AddRef();
    pNew->m_iCur = m_iCur;
    *ppEnum = pNew;
    return S_OK;
}

CConnectionPoint::CConnectionPoint(CSWbemSink* pObj, REFIID riid) : 
					m_cRef(0),
					m_rgnCookies(NULL),
					m_rgpUnknown(NULL)
{
    m_iid = riid;
	m_nMaxConnections = CCONNMAX;

	m_rgnCookies = (unsigned *)malloc(m_nMaxConnections * sizeof(unsigned));
	m_rgpUnknown = (IUnknown **)malloc(m_nMaxConnections * sizeof(IUnknown *));

	// Don't need AddRef/Release since we are nested inside CSWbemSink
    m_pObj = pObj;
    for(int count = 0; count < m_nMaxConnections; count++)
        {
			if (m_rgpUnknown)
				m_rgpUnknown[count] = NULL;

			if (m_rgnCookies)
				m_rgnCookies[count] = 0;
        }
    m_cConn = 0;
    m_nCookieNext = 10; // Arbitrary starting cookie value

    InterlockedIncrement(&g_cObj);
}

CConnectionPoint::~CConnectionPoint()
{
	if (m_rgpUnknown)
	{
		for(int count = 0; count < m_nMaxConnections; count++)
			if(m_rgpUnknown[count] != NULL)
			{
				m_rgpUnknown[count]->Release();
				m_rgpUnknown[count] = NULL;
			}

		free(m_rgpUnknown);
	}

	if (m_rgnCookies)
		free(m_rgnCookies);
	
    InterlockedDecrement(&g_cObj);
}

HRESULT CConnectionPoint::QueryInterface(REFIID riid, void** ppv)
{
    if(IID_IUnknown == riid || IID_IConnectionPoint == riid)
        *ppv = (IConnectionPoint*)this;
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CConnectionPoint::AddRef()
    {
    return ++m_cRef;
    }

ULONG CConnectionPoint::Release()
    {
    if(--m_cRef != 0)
        return m_cRef;
    delete this;
    return 0;
    }

HRESULT CConnectionPoint::GetConnectionInterface(IID *pIID)
{
	if(pIID == NULL)
		return E_POINTER;
	*pIID = m_iid;
	return S_OK;
}

HRESULT CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	return m_pObj->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
}

HRESULT CConnectionPoint::Advise(IUnknown* pUnknownSink, DWORD* pdwCookie)
{
	IUnknown* pSink;
	*pdwCookie = 0;
	_RD(static char *me = "CConnectionPoint::Advise";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	if(m_cConn == m_nMaxConnections)
	{
		//return CONNECT_E_ADVISELIMIT;
		// Expand the size of the connection lists
		m_rgnCookies = (unsigned *)realloc(m_rgnCookies, (m_nMaxConnections + CCONNMAX) * sizeof(unsigned));
		m_rgpUnknown = (IUnknown **)realloc(m_rgpUnknown, (m_nMaxConnections + CCONNMAX) * sizeof(IUnknown *));

		// Initialize new bit
		for(int count = m_nMaxConnections; count < (m_nMaxConnections + CCONNMAX); count++)
			{
			m_rgpUnknown[count] = NULL;
			m_rgnCookies[count] = 0;
			}

		m_nMaxConnections += CCONNMAX;
	}

	if(FAILED(pUnknownSink->QueryInterface(m_iid, (void**)&pSink)))
		return CONNECT_E_CANNOTCONNECT;
	for(int count = 0; count < m_nMaxConnections; count++)
		if(m_rgpUnknown[count] == NULL)
		{
			m_rgpUnknown[count] = pSink;
			m_rgnCookies[count] = ++m_nCookieNext;
			*pdwCookie = m_nCookieNext;
			break;
		}
	m_cConn++;

	return NOERROR;
}

HRESULT CConnectionPoint::Unadvise(DWORD dwCookie)
{
	_RD(static char *me = "CConnectionPoint::Unadvise";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	if(dwCookie == 0)
		return E_INVALIDARG;
	for(int count = 0; count < m_nMaxConnections; count++)
		if(dwCookie == m_rgnCookies[count])
		{
			if(m_rgpUnknown[count] != NULL)
			{
				m_rgpUnknown[count]->Release();
				m_rgpUnknown[count] = NULL;
				m_rgnCookies[count] = 0;
			}
			m_cConn--;
			return NOERROR;
		}
	return CONNECT_E_NOCONNECTION;
}

HRESULT CConnectionPoint::EnumConnections(IEnumConnections** ppEnum)
{
	HRESULT hr = E_FAIL;

	if (!ppEnum)
		hr = E_POINTER;
	else
	{
		*ppEnum = NULL;
		CONNECTDATA* pCD = new CONNECTDATA[m_cConn];

		if (!pCD)
			hr = E_OUTOFMEMORY;
		else
		{
			for(int count1 = 0, count2 = 0; count1 < m_nMaxConnections; count1++)
				if(m_rgpUnknown[count1] != NULL)
				{
					pCD[count2].pUnk = (IUnknown*)m_rgpUnknown[count1];
					pCD[count2].dwCookie = m_rgnCookies[count1];
					count2++;
				}
			
			CEnumConnections* pEnum = new CEnumConnections(this, m_cConn, pCD);
			delete [] pCD;

			if (!pEnum)
				hr = E_OUTOFMEMORY;
			else
				hr = pEnum->QueryInterface(IID_IEnumConnections, (void**)ppEnum);
		}
	}

	return hr;
}

void CConnectionPoint::UnadviseAll() {
	_RD(static char *me = "CConnectionPoint::UnadviseAll";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	for(int count = 0; count < m_nMaxConnections; count++) {
		if(m_rgpUnknown[count] != NULL)
		{
			m_rgpUnknown[count]->Release();
			m_rgpUnknown[count] = NULL;
			m_rgnCookies[count] = 0;
			m_cConn--;
		}
	}
	_RPrint(me, "Current connections (after adjustment): ", (long)m_cConn, "");
}

void CConnectionPoint::OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_OBJECT_READY_ARGS];
				VARIANTARG *pArg = args;

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_OBJECT_READY_ARGS;
				dispparams.rgvarg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pObject;

				hr = pdisp->Invoke(WBEMS_DISPID_OBJECT_READY, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
														DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}

void CConnectionPoint::OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				VARIANTARG *pArg;

				if (path)
				{
					DISPPARAMS putDispparams;
					VARIANTARG putArgs[NUM_ON_OBJECT_PUT_ARGS];

					memset(&putDispparams, 0, sizeof putDispparams);

					putDispparams.cArgs = NUM_ON_OBJECT_PUT_ARGS;
					putDispparams.rgvarg = pArg = putArgs;

					VariantInit(pArg);
					pArg->vt = VT_DISPATCH;
					pArg->pdispVal = pAsyncContext;

					pArg++;
					VariantInit(pArg);
					pArg->vt = VT_DISPATCH;
					pArg->pdispVal = path;

					hr = pdisp->Invoke(WBEMS_DISPID_OBJECT_PUT, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
													DISPATCH_METHOD, &putDispparams, NULL, NULL, NULL);
				}

				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_COMPLETED_ARGS];

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_COMPLETED_ARGS;
				dispparams.rgvarg = pArg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pErrorObject;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = (long)hResult;

				hr = pdisp->Invoke(WBEMS_DISPID_COMPLETED, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
															DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}

void CConnectionPoint::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_PROGRESS_ARGS];
				VARIANTARG *pArg = args;

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_PROGRESS_ARGS;
				dispparams.rgvarg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = (IDispatch  FAR *)pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_BSTR;
				pArg->bstrVal = message;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = current;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = upperBound;

				hr = pdisp->Invoke(WBEMS_DISPID_PROGRESS, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
														DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}


CEnumConnections::CEnumConnections(IUnknown* pUnknown, int cConn, CONNECTDATA* pConnData) : m_cRef(0)
{
	m_pUnkRef = pUnknown;
	m_iCur = 0;
	m_cConn = cConn;
	m_rgConnData = new CONNECTDATA[cConn];
	if(m_rgConnData != NULL)
		for(int count = 0; count < cConn; count++)
		{
			m_rgConnData[count] = pConnData[count];
			m_rgConnData[count].pUnk->AddRef();
		}

    InterlockedIncrement(&g_cObj);
}

CEnumConnections::~CEnumConnections()
{
	if(m_rgConnData != NULL)
	{
		for(unsigned count = 0; count < m_cConn; count++)
			m_rgConnData[count].pUnk->Release();
		delete [] m_rgConnData;
	}

    InterlockedDecrement(&g_cObj);
}

HRESULT CEnumConnections::Next(ULONG cConnections, CONNECTDATA* rgpcd, ULONG* pcFetched)
{
	if(pcFetched == NULL && cConnections != 1)
		return E_INVALIDARG;
	if(pcFetched != NULL)
		*pcFetched = 0;
    if(rgpcd == NULL || m_iCur >= m_cConn)
        return S_FALSE;
    unsigned cReturn = 0;
    while(m_iCur < m_cConn && cConnections > 0)
    {
        *rgpcd++ = m_rgConnData[m_iCur];
        m_rgConnData[m_iCur++].pUnk->AddRef();
        cReturn++;
        cConnections--;
    } 
    if(pcFetched != NULL)
        *pcFetched = cReturn;
    return S_OK;
}

HRESULT CEnumConnections::Skip(ULONG cConnections)
{
    if(m_iCur + cConnections >= m_cConn)
        return S_FALSE;
    m_iCur += cConnections;
    return S_OK;
}

HRESULT CEnumConnections::Reset()
{
    m_iCur = 0;
    return S_OK;
}

HRESULT CEnumConnections::Clone(IEnumConnections** ppEnum)
{
	if(ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;

    // Create the clone
    CEnumConnections* pNew = new CEnumConnections(m_pUnkRef, m_cConn, m_rgConnData);
    if(NULL == pNew)
        return E_OUTOFMEMORY;

    pNew->AddRef();
    pNew->m_iCur = m_iCur;
    *ppEnum = pNew;
    return S_OK;
}

HRESULT CEnumConnections::QueryInterface(REFIID riid, void** ppv)
{
    if(IID_IUnknown == riid || IID_IEnumConnections == riid)
        *ppv = (IEnumConnections*)this;
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CEnumConnections::AddRef()
    {
    return ++m_cRef;
    }

ULONG CEnumConnections::Release()
    {
    if(--m_cRef != 0)
        return m_cRef;
    delete this;
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\site.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  site.h
//
//  alanbos  13-Feb-98   Created.
//
//  Defines site information for an object
//
//***************************************************************************

#ifndef _SITE_H_
#define _SITE_H_

class CSWbemObject;
class CSWbemProperty;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemSite
//
//  DESCRIPTION:
//
//  Abstract base class  
//
//***************************************************************************

class CWbemSite 
{
protected:
	CWbemSite () { m_cRef = 1; }

	long	m_cRef;
	
public:
    virtual ~CWbemSite (void) { }

	virtual void Update () = 0;

	ULONG AddRef ();
	ULONG Release ();
    
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemObjectSite
//
//  DESCRIPTION:
//
//  Site class for ISWbemObject
//
//***************************************************************************

class CWbemObjectSite : public CWbemSite
{
private:
	ISWbemInternalObject	*m_pSWbemObject;

public:
	CWbemObjectSite (ISWbemInternalObject *pObject);
	~CWbemObjectSite ();

	// Overriden methods of base class
	void Update ();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemPropertySite
//
//  DESCRIPTION:
//
//  Site class for ISWbemProperty, where the property is non-array valued.
//	Embedded objects that are not in an array use this as their site.
//
//***************************************************************************

class CWbemPropertySite : public CWbemSite
{
private:
	// The property representing the embedded object
	CSWbemProperty		*m_pSWbemProperty;

	// The array index of the property value at which
	// this embedded object occurs (or -1 if not array)
	long				m_index;

	// The embedded object itself
	IWbemClassObject	*m_pIWbemClassObject;

public:
	CWbemPropertySite (CSWbemProperty *pProperty,
						IWbemClassObject *pSourceObject,
						long index = -1);

	~CWbemPropertySite ();

	// Overriden methods of base class
	void Update ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\sobjpath.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  sobjpath.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemObjectPath definition
//
//***************************************************************************

#ifndef _SOBJPATH_H_
#define _SOBJPATH_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectPath interface.  
//
//***************************************************************************

class CSWbemObjectPath : public ISWbemObjectPath,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
friend	CSWbemServices;

private:
	class CObjectPathDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};
	CObjectPathDispatchHelp		m_Dispatch;
	
	class CWbemObjectPathSecurity : public ISWbemSecurity,
									public ISupportErrorInfo,
									public IProvideClassInfo
	{
		private:
			CDispatchHelp				m_Dispatch;
			
		protected:
			long				m_cRef;

		public:
			CWbemObjectPathSecurity (CSWbemSecurity *pSecurity);
			CWbemObjectPathSecurity (ISWbemSecurity *pObjectPathSecurity);
			virtual ~CWbemObjectPathSecurity (void);

			//Non-delegating object IUnknown

			STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
			STDMETHODIMP_(ULONG) AddRef(void);
			STDMETHODIMP_(ULONG) Release(void);

			// IDispatch

			STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
				{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
			STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
				{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
			STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
									UINT cNames, LCID lcid, DISPID* rgdispid)
				{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
								  lcid,
								  rgdispid);}
			STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
									WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
											EXCEPINFO* pexcepinfo, UINT* puArgErr)
				{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
								pdispparams, pvarResult, pexcepinfo, puArgErr);}
		
			// ISWbemSecurity methods

			HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
			(
				/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
			);

			HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
			(
				/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
			);

			HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
			(
				/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
			);

			HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
			(
				/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
			);

			HRESULT STDMETHODCALLTYPE get_Privileges 
			(
				/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
			);

			// ISupportErrorInfo methods
			HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
			(
				/* [in] */ REFIID riid
			);

			// IProvideClassInfo methods
			HRESULT STDMETHODCALLTYPE GetClassInfo
			(
				/* [in,out] */ ITypeInfo **ppTI
			)
			{
				return m_Dispatch.GetClassInfo (ppTI);
			};

			bool								m_authnSpecified;
			bool								m_impSpecified;
			enum WbemAuthenticationLevelEnum	m_authnLevel;
			enum WbemImpersonationLevelEnum		m_impLevel;
			CSWbemPrivilegeSet					*m_pPrivilegeSet;	
	};
	

	CWbemObjectPathSecurity		*m_pSecurity;
	BSTR			m_bsLocale;
	BSTR			m_bsAuthority;

protected:

	long				m_cRef;         //Object reference count
	CWbemPathCracker	*m_pPathCracker;

protected:

public:
    
    CSWbemObjectPath(CSWbemSecurity *pSecurity = NULL, BSTR bsLocale = NULL);
	CSWbemObjectPath(CSWbemObjectPath & wbemObjectPath);
	CSWbemObjectPath(ISWbemObjectPath *pISWbemObjectPath);
    ~CSWbemObjectPath(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemObjectPath methods

    HRESULT STDMETHODCALLTYPE get_Path( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Path( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_RelPath( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_RelPath( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_DisplayName( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_DisplayName( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Namespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Namespace( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_ParentNamespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE get_Server( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Server( 
        /* [in] */ BSTR __RPC_FAR value) ;
    
    HRESULT STDMETHODCALLTYPE get_IsClass( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsClass() ;
    
    HRESULT STDMETHODCALLTYPE get_IsSingleton( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsSingleton() ;

    HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Class( 
        /* [in] */ BSTR __RPC_FAR value) ;
    
    HRESULT STDMETHODCALLTYPE get_Keys( 
		/* [retval][out] */ ISWbemNamedValueSet **objKeys) ;

	HRESULT STDMETHODCALLTYPE get_Security_( 
		/* [retval][out] */ ISWbemSecurity **objSecurity) ;

    HRESULT STDMETHODCALLTYPE get_Locale( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Locale( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Authority( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Authority( 
        /* [in] */ BSTR __RPC_FAR value) ;

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Methods of CSWbemObjectPath
	static	bool	GetObjectPath (IWbemClassObject *pIWbemClassObject, CComBSTR & bsPath);
	static	bool	GetParentPath (IWbemClassObject *pIWbemClassObject, CComBSTR & bsPath);

	static bool		CompareObjectPaths (IWbemClassObject *pIWbemClassObject, CWbemPathCracker & objectPath);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\sink.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  sink.h
//
//  rogerbo  21-May-98   Created.
//
//  Include file for CSWbemSink
//
//***************************************************************************

#ifndef _SINK_H_
#define _SINK_H_

const NUM_CONNECTION_POINTS = 1;
const CCONNMAX = 8;


//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemSink
//
//  DESCRIPTION:
//
//  Implements the ISWbemSink interface.  
//
//***************************************************************************

typedef struct _WbemObjectListEntry {
	IUnknown *pWbemObjectWrapper;
	IWbemServices *pServices;
} WbemObjectListEntry;


class CConnectionPoint;
class CWbemObjectSink;

class CSWbemSink : public ISWbemSink, 
				   public IConnectionPointContainer, 
				   public IProvideClassInfo2,
				   public IObjectSafety,
				   public ISupportErrorInfo,
				   public ISWbemPrivateSinkLocator
{
private:

	CDispatchHelp		m_Dispatch;		
	CConnectionPoint* m_rgpConnPt[NUM_CONNECTION_POINTS];
	WbemObjectListEntry *m_rgpCWbemObjectSink;   // One of these per outstanding operation
	int m_nMaxSinks;
	int m_nSinks;

	/* 
	 * Here we need to do per interface reference counting.  If the ref count
	 * of the enclosing object goes to zero, and the ref count of the enclosed
	 * object (this one), is non zero, then we have to instigate a cancel, because
	 * there are still outstanding operations.
	 */
	class CSWbemPrivateSink : public ISWbemPrivateSink {
		private:

		CSWbemSink *m_pSink;
		long m_cRef;

		public:

		CSWbemPrivateSink(CSWbemSink *pSink) : m_pSink(pSink), m_cRef(0) {}
		void Detach() { m_pSink = NULL; }

		long GetRef() { return m_cRef; }

		// IUnknown methods

		STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv) {
										if (IID_ISWbemPrivateSink==riid || IID_IUnknown==riid)
										{
											*ppv = (ISWbemPrivateSink *)(this);
											InterlockedIncrement(&m_cRef);
											return S_OK;
										}
										else if (IID_ISWbemPrivateSink==riid)
										{
											*ppv = (ISWbemPrivateSink *)(this);
											InterlockedIncrement(&m_cRef);
											return S_OK;
										}
										return ResultFromScode(E_NOINTERFACE);
									}

		STDMETHODIMP_(ULONG) AddRef(void) {
										InterlockedIncrement(&m_cRef);
										return m_cRef;
									}

		STDMETHODIMP_(ULONG) Release(void) {
										InterlockedDecrement(&m_cRef);
										if(0 == m_cRef)
										{
											delete this;
											return 0;
										}
									  	return m_cRef; 
									}

		// ISWbemPrivateSink methods

		HRESULT STDMETHODCALLTYPE OnObjectReady( 
				/* [in] */ IDispatch __RPC_FAR *objObject,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext) 
						{ return m_pSink?m_pSink->OnObjectReady(objObject, objAsyncContext):S_OK; }
			
		HRESULT STDMETHODCALLTYPE OnCompleted( 
				/* [in] */ HRESULT iHResult,
				/* [in] */ IDispatch __RPC_FAR *objPath,
				/* [in] */ IDispatch __RPC_FAR *objErrorObject,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext)
						{ return m_pSink?m_pSink->OnCompleted(iHResult, objPath, objErrorObject, objAsyncContext):S_OK; }
			
		HRESULT STDMETHODCALLTYPE OnProgress( 
				/* [in] */ long iUpperBound,
				/* [in] */ long iCurrent,
				/* [in] */ BSTR strMessage,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext)
					{ return m_pSink?m_pSink->OnProgress(iUpperBound, iCurrent, strMessage, objAsyncContext):S_OK; }

		HRESULT STDMETHODCALLTYPE AddObjectSink( 
				/* [in] */ IUnknown __RPC_FAR *objWbemSink,
				/* [in] */ IWbemServices __RPC_FAR *objServices)
					{ return m_pSink?m_pSink->AddObjectSink(objWbemSink, objServices):S_OK; }
			
		HRESULT STDMETHODCALLTYPE RemoveObjectSink( 
				/* [in] */ IUnknown __RPC_FAR *objWbemSink)
					{ return m_pSink?m_pSink->RemoveObjectSink(objWbemSink):S_OK; }

	} *m_pPrivateSink;

protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemSink();
    ~CSWbemSink(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}


	// ISWbemSink methods
	HRESULT STDMETHODCALLTYPE Cancel();

	// IConnectionPointContainer methods
	HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints** ppEnum);
	HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP);

	// IProvideClassInfo2 methods
	HRESULT __stdcall GetClassInfo(ITypeInfo** pTypeInfo);
	HRESULT __stdcall GetGUID(DWORD dwGuidKind, GUID* pGUID);

	// ISWbemPrivateSink methods
	HRESULT STDMETHODCALLTYPE OnObjectReady( 
            /* [in] */ IDispatch __RPC_FAR *objObject,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);
        
	HRESULT STDMETHODCALLTYPE OnCompleted( 
            /* [in] */ HRESULT iHResult,
            /* [in] */ IDispatch __RPC_FAR *objPath,
            /* [in] */ IDispatch __RPC_FAR *objErrorObject,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);
        
	HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ long iUpperBound,
            /* [in] */ long iCurrent,
            /* [in] */ BSTR strMessage,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);

	HRESULT STDMETHODCALLTYPE AddObjectSink( 
            /* [in] */ IUnknown __RPC_FAR *objWbemSink,
            /* [in] */ IWbemServices __RPC_FAR *objServices);
        
	HRESULT STDMETHODCALLTYPE RemoveObjectSink( 
            /* [in] */ IUnknown __RPC_FAR *objWbemSink);

	// ISWbemPrivateSinkLocator methods
	HRESULT STDMETHODCALLTYPE GetPrivateSink(
			/* [out] */ IUnknown **objWbemPrivateSink);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
};

class CEnumConnectionPoints : public IEnumConnectionPoints
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IEnumConnectionPoints
	HRESULT __stdcall Next(ULONG cConnections, IConnectionPoint** rgpcn, ULONG* pcFetched); 
	HRESULT __stdcall Skip(ULONG cConnections);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumConnectionPoints** ppEnum);

	CEnumConnectionPoints(IUnknown* pUnkRef, void** rgpCP);
	~CEnumConnectionPoints();

private:
	long m_cRef;
    IUnknown* m_pUnkRef;         // IUnknown for ref counting
    int m_iCur;                  // Current element
    IConnectionPoint* m_rgpCP[NUM_CONNECTION_POINTS];  // Array of connection points
};


class CConnectionPoint : public IConnectionPoint
{
private:

	int m_cRef;
	CSWbemSink* m_pObj;
	IID m_iid;
    int m_cConn;
    int m_nCookieNext;
	int m_nMaxConnections;
	unsigned *m_rgnCookies;
	IUnknown **m_rgpUnknown;

public:

	CConnectionPoint(CSWbemSink* pObj, REFIID refiid);
	~CConnectionPoint();

	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IConnectionPoint
	HRESULT __stdcall GetConnectionInterface(IID *pIID);
	HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer** ppCPC);
	HRESULT __stdcall Advise(IUnknown* pUnknownSink, DWORD* pdwCookie);
	HRESULT __stdcall Unadvise(DWORD dwCookie);
	HRESULT __stdcall EnumConnections(IEnumConnections** ppEnum);

	// Other methods
	void OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);
	void OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);
	void CConnectionPoint::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);

	void UnadviseAll();

};

class CEnumConnections : public IEnumConnections
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IEnumConnections
	HRESULT __stdcall Next(ULONG cConnections, CONNECTDATA* rgpcd, ULONG* pcFetched);
	HRESULT __stdcall Skip(ULONG cConnections);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumConnections** ppEnum);

	CEnumConnections(IUnknown* pUnknown, int cConn, CONNECTDATA* pConnData);
	~CEnumConnections();

private:
	int m_cRef;
    IUnknown* m_pUnkRef;       // IUnknown for ref counting
    unsigned m_iCur;           // Current element
    unsigned m_cConn;          // Number of connections
    CONNECTDATA* m_rgConnData; // Source of connections
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\sobjpath.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SOBJPATH.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectPath
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(CSWbemSecurity *pSecurity, BSTR bsLocale) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");
    
	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

	if (pSecurity)
		m_bsAuthority = SysAllocString (pSecurity->GetAuthority());
	else
		m_bsAuthority = NULL;  

	m_pSecurity = new CWbemObjectPathSecurity (pSecurity);
	m_bsLocale = SysAllocString (bsLocale);
}


//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Copy Constructor but yields the parent path
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(CSWbemObjectPath & objectPath) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");

	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

	objectPath.m_pPathCracker->GetParent (*m_pPathCracker);
	
	m_bsAuthority = SysAllocString (objectPath.m_bsAuthority);
	m_pSecurity = new CWbemObjectPathSecurity (objectPath.m_pSecurity);
	m_bsLocale = SysAllocString (objectPath.m_bsLocale);
}

//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Copy Constructor but yields the parent path
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(ISWbemObjectPath *pISWbemObjectPath) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");

	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

    if (pISWbemObjectPath)
	{
		CComPtr<ISWbemSecurity> pISWbemSecurity;

		if (SUCCEEDED(pISWbemObjectPath->get_Security_ (&pISWbemSecurity)))
			m_pSecurity = new CWbemObjectPathSecurity (pISWbemSecurity);

		pISWbemObjectPath->get_Authority(&m_bsAuthority);
		pISWbemObjectPath->get_Locale(&m_bsLocale);
		
		CComBSTR bsOriginalPath;

		if (SUCCEEDED(pISWbemObjectPath->get_Path (&(bsOriginalPath.m_str))))
		{
			CWbemPathCracker pathCracker (bsOriginalPath);
			pathCracker.GetParent (*m_pPathCracker);
		}
	}
}

//***************************************************************************
//
//  CSWbemObjectPath::~CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectPath::~CSWbemObjectPath(void)
{
	RELEASEANDNULL(m_pSecurity)
	RELEASEANDNULL(m_pPathCracker)
	
	if (m_bsLocale)
	{
		SysFreeString (m_bsLocale);
		m_bsLocale = NULL;
	}

	if (m_bsAuthority)
	{
		SysFreeString (m_bsAuthority);
		m_bsAuthority = NULL;
	}


    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemObjectPath::QueryInterface
// long CSWbemObjectPath::AddRef
// long CSWbemObjectPath::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectPath==riid)
		*ppv = (ISWbemObjectPath *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectPath::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectPath == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Path
//
//  DESCRIPTION:
//
//  Get the path as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = NULL;
		CComBSTR bsPath;

		if (m_pPathCracker->GetPathText (bsPath, false, true))
		{
			*value = bsPath.Detach ();
			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
      
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Path
//
//  DESCRIPTION:
//
//  Put the path as a string
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Path( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (*m_pPathCracker = value)
		hr = WBEM_S_NO_ERROR;
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_RelPath
//
//  DESCRIPTION:
//
//  Get the relpath as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_RelPath( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		CComBSTR bsRelPath;

		if (m_pPathCracker->GetPathText (bsRelPath, true, false))
		{
			hr = WBEM_S_NO_ERROR;
			*value = bsRelPath.Detach ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_RelPath
//
//  DESCRIPTION:
//
//  Set the relpath as a string
//
//  PARAMETERS:
//		value		new relpath
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_RelPath( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	// Parse the new path
	if (m_pPathCracker->SetRelativePath (value))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_DisplayName
//
//  DESCRIPTION:
//
//  Get the display name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	
	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pSecurity && m_pSecurity->m_pPrivilegeSet)
	{
		CComBSTR bsPath;
		
		if (m_pPathCracker->GetPathText(bsPath, false, true))
		{
			bool hasLocale = ((NULL != m_bsLocale) && (0 < wcslen (m_bsLocale)));
			bool hasAuthority = ((NULL != m_bsAuthority) && (0 < wcslen (m_bsAuthority)));

			// Add the scheme name and a terminating NULL 
			size_t len = 1 + wcslen ( WBEMS_PDN_SCHEME );

			// Add the WMI path length to the buffer
			len += wcslen (bsPath);

			wchar_t *pwcSecurity = CWbemParseDN::GetSecurityString 
						(m_pSecurity->m_authnSpecified, 
						 m_pSecurity->m_authnLevel, 
						 m_pSecurity->m_impSpecified, 
						 m_pSecurity->m_impLevel,
						 *(m_pSecurity->m_pPrivilegeSet),
						 m_bsAuthority);
			
			// Add the security length
			if (pwcSecurity)
				len += wcslen (pwcSecurity);

			wchar_t *pwcLocale = CWbemParseDN::GetLocaleString (m_bsLocale);

			// Add the locale length
			if (pwcLocale)
				len += wcslen (pwcLocale);

			// If we have a path, and either a locale or security component, add a "!" path prefix
			if ((0 < wcslen (bsPath)) && (pwcSecurity || pwcLocale))
				len += wcslen (WBEMS_EXCLAMATION);

			/*
			 * Now build the string
			 */
			wchar_t *pwcDisplayName = new wchar_t [ len ] ;

			if (!pwcDisplayName)
				hr = WBEM_E_OUT_OF_MEMORY;
			else
			{
				wcscpy ( pwcDisplayName , WBEMS_PDN_SCHEME ) ;

				if (pwcSecurity)
					wcscat ( pwcDisplayName, pwcSecurity );
			
				if (pwcLocale)
					wcscat ( pwcDisplayName, pwcLocale);

				if ((0 < wcslen (bsPath)) && (pwcSecurity || pwcLocale))
					wcscat ( pwcDisplayName, WBEMS_EXCLAMATION );

				if (0 < wcslen (bsPath))
					wcscat ( pwcDisplayName, bsPath) ;

				*value = SysAllocString ( pwcDisplayName ) ;
			
				if (pwcSecurity)
					delete [] pwcSecurity;

				if (pwcLocale)
					delete [] pwcLocale;

				if (pwcDisplayName)
					delete [] pwcDisplayName ;

				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_DisplayName
//
//  DESCRIPTION:
//
//  Set the display name as a string
//
//  PARAMETERS:
//		value		new BSTR value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_DisplayName( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (value)
	{
		ULONG chEaten = 0;
		bool bIsWmiPath = false;
		bool bIsNativePath = false;

		if (0 == _wcsnicmp (value , WBEMS_PDN_SCHEME , wcslen (WBEMS_PDN_SCHEME)))
		{
			chEaten += wcslen (WBEMS_PDN_SCHEME);
			bIsWmiPath = true;
		}

		if (0 < chEaten)
		{
			bool authnSpecified = false; 
			bool impSpecified = false;
			enum WbemAuthenticationLevelEnum authnLevel;
			enum WbemImpersonationLevelEnum impLevel;
			CSWbemPrivilegeSet privilegeSet;
			CComBSTR bsAuthority, bsLocale;
		
			if (bIsWmiPath)
			{	
				ULONG lTemp = 0;
			
				if (CWbemParseDN::ParseSecurity (&value [chEaten], &lTemp, authnSpecified,
							&authnLevel, impSpecified, &impLevel, privilegeSet, bsAuthority.m_str))
					chEaten += lTemp;

				lTemp = 0;
				
				if (CWbemParseDN::ParseLocale (&value [chEaten], &lTemp, bsLocale.m_str))
					chEaten += lTemp;
				
				// Skip over the "!" separator if there is one
				if(NULL != value [chEaten])
					if (0 == _wcsnicmp (&value [chEaten], WBEMS_EXCLAMATION, wcslen (WBEMS_EXCLAMATION)))
						chEaten += wcslen (WBEMS_EXCLAMATION);
			}

			// Build the new path with what's left

			CComBSTR bsPath;
			bsPath = value +chEaten;

			if (m_pSecurity && m_pSecurity->m_pPrivilegeSet && (*m_pPathCracker = bsPath))
			{
				m_pSecurity->m_authnSpecified = authnSpecified;
				m_pSecurity->m_impSpecified = impSpecified;
				m_pSecurity->m_authnLevel = authnLevel;
				m_pSecurity->m_impLevel = impLevel;
				m_pSecurity->m_pPrivilegeSet->Reset (privilegeSet);

				SysFreeString (m_bsAuthority);
				m_bsAuthority = SysAllocString (bsAuthority);

				SysFreeString (m_bsLocale);
				m_bsLocale = SysAllocString (bsLocale);

				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Server
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Server( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;
		CComBSTR bsServer;

		if (m_pPathCracker->GetServer (bsServer))
		{
			*value = bsServer.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Server
//
//  DESCRIPTION:
//
//  Set the server name as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Server( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetServer (value))
			hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Namespace
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Namespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		CComBSTR bsNamespace;

		if (m_pPathCracker->GetNamespacePath(bsNamespace))
		{
			*value = bsNamespace.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_ParentNamespace
//
//  DESCRIPTION:
//
//  Get the parent namespace as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_ParentNamespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();
	
	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;

		// Get the full path and lob the end off
		CComBSTR bsNamespacePath;

		if (m_pPathCracker->GetNamespacePath (bsNamespacePath, true))
		{
			*value = bsNamespacePath.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Namespace
//
//  DESCRIPTION:
//
//  Put the namespace as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Namespace( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	
	if (m_pPathCracker->SetNamespacePath (value))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
    
//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_IsClass
//
//  DESCRIPTION:
//
//  Get whether the path is to a class
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_IsClass( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = m_pPathCracker->IsClass ()  ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetAsClass
//
//  DESCRIPTION:
//
//  Set the path as a class path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::SetAsClass()
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetAsClass ())
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_IsSingleton
//
//  DESCRIPTION:
//
//  Get whether the path is to a singleton
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_IsSingleton( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = m_pPathCracker->IsSingleton () ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetAsSingleton
//
//  DESCRIPTION:
//
//  Set the path as a singleton instance path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::SetAsSingleton()
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetAsSingleton ())
		hr = WBEM_S_NO_ERROR;
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Class
//
//  DESCRIPTION:
//
//  Get the class name from the path
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Class( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;
		CComBSTR bsPath;

		if (m_pPathCracker->GetClass (bsPath))
		{
			*value = bsPath.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Class
//
//  DESCRIPTION:
//
//  Set the class name in the path
//
//  PARAMETERS:
//		value		new class name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Class( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetClass (value))
			hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Keys
//
//  DESCRIPTION:
//
//  Get the keys collection from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemNamedValueSet returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Keys(
			/* [out][retval] */ ISWbemNamedValueSet **objKeys)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == objKeys)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pPathCracker->GetKeys (objKeys))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
	
//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Security
//
//  DESCRIPTION:
//
//  Get the security info from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemSecurity returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Security_(
			/* [out][retval] */ ISWbemSecurity **objSecurity)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == objSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pSecurity)
	{
		*objSecurity = m_pSecurity;
		m_pSecurity->AddRef();
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Locale
//
//  DESCRIPTION:
//
//  Get the locale info from the path
//
//  PARAMETERS:
//		value		pointer to locale returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Locale( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = SysAllocString ( m_bsLocale ) ;
		hr = S_OK ;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Locale
//
//  DESCRIPTION:
//
//  Set the locale info into the path
//
//  PARAMETERS:
//		value		new locale value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Locale( 
            /* [in] */ BSTR __RPC_FAR value)
{
	ResetLastErrors ();
	SysFreeString (m_bsLocale);
	m_bsLocale = SysAllocString (value);

	return S_OK ;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Authority
//
//  DESCRIPTION:
//
//  Get the authority info from the path
//
//  PARAMETERS:
//		value		pointer to authority returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Authority( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = SysAllocString ( m_bsAuthority ) ;
		hr = S_OK ;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Authority
//
//  DESCRIPTION:
//
//  Set the authority info into the path
//
//  PARAMETERS:
//		value		new authority value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Authority( 
            /* [in] */ BSTR __RPC_FAR value)
{
	ResetLastErrors ();
	SysFreeString (m_bsAuthority);
	m_bsAuthority = SysAllocString (value);

	return WBEM_S_NO_ERROR;
}


// CWbemObjectPathSecurity methods

//***************************************************************************
//
// CWbemObjectPathSecurity::CWbemObjectPathSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::CWbemObjectPathSecurity (
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_authnSpecified (false),
		m_impSpecified (false),
		m_cRef (1)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	
	if (pSecurity)
	{
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		else
			m_pPrivilegeSet = new CSWbemPrivilegeSet ();

		pSecurity->get_AuthenticationLevel (&m_authnLevel);
		pSecurity->get_ImpersonationLevel (&m_impLevel);
		m_authnSpecified = true;
		m_impSpecified = true;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_authnSpecified = false;
		m_impSpecified = false;
	}
}

//***************************************************************************
//
// CWbemObjectPathSecurity::CWbemObjectPathSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::CWbemObjectPathSecurity (
	ISWbemSecurity *pISWbemSecurity) :
		m_pPrivilegeSet (NULL),
		m_authnSpecified (false),
		m_impSpecified (false),
		m_cRef (1)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
							CLSID_SWbemSecurity, L"SWbemSecurity");
	
	if (pISWbemSecurity)
	{
		CComPtr<ISWbemPrivilegeSet> pISWbemPrivilegeSet;
		pISWbemSecurity->get_Privileges (&pISWbemPrivilegeSet);
		m_pPrivilegeSet = new CSWbemPrivilegeSet (pISWbemPrivilegeSet);
	
		pISWbemSecurity->get_AuthenticationLevel (&m_authnLevel);
		pISWbemSecurity->get_ImpersonationLevel (&m_impLevel);
		m_authnSpecified = true;
		m_impSpecified = true;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_authnSpecified = false;
		m_impSpecified = false;
	}
}

//***************************************************************************
//
// CWbemObjectPathSecurity::~CWbemObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::~CWbemObjectPathSecurity ()
{
	RELEASEANDNULL(m_pPrivilegeSet)
}

//***************************************************************************
// HRESULT CWbemObjectPathSecurity::QueryInterface
// long CWbemObjectPathSecurity::AddRef
// long CWbemObjectPathSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************
STDMETHODIMP CSWbemObjectPath::CWbemObjectPathSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;


    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::CWbemObjectPathSecurity::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::CWbemObjectPathSecurity::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::CWbemObjectPathSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_authnSpecified)
	{
		*pAuthenticationLevel = m_authnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_impSpecified)
	{
		*pImpersonationLevel = m_impLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
			
//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		m_authnLevel = authenticationLevel;
		m_authnSpecified = true;
		hr = WBEM_S_NO_ERROR;
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		m_impLevel = impersonationLevel;
		m_impSpecified = true;
		hr = WBEM_S_NO_ERROR;
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemObjectPath::GetObjectPath
//
//  DESCRIPTION:
//
//  Attempts to extract the __RELPATH system property value from a WBEM object
//	and return it as a BSTR.  Note that if this object is not yet persisted
//	the __RELPATH property will be null or invalid.
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		bsPath					placeholder for the path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::GetObjectPath (
	IWbemClassObject *pIWbemClassObject,
	CComBSTR & bsPath
)
{
	bool result = false;

	if (pIWbemClassObject)
	{
		CComVariant var;

		if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_RELPATH, 0, &var, NULL, NULL))
			&& (VT_BSTR == var.vt) 
			&& (var.bstrVal)
			&& (0 < wcslen (var.bstrVal)))
		{
			bsPath = var.bstrVal;
			result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  CSWbemObjectPath::GetParentPath
//
//  DESCRIPTION:
//
//  Attempts to extract the path of the parent container for the given object.
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		bsParentPath			placeholder for the path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::GetParentPath (
	IWbemClassObject *pIWbemClassObject,
	CComBSTR & bsParentPath
)
{
	bool result = false;

	if (pIWbemClassObject)
	{
		CComVariant var;

		if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_PATH, 0, &var, NULL, NULL))
					&& (VT_BSTR == var.vt) 
					&& (var.bstrVal)
					&& (0 < wcslen (var.bstrVal)))
		{
			CWbemPathCracker pathCracker (var.bstrVal);

			if (CWbemPathCracker::wbemPathTypeError != pathCracker.GetType ())
			{
				CWbemPathCracker parentPath;

				if (pathCracker.GetParent (parentPath))
					result = parentPath.GetPathText(bsParentPath, false, true, false);
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  CSWbemObjectPath::CompareObjectPaths
//
//  DESCRIPTION:
//
//  Given an IWbemClassObject, determine whether it can "fit" the supplied
//	path
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		objectPath				cracked path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::CompareObjectPaths (
	IWbemClassObject *pIWbemClassObject, 
	CWbemPathCracker & objectPath
)
{
	bool result = false;
	CComVariant var;
	CComBSTR bsPath;
		
	// Depending on what type of path we're trying to match against
	// we get our path info appropriately
	switch (objectPath.GetType ())
	{
		case CWbemPathCracker::WbemPathType::wbemPathTypeWmi:
		{
			if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_RELPATH, 0, &var, NULL, NULL))
				&& (VT_BSTR == var.vt) 
				&& (var.bstrVal)
				&& (0 < wcslen (var.bstrVal)))
			{
				bsPath = var.bstrVal;
				result = (objectPath == bsPath);
			}
		}
			break;

	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\site.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SITE.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the WBEM site implementation
//
//***************************************************************************

#include "precomp.h"

ULONG CWbemSite::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

ULONG CWbemSite::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
// CWbemObjectSite::CWbemObjectSite
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemObjectSite::CWbemObjectSite (ISWbemInternalObject *pObject)
{
	m_pSWbemObject = pObject;

	if (m_pSWbemObject)
		m_pSWbemObject->AddRef ();
}

//***************************************************************************
//
// CWbemObjectSite::~CWbemObjectSite
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemObjectSite::~CWbemObjectSite ()
{
	if (m_pSWbemObject)
		m_pSWbemObject->Release ();
}

//***************************************************************************
//
// CWbemObjectSite::Update
//
// DESCRIPTION:
//
// Overriden virtual method to update this site
//
//***************************************************************************

void CWbemObjectSite::Update ()
{
	if (m_pSWbemObject)
		m_pSWbemObject->UpdateSite ();
}

//***************************************************************************
//
// CWbemPropertySite::CWbemPropertySite
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemPropertySite::CWbemPropertySite (CSWbemProperty *pProperty,
						IWbemClassObject *pSourceObject,
						long index)
{
	m_pSWbemProperty = pProperty;
	m_pIWbemClassObject = pSourceObject;
	m_index = index;

	if (m_pSWbemProperty)
		m_pSWbemProperty->AddRef ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->AddRef ();
}

//***************************************************************************
//
// CWbemPropertySite::~CWbemPropertySite
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemPropertySite::~CWbemPropertySite ()
{
	if (m_pSWbemProperty)
		m_pSWbemProperty->Release ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();
}

//***************************************************************************
//
// CWbemPropertySite::Update
//
// DESCRIPTION:
//
// Overriden virtual method to update this site
//
//***************************************************************************

void CWbemPropertySite::Update ()
{
	if (m_pSWbemProperty)
	{
		if (m_pIWbemClassObject)
		{
			/*
			 * Case 1 this property site is for an object;
			 * we have an embedded object deal.  We commit the
			 * new embedded object value to its owning property
			 * in the parent object.
			 */
		
			// Get the current value of the source object into a VARIANT:
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_UNKNOWN;
			var.punkVal = m_pIWbemClassObject;
			m_pIWbemClassObject->AddRef ();

			// Set the value in the parent object
			m_pSWbemProperty->UpdateEmbedded (var, m_index);
		
			// Release the value
			VariantClear (&var);
		}
		else
		{
			// Addressed by a qualifier - nothing to do
		}

		// Now delegate further to property to update itself.
		if (m_pSWbemProperty)
			m_pSWbemProperty->UpdateSite ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\util.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  UTIL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Some useful functions
//
//***************************************************************************

#include "precomp.h"
#include "assert.h"
#include "initguid.h"

#include "dispex.h"

#include <math.h>

extern CWbemErrorCache *g_pErrorCache;
extern CRITICAL_SECTION g_csErrorCache;

typedef struct {
    VARTYPE vtOkForQual;
    VARTYPE vtTest;
} Conversion;

Conversion QualConvertList[] = {
    {VT_I4, VT_I4},
    {VT_I4, VT_UI1},
    {VT_I4, VT_I2},
    {VT_R8, VT_R4},
    {VT_R8, VT_R8},
    {VT_BOOL, VT_BOOL},
    {VT_I4, VT_ERROR},
    {VT_BSTR, VT_CY},
    {VT_BSTR, VT_DATE},
    {VT_BSTR, VT_BSTR}};

//***************************************************************************
//
// GetAcceptableQualType(VARTYPE vt)
//
// DESCRIPTION:
//
// Only certain types are acceptable for qualifiers.  This routine takes a 
// vartype and returns an acceptable conversion type.  Note that if the type is
// already acceptable, then it is returned.
//
//***************************************************************************

VARTYPE GetAcceptableQualType(VARTYPE vt)
{
    int iCnt;    
    VARTYPE vtArrayBit = vt & VT_ARRAY;
    VARTYPE vtSimple = vt & ~(VT_ARRAY | VT_BYREF);
    int iSize = sizeof(QualConvertList) / sizeof(Conversion);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(vtSimple == QualConvertList[iCnt].vtTest)
            return QualConvertList[iCnt].vtOkForQual | vtArrayBit;
    return VT_ILLEGAL;
}

//***************************************************************************
//
//  SCODE MapFromCIMOMObject
//
//  Description: 
//
//  This function filters out embedded objects that have been passed in
//	from CIMOM, ensuring they are returned to the automation environment
//	as VT_DISPATCH types.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

HRESULT MapFromCIMOMObject(CSWbemServices *pService, 
								VARIANT *pVal,
								ISWbemInternalObject *pSWbemObject,
								BSTR propertyName,
								long index)

{
	HRESULT hr = S_OK;

    if(pVal->vt == VT_UNKNOWN)
    {
		/*
		 * This may be an embedded object. If it is replace by it's
		 * scriptable equivalent. If not leave it be.
		 */
		if (pVal->punkVal)
		{
			CComQIPtr<IWbemClassObject> pIWbemClassObject (pVal->punkVal);

			if (pIWbemClassObject)
			{
				// Yowzer - it's one of ours
				CSWbemObject *pNew = new CSWbemObject (pService, pIWbemClassObject);

				if (pNew)
				{
					CComQIPtr<IDispatch> pIDispatch (reinterpret_cast<IUnknown*>(pNew));

					if (pIDispatch)
					{	
						// Conversion succeeded - replace the punkVal by a pdispVal
						pVal->punkVal->Release ();
						pVal->punkVal = NULL;

						// Transfer the AddRef'd pointer from the QI call above to the Variant
						pVal->pdispVal = pIDispatch.Detach ();	
						pVal->vt = VT_DISPATCH;
					
						if (pSWbemObject)
						{
							// Our newly create CSWbemObject is an embedded object
							// we need to set its site
							pNew->SetSite (pSWbemObject, propertyName, index);
						}
					}
					else
					{
						// This should NEVER happen, but just in case
						delete pNew;
						hr = WBEM_E_FAILED;
					}
				}
				else
					hr = WBEM_E_OUT_OF_MEMORY;
			}
		}

	}
	else if(pVal->vt == (VT_UNKNOWN | VT_ARRAY))
    {
		// got an array of objects.  Replace the object pointers with a wrapper
        // pointer

        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(pVal->parray, 1, &lLBound);
        SafeArrayGetUBound(pVal->parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        // Update the individual data pieces
        // ================================
		bool ok = true;

        for(long lIndex = lLBound; ok && (lIndex <= lUBound); lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			
			CComPtr<IUnknown> pUnk;

            if (FAILED(SafeArrayGetElement(pVal->parray, &lIndex, &pUnk)) || !pUnk)
			{
				ok = false;
				hr = WBEM_E_FAILED;
			}
			else
			{
				CComQIPtr<IWbemClassObject> pIWbemClassObject (pUnk);

				if (pIWbemClassObject)
				{
					CSWbemObject *pNew = new CSWbemObject (pService, pIWbemClassObject);

					if (pNew)
					{
						CComQIPtr<IDispatch> pIDispatch (reinterpret_cast<IUnknown*>(pNew));

						if (pIDispatch)
						{
							if (FAILED(SafeArrayPutElement(pVal->parray, &lIndex, pIDispatch)))
							{
								hr = WBEM_E_FAILED;
								ok = false;
							}
							else
							{
								pVal->vt = VT_ARRAY | VT_DISPATCH;

								if (pSWbemObject)
								{
									// This element is an embedded object.  We must set it's site.
									pNew->SetSite (pSWbemObject, propertyName, lIndex);
								}
							}
						}
						else
						{
							// This should NEVER happen, but just in case
							delete pNew;
							hr = WBEM_E_FAILED;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
						ok = false;
					}
				}
			}
        }
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT MapToCIMOMObject
//
//  Description: 
//
//  This function filters out embedded objects that have been passed in
//	as VT_DISPATCH (possibly combined with VT_BYREF or VT_ARRAY).  The
//	object is recast inside a VT_UNKNOWN so it can be accepted by CIMOM.
//
//  Parameters:
//
//  pVal		The input variant to check
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT MapToCIMOMObject(
	VARIANT *pVal
)
{
	HRESULT hRes = S_OK;

    if(pVal->vt == VT_DISPATCH || (pVal->vt == (VT_DISPATCH | VT_BYREF)))
    {
		/*
		 * We may have an embedded object. Replace the object pointer with 
		 * a wrapper pointer.
		 */
        IDispatch *pDisp = NULL;
		
		if (V_ISBYREF(pVal) && (pVal->ppdispVal))
			pDisp = *(pVal->ppdispVal);
		else if (VT_DISPATCH == V_VT(pVal))
			pDisp = pVal->pdispVal;
		
		if (pDisp)
		{
			// If successful this will AddRef the returned interface
            IWbemClassObject *pObj = CSWbemObject::GetIWbemClassObject (pDisp);

			if (pObj)
			{
				// Release the dispatch pointer as we are about to remove it from the
				// VARIANT, but only if it wasn't a VT_BYREF (because byrefs don't
				// get AddRef'd by VariantCopy or Released by VariantClear).
				if (!V_ISBYREF(pVal))
					pDisp->Release ();

				pVal->punkVal = pObj;
		        pVal->vt = VT_UNKNOWN;
			}
			else
			{
				/*
				 * Rather than just cast IDispatch* to IUnknown*, we do a QI
				 * with a release just in case the object has per-interface
				 * ref counting.
				 */
				if (SUCCEEDED (hRes = pDisp->QueryInterface (IID_IUnknown, (PPVOID) &(pVal->punkVal))))
				{
					pDisp->Release ();
					pVal->vt = VT_UNKNOWN;
				}
            }
        }
	}
	else if(pVal->vt == (VT_DISPATCH | VT_ARRAY))
    {
		// got an array of embedded objects.  Replace the object pointers with a wrapper
        // pointer

        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(pVal->parray, 1, &lLBound);
        SafeArrayGetUBound(pVal->parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        // Update the individual data pieces
        // ================================
		long lIndex;

        for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			IDispatch * pDisp = NULL;

			if (FAILED (hRes = SafeArrayGetElement(pVal->parray, &lIndex, &pDisp)))
				break;
			
			if (pDisp)
			{
				// If successful this will AddRef the returned interface
				IWbemClassObject *pObj = CSWbemObject::GetIWbemClassObject (pDisp);
				
				if (pObj)
				{
					pDisp->Release ();  // Balances the SafeArrayGetElement call

					// Put it into the new array
					// =========================
					hRes = SafeArrayPutElement(pVal->parray, &lIndex, pObj);
					pObj->Release (); // balances CSWbemObject::GetIWbemClassObject call

					if (FAILED (hRes))
						break;
					else
						pVal->vt = VT_UNKNOWN | VT_ARRAY;
				}
				else
				{
					/*
					 * Rather than just cast IDispatch* to IUnknown*, we do a QI
					 * with a release just in case the object has per-interface
					 * ref counting.
					 */
					IUnknown *pUnk = NULL;

					if (SUCCEEDED (hRes = pDisp->QueryInterface (IID_IUnknown, (PPVOID) &pUnk)))
					{
						pDisp->Release ();  // Balances the SafeArrayGetElement call
						hRes = SafeArrayPutElement(pVal->parray, &lIndex, pUnk);
						pUnk->Release (); // Balances the QI call

						if (FAILED (hRes))
							break;
						else
							pVal->vt = VT_UNKNOWN | VT_ARRAY;
					}
					else
					{
						pDisp->Release ();  // Balances the SafeArrayGetElement call
						break;
					}
				}	
			}
			else
				break;
        }

		if (lUBound < lIndex)
		{
			hRes = WBEM_S_NO_ERROR;
			pVal->vt = VT_UNKNOWN | VT_ARRAY;
		}
	}

	return hRes;
}

//***************************************************************************
//
//  HRESULT SetSite
//
//  Description: 
//
//  This function examines a VARIANT that has been successfully set as the
//	value of a property to determine whether it contains any embedded objects.
//	Any such objects are modified to ensure their site represents the property
//	in question.
//
//  Parameters:
//
//  pVal			The input variant to check
//	pSObject		Owning object of the property
//	propertyName	Take a wild guess
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

void SetSite (VARIANT *pVal, ISWbemInternalObject *pSObject, BSTR propertyName,
						long index)
{
	HRESULT hRes = S_OK;

	if (pVal)
	{
		if(pVal->vt == VT_DISPATCH || (pVal->vt == (VT_DISPATCH | VT_BYREF)))
		{
			// Could  be an embedded object
			IDispatch *pDisp = NULL;
			
			if (VT_DISPATCH == V_VT(pVal))
				pDisp = pVal->pdispVal;
			else if (NULL != pVal->ppdispVal)
				pDisp = *(pVal->ppdispVal);

			if (pDisp)
				CSWbemObject::SetSite (pDisp, pSObject, propertyName, index);
		}
		else if(pVal->vt == (VT_DISPATCH | VT_ARRAY))
		{
			// Could be an array of embedded objects.  

			SAFEARRAYBOUND aBounds[1];

			long lLBound, lUBound;
			SafeArrayGetLBound(pVal->parray, 1, &lLBound);
			SafeArrayGetUBound(pVal->parray, 1, &lUBound);

			aBounds[0].cElements = lUBound - lLBound + 1;
			aBounds[0].lLbound = lLBound;

			// Update the individual data pieces
			// ================================
			long lIndex;

			for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
			{
				// Load the initial data element into a VARIANT
				// ============================================
				IDispatch * pDisp = NULL;

				if (FAILED (hRes = SafeArrayGetElement(pVal->parray, &lIndex, &pDisp)))
					break;
				
				if (pDisp)
				{
					CSWbemObject::SetSite (pDisp, pSObject, propertyName, lIndex);
					pDisp->Release ();	// To balance AddRef from SafeArrayGetElement
				}
				else
					break;
			}
		}
	}
}

//***************************************************************************
//
//  HRESULT ConvertArray
//
//  Description: 
//
//  This function is applied to VARIANT arrays in order to check for certain
//  restrictions imposed by CIMOM (e.g. they must be homogeneous) or perform
//  conversions (certain VARIANT types have to be mapped to acceptable CIMOM
//	types).
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertArray(VARIANT * pDest, VARIANT * pSrc, BOOL bQualTypesOnly,
					 VARTYPE requiredVarType)
{
	VARTYPE vtPut;
  
	// Now is not (yet) the time to perform SWbemObject->IWbemClassObject conversion
	if (VT_UNKNOWN == requiredVarType)
		requiredVarType = VT_DISPATCH;

	// Treat these imposters just the same...
	if (VT_EMPTY == requiredVarType)
		requiredVarType = VT_NULL;

    if(pSrc == NULL || pDest == NULL)
        return WBEM_E_FAILED;

	if (!(V_VT(pSrc) & VT_ARRAY) || !(V_VT(pSrc) & VT_VARIANT))
		return WBEM_E_FAILED;

	// Extract the source SAFEARRAY (how depends on whether VT_BYREF is set)
	SAFEARRAY *parray = NULL;

	if (VT_BYREF & V_VT(pSrc))
	{
		if (pSrc->pparray)
			parray = *(pSrc->pparray);
	}
	else
		parray = pSrc->parray;


	if (!parray)
		return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(parray);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(parray,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(parray,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 

    if(iNumElements == 0)
	{
		// Degenerate case of an empty array - simply create an empty
		// copy with a VT_VARIANT type for properties
		if (!bQualTypesOnly)
			vtPut = VT_VARIANT;
		else 
		{
			// For qualifiers, we can hope that we've been given a candidate
			// type from an existing value; otherwise we'll just have to make one up.
			vtPut = (VT_NULL != requiredVarType) ? requiredVarType : VT_I4;
		}
	}
	else
	{
		// Use an explicit type if it was supplied
		if (VT_NULL != requiredVarType)
		{
			vtPut = requiredVarType;
		}
		else
		{
			// Try an infer one from the array supplied
			// Make sure all the elements of the source array are of the same type.

			for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
			{
				VARIANT var;
				VariantInit(&var);
                   
				sc = SafeArrayGetElement(parray,ix,&var);
				if(sc != S_OK)
					return sc;
				VARTYPE vt =  var.vt;
				VariantClear(&var);

				if(ix[0] == lLower)
					vtPut = vt;
				else if (vtPut != vt)
				{
					// The vartype is different from that previously encountered.
					// In general this is an error, but it is possible that we may
					// wish to "upcast" to a common vartype in certain circumstances,
					// as the automation controller may return heterogenous arrays.
					// The only cases in which this applies are:
					//
					//	1. VT_UI1, VT_I2, VT_I4 should be upcast to the widest
					//	   occurring type in the array.
					//
					//	2. VT_R4, VT_R8 should be upcast to the widest occuring type
					//     in the array
					//
					//	All other cases are treated as an error.

					bool error = true;

					switch (vtPut)
					{
						case VT_UI1:
							if ((VT_I2 == vt) || (VT_I4 == vt))
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_I2:
							if (VT_UI1 == vt)
							{
								error = false;
							}
							else if (VT_I4 == vt)
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_I4:
							if ((VT_I2 == vt) || (VT_UI1 == vt))
								error = false;
							break;

						case VT_R4:
							if (VT_R8 == vt)
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_R8:
							if (VT_R4 == vt)
								error = false;
							break;
					}

					if (error)
						return WBEM_E_INVALID_PARAMETER;
				}
			}

			// Having made our best guess, we may need to refine it
			// if we are being restricted to qualifier types only
			if(bQualTypesOnly)
				vtPut = GetAcceptableQualType(vtPut);
		}
	}

    // Create a destination array of equal size
    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    SAFEARRAY * pDestArray = SafeArrayCreate(vtPut,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
                   
        sc = SafeArrayGetElement(parray,ix,&var);
        if(sc != S_OK)
		{
			SafeArrayDestroy (pDestArray);
            return sc;
		}

        if(var.vt != vtPut)
        {
            // do the conversion to the acceptable type and put that

            VARIANT vTemp;
            VariantInit(&vTemp);
            LCID lcid = GetSystemDefaultLCID();
            sc = VariantChangeTypeEx(&vTemp, &var, lcid, 0, vtPut);

            if(sc != S_OK)
			{
				SafeArrayDestroy (pDestArray);
                return sc;
			}

            if(vtPut == VT_BSTR || vtPut == VT_UNKNOWN || vtPut == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)vTemp.bstrVal);
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)&vTemp.lVal);

            VariantClear(&vTemp);
        }
        else
        {
            if(vtPut == VT_BSTR || vtPut == VT_UNKNOWN || vtPut == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)var.bstrVal);
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)&var.lVal);
        }

        VariantClear(&var);
    }

    pDest->vt = (VT_ARRAY | vtPut);
    pDest->parray = pDestArray;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT ConvertArrayRev
//
//  Description: 
//
//  This function is applied to outbound VARIANT arrays in order to transform
//	VARIANT arrays so that each member is a VT_VARIANT rather than a simple
//	type (VT_BSTR).  This is done so that certain automation environments
//	(such as VBScript) can correctly interpret array values.
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertArrayRev(VARIANT *pDest, VARIANT *pSrc)
{
    if(pSrc == NULL || pDest == NULL || (0 == (pSrc->vt & VT_ARRAY)))
        return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(pSrc->parray);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(pSrc->parray,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(pSrc->parray,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 
    
    VARTYPE vtSimple = pSrc->vt & ~VT_ARRAY;
    
    // Create a destination array of equal size

    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    SAFEARRAY *pDestArray = SafeArrayCreate(VT_VARIANT,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
		var.vt = vtSimple;
                   
		switch (var.vt)
		{
			case VT_BSTR:
			{
				BSTR bstrVal = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &bstrVal)))
				{
					var.bstrVal = SysAllocString (bstrVal);
					SysFreeString (bstrVal);
				}
			}
				break;

			case VT_DISPATCH:
			{
				IDispatch *pDispatch = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &pDispatch)))
					var.pdispVal = pDispatch;
			}
				break;

			case VT_UNKNOWN:
			{
				IUnknown *pUnknown = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &pUnknown)))
					var.punkVal = pUnknown;
			}
				break;

			default:
			{
				// Assume simple integer value
				sc = SafeArrayGetElement (pSrc->parray, ix, &(var.lVal));
			}
				break;
		}

		if(sc != S_OK)
            return sc;

		sc = SafeArrayPutElement (pDestArray, ix, &var);
        VariantClear(&var);
    }

    pDest->vt = (VT_ARRAY | VT_VARIANT);
    pDest->parray = pDestArray;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT ConvertBSTRArray
//
//  Description: 
//
//  This function is applied to outbound SAFEARRAY's of BSTRs in order to 
//	transform then into SAFEARRAY's of VARIANTs (each of type VT_BSTR).  This
//	is required by scripting environments (such as VBScript0 which do not
//	support SAFEARRAY of non-VARIANT types.
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertBSTRArray(SAFEARRAY **ppDest, SAFEARRAY *pSrc)
{
    if(pSrc == NULL || ppDest == NULL)
        return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(pSrc);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(pSrc,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(pSrc,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 
    if(iNumElements == 0)
        return WBEM_E_FAILED;

    // Create a destination array of equal size

    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    *ppDest = SafeArrayCreate(VT_VARIANT,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
		var.vt = VT_BSTR;
                   
		BSTR bstrVal = NULL;
		if (S_OK == (sc = SafeArrayGetElement (pSrc, ix, &bstrVal)))
		{
			var.bstrVal = SysAllocString (bstrVal);
			SysFreeString (bstrVal);
		}
		
		if(sc != S_OK)
            return sc;

		sc = SafeArrayPutElement (*ppDest, ix, &var);
        VariantClear(&var);
    }

    return S_OK;
}

//***************************************************************************
//
//  HRESULT QualifierVariantChangeType
//
//  DESCRIPTION:
//
//  Just like VariantChangeType, but deals with arrays as well.
//
//  PARAMETERS:
//
//  VARIANT pvDest      Destination variant
//  VARIANT pvSrc       Source variant (can be the same as pvDest)
//  VARTYPE vtNew       The type to coerce to.
//
//***************************************************************************

HRESULT QualifierVariantChangeType (VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres = DISP_E_TYPEMISMATCH;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if (vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

		// Create a new array
        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);
        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);
        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);
        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);
		long lIndex;

		for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
		{
			// Load the initial data element into a VARIANT
			// ============================================
			VARIANT vSrcEl;
			VariantInit (&vSrcEl);
			V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
			SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));

			// Cast it to the new type
			// =======================
			if (SUCCEEDED (hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY)))
			{
				// Put it into the new array
				// =========================
				if(V_VT(&vSrcEl) == VT_BSTR)
					hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
				else
					hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
			}

			VariantClear (&vSrcEl);

			if (FAILED(hres)) 
				break;
		}

		if (lUBound < lIndex)
		{
			hres = WBEM_S_NO_ERROR;
			if(pvDest == pvSrc)
				VariantClear(pvSrc);

			V_VT(pvDest) = vtNew;
			V_ARRAY(pvDest) = psaDest;
		}
		else
			SafeArrayDestroy (psaDest);
    }
    else
	    hres = VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);

	return hres;
}

//***************************************************************************
//
//  void SetWbemError
//
//  DESCRIPTION:
//
//  For remoted WBEM COM interfaces, extra error information may be returned
//	on the thread as an IWbemClassObject.  This routine extracts that object
//	(if found) amd stores it in thread local-storage as an ISWbemObject.  The
//	object can be accessed later using the SWbemLastError coclass.
//
//  PARAMETERS:
//
//  pService		The backpointer to the CSWbemServices (used in case
//						we do property/method access on the error object)
//
//***************************************************************************

void SetWbemError (CSWbemServices *pService)
{
	EnterCriticalSection (&g_csErrorCache);

	if (g_pErrorCache)
		g_pErrorCache->SetCurrentThreadError (pService);

	LeaveCriticalSection (&g_csErrorCache);
}

//***************************************************************************
//
//  void ResetLastErrors
//
//  DESCRIPTION:
//
//  For remoted WBEM COM interfaces, extra error information may be returned
//	on the thread as an IWbemClassObject.  This routine clears that error.  It
//  also clears the ErrorInfo on the thread.  This should be called at the 
//  start of any of the API functions
//
//  PARAMETERS:
//
//***************************************************************************

void ResetLastErrors ()
{

	SetErrorInfo(0, NULL);

	EnterCriticalSection (&g_csErrorCache);

	if (g_pErrorCache)
		g_pErrorCache->ResetCurrentThreadError ();

	LeaveCriticalSection (&g_csErrorCache);
}

//***************************************************************************
//
//  HRESULT SetException
//
//  Description: 
//
//  This function fills in an EXECPINFO structure using the supplied HRESULT
//	and object name.  The former is mapped to the Err.Description property, 
//	and the latter to the Err.Source property.
//
//  Parameters:
//
//  pExcepInfo		pointer to EXCEPINFO to initialize (must not be NULL)
//	hr				HRESULT to map to string
//	bsObjectName	Name of source object that generated the error
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

void SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR bsObjectName)
{
	if (pExcepInfo->bstrDescription)
		SysFreeString (pExcepInfo->bstrDescription);

	pExcepInfo->bstrDescription = MapHresultToWmiDescription (hr);

	if (pExcepInfo->bstrSource)
		SysFreeString (pExcepInfo->bstrSource);

	pExcepInfo->bstrSource = SysAllocString (bsObjectName);
	pExcepInfo->scode = hr;
}

//***************************************************************************
//
//  HRESULT MapHresultToWmiDescription
//
//  Description: 
//
//  Thin wrapper around the IWbemStatusCodeText implementation.  Transforms
//	an HRESULT (which may or may not be a WMI-specific error code) into a
//	localized user-friendly description.
//
//  Parameters:
//
//	  hr				HRESULT to map to string
//
// Return Value:
//    BSTR containing the description (or NULL).
//***************************************************************************

BSTR MapHresultToWmiDescription (HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator 
	IWbemStatusCodeText *pErrorCodeTranslator = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTranslator);
	
	if (SUCCEEDED (result))
	{
		HRESULT hrCode = hr;

		// Some WBEM success codes become Scripting error codes.

		if (wbemErrTimedout == hr)
			hrCode = WBEM_S_TIMEDOUT;
		else if (wbemErrResetToDefault == hr)
			hrCode = WBEM_S_RESET_TO_DEFAULT;

		HRESULT sc = pErrorCodeTranslator->GetErrorCodeText(
							hrCode, (LCID) 0, WBEMSTATUS_FORMAT_NO_NEWLINE, &bsMessageText);	

		pErrorCodeTranslator->Release ();		
	}

	return bsMessageText;
}

	
//***************************************************************************
//
//  HRESULT ConvertDispatchToArray
//
//  DESCRIPTION:
//
//  Attempt to convert from an IDispatch value to a CIM array value (property
//	qualifier or context).
//
//  PARAMETERS:
//
//		pDest		Output value
//		pSrc		Input value
//		lCimType	CIM Property type (underlying the array) - defaults to
//					CIM_ILLEGAL for Qualifier & Context value mappings.
//		bIsQual		true iff we are mapping for a qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT ConvertDispatchToArray (
	VARIANT *pvDest,
	VARIANT *pvSrc,
	CIMTYPE lCimType,
	BOOL bIsQual,
	VARTYPE requiredQualifierType
)
{
	HRESULT hr = WBEM_E_FAILED; // Default error
	IDispatch * pDispatch = NULL;
  
	/*
	 * Extract the IDispatch pointer. NB we assume the VT of pSrc is
	 * VT_DISPATCH (possibly combined with VT_BYREF) for this function to
	 * have been called.
	 */
	if (VT_DISPATCH == V_VT(pvSrc))
		pDispatch = pvSrc->pdispVal;
    else if (pvSrc->ppdispVal)
		pDispatch = *(pvSrc->ppdispVal);
        
	if (NULL == pDispatch)
		return hr;

	// The expected var type of the property
	VARTYPE expectedVarType = VT_ERROR;
	
	if (CIM_ILLEGAL != lCimType)
		expectedVarType = CimTypeToVtType (lCimType);

	CComQIPtr<IDispatchEx> pIDispatchEx (pDispatch);

	/*
	 * We use the IDispatchEx interface to iterate through the properties
	 * of the interface.
	 */
	if (pIDispatchEx)
	{
		/*
		 * Looks promising, but just check if this isn't one of our objects
		 */
		CComQIPtr<ISWbemObject> pISWbemObject (pDispatch);

		if (!pISWbemObject)
		{
			/*
			 * Start by determining how many properties there are so we can create
			 * a suitable array.
			 */
			long propertyCount = 0;
			DISPID dispId = DISPID_STARTENUM;
			DISPPARAMS dispParams;
			dispParams.rgvarg = NULL;
			dispParams.rgdispidNamedArgs = NULL;
			dispParams.cArgs = 0;
			dispParams.cNamedArgs = 0;

			while (S_OK == pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId))
			{
				if ((0 == propertyCount) && (VT_ERROR == expectedVarType))
				{
					/*
					 * If we are setting an array value for a context/qualifier, the
					 * Vartype will not yet be determined - we will use the best
					 * we can from the first array value.
					 */
					VARIANT vPropVal;
					VariantInit (&vPropVal);

					if (SUCCEEDED (pIDispatchEx->InvokeEx (dispId, 0, 
								DISPATCH_PROPERTYGET, &dispParams, &vPropVal, NULL, NULL)))
					{
						if (bIsQual)
							expectedVarType = GetAcceptableQualType(V_VT(&vPropVal));
						else if (VT_DISPATCH == V_VT(&vPropVal))
							expectedVarType = VT_UNKNOWN;
						else
							expectedVarType = V_VT(&vPropVal);
					}

					VariantClear (&vPropVal);
				}
				propertyCount++;
			}
			
			// Create the safearray - note that it may be empty
			SAFEARRAYBOUND rgsaBound;
			rgsaBound.cElements = propertyCount;
			rgsaBound.lLbound = 0;

			SAFEARRAY *pArray = SafeArrayCreate (expectedVarType, 1, &rgsaBound);
				
			if (0 < propertyCount)
			{
				// Enumerate the DISPIDs on this interface
				dispId = DISPID_STARTENUM;
				long nextExpectedIndex = 0;
				HRESULT enumHr;
				wchar_t *stopString = NULL;

				/*
				 * For JScript arrays, the property names are the specified indices of the 
				 * the array; these can be integer indices or they can be strings.  We make
				 * the following requirements of the array indices:
				 *
				 * (1) All of the indices are non-negative integers
				 * (2) The indices start at 0 and are contiguous.
				 */

				while (S_OK == (enumHr = pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId)))
				{
					BSTR memberName = NULL;
					if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
					{
					
						// Check that property name is numeric
						long index = wcstol (memberName, &stopString, 10);

						if ((0 != wcslen (stopString)))
						{
							// Failure - cannot convert to integer
							SysFreeString (memberName);
							memberName = NULL;
							break;
						}
						SysFreeString (memberName);
						memberName = NULL;
						
						if (index != nextExpectedIndex)
						{
							// Failure - non-contiguous array
							break;
						}

						nextExpectedIndex++;

						// Extract the property
						VARIANT vPropVal;
						VariantInit (&vPropVal);
						HRESULT hrInvoke;
							
						if (SUCCEEDED (hrInvoke = pIDispatchEx->InvokeEx (dispId, 0, 
									DISPATCH_PROPERTYGET, &dispParams, &vPropVal, NULL, NULL)))
						{
							HRESULT hr2 = WBEM_E_FAILED;

							// Take care of embedded objects
							if ((S_OK == MapToCIMOMObject (&vPropVal)) &&
								(S_OK == VariantChangeType (&vPropVal, &vPropVal, 0, expectedVarType)))
							{

								switch (expectedVarType)
								{
									case VT_BSTR:
										hr2 = SafeArrayPutElement (pArray, &index, (void*)vPropVal.bstrVal);
										break;

									case VT_UNKNOWN:
										if (!bIsQual)
											hr2 = SafeArrayPutElement (pArray, &index, (void*)vPropVal.punkVal);
										break;

									default:
										hr2 = SafeArrayPutElement (pArray, &index, (void*)&vPropVal.lVal);
										break;
								}
							}

							VariantClear (&vPropVal);

							if (FAILED(hr2))
								break;
						}
						else
						{
							// Failure - couldn't invoke method
							break;
						}
					} // GetMemberName SUCCEEDED
				} // while loop

				if (S_FALSE == enumHr)
				{
					// Now construct the new property value using our array
					VariantInit (pvDest);
					pvDest->vt = VT_ARRAY | expectedVarType;
					pvDest->parray = pArray;
					hr = S_OK;
				}
				else
				{
					// Something went wrong
					SafeArrayDestroy (pArray);
				}
			}	
			else
			{
				// Degenerate case of an empty array - simply create an empty
				// copy with a VT_VARIANT type for properties
				if (!bIsQual)
					expectedVarType = VT_VARIANT;
				else 
				{
					// For qualifiers, we can hope that we've been given a candidate
					// type from an existing value; otherwise we'll just have to make one up.
					expectedVarType = (VT_NULL != requiredQualifierType) ? requiredQualifierType :
																VT_I4;
				}

				VariantInit (pvDest);
				pvDest->vt = VT_ARRAY | expectedVarType;
				pvDest->parray = pArray;
				hr = S_OK;
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  void MapNulls
//
//  Description: 
//
//  The passing of a "null" value from script (where "null" in VB/VBS and JS
//	is the keyword null, and is an undefined variable in Perl) may be interpreted
//	by this API as equivalent to a default value for certain method calls.
//
//	This function is used to map VT_NULL dispatch parameters to the VB standard
//	realization of "missing" parameters, i.e. a VT_ERROR value whose scode is
//	DISP_E_PARAMNOTFOUND.
//
//  Parameters:
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

void	MapNulls (DISPPARAMS FAR* pdispparams)
{
	if (pdispparams)
	{
		for (unsigned int i = 0; i < pdispparams->cArgs; i++)
		{
			VARIANTARG &v = pdispparams->rgvarg [i];

			if (VT_NULL == V_VT(&v))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
			else if (((VT_VARIANT|VT_BYREF) == V_VT(&v)) &&
					 (VT_NULL == V_VT(v.pvarVal)))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
		}
	}
}

//***************************************************************************
//
//  BSTR FormatAssociatorsQuery
//
//  Description: 
//
//  Takes the parameters to an AssociatorsOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatAssociatorsQuery 
( 
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  associators of {SourceObject} where    
	//  AssocClass = AssocClassName
	//  ClassDefsOnly    
	//  SchemaOnly
	//  RequiredAssocQualifier = QualifierName
	//  RequiredQualifier = QualifierName    
	//  ResultClass = ClassName
	//  ResultRole = PropertyName    
	//  Role = PropertyName

	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WBEMS_QUERY_ASSOCOF) +
				   wcslen (WBEMS_QUERY_OPENBRACE) +
				   wcslen (WBEMS_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	bool needWhere = false;

	if ((strAssocClass && (0 < wcslen (strAssocClass))) ||
		(strResultClass && (0 < wcslen (strResultClass))) ||
		(strResultRole && (0 < wcslen (strResultRole))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier))) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = true;
		queryLength += wcslen (WBEMS_QUERY_WHERE);
	}

	if (strAssocClass && (0 < wcslen (strAssocClass)))
		queryLength += wcslen (WBEMS_QUERY_ASSOCCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strAssocClass);

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WBEMS_QUERY_RESCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strResultRole && (0 < wcslen (strResultRole)))
		queryLength += wcslen (WBEMS_QUERY_RESROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultRole);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WBEMS_QUERY_ROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WBEMS_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WBEMS_QUERY_SCHEMAONLY);

	if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQASSOCQ) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredAssocQualifier);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQQUAL) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WBEMS_QUERY_ASSOCOF, queryLength);
	wcscat (bsQuery, WBEMS_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WBEMS_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WBEMS_QUERY_WHERE);

		if (strAssocClass && (0 < wcslen (strAssocClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ASSOCCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strAssocClass);
		}

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}
		
		if (strResultRole && (0 < wcslen (strResultRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultRole);
		}

		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WBEMS_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WBEMS_QUERY_SCHEMAONLY);

		if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQASSOCQ);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredAssocQualifier);
		}
			
		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQQUAL);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}


	return bsQuery;
}


//***************************************************************************
//
//  BSTR FormatReferencesQuery
//
//  Description: 
//
//  Takes the parameters to an ReferencesOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatReferencesQuery 
( 
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  references of {SourceObject} where    
	//  ClassDefsOnly    
	//  SchemaOnly
	//  RequiredQualifier = QualifierName    
	//  ResultClass = ClassName
	//  Role = PropertyName
	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WBEMS_QUERY_REFOF) +
				   wcslen (WBEMS_QUERY_OPENBRACE) +
				   wcslen (WBEMS_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	bool needWhere = false;

	if ((strResultClass && (0 < wcslen (strResultClass))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = true;
		queryLength += wcslen (WBEMS_QUERY_WHERE);
	}

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WBEMS_QUERY_RESCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WBEMS_QUERY_ROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WBEMS_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WBEMS_QUERY_SCHEMAONLY);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQQUAL) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WBEMS_QUERY_REFOF, queryLength);
	wcscat (bsQuery, WBEMS_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WBEMS_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WBEMS_QUERY_WHERE);

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}
		
		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WBEMS_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WBEMS_QUERY_SCHEMAONLY);

		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQQUAL);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}

	return bsQuery;
}

//***************************************************************************
//
//  BSTR FormatMultiQuery
//
//  Description: 
//
//  Takes an array of class names and formats a multi query
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  classArray		SAFEARRAY of class names
//	iNumElements	length of array
//
//***************************************************************************

BSTR FormatMultiQuery ( 
	SAFEARRAY & classArray,
	long		iNumElements
)
{
	BSTR bsQuery = NULL;
	
	long queryLength = 1; // Terminating NULL
	queryLength += (iNumElements * wcslen (WBEMS_QUERY_SELECT)) +
				   ((iNumElements - 1) * wcslen (WBEMS_QUERY_GO));

	// Work out the string lengths
	HRESULT hr = S_OK;

	for (long i = 0; i < iNumElements && hr == S_OK; i++) 
	{
		BSTR bsName = NULL;
                   
		if (SUCCEEDED(hr = SafeArrayGetElement(&classArray, &i, &bsName)))
		{
			queryLength += wcslen (bsName);
			SysFreeString (bsName);
		}
	}

	if (SUCCEEDED(hr))
	{
		// Allocate the string and fill it in
		bsQuery = SysAllocStringLen (WBEMS_QUERY_SELECT, queryLength);

		for (long i = 0; i < iNumElements && hr == S_OK; i++) 
		{
			BSTR bsName = NULL;
                   
			if (SUCCEEDED(hr = SafeArrayGetElement(&classArray, &i, &bsName)))
			{
				if (i > 0)
					wcscat (bsQuery, WBEMS_QUERY_SELECT);

				wcscat (bsQuery, bsName);
				SysFreeString (bsName);

				if (i < iNumElements - 1)
					wcscat (bsQuery, WBEMS_QUERY_GO);
			}
		}
	}

	return bsQuery;
}

//***************************************************************************
//
//  EnsureGlobalsInitialized
//
//  DESCRIPTION:
//
//  Checks whether the g_pErrorCache global pointer is correctly initialized 
//	and, if not, assigns it appropriately.
//
//***************************************************************************

void EnsureGlobalsInitialized ()
{
	// Initialize security
	CSWbemSecurity::Initialize ();
	
	EnterCriticalSection (&g_csErrorCache);

	// Initlialize the error cache if proof be need be
	if ( ! g_pErrorCache )
		g_pErrorCache = new CWbemErrorCache ();
	
	LeaveCriticalSection (&g_csErrorCache);
}

#ifdef _RDEBUG

#undef _RPrint

void _RRPrint(int line, const char *file, const char *func, 
											const char *str, long code, const char *str2) 
{
	FILE *fp = fopen("c:/out.txt", "a");

	fprintf (fp, "%s %s(%d): %s - %s %ld(0x%lx)\n", file, func, line, str, str2, code, code);

	fclose(fp);
}
#endif


//***************************************************************************
//
//  CanCoerceString
//
//  DESCRIPTION:
//
//  Attempts to determine whether the supplied BSTR value can be cast
//	more tightly to the given CIM type.
//
//  PARAMETERS:
//		pVal		the variant in question
//		cimType		the casting CIM type
//
//  RETURN VALUES:
//		TRUE iff the cast is OK.
//
//***************************************************************************

bool CanCoerceString (
	const BSTR & bsValue,
	WbemCimtypeEnum cimType
)
{
	bool result = false;

	switch (cimType)
	{
		case wbemCimtypeReference:
		{
			CSWbemObjectPath objPath;
			result = SUCCEEDED (objPath.put_Path (bsValue));
		}
			break;

		case wbemCimtypeDatetime:
		{
			CSWbemDateTime dateTime;
			result = SUCCEEDED (dateTime.put_Value (bsValue));
		}
			break;

		case wbemCimtypeSint64:	
		{
			__int64 ri64;
			result = ReadI64(bsValue, ri64);
		}
			break;

		case wbemCimtypeUint64:
		{
			unsigned __int64 ri64;
			result = ReadUI64(bsValue, ri64);
		}
			break;

		case wbemCimtypeString:
			result = true;
			break;
	}

	return result;
}

//***************************************************************************
//
//  MapVariantTypeToCimType
//
//  DESCRIPTION:
//
//  Attempts to come up with a decent CIM type for the supplied VARIANT value.
//
//  PARAMETERS:
//		pVal		the variant in question
//		iCimType		preferred cimtype (if appropriate)
//
//  RETURN VALUES:
//		A best match CIM type
//
//***************************************************************************

WbemCimtypeEnum MapVariantTypeToCimType (
	VARIANT *pVal,
	CIMTYPE iCimType)
{
	WbemCimtypeEnum cimType = wbemCimtypeSint32;

	if (pVal)
	{
		VARIANT vTemp;
		VariantInit (&vTemp);

		if ((VT_EMPTY == V_VT(pVal)) || (VT_NULL == V_VT(pVal)))
			cimType = (CIM_ILLEGAL == iCimType) ?
							wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
		else if (((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
			     ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
        {
			// Need to dig out the array type
		    if ((S_OK == ConvertArray(&vTemp, pVal)) &&
            	(S_OK == MapToCIMOMObject(&vTemp)))
			{
				// Check for empty array
				long lLower, lUpper;

				if ((SUCCEEDED(SafeArrayGetLBound(vTemp.parray,1,&lLower))) &&
				    (SUCCEEDED(SafeArrayGetUBound(vTemp.parray,1,&lUpper))))
				{
					if (0 == lUpper - lLower + 1)
					{
						// For an empty array, we use wbemCimtypeSint32 unless
						// we have been supplied a valid override
						cimType = (CIM_ILLEGAL == iCimType) ?
							wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
					}
					else
					{
						// Pick something that matches our value and override 
						// as best we can
						cimType = GetCIMType (vTemp, iCimType, true, lLower, lUpper);
					}
				}
			}
		}
		else 
		{
			// Look for an IDispatch that needs to be mapped to an array
			if (((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal))))
			{
				if (S_OK == ConvertDispatchToArray (&vTemp, pVal, cimType & ~CIM_FLAG_ARRAY))
				{
					// Check for empty array
					long lLower, lUpper;

					if ((SUCCEEDED(SafeArrayGetLBound(vTemp.parray,1,&lLower))) &&
						(SUCCEEDED(SafeArrayGetUBound(vTemp.parray,1,&lUpper))))
					{
						if (0 == lUpper - lLower + 1)
							cimType = (CIM_ILLEGAL == iCimType) ?
									wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
						else
							cimType = GetCIMType (vTemp, iCimType, true, lLower, lUpper);
					}
				}	
				else
				{
					// Could be a plain old interface pointer for CIM_IUNKNOWN
					if (SUCCEEDED(VariantCopy (&vTemp, pVal)))
					{
						if (S_OK == MapToCIMOMObject(&vTemp))
							cimType = GetCIMType (vTemp, iCimType);
					}
				}
			}
			else
			{
				// The vanilla case
				if (SUCCEEDED(VariantCopy (&vTemp, pVal)))
				{
					if (S_OK == MapToCIMOMObject(&vTemp))
						cimType = GetCIMType (vTemp, iCimType);
				}
			}			
		}

		VariantClear (&vTemp);
	}

	return cimType;
}

//***************************************************************************
//
//  GetCIMType
//
//  DESCRIPTION:
//
//  Attempts to come up with a decent CIM type for the supplied VARIANT,
//	with (optionally) a legal CIMType "serving suggestion" to help resolve 
//	ambiguities.
//
//	Note that this function doesn't deal with empty arrays; that has 
//	already been taken care of by the caller. It also can assume that the
//	array is (VARTYPE) homogeneous, for the same reason.
//
//  PARAMETERS:
//		pVal		the variant in question
//		iCimType	preferred cimtype (if appropriate, else wbemCimtypeIllegal)
//
//  RETURN VALUES:
//		A best match CIM type
//
//***************************************************************************

WbemCimtypeEnum GetCIMType (
	VARIANT & var,
	CIMTYPE iCimType,
	bool bIsArray,
	long lLBound,
	long lUBound
)
{
	WbemCimtypeEnum cimType = wbemCimtypeSint32;

	switch (V_VT(&var) & ~VT_ARRAY)
	{
		/*
		 * Note that prior to this function being called
		 * we will have transformed VT_DISPATCH's to 
		 * VT_UNKNOWN's.
		 */
		case VT_UNKNOWN:
		{
			/*
			 * Could be an embedded object or just a regular
			 * IUnknown.
			 */
			if (bIsArray)
			{
				long ix = 0;
				bool bCanBeServingSuggestion = true;
					
				for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
				{
					CComPtr<IUnknown> pIUnknown;

					if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&pIUnknown)))
					{
						CComQIPtr<IWbemClassObject> pIWbemClassObject (pIUnknown);

						if (!pIWbemClassObject)
							bCanBeServingSuggestion = false;
					}
					else 
						bCanBeServingSuggestion = false;
				}

				if (bCanBeServingSuggestion)
					cimType = wbemCimtypeObject;
			}
			else
			{
				CComQIPtr<IWbemClassObject> pIWbemClassObject (var.punkVal);

				if (pIWbemClassObject)
					cimType = wbemCimtypeObject;
			}
		}
			break;

		case VT_EMPTY:
		case VT_ERROR:
		case VT_NULL:
			if (CIM_ILLEGAL == iCimType)
				cimType = wbemCimtypeSint32;	// Pick something
			else
				cimType = (WbemCimtypeEnum) iCimType;		// Anything goes
			break;

		case VT_VARIANT:
		case VT_DISPATCH:
			// Can't handle these with CIM types
			break;		

		case VT_I2:
		{
			cimType = wbemCimtypeSint16; // default

			switch (iCimType)
			{
				case wbemCimtypeSint32:
				case wbemCimtypeUint32:
				case wbemCimtypeSint64:
				case wbemCimtypeUint64:
				case wbemCimtypeSint16:
				case wbemCimtypeUint16:
				case wbemCimtypeChar16:
					cimType = (WbemCimtypeEnum) iCimType;
					break;
			
				// May be able to use a smaller type but
				// only if the value "fits"
				case wbemCimtypeSint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							short iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7F) || (-iVal > 0x80))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.iVal <= 0x7F) && (-var.iVal <= 0x80))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							short iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.iVal <= 0xFF) && (var.iVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;
			}
		}
			break;

		case VT_I4:
		{
			cimType = wbemCimtypeSint32;	// default

			switch (iCimType)
			{
				case wbemCimtypeSint32:
				case wbemCimtypeUint32:
				case wbemCimtypeSint64:
				case wbemCimtypeUint64:
					cimType = (WbemCimtypeEnum) iCimType;
					break;
			
				// May be able to use a smaller type but
				// only if the value "fits"
				case wbemCimtypeSint16:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7FFF) || (-iVal > 0x8000))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0x7FFF) && (-var.lVal <= 0x8000))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint16:
				case wbemCimtypeChar16:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFFFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0xFFFF) && (var.lVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeSint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7F) || (-iVal > 0x80))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0x7F) && (-var.lVal <= 0x80))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0xFF) && (var.lVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;
			}
		}
			break;

		case VT_UI1:
			if ((wbemCimtypeSint16 == iCimType) ||
				(wbemCimtypeUint16 == iCimType) ||
				(wbemCimtypeSint8 == iCimType) ||
				(wbemCimtypeUint8 == iCimType) ||
				(wbemCimtypeChar16 == iCimType) ||
				(wbemCimtypeSint32 == iCimType) ||
				(wbemCimtypeUint32 == iCimType) ||
				(wbemCimtypeSint64 == iCimType) ||
				(wbemCimtypeUint64 == iCimType))
				cimType = (WbemCimtypeEnum) iCimType;
			else
				cimType = wbemCimtypeUint8;	
			break;

		case VT_R8:
			if (wbemCimtypeReal64 == iCimType)
				cimType = (WbemCimtypeEnum) iCimType;
			else if (wbemCimtypeReal32 == iCimType)
			{
				if (bIsArray)
				{
					long ix = 0;
					bool bCanBeServingSuggestion = true;
						
					for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
					{
						double dblVal = 0;

						if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&dblVal)))
						{
							if (dblVal == (float)dblVal)
								bCanBeServingSuggestion = false;
						}
						else 
							bCanBeServingSuggestion = false;
					}

					if (bCanBeServingSuggestion)
						cimType = (WbemCimtypeEnum) iCimType;
				}
				else
				{
					if (var.dblVal == (float)(var.dblVal))
						cimType = (WbemCimtypeEnum) iCimType;
				}
			}
			else
				cimType = wbemCimtypeReal64;	
			break;

		case VT_R4:
			if ((wbemCimtypeReal32 == iCimType) ||
				(wbemCimtypeReal64 == iCimType))
				cimType = (WbemCimtypeEnum) iCimType;
			else
				cimType = wbemCimtypeReal32;	
			break;

		case VT_BOOL:
			cimType = wbemCimtypeBoolean;	
			break;

		case VT_CY:
		case VT_DATE:
			cimType = wbemCimtypeString;	// Only sensible choice
			break;

		case VT_BSTR:
		{
			cimType = wbemCimtypeString;	// Unless we get a tighter fit

			if ((wbemCimtypeString == iCimType) ||
				(wbemCimtypeDatetime == iCimType) ||
				(wbemCimtypeReference == iCimType) ||
				(wbemCimtypeUint64 == iCimType) ||
				(wbemCimtypeSint64 == iCimType))
			{
				if (bIsArray)
				{
					long ix = 0;
					bool bCanBeServingSuggestion = true;
					
					for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
					{
						BSTR bsValue = NULL;

						if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&bsValue)))
							bCanBeServingSuggestion = CanCoerceString (bsValue, (WbemCimtypeEnum) iCimType);
						else 
							bCanBeServingSuggestion = false;
						
						SysFreeString(bsValue);
					}

					if (bCanBeServingSuggestion)
						cimType = (WbemCimtypeEnum) iCimType;
				}
				else
				{
					if (CanCoerceString (var.bstrVal, (WbemCimtypeEnum) iCimType))
						cimType = (WbemCimtypeEnum) iCimType;
				}
			}
		}
			break;
	}
	
	return cimType;
}

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
bool ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return false;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return true;
        }
        
        return false;
    }

    ri64 = i64 * nSign;
    return true;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
bool ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return false;

        pwc++;
    }

    if(*pwc)
    {
        return false;
    }

    rui64 = ui64;
    return true;
}

HRESULT BuildStringArray (
	SAFEARRAY *pArray, 
	VARIANT & var
)
{
	HRESULT hr = WBEM_E_FAILED;
	SAFEARRAYBOUND rgsabound;
	rgsabound.lLbound = 0;
	long lBound = 0, uBound = -1;

	if (pArray)
	{
		SafeArrayGetUBound (pArray, 1, &uBound);
		SafeArrayGetLBound (pArray, 1, &lBound);
	}

	rgsabound.cElements = uBound + 1 - lBound;
	SAFEARRAY *pNewArray = SafeArrayCreate (VT_VARIANT, 1, &rgsabound);

	if (pNewArray)
	{
		BSTR bstrName = NULL;
		VARIANT nameVar;
		VariantInit (&nameVar);
		bool ok = true;

		/*
		 * If the source array is not empty, copy it over to the
		 * new array. Wrap each member in a Variant, and ensure indexing
		 * begins at 0.
		 */
		if (0 < rgsabound.cElements)
		{
			for (long i = 0; (i <= (rgsabound.cElements - 1)) && ok; i++)
			{
				long j = lBound + i;

				if (SUCCEEDED(SafeArrayGetElement (pArray, &j, &bstrName)))
				{
					BSTR copy = SysAllocString (bstrName);

					if (copy)
					{
						nameVar.vt = VT_BSTR;
						nameVar.bstrVal = copy;
						
						if (FAILED(SafeArrayPutElement (pNewArray, &i, &nameVar)))
						{
							ok = false;
							hr = WBEM_E_OUT_OF_MEMORY;
						}

						SysFreeString (bstrName);
						VariantClear (&nameVar);
					}
					else
					{
						ok = false;
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else 
					ok = false;
			}
		}

		if (ok)
		{
			// Now plug this array into the VARIANT
			var.vt = VT_ARRAY | VT_VARIANT;
			var.parray = pNewArray;
			hr = S_OK;
		}
		else
		{
			if (pNewArray)
				SafeArrayDestroy (pNewArray);
		}
	}
	else
		hr = WBEM_E_OUT_OF_MEMORY;

	return hr;
}

HRESULT SetFromStringArray (
	SAFEARRAY **ppArray,
	VARIANT *pVar
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pVar) || (VT_EMPTY == V_VT(pVar)) || 
				(VT_NULL == V_VT(pVar)))
	{
		if (*ppArray)
		{
			SafeArrayDestroy (*ppArray);
			*ppArray = NULL;
		}

		hr = WBEM_S_NO_ERROR;
	}
	else if (((VT_ARRAY | VT_VARIANT) == V_VT(pVar)) ||
			 ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVar)))
    {
        VARIANT vTemp;
		VariantInit (&vTemp);

        if (S_OK == ConvertArray(&vTemp, pVar))
		{
			// Is it a string array?
			if (V_VT(&vTemp) == (VT_ARRAY|VT_BSTR))
			{
				// Super - grab it out of the temporary VARIANT 
				if (*ppArray)
					SafeArrayDestroy (*ppArray);
				
				*ppArray = vTemp.parray;
				vTemp.vt = VT_NULL;
				vTemp.parray = NULL;
				hr = WBEM_S_NO_ERROR;
			}
		}

        VariantClear(&vTemp);
    }
	else 
	{
		// Look for an IDispatch that needs to be mapped to an array
		if ((VT_DISPATCH == V_VT(pVar)) 
			|| ((VT_DISPATCH|VT_BYREF) == V_VT(pVar)))
		{
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertDispatchToArray (&vTemp, pVar, wbemCimtypeString))
			{
				// Is it a string array?
				if (V_VT(&vTemp) == (VT_ARRAY|VT_BSTR))
				{
					// Super - grab it out of the temporary VARIANT 
					if (*ppArray)
						SafeArrayDestroy (*ppArray);
					
					*ppArray = vTemp.parray;
					vTemp.vt = VT_NULL;
					vTemp.parray = NULL;
					hr = WBEM_S_NO_ERROR;
				}
			}

			VariantClear (&vTemp);
		}
	}

	return hr;
}



//***************************************************************************
//
//  bool IsNullOrEmptyVariant
//
//  DESCRIPTION:
//
//  Given a VARIANT, check if it is essentially null/empty or has
//  more than one dimension
//
//  PARAMETERS:
//
//		pVar		variant to check
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool IsNullOrEmptyVariant (VARIANT & var)
{
	bool result = false;

	if ((VT_EMPTY == var.vt) || (VT_NULL == var.vt))
		result = true;
	else if (VT_ARRAY & var.vt)
	{
		// Check if array that it is not empty or NULL 

		if (!(var.parray))
			result = true;
		else
		{
			long lBound, uBound;

			if ((1 != SafeArrayGetDim (var.parray)) ||
				(
				 SUCCEEDED(SafeArrayGetLBound (var.parray, 1, &lBound)) &&
				 SUCCEEDED(SafeArrayGetUBound (var.parray, 1, &uBound)) &&
				 (0 == (uBound - lBound + 1))
				)
				 )
					result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool RemoveElementFromArray
//
//  DESCRIPTION:
//
//  Given a SAFEARRAY and an index, remove the element at that index
//	and shift left all following elements by one.
//
//  PARAMETERS:
//
//		array		the SAFEARRAY in qeustion
//		vt			Variant type of elements in array
//		iIndex		index of element to remove
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool RemoveElementFromArray (SAFEARRAY & array, VARTYPE vt, long iIndex)
{
	/*
	 * Note: caller must ensure that the array is within bounds and that the
	 * 
	 */

	bool result = false;
	long lBound, uBound;
	
	if ((1== SafeArrayGetDim (&array)) &&
		SUCCEEDED(SafeArrayGetLBound (&array, 1, &lBound)) &&
		SUCCEEDED(SafeArrayGetUBound (&array, 1, &uBound)) &&
		(0 < (uBound - lBound + 1)) && 
		(iIndex <= uBound))
	{
		bool ok = true;

		for (long i = iIndex+1; ok && (i <= uBound); i++)
			ok = ShiftLeftElement (array, vt, i);
			
		// Finally Redim to get rid of the last element
		if (ok)
		{
			SAFEARRAYBOUND	rgsabound;
			rgsabound.lLbound = lBound;
			rgsabound.cElements = uBound - lBound;
			result = SUCCEEDED(SafeArrayRedim (&array, &rgsabound));
		}
		else
			result = false;
	}

	return result;
}

//***************************************************************************
//
//  bool ShiftLeftElement
//
//  DESCRIPTION:
//
//  Given a SAFEARRAY and an index, remove the element at that index
//	and shift left all following elements by one.
//
//  PARAMETERS:
//
//		array		the SAFEARRAY in question
//		vt			Variant type of elements in array
//		iIndex		index of element to remove
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool ShiftLeftElement (SAFEARRAY & array, VARTYPE vt, long iIndex)
{
	bool result = false;
	long iNewIndex = iIndex - 1;

	switch (vt)
	{
		case VT_BSTR:
		{
			BSTR bstrVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bstrVal)))
			{
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, bstrVal));
				SysFreeString (bstrVal);
			}
		}
			break;

		case VT_UI1:
		{
			unsigned char bVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &bVal));
		}
			break;

		case VT_I2:
		{
			short iVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &iVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &iVal));
		}
			break;

		case VT_I4:
		{
			long lVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &lVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &lVal));
		}
			break;

		case VT_R4:
		{
			float fltVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &fltVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &fltVal));
		}
			break;

		case VT_R8:
		{
			double dblVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &dblVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &dblVal));
		}
			break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &boolVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &boolVal));
		}
			break;
	}

	return result;
}

bool ShiftElementsToRight (SAFEARRAY & array, VARTYPE vt, long iStartIndex,	
							long iEndIndex, long iCount)
{
	bool result = true;

	for (long iIndex = iEndIndex; result && (iIndex >= iStartIndex); iIndex--)
	{
		long iNewIndex = iIndex + iCount;

		switch (vt)
		{
			case VT_BSTR:
			{
				BSTR bstrVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bstrVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, bstrVal));
					SysFreeString (bstrVal);
				}
			}
				break;

			case VT_UI1:
			{
				unsigned char bVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &bVal));
			}
				break;

			case VT_I2:
			{
				short iVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &iVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &iVal));
			}
				break;

			case VT_I4:
			{
				long lVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &lVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &lVal));
			}
				break;

			case VT_R4:
			{
				float fltVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &fltVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &fltVal));
			}
				break;

			case VT_R8:
			{
				double dblVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &dblVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &dblVal));
			}
				break;

			case VT_BOOL:
			{
				VARIANT_BOOL boolVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &boolVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &boolVal));
			}
				break;

			case VT_DISPATCH:
			{
				IDispatch *pdispVal = NULL;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &pdispVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, pdispVal));

					if (pdispVal)
						pdispVal->Release ();
				}
			}
				break;

			case VT_UNKNOWN:
			{
				IUnknown *punkVal = NULL;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &punkVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, punkVal));

					if (punkVal)
						punkVal->Release ();
				}
			}
				break;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool MatchBSTR
//
//  DESCRIPTION:
//
//  Given a VARIANT and a BSTR, find out whether the BSTR matches the
//  VARIANT value (either the complete value or a member thereof).
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchBSTR (VARIANT & var, BSTR & bstrVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_BSTR;
	srcVar.bstrVal = SysAllocString (bstrVal);
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	VariantClear (&srcVar);
	return result;
}

//***************************************************************************
//
//  bool MatchUI1
//
//  DESCRIPTION:
//
//  Given a VARIANT and a UI1, find out whether the UI1 matches the
//  VARIANT value (either the complete value or a member thereof).
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchUI1 (VARIANT & var, unsigned char bVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_UI1;
	srcVar.bVal = bVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchBool (VARIANT & var, VARIANT_BOOL boolVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_BOOL;
	srcVar.boolVal = boolVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchI2 (VARIANT & var, short iVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_I2;
	srcVar.iVal = iVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchI4 (VARIANT & var, long lVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_I4;
	srcVar.lVal = lVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchR4 (VARIANT & var, float fltVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_R4;
	srcVar.fltVal = fltVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchR8 (VARIANT & var, double dblVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_R8;
	srcVar.dblVal = dblVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

//***************************************************************************
//
//  bool MatchValue
//
//  DESCRIPTION:
//
//  Given a VARIANT (which may or may not be an array) and a second VARIANT
//	(which is not an array) determine whether the second value matches the
//	first or an element of the first. 
//
//	ASSUMPTIONS
//	
//		1. The two VARIANTS have the same underlying type
//		2. The second VARIANT cannot be an array
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchValue (VARIANT &var1, VARIANT &var2)
{
	bool result = false;
	bool bIsArray = (var1.vt & VT_ARRAY) ? true : false;

	if (bIsArray)
	{
		long lBound, uBound;

		if (var1.parray && (1== SafeArrayGetDim (var1.parray)) &&
			SUCCEEDED(SafeArrayGetLBound (var1.parray, 1, &lBound)) &&
			SUCCEEDED(SafeArrayGetUBound (var1.parray, 1, &uBound)) &&
			(0 < (uBound - lBound + 1)))
		{
			// Break out on first match
			for (long i = lBound; !result && (i <= uBound); i++)
			{
				switch (var1.vt & ~VT_ARRAY)
				{
					case VT_BSTR:
					{
						BSTR bstrVal = NULL;

						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &bstrVal)))
						{
							result = (0 == wcscmp (bstrVal, var2.bstrVal));
							SysFreeString (bstrVal);
						}
					}
						break;

					case VT_UI1:
					{
						unsigned char bVal;

						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &bVal)))
							result = (bVal == var2.bVal);
					}
						break;

					case VT_I2:
					{
						short iVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &iVal)))
							result = (iVal == var2.iVal);
					}
						break;

					case VT_I4:
					{
						long lVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &lVal)))
							result = (lVal == var2.lVal);
					}
						break;

					case VT_R4:
					{
						float fltVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &fltVal)))
							result = (fltVal == var2.fltVal);
					}
						break;

					case VT_R8:
					{
						double dblVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &dblVal)))
							result = (dblVal == var2.dblVal);
					}
						break;

					case VT_BOOL:
					{
						VARIANT_BOOL boolVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &boolVal)))
							result = (boolVal == var2.boolVal);
					}
						break;
				}
			}
		}		
	}
	else
	{
		switch (var1.vt)
		{
			case VT_BSTR:
				result = (0 == wcscmp (var1.bstrVal, var2.bstrVal));
				break;

			case VT_UI1:
				result = (var1.bVal == var2.bVal);
				break;

			case VT_I2:
				result = (var1.iVal == var2.iVal);
				break;

			case VT_I4:
				result = (var1.lVal == var2.lVal);
				break;

			case VT_R4:
				result = (var1.fltVal == var2.fltVal);
				break;

			case VT_R8:
				result = (var1.dblVal == var2.dblVal);
				break;

			case VT_BOOL:
				result = (var1.boolVal == var2.boolVal);
				break;
		}
	
	}

	return result;
}


//***************************************************************************
//
//  HRESULT WmiVariantChangeType
//
//  DESCRIPTION:
//
//  Given a VARIANT value and a desired CIM type, cast the value to a VARIANT
//	which will be accepted when supplied to CIMOM for a property of that type. 
//
//  PARAMETERS:
//
//		vOut		the cast value
//		pvIn		the value to be cast
//		lCimType	the required CIM type
//
//	RETURNS:
//		S_OK if succeeded, WBEM_E_TYPE_MISMATCH if not
//
//***************************************************************************

HRESULT WmiVariantChangeType (
		VARIANT & vOut,
		VARIANT *pvIn,
		CIMTYPE	lCimType
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	VariantInit (&vOut);
	
	// First we check for a NULL value, as these are easy
	if ((NULL == pvIn) || VT_EMPTY == V_VT(pvIn) || VT_NULL == V_VT(pvIn) ||
			((VT_ERROR == V_VT(pvIn)) && (DISP_E_PARAMNOTFOUND == pvIn->scode)))
	{
		vOut.vt = VT_NULL;
		hr = S_OK;
	}
	else
	{
		// The kind of variant we will need to construct
		VARTYPE vtOut = CimTypeToVtType (lCimType);
		
		// The VARTYPE we've been given
		VARTYPE vtIn = V_VT(pvIn);


		if (vtOut == vtIn)
		{
			// Life is easy
			hr = VariantCopy (&vOut, pvIn);
		}
		else
		{
			// Types do not match - we have some work to to
			if (CIM_FLAG_ARRAY & lCimType)
			{
				/*
				 * Check for a regular SAFEARRAY type value first; if that fails
				 * then look for an IDispatch-style array value.
				 */
				if (((VT_ARRAY | VT_VARIANT) == vtIn) ||
					((VT_ARRAY | VT_VARIANT | VT_BYREF) == vtIn))
				{
					SAFEARRAY *parray = (VT_BYREF & vtIn) ? *(pvIn->pparray) : pvIn->parray;

					hr = WmiConvertSafeArray (vOut, parray, lCimType & ~VT_ARRAY);
				}
				else if ((VT_DISPATCH == vtIn) || ((VT_DISPATCH|VT_BYREF) == vtIn))
				{
					CComPtr<IDispatch> pIDispatch = 
							(VT_BYREF & vtIn) ? *(pvIn->ppdispVal) : pvIn->pdispVal;
    
					hr = WmiConvertDispatchArray (vOut, pIDispatch, lCimType & ~VT_ARRAY);
				}
			}
			else
			{
				switch (lCimType)
				{
					case wbemCimtypeSint8:
						{
							/*
							 * These are represented by
							 * a VT_I2, but we need to be careful about sign
							 * extension from shorter types taking us "out of range".
							 */
							if (SUCCEEDED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								// Did we get sign extended?
								if ((VT_UI1 == vtIn) || (VT_BOOL == vtIn))
									vOut.lVal &= 0x000000FF;
							}
							else 
							{
								// If we can't change the type, try the one we're given
								hr = VariantCopy (&vOut, pvIn);
							}
						}
						break;

					case wbemCimtypeSint64:
					case wbemCimtypeUint64:
						{
							/*
							 * These types are realized as VT_BSTR in CIM terms, which means
							 * that VariantChangeType will almost always succeed but not
							 * leave us with a valid numeric value. To be consistent with other
							 * numeric types we should round up floating/double
							 * values to the next largest integer (as is done by VariantChangeType
							 * for VT_R8 to numeric conversion).
							 */

							if (VT_R8 == V_VT(pvIn))
							{
								if (SUCCEEDED(hr = VariantCopy (&vOut, pvIn)))
								{
									// Round it up
									vOut.dblVal = ceil (vOut.dblVal);
									
									// Convert to string
									int dec = 0;
									int sign = 0;
									char *pDbl = _fcvt (vOut.dblVal, 0, &dec, &sign);
									
									if (pDbl) 
									{
										size_t len = strlen (pDbl);

										/*
										 * Having rounded up to an integer, we really expect 
										 * there to be no fractional component to the number
										 * returned by _fcvt.
										 */
										if (dec == len)
										{
											/*
											 * Now convert to a wide string - remember the
											 * sign bit!
											 */
											if (0 != sign)
												len += 1;

											wchar_t *pValue = new wchar_t [len + 1];

											if (pValue)
											{
												if (0 != sign)
												{
													pValue [0] = L'-';
													mbstowcs (pValue+1, pDbl, len);
												}
												else
													mbstowcs (pValue, pDbl, len);

												pValue [len] = NULL;

												// Now set it in the variant
												vOut.bstrVal = SysAllocString (pValue);
												vOut.vt = VT_BSTR;

												delete [] pValue;
												hr = S_OK;
											}
										}
									}
								}
							}
							else
								hr = VariantChangeType (&vOut, pvIn, 0, vtOut);
							
							if (FAILED(hr))
							{
								// If we can't change the type, try the one we're given
								hr = VariantCopy (&vOut, pvIn);
							}
						}
						break;

					case wbemCimtypeUint8:
					case wbemCimtypeSint16:
					case wbemCimtypeSint32:
					case wbemCimtypeReal32:
					case wbemCimtypeReal64:
					case wbemCimtypeString:
					case wbemCimtypeDatetime:
					case wbemCimtypeBoolean:
					case wbemCimtypeReference:
						{
							/*
							 * These types have a "prefect" fit to their
							 * corresponding Variant type.
							 */
							if (FAILED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
									hr = VariantCopy (&vOut, pvIn);
						}
						break;
					
					
					case wbemCimtypeUint32:
						{
							if (FAILED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								/*
								 * Watch for the case where we have been given a VT_R8
								 * in lieu of a "large" unsigned 32-bit integer value.
								 */
								if (VT_R8 == V_VT(pvIn))
								{
									// Is this "really" an integer?
									if (floor (pvIn->dblVal) == ceil(pvIn->dblVal))
									{
										// Fool it by casting to a UI4 - all we need is the bit pattern
										if (SUCCEEDED(hr = VarUI4FromR8 (pvIn->dblVal, (ULONG*)&vOut.lVal)))
											vOut.vt = VT_I4;
									}
								}
							}

							// If no joy thus far, just copy and have done with it
							if (FAILED(hr))
								hr = VariantCopy (&vOut, pvIn);
						}
						break;
					
					case wbemCimtypeChar16:
					case wbemCimtypeUint16:
						{
							/*
							 * These types are represented by
							 * a VT_I4, but we need to be careful about sign
							 * extension taking us "out of range".
							 */
							if (SUCCEEDED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								// Did we get sign extended from a shorter type?
								if ((VT_I2 == vtIn) || (VT_UI1 == vtIn) || (VT_BOOL == vtIn))
									vOut.lVal &= 0x0000FFFF;
							}
							else
								hr = VariantCopy (&vOut, pvIn);
						}
						break;
						
					case wbemCimtypeObject:
						{
							/* 
							 * We're looking for an embedded object
							 */
							if (SUCCEEDED(hr = VariantCopy (&vOut, pvIn)))
								hr = MapToCIMOMObject (&vOut);
						}
						break;
				}
			}
		}
	}

	return hr;
}


//***************************************************************************
//
//  HRESULT WmiConvertSafeArray
//
//  Description: 
//
//  This function is applied to VARIANT arrays in order to check for certain
//  restrictions imposed by CIMOM (e.g. they must be homogeneous) or perform
//  conversions (certain VARIANT types have to be mapped to acceptable CIMOM
//	types).
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT WmiConvertSafeArray(VARIANT &vOut, SAFEARRAY *parray, CIMTYPE lCimType)
{
	HRESULT hr = WBEM_E_FAILED;
	VARTYPE vtPut;		// The underlying type of the target array
	long lLower, lUpper;
  
	if (parray)
	{
		if (GetSafeArrayDimensions (*parray, lLower, lUpper))
		{
			int iNumElements = lUpper - lLower +1; 

			/* 
			 * For empty arrays, it suffices to create a empty array of
			 * VT_VARIANT's. Otherwise we need to build what WMI is expecting.
			 */
			vtPut = (iNumElements == 0) ? VT_VARIANT : CimTypeToVtType (lCimType);	
			
			// Now create a destination array of the required size
			SAFEARRAYBOUND rgsabound[1]; 
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = iNumElements;
			SAFEARRAY * pDestArray = SafeArrayCreate(vtPut, 1, rgsabound);

			if (pDestArray)
			{
				bool ok = true;

				for(long i = lLower; (i <= lUpper) && ok; i++) 
				{
					VARIANT var;
					VariantInit(&var);
                   
					if (SUCCEEDED(SafeArrayGetElement (parray, &i, &var)))
					{
						// do the conversion to the acceptable type and put that
						VARIANT vWMI;
						VariantInit(&vWMI);

						if (SUCCEEDED(hr = WmiVariantChangeType (vWMI, &var, lCimType)))
						{
							if(V_VT(&vWMI) == VT_BSTR || V_VT(&vWMI) == VT_UNKNOWN || V_VT(&vWMI) == VT_DISPATCH)
								ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)vWMI.bstrVal));
							else
								ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)&vWMI.lVal));
						}
						
						VariantClear (&vWMI);
					}
					else
						ok = false;

					VariantClear(&var);
				}

				if (!ok)
				{
					SafeArrayDestroy (pDestArray);
				}
				else
				{
					vOut.vt = (VT_ARRAY | vtPut);
					vOut.parray = pDestArray;
					hr = S_OK;
				}
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

    return hr;
}

//***************************************************************************
//
//  HRESULT WmiConvertDispatchArray
//
//  DESCRIPTION:
//
//  Attempt to convert from an IDispatch value to a CIM array value (property
//	qualifier or context).
//
//  PARAMETERS:
//
//		pDest		Output value
//		pSrc		Input value
//		lCimType	CIM Property type (underlying the array) - defaults to
//					CIM_ILLEGAL for Qualifier & Context value mappings.
//		bIsQual		true iff we are mapping for a qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT WmiConvertDispatchArray (
	VARIANT &vOut,
	CComPtr<IDispatch> & pIDispatch,
	CIMTYPE lCimType
)
{
	HRESULT hr = WBEM_E_FAILED; // Default error

	if (pIDispatch)
	{
		/*
		 * Looking for an IDispatchEx to iterate through the properties
		 * of the array.
		 */
		CComQIPtr<IDispatchEx> pIDispatchEx (pIDispatch);

		if (pIDispatchEx)
		{
			/*
			 * Looks promising, but just check if this isn't one of our objects
			 */
			CComQIPtr<ISWbemObject> pISWbemObject (pIDispatch);

			if (!pISWbemObject)
			{
				/*
				 * Start by determining how many properties there are so we can create
				 * a suitable array.
				 */
				long iNumElements = 0;
				DISPID dispId = DISPID_STARTENUM;
				
				while (S_OK == pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId))
					iNumElements++;
				
				/* 
				 * For empty arrays, it suffices to create a empty array of
				 * VT_VARIANT's. Otherwise we need to build what WMI is expecting.
				 */
				VARTYPE vtPut = (iNumElements == 0) ? VT_VARIANT : CimTypeToVtType (lCimType);	

				// Create the safearray - note that it may be empty
				SAFEARRAYBOUND rgsaBound;
				rgsaBound.cElements = iNumElements;
				rgsaBound.lLbound = 0;

				SAFEARRAY *pDestArray = SafeArrayCreate (vtPut, 1, &rgsaBound);
					
				if (pDestArray)
				{
					bool ok = true;

					if (0 < iNumElements)
					{
						// Enumerate the DISPIDs on this interface
						dispId = DISPID_STARTENUM;
						DISPPARAMS dispParams;
						dispParams.rgvarg = NULL;
						dispParams.rgdispidNamedArgs = NULL;
						dispParams.cArgs = 0;
						dispParams.cNamedArgs = 0;

						long nextExpectedIndex = 0;
						HRESULT enumHr;
						wchar_t *stopString = NULL;

						/*
						 * For JScript arrays, the property names are the specified indices of the 
						 * the array; these can be integer indices or they can be strings.  We make
						 * the following requirements of the array indices:
						 *
						 * (1) All of the indices are non-negative integers
						 * (2) The indices start at 0 and are contiguous.
						 */

						while (ok && SUCCEEDED(enumHr = pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId)))
						{
							if (S_FALSE == enumHr)
							{
								// We have reached the end
								break;
							}

							CComBSTR memberName;

							if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
							{
								// Check that property name is numeric
								long i = wcstol (memberName, &stopString, 10);

								if ((0 != wcslen (stopString)))
								{
									// Failure - cannot convert to integer
									ok = false;
								}
								else if (i != nextExpectedIndex)
								{
									// Failure - non-contiguous array
									ok = false;
								}
								else
								{
									nextExpectedIndex++;

									// Extract the property
									VARIANT var;
									VariantInit (&var);
										
									if (SUCCEEDED (pIDispatchEx->InvokeEx (dispId, 0, 
												DISPATCH_PROPERTYGET, &dispParams, &var, NULL, NULL)))
									{
										// do the conversion to the acceptable type and put that
										VARIANT vWMI;
										VariantInit(&vWMI);

										if (SUCCEEDED(hr = WmiVariantChangeType (vWMI, &var, lCimType)))
										{
											if(V_VT(&vWMI) == VT_BSTR || V_VT(&vWMI) == VT_UNKNOWN || V_VT(&vWMI) == VT_DISPATCH)
												ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)vWMI.bstrVal));
											else
												ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)&vWMI.lVal));
										}
										
										VariantClear (&vWMI);
									}
									else
										ok = false;
								}
							}
							else
							{
								// Failure - couldn't invoke method
								ok = false;
							} 
						} 
					}	

					if (ok)
					{
						// Now construct the new property value using our array
						vOut.vt = VT_ARRAY | vtPut;
						vOut.parray = pDestArray;
						hr = S_OK;
					}
					else
						SafeArrayDestroy (pDestArray);
				}
				else
					hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}

	return hr;
}

bool GetSafeArrayDimensions (SAFEARRAY &sArray, long &lLower, long &lUpper)
{
	bool result = false;

	// Must be 1-dimensional
	if (1 == SafeArrayGetDim(&sArray))
	{
		if (SUCCEEDED(SafeArrayGetLBound(&sArray,1,&lLower)) &&
			SUCCEEDED(SafeArrayGetUBound(&sArray,1,&lUpper)))
			result = true;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\classfac.h ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  classfac.h
//
//  alanbos  23-Mar-99   Created.
//
//  Class factory for WMI Scripting Host
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiScriptingHostFactory
//
//  DESCRIPTION:
//
//  Class factory for the CWmiScriptingHost classes.
//
//***************************************************************************

class CWmiScriptingHostFactory : public IClassFactory
{
protected:
	long			m_cRef;

public:

    CWmiScriptingHostFactory(void);
    ~CWmiScriptingHostFactory(void);
    
	//IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\precomp.h ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  precomp.h
//
//  alanbos  04-Mar-98   Created.
//
//  Master include file.
//
//***************************************************************************

#pragma warning(disable:4786)
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <objbase.h>
#include <objsafe.h>
#include <ocidl.h>
#include <memory.h>
#include <activscp.h>
#include "classfac.h"
#include "wmihost.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\util.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  util.h
//
//  alanbos  13-Feb-98   Created.
//
//  Useful things
//
//***************************************************************************

#ifndef _UTIL_H_
#define _UTIL_H_

HRESULT WmiVariantChangeType (VARIANT &vOut, VARIANT *pvIn, CIMTYPE lCimType);
HRESULT WmiConvertSafeArray (VARIANT &vOut, SAFEARRAY *pArray, CIMTYPE lCimType);
HRESULT WmiConvertDispatchArray (VARIANT &vOut, CComPtr<IDispatch> & pIDispatch, CIMTYPE lCimType);
bool	GetSafeArrayDimensions (SAFEARRAY &sArray, long &lLower, long &lUpper);

HRESULT	ConvertDispatchToArray (VARIANT *pDest, VARIANT *pSrc, CIMTYPE lCimType = CIM_ILLEGAL,
					BOOL bIsQualifier = false, VARTYPE requiredQualifierType = VT_NULL);

HRESULT MapToCIMOMObject (VARIANT *pVal);

HRESULT MapFromCIMOMObject (CSWbemServices *pService, VARIANT *pVal,
									ISWbemInternalObject *pObject = NULL,
									BSTR propertyName = NULL,
									long index = -1);

HRESULT ConvertArray(VARIANT * pDest, VARIANT * pSrc, BOOL bQualTypesOnly = false,
					 VARTYPE requiredVarType = VT_NULL);

HRESULT ConvertArrayRev(VARIANT * pDest, VARIANT * pSrc);

HRESULT ConvertBSTRArray(SAFEARRAY **ppDest, SAFEARRAY *pSrc);

HRESULT QualifierVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, VARTYPE vtNew);

VARTYPE GetAcceptableQualType(VARTYPE vt);

HRESULT BuildStringArray (SAFEARRAY *pArray, VARIANT & var);
HRESULT	SetFromStringArray (SAFEARRAY **ppArray, VARIANT *pVar);

BSTR FormatAssociatorsQuery (BSTR strObjectPath, BSTR strAssocClass,
	BSTR strResultClass, BSTR strResultRole, BSTR strRole, VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly, BSTR strRequiredAssocQualifier, BSTR strRequiredQualifier);

BSTR FormatReferencesQuery (BSTR strObjectPath,	BSTR strResultClass, BSTR strRole,
	VARIANT_BOOL bClassesOnly, VARIANT_BOOL bSchemaOnly, BSTR strRequiredQualifier);

BSTR FormatMultiQuery (SAFEARRAY &pClassList, long iNumElements);

void	CheckArrayBounds (SAFEARRAY *psa, long index);
void	SetSite (VARIANT *pVal, ISWbemInternalObject *pSObject, BSTR propertyName, long index = -1);
void	SetWbemError (CSWbemServices *pService);
void	ResetLastErrors ();
void	SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR m_objectName);
BSTR	MapHresultToWmiDescription (HRESULT hr);
void	MapNulls (DISPPARAMS FAR* pdispparams);

void EnsureGlobalsInitialized ();

// CIM <-> VARIANT type coercion functions
VARTYPE CimTypeToVtType(CIMTYPE lType);
WbemCimtypeEnum GetCIMType (VARIANT &var, CIMTYPE iCIMType, 
								bool bIsArray = false, long lLBound = 0, long lUBound = 0);
bool CanCoerceString (const BSTR & bsValue, WbemCimtypeEnum cimType);
WbemCimtypeEnum MapVariantTypeToCimType (VARIANT *pVal, CIMTYPE cimType = CIM_ILLEGAL);

bool ReadUI64(LPCWSTR wsz, unsigned __int64& rui64);
bool ReadI64(LPCWSTR wsz, __int64& rui64);

bool IsNullOrEmptyVariant (VARIANT & var);
bool RemoveElementFromArray (SAFEARRAY & array, VARTYPE vt, long iIndex);
bool ShiftLeftElement (SAFEARRAY & array, VARTYPE vt, long iIndex);
bool ShiftElementsToRight (SAFEARRAY & array, VARTYPE vt, long iStartIndex, 
						   long iEndIndex, long iShift);																	

bool MatchBSTR (VARIANT & var, BSTR & bstrVal);
bool MatchUI1 (VARIANT & var, unsigned char bVal);
bool MatchI2 (VARIANT & var, short iVal);
bool MatchI4 (VARIANT & var, long lVal);
bool MatchR4 (VARIANT & var, float fltVal);
bool MatchR8 (VARIANT & var, double dblVal);
bool MatchBool (VARIANT & var, VARIANT_BOOL boolVal);
bool MatchValue (VARIANT &var1, VARIANT &var2);

#define WBEMS_PDN_SCHEME		L"WINMGMTS:"
#define WBEMS_LEFT_PAREN		L"("
#define WBEMS_RIGHT_PAREN		L")"
#define	WBEMS_LEFT_CURLY		L"{"
#define	WBEMS_RIGHT_CURLY		L"}"
#define WBEMS_LEFT_SQBRK		L"["
#define WBEMS_RIGHT_SQBRK		L"]"
#define WBEMS_LEFT_ANGLE		L"<"
#define WBEMS_RIGHT_ANGLE		L">"
#define	WBEMS_EQUALS			L"="
#define	WBEMS_COMMA				L","
#define	WBEMS_EXCLAMATION		L"!"
#define	WBEMS_AUTH_LEVEL		L"authenticationLevel"
#define WBEMS_AUTH_DEFAULT		L"default"
#define WBEMS_AUTH_NONE			L"none"
#define WBEMS_AUTH_CONNECT		L"connect"
#define WBEMS_AUTH_CALL			L"call"
#define WBEMS_AUTH_PKT			L"pkt"
#define WBEMS_AUTH_PKT_INT		L"pktIntegrity"
#define WBEMS_AUTH_PKT_PRIV		L"pktPrivacy"
#define	WBEMS_IMPERSON_LEVEL	L"impersonationLevel"
#define WBEMS_IMPERSON_ANON		L"anonymous"
#define WBEMS_IMPERSON_IDENTIFY L"identify"
#define WBEMS_IMPERSON_IMPERSON	L"impersonate"
#define WBEMS_IMPERSON_DELEGATE	L"delegate"
#define WBEMS_LOCALE			L"locale"
#define WBEMS_AUTHORITY			L"authority"
#define WBEMS_RK_SCRIPTING		_T("Software\\Microsoft\\Wbem\\Scripting")
#define WBEMS_RV_DEFNS			_T("Default Namespace")
#define WBEMS_RV_ENABLEFORASP	_T("Enable for ASP")
#define WBEMS_RV_DEFAULTIMPLEVEL _T("Default Impersonation Level")
#define WBEMS_DEFNS				_T("root\\cimv2")


// Strings for queries
#define WBEMS_QUERY_ASSOCOF		OLESTR("associators of ")
#define WBEMS_QUERY_OPENBRACE	OLESTR("{")
#define WBEMS_QUERY_CLOSEBRACE	OLESTR("}")
#define WBEMS_QUERY_WHERE		OLESTR(" where ")
#define WBEMS_QUERY_ASSOCCLASS	OLESTR(" AssocClass ")
#define WBEMS_QUERY_EQUALS		OLESTR("=")
#define WBEMS_QUERY_CLASSDEFS	OLESTR(" ClassDefsOnly ")
#define WBEMS_QUERY_REQASSOCQ	OLESTR(" RequiredAssocQualifier ")
#define WBEMS_QUERY_REQQUAL		OLESTR(" RequiredQualifier ")
#define WBEMS_QUERY_RESCLASS	OLESTR(" ResultClass ")
#define WBEMS_QUERY_RESROLE		OLESTR(" ResultRole ")
#define WBEMS_QUERY_ROLE		OLESTR(" Role ")
#define WBEMS_QUERY_SCHEMAONLY	OLESTR(" SchemaOnly ")
#define WBEMS_QUERY_REFOF		OLESTR("references of ")
#define	WBEMS_QUERY_SELECT		OLESTR("select * from ")
#define WBEMS_QUERY_GO			OLESTR(" go ")

// System properties
#define WBEMS_SP_CLASS				OLESTR("__CLASS")
#define WBEMS_SP_PATH				OLESTR("__PATH")
#define WBEMS_SP_RELPATH			OLESTR("__RELPATH")
#define WBEMS_SP_SERVER				OLESTR("__SERVER")
#define WBEMS_SP_NAMESPACE			OLESTR("__NAMESPACE")
#define WBEMS_SP_GENUS				OLESTR("__GENUS")
#define WBEMS_SP_DERIVATION			OLESTR("__DERIVATION")

// Context variables
#define	WBEMS_CV_GET_EXTENSIONS			OLESTR("__GET_EXTENSIONS")
#define WBEMS_CV_GET_EXT_CLIENT_REQUEST	OLESTR("__GET_EXT_CLIENT_REQUEST")
#define WBEMS_CV_GET_EXT_PROPERTIES		OLESTR("__GET_EXT_PROPERTIES")
#define WBEMS_CV_CLONE_SOURCE_PATH		OLESTR("__CloneSourcePath")
#define WBEMS_CV_OWNER					OLESTR("INCLUDE_OWNER")
#define WBEMS_CV_GROUP					OLESTR("INCLUDE_GROUP")
#define WBEMS_CV_DACL					OLESTR("INCLUDE_DACL")
#define WBEMS_CV_SACL					OLESTR("INCLUDE_SACL")


#define ENGLISH_LOCALE 1033

// Useful cleanup macros
#define RELEASEANDNULL(x) \
if (x) \
{ \
	x->Release (); \
	x = NULL; \
}

#define FREEANDNULL(x) \
if (x) \
{ \
	SysFreeString (x); \
	x = NULL; \
}

#define DELETEANDNULL(x) \
if (x) \
{ \
	delete x; \
	x = NULL; \
}

#ifdef _RDEBUG
extern void _RRPrint(int line, const char *file, const char *func, 
								const char *str, long code, const char *str2); 
#define _RD(a) a
#define _RPrint(a,b,c,d) _RRPrint(__LINE__,__FILE__,a,b,c,d)
#else
#define _RD(a)
#define _RPrint(a,b,c,d)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\wmihost.h ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  wmihost.h
//
//  alanbos  23-Mar-99   Created.
//
//  Defines the WMI Active Scripting Host class.
//
//***************************************************************************

#ifndef _WMIHOST_H_
#define _WMIHOST_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiScriptingHost
//
//  DESCRIPTION:
//
//  The WMI implementation of an Active Scripting Host
//
//***************************************************************************

class CWmiScriptingHost : public IActiveScriptSite
{
protected:
    long m_lRef;
    IDispatch* m_pObject;

public:
    CWmiScriptingHost (); 
    ~CWmiScriptingHost ();

	// IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
	// IActiveScriptSite methods
    virtual HRESULT STDMETHODCALLTYPE GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid);

    virtual HRESULT STDMETHODCALLTYPE GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);

    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);

    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);

    virtual HRESULT STDMETHODCALLTYPE OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState);

    virtual HRESULT STDMETHODCALLTYPE OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);

    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);

    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\maindll.cpp ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  23-Mar-99   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include "initguid.h"

// Standard registry key/value names
#define WBEMS_RK_SCC		"SOFTWARE\\CLASSES\\CLSID\\"
#define WBEMS_RK_SC			"SOFTWARE\\CLASSES\\"
#define WBEMS_RK_THRDMODEL	"ThreadingModel"
#define WBEMS_RV_APARTMENT	"Apartment"
#define	WBEMS_RK_INPROC32	"InProcServer32"
#define WBEMS_RK_CLSID		"CLSID"

#define GUIDSIZE	128

// Count number of objects and number of locks.
long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule = NULL;

// CLSID for our implementation of IActiveScriptingSite
// {838E2F5E-E20E-11d2-B355-00105A1F473A}
DEFINE_GUID(CLSID_WmiActiveScriptingSite, 
0x838e2f5e, 0xe20e, 0x11d2, 0xb3, 0x55, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

// forward defines
STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc);
void UnregisterCoClass (REFGUID clsid);

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
		{
		}
			return TRUE;

		case DLL_THREAD_DETACH:
		{
		}
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			if(ghModule == NULL)
				ghModule = hInstance;
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
        }
			return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
	CWmiScriptingHostFactory *pObj = NULL;

	if (CLSID_WmiActiveScriptingSite == rclsid)
        pObj=new CWmiScriptingHostFactory();

    if(NULL == pObj)
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	return (0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//	STDAPI RegisterCoClass	
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry setup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc)
{
	OLECHAR		wcID[GUIDSIZE];
	char		nwcID[GUIDSIZE];
    char		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

	char *szCLSID = new char [strlen (WBEMS_RK_SCC) + GUIDSIZE + 1];

    // Create the path.
    if(0 ==StringFromGUID2(clsid, wcID, GUIDSIZE))
		return ERROR;

	wcstombs(nwcID, wcID, GUIDSIZE);
    lstrcpy (szCLSID, WBEMS_RK_SCC);
	lstrcat (szCLSID, nwcID);
	
	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
	{
		delete [] szCLSID;
		return ERROR;
	}

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (strlen(desc)+1));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
										(strlen(szModule)+1));
			RegSetValueEx(hKey2, WBEMS_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WBEMS_RV_APARTMENT, 
                                        (strlen(WBEMS_RV_APARTMENT)+1));
			RegCloseKey(hKey2);
		}

		RegCloseKey(hKey1);
	}
	else
	{
		delete [] szCLSID;
		return ERROR;
	}

	delete [] szCLSID;

	return NOERROR;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	return RegisterCoClass(CLSID_WmiActiveScriptingSite, "WMI Active Scripting Host");
}

//***************************************************************************
//
//	STDAPI UnregisterCoClass	
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry cleanup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

void UnregisterCoClass (REFGUID clsid)
{
	OLECHAR		wcID[GUIDSIZE];
    char		nwcID[GUIDSIZE];
    HKEY		hKey = NULL;

	char		*szCLSID = new char [strlen (WBEMS_RK_SCC) + GUIDSIZE + 1];

    // Create the path using the CLSID

    if(0 != StringFromGUID2(clsid, wcID, GUIDSIZE))
	{
		wcstombs(nwcID, wcID, GUIDSIZE);
	    lstrcpy (szCLSID, WBEMS_RK_SCC);
		lstrcat (szCLSID, nwcID);
	
		// First delete the subkeys of the HKLM\Software\Classes\CLSID\{GUID} entry
		if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_INPROC32);
			RegCloseKey(hKey);
		}

		// Delete the HKLM\Software\Classes\CLSID\{GUID} key
		if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCC, &hKey))
		{
			RegDeleteKey(hKey, nwcID);
			RegCloseKey(hKey);
		}
	}

	delete [] szCLSID;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnregisterCoClass(CLSID_WmiActiveScriptingSite);
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\classfac.cpp ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  23-Feb-99   Created.
//
//  Contains the class factory.
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CWmiScriptingHostFactory::CWmiScriptingHostFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiScriptingHostFactory::CWmiScriptingHostFactory(void)
{
    m_cRef=0L;
	return;
}

//***************************************************************************
//
// CWmiScriptingHostFactory::~CWmiScriptingHostFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiScriptingHostFactory::~CWmiScriptingHostFactory(void)
{
	return;
}

//***************************************************************************
//
// CWmiScriptingHostFactory::QueryInterface
// CWmiScriptingHostFactory::AddRef
// CWmiScriptingHostFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CWmiScriptingHostFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiScriptingHostFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiScriptingHostFactory::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHostFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a WMI Scripting Host.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWmiScriptingHostFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj = NULL;
    HRESULT      hr = E_FAIL;

	*ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pObj = new CWmiScriptingHost;
	
	if (NULL == pObj)
        return E_OUTOFMEMORY;

    if (FAILED (hr = pObj->QueryInterface(riid, ppvObj)))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHostFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CWmiScriptingHostFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\wmihost.cpp ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  23-Mar-99   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include <wbemdisp.h>

#define WMITHIS	L"instance"

//***************************************************************************
//
// CWmiScriptingHost::CWmiScriptingHost
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiScriptingHost::CWmiScriptingHost()
{
    m_lRef = 0;
	m_pObject = NULL;

#ifdef TEST
	// Grab an object to play with

	HRESULT hr = CoGetObject (L"winmgmts:{impersonationLevel=impersonate}!Win32_LogicalDisk=\"C:\"",
				NULL,IID_ISWbemObject, (void**)&m_pObject);
#endif
}

//***************************************************************************
//
// CWmiScriptingHost::~CWmiScriptingHost
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiScriptingHost::~CWmiScriptingHost()
{
	if (m_pObject)
	{
		m_pObject->Release();
		m_pObject = NULL;
	}
}

//***************************************************************************
//
// CWmiScriptingHost::QueryInterface
// CWmiScriptingHost::AddRef
// CWmiScriptingHost::Release
//
// Purpose: IUnknown method implementations
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IActiveScriptSite)
        *ppv = (IActiveScriptSite*)this;
    else if(riid == IID_IActiveScriptSiteWindow)
        *ppv = (IActiveScriptSiteWindow*)this;
    else
        return E_NOINTERFACE;
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CWmiScriptingHost::AddRef() 
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CWmiScriptingHost::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}
        
//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetLCID
//
//  Description: 
//
//		Retrieves the locale identifier associated with the host's user 
//		interface. The scripting engine uses the identifier to ensure 
//		that error strings and other user-interface elements generated 
//		by the engine appear in the appropriate language. .
//
//  Parameters:
//
//  plcid       
//			Address of a variable that receives the locale identifier 
//			for user-interface elements displayed by the scripting engine
//
// Return Value:
//  HRESULT         E_NOTIMPL - the system-defined locale should be used
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid)
{ 
    return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetItemInfo
//
//  Description: 
//
//		Allows the scripting engine to obtain information about an item 
//		added with the IActiveScript::AddNamedItem method. 
//
//  Parameters:
//
//  pstrName 
//			The name associated with the item, as specified in the 
//			IActiveScript::AddNamedItem method. 
//
//	dwReturnMask 
//			A bit mask specifying what information about the item 
//			should be returned. The scripting engine should request the 
//			minimum amount of information possible because some of 
//			the return parameters (for example,ITypeInfo) can take 
//			considerable time to load or generate. Can be a combination 
//			of the following values: 
//				SCRIPTINFO_IUNKNOWN  Return theIUnknown interface for this item.  
//				SCRIPTINFO_ITYPEINFO  Return theITypeInfo interface for this item.  
//
//	ppunkItem 
//			Address of a variable that receives a pointer to the IUnknown 
//			interface associated with the given item. The scripting engine 
//			can use the IUnknown::QueryInterface method to obtain the IDispatch 
//			interface for the item. This parameter receives NULL if dwReturnMask 
//			does not include the SCRIPTINFO_IUNKNOWN value. Also, it receives NULL 
//			if there is no object associated with the item name; this mechanism is 
//			used to create a simple class when the named item was added with the 
//			SCRIPTITEM_CODEONLY flag set in the IActiveScript::AddNamedItem method. 
//
//	ppTypeInfo 
//			Address of a variable that receives a pointer to theITypeInfo interface 
//			associated with the item. This parameter receives NULL if dwReturnMask 
//			does not include the SCRIPTINFO_ITYPEINFO value, or if type information 
//			is not available for this item. If type information is not available, 
//			the object cannot source events, and name binding must be realized with 
//			the IDispatch::GetIDsOfNames method. Note that the ITypeInfo interface 
//			retrieved describes the item's coclass (TKIND_COCLASS) because the object 
//			may support multiple interfaces and event interfaces. If the item supports 
//			the IProvideMultipleTypeInfo interface, the ITypeInfo interface retrieved 
//			is the same as the index zero ITypeInfo that would be obtained using the 
//			IProvideMultipleTypeInfo::GetInfoOfIndex method. 
//
// Return Value:
//		S_OK					Success.  
//		E_INVALIDARG			An argument was invalid.  
//		E_POINTER				An invalid pointer was specified.  
//		TYPE_E_ELEMENTNOTFOUND  An item of the specified name was not found.  
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTypeInfo)
{ 
	if (NULL == m_pObject)
		return TYPE_E_ELEMENTNOTFOUND;

    if(_wcsicmp(pstrName, WMITHIS))
        return TYPE_E_ELEMENTNOTFOUND;

    if(ppTypeInfo)
        *ppTypeInfo = NULL;
	
    if(ppunkItem)
        *ppunkItem = NULL;
	else
		return E_POINTER;

    if(dwReturnMask & SCRIPTINFO_IUNKNOWN)
        m_pObject->QueryInterface(IID_IUnknown, (void**)ppunkItem);
    
	// TODO - host should support SCRIPTINFO_ITYPEINFO
	// but we'll need scriptable objects to support IProvideClassInfo
	// or just hard code the typelib here

    return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetDocVersionString
//
//  Description: 
//
//		Retrieves a host-defined string that uniquely identifies the 
//		current document version. If the related document has changed 
//		outside the scope of ActiveX Scripting (as in the case of an 
//		HTML page being edited with NotePad), the scripting engine can 
//		save this along with its persisted state, forcing a recompile 
//		the next time the script is loaded. 
//
//  Parameters:
//
//  pstrVersionString 
//			Address of the host-defined document version string.  
//
// Return Value:
//		S_OK		Success
//		E_NOTIMPL	The scripting engine should assume that 
//					the script is in sync with the document
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion)
{ 
	return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnScriptTerminate
//
//  Description: 
//
//		Informs the host that the script has completed execution. The 
//		scripting engine calls this method before the call to the 
//		IActiveScriptSite::OnStateChange method, with the 
//		SCRIPTSTATE_INITIALIZED flag set, is completed. This method can 
//		be used to return completion status and results to the host. Note 
//		that many script languages, which are based on sinking events from 
//		the host, have life spans that are defined by the host. 
//		In this case, this method may never be called. 
//
//  Parameters:
//
//  pvarResult 
//			Address of a variable that contains the script result, 
//			or NULL if the script produced no result. 
//
//	pexcepinfo 
//			Address of an EXCEPINFO structure that contains exception 
//			information generated when the script terminated, or NULL 
//			if no exception was generated. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnStateChange
//
//  Description: 
//
//		Informs the host that the scripting engine has changed states. 
//
//  Parameters:
//
//  ssScriptState 
//		Value that indicates the new script state. See the 
//		IActiveScript::GetScriptState method for a description of the states. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnScriptError
//
//  Description: 
//
//		Informs the host that an execution error occurred while the engine 
//		was running the script. 
//
//  Parameters:
//
//  pase 
//		Address of the error object's IActiveScriptError interface. 
//		A host can use this interface to obtain information about the 
//		execution error.  
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pase)
{ 
    HRESULT hres;
    EXCEPINFO ei;
    hres = pase->GetExceptionInfo(&ei);
    if(SUCCEEDED(hres))
    {

        printf("\nGot Error from source %S", ei.bstrSource);
        printf("\nDescription is %S", ei.bstrDescription);
        printf("\nThe error code is 0x%x", ei.scode);
        DWORD dwLine, dwCookie;
        long lChar;
        pase->GetSourcePosition(&dwCookie, &dwLine, &lChar);
        printf("\nError occured on line %d, character %d", dwLine, lChar);
    }
    return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnEnterScript
//
//  Description: 
//
//		Informs the host that the scripting engine has begun executing the 
//		script code. The scripting engine must call this method on every 
//		entry or reentry into the scripting engine. For example, if the 
//		script calls an object that then fires an event handled by the 
//		scripting engine, the scripting engine must call 
//		IActiveScriptSite::OnEnterScript before executing the event, and 
//		must call the IActiveScriptSite::OnLeaveScript method after executing 
//		the event but before returning to the object that fired the event. 
//		Calls to this method can be nested. Every call to this method 
//		requires a corresponding call to IActiveScriptSite::OnLeaveScript. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnEnterScript( void)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnLeaveScript
//
//  Description: 
//
//		Informs the host that the scripting engine has returned from 
//		executing script code. The scripting engine must call this method 
//		before returning control to a calling application that entered the 
//		scripting engine. For example, if the script calls an object that 
//		then fires an event handled by the scripting engine, the scripting 
//		engine must call the IActiveScriptSite::OnEnterScript method before 
//		executing the event, and must call IActiveScriptSite::OnLeaveScript 
//		after executing the event before returning to the object that fired 
//		the event. Calls to this method can be nested. Every call to 
//		IActiveScriptSite::OnEnterScript requires a corresponding call to 
//		this method. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnLeaveScript( void)
{ 
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	hosttest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_)
#define AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\userprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WBEM method provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CMethodPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\userprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Method provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "methprov.h"

HMODULE ghModule;

DEFINE_GUID(CLSID_useridprovider,0x44BB1D18, 0x0FD7, 0x11d3, 0xB3, 0x66, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			return TRUE;

		case DLL_THREAD_DETACH:
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			if(ghModule == NULL)
				ghModule = hInstance;
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
        }
			return TRUE;
    }

    return TRUE;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_useridprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WBEM Method Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_useridprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_useridprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\userprov\methprov.cpp ===
//***************************************************************************
//
//  METHPROV.CPP
//
//  Module: WBEM Method provider sample code
//
//  Purpose: Defines the CMethodPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>
#include "cominit.h"

//***************************************************************************
//
// CMethodPro::CMethodPro
// CMethodPro::~CMethodPro
//
//***************************************************************************

CMethodPro::CMethodPro()
{
    InterlockedIncrement(&g_cObj);
    return;
   
}

CMethodPro::~CMethodPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CMethodPro::QueryInterface
// CMethodPro::AddRef
// CMethodPro::Release
//
// Purpose: IUnknown members for CMethodPro object.
//***************************************************************************


STDMETHODIMP CMethodPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethodPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CMethodPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CMethodPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}



/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is GetUserID.  It    * 
*         returns the user name and domain name of the thread in which  * 
*         the provider is called.  The mof definition is                *
*                                                                       *
*    [dynamic: ToInstance, provider("UserIDProvider")]class UserID      *
*    {                                                                  *
*         [implemented, static]                                         *
*            void GetUserID(											*
*				[out]string sDomain,									*
*               [out] string sUser,										*
*				[out] string dImpLevel,									*
*				[out] string sPrivileges [],							*
*				[out] boolean bPrivilegesEnabled []);                   *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CMethodPro::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr = WBEM_E_FAILED;  
	
	if (FAILED (WbemCoImpersonateClient ()))
		return WBEM_E_ACCESS_DENIED;

	IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
    if(_wcsicmp(MethodName, L"GetUserID"))
        return WBEM_E_INVALID_PARAMETER;

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"UserID");    
    BSTR DomainOutputArgName = SysAllocString(L"sDomain");
    BSTR UserOutputArgName = SysAllocString(L"sUser");
	BSTR ImpOutputArgName = SysAllocString(L"sImpLevel");
    BSTR PrivOutputArgName = SysAllocString(L"sPrivileges");
    BSTR EnabledOutputArgName = SysAllocString(L"bPrivilegesEnabled");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pWbemSvcs->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		 pResultSink->SetStatus(0,hr, NULL, NULL);
		 return WBEM_S_NO_ERROR;
	}
 
    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

	// Get the user and domain from the thread token

	HANDLE hToken;
	HANDLE hThread = GetCurrentThread ();

	// Open thread token
	if (OpenThreadToken (hThread, TOKEN_QUERY, true, &hToken))
	{
		DWORD dwRequiredSize = 0;
		DWORD dwLastError = 0;
		bool status = false;

		// Step 0 - get impersonation level
		SECURITY_IMPERSONATION_LEVEL secImpLevel;
		if (GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
												sizeof (SECURITY_IMPERSONATION_LEVEL), &dwRequiredSize))
		{
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_BSTR;

			switch (secImpLevel)
			{
				case SecurityAnonymous:
					var.bstrVal = SysAllocString (L"Anonymous");
					break;
				
				case SecurityIdentification:
					var.bstrVal = SysAllocString (L"Identification");
					break;
				
				case SecurityImpersonation:
					var.bstrVal = SysAllocString (L"Impersonation");
					break;

				case SecurityDelegation:
					var.bstrVal = SysAllocString (L"Delegation");
					break;

				default:
					var.bstrVal = SysAllocString (L"Unknown");
					break;
			}

			pOutParams->Put(ImpOutputArgName , 0, &var, 0);      
			VariantClear (&var);
		}

		DWORD dwUSize = sizeof (TOKEN_USER);
		TOKEN_USER *tu = (TOKEN_USER *) new BYTE [dwUSize];

		// Step 1 - get user info
		if (0 ==  GetTokenInformation (hToken, TokenUser, 
							(LPVOID) tu, dwUSize, &dwRequiredSize))
		{
			delete [] tu;
			dwUSize = dwRequiredSize;
			dwRequiredSize = 0;
			tu = (TOKEN_USER *) new BYTE [dwUSize];

			if (!GetTokenInformation (hToken, TokenUser, (LPVOID) tu, dwUSize, 
								&dwRequiredSize))
				dwLastError = GetLastError ();
			else
				status = true;
		}

		if (status)
		{
			// Dig out the user info
			dwRequiredSize = BUFSIZ;
			char *userName = new char [dwRequiredSize];
			char *domainName = new char [dwRequiredSize];
			SID_NAME_USE eUse;

			LookupAccountSid (NULL, (tu->User).Sid, userName, &dwRequiredSize,
									domainName, &dwRequiredSize, &eUse);

			VARIANT var;
			VariantInit (&var);
			var.vt = VT_BSTR;

			wchar_t wUserName [BUFSIZ];
			size_t len = mbstowcs( wUserName, userName, strlen (userName));
			wUserName [len] = NULL;
			
			var.bstrVal = SysAllocString (wUserName);
		    pOutParams->Put(UserOutputArgName , 0, &var, 0);      
			
			SysFreeString (var.bstrVal);

			wchar_t wDomainName [BUFSIZ];
			len = mbstowcs( wDomainName, domainName, strlen (domainName));
			wDomainName [len] = NULL;
			var.bstrVal = SysAllocString (wDomainName);
		  	pOutParams->Put(DomainOutputArgName , 0, &var, 0);      

			VariantClear (&var);

			delete [] userName;
			delete [] domainName;
		}
		
		delete [] tu;

		// Step 2 - get privilege info
		status = false;
		dwRequiredSize = 0;

		DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
		TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
		
		// Step 2 - get privilege info
		if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
		{
			delete [] tp;
			dwSize = dwRequiredSize;
			dwRequiredSize = 0;

			tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
			if (!GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
			{
				dwLastError = GetLastError ();
			}
			else
				status = true;
		}
		else
			status = true;

		if (status)
		{
			SAFEARRAYBOUND rgsabound;
			rgsabound.cElements = tp->PrivilegeCount;
			rgsabound.lLbound = 0;

			SAFEARRAY *pPrivArray = SafeArrayCreate (VT_BSTR, 1, &rgsabound);
			SAFEARRAY *pEnabArray = SafeArrayCreate (VT_BOOL, 1, &rgsabound);

			for (ULONG i = 0; i < tp->PrivilegeCount; i++)
			{
				TCHAR name [BUFSIZ];
				WCHAR wName [BUFSIZ];
				DWORD dwRequiredSize = BUFSIZ;

				if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
				{
					VARIANT_BOOL enabled = (tp->Privileges [i].Attributes & 
									(SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT)) ?
								VARIANT_TRUE : VARIANT_FALSE;

					mbstowcs (wName, name, strlen (name));
					wName [dwRequiredSize] = NULL;
					BSTR bsName = SysAllocString (wName);
					
					SafeArrayPutElement (pPrivArray, (LONG*) &i, bsName);
					SafeArrayPutElement (pEnabArray, (LONG*) &i, &enabled);
				}
			}

			VARIANT var1;
			var1.vt = VT_ARRAY|VT_BSTR;
			var1.parray = pPrivArray;
			pOutParams->Put(PrivOutputArgName , 0, &var1, 0);

			VariantClear (&var1);

			var1.vt = VT_ARRAY|VT_BOOL;
			var1.parray = pEnabArray;
			pOutParams->Put(EnabledOutputArgName , 0, &var1, 0);

			VariantClear (&var1);
		}
	
		delete [] tp;

		CloseHandle (hToken);
	}

	CloseHandle (hThread);

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(DomainOutputArgName);
    SysFreeString(UserOutputArgName);
	SysFreeString(ImpOutputArgName);
	SysFreeString(PrivOutputArgName);
    SysFreeString(EnabledOutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\userprov\methprov.h ===
//***************************************************************************
//
//  methprov.h
//
//  Module: WBEM Method Test Provider code
//
//  Purpose: Method Provider Test Header File.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _methprov_H_
#define _methprov_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMethodPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        IWbemClassObject* m_pOutClass;
     public:
        CMethodPro();
        ~CMethodPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};


        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CMethodPro *PCMethodPro;

// This class is the class factory for CMethodPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\hosttest.cpp ===
// hosttest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "objbase.h"
#include "initguid.h"
#include <stdio.h>
#include <activscp.h>


// CLSID for our implementation of IActiveScriptingSite
// {838E2F5E-E20E-11d2-B355-00105A1F473A}
DEFINE_GUID(CLSID_WmiActiveScriptingSite, 
0x838e2f5e, 0xe20e, 0x11d2, 0xb3, 0x55, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

WCHAR * ReadScript(char * pFileName);

int main(int argc, char* argv[])
{
	if (2 != argc)
	{
		printf ("Usage: hosttest <scriptfile>\n");
		return 1;
	}

	LPWSTR pScriptText = ReadScript (argv[1]);
		
    HRESULT sc = CoInitialize(0);

	// Get the active script site
	IActiveScriptSite	*pSite = NULL;

	HRESULT hr = CoCreateInstance (CLSID_WmiActiveScriptingSite,NULL,
						CLSCTX_INPROC_SERVER,IID_IActiveScriptSite, (void**) &pSite);

	// Get the scripting engine
	CLSID clsid;
	hr = CLSIDFromProgID (L"JScript", &clsid);
	
	IActiveScript* pScriptEngine = NULL;
    hr =CoCreateInstance (clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**) &pScriptEngine);
    

    IActiveScriptParse* pParse;
    sc = pScriptEngine->QueryInterface(IID_IActiveScriptParse, (void**)&pParse);
    if(FAILED(sc))
        return 1;

    sc = pParse->InitNew();

    // Bind the host to the engine
    sc = pScriptEngine->SetScriptSite(pSite);
    pSite->Release();
    
	// Register the "this" pointer
    sc = pScriptEngine->AddNamedItem(L"instance", 
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE | SCRIPTITEM_GLOBALMEMBERS);
    if(FAILED(sc))
        return 1;

    EXCEPINFO ei;
    sc = pParse->ParseScriptText(
        pScriptText,
        NULL, NULL, NULL, 
        0, 0, 0, NULL, &ei);
    if(FAILED(sc))
        return 1;

    pParse->Release();

    sc = pScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if(FAILED(sc))
        return 1;

    pScriptEngine->Release();

    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}

WCHAR * ReadScript(char * pFileName)
{
    FILE *fp;
    BOOL bUnicode = FALSE;
    BOOL bBigEndian = FALSE;

    // Make sure the file exists and can be opened

    fp = fopen(pFileName, "rb");
    if (!fp)
    {
        printf("\nCant open file %s", pFileName);
        return NULL;
    }

    // Determine the size of the file
    // ==============================
    
    fseek(fp, 0, SEEK_END);
    long lSize = ftell(fp); // add a bit extra for ending space and null NULL
    fseek(fp, 0, SEEK_SET);

    // Check for UNICODE source file.
    // ==============================

    BYTE UnicodeSignature[2];
    if (fread(UnicodeSignature, sizeof(BYTE), 2, fp) != 2)
    {
        printf("\nNothing in file %s", pFileName);
        fclose(fp);
        return NULL;
    }

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        LPWSTR pRet = new WCHAR[lSize/2 +2];
        if(pRet == NULL)
            return NULL;
        fread(pRet, 1, lSize-2, fp);
        fclose(fp);
        return pRet;
    }

    else
    {
        fseek(fp, 0, SEEK_SET);
        LPSTR pTemp = new char[lSize+1];
		memset (pTemp,0,(lSize+1) * sizeof(char));
        LPWSTR pRet = new WCHAR[lSize+1];
		memset (pRet, 0, (lSize + 1) * sizeof (WCHAR));
        if(pRet == NULL || pTemp == NULL)
            return NULL;
        fread(pTemp, 1, lSize, fp);
        fclose(fp);
        mbstowcs(pRet, pTemp, lSize);
        delete pTemp;
        return pRet;

    }

    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\polyview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _PolyView_h
#define _PolyView_h


enum {VIEW_DEFAULT=0, VIEW_CURRENT=1, VIEW_FIRST=2, VIEW_LAST=3};
enum {OBJECT_CURRENT=0, OBJECT_FIRST=1, OBJECT_LAST=2};


class CMultiView;
class CSingleView;
class CWBEMViewContainerCtrl;

class CPolyView
{
public:
	CPolyView(CWBEMViewContainerCtrl* phmmv);
	~CPolyView();
	CWnd* SetFocus();
	BOOL Create(CRect& rcView);
	BOOL DidCreateWindow() {return m_bDidCreateWindow; }
	void SetPropertyFilters(long lPropFilters);


	BOOL RedrawWindow( LPCRECT lpRectUpdate = NULL, CRgn* prgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE ); 
	void MoveWindow( LPCRECT lpRect, BOOL bRepaint = TRUE );
	void UpdateWindow( );
	void SetFont(CFont& font);


	CSingleView* GetSingleView() {return m_psv; }
	CMultiView* GetMultiView() {return m_pmv; }



	BOOL IsShowingMultiview(); 
	BOOL IsShowingSingleview();
	void ShowMultiView();
	void ShowSingleView();
	void SetNamespace(LPCTSTR pszNamespace);


	SCODE RefreshView();
	SCODE GetSelectedObject(CString& sPath);
	SCODE SelectObjectByPath(LPCTSTR szObjectPath);
	SCODE SelectObjectByPath(BSTR bstrObjectPath);
	void SetEditMode(BOOL bInStudioMode);


	void NotifyWillShow();
	//void NotifyDidShow();
	//void NotifyWillHide();
	//void NotifyDidHide();
	SCODE CreateInstance();
 	SCODE DeleteInstance();
	void NotifyInstanceCreated(LPCTSTR szObjectPath);
	void NotifyInstanceDeleted(LPCTSTR szObjectPath);
	BOOL QueryCanCreateInstance();
	BOOL QueryCanDeleteInstance();
	BOOL QueryNeedsSave();
	//void NotifyDidCreate();
	//void NotifyWillDestroy();
	BOOL QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	SCODE GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	SCODE SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	SCODE SaveData();
	void SetStudioModeEnabled(BOOL bInStudioMode);


private:
	BOOL m_bShowSingleView;
	CMultiView* m_pmv;
	CSingleView* m_psv;
	CWBEMViewContainerCtrl* m_phmmv;

	BSTR bstrTitle;
	LPDISPATCH m_lpPictureDisp;
	BOOL m_bDidCreateWindow;

	BOOL m_bDelaySvContextRestore;
	long m_lContextHandleSvDelayed;
	friend class CViewStack;
	BOOL m_bInStudioMode;
};


#endif //_PolyView_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\download.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Download.cpp : implementation file
//

#include "stdafx.h"
#include "Download.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDownload

TCHAR szMessage[1024];

IMPLEMENT_DYNCREATE(CDownload, CCmdTarget)

CDownload::CDownload()
{
}

CDownload::CDownload(CWnd* pView)
{
	m_pView = pView;
}

CDownload::~CDownload()
{
}


BEGIN_MESSAGE_MAP(CDownload, CCmdTarget)
	//{{AFX_MSG_MAP(CDownload)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CDownload, CCmdTarget)
    INTERFACE_PART(CDownload, IID_IBindStatusCallback, BindStatusCallback)
	INTERFACE_PART(CDownload, IID_IWindowForBindingUI, WindowForBindingUI)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDownload message handlers

STDMETHODIMP_(ULONG) CDownload::XBindStatusCallback::AddRef()
{   
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
    return pThis->ExternalAddRef();
}   

STDMETHODIMP_(ULONG) CDownload::XBindStatusCallback::Release()
{   
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
    return pThis->ExternalRelease();
}   

STDMETHODIMP CDownload::XBindStatusCallback::QueryInterface(REFIID iid, void** ppvObj)
{   
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj) ;
}   

STDMETHODIMP CDownload::XBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return S_OK;
}

STDMETHODIMP CDownload::XBindStatusCallback::GetPriority(LONG* pnPriority) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return E_NOTIMPL;
}

STDMETHODIMP CDownload::XBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return E_NOTIMPL;
}
STDMETHODIMP CDownload::XBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)


	static TCHAR action[64];
//	static TCHAR szMessage[128];

	// cleanup the msg buffer.
	memset(action, 0, sizeof(action));

	// what happened.
	switch(ulStatusCode)
	{
    case BINDSTATUS_FINDINGRESOURCE:
		_tcscpy(action, _T("Finding"));
		break;
	case BINDSTATUS_CONNECTING:
		_tcscpy(action, _T("Connecting"));
		break;
	case BINDSTATUS_REDIRECTING:
		_tcscpy(action, _T("Redirecting"));
		break;
	case BINDSTATUS_BEGINDOWNLOADDATA:
		_tcscpy(action, _T("Begin data"));
		_stprintf(szMessage, _T("Looking for\r\n %s"), szStatusText);
		pThis->m_pView->SendMessage(WM_UPDATE_PROGRESS, 0, (long) (void*) szStatusText);
		break;
	case BINDSTATUS_DOWNLOADINGDATA:
		_tcscpy(action, _T("Downloading"));
		break;
	case BINDSTATUS_ENDDOWNLOADDATA:
		_tcscpy(action, _T("End data"));
		break;
	case BINDSTATUS_BEGINDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("Begin download"));
		break;
	case BINDSTATUS_INSTALLINGCOMPONENTS:

		// only this one moves the progress bar.
		_stprintf(szMessage, _T("Installing\r\n %s"), szStatusText);
		pThis->m_pView->SendMessage(WM_UPDATE_PROGRESS, 0, (long) (void*) szStatusText);

		// I'm see 2 calls per component.
		break;
	case BINDSTATUS_ENDDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("End download"));
		break;
	case BINDSTATUS_USINGCACHEDCOPY:
		_tcscpy(action, _T("using cached copy"));
		break;
	case BINDSTATUS_SENDINGREQUEST:
		_tcscpy(action, _T("Requesting"));
		break;
	case BINDSTATUS_CLASSIDAVAILABLE:
		_tcscpy(action, _T("CLSID available"));
		break;
	case BINDSTATUS_MIMETYPEAVAILABLE:
		_tcscpy(action, _T("mime available"));
		break;
	case BINDSTATUS_CACHEFILENAMEAVAILABLE:
		_tcscpy(action, _T("cache available"));
		break;
	default: 
		action[0] = 0;
		break;
	} //endswitch



	return NOERROR;
}


STDMETHODIMP CDownload::XBindStatusCallback::OnStopBinding(HRESULT hrResult, LPCWSTR szError) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	if (hrResult != 0) {
		pThis->m_pView->PostMessage(WM_ONSTOPBINDING, (WPARAM) FALSE, (LPARAM) NULL);
	}


	return S_OK;
}

STDMETHODIMP CDownload::XBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return S_OK;
}

STDMETHODIMP CDownload::XBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)
	return S_OK;
}

STDMETHODIMP CDownload::XBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk) 
{
    METHOD_PROLOGUE(CDownload, BindStatusCallback)

	if (riid != IID_IClassFactory || punk == NULL)
		return E_INVALIDARG;

	pThis->m_pView->PostMessage(WM_ONSTOPBINDING, (WPARAM) TRUE, (LPARAM) punk);

	return S_OK;
}

STDMETHODIMP_(ULONG) CDownload::XWindowForBindingUI::AddRef()
{   
    METHOD_PROLOGUE(CDownload, WindowForBindingUI)
    return pThis->ExternalAddRef();
}   

STDMETHODIMP_(ULONG) CDownload::XWindowForBindingUI::Release()
{   
    METHOD_PROLOGUE(CDownload, WindowForBindingUI)
    return pThis->ExternalRelease();
}   

STDMETHODIMP CDownload::XWindowForBindingUI::QueryInterface(REFIID iid, void** ppvObj)
{   
    METHOD_PROLOGUE(CDownload, WindowForBindingUI)
    return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj) ;
}   

STDMETHODIMP CDownload::XWindowForBindingUI::GetWindow(REFGUID rguidReason, HWND* phwnd)
{
    METHOD_PROLOGUE(CDownload, WindowForBindingUI)

	*phwnd = pThis->m_pView->m_hWnd;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wbemcab.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WBEMCAB_DIALOG              102
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 102
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  103
#define IDR_MAINFRAME                   128
#define IDC_ANIMATE                     1000
#define IDC_MESSAGE                     1001
#define IDR_AVIDOWNLOAD                 6000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\download.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Download.h : header file
//

#include "urlmon.h"
#define WM_ONSTOPBINDING WM_USER + 1001
#define WM_UPDATE_PROGRESS (WM_ONSTOPBINDING + 1)

/////////////////////////////////////////////////////////////////////////////
// CDownload command target

class CDownload : public CCmdTarget
{
	DECLARE_DYNCREATE(CDownload)

	CDownload();           // protected constructor used by dynamic creation
	CDownload(CWnd* pView);

// Attributes
public:
	CWnd* m_pView;

// Operations
public:
	virtual ~CDownload();  // had to make the destructor public

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDownload)
	//}}AFX_VIRTUAL

// Implementation
protected:
//	virtual ~CDownload();

	// Generated message map functions
	//{{AFX_MSG(CDownload)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

public:
	DECLARE_INTERFACE_MAP()

	// IBindStatusCallback
    BEGIN_INTERFACE_PART(BindStatusCallback, IBindStatusCallback)
        STDMETHOD(OnStartBinding)(DWORD grfBSCOption, IBinding* pbinding);
		STDMETHOD(GetPriority)(LONG* pnPriority);
		STDMETHOD(OnLowResource)(DWORD dwReserved);
		STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText);
		STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
		STDMETHOD(GetBindInfo)(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
		STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed);
		STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown* punk);
    END_INTERFACE_PART(BindStatusCallback)

	// IWindowForBindingUI
	BEGIN_INTERFACE_PART(WindowForBindingUI, IWindowForBindingUI)
		STDMETHOD(GetWindow)(REFGUID rguidReason, HWND* phwnd);
	END_INTERFACE_PART(WindowForBindingUI)
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\polyview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "stdafx.h"
#include <afxcmn.h>

#include "mvbase.h"
#include "mv.h"
#include "sv.h"
#include "PolyView.h"
#include "utils.h"
#include "hmmvctl.h"
#include "titlebar.h"
#include "resource.h"

enum {EDITMODE_BROWSER=0, EDITMODE_STUDIO=1, EDITMODE_READONLY=2};	// There needs to be a common define for this somewhere.




CPolyView::CPolyView(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
	m_pmv = NULL;
	m_psv = NULL;
	m_bDidCreateWindow = FALSE;
	m_bDelaySvContextRestore = FALSE;
	m_bInStudioMode = FALSE;
	m_bShowSingleView = TRUE;
}

CPolyView::~CPolyView()
{
//hmh	if (m_pmv!=NULL && m_pmv->m_hWnd!=NULL) {
//		m_pmv->NotifyWillDestroy();
//	}

	delete m_pmv;

//kmh	if (m_psv!=NULL && m_psv->m_hWnd!=NULL) {
//		m_psv->NotifyWillDestroy();
//	}
	delete m_psv;
}


BOOL CPolyView::Create(CRect& rcView)
{
	m_pmv = new CMultiView(m_phmmv);
	m_psv = new CSingleView(m_phmmv);

	BOOL bDidCreate;
	bDidCreate = m_psv->Create(_T("SingleView"), NULL, WS_CHILD | WS_CLIPCHILDREN, rcView, m_phmmv, GenerateWindowID(), NULL);
	if (bDidCreate) {
//kmh		m_psv->NotifyDidCreate();
		m_psv->SetEditMode(m_bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	else {
		ASSERT(FALSE);
		delete m_psv;
		m_psv = NULL;
		return FALSE;
	}


	bDidCreate = m_pmv->Create(_T("MultiView"), NULL, WS_CHILD | WS_CLIPCHILDREN, rcView, m_phmmv, GenerateWindowID(), NULL);
	if (bDidCreate) {
//kmh		m_pmv->NotifyDidCreate();
		m_pmv->SetEditMode(m_bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);

	}
	else {
		ASSERT(FALSE);
		delete m_pmv;
		m_pmv = NULL;
		return FALSE;
	}
	m_bDidCreateWindow = TRUE;

	return TRUE;
}

BOOL CPolyView::IsShowingMultiview() 
{
	BOOL bShowingMultiview = FALSE;
	BOOL bShowingSingleview = FALSE;
	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			bShowingMultiview = m_pmv->IsWindowVisible();
		}
	}

	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			bShowingSingleview = m_psv->IsWindowVisible();
		}
	}
	if (bShowingMultiview && bShowingSingleview) {
		// Control should never come here, but for some
		// unknown reason there are times when both views
		// want to become visible simultaneously (by magic).
		// Turn off the unwanted view.
		if (m_bShowSingleView) {
			m_pmv->ShowWindow(SW_HIDE);
			bShowingMultiview = FALSE;
		}
		else {
			m_psv->ShowWindow(SW_HIDE);
			bShowingSingleview = FALSE;
		}
	}


	return bShowingMultiview; 
}

BOOL CPolyView::IsShowingSingleview() 
{
	BOOL bShowingMultiview = FALSE;
	BOOL bShowingSingleview = FALSE;
	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			bShowingMultiview = m_pmv->IsWindowVisible();
		}
	}
	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			bShowingSingleview = m_psv->IsWindowVisible();
		}
	}

	if (bShowingMultiview && bShowingSingleview) {
		// Control should never come here, but for some
		// unknown reason there are times when both views
		// want to become visible simultaneously (by magic).
		// Turn off the unwanted view.
		if (m_bShowSingleView) {
			m_pmv->ShowWindow(SW_HIDE);
			bShowingMultiview = FALSE;
		}
		else {
			m_psv->ShowWindow(SW_HIDE);
			bShowingSingleview = FALSE;
		}
	}


	return bShowingSingleview; 
}

void CPolyView::SetEditMode(BOOL bCanEdit)
{

	if (m_psv) {
		m_psv->SetEditMode(bCanEdit ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
}


BOOL CPolyView::RedrawWindow( LPCRECT lpRectUpdate, CRgn* prgnUpdate, UINT flags)
{

	BOOL bDidRedraw = FALSE;
	CWnd* pwnd;
	if (IsShowingMultiview()) {
		pwnd = m_pmv;
	}
	else {
		pwnd = m_psv;
	}


	if (pwnd==NULL || pwnd->m_hWnd==NULL) {
		return FALSE;
	}

	if (!pwnd->IsWindowVisible()) {
		return FALSE;
	}

	bDidRedraw = pwnd->RedrawWindow(lpRectUpdate, prgnUpdate, flags);	
	return bDidRedraw;
}



void CPolyView::MoveWindow( LPCRECT lpRect, BOOL bRepaint)
{

	if (m_pmv!=NULL && m_pmv->m_hWnd!=NULL) {
		m_pmv->MoveWindow(lpRect, bRepaint);
	}
	
	if (m_psv!=NULL && m_psv->m_hWnd!=NULL) {
		m_psv->MoveWindow(lpRect, bRepaint);
	}
}

void CPolyView::UpdateWindow( )
{

	CWnd* pwnd;
	if (IsShowingMultiview()) {
		pwnd = m_pmv;
	}
	else {
		pwnd = m_psv;
	}

	if (pwnd==NULL || pwnd->m_hWnd==NULL) {
		return;
	}
	
	pwnd->UpdateWindow();
}


void CPolyView::SetFont(CFont& font)
{

	if (m_psv != NULL) {
		m_psv->SetFont(&font);
	}

	if (m_pmv != NULL) {
		m_pmv->SetFont(&font);
	}
}


SCODE CPolyView::RefreshView()
{

	if (m_psv==NULL || m_pmv==NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		sc = m_pmv->RefreshView();
	}
	else {
		sc = m_psv->RefreshView();
	}
	return sc;
}



SCODE CPolyView::GetSelectedObject(CString& sPath)
{

	if (m_psv==NULL || m_pmv==NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}


	long lPos;
	sPath.Empty();
	if (IsShowingMultiview()) {
		lPos = m_pmv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos != -1) {
			sPath = m_pmv->GetObjectPath(lPos);
		}

	}
	else {
		lPos = m_psv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos != -1) {
			sPath = m_psv->GetObjectPath(lPos);
		}
	}

	if (sPath.IsEmpty()) {
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}


SCODE CPolyView::SelectObjectByPath(BSTR bstrPath)
{

	CString sPath;
	sPath = bstrPath;
	SCODE sc = SelectObjectByPath(sPath);
	return sc;
}

SCODE CPolyView::SelectObjectByPath(LPCTSTR szObjectPath)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SelectObjectByPath(szObjectPath);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SelectObjectByPath(szObjectPath);
		}
	}
	return sc;
}




void CPolyView::ShowMultiView()
{

	m_bShowSingleView = FALSE;

	CTitleBar* pTitleBar = m_phmmv->m_pTitleBar;
	if ((pTitleBar != NULL) && m_phmmv->InStudioMode()) {
		pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, TRUE);
	}

	if (IsShowingMultiview()) {
		if (m_pmv->IsWindowVisible()) {
			if (m_psv != NULL) {
				// It should not be possible, but somehow the singleview becomes
				// visible when only the multiview should be visible, so hide
				// the singleview if this is the case.
				m_psv->ShowWindow(SW_HIDE);
				ASSERT(FALSE);
			}
			return;
		}
	}


	SCODE sc = S_OK;




	if (IsShowingSingleview()) {
		m_psv->ShowWindow(SW_HIDE);
		m_psv->UpdateWindow();
	}


	if (!IsShowingMultiview() && (m_pmv != NULL)) {
		m_pmv->NotifyWillShow();;
		m_pmv->ShowWindow(SW_SHOW);
	}
}

void CPolyView::SetNamespace(LPCTSTR pszNamespace)
{

	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			m_psv->SetNameSpace(pszNamespace);
		}
	}

	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			m_pmv->SetNameSpace(pszNamespace);
			m_pmv->ViewClassInstances(_T(""));
		}
	}

}

void CPolyView::ShowSingleView()
{
	m_bShowSingleView = TRUE;


	CTitleBar* pTitleBar = m_phmmv->m_pTitleBar;
	if ((pTitleBar != NULL) && m_phmmv->InStudioMode()) {
		pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, FALSE);
	}

	if (IsShowingSingleview()) {
		return;
	}

	SCODE sc = S_OK;
	if (m_bDelaySvContextRestore) {
		sc = m_psv->RestoreContext(m_lContextHandleSvDelayed);
		m_bDelaySvContextRestore = FALSE;
	}


	if (IsShowingMultiview()) {
		m_pmv->ShowWindow(SW_HIDE);
		m_pmv->UpdateWindow();
	}

	if (!IsShowingSingleview() && (m_psv != NULL)) {
		m_psv->ShowWindow(SW_SHOW);
		m_psv->UpdateWindow();
	}
}




SCODE CPolyView::CreateInstance()
{

	SCODE sc = E_FAIL;
	if (m_psv != NULL) {
		sc = m_psv->CreateInstanceOfCurrentClass();
	}
	return sc;
}

SCODE CPolyView::DeleteInstance()
{

	SCODE sc = E_FAIL;
	CString sPath;
	long lPos;
	if (IsShowingMultiview()) {
		
		if (m_pmv != NULL) {
			lPos = m_pmv->StartObjectEnumeration(OBJECT_CURRENT);
			if (lPos != -1) {
				sPath = m_pmv->GetObjectPath(lPos);
			}
			sc = m_pmv->DeleteInstance();
			if (SUCCEEDED(sc) && (lPos!=-1) && m_psv!=NULL) {
				m_psv->ExternInstanceDeleted(sPath);
			}
		}
	}
	else {
		if (m_psv != NULL) {
			lPos = m_psv->StartObjectEnumeration(OBJECT_CURRENT);
			if (lPos != -1) {
				sPath = m_psv->GetObjectPath(lPos);
			}
			sc = m_psv->DeleteInstance();
			if (SUCCEEDED(sc) && (lPos!=-1) && m_pmv!=NULL) {
				m_pmv->ExternInstanceDeleted(sPath);
			}
		}
	}
	return sc;
}



void CPolyView::NotifyInstanceCreated(LPCTSTR szObjectPath)
{

	if (IsShowingMultiview()) {
		if (m_psv != NULL) {
			m_psv->ExternInstanceCreated(szObjectPath);
		}
	}
	else {
		if (m_pmv != NULL) {
			m_pmv->ExternInstanceCreated(szObjectPath);
		}
	}
}

void CPolyView::NotifyInstanceDeleted(LPCTSTR szObjectPath)
{

	if (IsShowingMultiview()) {
		if (m_psv != NULL) {
			m_psv->ExternInstanceDeleted(szObjectPath);
		}
	}
	else {
		if (m_pmv != NULL) {
			m_pmv->ExternInstanceDeleted(szObjectPath);
		}
	}
}




BOOL CPolyView::QueryCanCreateInstance()
{

	BOOL bCanCreateInstance = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bCanCreateInstance = m_pmv->QueryCanCreateInstance();
		}
	}
	else {
		if (m_psv != NULL) {
			bCanCreateInstance = m_psv->QueryCanCreateInstance();
		}
	}
	return bCanCreateInstance;
}


BOOL CPolyView::QueryCanDeleteInstance()
{

	BOOL bCanDeleteInstance = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bCanDeleteInstance = m_pmv->QueryCanDeleteInstance();
		}
	}
	else {
		if (m_psv != NULL) {
			bCanDeleteInstance = m_psv->QueryCanDeleteInstance();
		}
	}
	return bCanDeleteInstance;
}



BOOL CPolyView::QueryNeedsSave()
{

	BOOL bNeedsSave = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bNeedsSave = m_pmv->QueryNeedsSave();
		}
	}
	else {
		if (m_psv != NULL) {
			bNeedsSave = m_psv->QueryNeedsSave();
		}
	}
	return bNeedsSave;
}



BOOL CPolyView::QueryObjectSelected()
{

	BOOL bObjectSelected = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bObjectSelected = m_pmv->QueryObjectSelected();
		}
	}
	else {
		if (m_psv != NULL) {
			bObjectSelected = m_psv->QueryObjectSelected();
		}
	}
	return bObjectSelected;
}



CString CPolyView::GetObjectPath(long lPosition)
{

	CString sPath;
	BOOL bObjectSelected = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sPath = m_pmv->GetObjectPath(lPosition);
			if (::IsEmptyString(sPath)) {
				// Normalize the path if it is only white space.
				sPath.Empty();
			}

		}
	}
	else {
		if (m_psv != NULL) {
			sPath = m_psv->GetObjectPath(lPosition);
		}
	}
	return sPath;
}



long CPolyView::StartViewEnumeration(long lWhere)
{

	long lPosition = -1;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->StartViewEnumeration(lWhere);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->StartViewEnumeration(lWhere);
		}
	}
	return lPosition;
}


SCODE CPolyView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->GetTitle(pszTitle, lpPictureDisp);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->GetTitle(pszTitle, lpPictureDisp);
		}
	}
	return sc;
}



CString CPolyView::GetViewTitle(long lPosition)
{

	CString sViewTitle;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sViewTitle = m_pmv->GetViewTitle(lPosition);
		}
	}
	else {
		if (m_psv != NULL) {
			sViewTitle = m_psv->GetViewTitle(lPosition);
		}
	}
	return sViewTitle;
}


long CPolyView::NextViewTitle(long lPosition, BSTR* pbstrTitle)
{

	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->NextViewTitle(lPosition, pbstrTitle);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->NextViewTitle(lPosition, pbstrTitle);
		}
	}
	return lPosition;
}



long CPolyView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{

	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->PrevViewTitle(lPosition, pbstrTitle);
		}
		else {
			lPosition = -1;
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->PrevViewTitle(lPosition, pbstrTitle);
		}
		else {
			lPosition = -1;
		}
	}
	return lPosition;
}



SCODE CPolyView::SelectView(long lPosition)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SelectView(lPosition);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SelectView(lPosition);
		}
	}
	return sc;

}



long CPolyView::StartObjectEnumeration(long lWhere)
{

	long lPosition = -1;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->StartObjectEnumeration(lWhere);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->StartObjectEnumeration(lWhere);
		}
	}
	return lPosition;
}



CString CPolyView::GetObjectTitle(long lPos)
{

	CString sObjectTitle;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sObjectTitle = m_pmv->GetObjectTitle(lPos);
		}
	}
	else {
		if (m_psv != NULL) {
			sObjectTitle = m_psv->GetObjectTitle(lPos);
		}
	}
	return sObjectTitle;

}


SCODE CPolyView::SaveData()
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SaveData();
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SaveData();
		}
	}
	return sc;
}

void CPolyView::SetPropertyFilters(long lPropFilters)
{

	if (m_pmv != NULL) {
		m_pmv->SetPropertyFilter(lPropFilters);
	}

	if (m_psv != NULL) {
		m_psv->SetPropertyFilter(lPropFilters);
	}
}


//************************************************************
// CPolyView::SetStudioModeEnabled
//
// Set the StudioMode enabled flag.  
//
// Parameters:
//		[in] BOOL bInStudioMode
//			TRUE if the view should be the StudioMode view. This
//			corresponds to the mode where the user is allowed to
//			create and delete properties, etc.
//
// Returns:
//		Nothing.
//			
//************************************************************
void CPolyView::SetStudioModeEnabled(BOOL bInStudioMode)
{

	if (m_psv != NULL) {
		m_psv->SetEditMode(bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	if (m_pmv != NULL) {
		m_pmv->SetEditMode(bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	m_bInStudioMode = bInStudioMode;
}



CWnd* CPolyView::SetFocus()
{
	CWnd* pwndPrev = NULL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			pwndPrev = m_pmv->SetFocus();
		}
	}
	else if (m_psv != NULL) {
		pwndPrev = m_psv->SetFocus();
	}
	return pwndPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	wbemcab.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\adddialog.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: adddialog.cpp
//
// Description:
//	This file implements the CAddDialog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX,
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a new class and its
//			parent class.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "resource.h"
#include "classnav.h"
#include "wbemidl.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "AddDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ***************************************************************************
//
// CAddDialog::CAddDialog
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  CClassNavCtrl* pParent
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CAddDialog::CAddDialog(CClassNavCtrl* pParent)
	: CDialog(CAddDialog::IDD, NULL)
{
	//{{AFX_DATA_INIT(CAddDialog)
	m_csNewClass = _T("");
	m_csParent = _T("");
	//}}AFX_DATA_INIT
	m_pParent = pParent;
}

// ***************************************************************************
//
// CAddDialog::DoDataExchange
//
// Description:
//	  Called by the framework to exchange and validate dialog data.
//
// Parameters:
//	  pDX			A pointer to a CDataExchange object.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CAddDialog::DoDataExchange(CDataExchange* pDX)
{

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddDialog)
	DDX_Text(pDX, IDC_EDIT1, m_csNewClass);
	DDX_Text(pDX, IDC_EDITPARENT, m_csParent);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		CButton *pcbOK = reinterpret_cast<CButton *>(GetDlgItem( IDOK ));
		m_csNewClass.TrimLeft();
		if (!m_csNewClass.IsEmpty())
		{
			if (pcbOK)
			{
				pcbOK->EnableWindow(TRUE);
			}

		}
		else
		{
			if (pcbOK)
			{
				pcbOK->EnableWindow(FALSE);
			}
		}

	}

}


BEGIN_MESSAGE_MAP(CAddDialog, CDialog)
	//{{AFX_MSG_MAP(CAddDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
// CAddDialog::Create
//
// Description:
//	  Create the window.
//
// Parameters:
//	  CClassNavCtrl *pParent
//
// Returns:
//	  BOOL				Non-zero if successful; 0 otherwise.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CAddDialog::Create(CClassNavCtrl *pParent)
{
	m_pParent = pParent;
	return CDialog::Create(IDD, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CAddDialog:: - I
// ***************************************************************************
//
// CAddDialog::OnInitDialog
//
// Description:
//	  Initialize controls after the window is created but before it is shown.
//
// Parameters:
//	  VOID
//
// Returns:
//	  BOOL				TRUE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CAddDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CButton *pcbOK = reinterpret_cast<CButton *>(GetDlgItem( IDOK ));

	if (pcbOK)
	{
		pcbOK->EnableWindow(FALSE);
	}

	CEdit *pEdit = (CEdit *)GetDlgItem(IDC_EDIT1);
	if(pEdit)
		pEdit->LimitText(500);
	pEdit = (CEdit *)GetDlgItem(IDC_EDITPARENT);
	if(pEdit)
		pEdit->LimitText(500);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CAddDialog::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	CWnd* pWndFocus = NULL;
	TCHAR szClass[40];
	szClass[0] = '\0';
	if (lpMsg->message == WM_KEYUP)
	{
		pWndFocus = GetFocus();
		if (((pWndFocus = GetFocus()) != NULL) &&
			IsChild(pWndFocus) &&
			GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
			(_tcsicmp(szClass, _T("EDIT")) == 0))
		{
			UpdateData(TRUE);
		}
   }

	return CDialog::PreTranslateMessage(lpMsg);
}

/*	EOF:  adddialog.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\wbemcab.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// wbemcab.h : main header file for the WBEMCAB application
//

#if !defined(AFX_WBEMCAB_H__4E89F67E_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
#define AFX_WBEMCAB_H__4E89F67E_E47D_11D2_B36E_00105AA680B8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWbemcabApp:
// See wbemcab.cpp for the implementation of this class
//

class CWbemcabApp : public CWinApp
{
public:
	CWbemcabApp();

// Overrides
	virtual int ExitInstance( );

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemcabApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWbemcabApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_bExtractFailed;

};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMCAB_H__4E89F67E_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4E89F682_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
#define AFX_STDAFX_H__4E89F682_E47D_11D2_B36E_00105AA680B8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4E89F682_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\adddialog.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: adddialog.h
//
// Description:
//	This file declares the CAddDialog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX, 
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a new class and its
//			parent class.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by:
//	CBanner 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CAddDialog
//
// Description:
//	  This class which is a subclass of the MFC CDialog class.  It allows the 
//	  user to type in a name for a new class.
//
// Public members:
//	
//	  CAddDialog	Public constructor.
//	  GetNewClass	Gets the new class' name.
//	  GetParent		Gets the new class' parent class name.
//
//============================================================================
//
// CAddDialog::CAddDialog
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CAddDialog::GetNewClass
//
// Description:
//	  Gets the value of the new class' name.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  CString				New class' name.
//
//============================================================================
//
// CAddDialog::GetParent
//
// Description:
//	  Gets the value of the new class' name parent class name.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  CString				New class' parent class name.
//
//****************************************************************************

#ifndef _CAddDialog_H_
#define _CAddDialog_H_

class CClassNavCtrl;

class CAddDialog : public CDialog
{
// Construction
public:
	CAddDialog(CClassNavCtrl* pParent = NULL);   // standard constructor
	CString GetNewClass() {return m_csNewClass;}
	CString GetParent() {return m_csParent;}
	void SetNewClass(CString & csNewClass) { m_csNewClass= csNewClass;}
	void SetParent(CString csParent) {m_csParent = csParent;}
protected:
	
	//{{AFX_DATA(CAddDialog)
	enum { IDD = IDD_DIALOGADDCLASS };
	CString	m_csNewClass;
	CString	m_csParent;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddDialog)
	public:
	virtual BOOL Create(CClassNavCtrl *pParent);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CClassNavCtrl *m_pParent;
	// Generated message map functions
	//{{AFX_MSG(CAddDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

/*	EOF:  adddialog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\wbemcabdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// wbemcabDlg.h : header file
//

#if !defined(AFX_WBEMCABDLG_H__4E89F680_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
#define AFX_WBEMCABDLG_H__4E89F680_E47D_11D2_B36E_00105AA680B8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#include "download.h"
#include <urlmon.h>


/////////////////////////////////////////////////////////////////////////////
// CWbemcabDlg dialog

class CDownload;

class CWbemcabDlg : public CDialog
{
// Construction
public:
	CWbemcabDlg(CWnd* pParent = NULL);	// standard constructor
	CLSID m_clsid;
	COleVariant m_varCodebase;
	DWORD m_dwVersionMajor;
	DWORD m_dwVersionMinor;


// Dialog Data
	//{{AFX_DATA(CWbemcabDlg)
	enum { IDD = IDD_WBEMCAB_DIALOG };
	CEdit	m_msg;
	CAnimateCtrl	m_progress;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemcabDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

	afx_msg LRESULT OnStopBind(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT CWbemcabDlg::OnUpdateProgress(WPARAM wParam, LPARAM lParam);

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWbemcabDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	LPBINDCTX m_pBindContext;
	LPBINDSTATUSCALLBACK m_pBindStatusCallback;
	CDownload *m_download;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMCABDLG_H__4E89F680_E47D_11D2_B36E_00105AA680B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\wbemcab.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// wbemcab.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wbemcab.h"
#include "wbemcabDlg.h"
#include "download.h"
#include <urlmon.h>

#include  <io.h>
#include  <stdio.h>
#include  <stdlib.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAXPATH 1024






/////////////////////////////////////////////////////////////////////////////
// The one and only CWbemcabApp object
class CParams : CCommandLineInfo
{
public:
	CParams();
	virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );
	BOOL Validate(const CParams& params,  CString& sCodebase, CLSID& clsid, DWORD& dwVersionMajor, DWORD& dwVersionMinor);
	BOOL m_bDisplayHelp;

private:
	SCODE DecimalToU16(DWORD& dwValue, LPCTSTR pszValue);
	SCODE GetVersion(DWORD& dwVersionMajor, DWORD& dwVersionMinor);
	CString m_sCodebase;
	CString m_sClsid;
	CString m_sVersion;
	int m_nParams;
};


CParams::CParams()
{
	m_nParams = 0;
	m_bDisplayHelp = FALSE;
}

void CParams::ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast)
{
	if (bFlag && (lpszParam[0] == _T('?'))) {
		if (lpszParam[1] == 0) {
			m_bDisplayHelp = TRUE;
		}
	}

	
	
	++m_nParams;


	switch (m_nParams) {
	case 1:
		m_sCodebase = lpszParam;
		break;
	case 2:
		m_sClsid = lpszParam;
		break;
	case 3:
		m_sVersion = lpszParam;
	default:
		break;
	}
}




SCODE CParams::DecimalToU16(DWORD& dwValue, LPCTSTR pszValue)
{
	if (!::isdigit(*pszValue)) {
		return E_FAIL;
	}

	int nDigits = 0;
	dwValue = 0;
	while (*pszValue && ::isdigit(*pszValue)) {
		UINT uiDigit = (*pszValue - _T('0'));
		dwValue = dwValue * 10 + uiDigit;
		++nDigits;
		++pszValue;
	}

	if (nDigits > 5) {		// Check for more digits than 65535
		return E_FAIL;
	}
	
	if (dwValue > 65535) {
		return E_FAIL;
	}

	return S_OK;
}

SCODE CParams::GetVersion(DWORD& dwVersionMajor, DWORD& dwVersionMinor)
{
	CString sVersion = m_sVersion;
	CString sMajorMS;
	CString sMajorLS;
	CString sMinorMS;
	CString sMinorLS;

	DWORD dwMajorMS = 0;
	DWORD dwMajorLS = 0;
	DWORD dwMinorMS = 0;
	DWORD dwMinorLS = 0;
	SCODE sc;
	int iDot;

	// Get the MS 16 bits of the major version number.
	iDot = sVersion.Find(_T('.'));
	if  ((iDot == -1) || (iDot == 0)) {
		goto SYNTAX_ERROR;
	}

	sMajorMS = sVersion.SpanExcluding(_T("."));
	sVersion = sVersion.Right(sVersion.GetLength() - (iDot + 1));

	// Get the LS 16 bits of the major version number.
	iDot = sVersion.Find(_T('.'));
	if  ((iDot == -1) || (iDot == 0)) {
		goto SYNTAX_ERROR;
	}

	sMajorLS = sVersion.SpanExcluding(_T("."));
	sVersion = sVersion.Right(sVersion.GetLength() - (iDot + 1));



	// Get the MS 16 bits of the minor version number.
	iDot = sVersion.Find(_T('.'));
	if  ((iDot == -1) || (iDot == 0)) {
		goto SYNTAX_ERROR;
	}

	sMinorMS = sVersion.SpanExcluding(_T("."));
	sVersion = sVersion.Right(sVersion.GetLength() - (iDot + 1));


	// Get the LS 16 bits of the minor version number.
	sMinorLS = sVersion;

	
	sc = DecimalToU16(dwMajorMS, sMajorMS);
	if (FAILED(sc)) {
		goto SYNTAX_ERROR;
	}

	sc = DecimalToU16(dwMajorLS, sMajorLS);
	if (FAILED(sc)) {
		goto SYNTAX_ERROR;
	}


	sc = DecimalToU16(dwMinorMS, sMinorMS);
	if (FAILED(sc)) {
		goto SYNTAX_ERROR;
	}


	sc = DecimalToU16(dwMinorLS, sMinorLS);
	if (FAILED(sc)) {
		goto SYNTAX_ERROR;
	}

	dwVersionMajor = (dwMajorMS << 16) | dwMajorLS;
	dwVersionMinor = (dwMinorMS << 16) | dwMinorLS;

	return S_OK;

SYNTAX_ERROR:
	return E_FAIL;
}






BOOL CParams::Validate(
		const CParams& params,  
		CString& sCodebase, 
		CLSID& clsid, 
		DWORD& dwVersionMajor, 
		DWORD& dwVersionMinor)
{
	TCHAR szMessage[512];

	// Check for the proper number of parameters and display a message box if the wrong number 
	// of parameters was supplied.  The user should never see these errors as setup should always
	// invoke wbemcab with the proper number of arguments.
	if (params.m_nParams < 3) {
		::MessageBox(NULL, _T("Missing parameter(s).\r\n\r\n Usage:\r\n    CabExtract <cab file> <clsid> <version>"), _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		return FALSE;
	}
	else if (params.m_nParams > 3) {
		::MessageBox(NULL, _T("Too many parameters.\r\n\r\n Usage:\r\n    CabExtract <cab file> <clsid> <version>"), _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		return FALSE;
	}

	// Check for read access to the codebase file.
	int iStatus = ::_taccess(params.m_sCodebase, 4);
	if (iStatus < 0) {
		_stprintf(szMessage, _T("Can't find \"%s\""), params.m_sCodebase);
		::MessageBox(NULL, szMessage, _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		return FALSE;
	}

	COleVariant varClsid;
	varClsid = params.m_sClsid;
	SCODE sc = CLSIDFromString(varClsid.bstrVal, &clsid);
	if (FAILED(sc)) {
		::MessageBox(NULL, _T("CabExtract: invalid clsid format."), _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		return FALSE;
	}


	// Convert the relative path to an absolute path so  that CoGetClassFromURL can find it.
	LPTSTR pszBuffer = sCodebase.GetBuffer(MAXPATH + 1);
	_tfullpath(pszBuffer, m_sCodebase, MAXPATH);
	sCodebase.ReleaseBuffer();
	

	sc = GetVersion(dwVersionMajor, dwVersionMinor);
	if (FAILED(sc)) {
		::MessageBox(NULL, _T("CabExtract: invalid version format.\r\n\r\nVersion syntax = MajorMS16.MajorLS16.MinorMS16.MinorLS16."), _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		return FALSE;
	}


	return TRUE;
}









/////////////////////////////////////////////////////////////////////////////
// CWbemcabApp

BEGIN_MESSAGE_MAP(CWbemcabApp, CWinApp)
	//{{AFX_MSG_MAP(CWbemcabApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemcabApp construction

CWbemcabApp::CWbemcabApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_bExtractFailed = FALSE;

}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWbemcabApp object

CWbemcabApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWbemcabApp initialization






//*******************************************************
// CWbemcabApp::InitInstance
//
// Parse the command line arguments, then display a progress
// dialog while the requested component is being extracted 
// from the cabinet file.
//
// The command line syntax is:
//		wbemcab <cabinet file path> <component class id>
//
//
// Parameters:
//		None.
//
// Returns:
//		int 
//			0 = Success, -1 = failure
//
//********************************************************
BOOL CWbemcabApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)


	int nResponse;
	CWbemcabDlg dlg;

	// Parse the parameter and validate them.  This gives us sCodebase and clsid.
	CParams params;
	ParseCommandLine(reinterpret_cast<CCommandLineInfo&>(params));


	if (params.m_bDisplayHelp) {
		::MessageBox(NULL, _T("The CabExtract utility extracts and installs controls from a cabinet file.\r\n\r\nUsage:\r\n    CabExtract <cabinet file> <class id> <version>"), _T("CabExtract Help"), MB_OK | MB_ICONINFORMATION);
		return FALSE;
	}


	// Pass the parameters to the dialog
	DWORD dwVersionMajor = 0;
	DWORD dwVersionMinor = 0;
	CString sCodebase;
	if (!params.Validate(params, sCodebase, dlg.m_clsid, dlg.m_dwVersionMajor, dlg.m_dwVersionMinor)) {
		goto FAILURE;
	}
	dlg.m_varCodebase = sCodebase;


	// Display the dialog and handle the result code.
	m_pMainWnd = &dlg;
	nResponse = dlg.DoModal();

	if (nResponse == IDCANCEL)
	{
		// The component extraction failed.
		goto FAILURE;
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;

FAILURE:
	m_bExtractFailed = TRUE;
	return FALSE;
}


//*******************************************************
// CWbemcabApp::ExitInstance
//
// Return the success or failure code to the process that invoked this utility.
//
// Parameters:
//		None.
//
// Returns:
//		int 
//			0 = Success, -1 = failure
//
//********************************************************
int CWbemcabApp::ExitInstance( )
{
	CWinApp::ExitInstance();
	if (m_bExtractFailed) {
		return -1;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\wbemcabdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// wbemcabDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wbemcab.h"
#include "wbemcabDlg.h"
#include <afxpriv.h>
#include "download.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TCHAR szMessage[];

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemcabDlg dialog

CWbemcabDlg::CWbemcabDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWbemcabDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWbemcabDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_dwVersionMajor = -1;
	m_dwVersionMinor = -1;
}

void CWbemcabDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWbemcabDlg)
	DDX_Control(pDX, IDC_MESSAGE, m_msg);
	DDX_Control(pDX, IDC_ANIMATE, m_progress);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWbemcabDlg, CDialog)
	//{{AFX_MSG_MAP(CWbemcabDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ONSTOPBINDING, OnStopBind)
	ON_MESSAGE(WM_UPDATE_PROGRESS, OnUpdateProgress)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemcabDlg message handlers

BOOL CWbemcabDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	

	BOOL x = m_progress.Open(IDR_AVIDOWNLOAD);




	m_download = new CDownload(this);

	HRESULT hr;
	hr = OleInitialize(NULL);
	hr = CreateBindCtx(0, &m_pBindContext);

	// Note that the URL moniker will not request IWindowForBindingUI from clients 
	// unless the bind context BIND_OPTS specify the grfFlags value of BIND_MAYBOTHERUSER. 
	// The bind context BIND_OPTS is set by calling IBindCtx::SetBindOptions
	BIND_OPTS bindopts;
	m_pBindContext->GetBindOptions(&bindopts);
	bindopts.grfFlags |= BIND_MAYBOTHERUSER;
	m_pBindContext->SetBindOptions(&bindopts);


	m_download->ExternalQueryInterface(&IID_IBindStatusCallback, (void **)&m_pBindStatusCallback);
	hr = RegisterBindStatusCallback(m_pBindContext, m_pBindStatusCallback, 0, 0);
	
	LPCLASSFACTORY pClassFactory = NULL;
	hr = CoGetClassObjectFromURL(m_clsid, m_varCodebase.bstrVal, 
								 m_dwVersionMajor, m_dwVersionMinor, 
								 NULL, m_pBindContext, 
								 CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
								 0, IID_IClassFactory, (void **)&pClassFactory);

	switch (hr)
	{
		case S_OK:
			PostMessage(WM_ONSTOPBINDING, (WPARAM)pClassFactory);
			break;
		case MK_S_ASYNCHRONOUS:
			break;
		case E_NOINTERFACE:
			PostMessage(WM_ONSTOPBINDING, (WPARAM)NULL);
			break;
		default:
			PostMessage(WM_ONSTOPBINDING, (WPARAM)NULL);
		break;
	}




	return TRUE;  // return TRUE  unless you set the focus to a control
}






LRESULT CWbemcabDlg::OnStopBind(WPARAM wParam, LPARAM lParam)
{

	m_pBindStatusCallback->Release();
	m_pBindContext->Release();
	delete m_download;

	// WParam will be set to TRUE if the component installation was successful.
	if (wParam) {
		// The
		EndDialog(IDOK);
	}
	else {
		::MessageBox(NULL, _T("Control installation failed."), _T("Control Installation Failure"), MB_OK | MB_ICONERROR);
		EndDialog(IDCANCEL);
	}
	return 0;
}

LRESULT CWbemcabDlg::OnUpdateProgress(WPARAM wParam, LPARAM lParam)
{
	m_msg.SetWindowText(szMessage);
	return 0;
}



void CWbemcabDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWbemcabDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWbemcabDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\banner.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: banner.cpp
//
// Description:
//	This file implements the CBanner class which is a part of the Class Explorer
//	OCX.  CBanner is a subclass of the Microsoft CWnd class and performs
//	the following functions:
//		a.  Contains static label, combo box and toolbar child contols
//			which allow the user to select a namespace and add and
//			delete classes
//		b.  Handles the creation of, geometry and destruction of the child
//			contols.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CClassNavCtrl class
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "ClassNavPpg.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "nsentry.h"
#include "ClassNavNSEntry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1

// ***************************************************************************
//
// CBanner::CBanner
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  CClassNavCtrl* pParent		Parent.
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CBanner::CBanner(CClassNavCtrl* pParent)
	:	m_pParent (pParent),
		m_bFontCreated (FALSE),
		m_nFontHeight (13),
		m_nOffset (2),
		m_pnseNameSpace (NULL),
		m_bAdding(FALSE)
{
	m_csBanner = _T("Classes in:");
}

CBanner::~CBanner()
{
	delete m_pnseNameSpace;
}

BEGIN_MESSAGE_MAP(CBanner, CWnd)
	//{{AFX_MSG_MAP(CBanner)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_COMMAND(ID_BUTTONADD, OnButtonadd)
	ON_COMMAND(ID_BUTTONDELETE, OnButtondelete)
	ON_COMMAND(ID_BUTTONCLASSSEARCH, OnButtonclasssearch)
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
//	CBannerCWnd::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls based upon font size for the
//		edit and button controls.  Remainder goes to the tree control.
//
//	Parameters:
//		int cx			Width
//		int cy			Height
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CBanner::SetChildControlGeometry(int cx, int cy)
{
	int nTextLength = GetTextLength(&m_csBanner);
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	CRect rBannerRect = CRect(	0 + nSideMargin ,
							0 + nTopMargin ,
							cx - nSideMargin ,
							cy - nTopMargin);


	rBannerRect.NormalizeRect();

	int nNameSpaceX = rBannerRect.TopLeft().x + nTextLength + 8;

	int nToolBarX = max(nNameSpaceX + 2,
						rBannerRect.TopLeft().x +
							rBannerRect.Width() - (csToolBar.cx + 6));

	int nNameSPaceXMax = nToolBarX - 2;

	#pragma warning( disable :4244 )
	int nToolBarY = rBannerRect.TopLeft().y +
					((rBannerRect.Height() - csToolBar.cy) * .5);
	#pragma warning( default : 4244 )

	m_rNameSpace = CRect(	nNameSpaceX,
							rBannerRect.TopLeft().y - 3 ,
							nNameSPaceXMax,
							rBannerRect.BottomRight().y + 0);


	m_rToolBar = CRect(nToolBarX,
				nToolBarY - nTopMargin,
				rBannerRect.BottomRight().x  - 0,
				nToolBarY + csToolBar.cy + nTopMargin );
}

// ***************************************************************************
//
//	CBannerCWnd::GetTextLength
//
//	Description:
//		Get the length of a string using the control's font.
//
//	Parameters:
//		CString *		Text
//
//	Returns:
//		int				Length of string
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
int CBanner::GetTextLength(CString *pcsText)
{

	CSize csLength;
	int nReturn;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(m_pParent -> m_cfFont) );
	csLength = pdc-> GetTextExtent( *pcsText );
	nReturn = csLength.cx;
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return nReturn;

}

// ***************************************************************************
//
//  CBanner::PreCreateWindow
//
//	Description:
//		This VIRTUAL member function returns Initializes create struct values
//		for the custom tree control.
//
//	Parameters:
//		CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//							creation values.
//
//	Returns:
// 		BOOL				Nonzero if the window creation should continue;
//							0 to indicate creation failure.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CBanner::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style = WS_CHILD | WS_VISIBLE | ES_WANTRETURN;
	cs.style &= ~WS_BORDER;

	if (!CWnd::PreCreateWindow(cs))
	{
		return FALSE;
	}

	return TRUE;

}

// ***************************************************************************
//
//  CClassTree::OnPaint
//
//	Description:
//		Paint the client area of the widow.
//
//	Parameters:
//		NONE
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CBanner::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);


	CBrush br3DFACE(dwBackColor);
	dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);

	// Must do update to be able to over draw the border area.
	m_cctbToolBar.UpdateWindow();
	m_pnseNameSpace->RedrawWindow();

	dc.SelectObject( &(m_pParent->m_cfFont) );

	dc.SetBkMode( TRANSPARENT );

	CRect rcClipInitial;
	int nReturn = dc.GetClipBox( &rcClipInitial);
	CRect rcClip;
	CRect rcClient;
	GetClientRect(rcClient);


	// Draw the banner text that is clipped so that we don't overwrite the other stuff.
	rcClient.DeflateRect(0, 0, 11, 0);
	rcClip.IntersectRect(rcClipInitial, rcClient);
	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect( &rcClip );
	dc.SelectClipRgn( &rgnClip );
	dc.TextOut( m_nOffset + nSideMargin + 2, 9,
		(LPCTSTR) m_csBanner, m_csBanner.GetLength() );
	rgnClip.DeleteObject();

	// Draw the frame using the original clip box.
	dc.SetBkMode( OPAQUE );
	rgnClip.CreateRectRgnIndirect( &rcClipInitial );
	dc.SelectClipRgn( &rgnClip);
	DrawFrame(&dc);
	rgnClip.DeleteObject( );



	// Do not call CWnd::OnPaint() for painting messages
}

// ***************************************************************************
//
// CBanner::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	SetChildControlGeometry(cx, cy);
	m_cctbToolBar.MoveWindow( m_rToolBar);
	m_pnseNameSpace->MoveWindow(m_rNameSpace);

}

// ***************************************************************************
//
// CBanner::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CBanner::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;


	CRect crRect;
	GetClientRect( &crRect);

	if(m_cctbToolBar.Create
		(this, WS_CHILD | WS_VISIBLE  | CBRS_SIZE_FIXED) == -1)
	{
		return FALSE;
	}

	m_cctbToolBar.LoadToolBar( MAKEINTRESOURCE(IDR_TOOLBARADDDELETE) );


	SetChildControlGeometry(crRect.Width(), crRect.Height());

	m_pnseNameSpace = new CClassNavNSEntry;

	m_pnseNameSpace->SetLocalParent(m_pParent);

	if (m_pnseNameSpace->Create(NULL, NULL, WS_VISIBLE | WS_CHILD, m_rNameSpace,
		this, IDC_NSENTRY, NULL) == 0)
	{
		return FALSE;
	}


	CToolBarCtrl* ptbcToolBarCtrl = &m_cctbToolBar.GetToolBarCtrl();


	ptbcToolBarCtrl -> EnableButton(ID_BUTTONADD,FALSE);
	ptbcToolBarCtrl -> EnableButton(ID_BUTTONDELETE,FALSE);
	ptbcToolBarCtrl -> EnableButton(ID_BUTTONCLASSSEARCH,FALSE);

	// This is where we want to associate a string with
	// the tool for each button.
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	#pragma warning( disable :4244 )
	CRect crToolBar(0,0,(int) csToolBar.cx * .3333,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Search for Class"),&crToolBar,1);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int)csToolBar.cx * .3333,0,(int) csToolBar.cx * .6666,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Add Class"),&crToolBar,2);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int) csToolBar.cx * .6666, 0, csToolBar.cx , csToolBar.cy);
 	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Delete Class"),&crToolBar,3);

	return 0;
}

// ***************************************************************************
//
// CClassTree::DrawFrame
//
// Description:
//	  Draws the frame around the banner window.
//
// Parameters:
//	  CDC* pdc			Device context for drawing.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::DrawFrame(CDC* pdc)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame;
	GetClientRect(rcFrame);
	rcFrame.DeflateRect(nSideMargin,nTopMargin - 1);

	CRect rc;


	// Horizontal line at top
	rc.left = rcFrame.left;
	rc.right = rcFrame.right - 1;
	rc.top = rcFrame.top - 1;
	rc.bottom = rcFrame.top ;
	pdc->FillRect(rc, &br3DSHADOW);

	// Horizontal line at bottom
	rc.top = rcFrame.bottom - 1;
	rc.bottom = rcFrame.bottom ;
	pdc->FillRect(rc, &br3DHILIGHT);

	// Vertical line at left
	rc.left = rcFrame.left;
	rc.right = rcFrame.left + 1;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.bottom;
	pdc->FillRect(rc, &br3DSHADOW);

	// Vertical line at right
	rc.left = rcFrame.right - 2;
	rc.right = rcFrame.right - 1;
	pdc->FillRect(rc, &br3DHILIGHT);

}

// ***************************************************************************
//
// CClassTree::OnButtonAdd
//
// Description:
//	  Add class button handler.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnButtonadd()
{
	AddClass(NULL,NULL);
}

void CBanner::AddClass(CString *pcsParent, HTREEITEM hParentItem)
{
	CString csNewClass;
	CString csParent;
	int nReturn;

	m_pParent -> OnActivateInPlace(TRUE,NULL);

	if (m_bAdding == FALSE)
	{
		// Pass In
		CString csParent = pcsParent ? *pcsParent : m_pParent -> GetSelectionClassName();

		BOOL bCanChangeSelection = m_pParent->QueryCanChangeSelection(csParent);

		if (!bCanChangeSelection)
		{
			if (m_pParent ->m_bRestoreFocusToTree)
			{
				m_pParent ->m_ctcTree.SetFocus();
			}
			else
			{
				SetFocus();
			}
			return;
		}
		m_pParent -> GetAddDialog()->SetParent(csParent );
		CString csClass = _T("");
		m_pParent -> GetAddDialog()->SetNewClass(csClass);
		m_bAdding = TRUE;
	}

	m_pParent -> PreModalDialog();
	nReturn = (int) m_pParent -> GetAddDialog() -> DoModal( );
	m_pParent -> PostModalDialog();

	if (nReturn == IDCANCEL)
	{
		m_bAdding = FALSE;
		if (m_pParent ->m_bRestoreFocusToTree)
		{
			m_pParent ->m_ctcTree.SetFocus();
		}
		else
		{
			SetFocus();
		}
		return;
	}

	csParent = m_pParent -> GetAddDialog() -> GetParent();
	// Filter out leading space
	csParent.TrimLeft();
	csParent.TrimRight();

	csNewClass = 	m_pParent -> GetAddDialog() -> GetNewClass();
	csNewClass.TrimLeft();
	csNewClass.TrimRight();

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}

	COleVariant covParent(csParent);


	CString csError;

	// Pass in
	HTREEITEM hParent;

	if (csParent.GetLength() > 0)
	{
		hParent = pcsParent ? hParentItem : m_pParent -> GetSelection();
	}
	else
	{
		hParent = NULL;
	}


	IWbemClassObject *pimcoNew =
		CreateSimpleClass
		(m_pParent -> GetServices(), &csNewClass, &csParent,
		nReturn, csError);

	if (!pimcoNew)
	{
		OnButtonadd();
		return;
	}

	if (csParent.GetLength() > 0)
	{
		IWbemClassObject *pParent =
			GetClassObject (m_pParent->GetServices(),&csParent);
		if (pParent)
		{
			hParent = m_pParent->m_ctcTree.FindAndOpenObject(pParent);
			pParent->Release();
		}
	}
	else
	{
		hParent = NULL;
	}


	HTREEITEM hNew =
			m_pParent -> GetTree() -> FindObjectinChildren
				(hParent, pimcoNew);

	if (!hParent || !hNew)
	{
		HTREEITEM hItem =
			m_pParent -> GetTree() -> AddNewClass(hParent, pimcoNew);

		TV_INSERTSTRUCT		tvstruct;
		tvstruct.item.hItem = hParent;
		tvstruct.item.mask = TVIF_CHILDREN | TVIF_STATE;
		tvstruct.item.stateMask = TVIS_EXPANDEDONCE;
		tvstruct.item.state = TVIS_EXPANDEDONCE;
		tvstruct.item.cChildren = 1;

		m_pParent -> GetTree() -> SetItem(&tvstruct.item);


		m_pParent -> GetTree() -> Expand(hParent,TVE_EXPAND );
		m_pParent -> GetTree() -> EnsureVisible(hItem );
		m_pParent -> GetTree() -> SelectItem(hItem);
		m_pParent -> GetTree() -> SetFocus();
	}


	csNewClass = GetIWbemFullPath(m_pParent->GetServices(),pimcoNew);
	COleVariant covNewClass(csNewClass);

	if (m_pParent->m_bReadySignal)
	{
		m_pParent -> FireEditExistingClass(covNewClass);
	}

	m_bAdding = FALSE;

#ifdef _DEBUG
	afxDump <<"CBanner::OnButtonadd(): 	m_pParent -> FireEditExistingClass(covNewClass); \n";
	afxDump << "     " << csNewClass << "\n";
#endif

}

// ***************************************************************************
//
// CClassTree::OnButtonDelete
//
// Description:
//	  Delete class button handler.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnButtondelete()
{
	DeleteClass(NULL,NULL);
}

void CBanner::DeleteClass(CString *pcsDeleteClass, HTREEITEM hDeleteItem)
{
	m_pParent -> OnActivateInPlace(TRUE,NULL);

	HTREEITEM hSelection = hDeleteItem ? hDeleteItem : m_pParent -> GetSelection();
	HTREEITEM hParent = m_pParent -> m_ctcTree.GetParentItem(hSelection);
	CString csSelection = pcsDeleteClass ? *pcsDeleteClass : m_pParent -> GetSelectionClassName();

	m_pParent -> m_ctcTree.SelectItem(hSelection);

	HTREEITEM hNewSelection = m_pParent->GetSelection();

	BOOL bCanChangeSelection = (hSelection == hNewSelection);// m_pParent -> QueryCanChangeSelection(csSelection);

	if (!bCanChangeSelection)
	{
		if (m_pParent ->m_bRestoreFocusToTree)
		{
			m_pParent ->m_ctcTree.SetFocus();
		}
		else
		{
			SetFocus();
		}
		return;
	}

//	m_pParent -> m_ctcTree.SelectItem(hSelection);

	BOOL bSubclasses = HasSubclasses(m_pParent->GetServices(), &csSelection, m_pParent->m_csNameSpace);
	CString csPrompt = _T("Do You Want to Delete the \"");
	csPrompt += csSelection;
	if (bSubclasses)
	{
		csPrompt+= _T("\" class and all its children?");
	}
	else
	{
		csPrompt+= _T("\" class?");
	}
	CString csError;

	int nReturn =
			::MessageBox
			( m_pParent -> GetSafeHwnd(),
			csPrompt,
			_T("Delete Class Query"),
			MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 |
			MB_APPLMODAL);

	if (nReturn == IDYES)
	{
		BOOL bReturn = DeleteAClass(m_pParent -> GetServices(),&csSelection);
		if (bReturn)
		{
			HTREEITEM hPreSibling = m_pParent -> GetTree()->GetPrevSiblingItem(hSelection);
			HTREEITEM hSibling = m_pParent -> GetTree()->GetNextSiblingItem(hSelection);
			HTREEITEM hParent = m_pParent -> GetTree()->GetParentItem(hSelection);

			m_pParent -> GetTree()->SetDeleting(TRUE);
			m_pParent -> GetTree() -> DeleteBranch(hSelection);

			m_pParent->GetTree()->m_schema.Delete(csSelection);
			m_pParent->GetTree()->RefreshIcons(hParent);

			IWbemClassObject *pItem =
				hSibling ?
				(IWbemClassObject*)
					m_pParent -> GetTree() -> GetItemData(hSibling):
					(hParent ? (IWbemClassObject*)
						m_pParent -> GetTree() -> GetItemData(hParent):
						(hPreSibling? (IWbemClassObject*)
							m_pParent -> GetTree() -> GetItemData(hPreSibling):
						NULL));
			if (pItem)
			{

				if (m_pParent->m_bReadySignal)
				{
					CString csClass =
						GetIWbemFullPath(m_pParent->GetServices(),pItem);
					COleVariant covClass(csClass);
					m_pParent -> FireEditExistingClass(covClass);
				}

			}
			m_pParent -> GetTree()->SetDeleting(FALSE);

		}
	}

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}

}

CString CBanner::GetNameSpace()
{
	return m_pnseNameSpace->GetNameSpace();

}

void CBanner::SetNameSpace(CString *pcsNamespace)
{
	m_pnseNameSpace->SetNameSpace(*pcsNamespace);

}

SCODE CBanner::OpenNamespace(CString *pcsNamespace, BOOL boolNoFireEvent)
{
	BOOL bReturn =
		m_pnseNameSpace->OpenNamespace
		(*pcsNamespace,boolNoFireEvent);

	return bReturn;

}

void CBanner::NSEntryRedrawn()
{

	Invalidate();
	m_pParent->InvalidateControl();


}

void CBanner::OnButtonclasssearch()
{
	// TODO: Add your command handler code here

	m_pParent -> OnActivateInPlace(TRUE,NULL);
	m_pParent->OnPopupSearchforclass();

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}
}



void CBanner::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

}

void CBanner::OnSetFocus(CWnd* pOldWnd)
{
	m_pnseNameSpace->SetFocusToEdit();

}

/*	EOF:  banner.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\banner.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: banner.h
//
// Description:
//	This file declares the CBanner class which is a part of the Class Explorer 
//	OCX.  CBanner is a subclass of the Microsoft CWnd class and performs 
//	the following functions:
//		a.  Contains static label, combo box and toolbar child contols
//			which allow the user to select a namespace and add and
//			delete classes
//		b.  Handles the creation of, geometry and destruction of the child
//			contols.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	CClassNavCtrl class	 
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CBanner
//
// Description:
//	This class is a subclass of the Microsoft CWnd class. It is a window
//	container class for three child windows, two of which provide a 
//	significant part of the Class Explore's user interface.  It contains a
//	static label, a combo box which allows the user to select a namespace
//	and a toolbar for adding and deleting classes.
//
// Public members:
//	
//	CBanner 
//
//============================================================================
//	CBanner		Public constructor.
//
//============================================================================
//
//  CBanner::CBanner
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//

//****************************************************************************

#ifndef _CBANNER_H_
#define _CBANNER_H_

class CClassNavCtrl;
//class CNameSpace;
class CClassTree;
class CClassNavNSEntry;

class CBanner : public CWnd
{
// Construction
public:
	CBanner(CClassNavCtrl* pParent = NULL);   // standard constructor
	~CBanner();
	CString GetNameSpace();
	void SetNameSpace(CString *pcsNamespace);
	SCODE OpenNamespace(CString *pcsNamespace, BOOL boolNoFireEvent);
protected:
	void SetParent(CClassNavCtrl* pParent) 
		{	m_pParent = pParent;
		}
	CClassNavCtrl* m_pParent;
	BOOL m_bFontCreated;

	CClassNavNSEntry *m_pnseNameSpace;
	CContainedToolBar m_cctbToolBar;

	CString m_csBanner;
	int m_nOffset;
	int m_nFontHeight;

	CRect m_rFilter;
	CRect m_rNameSpace;
	CRect m_rToolBar;
	int GetTextLength(CString *pcsText);
	void SetChildControlGeometry(int cx, int cy);
	void DrawFrame(CDC* pdc);

	void NSEntryRedrawn();

	BOOL m_bAdding;

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBanner)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

	friend class CClassNavCtrl;
	friend class CClassNavNSEntry;
	friend class CClassTree;

	void AddClass(CString *pcsParent = NULL, HTREEITEM hParent = NULL);
	void DeleteClass(CString *pcsDeleteClass = NULL, HTREEITEM hDeleteItem = NULL);

	//{{AFX_MSG(CBanner)
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnButtonadd();
	afx_msg void OnButtondelete();
	afx_msg void OnButtonclasssearch();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

/*	EOF:  banner.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\cclasstree.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CClassTree.cpp
//
// Description:
//	This file implements the CClassTree class which is a part of the Class
//	Navigator OCX, it is a subclass of the Microsoft CTreeCtrl common
//  control and performs the following functions:
//		a.  Insertion of individual classes
//		b.  Allows classes to be "expanded" by going out to the database
//			to get its subclasses
//		c.  Allows classes to be renamed.
//		d.  Supports operations to add and delete tree branches.
//		e.	Supports OLE drag and drop (disabled for ALPHA)
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

// ===========================================================================
//
//	Includes
//
// ===========================================================================

#include "precomp.h"
#include "resource.h"
#include "afxpriv.h"
#include "AFXCONV.H"
#include "wbemidl.h"
#include "olemsclient.h"
#include "CClassTree.h"
#include "RenameClassDIalog.h"
#include "TreeDropTarget.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "resource.h"


#define KBSelectionTimer 1000
#define ExpansionOrSelectionTimer 1001
#define UPDATESELECTEDITEM WM_USER + 450
#define SELECTITEMONFOCUS WM_USER + 451

void CALLBACK EXPORT  SelectItemAfterDelay(HWND hWnd,UINT nMsg, WPARAM nIDEvent, ULONG dwTime)
{
	::PostMessage(hWnd,UPDATESELECTEDITEM,0,0);
}


// Only has a valid value for the interval between a double click.
CClassTree *gpTreeTmp;

void CALLBACK EXPORT  ExpansionOrSelection(HWND hWnd,UINT nMsg,WPARAM nIDEvent, ULONG dwTime)
{

	CClassTree *pTree = gpTreeTmp;

	if (!pTree)
	{
		return;
	}

	if (pTree->m_uiSelectionTimer)
	{
		pTree->KillTimer(pTree->m_uiSelectionTimer );
		pTree-> m_uiSelectionTimer= 0;
	}

	if (InterlockedDecrement(&pTree->m_lSelection) == 0)
	{
		CPoint point(0,0);
		pTree->ContinueProcessSelection(TRUE,point );
		gpTreeTmp = NULL;
	}
}

// ===========================================================================
//
//	Message Map
//
// ===========================================================================
BEGIN_MESSAGE_MAP(CClassTree,CTreeCtrl)
	ON_WM_CONTEXTMENU()
	//{{AFX_MSG_MAP(CClassTree)
	ON_WM_CREATE()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, OnEndlabeledit)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemexpanded)
	ON_NOTIFY_REFLECT(TVN_BEGINLABELEDIT, OnBeginlabeledit)
	ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(NM_KILLFOCUS, OnKillfocus)
	ON_NOTIFY_REFLECT(NM_SETFOCUS, OnSetfocus)
	ON_NOTIFY_REFLECT(TVN_SELCHANGING, OnSelchanging)
	//}}AFX_MSG_MAP
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING,OnItemExpanding)
	ON_MESSAGE( UPDATESELECTEDITEM,SelectTreeItem)
	ON_MESSAGE( SELECTITEMONFOCUS,SelectTreeItemOnFocus)
END_MESSAGE_MAP()

// ***************************************************************************
//
//  CClassTree::PreCreateWindow
//
//	Description:
//		This VIRTUAL member function returns Initializes create struct values
//		for the custom tree control.
//
//	Parameters:
//		CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//							creation values.
//
//	Returns:
// 		BOOL				Nonzero if the window creation should continue;
//							0 to indicate creation failure.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CClassTree::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CTreeCtrl::PreCreateWindow(cs))
		return FALSE;

	cs.style = WS_CHILD | WS_VISIBLE |  CS_DBLCLKS | TVS_SHOWSELALWAYS |
		TVS_HASLINES |  TVS_LINESATROOT |TVS_HASBUTTONS;

	return TRUE;
}

// ***************************************************************************
//
// CClassTree::CClassTree
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CClassTree::CClassTree()
	:	m_bInDrag (FALSE),
		m_prevDropEffect (DROPEFFECT_NONE),
		m_bDropTargetRegistered (FALSE),
		m_bDragAndDropState (FALSE),
		m_dragSize (1,1),
		m_dragPoint (-1,-1),
		m_lClickTime(0),
		m_bDeleting(FALSE),
		m_bMouseDown(FALSE),
		m_bKeyDown(FALSE),
		m_uiTimer(0),
		m_bFirstSetFocus(TRUE),
		m_bUseItem(FALSE),
		m_hItemToUse(NULL)
{

}

//============================================================================
//
//  CClassTree::InitTreeState
//
//	Description:
//		This function initializes processing state for the custom tree control.
//
//	Parameters:
//		CClassNavCtrl *pParent	A CClassNavCtrl pointer to the tree controls
//								parent window.
//
//	Returns:
//		VOID				.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//============================================================================
void CClassTree::InitTreeState (CClassNavCtrl *pParent)
{
	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;

	m_pParent = pParent;
}

// ***************************************************************************
//
//  CClassTree::AddTreeObject
//
//	Description:
//		Adds an IWbemClassObject instance to the tree.
//
//	Parameters:
//		HTREEITEM hParent			Tree item parent.
//		IWbemClassObject *pimcoNew	Class object
//		BOOL bNewClass				If a new class add to tree and class
//									roots.
//
//	Returns:
// 		HTREEITEM					Tree item handle of added class.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
HTREEITEM CClassTree::AddNewClass(HTREEITEM hParent,IWbemClassObject *pimcoNew)
{
	CSchemaInfo::CClassInfo &info= m_schema.AddClass(pimcoNew);

	HTREEITEM hObject = AddTreeObject2(hParent, info);

	if (hObject)
		EnsureVisible(hObject);

	// Update parent's icons
	if(hParent)
		RefreshIcons(hParent);
	else
	{
		m_pParent->GetTreeRoots()->Add(hObject);
		m_pParent->GetClassRoots()->Add(pimcoNew);
	}

	return hObject;
}

void CClassTree::RefreshIcons(HTREEITEM hItem)
{
	while(hItem)
	{
		int nImage = m_schema[GetItemText(hItem)].GetImage();
		SetItemImage(hItem, nImage, nImage);
		hItem = GetParentItem(hItem);
	}
}


HTREEITEM CClassTree::AddTreeObject2(HTREEITEM hParent, CSchemaInfo::CClassInfo &info)
{
	HTREEITEM hObject = NULL;
	int nImage = info.GetImage();
	hObject = InsertTreeItem(hParent, (LPARAM) info.m_pObject, nImage, nImage, info.m_szClass, FALSE, info.m_rgszSubs.GetSize()>0);
	return hObject;
}

// ***************************************************************************
//
//  CClassTree::OnItemExpanding
//
//	Description:
//		Special processing associated with expanding or callapsing a
//		tree branch.
//
//	Parameters:
//		NMHDR *pNMHDR				Notification message structure.
//		LRESULT *pResult			Set to TRUE to prevent the list from
//									expanding or collapsing.
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnItemExpanding
(NMHDR *pNMHDR, LRESULT *pResult)
{

	SetFocus();

	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	HTREEITEM hItem = pnmtv->itemNew.hItem;

	*pResult = 0;
	m_pParent -> InvalidateControl();
}

// ***************************************************************************
//
//  CClassTree::InsertTreeItem
//
//	Description:
//		Construct TV_INSERTSTRUCT for insertion into the CTreeCtrl and insert
//		item.
//
//	Parameters:
//		HTREEITEM hParent		Parent tree item.
//		LPARAM lparam			Data to store in tree item data.
//		int iBitmap				Index to bitmap.
//		int iSelectedBitmap		Index to selected bitmap.
//		LPCTSTR pszText			Tree item label.
//		BOOL bBold				If TRUE label in bold.
//		BOOL bChildren			If TRUE tree item has children.
//
//	Returns:
// 		HTREEITEM				Tree item handle of new item.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
HTREEITEM CClassTree::InsertTreeItem
(HTREEITEM hParent, LPARAM lparam, int iBitmap, int iSelectedBitmap,
 LPCTSTR pszText, BOOL bBold, BOOL bChildren)
{
	// If we are in select all mode we open the tree items
	// with a check (see tvis.item.state)

	TVINSERTSTRUCT tvis;
	tvis.hParent = hParent;
	tvis.hInsertAfter = TVI_LAST;
	tvis.item.mask = TVIF_TEXT | TVIF_SELECTEDIMAGE | TVIF_CHILDREN | TVIF_PARAM | TVIF_IMAGE | TVIF_STATE;
	tvis.item.cChildren = bChildren?1:0;
	tvis.item.pszText = (LPTSTR) pszText;
	tvis.item.iImage = iBitmap;
	tvis.item.iSelectedImage = iBitmap;
	tvis.item.state = INDEXTOSTATEIMAGEMASK((m_pParent->m_bSelectAllMode)?2:1);;
	tvis.item.stateMask = TVIS_STATEIMAGEMASK;
	tvis.item.lParam = lparam;

	return InsertItem(&tvis);
}

// ***************************************************************************
//
//  CClassTree::OnRButtonDown
//
//	Description:
//		Do not pass on to the base class so the context menu can be
//		invoked.
//
//	Parameters:
//		UINT nFlags		Indicates whether various virtual keys are down.
//		CPoint point	Specifies the x and y coordinates of the cursor.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnRButtonDown(UINT nFlags, CPoint point)
{
	// Do not want to pass on to tree control.
	UINT hitFlags ;
    HTREEITEM hItem ;

    hItem = HitTest( point, &hitFlags ) ;
    if (hitFlags & (TVHT_ONITEM | TVHT_ONITEMBUTTON))
	{
//		m_pParent->m_hContextSelection = hItem;
	}
	else
	{
//		m_pParent->m_hContextSelection = NULL;
	}
}


// ***************************************************************************
//
//  CClassTree::OnContextMenu
//
//	Description:
//		Initialize the context menu.  See PSS ID Q141199.
//
//	Parameters:
//		CWnd* pWnd		CWnd parent.
//		CPoint point	Specifies the x and y coordinates of the cursor.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnContextMenu(CWnd* pWnd, CPoint point)
{
	// CG: This function was added by the Pop-up Menu component
	// See for PSS ID Number: Q141199 for explanation of modifications
	// required for COleControl

	UINT hitFlags ;
    HTREEITEM hItem ;

	CPoint cpClient;

	if (point.x == -1 && point.y == -1)
	{
		CRect crClient;
		GetClientRect(&crClient);
		hItem = GetSelectedItem();
		if (hItem)
		{
			RECT rect;
			BOOL bRect = GetItemRect(hItem,&rect, TRUE );
			POINT p;
			p.x = rect.left + 2;
			p.y = rect.top + 2;
			if (bRect && crClient.PtInRect(p))
			{
				cpClient.x = rect.left + 2;
				cpClient.y = rect.top + 2;
			}
			else
			{
				cpClient.x = 0;
				cpClient.y = 0;
			}
		}
		m_pParent->m_hContextSelection = hItem;
		point = cpClient;
		ClientToScreen(&point);
	}
	else
	{
		cpClient = point;
		ScreenToClient(&cpClient);
		hItem = HitTest( cpClient, &hitFlags ) ;
		if (hitFlags & (TVHT_ONITEM | TVHT_ONITEMBUTTON))
		{
			m_pParent->m_hContextSelection = hItem;
		}
		else
		{
			m_pParent->m_hContextSelection = NULL;
		}
	}


	VERIFY(m_cmContext.LoadMenu(CG_IDR_POPUP_A_TREE_CTRL));

	CMenu* pPopup = m_cmContext.GetSubMenu(0);

	CWnd* pWndPopupOwner = m_pParent;

	HWND hwndFocus = ::GetFocus();
	pPopup->TrackPopupMenu
		(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
		pWndPopupOwner);


	m_cmContext.DestroyMenu();
	if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
		::SetFocus(hwndFocus);
	}
}

// ***************************************************************************
//
// CClassTree::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CClassTree::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CTreeCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_uTreeCF = RegisterClipboardFormat(_T("ATREECONTROL_CF"));

	return 0;
}

// ***************************************************************************
//
//  CClassTree::OnLButtonDown
//
//	Description:
//		Process things that need to happen on a left button down.
//
//	Parameters:
//		UINT nFlags		Indicates whether various virtual keys are down.
//		CPoint point	Specifies the x and y coordinates of the cursor.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnLButtonDown(UINT nFlags, CPoint point)
{
	UINT m_nLBDFlags;
	CPoint m_cpLBDPoint = point;

	HTREEITEM hItem = HitTest( m_cpLBDPoint, &m_nLBDFlags ) ;

	// Toggle tree item image if the state icon was selected.
	if (hItem  && (m_nLBDFlags & (TVHT_ONITEMSTATEICON)) )
	{
		UINT nStateMask = TVIS_STATEIMAGEMASK;
		UINT uState =
			GetItemState( hItem, nStateMask );

		UINT uImage1 = 	 INDEXTOSTATEIMAGEMASK (1);
		UINT uImage2 = 	 INDEXTOSTATEIMAGEMASK (2);


		if (uState & INDEXTOSTATEIMAGEMASK (1))
		{
			uState = INDEXTOSTATEIMAGEMASK (2);
		}
		else
		{
			if (m_pParent->m_bSelectAllMode)
			{
				m_pParent->m_bItemUnselected = TRUE;
			}
			else
			{
				m_pParent->m_bItemUnselected = FALSE;

			}
			uState = INDEXTOSTATEIMAGEMASK (1);
		}

        SetItemState(hItem, uState, TVIS_STATEIMAGEMASK);

	}

    CTreeCtrl::OnLButtonDown(nFlags, point);

}

// ***************************************************************************
//
//  CClassTree::OnLButtonUp
//
//	Description:
//		Process things that need to happen on a left button up.
//
//	Parameters:
//		UINT nFlags		Indicates whether various virtual keys are down.
//		CPoint point	Specifies the x and y coordinates of the cursor.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_bMouseDown = TRUE;
	m_bKeyDown = FALSE;


    CTreeCtrl::OnLButtonUp(nFlags, point);

	m_pParent -> OnActivateInPlace(TRUE,NULL);

}

// ***************************************************************************
//
//  CClassTree::OnMouseMove
//
//	Description:
//		Process things that need to happen when the mouse moves.
//
//	Parameters:
//		UINT nFlags		Indicates whether various virtual keys are down.
//		CPoint point	Specifies the x and y coordinates of the cursor.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bInDrag)
	{
		CTreeCtrl::OnMouseMove(nFlags, point);
		return;
	}

	if ((nFlags & MK_LBUTTON) == MK_LBUTTON)
	{
		UINT m_nLBDFlags;
		CPoint m_cpLBDPoint = point;

		HTREEITEM hItem = HitTest( m_cpLBDPoint, &m_nLBDFlags ) ;

		m_bInDrag = TRUE;	// This disables beginning a drag
							// Maybe will be enabled post alpha

		return;
	}


	CTreeCtrl::OnMouseMove(nFlags, point);
}


// ***************************************************************************
//
//  CClassTree::OnSelchanged
//
//	Description:
//		Process things that need to happen when the selected tree item
//		has changed.
//
//	Parameters:
//		NMHDR *pNMHDR				Notification message structure.
//		LRESULT *pResult			Set to TRUE to prevent the selection from
//									changing.
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	*pResult = 0;
	m_pParent -> PostMessage(SETFOCUSTREE,0,0);
}

void CClassTree::ContinueProcessSelection(UINT nFlags, CPoint point)
{
	if (m_pParent->m_bOpeningNamespace)
	{
		return;
	}

	UINT uFlags = 0;
	HTREEITEM hItem;

	if (m_bUseItem)
	{

		hItem = m_hItemToUse;
		m_bUseItem = FALSE;
		m_hItemToUse = NULL;
	}
	else
	{
		hItem= HitTest( point, &uFlags );
	}

	if (!hItem || m_bKeyDown)
	{
		m_bUseItem = FALSE;
		m_hItemToUse = NULL;
		m_pParent -> PostMessage(SETFOCUSTREE,0,0);
		return;
	}


	IWbemClassObject *pItem = reinterpret_cast<IWbemClassObject *>(GetItemData(hItem));

	if (m_bUseItem)
	{
		m_bUseItem = FALSE;
		m_hItemToUse = NULL;
	}

	if (!pItem)
	{
		m_pParent -> PostMessage(SETFOCUSTREE,0,0);
		return;
	}

	CString csClass = _T("__Class");
	m_csSelection = ::GetProperty(pItem, &csClass);

	if (m_csSelection[0] == '_' &&  m_csSelection[1] == '_')
	{
		// Disable the delete button.
		m_pParent->m_cbBannerWindow.m_cctbToolBar.
			GetToolBarCtrl().EnableButton(ID_BUTTONDELETE,FALSE);
		m_pParent->m_cbBannerWindow.m_cctbToolBar.
			GetToolBarCtrl().EnableButton(ID_BUTTONADD,TRUE);
	}
	else
	{
		m_pParent->m_cbBannerWindow.m_cctbToolBar.
			GetToolBarCtrl().EnableButton(ID_BUTTONDELETE,TRUE);
		m_pParent->m_cbBannerWindow.m_cctbToolBar.
			GetToolBarCtrl().EnableButton(ID_BUTTONADD,TRUE);
	}

	if (!m_bDeleting)
	{
		CString csItem;
		COleVariant covClass;
		// Fire events.
		csItem = GetIWbemFullPath(m_pParent->GetServices(),pItem);
		covClass = csItem;
		if (!m_pParent->m_bOpenedInitialNamespace)
		{
			m_pParent->m_bOpenedInitialNamespace = TRUE;

			if (m_pParent->m_bReadySignal)
			{
				m_pParent->FireNotifyOpenNameSpace(m_pParent->m_csNameSpace);
			}
		}
#ifdef _DEBUG
		afxDump <<"CClassTree::OnSelchanged: 	Before m_pParent -> FireEditExistingClass(covNewClass); \n";
		afxDump << "     " << csItem << "\n";
#endif
		if (m_pParent->m_bReadySignal)
		{
			m_pParent -> FireEditExistingClass(covClass);
		}
#ifdef _DEBUG
		afxDump <<"CClassTree::OnSelchanged: 	After m_pParent -> FireEditExistingClass(covNewClass); \n";
		afxDump << "     " << csItem << "\n";
#endif


	}

	m_pParent -> PostMessage(SETFOCUSTREE,0,0);




}


// ***************************************************************************
//
//  CClassTree::OnHScroll
//
//	Description:
//		Process things that need to happen when the tree has been scrolled.
//
//	Parameters:
//		UINT nSBCode			Scroll-bar code for scrolling request.
//		UINT nPos				Scroll-box position.
//		CScrollBar* pScrollBar	Scroll bar control or NULL.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
}

// ***************************************************************************
//
//  CClassTree::OnVScroll
//
//	Description:
//		Process things that need to happen when the tree has been scrolled.
//
//	Parameters:
//		UINT nSBCode			Scroll-bar code for scrolling request.
//		UINT nPos				Scroll-box position.
//		CScrollBar* pScrollBar	Scroll bar control or NULL.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnVScroll(nSBCode, nPos, pScrollBar);
}

// ***************************************************************************
//
// CClassTree::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::OnSize(UINT nType, int cx, int cy)
{
	CTreeCtrl::OnSize(nType, cx, cy);
}

// ***************************************************************************
//
// CClassTree::OnDestroy
//
// Description:
//	  Process things that need to happen when the tree is going away,
//	  before the tree is actually destroyed.  Is is no longer visible
//	  but still exists.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::OnDestroy()
{
	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;


	CPtrArray *pcpaTreeRoots = m_pParent -> GetTreeRoots();

	int nRoots = (int) pcpaTreeRoots -> GetSize( );

	HTREEITEM hItem;
	for (int i = 0; i < nRoots; i++)
	{
		hItem =
			reinterpret_cast<HTREEITEM>(pcpaTreeRoots -> GetAt(i));
		if (hItem)
		{
			ReleaseClassObjects(hItem);
		}
	}

	CTreeCtrl::OnDestroy();
}

// ***************************************************************************
//
// CClassTree::GetSelectionPath
//
// Description:
//	  Returns a CString which contains the current tree selection.
//
// Parameters:
//	  VOID
//
// Returns:
//	  CString		Full path of selection.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CString CClassTree::GetSelectionPath(HTREEITEM hIn)
{
	CString csPath = _T("");
	HTREEITEM hItem = hIn ? hIn :GetSelectedItem();
	if (hItem)
	{
		IWbemClassObject *pimcoSel =
			reinterpret_cast<IWbemClassObject *>
			(GetItemData(hItem));
		if (pimcoSel)
		{
			csPath = GetIWbemFullPath
				(NULL, pimcoSel);
		}
	}

	return csPath;
}

// ***************************************************************************
//
// CClassTree::NumExtendedSelection
//
// Description:
//	  Returns the number of extended selections for specified state.
//
// Parameters:
//	  int nState		Selected or not selected
//
// Returns:
//	  int				Number of items with state.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CClassTree::NumExtendedSelection(int nState)
{
	CPtrArray cpaExtendedSelection;

	int nExtendedSelection =
		ExtendedSelectionFromTree(cpaExtendedSelection,nState);

	CString *pcs;
	for (int i = 0; i < nExtendedSelection; i++)
	{
		pcs = reinterpret_cast<CString *>
			(cpaExtendedSelection.GetAt(i));
		delete pcs;
	}

	return nExtendedSelection;
}

// ***************************************************************************
//
// CClassTree::GetExtendedSelection
//
// Description:
//	  Return a SAFEARRAY which contains the class names of classes selected
//	  via the extended selection mechanism. [Extended selection is via
//	  selection of the tree items icon.]
//
// Parameters:
//	  int nState		Selected or not selected
//
// Returns:
//	  SAFEARRAY *		Of type VT_BSTR
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
SAFEARRAY *CClassTree::GetExtendedSelection(int nState)
{

	SAFEARRAY *psaSelections;
	int i;

	CPtrArray cpaExtendedSelection;

	int nExtendedSelection =
		ExtendedSelectionFromTree(cpaExtendedSelection,nState);

	if (nExtendedSelection == 0)
	{
		MakeSafeArray (&psaSelections, VT_BSTR, 1);
		PutStringInSafeArray (psaSelections, &m_pParent->m_csNameSpace, 0);
	}
	else
	{
		MakeSafeArray (&psaSelections, VT_BSTR, nExtendedSelection + 1);
		int n = 0;
		PutStringInSafeArray (psaSelections, &m_pParent->m_csNameSpace , n++);
		for (i = 0; i < nExtendedSelection; i++)
		{
			CString *pcs =
				reinterpret_cast<CString *>(cpaExtendedSelection.GetAt(i));
			PutStringInSafeArray (psaSelections, pcs , n++);
		}
	}

	int nSelections = (int)  cpaExtendedSelection.GetSize( );

	CString *pcs;
	for (i = 0; i < nSelections; i++)
	{
		pcs = reinterpret_cast<CString *>
			(cpaExtendedSelection.GetAt(i));
		delete pcs;
	}

	return psaSelections;

}

// ***************************************************************************
//
// CClassTree::ExtendedSelectionFromTree
//
// Description:
//	  Return a CPtrArray which contains the class names of classes selected
//	  via the extended selection mechanism with state (either selected or not
//	  selected.  For whole tree.
//
// Parameters:
//	  CPtrArray &cpaExtendedSelection	The items with state.
//	  int nState						Selected or not selected
//
// Returns:
//	  int								Number of items with state in tree.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CClassTree::ExtendedSelectionFromTree
(CPtrArray &cpaExtendedSelection,int nState)
{

	CPtrArray *pcpaTreeRoots = m_pParent -> GetTreeRoots();

	int nRoots = (int) pcpaTreeRoots -> GetSize( );

	HTREEITEM hItem;
	for (int i = 0; i < nRoots; i++)
	{
		hItem =
			reinterpret_cast<HTREEITEM>(pcpaTreeRoots -> GetAt(i));
		if (hItem)
		{
			ExtendedSelectionFromRoot(hItem,cpaExtendedSelection,nState);
		}
	}
	return (int) cpaExtendedSelection.GetSize( );

}

// ***************************************************************************
//
// CClassTree::ExtendedSelectionFromRoot
//
// Description:
//	  Return a CPtrArray which contains the class names of classes selected
//	  via the extended selection mechanism with state (either selected or not
//	  selected.  For a branch.
//
// Parameters:
//	  HTREEITEM hItem					Branch root to get selection from.
//	  CPtrArray &cpaExtendedSelection	The items with state.
//	  int nState						Selected or not selected
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::ExtendedSelectionFromRoot
(HTREEITEM hItem, CPtrArray &cpaExtendedSelection, int nState)
{

	UINT nStateMask = TVIS_STATEIMAGEMASK;
	UINT uState =
			GetItemState( hItem, nStateMask );

	if (uState & INDEXTOSTATEIMAGEMASK (nState))
	{
		IWbemClassObject *pItem = (IWbemClassObject*) GetItemData(hItem) ;
		if (pItem)
		{
			CString csClass = _T("__Path");
			csClass = ::GetProperty(pItem, &csClass);
			CString *pcsClass = new CString(csClass);
			cpaExtendedSelection.Add
				(reinterpret_cast<void *>(pcsClass));
		}
	}

	// now rip thru the children
	if (!ItemHasChildren (hItem))
	{
		return ;
	}

	HTREEITEM hChild = GetChildItem(hItem);

	while (hChild)
	{
		ExtendedSelectionFromRoot(hChild, cpaExtendedSelection,nState);
		hChild = GetNextSiblingItem(hChild);
	}

	return;
}

// ***************************************************************************
//
// CClassTree::ClearExtendedSelection
//
// Description:
//	  Clears extended selection for the whole tree.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::ClearExtendedSelection()
{

	CPtrArray *pcpaTreeRoots = m_pParent -> GetTreeRoots();

	int nRoots = (int) pcpaTreeRoots -> GetSize( );

	HTREEITEM hItem;
	for (int i = 0; i < nRoots; i++)
	{
		hItem =
			reinterpret_cast<HTREEITEM>(pcpaTreeRoots -> GetAt(i));
		if (hItem)
		{
			ClearExtendedSelectionFromRoot(hItem);
		}
	}
	m_pParent -> InvalidateControl();
}

// ***************************************************************************
//
// CClassTree::ClearExtendedSelection
//
// Description:
//	  Clears extended selection for a branch.
//
// Parameters:
//	  HTREEITEM hItem					Branch root to clear selection from.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::ClearExtendedSelectionFromRoot
(HTREEITEM hItem)
{
	UINT nStateMask = TVIS_STATEIMAGEMASK;
	UINT uState =
			GetItemState( hItem, nStateMask );

	if (uState & INDEXTOSTATEIMAGEMASK (2))
	{
		 SetItemState(hItem, INDEXTOSTATEIMAGEMASK (1), TVIS_STATEIMAGEMASK);
	}

	// now rip thru the children

	if (!ItemHasChildren (hItem))
	{
		return ;
	}

	HTREEITEM hChild = GetChildItem(hItem);

	while (hChild)
	{
		ClearExtendedSelectionFromRoot(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	return;
}

// ***************************************************************************
//
// CClassTree::SetExtendedSelection
//
// Description:
//	  Sets extended selection for the whole tree.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::SetExtendedSelection()
{

	CPtrArray *pcpaTreeRoots = m_pParent -> GetTreeRoots();

	int nRoots = (int) pcpaTreeRoots -> GetSize( );

	HTREEITEM hItem;
	for (int i = 0; i < nRoots; i++)
	{
		hItem =
			reinterpret_cast<HTREEITEM>(pcpaTreeRoots -> GetAt(i));
		if (hItem)
		{
			SetExtendedSelectionFromRoot(hItem);
		}
	}
	m_pParent -> InvalidateControl();
}

// ***************************************************************************
//
// CClassTree::SetExtendedSelectionFromRoot
//
// Description:
//	  Sets extended selection for a branch.
//
// Parameters:
//	  HTREEITEM hItem					Branch root to set selection for.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassTree::SetExtendedSelectionFromRoot
(HTREEITEM hItem)
{

	SetItemState(hItem, INDEXTOSTATEIMAGEMASK (2), TVIS_STATEIMAGEMASK);

	// now rip thru the children

	if (!ItemHasChildren (hItem))
	{
		return ;
	}

	HTREEITEM hChild = GetChildItem(hItem);

	while (hChild)
	{
		SetExtendedSelectionFromRoot(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	return;
}

// ***************************************************************************
//
//  CClassTree::OnItemexpanded
//
//	Description:
//		Invoked to let the tree know one of its tree items has been
//		expanded or contracted.
//
//	Parameters:
//		NMHDR *pNMHDR				Notification message structure.
//		LRESULT *pResult			Return value ignored.
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnItemexpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	*pResult = 0;
}

// ***************************************************************************
//
//  CClassTree::FindObjectinChildren
//
//	Description:
//		Finds the tree item in a branch that represents a class object
//
//	Parameters:
//		HTREEITEM hItem					Root of branch
//		IWbemClassObject *pClassObject	Class to search for.
//
//	Returns:
// 		HTREEITEM						Tree item; or NULL if not found.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
HTREEITEM CClassTree::FindObjectinChildren
(HTREEITEM hItem, IWbemClassObject *pClassObject)
{
	HTREEITEM hChild = GetChildItem(hItem);
	if (!hChild)
	{
		return NULL;
	}

	IWbemClassObject *pChild;

	while (hChild)
	{
		pChild =
			reinterpret_cast<IWbemClassObject *>
			(GetItemData(hChild));
		if (ClassIdentity(pClassObject,pChild))
		{
			return hChild;
		}

		hChild = GetNextSiblingItem(hChild);
	}

	return NULL;

}

// ***************************************************************************
//
//  CClassTree::OnEndlabeledit
//
//	Description:
//		Invoked to let the tree know one of its tree item labels
//		has been changed.  Semantics for us is a class rename.
//
//	Parameters:
//		NMHDR *pNMHDR				Notification message structure.
//		LRESULT *pResult			Set to FALSE to prevent the label from
//									changing; otherwise non-zero.
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult)
{
	TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
	HTREEITEM hItem = pTVDispInfo -> item.hItem;

	UpdateItemData(hItem);

	IWbemClassObject *pimcoEdit =
		reinterpret_cast<IWbemClassObject *>(GetItemData(hItem));
	CString csClass = _T("__Class");
	CString csClassName = pimcoEdit ? ::GetProperty
		(pimcoEdit, &csClass) : "";

	CString csNew = pTVDispInfo -> item.pszText;

	if (csNew.GetLength() == 0)
	{
		*pResult = 0;
		SelectItem(hItem);      // 1-29-99
		SetFocus();				// 1-29-99
		return;
	}

	// Check to see if the class already exists
	IWbemClassObject *pimcoMaybe = NULL;
	BSTR bstrTemp = csNew.AllocSysString();

	SCODE sc = m_pParent -> GetServices() ->
		GetObject(bstrTemp, 0,  NULL, &pimcoMaybe, NULL);

	::SysFreeString(bstrTemp);

	// Class already exists so cannot rename.
	if (pimcoMaybe && sc == S_OK)
	{
		CString csUserMsg =
			_T("An error occured renaming a class: ");
		csUserMsg +=
					_T("The class already exists.");
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 11);
		pimcoMaybe -> Release();
		*pResult = 0;
		SelectItem(hItem);      // 1-29-99
		SetFocus();				// 1-29-99
		return;
	}

	// Must delete pimcoEdit after its children have been
	// reparented.
	IWbemClassObject *pimcoNew =
		RenameAClass
		(m_pParent -> GetServices(), pimcoEdit, &csNew, FALSE);
	if (!pimcoNew)
	{
		CString csUserMsg =
			_T("Cannot rename class: ") + csClassName;
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		SelectItem(hItem);      // 1-29-99
		SetFocus();				// 1-29-99
		*pResult = 0;			// 1-29-99
		return;
	}

	csClass = GetIWbemFullPath(m_pParent->GetServices(),pimcoNew);
	COleVariant covClass(csClass);
	if (m_pParent->m_bReadySignal)
	{
		m_pParent -> FireEditExistingClass(covClass);
	}
#ifdef _DEBUG
		afxDump <<"CBanner::OnEndlabeledit: 	m_pParent -> FireEditExistingClass(covNewClass); \n";
		afxDump << "     " << csClass << "\n";
#endif



	pimcoEdit->Release();
	SetItemData(hItem,(LPARAM)(pimcoNew));


	HTREEITEM hChild = GetChildItem(hItem);
	while (hChild)
	{
		IWbemClassObject *pimcoChild
			= reinterpret_cast<IWbemClassObject *>(GetItemData(hChild));
		ReparentAClass(m_pParent -> GetServices(),pimcoNew, pimcoChild);

		hChild = GetNextSiblingItem(hChild);
	}


	BOOL bReturn = DeleteAClass
		(m_pParent -> GetServices(), &csClassName );

	SelectItem(hItem);      // 1-29-99
	SetFocus();				// 1-29-99

	*pResult = 1;
}

void CClassTree::UpdateItemData(HTREEITEM hItem)
{
	IWbemClassObject *pimcoItemData =
		reinterpret_cast<IWbemClassObject *>(GetItemData(hItem));

	if (!pimcoItemData)
	{
		return;
	}

	CString csClass = GetIWbemClass(pimcoItemData);

	pimcoItemData->Release();
	pimcoItemData = NULL;

	pimcoItemData = GetClassObject
		(m_pParent -> GetServices(),&csClass,FALSE);

	if (!pimcoItemData)
	{
		return;
	}

	SetItemData(hItem,(LPARAM)(pimcoItemData));

}


// ***************************************************************************
//
//  CClassTree::OnBeginlabeledit
//
//	Description:
//		Invoked to let the tree know one of its tree item labels
//		is being changed.  Semantics for us is a class rename.
//
//	Parameters:
//		NMHDR *pNMHDR				Notification message structure.
//		LRESULT *pResult			Set to non-zero to prevent the label from
//									being edited; otherwise zero.
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::OnBeginlabeledit(NMHDR* pNMHDR, LRESULT* pResult)
{

	HTREEITEM hSelection = GetSelectedItem( );

	if (hSelection)
	{
		CString csSelection = GetSelectionPath(hSelection);

		BOOL bCanChangeSelection = m_pParent->QueryCanChangeSelection(csSelection);

		if (!bCanChangeSelection)
		{
			SetFocus();
			*pResult = 1;
			return;
		}
	}


	TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
	HTREEITEM hItem = pTVDispInfo -> item.hItem;
	IWbemClassObject *pimcoEdit =
			reinterpret_cast<IWbemClassObject *>(GetItemData(hItem));


	if (!pimcoEdit)
	{
		*pResult = 1;
		return;
	}

	CString csClass = _T("__Class");
	m_csSelection = ::GetProperty(pimcoEdit, &csClass);

	if (m_csSelection[0] == '_' &&  m_csSelection[1] == '_')
	{
		*pResult = 1;
		CString csPrompt =
				_T("You cannot rename a system class.");
		int nReturn =
				m_pParent -> MessageBox
				(
				csPrompt,
				_T("Class Rename Error"),
				MB_OK  | 	 MB_ICONSTOP | MB_DEFBUTTON1 |
				MB_APPLMODAL);
		SetFocus();
		return;
	}

	if (ItemHasChildren(hItem))
	{
		*pResult = 1;
		CString csPrompt =
				_T("You cannot rename a class which has subclasses.");
		int nReturn =
				m_pParent -> MessageBox
				(
				csPrompt,
				_T("Class Rename Error"),
				MB_OK  | 	 MB_ICONSTOP | MB_DEFBUTTON1 |
				MB_APPLMODAL);
		SetFocus();
		return;
	}
	else
	{


		BOOL bSubClasses =
			HasSubclasses
			(m_pParent->GetServices(), pimcoEdit,m_pParent->m_csNameSpace);
		if (bSubClasses)
		{
			*pResult = 1;
			return;
		}
		else
		{
			BOOL bReturn;
			CString csQual = _T("dynamic");
			SCODE sc =
				GetAttribBool
				(pimcoEdit,NULL, &csQual,bReturn);
			CString csProvider;
			CString csPrompt;
			if (bReturn)
			{
				csQual = _T("provider");
				sc =
					GetAttribBSTR
						(pimcoEdit,NULL, &csQual, csProvider);
				csPrompt =
					_T("The dynamic provider for this class \"");
				csPrompt += csProvider + _T("\"");
				csPrompt += _T(" may need to be updated.  Do you want to continue renaming the class?");
			}
			else
			{

				csPrompt =
					_T("If this class has static instances renaming the class will result in the instances being deleted.  Do you want to continue renaming the class?");
			}
			int nReturn =
				m_pParent -> MessageBox
				(
				csPrompt,
				_T("Class Rename Warning"),
				MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
				MB_APPLMODAL);
			SetFocus();
			if (nReturn == IDYES)
			{
				*pResult = 0;
			}
			else
			{
				*pResult = 1;
			}
		}
	}
}

// ***************************************************************************
//
//  CClassTree::FindAndOpenObject
//
//	Description:
//		Find an object in the tree or grow the tree to object.
//
//	Parameters:
//		IWbemClassObject *pClass		Class object;
//
//	Returns:
// 		HTREEITEM					Tree item or NULL.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
HTREEITEM CClassTree::FindAndOpenObject(IWbemClassObject *pClass)
{
	CString csClass = _T("__Class");
	csClass = ::GetProperty(pClass,&csClass);
	CStringArray *pcsaPath = PathFromRoot (pClass);
	HTREEITEM hRoot;
	HTREEITEM hItem = NULL;
	if (pcsaPath->GetSize() > 1)
	{
		HTREEITEM hChild;
		hChild = hRoot =
			m_pParent->FindObjectinClassRoots
				(&pcsaPath->GetAt(0));
		for (int i = 1; i < pcsaPath->GetSize(); i++)
		{
			IWbemClassObject *pObject = NULL;
			IWbemClassObject *pErrorObject = NULL;
			BSTR bstrTemp = pcsaPath->GetAt(i).AllocSysString();
			SCODE sc =
				m_pParent->GetServices() -> GetObject
					(bstrTemp,0,
					NULL, &pObject, NULL);
			::SysFreeString(bstrTemp);
			if (sc == S_OK)
			{
				hChild =
					FindObjectinChildren
					(hRoot, pObject);
				if (hChild)
				{
					hRoot = hChild;
				}
				else
				{
					Expand(hRoot,TVE_EXPAND);
					hRoot = hChild =
					   FindObjectinChildren
						(hRoot,  pObject);

				}
				ReleaseErrorObject(pErrorObject);
				pObject ->Release();
			}
			else
			{
				ErrorMsg
						(NULL, sc, pErrorObject, TRUE, NULL, __FILE__, __LINE__ - 40);
				ReleaseErrorObject(pErrorObject);
			}
		}
		hItem = hChild;
	}
	else
	{
		 hRoot =
			m_pParent->FindObjectinClassRoots
				(&csClass);
		 hItem = hRoot;
	}


	delete pcsaPath;
	if (hItem)
	{
		SelectSetFirstVisible(hItem);
		SelectItem(hItem);
		SetFocus();
		Expand(hItem,TVE_EXPAND);
	}

	return hItem;

}






BOOL CClassTree::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point)
{
	return TRUE;
}

DROPEFFECT CClassTree::OnDropEx(COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT dropEffectList, CPoint point)
{
	return DROPEFFECT_NONE;
}

DROPEFFECT CClassTree::OnDragEnter(COleDataObject* pDataObject, DWORD grfKeyState, CPoint point)
{
	return DROPEFFECT_NONE;
}

DROPEFFECT CClassTree::OnDragOver(COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point)
{
	return DROPEFFECT_NONE;
}

DROPEFFECT CClassTree::OnDragScroll(DWORD grfKeyState, CPoint point)
{
	return DROPEFFECT_NONE;
}

void CClassTree::OnDragLeave()
{
}

// ***************************************************************************
//
//  CClassTree::IsChildNodeOf
//
//	Description:
//		Predicate to see if a tree item is a parent or grand ... parent
//		of a another tree item.
//
//	Parameters:
//		HTREEITEM hitemChild			Item to test.
//		HTREEITEM hitemSuspectedParent	Maybe a parent.
//
//	Returns:
// 		BOOL							TRUE if a child; otherwise FALSE
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CClassTree::IsChildNodeOf
(HTREEITEM hitemChild, HTREEITEM hitemSuspectedParent)
{
	do
	{
		if (hitemChild == hitemSuspectedParent)
			break;
	}
	while ((hitemChild = GetParentItem(hitemChild)) != NULL);

	return (hitemChild != NULL);
}

// ***************************************************************************
//
//  CClassTree::DeleteBranch
//
//	Description:
//		Delete a branch of the tree and conditionally release the
//		class objects assoiciated with the tree items.
//
//	Parameters:
//		HTREEITEM hItem			Root of branch to transfer.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::DeleteBranch(HTREEITEM &hItem)
{

	HTREEITEM hParent = GetParentItem(hItem);
	IWbemClassObject *pClassObject;

	pClassObject
			= reinterpret_cast<IWbemClassObject *>
			(GetItemData( hItem ));

	if (!hParent) // item is a root
	{
		if (pClassObject)
		{
			m_pParent -> RemoveObjectFromClassRoots(pClassObject);
		}
		m_pParent -> RemoveItemFromTreeItemRoots(hItem);

	}

	if (pClassObject)
	{
		pClassObject -> Release();
	}

	if (!ItemHasChildren (hItem))
	{
		DeleteItem(hItem);
		HTREEITEM hChild = NULL;
		hChild = GetChildItem(hParent);

		if (!hChild)
		{
			TV_INSERTSTRUCT		tvstruct;
			tvstruct.item.hItem = hParent;
			tvstruct.item.mask = TVIF_CHILDREN | TVIF_STATE;
			tvstruct.item.stateMask = TVIS_EXPANDEDONCE;
			tvstruct.item.state = TVIS_EXPANDEDONCE;
			tvstruct.item.cChildren = 0;

			SetItem(&tvstruct.item);
			EnsureVisible (hParent); // 10-26-96 force parent to update

		}
		hItem = 0;
		return;
	}


	HTREEITEM hChild = GetChildItem(hItem);

	while (hChild)
	{
		DeleteBranch(hChild);
		if (hChild)
			hChild = GetNextSiblingItem(hChild);
	}

	DeleteItem(hItem);

	hChild = NULL;
	hChild = GetChildItem(hParent);

	if (!hChild)
	{
		TV_INSERTSTRUCT		tvstruct;
		tvstruct.item.hItem = hParent;
		tvstruct.item.mask = TVIF_CHILDREN | TVIF_STATE;
		tvstruct.item.stateMask = TVIS_EXPANDEDONCE;
		tvstruct.item.state = TVIS_EXPANDEDONCE;
		tvstruct.item.cChildren = 0;

		SetItem(&tvstruct.item);
		EnsureVisible (hParent); // 10-26-96 force parent to update

	}

	hItem = 0;

}

// ***************************************************************************
//
//  CClassTree::OnScroll
//
//	Description:
//		Scroll the window by a line only.  Called only by the drop target
//		when it detects that a drag operation is in the scrolling region.
//
//	Parameters:
//		UINT nScrollCode		Scrolling request.
//		UINT nPos				Not used.
//		BOOL bDoScroll			If TRUE do the scroll; otherwise just
//								return whither or not a scroll could occur.
//
//	Returns:
// 		BOOL					TRUE if could scroll; otherwise FALSE.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CClassTree::OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll)
{
	// Read the docs on CView::OnScroll to understand the semantics of
	// bDoScroll.

	// calc new x position
	int x = GetScrollPos(SB_HORZ);

	switch (LOBYTE(nScrollCode))
	{
	case SB_LINEUP:
		x = -1;
		break;
	case SB_LINEDOWN:
		x = 1;
		break;
	}

	// calc new y position
	int y = GetScrollPos(SB_VERT);

	switch (HIBYTE(nScrollCode))
	{
	case SB_LINEUP:
		y = -1;
		break;
	case SB_LINEDOWN:
		y =  1;
		break;
	}

	BOOL bResult = OnScrollBy(CSize(x, y ), bDoScroll);


	return bResult;
}

//***************************************************************************
//
// CClassTree::OnScrollBy
//
// Purpose:
//
//			This is work in progress.
//
//***************************************************************************
// ***************************************************************************
//
//  CClassTree::OnScrollBy
//
//	Description:
//		Actually scrolls the window if bDoScroll it TRUE.  If bDSoScroll
//		is FALSE test to see if a scroll could be done.
//
//	Parameters:
//		CSize sizeScroll		Number of pixels scrolled horizontally
//								and vertically.
//		BOOL bDoScroll			If TRUE do the scroll; otherwise just
//								return whither or not a scroll could occur.
//
//	Returns:
// 		BOOL					TRUE if could scroll; otherwise FALSE.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CClassTree::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
	int nScrollH = sizeScroll.cx;
	int nScrollV = sizeScroll.cy;
	int xOrig;
	int yOrig;
	int x = sizeScroll.cx;
	int y = sizeScroll.cy;

	CRect rControl;
	GetClientRect(&rControl);
	CDC *pdc = GetDC( );
	pdc -> LPtoDP(&rControl);
	ClientToScreen(&rControl);
	ReleaseDC(pdc);


	SCROLLINFO siHInfo;
	SCROLLINFO siVInfo;
	siHInfo.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;
	siVInfo.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;
	BOOL bReturn;

	bReturn = GetScrollInfo(SB_HORZ, &siHInfo,  SIF_ALL);
	bReturn = GetScrollInfo(SB_VERT, &siVInfo ,SIF_ALL);

	long lStyle = GetWindowLong(GetSafeHwnd(), GWL_STYLE);

	BOOL bHScroll = lStyle & WS_HSCROLL;
	BOOL bVScroll = lStyle & WS_VSCROLL;

	// don't scroll if there is no valid scroll range (ie. no scroll bar)
	if (!bVScroll)
	{
		// vertical scroll bar not enabled
		sizeScroll.cy = 0;
	}

	if (!bHScroll)
	{
		// horizontal scroll bar not enabled
		sizeScroll.cx = 0;
	}

	// adjust current x position
	xOrig = GetScrollPos(SB_HORZ);
	int xMax = GetScrollLimit(SB_HORZ);
	x += xOrig;
	if (x < 0)
		x = 0;
	else if (x > xMax)
		x = xMax;

	// adjust current y position
	yOrig = GetScrollPos(SB_VERT);
	int yMax = GetScrollLimit(SB_VERT);
	y += yOrig;
	if (y < 0)
		y = 0;
	else if (y > yMax)
		y = yMax;

	//did anything change?
	if (x == xOrig && y == yOrig)
		return FALSE;

	if (bDoScroll)
	{
		bReturn;


		WPARAM wParam;
		LPARAM lParam;

		wParam =  MAKEWPARAM((nScrollV < 0) ? SB_LINEUP : SB_LINEDOWN, yOrig);
		lParam = NULL;
		this -> SendMessage(WM_VSCROLL, wParam, lParam);
		wParam =  MAKEWPARAM((nScrollH < 0) ? SB_LINEUP : SB_LINEDOWN, xOrig);
		lParam = NULL;
		this -> SendMessage(WM_HSCROLL, wParam, lParam);

		bReturn = ::UpdateWindow(GetSafeHwnd());

		bReturn = GetScrollInfo(SB_VERT, &siVInfo ,SIF_ALL);
		m_pParent -> InvalidateControl();
		m_pParent -> SetModifiedFlag( TRUE );
	}
	return TRUE;
}

// ***************************************************************************
//
//  CClassTree::ReleaseClassObjects
//
//	Description:
//		Release (in OLE sense) the IWbemClassobject instances.
//
//	Parameters:
//		HTREEITEM hItem			Tree root to start releasing from.
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassTree::ReleaseClassObjects(HTREEITEM hItem)
{
	IWbemClassObject *pClassObject
		= reinterpret_cast<IWbemClassObject *>(GetItemData( hItem ));

	if (pClassObject)
	{
		pClassObject -> Release();
		SetItemData(hItem,NULL);
	}

	if (!ItemHasChildren (hItem))
	{
		return;
	}

	HTREEITEM hChild = GetChildItem(hItem);
	while (hChild)
	{
		ReleaseClassObjects(hChild);
		hChild = GetNextSiblingItem(hChild);
	}
}

LRESULT CClassTree::SelectTreeItemOnFocus(WPARAM, LPARAM)
{
	if (m_nSpinFocus < 1)
	{
		m_nSpinFocus++;
		HTREEITEM hItem =	GetSelectedItem();
		if (hItem)
		{
			m_nSelectedItem = hItem;
		}
		PostMessage(SELECTITEMONFOCUS,0,0);
		return 0;
	}


	HTREEITEM hSelectedItem = GetSelectedItem();

	if (hSelectedItem && m_nSelectedItem && GetCount() != -1)
	{
		SelectItem(m_nSelectedItem);
		SetFocus();
		IWbemClassObject *pItem =  (IWbemClassObject*)GetItemData(m_nSelectedItem);
		if (pItem)
		{
			if (m_pParent->m_bReadySignal)
			{
				COleVariant covClass;
				CString csItem = GetIWbemFullPath(m_pParent->GetServices(),pItem);
				covClass = csItem;
				m_pParent -> FireEditExistingClass(covClass);
#ifdef _DEBUG
				afxDump <<"CClassTree::SelectTreeItemOnFocus: 	m_pParent -> FireEditExistingClass(covClass); \n";
				afxDump << "     " << csItem << "\n";
#endif
			}


		}
	}
	m_pParent->InvalidateControl();
	m_pParent -> PostMessage(SETFOCUSTREE,0,0);
	return 0;
}

LRESULT CClassTree::SelectTreeItem(WPARAM, LPARAM)
{
	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;

	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	HTREEITEM hItem = GetSelectedItem();

	if (!hItem)
	{
		return 0;
	}

	m_bUseItem = TRUE;
	m_hItemToUse = hItem;
	CPoint point(0,0);

	ContinueProcessSelection(0, point);

	return 0;
}

void CClassTree::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{

	TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;

	switch (pTVKeyDown->wVKey)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_UP:
	case VK_DOWN:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
		if (m_uiTimer)
		{
			KillTimer( m_uiTimer );
			m_uiTimer = 0;
		}
		m_uiTimer = (UINT) SetTimer(KBSelectionTimer, 250, SelectItemAfterDelay);
		m_bKeyDown = TRUE;
		m_bMouseDown = FALSE;
		break;
	default:
		m_bKeyDown = FALSE;
		m_bMouseDown = TRUE;
		break;

	};
	// TODO: Add your control notification handler code here

	*pResult = 0;
}

void CClassTree::OnKillfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
#ifdef _DEBUG
	afxDump << _T("CClassTree::OnKillfocus\n");
#endif
	m_pParent->m_bRestoreFocusToTree = TRUE;
	*pResult = 0;
}

void CClassTree::OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here

#ifdef _DEBUG
	afxDump << _T("Before COleControl::OnActivateInPlace in CClassTree::OnSetFocus\n");
#endif
	// TODO: Add your message handler code here
	m_pParent->OnActivateInPlace(TRUE,NULL);
#ifdef _DEBUG
	afxDump << _T("After COleControl::OnActivateInPlace in CClassTree::OnSetFocus\n");
#endif
	m_pParent->m_bRestoreFocusToTree = TRUE;
	*pResult = 0;
}



void CClassTree::OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	m_pParent -> OnActivateInPlace(TRUE,NULL);

	HTREEITEM hOld = pNMTreeView->itemOld.hItem;

	CString csSelection = GetSelectionPath(hOld);

	BOOL bCanChangeSelection = m_pParent->QueryCanChangeSelection(csSelection);

	if (!bCanChangeSelection)
	{
		SetFocus();
		*pResult = TRUE;
		return;
	}

	*pResult = 0;
	UINT uInterval = GetDoubleClickTime();
	if (uInterval > 0)
	{
		if (m_uiSelectionTimer)
		{
			KillTimer( m_uiSelectionTimer );
			m_uiSelectionTimer = 0;
		}
		gpTreeTmp = this;
		m_lSelection = 1;
		m_uiSelectionTimer =(UINT) ::SetTimer
			(this->m_hWnd,
			ExpansionOrSelectionTimer,
			/*uInterval + */50,
			ExpansionOrSelection);

		NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
		HTREEITEM hItem = pnmtv->itemNew.hItem;

		m_bUseItem = TRUE;
		m_hItemToUse = hItem;

	}

	*pResult = 0;
}

/*	EOF:  CClassTree.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\cclasstree.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CClassTree.h
//
// Description:
//	This file declares the CClassTree class which is a part of the Class 
//	Navigator OCX, it is a subclass of the Microsoft CTreeCtrl common 
//  control and performs the following functions:
//		a.  Insertion of individual classes
//		b.  Allows classes to be "expanded" by going out to the database
//			to get its subclasses
//		c.  Allows classes to be renamed.
//		d.  Supports operations to add and delete tree branches.
//		e.	Supports OLE drag and drop (disabled for ALPHA)
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#ifndef _CClassTree_H_
#define _CClassTree_H_

#include "SchemaInfo.h"

//****************************************************************************
//
// CLASS:  CClassTree
//
// Description:
//	  This class is a subclass of the Mocrosoft CTreeCtrl common control.  It
//	  specializes the common control to interact with the HMM database and 
//	  display HMM class data.
//
// Public members:
//	
//	  CClassTree		Public constructor.
//	  GetSelection		Returns the currently selected tree item.	  
//
//============================================================================
//
// CClassTree::CClassTree
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CClassTree::GetSelection
//
// Description:
//	  This member function returns the currently selected tree item.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  HTREEITEM		The tree control item currently selected.
//
//****************************************************************************

struct IWbemClassObject;
class CClassNavCtrl;
class CTreeDropTarget;
class CBanner;

class CClassTree : public CTreeCtrl
{
public:
	CClassTree();
	CString GetSelection() {return m_csSelection;}
	void ContinueProcessSelection(UINT nFlags, CPoint point);
	long m_lSelection;
	UINT m_uiSelectionTimer;

	CSchemaInfo m_schema;

protected:
	CClassNavCtrl *m_pParent;
	CString m_csSelection;

	UINT m_uTreeCF;
	BOOL m_bInDrag;
	DROPEFFECT m_prevDropEffect;
	CLIPFORMAT m_cfObjectDescriptor;
	BOOL m_bDropTargetRegistered;
	BOOL m_bDragAndDropState;
	CSize m_dragSize;
	CPoint m_dragPoint;
	HTREEITEM m_htiDroppedParent;
	HTREEITEM m_htiDropped;
	IWbemClassObject *m_pimcoDroppedParent;
	IWbemClassObject *m_pimcoDropped;

	LONG m_lClickTime;

	BOOL m_bDeleting;

	// Context Menu
	CMenu m_cmContext;

	BOOL IsChildNodeOf
		(HTREEITEM hitemChild, HTREEITEM hitemSuspectedParent);

	void OnItemExpanding(NMHDR *pNMHDR, LRESULT *pResult);

	HTREEITEM  InsertTreeItem 
		(	HTREEITEM hParent, 
			LPARAM lparam, 
			int iBitmap, 
			int iSelectedBitmap,
			LPCTSTR pszText,  
			BOOL bBold = FALSE,
			BOOL bChildren = FALSE);

	int ExtendedSelectionFromTree(CPtrArray &cpaExtendedSelection,int nState = 2);
	void ExtendedSelectionFromRoot
		(HTREEITEM hItem, CPtrArray &cpaExtendedSelection, int nState = 2);
	void  ClearExtendedSelectionFromRoot (HTREEITEM hItem);
	void  SetExtendedSelectionFromRoot (HTREEITEM hItem);
	CString GetSelectionPath(HTREEITEM hItem = NULL);


	// OLE Drag and Drop


	virtual BOOL OnDrop
		(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT  OnDropEx
		(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, DROPEFFECT dropEffectList, CPoint point);
	virtual DROPEFFECT OnDragEnter
		(COleDataObject* pDataObject, DWORD grfKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver
		(COleDataObject* pDataObject, DWORD grfKeyState, CPoint point);
	virtual DROPEFFECT OnDragScroll
		(DWORD grfKeyState, CPoint point);
	virtual void OnDragLeave();


	BOOL  PreCreateWindow(CREATESTRUCT& cs);

	HTREEITEM AddNewClass(HTREEITEM hParent, IWbemClassObject *imcoNew);
	void RefreshIcons(HTREEITEM hItem);

	HTREEITEM AddTreeObject2(HTREEITEM hParent, CSchemaInfo::CClassInfo &info);

	void InitTreeState (CClassNavCtrl *pParent);
	void ReleaseClassObjects(HTREEITEM hItem);

	SAFEARRAY *GetExtendedSelection(int nState = 2);
	int NumExtendedSelection(int nState = 2);
	void ClearExtendedSelection();
	void SetExtendedSelection();

	HTREEITEM FindObjectinChildren
		(HTREEITEM hItem, IWbemClassObject *pClassObject);

	HTREEITEM FindAndOpenObject(IWbemClassObject *pClass) ;

	void SetDeleting(BOOL bDeleting) {m_bDeleting = bDeleting;}

	void DeleteBranch(HTREEITEM &hItem);

	BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll);
	BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll);
	 
	UINT m_uiTimer;
	BOOL m_bMouseDown;
	BOOL m_bKeyDown;
	BOOL m_bUseItem;
	HTREEITEM m_hItemToUse;

	BOOL m_bFirstSetFocus;
	int m_nSpinFocus;
	HTREEITEM m_nSelectedItem;

	void UpdateItemData(HTREEITEM hItem);

protected:
    //{{AFX_MSG(CClassTree)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnItemexpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBeginlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKillfocus(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	afx_msg LRESULT SelectTreeItem(WPARAM, LPARAM);
	afx_msg LRESULT SelectTreeItemOnFocus(WPARAM, LPARAM);
    DECLARE_MESSAGE_MAP()

private:
	friend class	CBanner;
	friend class CTreeDropTarget;
	friend class CClassNavCtrl;
};

#endif _CClassTree_H_

/*	EOF:  CClassTree.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\ccontainedtoolbar.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file implements the CContainedToolBar class which is a part of the Class
//	Navigator OCX, it is a subclass of the Microsoft CToolBar
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "afxpriv.h"
#include "AFXCONV.H"
#include "resource.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "CContainedToolBar.h"
#include "AddDialog.h"
#include "CClassTree.h"
//#include "EditInput.h"
//#include "NameSpace.h"
#include "Banner.h"
#include "ClassNavCtl.h"

BEGIN_MESSAGE_MAP(CContainedToolBar,CToolBar)
	//{{AFX_MSG_MAP(CContainedToolBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CSize CContainedToolBar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	int nButtons = rToolBarCtrl.GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		rToolBarCtrl.GetItemRect(0, &rcButtons);
		rToolBarCtrl.GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}

// ***************************************************************************
//
// CContainedToolBar::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CContainedToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style = lpCreateStruct->style |
								CBRS_TOOLTIPS | CBRS_FLYBY;
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		rToolBarCtrl.SetToolTips(&m_ttip );


	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnav.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ClassNav.cpp : Implementation of CClassNavApp and DLL registration.

#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CClassNavApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xc587b670, 0x103, 0x11d0, { 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xc587b673, 0x103, 0x11d0,
           { 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CClassNavApp::InitInstance - DLL initialization

char *m_pszHelpPath = NULL;


BOOL CClassNavApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CClassNavApp::ExitInstance - DLL termination

int CClassNavApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\ccontainedtoolbar.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file declares the CContainedToolBar class which is a part of the Class 
//	Navigator OCX, it is a subclass of the Microsoft CToolBar 
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CContainedToolBar
//
// Description:
//	  This class is a subclass of the Microsoft CToolBar control.  It
//	  provides a member function to calculate its size and provides a tooltip.
//
// Public members:
//	
//	  CContainedToolBar	Public constructor.
//	  GetToolTip		Returns the tooltip control.
//	  SetParent			Sets the classes logicl parent.
//	  GetToolBarSize	Returns the size of the tool bar. 
//
//============================================================================
//
// CContainedToolBar::CContainedToolBar
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CContainedToolBar::GetToolTip
//
// Description:
//	  This member function returns a reference to the tooltip control.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CToolTipCtrl &	Reference to the tooltip control.
//
//============================================================================
//
// CContainedToolBar::SetParent
//
// Description:
//	  This member function sets the logical parent.
//
// Parameters:
//	  CClassNavCtrl *pParent	Logical parent.
//
// Returns:
// 	  VOID
//
//============================================================================
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
//****************************************************************************	 

#ifndef _CContainedToolBar_H_
#define _CContainedToolBar_H_

class 	CClassNavCtrl;

class CContainedToolBar : public CToolBar
{
public:
	CContainedToolBar() {m_pParent = NULL;}
	void SetParent(CClassNavCtrl *pParent) {m_pParent = pParent;}
	CSize GetToolBarSize();
	CToolTipCtrl &GetToolTip() {return m_ttip;}
protected:
	CClassNavCtrl *m_pParent;
	CToolTipCtrl m_ttip;
    //{{AFX_MSG(CContainedToolBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnav.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ClassNav.h : main header file for CLASSNAV.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CClassNavApp : See ClassNav.cpp for implementation.

class CClassNavApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	~CClassNavApp() {m_pszHelpFilePath = NULL;}
protected:
	const char *m_pszHelpPath;
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavctl.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: ClassNavCtl.cpp
//
// Description:
//	This file implements the CClassNavCtrl ActiveX control class.
//	The CClassNavCtrl class is a part of the Class Explorer OCX, it
//  is a subclass of the Microsoft COleControl class and performs
//	the following functions:
//		a.  Displays the class hierarchy
//		b.  Allows classes to be added and deleted
//		c.  Searches for classes in the tree
//		d.  Implements automation properties, methods and events.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

// ===========================================================================
//
//	Includes
//
// ===========================================================================
#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "ClassSearch.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "ClassNavPpg.h"
#include "ProgDlg.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"
#include "ClassNavNSEntry.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "logindlg.h"
#include "SchemaInfo.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ===========================================================================
//
//	Externs
//
// ===========================================================================
extern CClassNavApp theApp;

// ===========================================================================
//
//	Dynamic creation
//
// ===========================================================================
IMPLEMENT_DYNCREATE(CClassNavCtrl, COleControl)


// ===========================================================================
//
//	Message map
//
// ===========================================================================
BEGIN_MESSAGE_MAP(CClassNavCtrl, COleControl)
	//{{AFX_MSG_MAP(CClassNavCtrl)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_COMMAND(ID_CLEAREXTENDEDSELECTION, OnClearextendedselection)
	ON_UPDATE_COMMAND_UI(ID_CLEAREXTENDEDSELECTION, OnUpdateClearextendedselection)
	ON_COMMAND(ID_POPUP_SEARCHFORCLASS, OnPopupSearchforclass)
	ON_UPDATE_COMMAND_UI(ID_POPUP_SEARCHFORCLASS, OnUpdatePopupSearchforclass)
	ON_COMMAND(ID_POPUP_SELECTALL, OnPopupSelectall)
	ON_UPDATE_COMMAND_UI(ID_POPUP_SELECTALL, OnUpdatePopupSelectall)
	ON_WM_DESTROY()
	ON_COMMAND(ID_MENUITEMREFRESH, OnMenuitemrefresh)
	ON_UPDATE_COMMAND_UI(ID_MENUITEMREFRESH, OnUpdateMenuitemrefresh)
	ON_WM_LBUTTONUP()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_COMMAND(ID_POPUP_ADDCLASS, OnPopupAddclass)
	ON_UPDATE_COMMAND_UI(ID_POPUP_ADDCLASS, OnUpdatePopupAddclass)
	ON_COMMAND(ID_POPUP_DELETECLASS, OnPopupDeleteclass)
	ON_UPDATE_COMMAND_UI(ID_POPUP_DELETECLASS, OnUpdatePopupDeleteclass)
	ON_COMMAND(ID_POPUP_RENAMECLASS, OnPopupRenameclass)
	ON_UPDATE_COMMAND_UI(ID_POPUP_RENAMECLASS, OnUpdatePopupRenameclass)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(INITIALIZE_NAMESPACE, InitializeState )
	ON_MESSAGE(FIRE_OPEN_NAMESPACE, FireOpenNamespace )
	ON_MESSAGE(REDRAW_CONTROL, RedrawAll)
	ON_MESSAGE(SETFOCUSTREE, SetFocusTree)
	ON_MESSAGE(SETFOCUSNSE, SetFocusNSE)
	ON_MESSAGE(CLEARNAMESPACE, ClearNamespace)
END_MESSAGE_MAP()


// ===========================================================================
//
//	Dispatch map
//
// ===========================================================================
BEGIN_DISPATCH_MAP(CClassNavCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CClassNavCtrl)
	DISP_PROPERTY_EX(CClassNavCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_FUNCTION(CClassNavCtrl, "GetExtendedSelection", GetExtendedSelection, VT_VARIANT, VTS_NONE)
	DISP_FUNCTION(CClassNavCtrl, "GetSingleSelection", GetSingleSelection, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CClassNavCtrl, "OnReadySignal", OnReadySignal, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CClassNavCtrl, "InvalidateServer", InvalidateServer, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CClassNavCtrl, "MofCompiled", MofCompiled, VT_EMPTY, VTS_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CClassNavCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


// ===========================================================================
//
//	Event map
//
// ===========================================================================
BEGIN_EVENT_MAP(CClassNavCtrl, COleControl)
	//{{AFX_EVENT_MAP(CClassNavCtrl)
	EVENT_CUSTOM("EditExistingClass", FireEditExistingClass, VTS_VARIANT)
	EVENT_CUSTOM("NotifyOpenNameSpace", FireNotifyOpenNameSpace, VTS_BSTR)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("QueryCanChangeSelection", FireQueryCanChangeSelection, VTS_BSTR  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


// ===========================================================================
//
//	Property Pages
//
// ===========================================================================
BEGIN_PROPPAGEIDS(CClassNavCtrl, 1)
	PROPPAGEID(CClassNavPropPage::guid)
END_PROPPAGEIDS(CClassNavCtrl)


// ===========================================================================
//
//	Class factory and guid
//
// ===========================================================================
IMPLEMENT_OLECREATE_EX(CClassNavCtrl, "WBEM.ClassNavCtrl.1",
	0xc587b673, 0x103, 0x11d0, 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa)


// ===========================================================================
//
//	Type library ID and version
//
// ===========================================================================
IMPLEMENT_OLETYPELIB(CClassNavCtrl, _tlid, _wVerMajor, _wVerMinor)


// ===========================================================================
//
//	Interface IDs
//
// ===========================================================================
const IID BASED_CODE IID_DClassNav =
		{ 0xc587b671, 0x103, 0x11d0, { 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const IID BASED_CODE IID_DClassNavEvents =
		{ 0xc587b672, 0x103, 0x11d0, { 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };


// ===========================================================================
//
//	Font Height
//
// ===========================================================================
#define CY_FONT 15


// ===========================================================================
//
//	Control type information
//
// ===========================================================================
static const DWORD BASED_CODE _dwClassNavOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CClassNavCtrl, IDS_CLASSNAV, _dwClassNavOleMisc)


// ***************************************************************************
//
// CClassNavCtrl::CClassNavCtrlFactory::UpdateRegistry
//
// Description:
//	  Adds or removes system registry entries for CCClassNavCtrl.
//
// Parameters:
//	  BOOL bRegister			Register if TRUE; Unregister if FALSE.
//
// Returns:
//	  BOOL						TRUE on success
//								FALSE on failure
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CClassNavCtrl::CClassNavCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CLASSNAV,
			IDB_CLASSNAV,
			afxRegInsertable | afxRegApartmentThreading,
			_dwClassNavOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

int GetPropNames(IWbemClassObject * pClass, CString *&pcsReturn)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL,&psa);

    if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property names ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (NULL, pClass);
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 10);
	}
	else
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsReturn = new CString [(lUpper - lLower) + 1];
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BOOL bClsidSetForProp = FALSE;
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
           pcsReturn[i] = PropName;
           SysFreeString(PropName);
	   }
	}

	SafeArrayDestroy(psa);

	return (lUpper - lLower) + 1;
}

void GetAssocLeftRight(IWbemClassObject *pAssoc , CString &szLeft, CString &szRight)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;

	nProps = GetPropNames(pAssoc, pcsProps);
	int i,k;
	IWbemQualifierSet * pAttrib = NULL;
	int cRefs = 0;
	CString csTmp = _T("syntax");
	k = 0;  // index into pcsRolesAndPaths
	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pAssoc -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			VARIANTARG var;
			VariantInit(&var);
			sc = pAttrib->GetNames(0,&psa);
			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					//Get the attrib value
					long lReturn;
					BSTR bstrTemp = csTmp.AllocSysString();
					sc = pAttrib -> Get(bstrTemp, 0,
										&var,&lReturn);
					::SysFreeString(bstrTemp);
					if (sc != S_OK)
					{
						CString csUserMsg;
						csUserMsg =  _T("Cannot get qualifier value ");
						csUserMsg += pcsProps[i] + _T(" for object ");
						csUserMsg += GetIWbemFullPath (NULL, pAssoc);
						csUserMsg += _T(" quialifier ") + csTmp;
						ErrorMsg
								(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
								__LINE__ - 11);
					}
					else
					{
						CString csValue;
						CString csValue2;
						if (var.vt == VT_BSTR)
						{
							csValue = var.bstrVal;
							csValue2 = csValue.Right(csValue.GetLength() - 4);
							csValue = csValue.Left(4);
							if(csValue.CompareNoCase(_T("ref:")) == 0)
							{
								if(cRefs == 0)
									szLeft = csValue2;
								else
									szRight = csValue2;
								cRefs++;
//								pcsRolesAndPaths[k++] = pcsProps[i];
							}
						}
						SysFreeString(AttrName);
					}
				}
			 }
			 pAttrib -> Release();
		}
	}
	SafeArrayDestroy(psa);
	delete [] pcsProps;
}


// ***************************************************************************
//
// CClassNavCtrl::CClassNavCtrl
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CClassNavCtrl::CClassNavCtrl()
{
	InitializeIIDs(&IID_DClassNav, &IID_DClassNavEvents);

	m_bChildrenCreated = FALSE;
	m_bInit = FALSE;
	m_lWidth = 200;
	m_lHeight = 200;
	m_pcilImageList = NULL;
	m_pcilStateImageList = NULL;
	m_nBitmaps = 2;
	m_pAddDialog = NULL;
	m_pRenameDialog = NULL;
	m_pSearchDialog = NULL;
	m_hContextSelection = NULL;
	m_bMetricSet = FALSE;
	m_csBanner = _T("Classes in:");
	m_nOffset = 2;
	m_bDrawAll = FALSE;
	m_bFirstDraw = TRUE;
	m_pServices = NULL;
	m_bSelectAllMode = FALSE;
	m_bOpeningNamespace = FALSE;
	m_bInOnDraw = FALSE;
	m_bOpenedInitialNamespace = FALSE;
	m_csFontName = _T("MS Shell Dlg");
	m_nFontHeight = CY_FONT;
	m_nFontWeight = (short) FW_NORMAL;
	m_pProgressDlg = NULL;
	m_bItemUnselected = NULL;
	m_bRestoreFocusToTree = TRUE;
	m_bReadySignal = FALSE;

	m_pDlg = NULL;

	AfxEnableControlContainer();



}

// ***************************************************************************
//
// CClassNavCtrl::~CClassNavCtrl
//
// Description:
//	  Class destructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CClassNavCtrl::~CClassNavCtrl()
{
	if (m_pServices)
	{
		m_pServices -> Release();
	}

	delete m_pProgressDlg;
}


// ***************************************************************************
//
// CClassNavCtrl::GetControlFlags
//
// Description:
//	  Returns flags to customize MFC's implementation of ActiveX controls.  For
//	  a description of the flags see MFC technical note "Optimizing an ActiveX
//	  Control".
//
// Parameters:
//	  NONE
//
// Returns:
//	  DWORD			Control flags
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
DWORD CClassNavCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();

	// The control will not be redrawn when making the transition
	// between the active and inactivate state.
	dwFlags |= noFlickerActivate;
	return dwFlags;
}

// ***************************************************************************
//
// CClassNavCtrl::OnDraw
//
// Description:
//	  Drawing member function for screen device.
//
// Parameters:
//	  CDC *pDC			The device context in which the drawing occurs.
//	  CRect &rcBounds	The rectangular area of the control, including the
//						border.
//	  CRect &rcInvalid	The rectangular area of the control that is invalid.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{




	CRect rcSave = rcBounds;
	CRect rcSave1 = rcBounds;

	if (m_bInOnDraw)
	{
		return;
	}

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);

	m_bInOnDraw = TRUE;
	if (GetSafeHwnd()) {
		CRect rcOutline(rcBounds);
		CBrush cbBackGround;
		cbBackGround.CreateSolidBrush(dwBackColor);
		CBrush *cbSave = pdc -> SelectObject(&cbBackGround);
		pdc ->FillRect(&rcOutline, &cbBackGround);
		pdc -> SelectObject(cbSave);
	}


	if (m_bOpeningNamespace == TRUE)
	{

		if (m_cbBannerWindow.GetSafeHwnd())
		{
			m_cbBannerWindow.ShowWindow(SW_SHOWNA);
		}
		if (m_ctcTree.GetSafeHwnd())
		{
			m_ctcTree.ShowWindow(SW_SHOWNA);
		}
		m_bInOnDraw = FALSE;
		return;

	}



	// So we can count on fundamental display characteristics.
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);


	if (m_bOpeningNamespace == FALSE && m_pServices == NULL && m_bDrawAll == TRUE)
	{
		m_bInOnDraw = FALSE;
		return;

	}



	if (!AmbientUserMode( ) && m_ctcTree.GetSafeHwnd( ))
	{
		// May want to do something fancier, but for now just print
		// text.
		m_bInOnDraw = FALSE;
		return;
	}
	else	// In case an editor does not support ambient modes.
		if (m_ctcTree.GetSafeHwnd( ) == NULL)
		{
			m_bInOnDraw = FALSE;
			return;
		}



	// First time just a blank window.

	CFont* pOldFont;

	if (m_bFirstDraw)
	{
		m_bFirstDraw = FALSE;
		CWnd::SetFont ( &m_cfFont , FALSE);
		pOldFont = pdc -> SelectObject( &m_cfFont );
		InitializeChildControlSize(rcBounds.Width(), rcBounds.Height());
	}

	pOldFont = pdc -> SelectObject( &m_cfFont );

	CRect rcOutline(rcBounds);
	CBrush cbBackGround;
	cbBackGround.CreateSolidBrush(dwBackColor);
	CBrush *cbSave = pdc -> SelectObject(&cbBackGround);
	pdc ->FillRect(&rcOutline, &cbBackGround);
	pdc -> SelectObject(cbSave);

	rcOutline = m_rTreeRect;
	pdc -> Draw3dRect(&rcOutline, crBlack, crGray);

	pdc -> SetBkMode( TRANSPARENT );
	pdc -> TextOut
		( m_nOffset + 4 , ((int) (m_nFontHeight * .35)) + ( 3 * m_nOffset),
			(LPCTSTR) m_csBanner, m_csBanner.GetLength() );

	pdc -> SetBkMode( OPAQUE );
	pdc->SelectObject(pOldFont);

	InitializeTreeForDrawing();
	m_bInOnDraw = FALSE;

	m_cbBannerWindow.ShowWindow(SW_SHOW);
	m_ctcTree.ShowWindow(SW_SHOW);


}

// ***************************************************************************
//
// CClassNavCtrl::GetControlFont
//
// Description:
//	  Create the font used by the control and get the font metrics.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::CreateControlFont()
{

	if (!m_bMetricSet) // Create the font used by the control.
	{
		CDC *pdc = CWnd::GetDC( );

		pdc -> SetMapMode (MM_TEXT);
		pdc -> SetWindowOrg(0,0);

		LOGFONT lfFont;

		 InitializeLogFont
			(lfFont, m_csFontName,m_nFontHeight, m_nFontWeight);

		m_cfFont.CreateFontIndirect(&lfFont);

		CWnd::SetFont ( &m_cfFont , FALSE);
		CFont* pOldFont = pdc -> SelectObject( &m_cfFont );
		pdc->GetTextMetrics(&m_tmFont);
		pdc -> SelectObject(pOldFont);

		m_bMetricSet = TRUE;

		ReleaseDC(pdc);
	}

}

// ***************************************************************************
//
// CClassNavCtrl::InitializeLogFont
//
// Description:
//	  Fill in LOGFONT structure.
//
// Parameters:
//	  LOGFONT &rlfFont	Structure to fill in.
//	  CString csName	Font name.
//	  int nHeight		Font height.
//	  int nWeight		Font weight.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{

	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfWidth = 0;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;

}

// ***************************************************************************
//
// CClassNavCtrl::InitializeTreeForDrawing
//
// Description:
//	  Create the tree control's image list and set the root node.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::InitializeTreeForDrawing()
{
	if (!m_bInit)
	{
		//InitializeState();
		m_bInit = TRUE;

		HICON hIconObjectClass = theApp.LoadIcon(IDI_ICONOBJECTCLASS);
		HICON hIconObjectClassChecked =
			theApp.LoadIcon(IDI_ICONOBJECTCLASSCHECKED);
		HICON hIconAssocClass =
			theApp.LoadIcon(IDI_ICONASSOCCLASS);
		HICON hIconAssocClassChecked =
			theApp.LoadIcon(IDI_ICONASSOCCLASSCHECKED);

		m_pcilImageList = new CImageList();
		CSchemaInfo::CreateImageList(m_pcilImageList);
//		m_pcilImageList->Create(MAKEINTRESOURCE(IDB_SYMBOLS), 16, 16, RGB(0,0,0));

//		m_pcilImageList->Attach(ImageList_LoadBitmap(GetModuleHandle(_T("WBEMUtils.dll")),MAKEINTRESOURCE(IDB_SYMBOLS), 16, 16, RGB(0,128,128)));

#if 0
		m_pcilImageList->Create(16, 16, TRUE, 4, 4);

		iReturn = m_pcilImageList -> Add(hIconObjectClass);			// 0
		iReturn = m_pcilImageList -> Add(hIconObjectClassChecked);	// 1
		iReturn = m_pcilImageList -> Add(hIconAssocClass);			// 2
		iReturn = m_pcilImageList -> Add(hIconAssocClassChecked);	// 3

		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONOBJECTCLASSABSTRACT));	// 4
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONASSOCCLASSABSTRACT));	// 5
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONOBJECTCLASSABSTRACT1));// 6
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONASSOCCLASSABSTRACT1));	// 7
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ABOUTDLL1));				// 8
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONOBJECTCLASS1));		// 9
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONASSOCCLASS1));			// 10
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONASSOCCLASS2));			// 11
		m_pcilImageList->Add(theApp.LoadIcon(IDI_ICONASSOCCLASS3));			// 12
#endif

		// This image list is maintained by the ctreectrl.
		CImageList *pcilOld  = m_ctcTree.CTreeCtrl::SetImageList(m_pcilImageList,TVSIL_NORMAL);
		delete pcilOld;


		CBitmap cbmChecks;

		cbmChecks.LoadBitmap(IDB_BITMAPCHECKS);

		m_pcilStateImageList = new CImageList();

		m_pcilStateImageList -> Create (16, 16, TRUE, 3, 0);

		m_pcilStateImageList -> Add(&cbmChecks,RGB (255,0,0));

		pcilOld  = m_ctcTree.CTreeCtrl::SetImageList(m_pcilStateImageList,TVSIL_STATE);
		delete pcilOld;

		HTREEITEM hRoot;
		if (m_htiTreeRoots.GetSize() > 0)
			hRoot = reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(0));
		else
			hRoot = NULL; // start do something here.

		if (hRoot)
		{
			m_ctcTree.SelectItem(hRoot);
			m_ctcTree.SetFocus();
			IWbemClassObject *pimcsRoot = reinterpret_cast<IWbemClassObject *>(m_iwcoTreeRoots.GetAt(0));
			CString m_csSingleSelection = GetIWbemFullPath(m_pServices, pimcsRoot);
		}
		m_bDrawAll = TRUE;
		InvalidateControl();
	}
}

// ***************************************************************************
//
// CClassNavCtrl::DoPropExchange
//
// Description:
//	  Control property persistence support.  Called by the framework when
//	  loading or storing a control from a persistent storage representation,
//	  such as a stream or property set.
//
// Parameters:
//	  CPropExchange* pPX	Context of the property exchange, including its
//							direction.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
	PX_String(pPX, _T("NameSpace"), m_csNameSpace, _T(""));
}

// ***************************************************************************
//
// CClassNavCtrl::OnResetState
//
// Description:
//	  Reset control to default state to defaults found in DoPropExchange.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnResetState()
{
	COleControl::OnResetState();
}


// ***************************************************************************
//
// CClassNavCtrl::AboutBox
//
// Description:
//	  Display an "About" box to the user.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_CLASSNAV);
	dlgAbout.DoModal();
}


// ***************************************************************************
//
// CClassNavCtrl::OnDrawMetafile
//
// Description:
//	  Drawing member function for Metafile device.
//
// Parameters:
//	  CDC *pDC			The device context in which the drawing occurs.
//	  CRect &rcBounds	The rectangular area of the control, including the
//						border.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnDrawMetafile(CDC* pDC, const CRect& rcBounds)
{
	return;

	CRect rcOutline(rcBounds);
	rcOutline.DeflateRect( 1, 1, 1, 1);

	pDC->Rectangle( &rcBounds);
}

// ***************************************************************************
//
// CClassNavCtrl::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnSize(UINT nType, int cx, int cy)
{
	if (!GetSafeHwnd())
		return;

	COleControl::OnSize(nType, cx, cy);

	if (!m_bMetricSet) // Create the font used by the control.
		CreateControlFont();

	SetChildControlGeometry(cx, cy);

	if (!m_bChildrenCreated)
	{
		m_bChildrenCreated = TRUE;

		if (m_ctcTree.Create (WS_CHILD  | TVS_HASLINES |  WS_VISIBLE, m_rTree, this , IDC_TREE ) == -1)
			return;

		m_ctcTree.UpdateWindow();
		m_ctcTree.RedrawWindow();

		m_cbBannerWindow.SetParent(this);

		if (m_cbBannerWindow.Create(NULL, _T("BannerCWnd"), WS_CHILD  |  WS_VISIBLE ,m_rBannerRect, this, IDC_TOOLBAR) == -1)
			return;

		m_pAddDialog = new CAddDialog(this);
		m_pRenameDialog = new CRenameClassDIalog(this);
		m_pSearchDialog = new CClassSearch(this);

		m_ctcTree.CWnd::SetFont ( &m_cfFont , FALSE);
		m_cbBannerWindow.CWnd::SetFont ( &m_cfFont , FALSE);

		m_pProgressDlg = new CProgressDlg;
	}


	m_cbBannerWindow.MoveWindow(m_rBannerRect,TRUE);
	m_ctcTree.MoveWindow(m_rTree,TRUE);
	InvalidateControl();

}

LRESULT CClassNavCtrl::RedrawAll(WPARAM, LPARAM)
{
	m_cbBannerWindow.UpdateWindow();
	m_ctcTree.UpdateWindow();

	m_cbBannerWindow.RedrawWindow();
	m_ctcTree.RedrawWindow();

	Refresh();

	return 0;

}

// ***************************************************************************
//
// CClassNavCtrl::InitializeChildControlSize
//
// Description:
//	  Initializes the child control (banner and tree control) sizes.
//
// Parameters:
//	  int cx			Width
//	  int cy			Height
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::InitializeChildControlSize(int cx, int cy)
{
	SetChildControlGeometry(cx, cy);

	m_cbBannerWindow.MoveWindow(m_rBannerRect);
	m_ctcTree.MoveWindow(m_rTree);

}

// ***************************************************************************
//
//	CClassNavCtrl::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls based upon font size for the
//		edit and button controls.  Remainder goes to the tree control.
//
//	Parameters:
//		int cx			Width
//		int cy			Height
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CClassNavCtrl::SetChildControlGeometry(int cx, int cy)
{

	int nBannerHeight = (m_tmFont.tmHeight) + 20;

	m_rBannerRect = CRect(	0,
							0,
							cx,
							nBannerHeight);


	m_rTreeRect = CRect (	nSideMargin,
							nBannerHeight + m_nOffset,
							cx - (nSideMargin + 1) ,
							cy - nTopMargin);
	m_rTree = CRect(		nSideMargin + 1,
							nBannerHeight + m_nOffset + 1,
							cx - (nSideMargin + 2),
							cy  - (nTopMargin + 1));

}

void CClassNavCtrl::PopulateTree(HTREEITEM hRoot, CString szRoot, CSchemaInfo &schema, BOOL bSelf /*= FALSE*/)
{
	CSchemaInfo::CClassInfo &infoRoot = schema[szRoot];

	HTREEITEM hSelf = NULL;
	if(bSelf)
	{
		if(infoRoot.m_szClass.GetLength())
		{
			hSelf = m_ctcTree.AddTreeObject2(hRoot, infoRoot);
			hRoot = hSelf;
		}
		else
		{
			CString sz = _T("Unable to find class ") + szRoot;
			m_ctcTree.InsertItem(sz, 0, 0, hRoot);
		}
	}

	for(int i=0;i<infoRoot.m_rgszSubs.GetSize();i++)
	{
		CSchemaInfo::CClassInfo &info = schema[infoRoot.m_rgszSubs[i]];
		if(!info.m_szClass.GetLength())
		{
			ASSERT(FALSE);
			continue;
		}

		HTREEITEM hChild = m_ctcTree.AddTreeObject2(hRoot, info);

		if(NULL == hRoot && hChild)
		{
			m_htiTreeRoots.Add(reinterpret_cast<void *>(hChild));
			m_iwcoTreeRoots.Add(info.m_pObject);
		}

		BOOL bChildren = info.m_rgszSubs.GetSize()>0;
		if(bChildren && hChild)
			PopulateTree(hChild, infoRoot.m_rgszSubs[i], schema);
	}
}

// ***************************************************************************
//
// CClassNavCtrl::InitializeState
//
// Description:
//	  If we are in AmbientUserMode initialize the state of the control.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::InitializeState()
{
	PostMessage(INITIALIZE_NAMESPACE,0,0);
}

#if 0
// Routine for enumerating all tree items
void ForEach(CTreeCtrl &tree, HTREEITEM hItem, CSchemaInfo &schema)
{
	if(TVI_ROOT != hItem)
	{
		...FOR EACH...
	}
	HTREEITEM hChild = tree.GetChildItem(hItem);
	while(hChild)
	{
		ForEach(tree, hChild, schema);
		hChild = tree.GetNextSiblingItem(hChild);
	}
}
#endif

void CClassNavCtrl::PopulateTree()
{
	DWORD dw1 = GetTickCount();
	int i;
	CPtrArray cpaDeepEnum;
	// Do deep enum here.
	GetClasses(m_pServices, NULL, cpaDeepEnum, FALSE); //m_iwcoTreeRoots);

	if(m_bCancel)
	{
		m_bCancel = FALSE;
		ReleaseObjects(&cpaDeepEnum);
		return;
	}

	m_ctcTree.m_schema.Init(cpaDeepEnum);

	m_ctcTree.SetRedraw(FALSE);
	PopulateTree(NULL, "", m_ctcTree.m_schema);

	// Sort by Associations first
	HTREEITEM hFirst = m_ctcTree.GetChildItem(NULL);
	i=0;
	while(hFirst)
	{
		int nImage, nSelectedImage;
		m_ctcTree.GetItemImage(hFirst, nImage, nSelectedImage);
		CString szCount;
		szCount.Format(_T("%05i"), i);

		if(SCHEMA_CLASS == nImage || SCHEMA_CLASS_ABSTRACT1 == nImage || SCHEMA_CLASS_ABSTRACT2 == nImage)
			m_ctcTree.SetItemText(hFirst, "   " + szCount + m_ctcTree.GetItemText(hFirst));
		else
			m_ctcTree.SetItemText(hFirst, "zzz" + szCount + m_ctcTree.GetItemText(hFirst));

		hFirst = m_ctcTree.GetNextSiblingItem(hFirst);
		i++;
	}
	m_ctcTree.SortChildren(NULL);
	hFirst = m_ctcTree.GetChildItem(NULL);
	while(hFirst)
	{
//		int nImage, nSelectedImage;
//		m_ctcTree.GetItemImage(hFirst, nImage, nSelectedImage);
//		if(0 == nImage || 4 == nImage || 6 == nImage)
		{
			CString sz = m_ctcTree.GetItemText(hFirst);
			m_ctcTree.SetItemText(hFirst, sz.Right(sz.GetLength()-8));
		}
		hFirst = m_ctcTree.GetNextSiblingItem(hFirst);
	}

	m_ctcTree.SetRedraw(TRUE);
}


LRESULT CClassNavCtrl::InitializeState(WPARAM, LPARAM)
{
	if (AmbientUserMode( ))
	{
		if (m_bOpeningNamespace == TRUE)
		{
			return 0;

		}

		m_bOpeningNamespace = TRUE;

		CWaitCursor cwcWait;

		int nRoots = (int) m_htiTreeRoots.GetSize( );

		int i;
		HTREEITEM hItem;
		for (i = 0; i < nRoots; i++)
		{
			hItem =
				reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
			if (hItem)
			{
				m_ctcTree.ReleaseClassObjects(hItem);
			}

		}

		m_htiTreeRoots.RemoveAll();
		m_iwcoTreeRoots.RemoveAll();

		m_ctcTree.SetRedraw(FALSE);
		m_ctcTree.DeleteAllItems();
		m_ctcTree.SetRedraw(TRUE);

		m_pServices = NULL;
		m_bUserCancel = FALSE;
		m_pServices = InitServices(&m_csNameSpace);

		// bug#39985
		if(m_bUserCancel && !m_hWnd)
			return 0;

		m_bOpeningNamespace = FALSE;
		if (m_bUserCancel)
		{
			InvalidateControl();
			m_ctcTree.Invalidate();
			m_ctcTree.RedrawWindow(NULL,NULL,RDW_INVALIDATE | RDW_INTERNALPAINT);
			CString csText = m_cbBannerWindow.m_pnseNameSpace->GetNamespaceText();
			if (!csText.IsEmpty())
			{
				m_cbBannerWindow.m_pnseNameSpace->ClearNamespaceText((LPCTSTR) csText);
				m_cbBannerWindow.UpdateWindow();
				m_cbBannerWindow.RedrawWindow();
			}
			return 0;
		}

		if (!m_pServices)
		{
			CString csUserMsg;
			if (m_sc == 0x8001010e)
			{
				csUserMsg =
							_T("You cannot open another Developer Studio window.  Please close this web page.");
				//ErrorMsg
				//		(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
				CString csTitle = _T("WBEM Developer Studio");
				MessageBox(csUserMsg,csTitle);
				m_ctcTree.Invalidate();
				InvalidateControl();

				return 0;



			}
			else
			{
				if (!m_csNameSpace.IsEmpty())
				{
					csUserMsg =
							_T("Cannot open namespace ");
					csUserMsg += m_csNameSpace;
					ErrorMsg
						(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
				}
				m_ctcTree.Invalidate();
				InvalidateControl();

				return 0;
			}

		}
		m_cbBannerWindow.OpenNamespace(&m_csNameSpace,TRUE);

		if (!m_bOpenedInitialNamespace)
		{
			if (m_bReadySignal && AmbientUserMode( ))
			{
				FireNotifyOpenNameSpace(m_csNameSpace);
			}
			m_bOpenedInitialNamespace = TRUE;
		}

		if (!m_pProgressDlg->GetSafeHwnd())
		{
			m_bCancel = FALSE;
			CString csMessage;
			csMessage = _T("Retrieving classes:");
			SetProgressDlgLabel(csMessage);
			csMessage = _T("Root classes");
			//csMessage = _T("Retrieving " ) + *pcsParent + _T(" subclasses.  You may cancel the operation.");
			SetProgressDlgMessage(csMessage);
			CreateProgressDlgWindow();
		}

		PopulateTree();

		if (m_bCancel)
		{
			CString csText = m_cbBannerWindow.m_pnseNameSpace->GetNamespaceText();
			if (!csText.IsEmpty())
			{
				m_cbBannerWindow.m_pnseNameSpace->ClearNamespaceText((LPCTSTR) csText);
				m_cbBannerWindow.UpdateWindow();
				m_cbBannerWindow.RedrawWindow();
			}
			int nRoots = (int) m_htiTreeRoots.GetSize( );

			int i;
			HTREEITEM hItem;
			for (i = 0; i < nRoots; i++)
			{
				hItem =
					reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
				if (hItem)
				{
					m_ctcTree.ReleaseClassObjects(hItem);
				}

			}

			m_htiTreeRoots.RemoveAll();
			m_iwcoTreeRoots.RemoveAll();


			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONCLASSSEARCH,FALSE);
			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONADD,FALSE);
			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONDELETE,FALSE);

			m_ctcTree.SetRedraw(FALSE);
			m_ctcTree.DeleteAllItems();
			m_ctcTree.SetRedraw(TRUE);

			m_bCancel = FALSE;
			if (m_bReadySignal)
			{
				CString csEmpty = _T("");
				COleVariant covEmpty(csEmpty);
				FireEditExistingClass(covEmpty);
#ifdef _DEBUG
				afxDump <<"CBanner::InitializeState: 	m_pParent -> FireEditExistingClass(covEmpty); \n";
				afxDump << "     " << csEmpty << "\n";

#endif
			}
		}

		DestroyProgressDlgWindow();

		SetModifiedFlag();
		InvalidateControl();

		PostMessage(SETFOCUSTREE,0,0);
	}
	return 0;

}

LRESULT CClassNavCtrl::FireOpenNamespace(WPARAM, LPARAM)
{
	if (!m_bOpenedInitialNamespace && m_bReadySignal)
	{
		FireNotifyOpenNameSpace(m_csNameSpace);
	}


	return 0;
}

// ***************************************************************************
//
// CClassNavCtrl::GrowTree
//
// Description:
//	  Add subclass items to a class object to the tree.
//
// Parameters:
//	  HTREEITEM	hParent			Parent tree item.
//	  IWbemClassObject *pParent	Parent class object.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CClassNavCtrl::GrowTree(HTREEITEM hParent, IWbemClassObject *pParent)
{
	CPtrArray cpaClasses;

	CString csClass = _T("__Class");
	csClass = ::GetProperty(pParent,&csClass);

	if (!m_pProgressDlg->GetSafeHwnd())
	{
		m_bCancel = FALSE;
		CString csMessage;
		csMessage = _T("Retrieving classes:");
		SetProgressDlgLabel(csMessage);
		csMessage =  csClass + _T(" subclasses");
		SetProgressDlgMessage(csMessage);
		CreateProgressDlgWindow();
	}


	// Do deep enum here
	//int nEnumed =
	//		GetClasses
	//		(m_pServices, &csClass, cpaClasses, FALSE);

	CPtrArray cpaDeepEnum;
	// Do deep enum here.

	GetClasses(m_pServices, &csClass, cpaDeepEnum, FALSE);

	int nClasses = 0;

	DestroyProgressDlgWindow();
	if (m_bCancel)
	{
		m_bCancel = FALSE;
		PostMessage(SETFOCUSTREE,0,0);
		ReleaseObjects(&cpaDeepEnum);
		return 0;
	}


	m_ctcTree.m_schema.Delete(csClass);

	IWbemClassObject *pObject = NULL;
	BSTR bstrTemp = csClass.AllocSysString();
	HRESULT hr = m_pServices->GetObject(bstrTemp,0, NULL,&pObject,NULL);
	::SysFreeString(bstrTemp);
	if(SUCCEEDED(hr))
		m_ctcTree.m_schema.AddClass(pObject);


	m_ctcTree.m_schema.Update(cpaDeepEnum);

	m_ctcTree.SetRedraw(FALSE);
	PopulateTree(hParent, csClass, m_ctcTree.m_schema);
	m_ctcTree.SetRedraw(TRUE);

	m_ctcTree.RefreshIcons(hParent);

	PostMessage(SETFOCUSTREE,0,0);

	return (int)cpaDeepEnum.GetSize(); // NOTE: Win64 - We will NEVER have more that 4 billion items as possible from GetSize
}

// ***************************************************************************
//
// CClassNavCtrl::GetOLEMSObject
//
// Description:
//	  Get an OLEMS class object.
//
// Parameters:
//	  CString *pcsClass			Class name.
//
// Returns:
//	  IWbemClassObject *			The class object.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
IWbemClassObject *CClassNavCtrl::GetOLEMSObject (CString *pcsClass)
{
	IWbemClassObject *pClass = NULL;
	BSTR bstrTemp = pcsClass -> AllocSysString();
	SCODE sc =
		GetServices() -> GetObject
			(bstrTemp,0,NULL,&pClass,NULL);
	::SysFreeString(bstrTemp);

	return pClass;
}


// ***************************************************************************
//
// CClassNavCtrl::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CClassNavCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style |= WS_CLIPCHILDREN;
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_ctcTree.InitTreeState(this);

	return 0;
}

// ***************************************************************************
//
// CClassNavCtrl::DestroyWindow
//
// Description:
//	  Destroy objects that cannot be destroyed in the class destructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  BOOL				Nonzero if the window is destroyed; otherwise 0.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CClassNavCtrl::DestroyWindow()
{
	m_ctcTree.SetImageList(NULL, TVSIL_NORMAL);
	m_ctcTree.SetImageList(NULL, TVSIL_STATE);

	delete m_pcilImageList;
	delete m_pcilStateImageList;
	delete m_pAddDialog;
	delete m_pRenameDialog;
	delete m_pSearchDialog;
	m_pcilImageList = NULL;
	m_pcilStateImageList = NULL;
	m_pAddDialog = NULL;
	m_pRenameDialog = NULL;
	m_pSearchDialog = NULL;

	return COleControl::DestroyWindow();
}

// ***************************************************************************
//
// CClassNavCtrl::GetExtendedSelection
//
// Description:
//	  Automation method to allow other programs to retireve the extended
//	  selection.  Selection via a check in check box.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VARIANT			A safearray of type VT_ARRAY | VT_BSTR.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
VARIANT CClassNavCtrl::GetExtendedSelection()
{
	SAFEARRAY *psa;
	if (m_bSelectAllMode)
	{
		psa = GetExtendedSelectionSelectAllMode();
	}
	else
	{
		psa = m_ctcTree.GetExtendedSelection ();
	}

	VARIANT vaResult;
	VariantInit(&vaResult);

	vaResult.vt = VT_ARRAY | VT_BSTR;
	vaResult.parray = psa;

	return vaResult;
}

// ***************************************************************************
//
// CClassNavCtrl::GetExtendedSelectionSelectAllMode
//
// Description:
//	  Get the extended selection if we are in select all mode.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VARIANT			A safearray of bstr's.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
SAFEARRAY *CClassNavCtrl::GetExtendedSelectionSelectAllMode()
{
	SAFEARRAY *psaNotSelected = m_ctcTree.GetExtendedSelection (1);
	long uBound;
	SafeArrayGetUBound(psaNotSelected, 1, &uBound);

	int i;

	long ix;

	BSTR bstrClassName;
	CString csTmp;
	CStringArray csaNotSelected;

	// First name is the namespace.
	for(i = 1; i <= uBound; ++i)
	{
		ix = i;
		HRESULT hresult =
			SafeArrayGetElement
			(psaNotSelected, &ix, &bstrClassName);
		if (hresult == S_OK)
		{
			csTmp = bstrClassName;
			csaNotSelected.Add(csTmp);
			SysFreeString(bstrClassName);
		}
	}

	SafeArrayDestroy(psaNotSelected);
	psaNotSelected = NULL;

	int nNotSelected = (int) csaNotSelected.GetSize();

	CStringArray *pcsaClassNames =
		GetAllClassPaths(GetServices(), m_csNameSpace);

	int nAllClasses = (int) pcsaClassNames->GetSize();


	int nExtendedSelection = ((int) pcsaClassNames->GetSize()) - nNotSelected + 1;

	SAFEARRAY *psaSelections;
	MakeSafeArray (&psaSelections, VT_BSTR, nExtendedSelection);
	int iSelected = 0;
	PutStringInSafeArray (psaSelections, &m_csNameSpace , iSelected++);

	for (i = 0; i < nAllClasses; i++)
	{
		CString csClass = pcsaClassNames->GetAt(i);

		if (nNotSelected > 0)
		{
			BOOL bNotSelected = FALSE;
			for (int n = 0; n < nNotSelected; n++)
			{
				csTmp = csaNotSelected.GetAt(n);
				if (csClass.CompareNoCase(csTmp) == 0)
				{
					bNotSelected = TRUE;
					break;
				}
			}

			if (bNotSelected == FALSE)
			{
				PutStringInSafeArray (psaSelections, &csClass , iSelected++);
			}
		}
		else
		{

			PutStringInSafeArray (psaSelections, &csClass , iSelected++);

		}
	}

	delete pcsaClassNames;

	return psaSelections;
}

// ***************************************************************************
//
// CClassNavCtrl::GetSingleSelection
//
// Description:
//	  Automation method to allow other programs to retireve currently
//	  selected tree item.  Selection via tree item selection.
//
// Parameters:
//	  NONE
//
// Returns:
//	  BSTR				Class path.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BSTR CClassNavCtrl::GetSingleSelection()
{
	return m_ctcTree.GetSelectionPath().AllocSysString();
}

// ***************************************************************************
//
// CClassNavCtrl::IsTreeItemARoot
//
// Description:
//	  Predicate to tell if a tree item handle is a root.
//
// Parameters:
//	  HTREEITEM	hItem	Item to test
//
// Returns:
//	  BOOL				TRUE if a root; FALSE is not a root.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CClassNavCtrl::IsTreeItemARoot(HTREEITEM hItem)
{
	int nRoots = (int) m_htiTreeRoots.GetSize( );

	HTREEITEM hRoot;
	for (int i = 0; i < nRoots; i++)
	{
		hRoot =
			reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
		if (hItem == hRoot)
		{
			return TRUE;

		}
	}
	return FALSE;
}

// ***************************************************************************
//
// CClassNavCtrl::RemoveObjectFromClassRoots
//
// Description:
//	  Delete a class root object.
//
// Parameters:
//	  IWbemClassObject *pClassObject		Object to remove.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::RemoveObjectFromClassRoots
(IWbemClassObject *pClassObject)
{
	int nRoots = (int) m_iwcoTreeRoots.GetSize( );
	if (nRoots == 0)
	{
		return;
	}
	IWbemClassObject * pRoot;
	for (int i = 0; i < nRoots; i++)
	{
		pRoot =
			reinterpret_cast<IWbemClassObject *>(m_iwcoTreeRoots.GetAt(i));
		if (pClassObject == pRoot)
		{
			m_iwcoTreeRoots.RemoveAt( i );
			break;
		}
	}
}

// ***************************************************************************
//
// CClassNavCtrl::FindObjectinClassRoots
//
// Description:
//	  Searches for a class, by name, in the tree roots.
//
// Parameters:
//	  CString *pcsClassObject		Class name.
//
// Returns:
//	  HTREEITEM						Tree item if found; NULL otherwise.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
HTREEITEM CClassNavCtrl::FindObjectinClassRoots(CString *pcsClassObject)
{
	IWbemClassObject *pClassObject = NULL;
	BSTR bstrTemp = pcsClassObject->AllocSysString();
	SCODE sc = m_pServices->GetObject
		(bstrTemp,0,NULL,&pClassObject,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
	   return NULL;
	}

	int nRoots = (int) m_htiTreeRoots.GetSize( );
	if (nRoots == 0)
	{
		pClassObject->Release();
		return NULL;
	}

	IWbemClassObject * pRoot;
	for (int i = 0; i < nRoots; i++)
	{
		pRoot =
			reinterpret_cast<IWbemClassObject *>
			(m_ctcTree.GetItemData
			(reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i))));
		if (ClassIdentity(pClassObject,pRoot))
		{
			pClassObject->Release();
			return reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
		}
	}
	pClassObject->Release();
	return NULL;
}

// ***************************************************************************
//
// CClassNavCtrl::RemoveItemFromTreeItemRoots
//
// Description:
//	  Delete a tree item from roots.
//
// Parameters:
//	  HTREEITEM	hItem	Item to remove.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::RemoveItemFromTreeItemRoots(HTREEITEM hItem)
{

	int nRoots = (int) m_htiTreeRoots.GetSize( );
	if (nRoots == 0)
	{
		return;
	}

	HTREEITEM hRoot;
	for (int i = 0; i < nRoots; i++)
	{
		hRoot =
			reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
		if (hItem == hRoot)
		{
			m_htiTreeRoots.RemoveAt( i );
			break;
		}
	}
}

// ***************************************************************************
//
// CClassNavCtrl::GetSelectionClassName
//
// Description:
//	  Get class name of single selection.
//
// Parameters:
//	  NONE
//
// Returns:
//	  CString				Class name.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CString CClassNavCtrl::GetSelectionClassName()
{
	HTREEITEM hItem = GetSelection();
	if (hItem)
	{
		IWbemClassObject *pItem =  (IWbemClassObject*)
			m_ctcTree.GetItemData(hItem);
		if (pItem)
		{
			CString csClass = _T("__Class");
			return ::GetProperty(pItem, &csClass);
		}
	}

	return _T("");

}

// ***************************************************************************
//
// CClassNavCtrl::OnClearextendedselection
//
// Description:
//	  Clear extended tree item selection and selection mode.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnClearextendedselection()
{
	m_ctcTree.ClearExtendedSelection();
	m_bSelectAllMode = FALSE;
}

// ***************************************************************************
//
// CClassNavCtrl::OnUpdateClearextendedselection
//
// Description:
//	  Enable or disable context menu item.
//
// Parameters:
//	  CCmdUI* pCmdUI			Represents the menu item.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnUpdateClearextendedselection(CCmdUI* pCmdUI)
{
	if (m_ctcTree.NumExtendedSelection() > 0)
		pCmdUI -> Enable(TRUE);
	else
		pCmdUI -> Enable(FALSE);
}

// ***************************************************************************
//
// CClassNavCtrl::GetNameSpace
//
// Description:
//	  Get automation property.
//
// Parameters:
//	  NONE
//
// Returns:
//	  BSTR					Currently opened namespace.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BSTR CClassNavCtrl::GetNameSpace()
{
	return m_csNameSpace.AllocSysString();
}

// ***************************************************************************
//
// CClassNavCtrl::SetNameSpace
//
// Description:
//	  Set automation property.
//
// Parameters:
//	  LPCTSTR lpszNewValue		Namespace to open.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{
	m_bOpeningNamespace = TRUE;
	CString csNameSpace = lpszNewValue;
	if (GetSafeHwnd() && AmbientUserMode())
	{
		IWbemServices *pServices = GetIWbemServices(csNameSpace);
		if (pServices)
		{
			SCODE sc = m_cbBannerWindow.OpenNamespace(&csNameSpace,TRUE);
			m_pServices = pServices;
			OpenNameSpace(&csNameSpace);
		}
		else if (m_sc == S_OK)
		{
			CString csUserMsg =
							_T("Cannot open namespace \"");
			csUserMsg += m_csNameSpace;
			csUserMsg += _T("\".");
			ErrorMsg
					(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
			m_bOpeningNamespace = FALSE;
			return;
		}
		SetModifiedFlag();
	}
	else if (GetSafeHwnd() && !AmbientUserMode())
	{
		m_csNameSpace = lpszNewValue;
		SetModifiedFlag();
	}

	m_bOpeningNamespace = FALSE;

}

// ***************************************************************************
//
// CClassNavCtrl::OpenNameSpace
//
// Description:
//	  Connect to namespace server, fire an event, and reset the tree state.
//
// Parameters:
//	  CString *pcsNameSpace		Namespace to connect to.
//
// Returns:
//	  BOOL						TRUE if successful; FALSE otherwise.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CClassNavCtrl::OpenNameSpace(CString *pcsNameSpace)
{
	//bug#56727
	CString csSelection = m_ctcTree.GetSelectionPath();
	if (!QueryCanChangeSelection(csSelection))
	{
		SetFocus();
		return FALSE;
	}



	m_bOpeningNamespace = TRUE;

	CWaitCursor cwcWait;
	IWbemServices *pServices = InitServices(pcsNameSpace);

	if (pServices)
	{
		if (m_pServices)
		{
			m_pServices -> Release();
		}

		m_pServices = pServices;
		m_csNameSpace = *pcsNameSpace;

		if (m_bReadySignal)
		{
			FireNotifyOpenNameSpace(*pcsNameSpace);
		}

		int nRoots = (int) m_htiTreeRoots.GetSize( );

		int i;
		HTREEITEM hItem;
		for (i = 0; i < nRoots; i++)
		{
			hItem =
				reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
			if (hItem)
			{
				m_ctcTree.ReleaseClassObjects(hItem);
			}
		}

		m_htiTreeRoots.RemoveAll();
		m_iwcoTreeRoots.RemoveAll();

		m_ctcTree.SetRedraw(FALSE);
		m_ctcTree.DeleteAllItems();
		m_ctcTree.SetRedraw(TRUE);


		if (!m_pProgressDlg->GetSafeHwnd())
		{
			m_bCancel = FALSE;
			CString csMessage;
			csMessage = _T("Retrieving classes:");
			SetProgressDlgLabel(csMessage);
			csMessage = _T("Root classes");
			//csMessage = _T("Retrieving " ) + *pcsParent + _T(" subclasses.  You may cancel the operation.");
			SetProgressDlgMessage(csMessage);
			CreateProgressDlgWindow();
		}

		PopulateTree();
#if 0
		CPtrArray cpaDeepEnum;
		// Do deep enum here.

		GetClasses
			(m_pServices, NULL, cpaDeepEnum, FALSE); //m_iwcoTreeRoots);

		CSchemaInfo schema;
		ASSERT(FALSE);
		m_ctcTree.SetRedraw(FALSE);
		PopulateTree(NULL, "", schema);
		m_ctcTree.SetRedraw(TRUE);
#endif

		if (m_bCancel)
		{
#if 0
			int nRootsd = (int) m_htiTreeRoots.GetSize( );

			int i;
			HTREEITEM hItem;
			for (i = 0; i < nRoots; i++)
			{
				hItem =
					reinterpret_cast<HTREEITEM>(m_htiTreeRoots.GetAt(i));
				if (hItem)
				{
					m_ctcTree.ReleaseClassObjects(hItem);
					m_ctcTree.UnCacheTools(hItem);
				}

			}
#endif
			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONCLASSSEARCH,FALSE);
			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONADD,FALSE);
			m_cbBannerWindow.m_cctbToolBar.GetToolBarCtrl().EnableButton(ID_BUTTONDELETE,FALSE);

			m_htiTreeRoots.RemoveAll();
			m_iwcoTreeRoots.RemoveAll();

			m_ctcTree.SetRedraw(FALSE);
			m_ctcTree.DeleteAllItems();
			m_ctcTree.SetRedraw(TRUE);

			m_bCancel = FALSE;
			PostMessage(CLEARNAMESPACE,0,0);
		}

		DestroyProgressDlgWindow();

		hItem = 0;
		hItem = m_ctcTree.GetRootItem();
		if (hItem)
		{
			m_ctcTree.SelectItem(hItem);
			m_ctcTree.SetFocus();
		}

		InvalidateControl();
		SetModifiedFlag();
		PostMessage(SETFOCUSTREE,0,0);
		m_bOpeningNamespace = FALSE;
		return TRUE;
	}
	else
	{
		CString csPrompt = _T("Cannot open ") + *pcsNameSpace +
							_T(".  ");
		int nReturn =
			MessageBox
			(
			csPrompt,
			_T("Namespace Open Error"),
			MB_OK  | 	MB_ICONEXCLAMATION | MB_DEFBUTTON1 |
			MB_APPLMODAL);
		PostMessage(SETFOCUSTREE,0,0);
		m_bOpeningNamespace = FALSE;
		return FALSE;
	}
}

// ***************************************************************************
//
// CClassNavCtrl::PreTranslateMessage
//
// Description:
//	  Used by class CWinApp to translate window messages before they are
//	  dispatched to the TranslateMessage and DispatchMessage Windows functions.
//
// Parameters:
//	  LPMSG lpMsg				The window message.
//
// Returns:
//	  BOOL						Nonzero if the message was translated and
//								should not be dispatched; 0 if the message
//								was not translated and should be dispatched.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CClassNavCtrl::PreTranslateMessage(LPMSG lpMsg)
{
	BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:

		if (lpMsg->wParam == VK_TAB)
		{
			return FALSE;
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (pWndFocus != NULL &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
				(_tcsicmp(szClass, _T("edit")) == 0)))
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		if (lpMsg->wParam == VK_RETURN)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (!pWndFocus)
			{
				break;
			}
			CRect crEdit;
			CRect crTree;
			CRect crIntersect;

			pWndFocus->GetWindowRect(&crEdit);
			m_ctcTree.GetWindowRect(&crTree);

			crEdit.NormalizeRect();
			crTree.NormalizeRect();
			BOOL bIntersect = crIntersect.IntersectRect(&crEdit,&crTree);

			if (bIntersect &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
				(_tcsicmp(szClass, _T("edit")) == 0)))
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		break;
	}

	// bug #51022 - Should call PreTranslateMessage, not PreTranslateInput
	return COleControl::PreTranslateMessage (lpMsg);



#if 0

	CWnd* pWndFocus = NULL;
	TCHAR szClass[40];
	szClass[0] = '\0';
	switch (lpMsg->message)
	{
	case WM_LBUTTONUP:

		pWndFocus = GetFocus();
		if (pWndFocus)
		{
			GetClassName(pWndFocus->m_hWnd, szClass, 39);
		}

		if ((pWndFocus != NULL) &&
			IsChild(pWndFocus) &&
			(szClass) &&
			(_tcsicmp(szClass, _T("EDIT")) == 0))
		{

		}
	break;
	case WM_KEYDOWN:
		if (lpMsg->wParam == VK_LEFT ||
			   lpMsg->wParam == VK_UP ||
			   lpMsg->wParam == VK_RIGHT ||
			   lpMsg->wParam == VK_DOWN||
			   lpMsg->wParam == VK_NEXT ||
			   lpMsg->wParam == VK_PRIOR ||
			   lpMsg->wParam == VK_HOME ||
			   lpMsg->wParam == VK_END
			   )
		  {
			   TCHAR szClass[40];
				CWnd* pWndFocus = GetFocus();
				if (((pWndFocus = GetFocus()) != NULL) &&
					IsChild(pWndFocus) &&
					GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
					((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
					(_tcsicmp(szClass, _T("edit")) == 0)))
				{
					pWndFocus->SendMessage(WM_KEYDOWN, lpMsg->wParam, lpMsg->lParam);
					return TRUE;
				}
		   }
		break;
   case WM_KEYUP:

	if (lpMsg->wParam == VK_RETURN)
	{
	// Allow combo box edit control to process a CR.
		pWndFocus = GetFocus();
		if (((pWndFocus = GetFocus()) != NULL) &&
			IsChild(pWndFocus) &&
			(pWndFocus->GetStyle() & ES_WANTRETURN) &&
			GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
			(_tcsicmp(szClass, _T("EDIT")) == 0))
		{
			pWndFocus->SendMessage(WM_CHAR, lpMsg->wParam, lpMsg->lParam);
			return TRUE;
		}
	}
	else if (lpMsg->wParam == VK_LEFT ||
			   lpMsg->wParam == VK_UP ||
			   lpMsg->wParam == VK_RIGHT ||
			   lpMsg->wParam == VK_DOWN ||
			   lpMsg->wParam == VK_NEXT ||
			   lpMsg->wParam == VK_PRIOR ||
			   lpMsg->wParam == VK_HOME ||
			   lpMsg->wParam == VK_END
			   )
	  {
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (((pWndFocus = GetFocus()) != NULL) &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
					(_tcsicmp(szClass, _T("edit")) == 0)))
			{
				pWndFocus->SendMessage(WM_KEYUP, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
	   }
      break;
	}

	BOOL b = COleControl::PreTranslateMessage(lpMsg);
	return b;
#endif


}


// ***************************************************************************
//
// CClassNavCtrl::OnPopupSearchforclass
//
// Description:
//	  Implements simple class search mechanism.  Should be replaced by
//	  a menu driven search rather than having the user type in the class name.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnPopupSearchforclass()
{


	CString csSelection = m_ctcTree.GetSelectionPath();

	BOOL bCanChangeSelection = QueryCanChangeSelection(csSelection);

	if (!bCanChangeSelection)
	{
		SetFocus();
		return;
	}

	CString csSave = "";
	BOOL bDone = FALSE;
	while(!bDone)
	{
		GetSearchDialog()->m_csSearchClass=csSave;
		PreModalDialog();
		int nReturn = (int) GetSearchDialog()->DoModal( );
		PostModalDialog();

		if (nReturn == IDCANCEL)
			return;

		HTREEITEM hItem;

		IWbemClassObject *pClass = GetSearchDialog()->GetSelectedObject();

		if (pClass == NULL) {
			return;
		}

		CWaitCursor cwcWait;


		CStringArray *pcsaPath = PathFromRoot (pClass) ;

#ifdef _DEBUG
			for (int index = 0; index < pcsaPath->GetSize(); index++)
			{
				afxDump << pcsaPath->GetAt(index) << "\n";

			}
#endif

		m_ctcTree.SetRedraw(FALSE);
		HTREEITEM hRoot;
		if (pcsaPath->GetSize() > 1)
		{
			HTREEITEM hChild;
			hChild = hRoot =
				FindObjectinClassRoots
					(&pcsaPath->GetAt(0));
			for (int i = 1; i < pcsaPath->GetSize(); i++)
			{

#ifdef _DEBUG
				afxDump << pcsaPath->GetAt(i) << "\n";

#endif
				IWbemClassObject *pObject = NULL;
				BSTR bstrTemp = pcsaPath->GetAt(i).AllocSysString();
				SCODE sc =
					m_pServices -> GetObject
						(bstrTemp,0,
						NULL,&pObject,NULL);
				::SysFreeString(bstrTemp);
				if (sc == S_OK)
				{
					hChild =
						m_ctcTree.FindObjectinChildren
						(hRoot, pObject);
					if (hChild)
					{
						hRoot = hChild;
					}
					else
					{
						ASSERT(FALSE);

						CString csUserMsg;
						csUserMsg.Format(_T("Cannot find class %s in tree"), pcsaPath->GetAt(i));
						csUserMsg += m_csNameSpace;
						ErrorMsg(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
					}
					pObject ->Release();
				}

			}
			hItem = hChild;
		}
		else	//the object is one of the root objects
		{
			 hRoot =
				FindObjectinClassRoots (&pcsaPath->GetAt(0));
			 hItem = hRoot;
		}


		delete pcsaPath;
		pClass->Release();
		m_ctcTree.SelectSetFirstVisible(hItem);
		m_ctcTree.SelectItem(hItem);
		m_ctcTree.SetFocus();
		bDone = TRUE;
		m_ctcTree.SetRedraw(TRUE);
	}


	m_ctcTree.UpdateWindow();
	m_ctcTree.RedrawWindow();

}

// ***************************************************************************
//
// CClassNavCtrl::OnUpdatePopupSearchforclass
//
// Description:
//	  Enable context menu item.
//
// Parameters:
//	  CCmdUI* pCmdUI			Represents the menu item.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnUpdatePopupSearchforclass(CCmdUI* pCmdUI)
{
	pCmdUI -> Enable(TRUE);
}

// ***************************************************************************
//
// CClassNavCtrl::OnPopupSelectall
//
// Description:
//	  Selects all of the tree items in terms of extended selection.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnPopupSelectall()
{
	m_ctcTree.SetExtendedSelection();
	m_bSelectAllMode = TRUE;
	m_bItemUnselected = FALSE;
}

// ***************************************************************************
//
// CClassNavCtrl::OnUpdatePopupSelectall
//
// Description:
//	  Enable or disable context menu item.
//
// Parameters:
//	  CCmdUI* pCmdUI			Represents the menu item.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnUpdatePopupSelectall(CCmdUI* pCmdUI)
{
	if (!m_bSelectAllMode)
	{
		pCmdUI -> Enable(TRUE);
	}
	else
	{
		if (m_bItemUnselected)
		{
			pCmdUI -> Enable(TRUE);
		}
		else
		{
			pCmdUI -> Enable(FALSE);
		}
	}
}

// ***************************************************************************
//
// CClassNavCtrl::OnReadySignal
//
// Description:
//	  Automation method that tells the control that it can now fire events.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnReadySignal()
{

	m_bReadySignal = TRUE;


	if (m_pServices)
	{
		return;
	}

	InitializeState(0,0);

	// bug#39985
	if(!m_hWnd)
		return;

	HTREEITEM hItem = m_ctcTree.GetSelectedItem();

	if (hItem)
	{
		IWbemClassObject *pItem =  (IWbemClassObject*)
			m_ctcTree.GetItemData(hItem);
		CString csItem =
			GetIWbemFullPath(GetServices(),pItem);
		if (m_bReadySignal)
		{
			COleVariant covClass;
			covClass = csItem;
			FireEditExistingClass(covClass);
#ifdef _DEBUG
			afxDump <<"CBanner::OnReadySignal(): m_pParent -> FireEditExistingClass(covClass); \n";
			afxDump << "     " << csItem << "\n";
#endif
		}
	}
	else
	{
		hItem = m_ctcTree.GetRootItem();
		if (hItem)
		{
			m_ctcTree.SelectItem(hItem);
			m_ctcTree.SetFocus();
		}
	}


}

// ***************************************************************************
//
// CClassNavCtrl::OnGetControlInfo
//
// Description:
//	  Called by the framework when the controls container has requested
//	  information about the control. This information consists primarily of
//	  a description of the controls mnemonic keys.
//
// Parameters:
//	  LPCONTROLINFO pControlInfo		Control info structure.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassNavCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
{
	pControlInfo->dwFlags |= CTRLINFO_EATS_RETURN;
	COleControl::OnGetControlInfo(pControlInfo);
}


void CClassNavCtrl::PassThroughGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	FireGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}


void CClassNavCtrl::InvalidateServer(LPCTSTR lpctstrServer)
{
	// TODO: Add your dispatch handler code here

}

//***************************************************************************
//
// InitServices
//
// Purpose:
//
//***************************************************************************

IWbemServices *CClassNavCtrl::InitServices
(CString *pcsNameSpace)
{
	CString csObjectPath;

	if (pcsNameSpace == NULL || pcsNameSpace->IsEmpty())
	{
		PreModalDialog();
		CInitNamespaceDialog cindInitNamespace;


		cindInitNamespace.m_pParent = this;

		m_pDlg = &cindInitNamespace;
		int nReturn = (int) cindInitNamespace.DoModal();
		m_pDlg = NULL;

		PostModalDialog();

		if (nReturn == IDOK)
		{
			csObjectPath = cindInitNamespace.GetNamespace();
			*pcsNameSpace = csObjectPath;
		}
		else
		{
			m_sc = S_OK;
			m_bUserCancel = TRUE;
			return NULL;
		}
	}
	else
	{
		 csObjectPath = *pcsNameSpace;
	}

    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;


    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

IWbemServices *CClassNavCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt == VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
		m_cbBannerWindow.m_cctbToolBar.
			GetToolBarCtrl().EnableButton(ID_BUTTONCLASSSEARCH,TRUE);
		m_bSelectAllMode = FALSE;
	}

	return pRealServices;
}
/*
BOOL CClassNavCtrl::OnHelpInfo(HELPINFO* pHelpInfo)
{
	// TODO: Add your message handler code here and/or call default

	WinHelp(0,HELP_FINDER);

	return TRUE;
}

*/



void CClassNavCtrl::OnSetClientSite()
{

	COleControl::OnSetClientSite();
}



void CClassNavCtrl::OnDestroy()
{
	m_ctcTree.SetImageList(NULL, TVSIL_NORMAL);
	m_ctcTree.SetImageList(NULL, TVSIL_STATE);

	delete m_pcilImageList;
	delete m_pcilStateImageList;
	delete m_pAddDialog;
	delete m_pRenameDialog;
	delete m_pSearchDialog;
	m_pcilImageList = NULL;
	m_pcilStateImageList = NULL;
	m_pAddDialog = NULL;
	m_pRenameDialog = NULL;
	m_pSearchDialog = NULL;

	COleControl::OnDestroy();

	// TODO: Add your message handler code here

}

void CClassNavCtrl::OnMenuitemrefresh()
{
	//bug#57686
	CString csSelection = m_ctcTree.GetSelectionPath();
	if (!QueryCanChangeSelection(csSelection))
	{
		SetFocus();
		return;
	}

	// TODO: Add your command handler code here
	if (m_hContextSelection)
	{
		IWbemClassObject *pClassObject
			= reinterpret_cast<IWbemClassObject *>
			(m_ctcTree.GetItemData( m_hContextSelection ));

		m_ctcTree.SetRedraw(FALSE);
		m_ctcTree.Expand(m_hContextSelection,TVE_COLLAPSE);
		m_ctcTree.SetRedraw(TRUE);
		CString csPath;
		if (pClassObject)
		{
			pClassObject->AddRef();

			HTREEITEM hParent = m_ctcTree.GetParentItem(m_hContextSelection);

			HTREEITEM hChild = m_ctcTree.GetChildItem(m_hContextSelection);
			m_ctcTree.SetRedraw(FALSE);
			while (hChild)
			{
				HTREEITEM hNextChild = m_ctcTree.GetNextSiblingItem(hChild);
				m_ctcTree.DeleteBranch(hChild);
				hChild = hNextChild;
			}
			m_ctcTree.SetRedraw(TRUE);

			int nSubs = GrowTree(m_hContextSelection, pClassObject);
			if (nSubs > 0)
			{
				TV_INSERTSTRUCT		tvstruct;
				tvstruct.item.hItem = m_hContextSelection;
				tvstruct.item.mask = TVIF_CHILDREN;
				tvstruct.item.cChildren = nSubs;
				m_ctcTree.SetItem(&tvstruct.item);
				m_ctcTree.EnsureVisible (m_hContextSelection);
			}
			m_ctcTree.Expand(m_hContextSelection,TVE_COLLAPSE);
		}
	}
	else if (m_ctcTree.GetRootItem() == NULL)
	{
		InitializeState(0,0);

	}
}

void CClassNavCtrl::OnUpdateMenuitemrefresh(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	if (m_hContextSelection)
	{
		pCmdUI -> Enable(TRUE);
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CClassNavCtrl::SetProgressDlgMessage(CString &csMessage)
{
	m_pProgressDlg->SetMessage(csMessage);
}

void CClassNavCtrl::SetProgressDlgLabel(CString &csLabel)
{
	m_pProgressDlg->SetLabel(csLabel);
}

void CClassNavCtrl::CreateProgressDlgWindow()
{
	PreModalDialog();
	m_pProgressDlg->Create(this);
}

BOOL CClassNavCtrl::CheckCancelButtonProgressDlgWindow()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		return m_pProgressDlg->CheckCancelButton();
	}

	return FALSE;
}

void CClassNavCtrl::DestroyProgressDlgWindow()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->DestroyWindow();
		PostModalDialog();
	}
}

void CClassNavCtrl::PumpMessagesProgressDlgWindow()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->PumpMessages();
	}
}

int CClassNavCtrl::GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, BOOL bShallow)
{

#ifdef _DEBUG
	DWORD d1 = GetTickCount();
#endif

	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	long lFlag = bShallow ? WBEM_FLAG_SHALLOW : WBEM_FLAG_DEEP;

	if (pcsParent)
	{
		BSTR bstrTemp = pcsParent->AllocSysString();
		sc = pIWbemServices->CreateClassEnum
		(bstrTemp,
		lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemClassObject);
		::SysFreeString(bstrTemp);

	}
	else
	{
		sc = pIWbemServices->CreateClassEnum
			(NULL,
			lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemClassObject);
	}
	if (sc != S_OK)
	{
		CString csUserMsg =
							_T("Cannot create a class enumeration ");
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return 0;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(m_csNameSpace,pIEnumWbemClassObject, pIWbemServices);
	}


	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray =
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	for (int i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}

	ULONG uReturned;

	HRESULT hResult =
			pIEnumWbemClassObject->Next(1000,N_INSTANCES,pInstanceArray, &uReturned);

	pIWbemClassObject = NULL;


	while(hResult == S_OK || hResult == WBEM_S_TIMEDOUT || uReturned > 0)
	{

#pragma warning( disable :4018 )
		for (int c = 0; c < uReturned; c++)
#pragma warning( default : 4018 )
		{
			pIWbemClassObject = pInstanceArray[c];
			cpaClasses.Add(reinterpret_cast<void *>(pIWbemClassObject));
			pimcoInstances[c] = NULL;
			pIWbemClassObject = NULL;
		}

		m_bCancel = CheckCancelButtonProgressDlgWindow();

		if (m_bCancel)
		{
			for (int i = 0; i < cpaClasses.GetSize(); i++)
			{
				IWbemClassObject     *pObject =
					reinterpret_cast<IWbemClassObject *>(cpaClasses.GetAt(i));
				pObject->Release();
			}
			cpaClasses.RemoveAll();
			break;
		}

		uReturned = 0;
		hResult = pIEnumWbemClassObject->Next
			(1000,N_INSTANCES,pInstanceArray, &uReturned);
	}

	pIEnumWbemClassObject -> Release();

	return (int) cpaClasses.GetSize();

}

void CClassNavCtrl::MofCompiled(LPCTSTR lpctstrNamespace)
{
	// TODO: Add your dispatch handler code here
	CString csNamespace = lpctstrNamespace;

	if (csNamespace.IsEmpty())
	{
		return;
	}

	BOOL bReturn;
	if (m_csNameSpace.IsEmpty())
	{
		m_cbBannerWindow.m_pnseNameSpace->SetNamespaceText((LPCTSTR)csNamespace);
		m_cbBannerWindow.UpdateWindow();
		m_cbBannerWindow.RedrawWindow();
		bReturn = OpenNameSpace(&csNamespace);
		if (bReturn)
		{
				m_cbBannerWindow.OpenNamespace(&csNamespace,TRUE);

		}
		PostMessage(SETFOCUSNSE,0,0);
	}
	else if (m_csNameSpace.CompareNoCase(csNamespace))
	{
		m_cbBannerWindow.m_pnseNameSpace->SetNamespaceText((LPCTSTR)csNamespace);
		m_cbBannerWindow.UpdateWindow();
		m_cbBannerWindow.RedrawWindow();
		bReturn = OpenNameSpace(&csNamespace);
		if (bReturn)
		{
			m_cbBannerWindow.OpenNamespace(&csNamespace,TRUE);

		}
		PostMessage(SETFOCUSNSE,0,0);
	}
	else
	{
		bReturn = OpenNameSpace(&m_csNameSpace);
		if (bReturn)
		{
			m_cbBannerWindow.OpenNamespace(&csNamespace,TRUE);

		}
		PostMessage(SETFOCUSNSE,0,0);
	}

}


void CClassNavCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	COleControl::OnLButtonUp(nFlags, point);
}

void CClassNavCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	Refresh();
}

LRESULT CClassNavCtrl::SetFocusTree(WPARAM, LPARAM)
{

	m_ctcTree.SetFocus();
	return 0;
}

LRESULT CClassNavCtrl::SetFocusNSE(WPARAM, LPARAM)
{
	m_cbBannerWindow.m_pnseNameSpace->SetFocus();
	return 0;
}

LRESULT CClassNavCtrl::ClearNamespace(WPARAM, LPARAM)
{
	CString csText = m_cbBannerWindow.m_pnseNameSpace->GetNamespaceText();
	if (!csText.IsEmpty())
	{
		m_cbBannerWindow.m_pnseNameSpace->ClearNamespaceText((LPCTSTR) csText);
		m_cbBannerWindow.UpdateWindow();
		m_cbBannerWindow.RedrawWindow();
	}
	return 0;
}

int CClassNavCtrl::PartitionClasses(CPtrArray *pcpaDeepEnum, CPtrArray *pcpaShallowEnum, CString csClass)
{

	int cEnum = (int) pcpaDeepEnum->GetSize();
	CDWordArray cdwaRoots;
	int i;

	for (i = 0; i < cEnum; i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(pcpaDeepEnum->GetAt(i));
		CString csSuper = GetIWbemSuperClass(pObject);
		if (csSuper.CompareNoCase(csClass) == 0)
		{
			pcpaShallowEnum->Add(pObject);
			cdwaRoots.Add(i);
		}
	}

	for (i = ((int) cdwaRoots.GetSize()) - 1; i >= 0; i--)
	{
		pcpaDeepEnum->RemoveAt(cdwaRoots.GetAt(i));

	}

	return ((int) pcpaShallowEnum->GetSize());

}

void CClassNavCtrl::ReleaseObjects(CPtrArray *pcpaEnum)
{

	int cEnum = (int) pcpaEnum->GetSize();
	int i;

	for (i = 0; i < cEnum; i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(pcpaEnum->GetAt(i));
		if (pObject)
		{
			pObject->Release();
		}
	}
}

void CClassNavCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

#ifdef _DEBUG
	afxDump << _T("Before COleControl::OnActivateInPlace in CClassNavCtrl::OnSetFocus\n");
#endif
	// TODO: Add your message handler code here

	OnActivateInPlace(TRUE,NULL);

	if (m_bRestoreFocusToTree)
	{
		m_ctcTree.SetFocus();
	}
	else
	{
		m_cbBannerWindow.SetFocus();
	}


#ifdef _DEBUG
	afxDump << _T("After COleControl::OnActivateInPlace in CClassNavCtrl::OnSetFocus\n");
#endif
}


BOOL CClassNavCtrl::QueryCanChangeSelection(CString &rcsSelection)
{

	if (rcsSelection.GetLength() == 0)
	{
		return TRUE;
	}

	VARIANT varScode;
	VariantInit(&varScode);
	varScode.vt = VT_I4;
	varScode.lVal = S_OK;
	if (m_bReadySignal)
	{
		FireQueryCanChangeSelection ((LPCTSTR) rcsSelection, &varScode);
	}
	SCODE sc = varScode.lVal;
	VariantClear(&varScode);

	BOOL bCanChangeSelection = (sc == E_FAIL ? FALSE: TRUE);
	return bCanChangeSelection;

}

/*	EOF:  ClassNavCtl.cpp */

void CClassNavCtrl::OnPopupAddclass()
{
	// TODO: Add your command handler code here
	IWbemClassObject *pimcoItem =
			reinterpret_cast<IWbemClassObject *>(m_ctcTree.GetItemData(m_hContextSelection));
	CString csPath = GetIWbemClass(pimcoItem);
	m_cbBannerWindow.AddClass(&csPath, m_hContextSelection);
}

void CClassNavCtrl::OnUpdatePopupAddclass(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	if (m_hContextSelection)
	{
		pCmdUI -> Enable(TRUE);
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CClassNavCtrl::OnPopupDeleteclass()
{
	// bug#57685
	if(!m_hContextSelection)
		return;
	// TODO: Add your command handler code here
	IWbemClassObject *pimcoItem =
			reinterpret_cast<IWbemClassObject *>(m_ctcTree.GetItemData(m_hContextSelection));
	CString csPath = GetIWbemClass(pimcoItem);
	m_cbBannerWindow.DeleteClass(&csPath, m_hContextSelection);
}

void CClassNavCtrl::OnUpdatePopupDeleteclass(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	if (m_hContextSelection)
	{
		IWbemClassObject *pItem =
			reinterpret_cast<IWbemClassObject *>(m_ctcTree.GetItemData(m_hContextSelection));

		if (!pItem)
		{
			pCmdUI -> Enable(FALSE);
			return;
		}

		CString csClass = _T("__Class");
		CString m_csSelection = ::GetProperty(pItem, &csClass);

		if (m_csSelection[0] == '_' &&  m_csSelection[1] == '_')
		{
			pCmdUI -> Enable(FALSE);
			return;
		}
	}
	// bug#57685
	if(!m_hContextSelection)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	pCmdUI -> Enable(TRUE);
}

void CClassNavCtrl::OnPopupRenameclass()
{
	// TODO: Add your command handler code here
	if (m_hContextSelection)
	{
		m_ctcTree.EditLabel(m_hContextSelection);
	}
}

void CClassNavCtrl::OnUpdatePopupRenameclass(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	if (m_hContextSelection)
	{
		IWbemClassObject *pItem =
			reinterpret_cast<IWbemClassObject *>(m_ctcTree.GetItemData(m_hContextSelection));

		if (!pItem)
		{
			pCmdUI -> Enable(FALSE);
			return;
		}

		CString csClass = _T("__Class");
		CString m_csSelection = ::GetProperty(pItem, &csClass);

		if (m_csSelection[0] == '_' &&  m_csSelection[1] == '_')
		{
			pCmdUI -> Enable(FALSE);
			return;
		}

		if (m_ctcTree.ItemHasChildren(m_hContextSelection))
		{
			pCmdUI -> Enable(FALSE);
			return;
		}
	}
	// bug#57685
	if(!m_hContextSelection)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	pCmdUI -> Enable(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavctl.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: ClassNavCtl.h
//
// Description:
//	This file declares the CClassNavCtrl ActiveX control class.
//	The CClassNavCtrl class is a part of the Class Explorer OCX, it
//  is a subclass of the Mocrosoft COleControl class and performs
//	the following functions:
//		a.  Displays the class hierarchy
//		b.  Allows classes to be added and deleted
//		c.  Searches for classes in the tree
//		d.  Implements automation properties, methods and events.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#ifndef _CLASSNAVCTL_H_
#define _CLASSNAVCTL_H_

//****************************************************************************
//
// CLASS:  CClassNavCtrl
//
// Description:
//	This class is a subclass of the Microsoft COleControl class.  It
//	specializes the class to bea able to interact with the HMM database and
//	display HMM class data.
//
// Public members:
//
//	CClassNavCtrl
//	GetSelection
//	GetSelectionClassName
//	GetServices
//
//============================================================================
//	CClassNavCtrl		Public constructor.
//	GetSelection		Returns the currently selected tree item.
//	GetSelectionClassName
//						Returns the class name of the currently selected tree
//						item
//	GetServices			Returns a pointer to the the IWbemServices COM object
//						instance
//
//============================================================================
//
//  CClassNavCtrl::CClassNavCtrl
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
//  CClassNavCtrl::GetSelection
//
// Description:
//	  This member function returns the currently selected tree item.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  HTREEITEM		The tree control item currently selected.
//
//============================================================================
//
//  CClassNavCtrl::GetSelectionClassName
//
// Description:
//	  This member function returns the class name of the currently selected
//	  tree item
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CString		Currently selected tree item's class name.
//
//============================================================================
//
//  CClassNavCtrl::GetServices
//
// Description:
//	  This member function returns a pointer to the the IWbemServices COM object
//	  instance
//
// Parameters:
//	  VOID
//
// Returns:
// 	  IWbemServices *		Pointer to the Wbem Services COM object.
//
//****************************************************************************


const int IDC_ADD = 1;
const int IDC_DELETE = 2;
const int IDC_TREE = 3;
const int IDC_NSENTRY = 4;
const int IDC_NAMESPACE = 6;
const int IDC_TOOLBAR = 5;

const int nSideMargin = 10;
const int nTopMargin = 6;


struct IWbemServices;

class CAddDialog;
class CRenameClassDIalog;
class CClassSearch;
class CClassNavNSEntry;
class CProgressDlg;
class CInitNamespaceDialog;


#define INITIALIZE_NAMESPACE WM_USER + 300
#define FIRE_OPEN_NAMESPACE WM_USER + 390
#define REDRAW_CONTROL WM_USER + 590
#define SETFOCUSTREE WM_USER + 591
#define SETFOCUSNSE WM_USER + 592
#define CLEARNAMESPACE WM_USER + 593

class CClassNavCtrl : public COleControl
{
	DECLARE_DYNCREATE(CClassNavCtrl)

public:
	// Constructor
	CClassNavCtrl();

	HTREEITEM GetSelection()
	{
		HTREEITEM hItem = m_ctcTree.GetSelectedItem();
		if(!hItem)
			hItem = m_ctcTree.GetChildItem(TVI_ROOT);
		return hItem;
	}
	CString GetSelectionClassName();

	IWbemServices *GetServices() {return m_pServices;}
	BOOL OpenNameSpace(CString *pcsNameSpace);
	BOOL QueryCanChangeSelection(CString &rcsPath);

	CString GetCurrentNamespace(){return m_csNameSpace;}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassNavCtrl)
	public:
	virtual void OnSetClientSite();
	protected:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL DestroyWindow();
	virtual DWORD GetControlFlags();
	virtual BOOL PreTranslateMessage(LPMSG pMsg);
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnDrawMetafile(CDC* pDC, const CRect& rcBounds);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// bug#39985
	CDialog *m_pDlg;
	CString m_csSave;

	virtual HRESULT OnHide()
	{
		if(m_pDlg)
			m_pDlg->EndDialog(IDCANCEL);
		return COleControl::OnHide();
	}


	CString m_csNameSpace;
	BOOL m_bDrawAll;
	BOOL m_bSelectAllMode;
	~CClassNavCtrl();

	BOOL m_bOpeningNamespace;

	void InitializeTreeForDrawing();
	void InitializeState();
	int GrowTree(HTREEITEM hParent, IWbemClassObject *pParent);

	void PopulateTree();
	void PopulateTree(HTREEITEM hRoot, CString szRoot, CSchemaInfo &schema, BOOL bSelf = FALSE);

	CClassTree *GetTree() {return &m_ctcTree;}

	BOOL m_bItemUnselected;

	long m_nBitmaps;
	CImageList *m_pcilImageList;
	CImageList *m_pcilStateImageList;

	CPtrArray m_iwcoTreeRoots;
	CPtrArray m_htiTreeRoots;

	BOOL m_bCancel;

	IWbemServices *m_pServices;

	BOOL m_bReadySignal;

	// Selection and extended selection
	CPtrArray	m_cpaExtendedSelections;

	HTREEITEM m_hContextSelection;

	// Contained controls (in the Class Navigator control).
	CClassTree m_ctcTree;
	CBanner m_cbBannerWindow;
	CString m_csBanner;

	BOOL m_bRestoreFocusToTree;

	CRect m_rBannerRect;
	CRect m_rFilter;
	CRect m_rNameSpace;
	CRect m_rNameSpaceRect;
	CRect m_rTreeRect;
	CRect m_rTree;
	CRect m_rAdd;
	CRect m_rDelete;

	int m_nOffset;

	CAddDialog *m_pAddDialog;
	CRenameClassDIalog* m_pRenameDialog;
	CClassSearch *m_pSearchDialog;
	CProgressDlg *m_pProgressDlg;

	BOOL m_bInit;
	BOOL m_bChildrenCreated;
	long m_lWidth;
	long m_lHeight;

	BOOL m_bInOnDraw;
	BOOL m_bFirstDraw;
	void InitializeChildControlSize(int cx, int cy);
	void SetChildControlGeometry(int cx, int cy);

	BOOL m_bMetricSet;
	TEXTMETRIC m_tmFont;
	CFont m_cfFont;
	CString m_csFontName;
	short m_nFontWeight;
	short m_nFontHeight;
	void CreateControlFont();
	void InitializeLogFont(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);

	int ObjectClassBitmap() {return SCHEMA_CLASS;}
	int ObjectClassCheckedBitmap() {return SCHEMA_CLASS;}
	int AssocClassBitmap() {return SCHEMA_ASSOC;}
	int AssocClassCheckedBitmap() {return SCHEMA_ASSOC;}

	CAddDialog *GetAddDialog() {return m_pAddDialog;}
	CClassSearch *GetSearchDialog() {return m_pSearchDialog;}
	CRenameClassDIalog *GetRenameDialog() {return m_pRenameDialog;}

	CPtrArray *GetTreeRoots() {return &m_htiTreeRoots;}
	CPtrArray *GetClassRoots() {return &m_iwcoTreeRoots;}

	void RemoveObjectFromClassRoots(IWbemClassObject *pClassObject);
	void RemoveItemFromTreeItemRoots(HTREEITEM hItem);

	BOOL IsTreeItemARoot(HTREEITEM hItem);

	SAFEARRAY *GetExtendedSelectionSelectAllMode();
	IWbemClassObject *GetOLEMSObject (CString *pcsClass);
	HTREEITEM FindObjectinClassRoots(CString *csClassObject);

	BOOL m_bOpenedInitialNamespace;

	enum BitmapIndex
	{
			BITMAPOBJECTCLASS = 0,
			BITMAPOBJECTCLASSCHECKED,
			BITMAPASSOCCLASS,
			BITMAPASSOCCLASSCHECKED
	};

	SCODE m_sc;
	BOOL m_bUserCancel;

	IWbemServices *InitServices(CString *pcsNameSpace = NULL);

	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	void PassThroughGetIWbemServices
		(	LPCTSTR lpctstrNamespace,
			VARIANT FAR* pvarUpdatePointer,
			VARIANT FAR* pvarServices,
			VARIANT FAR* pvarSC,
			VARIANT FAR* pvarUserCancel);


	int GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, BOOL bShallow = TRUE);

	int PartitionClasses(CPtrArray *pcpaDeepEnum, CPtrArray *pcpaShallowEnum, CString csClass);
	void ReleaseObjects(CPtrArray *pcpaEnum);

	void SetProgressDlgMessage(CString &csMessage);
	void SetProgressDlgLabel(CString &csLabel);
	void CreateProgressDlgWindow();
	BOOL CheckCancelButtonProgressDlgWindow();
	void DestroyProgressDlgWindow();
	void PumpMessagesProgressDlgWindow();

	DECLARE_OLECREATE_EX(CClassNavCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CClassNavCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CClassNavCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CClassNavCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CClassNavCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClearextendedselection();
	afx_msg void OnUpdateClearextendedselection(CCmdUI* pCmdUI);
	afx_msg void OnPopupSearchforclass();
	afx_msg void OnUpdatePopupSearchforclass(CCmdUI* pCmdUI);
	afx_msg void OnPopupSelectall();
	afx_msg void OnUpdatePopupSelectall(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	afx_msg void OnMenuitemrefresh();
	afx_msg void OnUpdateMenuitemrefresh(CCmdUI* pCmdUI);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnPopupAddclass();
	afx_msg void OnUpdatePopupAddclass(CCmdUI* pCmdUI);
	afx_msg void OnPopupDeleteclass();
	afx_msg void OnUpdatePopupDeleteclass(CCmdUI* pCmdUI);
	afx_msg void OnPopupRenameclass();
	afx_msg void OnUpdatePopupRenameclass(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg LRESULT InitializeState(WPARAM, LPARAM);
	afx_msg LRESULT FireOpenNamespace(WPARAM, LPARAM);
	afx_msg LRESULT RedrawAll(WPARAM, LPARAM);
	afx_msg LRESULT SetFocusTree(WPARAM, LPARAM);
	afx_msg LRESULT SetFocusNSE(WPARAM, LPARAM);
	afx_msg LRESULT ClearNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CClassNavCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg VARIANT GetExtendedSelection();
	afx_msg BSTR GetSingleSelection();
	afx_msg void OnReadySignal();
	afx_msg void InvalidateServer(LPCTSTR lpctstrServer);
	afx_msg void MofCompiled(LPCTSTR lpctstrNamespace);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();
public:
// Event maps
	//{{AFX_EVENT(CClassNavCtrl)
	void FireEditExistingClass(const VARIANT FAR& vExistingClass)
		{FireEvent(eventidEditExistingClass,EVENT_PARAM(VTS_VARIANT), &vExistingClass);}
	void FireNotifyOpenNameSpace(LPCTSTR lpcstrNameSpace)
		{FireEvent(eventidNotifyOpenNameSpace,EVENT_PARAM(VTS_BSTR), lpcstrNameSpace);}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	void FireQueryCanChangeSelection(LPCTSTR lpctstrFullPath, VARIANT FAR* pvarSCode)
		{FireEvent(eventidQueryCanChangeSelection,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT), lpctstrFullPath, pvarSCode);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CClassNavCtrl)
	dispidNameSpace = 1L,
	dispidGetExtendedSelection = 2L,
	dispidGetSingleSelection = 3L,
	dispidOnReadySignal = 4L,
	dispidInvalidateServer = 5L,
	dispidMofCompiled = 6L,
	eventidEditExistingClass = 1L,
	eventidNotifyOpenNameSpace = 2L,
	eventidGetIWbemServices = 3L,
	eventidQueryCanChangeSelection = 4L,
	//}}AFX_DISP_ID
	};
private:
	friend class CClassTree;
	friend class CBanner;
	friend class CNameSpace;
	friend class CClassNavNSEntry;
	friend class CInitNamespaceDialog;
};

#endif	// _CLASSNAVCTL_H_


// C:\Program Files\Microsoft Visual Studio\VB98\Vb6.exe
// D:\Wbem11\ActiveXSuite\Test\Controls\VB\Ryan40385\Project1.vbp

// c:\inetpub\wwwroot\wbem\studio.htm

/*	EOF:  ClassNavCtl.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavnsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __CLASSNAVNSENTRY_H__
#define __CLASSNAVNSENTRY_H__

class CClassNavCtrl;

class CClassNavNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CClassNavNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassNavNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CClassNavNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid);
			afx_msg void OnNameSpaceRedrawn() ;
			afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) ;
			afx_msg void OnRequestUIActive() ;
			afx_msg void OnChangeFocus(long lGettingFocus);
		//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CClassNavNSEntry();
	void SetLocalParent(CClassNavCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CClassNavCtrl* m_pParent;
};

#endif // __CLASSNAVNSENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavnsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "nsentry.h"
#include "ClassNavNSEntry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClassNavNSEntry

IMPLEMENT_DYNCREATE(CClassNavNSEntry,CNSEntry)

CClassNavNSEntry::CClassNavNSEntry()
{



}

BEGIN_MESSAGE_MAP(CClassNavNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CClassNavNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CClassNavNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CClassNavNSEntry)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CClassNavNSEntry,1,OnNameSpaceChanged,VTS_BSTR VTS_I4)
	ON_EVENT_REFLECT(CClassNavNSEntry,2,OnNameSpaceRedrawn,VTS_NONE)
	ON_EVENT_REFLECT(CClassNavNSEntry,3,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CClassNavNSEntry,4,OnRequestUIActive,VTS_NONE)
	ON_EVENT_REFLECT(CClassNavNSEntry,5,OnChangeFocus,VTS_I4)
END_EVENTSINK_MAP()

void CClassNavNSEntry::OnChangeFocus(long lGettingFocus)
{
	if (!lGettingFocus)
	{
		m_pParent->m_bRestoreFocusToTree = FALSE;
	}

}

void CClassNavNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid)
{
	// TODO: Add your control notification handler code here
	if (!longValid)
	{
		m_pParent->InvalidateControl();
		return;
	}

	CString csNameSpace = bstrNewNameSpace;
	m_pParent->m_bOpeningNamespace = TRUE;
	m_pParent->OpenNameSpace(&csNameSpace);
	m_pParent->m_bOpeningNamespace = FALSE;
	m_pParent->InvalidateControl();
}


void CClassNavNSEntry::OnNameSpaceRedrawn()
{
	m_pParent->m_cbBannerWindow.NSEntryRedrawn();
}

void CClassNavNSEntry::OnRequestUIActive()
{
	m_pParent->OnActivateInPlace(TRUE,NULL);
}

void CClassNavNSEntry::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ClassNavPpg.cpp : Implementation of the CClassNavPropPage property page class.

#include "precomp.h"
#include "ClassNav.h"
#include "ClassNavPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CClassNavPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CClassNavPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CClassNavPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CClassNavPropPage, "WBEM.ClassNavPropPage.1",
	0xc587b674, 0x103, 0x11d0, 0x8c, 0xa2, 0, 0xaa, 0, 0x6d, 0x1, 0xa)


/////////////////////////////////////////////////////////////////////////////
// CClassNavPropPage::CClassNavPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CClassNavPropPage

BOOL CClassNavPropPage::CClassNavPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_CLASSNAV_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CClassNavPropPage::CClassNavPropPage - Constructor

CClassNavPropPage::CClassNavPropPage() :
	COlePropertyPage(IDD, IDS_CLASSNAV_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CClassNavPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CClassNavPropPage::DoDataExchange - Moves data between page and properties

void CClassNavPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CClassNavPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CClassNavPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classnavppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ClassNavPpg.h : Declaration of the CClassNavPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CClassNavPropPage : See ClassNavPpg.cpp.cpp for implementation.

class CClassNavPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CClassNavPropPage)
	DECLARE_OLECREATE_EX(CClassNavPropPage)

// Constructor
public:
	CClassNavPropPage();

// Dialog Data
	//{{AFX_DATA(CClassNavPropPage)
	enum { IDD = IDD_PROPPAGE_CLASSNAV };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CClassNavPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\editinput.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: EditInput.cpp
//
// Description:
//	This file implements the CEditInput class which is a subclass
//	of the MFC CEdit class.  It is a part of the Class Explorer OCX,
//	and it performs the following functions:
//		a.  Is used to dynamically subclass the edit control in
//			the CNameSpace combo box class.  It only exists because
//			a carriage return is not seen by the edit control using
//			the normal mechanisms in the Internet Explorer.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CNameSpace
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "classnav.h"
#include "EditInput.h"
#include "NameSpace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CEditInput, CEdit)
	//{{AFX_MSG_MAP(CEditInput)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
// CEditInput::OnChar
//
// Description:
//	  Called by the framework to handle character input.  We use it to
//	  send a CNS_EDITDONE message to the CNameSpace combo box.
//
// Parameters:
//	  nChar		Contains the character code value of the key.
//	  nRepCnt   Contains the repeat count.
//	  nFlags	Contains the scan code, key-transition code, previous key
//				state, and context code.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CEditInput::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_pParent && (nChar == 13))
	{
		m_pParent->SendMessage(CNS_EDITDONE,0,0);
	}

	CEdit::OnChar(nChar, nRepCnt, nFlags);
}

/*	EOF:  EditInput.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\editinput.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: EditInput.h
//
// Description:
//	This file declares the CEditInput class which is a subclass
//	of the MFC CEdit class.  It is a part of the Class Explorer OCX, 
//	and it performs the following functions:
//		a.  Is used to dynamically subclass the edit control in
//			the CNameSpace combo box class.  It only exists because 
//			a carriage return is not seen by the edit control using
//			the normal mechanisms in the Internet Explorer. 
//
// Part of: 
//	ClassNav.ocx 
//
// Used by:
//	CNameSpace 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CEditInput
//
// Description:
//	  This class which is a subclass of the MFC CEdit class.  It allows a 
//	  carriage return to bee seen by the edit control in the CNameSpace
//	  combo box.  When a carriage return is seen a CNS_EDITDONE message
//	  is sent to the combo box.
//
// Public members:
//	
//	  CEditInput		Public constructor.
//	  SetLocalParent	Initialize the member var that holds the CNameSpace
//						object. 
//
//============================================================================
//
// CEditInput::CEditInput
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  NONEnt
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CEditInput::SetLocalParent
//
// Description:
//	  Initialize the member var that holds the CNameSpace  object. 
//
// Parameters:
//	  CNameSpace *pParent	 Containing CNameSpace object.		
//
// Returns:
// 	  VOID
//
//****************************************************************************

#ifndef _CEditInput_H_
#define _CEditInput_H_

class CNameSpace;

class CEditInput : public CEdit
{

public:
	CEditInput(){m_pParent = NULL;}
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditInput)
	//}}AFX_VIRTUAL
	void SetLocalParent(CNameSpace *pParent){m_pParent = pParent;}

protected:
	CNameSpace *m_pParent;
	//{{AFX_MSG(CEditInput)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#endif

/*	EOF:  EditInput.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classsearch.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: classsearch.h
//
// Description:
//	This file declares the CClassSearch class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX, 
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a class to search
//			for.  The actual search is performed by the CClassNavCtl 
//			class. 
//
// Part of: 
//	ClassNav.ocx 
//
// Used by:
//	CClassNavCtrl 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CClassSearch
//
// Description:
//	  This class which is a subclass of the MFC CDialog class.  It allows the 
//	  user to type in the name of a class to search for.  The actual search 
//	  is performed by the CClassNavCtl class. 
//
// Public members:
//	
//	  CClassSearch			Public constructor.
//	  m_csSearchClass;		The string entered by the user.	  
//
//============================================================================
//
// CClassSearch::CClassSearch
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//****************************************************************************

#ifndef _CClassSearch_H_
#define _CClassSearch_H_


class CClassSearch : public CDialog
{

// Construction
public:
	CString GetSelectedClassName();
	IWbemClassObject * GetSelectedObject();
	CClassSearch(CClassNavCtrl* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CClassSearch)
	enum { IDD = IDD_DIALOGSEARCHFORCLASS };
	CButton	m_ctrlCheckClassNames;
	CListBox	m_lbSearchResults;
	CString	m_csSearchClass;
	BOOL	m_bSearchProperties;
	BOOL	m_bSearchDescriptions;
	BOOL	m_bSearchClassNames;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassSearch)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	 CClassNavCtrl *m_pParent;
	// Generated message map functions
	//{{AFX_MSG(CClassSearch)
	afx_msg void OnButtonSearch();
	afx_msg void OnDblclkListSearchResults();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelchangeListSearchResults();
	afx_msg void OnSetfocusEdit1();
	afx_msg void OnCheckSearchClass();
	afx_msg void OnCheckSearchDescriptions();
	afx_msg void OnCheckSearchProperties();
	afx_msg void OnUpdateEdit1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	HRESULT CheckDescriptionForPattern (IWbemClassObject * pObj, CString& pattern);
	HRESULT CheckPropertyNamesForPattern (IWbemClassObject * pObj, CString& pattern);
	HRESULT CheckClassNameForPattern (IWbemClassObject * pObj, CString& pattern);
	HRESULT DoSearch();
	void UpdateOKButtonState();
	void UpdateSearchButtonState();
	CString m_csSelectedClass;
	CMapStringToPtr m_mapNamesToObjects;
	IWbemClassObject * m_pSelectedObject;

	void CleanupMap();

};

#endif

/*	EOF:  CClassSearch.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\classsearch.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: classsearch.h
//
// Description:
//	This file implements the CClassSearch class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX,
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a class to search
//			for.  The actual search is performed by the CClassNavCtl
//			class.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CClassNavCtrl
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "resource.h"
#include "classnav.h"
#include "wbemidl.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "AddDialog.h"

#include "ClassSearch.h"
#include "olemsclient.h"
#include "comdef.h"
#include "logindlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CHUNK_SIZE 500

// ***************************************************************************
//
// CClassSearch::CClassSearch
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CClassSearch::CClassSearch(CClassNavCtrl* pParent)
	: CDialog(CClassSearch::IDD, NULL)
{
	//{{AFX_DATA_INIT(CClassSearch)
	m_csSearchClass = _T("");
	m_bSearchProperties = FALSE;
	m_bSearchDescriptions = FALSE;
	m_bSearchClassNames = TRUE;

	//}}AFX_DATA_INIT
	m_pParent = pParent;
}

// ***************************************************************************
//
// CClassSearch::DoDataExchange
//
// Description:
//	  Called by the framework to exchange and validate dialog data.
//
// Parameters:
//	  pDX			A pointer to a CDataExchange object.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CClassSearch::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClassSearch)
	DDX_Control(pDX, IDC_CHECK_SEARCH_CLASS, m_ctrlCheckClassNames);
	DDX_Control(pDX, IDC_LIST_SEARCH_RESULTS, m_lbSearchResults);
	DDX_Text(pDX, IDC_EDIT1, m_csSearchClass);
	DDX_Check(pDX, IDC_CHECK_SEARCH_PROPERTIES, m_bSearchProperties);
	DDX_Check(pDX, IDC_CHECK_SEARCH_DESCRIPTIONS, m_bSearchDescriptions);
	DDX_Check(pDX, IDC_CHECK_SEARCH_CLASS, m_bSearchClassNames);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClassSearch, CDialog)
	//{{AFX_MSG_MAP(CClassSearch)
	ON_BN_CLICKED(IDC_BUTTON_SEARCH, OnButtonSearch)
	ON_LBN_DBLCLK(IDC_LIST_SEARCH_RESULTS, OnDblclkListSearchResults)
	ON_LBN_SELCHANGE(IDC_LIST_SEARCH_RESULTS, OnSelchangeListSearchResults)
	ON_EN_SETFOCUS(IDC_EDIT1, OnSetfocusEdit1)
	ON_BN_CLICKED(IDC_CHECK_SEARCH_CLASS, OnCheckSearchClass)
	ON_BN_CLICKED(IDC_CHECK_SEARCH_DESCRIPTIONS, OnCheckSearchDescriptions)
	ON_BN_CLICKED(IDC_CHECK_SEARCH_PROPERTIES, OnCheckSearchProperties)
	ON_EN_UPDATE(IDC_EDIT1, OnUpdateEdit1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*	EOF:  CClassSearch.cpp */

///////////////////////////////////////////////////////////////////////////////////////
void CClassSearch::OnButtonSearch()
{
	CleanupMap();
	m_lbSearchResults.ResetContent();

	UpdateData();
	m_csSearchClass.TrimLeft();
	m_csSearchClass.TrimRight();
	if (m_csSearchClass.IsEmpty()) {
		return;
	}

	BeginWaitCursor();

	HRESULT hr = DoSearch();

	if (FAILED (hr)) {
		m_lbSearchResults.AddString(_T("Search failed"));
		return;
	}

	//if no objects were found
	if (m_mapNamesToObjects.IsEmpty()) {
		m_lbSearchResults.AddString(_T("No matches"));
	}

   POSITION pos;
   IWbemClassObject * pObj;
   CString key;

   for( pos = m_mapNamesToObjects.GetStartPosition(); pos != NULL; )   {
	   m_mapNamesToObjects.GetNextAssoc( pos, key, (void*&)pObj );

	   m_lbSearchResults.AddString(key);
   }


	UpdateOKButtonState();

	EndWaitCursor();

	DWORD time1 = GetTickCount();


	//clean up all messages from the message queue: in case user was clicking
	//with the hourglass on...
	MSG msg;
	while (PeekMessage(&msg, m_hWnd, 0, WM_USER - 1, PM_NOREMOVE)) {
		if (time1 < msg.time) {
			break;
		}
		else {
			//remove the message
			PeekMessage(&msg, m_hWnd, 0, WM_USER - 1, PM_REMOVE);
		}
	}

}

//*************************************************************************************
//		Set selected object and close the dialog
//*************************************************************************************
void CClassSearch::OnDblclkListSearchResults()
{

	OnOK();
}

IWbemClassObject * CClassSearch::GetSelectedObject()
{
	return m_pSelectedObject;

}
BOOL CClassSearch::OnInitDialog()
{
	CDialog::OnInitDialog();

	//make "Search" button the default
	SetDefID(IDC_BUTTON_SEARCH);

	//disable "Search" button until text is entered into edit box
	GetDlgItem(IDC_BUTTON_SEARCH)->EnableWindow(FALSE);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CClassSearch::CleanupMap()
{
   POSITION pos;
   IWbemClassObject * pObj;
   CString key;

   for( pos = m_mapNamesToObjects.GetStartPosition(); pos != NULL; )   {

	   m_mapNamesToObjects.GetNextAssoc( pos, key, (void*&)pObj );
	   pObj->Release();
   }

   m_mapNamesToObjects.RemoveAll();

}

void CClassSearch::OnOK()
{

	int index = m_lbSearchResults.GetCurSel();
	if (index == LB_ERR) {

		//nothing is selected

		m_pSelectedObject = NULL;
		m_csSelectedClass.Empty();

		CleanupMap();
		CDialog::OnOK();
		return;
	}

	CString name;
	m_lbSearchResults.GetText(index, name);

    IWbemClassObject * pObj = NULL;
	BOOL res = m_mapNamesToObjects.Lookup(name, (void*&)pObj );
	if (!res) {
		//this executes when "No matches" is  selected
		m_pSelectedObject = NULL;
		m_csSelectedClass.Empty();

		CleanupMap();

		//Dialog stays up
		return;
	}
	ASSERT(pObj);

	m_pSelectedObject = pObj;
	m_csSelectedClass = name;

	//do another AddRef() on selected object, because subsequent call to
	//CleanupMap will release
	m_pSelectedObject->AddRef();


	CleanupMap();

	CDialog::OnOK();
}

CString CClassSearch::GetSelectedClassName()
{
	return m_csSelectedClass;

}



void CClassSearch::OnSelchangeListSearchResults()
{
	if 	(m_lbSearchResults.GetCurSel() != LB_ERR)  { //an item is selected
		SetDefID(IDOK);
	}
	else {
		SetDefID(IDC_BUTTON_SEARCH);
	}
}

void CClassSearch::OnSetfocusEdit1()
{
	//if edit box receives input focus, "Search" button should become the default
	SetDefID(IDC_BUTTON_SEARCH);
}

void CClassSearch::OnCheckSearchClass()
{
	UpdateSearchButtonState();
}

void CClassSearch::OnCheckSearchDescriptions()
{
	UpdateSearchButtonState();

}

void CClassSearch::OnCheckSearchProperties()
{
	UpdateSearchButtonState();

}

void CClassSearch::UpdateSearchButtonState()
{
	//the button should be enabled if at least one of the search checkboxes is checked
	UpdateData();

	if ((m_bSearchClassNames || m_bSearchProperties || m_bSearchDescriptions) &&
		(!m_csSearchClass.IsEmpty())) {
		GetDlgItem(IDC_BUTTON_SEARCH)->EnableWindow(TRUE);
	}
	else {
		GetDlgItem(IDC_BUTTON_SEARCH)->EnableWindow(FALSE);
	}

}

void CClassSearch::OnUpdateEdit1()
{

	UpdateSearchButtonState();

}

/******************************************************************************
// This method disables OK button when search result list is empty("No matches")
// and ensbles it when there are valid items in the result list.
*******************************************************************************/
void CClassSearch::UpdateOKButtonState()
{
	GetDlgItem(IDOK)->EnableWindow(!m_mapNamesToObjects.IsEmpty());
}

HRESULT CClassSearch::DoSearch()
{
	ASSERT(m_pParent->GetServices());

	IEnumWbemClassObject * pEnum = NULL;

	//GET ALL CLASSES IN THE NAMESPACE
	HRESULT hr = m_pParent->GetServices()->CreateClassEnum(NULL,
									WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
									NULL, &pEnum);
	if (FAILED(hr)) {
		return hr;
	}
	hr = SetEnumInterfaceSecurity(m_pParent->GetCurrentNamespace(),
									pEnum,
									m_pParent->GetServices());

	if (FAILED(hr)) {
		// Oh well, just keep going, just in case it works without the security set correctly
//		return hr;
	}

	IWbemClassObject * pObj[CHUNK_SIZE];

	ULONG uRet = 0;

    while (1) {

		for (UINT i = 0; i < CHUNK_SIZE; i++) {
			pObj[i] = NULL;
		}

        hr = pEnum->Next(WBEM_INFINITE, CHUNK_SIZE, (IWbemClassObject **)&pObj, &uRet);

		TRACE(_T("hresult from Next is %x\n"), hr);
		TRACE(_T("Next returned %d items\n"), uRet);


		if (hr == WBEM_S_FALSE && uRet== 0) {
		    break;
		}

		if (FAILED(hr) && uRet == 0) {
			break;
		}

		for (i = 0; i < uRet; i++) {

			TRACE(_T("object %d\n"), i);

			if (m_bSearchClassNames) {

				hr = CheckClassNameForPattern(pObj[i], m_csSearchClass);
				if (SUCCEEDED (hr)) {
					//add this object, inspect the next one
					m_mapNamesToObjects.SetAt(GetIWbemClass(pObj[i]), pObj[i]);
					continue;
				}
			}

			//pattern is not found in class name. Check in property names:
			if (m_bSearchProperties) {
				hr = CheckPropertyNamesForPattern(pObj[i], m_csSearchClass);
				if (SUCCEEDED (hr)) {
					//add this object, inspect the next one
					m_mapNamesToObjects.SetAt(GetIWbemClass(pObj[i]), pObj[i]);
					continue;
				}
			}

			//pattern is not found in property names. Check in description:
			if (m_bSearchDescriptions) {
				hr = CheckDescriptionForPattern(pObj[i], m_csSearchClass);
				if (SUCCEEDED (hr)) {
					m_mapNamesToObjects.SetAt(GetIWbemClass(pObj[i]), pObj[i]);
					continue;
				}
			}

			//if we got here, pattern is not found
			pObj[i]->Release();
		}
	}

	pEnum->Release();


	return S_OK;
}


HRESULT CClassSearch::CheckPropertyNamesForPattern(IWbemClassObject *pObj, CString &pattern)
{
	ASSERT (pObj);

	bstr_t bstrClass("__CLASS");
	VARIANT var;
	VariantInit(&var);

	HRESULT hr = pObj->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
	if (FAILED(hr)) {
		return hr;
	}

	while (1) {
		BSTR bstrOut;
		hr = pObj->Next(0L, &bstrOut, NULL, NULL, NULL);
		if (hr == WBEM_S_NO_MORE_DATA ) {
			break;
		}
		if (FAILED(hr)) {
			continue;
		}

		CString csPropName;
		csPropName = (char *)bstr_t(bstrOut);
		SysFreeString(bstrOut);

		csPropName.MakeUpper();
		pattern.MakeUpper();

		if (csPropName.Find((LPCTSTR)pattern) == -1) {
			continue;
		}
		else {
			return S_OK;
		}
	}

	return E_FAIL;

}

HRESULT CClassSearch::CheckDescriptionForPattern(IWbemClassObject *pObj, CString &pattern)
{
	ASSERT (pObj);

	IWbemQualifierSet * pQualSet = NULL;

	HRESULT hr = pObj->GetQualifierSet(&pQualSet);
	if (FAILED(hr)) {
		return hr;
	}

	CString descr ("Description");
	VARIANT varOut;
	VariantInit(&varOut);
	hr = pQualSet->Get(descr.AllocSysString(), 0L, &varOut, NULL);
	if (FAILED(hr)) {
		pQualSet->Release();
		return hr;
	}

	ASSERT (varOut.vt == VT_BSTR);

	CString csDescr((char *)bstr_t(varOut.bstrVal));

	csDescr.MakeUpper();
	pattern.MakeUpper();

	if (csDescr.Find((LPCTSTR)pattern) == -1) {
		pQualSet->Release();
		return E_FAIL;
	}

	pQualSet->Release();

	return S_OK;
}

HRESULT CClassSearch::CheckClassNameForPattern(IWbemClassObject *pObj, CString &pattern)
{
	ASSERT (pObj);

	bstr_t bstrClass("__CLASS");
	VARIANT var;
	VariantInit(&var);

	HRESULT hr = pObj->Get(bstrClass, 0L, &var, NULL, NULL);
	if (FAILED(hr)) {
		return hr;
	}
	ASSERT (var.vt == VT_BSTR);

	CString csClassName((char *)bstr_t(var.bstrVal));

	csClassName.MakeUpper();
	pattern.MakeUpper();

	if (csClassName.Find(pattern) == -1) {
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\initnamespacedialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// InitNamespaceDialog.cpp : implementation file
//

#include "precomp.h"
#include "classnav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "ClassSearch.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

#define INITIALIZE_INIT_NAMESPACE WM_USER + 400

CInitNamespaceDialog::CInitNamespaceDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CInitNamespaceDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInitNamespaceDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInit = FALSE;
}


void CInitNamespaceDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInitNamespaceDialog)
	DDX_Control(pDX, IDOK, m_buttonOK);
	DDX_Control(pDX, IDC_NSENTRYCTRLINITNAMESPACE, m_cnseInitNamespace);
	//}}AFX_DATA_MAP

	if (!m_bInit)
	{
		m_bInit = TRUE;
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
	}
}

LRESULT CInitNamespaceDialog::InitNamespace(WPARAM, LPARAM)
{

	if (!m_cnseInitNamespace.GetSafeHwnd())
	{
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
	}
	else
	{
		m_cnseInitNamespace.SetNamespaceText(_T("root\\CIMV2"));
		m_cnseInitNamespace.SetFocusToEdit();
	}

	return 0;

}

BEGIN_MESSAGE_MAP(CInitNamespaceDialog, CDialog)
	//{{AFX_MSG_MAP(CInitNamespaceDialog)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_MESSAGE(INITIALIZE_INIT_NAMESPACE, InitNamespace )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog message handlers

BEGIN_EVENTSINK_MAP(CInitNamespaceDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceDialog)
	ON_EVENT(CInitNamespaceDialog, IDC_NSENTRYCTRLINITNAMESPACE, 3 /* GetIWbemServices */, OnGetIWbemServicesNsentryctrlinitnamespace, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

BOOL CInitNamespaceDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_cnseInitNamespace.SetLocalParent(m_pParent);
	m_cnseInitNamespace.ClearOnLoseFocus(0);

	CRect rectMove;
	CenterWindowInOwner(this,rectMove);

	SetWindowPos(&wndTop,
				rectMove.left,
				rectMove.top,
				rectMove.Width(),
				rectMove.Height(),
				SWP_NOSIZE | SWP_NOMOVE);



	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CInitNamespaceDialog::OnOK()
{
	// TODO: Add extra validation here

	CWnd* pWndFocus = GetFocus();
	TCHAR szClass[140];
	int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

	CString csText = m_cnseInitNamespace.GetNamespaceText();
	csText.TrimLeft();
	csText.TrimRight();

	BSTR bstrNamespace = csText.AllocSysString();
	EnableWindow(FALSE);
	m_cnseInitNamespace.OpenNamespace(bstrNamespace, FALSE);
	EnableWindow(TRUE);
	SetFocus();
	SysFreeString(bstrNamespace);

}

void CInitNamespaceDialog::OnCancel()
{
	// TODO: Add extra cleanup here
	// Need to give focus back to the NSPicker
	CDialog::OnCancel();

	// Maybe we need to post a message here!
	m_pParent->PostMessage(SETFOCUSNSE,0,0);
}

void CInitNamespaceDialog::OnGetIWbemServicesNsentryctrlinitnamespace
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	// TODO: Add your control notification handler code here
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

void CInitNamespaceDialog::OnDestroy()
{
	m_bValid = m_cnseInitNamespace.IsTextValid();
	m_csNamespace = m_cnseInitNamespace.GetNamespaceText();

	CDialog::OnDestroy();

	// TODO: Add your message handler code here

}

BOOL CInitNamespaceDialog::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:
		if (lpMsg->wParam == VK_RETURN)
		{
			CWnd* pWndFocus = GetFocus();
			TCHAR szClass[140];
			int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

			if (pWndFocus &&
				IsChild(pWndFocus) &&
				n > 0 &&
				_tcsicmp(szClass, _T("EDIT")) == 0)
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
			if (lpMsg->message == WM_KEYUP)
			{
				return TRUE;
			}
			PostMessage(WM_CLOSE, 0, 0);
			return TRUE;

		}

		break;
	}

	return CDialog::PreTranslateMessage(lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\initnamespacedialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "nsentry.h"
//}}AFX_INCLUDES
#if !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_)
#define AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InitNamespaceDialog.h : header file
//
class CClassNavCtrl;
class CInitNamespaceNSEntry;
/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

class CInitNamespaceDialog : public CDialog
{
// Construction
public:
	CInitNamespaceDialog(CWnd* pParent = NULL);   // standard constructor
	CString GetNamespace() {return m_csNamespace;}
// Dialog Data
	//{{AFX_DATA(CInitNamespaceDialog)
	enum { IDD = IDD_DIALOGINITNAMESPACE };
	CButton	m_buttonOK;
	CInitNamespaceNSEntry	m_cnseInitNamespace;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceDialog)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CClassNavCtrl *m_pParent;
	CString m_csNamespace;
	BOOL m_bValid;
	BOOL m_bInit;
	// Generated message map functions
	//{{AFX_MSG(CInitNamespaceDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnGetIWbemServicesNsentryctrlinitnamespace(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnDestroy();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg LRESULT InitNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	friend class CClassNavCtrl;
	friend class CInitNamespaceNSEntry;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\initnamespacensentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "resource.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "ClassSearch.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceNSEntry

IMPLEMENT_DYNCREATE(CInitNamespaceNSEntry,CNSEntry)

CInitNamespaceNSEntry::CInitNamespaceNSEntry()
{
	m_pParent = NULL;

}

BEGIN_MESSAGE_MAP(CInitNamespaceNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CInitNamespaceNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CInitNamespaceNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceNSEntry)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 1 , OnNameSpaceChanged, VTS_BSTR VTS_BOOL)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 2 , OnNameSpaceRedrawn, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CInitNamespaceNSEntry::OnNameSpaceRedrawn()
{
	m_pParent->InvalidateControl();
}


void CInitNamespaceNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid)
{
	CInitNamespaceDialog *pParent =
		reinterpret_cast<CInitNamespaceDialog *>(GetParent());
	pParent->CDialog::OnOK();
	m_pParent->InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\initnamespacensentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __InstNavNSEntry_H__
#define __InstNavNSEntry_H__

class CClassNavCtrl;

class CInitNamespaceNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CInitNamespaceNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CInitNamespaceNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid);
			afx_msg void OnNameSpaceRedrawn();
		//	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CInitNamespaceNSEntry();
	void SetLocalParent(CClassNavCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CClassNavCtrl* m_pParent;
};

#endif // __InstNavNSEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\namespace.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: namespace.cpp
//
// Description:
//	This file implements the CNameSpace class which is a subclass
//	of the MFC CComboBox class.  It is a part of the Class Explorer OCX,
//	and it performs the following functions:
//		a.  Displays a history of the namespaces either opened or
//			attempted to be opened
//		b.  Allows the user to select from the list of namespaces
//		c.  Allows the user to type in the namespace which will be added
//			to the history list.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CBanner
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "EditInput.h"
#include "NameSpace.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "ClassNavPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ***************************************************************************
//
// CNameSpace::CNameSpace
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CNameSpace::CNameSpace()
:m_bFirst(TRUE)
{
}

BEGIN_MESSAGE_MAP(CNameSpace, CComboBox)
	//{{AFX_MSG_MAP(CNameSpace)
	ON_CONTROL_REFLECT(CBN_SELENDOK, OnSelendok)
	ON_WM_CTLCOLOR()
	ON_MESSAGE( CNS_EDITDONE, OnEditDone )
	ON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropdown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


// ***************************************************************************
//
// CNameSpace::OnSelendok
//
// Description:
//	  Handler for selecting an item from the combo box list.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNameSpace::OnSelendok()
{
	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	CString csNameSpace;
	int nSelect = GetCurSel( );
	if (nSelect != CB_ERR )
	{
		GetLBText(nSelect,csNameSpace);
		SetWindowText(csNameSpace);
		if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
		{
			BOOL bOpened = m_pParent -> OpenNameSpace(&csNameSpace);
			if (bOpened)
			{
				m_csNameSpace = csNameSpace;
			}
			else
			{
				int nGoodNamespace =
					FindStringExact(-1,(LPCSTR) m_csNameSpace);
				SetCurSel( nGoodNamespace );
			}
		}
		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
	}
}

// ***************************************************************************
//
//  CNameSpace::OnEditDone
//
// Description:
//	  Handler function which is invoked when editing ofthe edit control
//	  is done.
//
// Parameters:
//	  UINT				Not used.
//	  LONG				Not used.
//
// Returns:
// 	  long				0
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
LRESULT CNameSpace::OnEditDone(WPARAM, LPARAM )
{
	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	CString csNameSpace;
	GetWindowText(csNameSpace);

	if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
	{
		CWaitCursor cwcWait;
		int nFound = FindStringExact(-1, csNameSpace);
		if (nFound == CB_ERR)
		{
			int nReturn = InsertString(0,(LPCSTR) csNameSpace);
			m_csaNameSpaceHistory.Add(csNameSpace);
		}

		BOOL bOpened = m_pParent -> OpenNameSpace(&csNameSpace);
		if (bOpened)
		{

			m_csNameSpace = csNameSpace;
		}
		else
		{
			int nGoodNamespace =
					FindStringExact(-1,(LPCSTR) m_csNameSpace);
			SetCurSel( nGoodNamespace );
		}
		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		else if (nIndex == -1)
		{
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		if (m_csaNameSpaceHistory.GetSize() == 21)
		{
			m_csaNameSpaceHistory.RemoveAt(20);
		}
	}

	return 0;
}

// ***************************************************************************
//
//  CNameSpace::OnDropDown
//
// Description:
//	  Handler function which is invoked when the combo box's list is
//	  dropped down.  It builds the list from the history list.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNameSpace::OnDropdown()
{
	CWaitCursor wait;

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	int n = GetCount() - 1;

	while (n > -1)
	{
		DeleteString(n);
		n--;
	}

	int i;
	int nNameSpaces = m_csaNameSpaceHistory.GetSize();
	for (i = 0; i < nNameSpaces;i++)
	{
		AddString(m_csaNameSpaceHistory.GetAt(i));
	}

	CString csEINameSpace;
	GetWindowText(csEINameSpace);

	if (csEINameSpace.GetLength() == 0)
	{
		csEINameSpace = m_csNameSpace;
	}

	int nFound =
				FindString(-1, csEINameSpace);

	if (nFound !=  CB_ERR)
	{

		SelectString
			( -1, (LPCSTR) csEINameSpace);

	}

	CRect crParent;
	m_pParent -> m_cbBannerWindow.GetWindowRect(&crParent);
	crParent.NormalizeRect();

	CRect crMe;
	GetWindowRect(&crMe);
	crMe.NormalizeRect();

	int nWidth = crParent.Width();
	int nLeft = crMe.TopLeft().x - crParent.TopLeft().x;
	int nAbsoluteMax =  nWidth > nLeft ? nWidth - nLeft : nLeft - nWidth;

	CRect crClient;
	GetClientRect( &crClient);
	crClient.NormalizeRect();


	int nMax = crClient.Width();

	for (i = 0; i < m_csaNameSpaceHistory.GetSize(); i++)
	{
		int nWidth =
			m_pParent->m_cbBannerWindow.GetTextLength(&m_csaNameSpaceHistory.GetAt(i));
		nWidth+=10;
		if (nMax < nWidth)
		{
			nMax = nWidth;
		}

	}

	if (nMax > nAbsoluteMax)
	{
		nMax = nAbsoluteMax;
	}

	SetDroppedWidth(nMax);

	if (m_csaNameSpaceHistory.GetSize() > 5)
	{
		int nReturn = ModifyStyle( 0, WS_VSCROLL ,  0 );
	}
}

// ***************************************************************************
//
// CNameSpace::StringInArray
//
// Description:
//	  Check to see if a CString is in a CStringArray starting at a specified
//	  index.
//
// Parameters:
//	  CStringArray *pcsaArray	Array to search
//	  CString *pcsString		CString to look for (by content)
//	  int nIndex				Starting at index
//
// Returns:
// 	  int						Index if found; otherwise -1
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CNameSpace::StringInArray
(CStringArray *pcsaArray, CString *pcsString, int nIndex)
{
	int nSize = pcsaArray->GetSize();

	for (int i = nIndex; i < nSize; i++)
	{
		if (pcsString->CompareNoCase(pcsaArray->GetAt(i)) == 0)
		{
			return i;
		}
	}
	return -1;
}

// ***************************************************************************
//
// CNameSpace::OnCtlColor
//
// Description:
//	  Called by the framework to give a window a chance to set the brush
//	  used to paint the backgound color.  We use it to dynamically subclass
//	  the edit contol.
//
// Parameters:
//	  pDC			Not used.
//	  pWnd			Contains a pointer to the control asking for the color.
//	  nCtlColor		Specifies the control.
//
// Returns:
// 	  HBRUSH		The brush passed in.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
HBRUSH CNameSpace::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CComboBox::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO: Change any attributes of the DC here
	if (m_bFirst && (nCtlColor == CTLCOLOR_EDIT))
	{
		m_ceiInput.SubclassWindow(pWnd->m_hWnd);
		m_ceiInput.SetLocalParent(this);
		m_bFirst = FALSE;
	}
	// TODO: Return a different brush if the default is not desired
	return hbr;
}

/*	EOF:  namespace.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#define _AFX_ENABLE_INLINES

#include <afxctl.h>         // MFC support for OLE Controls
#include <AFXCMN.H>
#include <Afxdisp.h>
// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\progdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//  ProgDlg.cpp : implementation file
// CG: This file was added by the Progress Dialog component

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "ProgDlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(UINT nCaptionID)
{

    m_bCancel=FALSE;

    //{{AFX_DATA_INIT(CProgressDlg)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_bParentDisabled = FALSE;
}

CProgressDlg::~CProgressDlg()
{
    if(m_hWnd!=NULL)
      DestroyWindow();
	 m_bCancel=FALSE;
}

BOOL CProgressDlg::DestroyWindow()
{
	m_bCancel=FALSE;
    ReEnableParent();
    return CDialog::DestroyWindow();
}

void CProgressDlg::ReEnableParent()
{
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);

    if(m_bParentDisabled && (pParentOwner!=NULL))
      pParentOwner->EnableWindow(TRUE);
    m_bParentDisabled=FALSE;
}

BOOL CProgressDlg::Create(CWnd *pParent)
{
	m_pParentWnd = pParent;

	m_bCancel=FALSE;
    // m_bParentDisabled is used to re-enable the parent window
    // when the dialog is destroyed. So we don't want to set
    // it to TRUE unless the parent was already enabled.

	// Get the true parent of the dialog
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);
    if((pParentOwner!=NULL) && pParentOwner->IsWindowEnabled())
    {
      pParentOwner->EnableWindow(FALSE);
      m_bParentDisabled = TRUE;
    }

    if(!CDialog::Create(CProgressDlg::IDD,pParentOwner))
    {
      ReEnableParent();
      return FALSE;
    }

    return TRUE;
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, CG_IDC_PROGDLG_STATUS, m_cstaticMessage);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CProgressDlg::SetStatus(LPCTSTR lpszMessage)
{
    ASSERT(m_hWnd); // Don't call this _before_ the dialog has
                    // been created. Can be called from OnInitDialog
    CWnd *pWndStatus = GetDlgItem(CG_IDC_PROGDLG_STATUS);

    // Verify that the static text control exists
    ASSERT(pWndStatus!=NULL);
    pWndStatus->SetWindowText(lpszMessage);
}

void CProgressDlg::OnCancel()
{
    m_bCancel=TRUE;
}

void CProgressDlg::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;
    // Handle dialog messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if(!IsDialogMessage(&msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }

}

BOOL CProgressDlg::CheckCancelButton()
{
    // Process all pending messages
    PumpMessages();

    // Reset m_bCancel to FALSE so that
    // CheckCancelButton returns FALSE until the user
    // clicks Cancel again. This will allow you to call
    // CheckCancelButton and still continue the operation.
    // If m_bCancel stayed TRUE, then the next call to
    // CheckCancelButton would always return TRUE

    BOOL bResult = m_bCancel;
    //m_bCancel = FALSE;

    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

BOOL CProgressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

	 m_bCancel=FALSE;
	m_cstaticMessage.SetWindowText(m_csMessage);
	SetWindowText(m_csLabel);
	MoveWindowToLowerLeftOfOwner(this);
    return TRUE;
}



int CProgressDlg::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style |= WS_EX_TOPMOST;

	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\nsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

long CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bstrNamespace, longNoFireEvent);
	return result;
}

void CNSEntry::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

CString CNSEntry::GetNamespaceText()
{
	CString result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CNSEntry::IsTextValid()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CNSEntry::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lClearOnLoseFocus);
}

void CNSEntry::ClearNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

void CNSEntry::SetFocusToEdit()
{
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\namespace.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: namespace.h
//
// Description:
//	This file declares the CNameSpace class which is a subclass
//	of the MFC CComboBox class.  It is a part of the Class Explorer OCX, 
//	and it performs the following functions:
//		a.  Displays a history of the namespaces either opened or
//			attempted to be opened
//		b.  Allows the user to select from the list of namespaces
//		c.  Allows the user to type in the namespace which will be added
//			to the history list.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by:
//	CBanner 
//	 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

//****************************************************************************
//
// CLASS:  CNameSpace
//
// Description:
//	This class is a subclass of the MFC CComboBox class.  It displays a 
//	history of the namespaces either opened or attempted to be opened, allows 
//	the user to select from the list of namespaces and allows the user to type 
//	in the namespace which will be added to the history list.
//
// Public members:
//	
//	CNameSpace 
//	SetParent
//	OnEditDone
//
//============================================================================
//	CNameSpace			Public constructor.
//	SetParent			Initialize parent.
//	OnEditDone			Handler for edit input.
//
//============================================================================
//
//  CNameSpace::CNameSpace
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
//  CNameSpace::SetParent
//
// Description:
//	  Set the logical parent, which is the control.
//
// Parameters:
//	  CClassNavCtrl *pParent		The control.
//
// Returns:
// 	  VOID
//
//============================================================================
//
//  CNameSpace::OnEditDone
//
// Description:
//	  Handler function which is invoked when editing of the edit control
//	  is done.
//
// Parameters:
//	  UINT				Not used.
//	  LONG				Not used.
//
// Returns:
// 	  long				0
//
//****************************************************************************


#ifndef _NAMESPACE_H_
#define _NAMESPACE_H_


#define CNS_EDITDONE WM_USER + 13

class CClassNavCtrl;
class CEditInput;


class CNameSpace : public CComboBox
{
// Construction
public:
	CNameSpace();
	void SetParent(CClassNavCtrl *pParent) {m_pParent = pParent;}
	afx_msg LRESULT OnEditDone(WPARAM, LPARAM );

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameSpace)
	//}}AFX_VIRTUAL

protected:

	CClassNavCtrl *m_pParent;
	CString m_csNameSpace;
	CEditInput m_ceiInput;
	BOOL m_bFirst;
	CStringArray m_csaNameSpaceHistory;
	int CNameSpace::StringInArray
		(CStringArray *pcsaArray, CString *pcsString, int nIndex);
	//{{AFX_MSG(CNameSpace)
	afx_msg void OnSelendok();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG

	afx_msg void OnDropdown();
	
protected:
	DECLARE_MESSAGE_MAP()
	
};

#endif

/*	EOF:  namespace.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_NSENTRY1_H__AF631F12_C9D2_11D1_967E_00C04FD9B15B__INCLUDED_)
#define AFX_NSENTRY1_H__AF631F12_C9D2_11D1_967E_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	long OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent);
	void SetNamespaceText(LPCTSTR lpctstrNamespace);
	CString GetNamespaceText();
	long IsTextValid();
	void ClearOnLoseFocus(long lClearOnLoseFocus);
	void ClearNamespaceText(LPCTSTR lpctstrNamespace);
	void SetFocusToEdit();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY1_H__AF631F12_C9D2_11D1_967E_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\olemsclient.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  OLEMSClient.cpp
//
//  Module: Class Navigator ActiveX Control
//
//
//***************************************************************************
#include "precomp.h"
#include <OBJIDL.H>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "OLEMSClient.h"
#include "logindlg.h"


#define BUFF_SIZE 256


// *************************************************************************
// Safe array utilities
//
// VT_BSTR for strings
SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
	long i = iIndex;
    HRESULT hResult = SafeArrayPutElement(psa,&i,pcs -> AllocSysString());
	return GetScode(hResult);
}

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription)
{
	if (!pErrorObject)
	{
		rcsDescription.Empty();
		return FALSE;
	}

	CString csProp = _T("Description");
	CString csDescription = GetBSTRProperty(pErrorObject,&csProp);
	if (csDescription.IsEmpty() || csDescription.GetLength() == 0)
	{
		rcsDescription.Empty();
		return FALSE;
	}
	else
	{
		rcsDescription = csDescription;
		return TRUE;
	}


}

CString GetBSTRProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString();
    sc = pInst->Get(bstrTemp,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);
	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property value ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (NULL, pInst);
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return _T("");
	}


	CString csOut;
	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


//***************************************************************************
//
// CreateSimpleClass
//
// Purpose: This creates a new class with a class name and parent.
//
//***************************************************************************

IWbemClassObject *CreateSimpleClass
(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass, int &nError,
CString &csError )
{
	IWbemClassObject *pNewClass = NULL;
    IWbemClassObject *pParentClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

   	SCODE sc;


	BSTR bstrTemp =  pcsNewClass->AllocSysString();
	sc = pProv -> GetObject
		(bstrTemp ,0,NULL, &pNewClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
		pNewClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg +=
			_T(":  Class ") + *pcsNewClass;
		csUserMsg += _T(" already exists");
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 9);

		return NULL;

	}

	pcsParentClass =
		pcsParentClass->GetLength()==0? NULL: pcsParentClass;

	if (pcsParentClass)
	{
		bstrTemp = pcsParentClass->AllocSysString();
		sc = pProv -> GetObject
			(bstrTemp,0,NULL, &pParentClass,NULL);
		::SysFreeString(bstrTemp);
	}
	else
	{
		sc = pProv -> GetObject
			(NULL,0,NULL, &pParentClass,NULL);
	}

	if (sc != S_OK)
	{
		if (pcsParentClass)
		{
			CString csUserMsg =
				_T("An error occured creating the class ") + *pcsNewClass;
			csUserMsg +=
				_T(":  Cannot create the new class because the parent class object \"") + *pcsParentClass + _T("\" does not exist.");

			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		}
		else
		{
			CString csUserMsg =
				_T("An error occured creating the class ") + *pcsNewClass +  _T(" .");
			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);

		}
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	if (pcsParentClass)
	{
		sc = pParentClass->SpawnDerivedClass(0,&pNewClass);
	}
	else
	{
		pNewClass = pParentClass;
		pNewClass->AddRef();
		sc = S_OK;
	}

	if (sc != S_OK)
	{
		pParentClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		if (pcsParentClass)
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class of ") + *pcsParentClass;
		}
		else
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class");
		}

		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 9);

		return NULL;
	}

	pParentClass->Release();

	CString csTmp;

	// Init class __Class Property
	csTmp = L"__Class";
	SetProperty (pProv, pNewClass, &csTmp,pcsNewClass );

	pErrorObject = NULL;

	sc = pProv->PutClass(pNewClass,0,NULL,NULL);

	if (sc != S_OK)
	{
		CString csUserMsg=
		_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg += _T(":  Cannot PutClass on ") + *pcsNewClass;
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		pNewClass->Release();
		pNewClass = NULL;
		BSTR bstrTemp = pcsNewClass->AllocSysString();
		sc = pProv -> GetObject
		(bstrTemp,0,NULL,&pNewClass,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg=
					_T("An error occured creating the class ") + *pcsNewClass;
			csUserMsg +=
					_T(":  Cannot get the new class.\"") ;

			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 21);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		ReleaseErrorObject(pErrorObject);
		return pNewClass;
	}
}

//***************************************************************************
//
// DeleteAClass
//
// Purpose: This deletes a class.
//
//***************************************************************************
BOOL DeleteAClass
(IWbemServices * pProv, CString *pcsClass)
{
	SCODE sc;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc =  pProv -> DeleteClass(bstrTemp,0,NULL,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot delete class ") + *pcsClass;

		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);

		return TRUE;
	}
}

//***************************************************************************
//
// ReparentAClass
//
// Purpose: Clone a class and change its superclass..
//
//***************************************************************************
IWbemClassObject *ReparentAClass
(IWbemServices * pProv, IWbemClassObject *pimcoParent, IWbemClassObject *pimcoChild)
{

	IWbemClassObject *pimcoClone = NULL;
	IWbemClassObject *pErrorObject = NULL;
	SCODE sc;

	sc = pimcoChild -> Clone(&pimcoClone);
	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot clone class ");
		CString csProp = _T("__Class");
		CString csClass;
		csClass = ::GetProperty(pimcoChild,&csProp);
		csUserMsg += csClass;
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
		return FALSE;
	}


	CString csProp = _T("__Class");
	CString csParentClass;
	if (pimcoParent)
	{
		csParentClass = ::GetProperty(pimcoParent,&csProp);
	}
	else
		csParentClass = _T("");

	csProp = _T("__SuperClass");
	BOOL bReturn = ::SetProperty (pProv, pimcoClone, &csProp, &csParentClass);

	if (bReturn)
	{
		sc = pProv -> PutClass(pimcoClone, 0, NULL,NULL);
		if (sc != S_OK)
		{
			CString csUserMsg =
							_T("Cannot PutClass ");

			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		else
		{
			ReleaseErrorObject(pErrorObject);
			return pimcoClone;
		}
	}
	else
	{

		return FALSE;
	}

}

//***************************************************************************
//
// RenameAClass
//
// Purpose: Clone a class and change its naem.
//
//***************************************************************************
IWbemClassObject *RenameAClass
(IWbemServices * pProv, IWbemClassObject *pimcoClass, CString *pcsNewName,
 BOOL bDeleteOriginal)
{

	IWbemClassObject *pimcoClone = NULL;
	IWbemClassObject *pErrorObject = NULL;
	SCODE sc;

	sc = pimcoClass -> Clone(&pimcoClone);
	if (sc != S_OK)
	{
		CString csUserMsg =
			_T("An error occured renaming a class: ");
		csUserMsg +=
					_T("Cannot clone class ");
		CString csProp = _T("__Class");
		CString csClass;
		csClass = ::GetProperty(pimcoClass,&csProp);
		csUserMsg += csClass;
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
		return FALSE;
	}

	CString csProp = _T("__Class");

	SetProperty (pProv, pimcoClone, &csProp, pcsNewName);

	sc = pProv -> PutClass(pimcoClone, 0, NULL,NULL);
	if (sc != S_OK)
		{
			CString csUserMsg=
				_T("An error occured renaming a class: ");
			csUserMsg +=
				_T("Cannot PutClass ");
			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			ReleaseErrorObject(pErrorObject);
			return NULL;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
	}


	if (bDeleteOriginal)
	{
		CString csDelete;
		csProp = _T("__Class");
		csDelete = ::GetProperty(pimcoClass,&csProp);
		pimcoClass -> Release();
		BOOL bReturn = DeleteAClass
			(pProv, &csDelete);
		if (!bReturn)
		{
			CString csUserMsg =
				_T("An error occured renaming a class: ");
			csUserMsg +=
					_T("Cannot delete the original class ");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
			return NULL;
		}


	}
	return pimcoClone;

}


BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty, CString *pcsPropertyValue)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = pcsPropertyValue -> AllocSysString ( );
    if(var.bstrVal == NULL)
	{
        return WBEM_E_FAILED;
	}

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Put(bstrTemp ,0,&var,NULL);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
		{
			CString csUserMsg =
							_T("Cannot Put " + *pcsProperty);
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
	}


	VariantClear(&var);
	return TRUE;
}

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty, long lValue)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = lValue;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Put( bstrTemp ,0,&var,NULL);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot Put " + *pcsProperty);
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
	}


	VariantClear(&var);
	return TRUE;
}



CString GetProperty
(IWbemClassObject * pInst, CString *pcsProperty)

{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
    long lType;
	long lFlavor;

	BSTR bstrTemp =  pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot get a property ");
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


//***************************************************************************
// Function:	GetAllClasses
// Purpose:		Gets all classes in the database.
//***************************************************************************
int GetAllClasses(IWbemServices * pIWbemServices, CPtrArray &cpaClasses,CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	sc = pIWbemServices->CreateClassEnum
		(NULL, WBEM_FLAG_DEEP | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemClassObject);
	if (sc != S_OK)
	{
		CString csUserMsg= _T("Cannot get all classes ");
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return 0;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);

	}

	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray =
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	for (int i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}

	ULONG uReturned;

	HRESULT hResult =
			pIEnumWbemClassObject->Next(0,N_INSTANCES,pInstanceArray, &uReturned);

	pIWbemClassObject = NULL;

	while(hResult == S_OK || hResult == WBEM_S_TIMEDOUT || uReturned > 0)
	{
#pragma warning( disable :4018 )
		for (int c = 0; c < uReturned; c++)
#pragma warning( default : 4018 )
		{
			pIWbemClassObject = pInstanceArray[c];
			cpaClasses.Add(reinterpret_cast<void *>(pIWbemClassObject));
			pimcoInstances[c] = NULL;
			pIWbemClassObject = NULL;
		}
		uReturned = 0;
		hResult = pIEnumWbemClassObject->Next
			(0,N_INSTANCES,pInstanceArray, &uReturned);
	}

	pIEnumWbemClassObject -> Release();
	return (int) cpaClasses.GetSize();

}

CStringArray *GetAllClassPaths(IWbemServices * pIWbemServices, CString &rcsNamespace)
{

	CPtrArray cpaClasses;
	int nClasses=
		GetAllClasses(pIWbemServices, cpaClasses,rcsNamespace);

	CStringArray *pcsaClassNames = new CStringArray;

	for (int i = 0; i < nClasses; i++)
	{
		IWbemClassObject *pClass =
			reinterpret_cast<IWbemClassObject *>
				(cpaClasses.GetAt(i));
		CString csProp = _T("__Path");
		CString csClass = ::GetProperty(pClass,&csProp);
		pcsaClassNames->Add(csClass);
		pClass->Release();
	}

	return pcsaClassNames;

}

//***************************************************************************
// Function:	HasSubclasses
// Purpose:		Predicate to tell if a class has any subclasses.
//***************************************************************************
BOOL HasSubclasses(IWbemClassObject *pimcoNew, CPtrArray *pcpaDeepEnum)
{
	CString csClass = _T("__Class");
	csClass = ::GetProperty(pimcoNew,&csClass);

	for (int i = 0; i < pcpaDeepEnum->GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(pcpaDeepEnum->GetAt(i));
		CString csSuper = GetIWbemSuperClass(pObject);
		if (csSuper.CompareNoCase(csClass) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;


}

BOOL HasSubclasses(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass, CString &rcsNamespace)
{
#ifdef _DEBUG
	DWORD dFn1 = GetTickCount();
#endif

	SCODE sc;
	IEnumWbemClassObject * pIEnumWbemClassObject = NULL;
	IWbemClassObject     * pIWbemClassObject = NULL;
	IWbemClassObject     * pErrorObject = NULL;

	CString csClass = _T("__Class");
	csClass = ::GetProperty(pimcoClass,&csClass);

#ifdef _DEBUG
	DWORD dEnum1 = GetTickCount();
#endif
	BSTR bstrTemp = csClass.AllocSysString();
	sc = pIWbemServices->CreateClassEnum
		(bstrTemp, WBEM_FLAG_SHALLOW | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY , NULL, &pIEnumWbemClassObject);
	::SysFreeString(bstrTemp);
#ifdef _DEBUG
	DWORD dEnum2 = GetTickCount();
#endif

	if (sc != S_OK)
	{
		CString csUserMsg=
							_T("Cannot create a class enumeration ");
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
	BOOL bStop = FALSE;
#ifdef _DEBUG
	DWORD dNext1 = GetTickCount();
	DWORD dNext2 = -1;
#endif
    if (!bStop && S_OK == pIEnumWbemClassObject->Next(INFINITE, 1, &pIWbemClassObject, &uReturned) )
		{
			if (pIWbemClassObject)
			{
#ifdef _DEBUG
				dNext2 = GetTickCount();
#endif
				pIWbemClassObject -> Release();
				pIWbemClassObject = NULL;
				i++;
			}
			 if (i > 0)
			 {
				 bStop = TRUE;
			 }
		}

#ifdef _DEBUG
	if (dNext2 == -1)
	{
		dNext2 = GetTickCount();
	}

	DWORD dRel1 = GetTickCount();
#endif

	pIEnumWbemClassObject -> Release();

#ifdef _DEBUG
#ifdef _DOTIMING
	DWORD dRel2 = GetTickCount();

	DWORD dFn2 = GetTickCount();

	afxDump << "HasSubclasses function tick count for class " << csClass << " = " << dFn2 - dFn1  << "\n";
	afxDump << "   HasSubclasses CreateClassEnum tick count = " << dEnum2 - dEnum1  << "\n";
	if (i == 0)
	{
		afxDump << "   HasSubclasses Next tick count (zero objects returned) = " <<  dNext2 - dNext1 <<  "\n";
	}
	else
	{
		afxDump << "   HasSubclasses Next tick count (" << i << " Next API calls)  = " <<  dNext2 - dNext1  << "\n";
	}
	afxDump << "   HasSubclasses Release tick count = " << dRel2 - dRel1  << "\n\n";
#endif
#endif

	return i > 0? TRUE : FALSE;


}
//***************************************************************************
// Function:	HasSubclasses
// Purpose:		Predicate to tell if a class has any subclasses.
//***************************************************************************
BOOL HasSubclasses(IWbemServices * pIWbemServices, CString *pcsClass, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass->AllocSysString();
	sc = pIWbemServices->CreateClassEnum
		(bstrTemp, WBEM_FLAG_SHALLOW | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY ,
		NULL,&pIEnumWbemClassObject);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot create a class enumeration ");
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
	BOOL bStop = FALSE;
    if (!bStop && S_OK == pIEnumWbemClassObject->Next(INFINITE,1, &pIWbemClassObject, &uReturned) )
		{
			 if (pIWbemClassObject)
			 {
				pIWbemClassObject -> Release();
				pIWbemClassObject = NULL;
				i++;
			 }
			 if (i > 0)
			 {
				 bStop = TRUE;
			 }
		}

	pIEnumWbemClassObject -> Release();
	return i > 0? TRUE : FALSE;

}

//***************************************************************************
//
// GetAttribBool
//
// Purpose: gets an Boolean Qualifier.
//
//***************************************************************************

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 BOOL &bReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;
	BSTR bstrTemp;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);


	if (sc != S_OK)
	{
		bReturn = FALSE;
		return S_OK;
	}

	VARIANTARG var;
	VariantInit(&var);

	bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		bReturn = V_BOOL(&var);
	else
		bReturn = FALSE;


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
// GetAttribBSTR
//
// Purpose: gets an BSTR Qualifier.
//
//***************************************************************************

long GetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 CString &csReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;


    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);

	if (sc != S_OK)
	{
		csReturn.Empty();
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK && var.vt == VT_BSTR)
	{
		csReturn = var.bstrVal;
	}
	else
	{
		csReturn.Empty();
	}


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}




//***************************************************************************
//
// GetIWbemFullPath
//
// Purpose: Returns the complete path of the object.
//
//***************************************************************************
CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return ::GetProperty(pClass,&csProp);


}


IWbemLocator *InitLocator()
{

	IWbemLocator *pLocator = NULL;
	SCODE sc  = CoCreateInstance(CLSID_WbemLocator,
							 0,
							 CLSCTX_INPROC_SERVER,
							 IID_IWbemLocator,
							 (LPVOID *) &pLocator);
	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot iniitalize the locator ");
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
			return 0;
	}

	return pLocator;


}

CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty)

{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get( bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
	   return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}



CString GetIWbemSuperClass(IWbemClassObject *pClass)
{

	CString csProp = _T("__SuperClass");
	return GetBSTRProperty(pClass,&csProp);


}


CString GetIWbemClass(IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return GetBSTRProperty(pClass,&csProp);


}

IWbemClassObject *GetClassObject (IWbemServices *pProv,CString *pcsClass,BOOL bQuiet)
{
	IWbemClassObject *pClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	SCODE sc =
		pProv->GetObject
			(bstrTemp,0,NULL, &pClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK && bQuiet == FALSE)
	{
		CString csUserMsg=
							_T("Cannot get class ") + *pcsClass;
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	return pClass;
}


CStringArray *PathFromRoot (IWbemClassObject *pObject)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	CString csProp = _T("__derivation");

	BSTR bstrTemp = csProp.AllocSysString ( );
    sc = pObject->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
	   return NULL;
	}



	long ix[2] = {0,0};
	long lLower, lUpper;

	int iDim = SafeArrayGetDim(var.parray);
	sc = SafeArrayGetLBound(var.parray,1,&lLower);
	sc = SafeArrayGetUBound(var.parray,1,&lUpper);
	BSTR bstrClass;
	CStringArray csaTmp;
	for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
	{
		sc = SafeArrayGetElement(var.parray,ix,&bstrClass);
		CString csTmp = bstrClass;
		csaTmp.Add(csTmp);
		SysFreeString(bstrClass);

	}

	CStringArray *pcsaReturn = new CStringArray;

	for (int i = (int) csaTmp.GetSize() - 1; i > -1; i--)
	{
		pcsaReturn->Add(csaTmp.GetAt(i));
	}

	CString csObject = 	GetIWbemClass(pObject);
	pcsaReturn->Add(csObject);

	VariantClear(&var);
	return pcsaReturn;

}

 //***************************************************************************
//
// ObjectIdentity
//
// Purpose: Predicate to tell if two class objects are the
//			same com object.
//
//***************************************************************************
BOOL ClassIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2)
{
	return (GetIWbemClass(piWbem1).CompareNoCase(GetIWbemClass(piWbem2)) == 0);
}

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
 CString *pcsLogMsg, char *szFile, int nLine, UINT uType)
{
	CString csCaption = _T("Class Explorer Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);

	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject)
{

	BOOL bHasServer = FALSE;
	TCHAR c1 = (*pcsNamespace)[0];
	TCHAR c2 = (*pcsNamespace)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer = TRUE;
	}

	CString csNamespace;

	CString csPath = GetIWbemFullPath(pProv,pObject);
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);
	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer && bHasServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace.CompareNoCase(*pcsNamespace) != 0;


}

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd)
{
	CWnd *pOwner = pWnd->GetOwner();
	RECT rectOwner;
	pOwner->GetClientRect(&rectOwner);

	pOwner->ClientToScreen(&rectOwner);

	RECT rect;
	pWnd->GetClientRect(&rect);

	pWnd->ClientToScreen(&rect);

	RECT rectMove;
	rectMove.left = rectOwner.left;
	rectMove.bottom = rectOwner.bottom;
	rectMove.right = rectOwner.left + (rect.right - rect.left);
	rectMove.top = rectOwner.top + (rectOwner.bottom - rect.bottom);
	pWnd->MoveWindow(&rectMove,TRUE);
}

void CenterWindowInOwner(CWnd *pWnd,CRect &rectMove)
{
	if (!pWnd)
	{
		return;
	}

	CWnd *pOwner = pWnd->GetOwner();

	if (!pOwner)
	{
		return;
	}

	CRect rectOwner;
	pOwner->GetWindowRect(&rectOwner);

	CRect rect;
	pWnd->GetWindowRect(&rect);

	if (rectOwner.Width() < rect.Width())
	{
		long delta = (long) ((rectOwner.Width() - rect.Width()) * .5);
		rectMove.left = rectOwner.left + delta;
		rectMove.right = rectOwner.right - delta;
	}
	else
	{
		long delta = (long) ((rect.Width() - rectOwner.Width()) * .5);
		rectMove.left = rectOwner.left - delta;
		rectMove.right = rectOwner.right + delta;
	}

	if (rectOwner.Height() < rect.Height())
	{
		long delta = (long) ((rectOwner.Height() - rect.Height()) * .5);
		rectMove.top = rectOwner.top + delta;
		rectMove.bottom = rectOwner.bottom - delta;
	}
	else
	{
		long delta = (long) ((rect.Height() - rectOwner.Height()) * .5);
		rectMove.top = rectOwner.top - delta;
		rectMove.bottom = rectOwner.bottom + delta;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\olemsclient.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved




#define N_INSTANCES 100

IWbemServices * InitServices(CString *pcsNameSpace = NULL, IWbemLocator *pLocator = NULL);

IWbemLocator *InitLocator();

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription);

IWbemClassObject *CreateSimpleClass
(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass,
 int &nError, CString &csError );

IWbemClassObject *GetClassObject (IWbemServices *pProv,CString *pcsClass, BOOL bQuiet = FALSE);

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, CString *pcsPropertyValue);

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, long lValue);

CString GetProperty
(IWbemClassObject * pInst, CString *pcsProperty);

CString GetBSTRProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty);

CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty);

int GetAllClasses(IWbemServices * pIWbemServices, CPtrArray &cpaClasses, CString &rcsNamespace);

CStringArray *GetAllClassPaths(IWbemServices * pIWbemServices, CString &rcsNamespace);

BOOL HasSubclasses(IWbemServices * pIWbemServices, CString *pcsClass, CString &rcsNamespace);

BOOL HasSubclasses(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass, CString &rcsNamespace);

BOOL HasSubclasses(IWbemClassObject *pimcoNew, CPtrArray *pcpaDeepEnum);

long GetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 CString &csReturn);

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 BOOL &bReturn);

SCODE MakeSafeArray
(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

BOOL DeleteAClass
(IWbemServices * pProv, CString *pcsClass);

IWbemClassObject *RenameAClass
(IWbemServices * pProv, IWbemClassObject *pimcoClass, CString *pcsNewName,
 BOOL bDeleteOriginal = FALSE);

IWbemClassObject *ReparentAClass
(IWbemServices * pProv, IWbemClassObject *pimcoParent, IWbemClassObject *pimcoChild);

CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass);

CStringArray *PathFromRoot (IWbemClassObject *pObject);

BOOL ClassIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2);

CString GetIWbemSuperClass(IWbemClassObject *pClass);

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, 
 CString *pcsLogMsg, char *szFile, int nLine, UINT uType = MB_ICONEXCLAMATION);

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine);

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject);

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd);

void CenterWindowInOwner(CWnd *pWnd,CRect &rectMove);

CString GetIWbemClass(IWbemClassObject *pClass);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\progdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ProgDlg.h : header file
// CG: This file was added by the Progress Dialog component

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

#ifndef __PROGDLG_H__
#define __PROGDLG_H__

class CProgressDlg : public CDialog
{
// Construction / Destruction
public:
    CProgressDlg(UINT nCaptionID = 0);   // standard constructor
    ~CProgressDlg();

    BOOL Create(CWnd *pParent=NULL);
	void SetMessage(CString &csMessage) 
	{m_csMessage = csMessage;}
	void SetLabel(CString &csLabel) 
	{m_csLabel = csLabel;}
	void PumpMessages();

    // Checking for Cancel button
    BOOL CheckCancelButton();
    // Progress Dialog manipulation
    void SetStatus(LPCTSTR lpszMessage);
    
// Dialog Data
    //{{AFX_DATA(CProgressDlg)
	enum { IDD = CG_IDD_PROGRESS };
	CStatic	m_cstaticMessage;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
	
	CString m_csMessage;
	CString m_csLabel;

    BOOL m_bCancel;
    BOOL m_bParentDisabled;

    void ReEnableParent();

    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    virtual BOOL OnInitDialog();
	virtual void OnCancel();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // __PROGDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\provider.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: MosProvider_v1 */

#ifndef _MosProvider_v1_H_
#define _MosProvider_v1_H_

DEFINE_GUID(LIBID_MosProvider_v1,0x027947F3L,0xD731,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

typedef enum {
    OLEMS_FLAG_KEYS_ONLY = 1,
    OLEMS_FLAG_ALWAYS,
    OLEMS_FLAG_ONLY_IF_TRUE,
    OLEMS_FLAG_ONLY_IF_FALSE,
    OLEMS_FLAG_ONLY_IF_IDENTICAL,
    OLEMS_FLAG_INCLUDE_ATTR,
    OLEMS_FLAG_CLASS_ATTRIB,
    OLEMS_FLAG_PRIVATE_ATTRIB,
    OLEMS_FLAG_TEMP_ATTRIB,
    OLEMS_FLAG_NAMESPACE_ATTRIB,
    OLEMS_FLAG_SHALLOW,
    OLEMS_FLAG_DEEP,
    OLEMS_FLAG_NO_EXPANSION,
    OLEMS_FLAG_PREFER_THIS,
    OLEMS_FLAG_PREFER_SOURCE
} OLEMS_FLAG_TYPE;

typedef enum {
    OLEMS_NO_ERROR = 0,
    OLEMS_S_NO_MORE_DATA = 262145,
    OLEMS_E_FAILED = -2147217407,
    OLEMS_E_NOT_FOUND,
    OLEMS_E_ACCESS_DENIED,
    OLEMS_E_PERMISSION_DENIED,
    OLEMS_E_PROVIDER_FAILURE,
    OLEMS_E_TYPE_MISMATCH,
    OLEMS_E_INVALID_ENV_VAR,
    OLEMS_E_OUT_OF_MEMORY,
    OLEMS_E_UNSUPPORTED_VARIANT,
    OLEMS_E_NETWORK_ERROR,
    OLEMS_E_INVALID_CONTEXT,
    OLEMS_E_INVALID_PARAMETER,
    OLEMS_E_NOT_AVAILABLE,
    OLEMS_E_CRITICAL_ERROR,
    OLEMS_E_INVALID_STREAM,
    OLEMS_E_NOT_SUPPORTED,
    OLEMS_E_INVALID_SUPERCLASS,
    OLEMS_E_INVALID_NAMESPACE,
    OLEMS_E_INVALID_OBJECT,
    OLEMS_E_INVALID_CLASS,
    OLEMS_E_PROVIDER_NOT_FOUND,
    OLEMS_E_INVALID_PROVIDER_REGISTRATION,
    OLEMS_E_PROVIDER_LOAD_FAILURE
} OLEMS_STATUS;

DEFINE_GUID(IID_IMosAttributeSet,0xDC12A680L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosAttributeSet */
#undef INTERFACE
#define INTERFACE IMosAttributeSet

DECLARE_INTERFACE_(IMosAttributeSet, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosAttributeSet methods */
    STDMETHOD_(SCODE, Get)(THIS_ BSTR Name, long lFlags, long FAR* plType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Put)(THIS_ BSTR Name, long lType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Delete)(THIS_ BSTR Name) PURE;
    STDMETHOD_(SCODE, GetNames)(THIS_ SAFEARRAY FAR* FAR* pNames) PURE;
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ long lFlags, BSTR FAR* pName, long FAR* plType, VARIANT FAR* pVal) PURE;
};

DEFINE_GUID(IID_IMosClassObject,0xDC12A681L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosClassObject */
#undef INTERFACE
#define INTERFACE IMosClassObject

DECLARE_INTERFACE_(IMosClassObject, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosClassObject methods */
    STDMETHOD_(SCODE, GetAttributeSet)(THIS_ IMosAttributeSet FAR* FAR* pAttribSet) PURE;
    STDMETHOD_(SCODE, Get)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Put)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Delete)(THIS_ BSTR Name) PURE;
    STDMETHOD_(SCODE, GetNames)(THIS_ SAFEARRAY FAR* FAR* pNames, BSTR AttrName, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetType)(THIS_ BSTR Name, long FAR* plType) PURE;
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ long lFlags, BSTR FAR* pName, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetPropAttributeSet)(THIS_ BSTR pProperty, IMosAttributeSet FAR* FAR* pAttribSet) PURE;
    STDMETHOD_(SCODE, Clone)(THIS_ IMosClassObject FAR* FAR* pCopy) PURE;
    STDMETHOD_(SCODE, CopyHere)(THIS_ IMosClassObject FAR* pSrc) PURE;
    STDMETHOD_(SCODE, Merge)(THIS_ long lFlags, IMosClassObject FAR* pSrc) PURE;
    STDMETHOD_(SCODE, PutAttribForAllProps)(THIS_ BSTR Name, long lType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, DeleteAttribForAllProps)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, DeleteProps)(THIS_ BSTR Attrib, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetObjectText)(THIS_ BSTR FAR* pMofSyntax) PURE;
};

DEFINE_GUID(IID_IMosNotify,0x7C857801L,0x7381,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosNotify */
#undef INTERFACE
#define INTERFACE IMosNotify

DECLARE_INTERFACE_(IMosNotify, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosNotify methods */
    STDMETHOD_(SCODE, Notify)(THIS_ long lObjectCount, IMosClassObject FAR* FAR* pObjArray) PURE;
};

DEFINE_GUID(IID_IEnumMosClassObject,0x027947E1L,0xD731,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

/* Definition of interface: IEnumMosClassObject */
#undef INTERFACE
#define INTERFACE IEnumMosClassObject

DECLARE_INTERFACE_(IEnumMosClassObject, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IEnumMosClassObject methods */
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ ULONG uCount, IMosClassObject FAR* FAR* pProp, ULONG FAR* puReturned) PURE;
    STDMETHOD_(SCODE, Clone)(THIS_ IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, Skip)(THIS_ ULONG nNum) PURE;
};

DEFINE_GUID(IID_IMosProvider,0x9556DC99L,0x828C,0x11CF,0xA3,0x7E,0x00,0xAA,0x00,0x32,0x40,0xC7);

/* Definition of interface: IMosProvider */
#undef INTERFACE
#define INTERFACE IMosProvider

DECLARE_INTERFACE_(IMosProvider, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosProvider methods */
    STDMETHOD_(SCODE, OpenNamespace)(THIS_ BSTR ObjectPath, BSTR User, BSTR Password, IMosProvider FAR* FAR* pNewContext) PURE;
    STDMETHOD_(SCODE, QueryNotificationHandler)(THIS_ IMosNotify FAR* FAR* pHandler) PURE;
    STDMETHOD_(SCODE, CreateClass)(THIS_ long lFlags, BSTR Parent, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, DeleteClass)(THIS_ BSTR Class, long lFlags) PURE;
    STDMETHOD_(SCODE, CreateClassEnum)(THIS_ BSTR Parent, long lFlags, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, CreateClassEnumAsync)(THIS_ BSTR RefClass, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, UpdateClass)(THIS_ long lFlags, IMosClassObject FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetClass)(THIS_ BSTR Class, long lFlags, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetClassAsync)(THIS_ BSTR Class, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, CreateInstance)(THIS_ BSTR Class, long lFlags, IMosClassObject FAR* FAR* pInst) PURE;
    STDMETHOD_(SCODE, UpdateInstance)(THIS_ long lFlags, IMosClassObject FAR* pInst) PURE;
    STDMETHOD_(SCODE, DeleteInstance)(THIS_ BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, CreateInstanceEnum)(THIS_ long lFlags, BSTR Class, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, CreateInstanceEnumAsync)(THIS_ BSTR Class, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, LockInstance)(THIS_ long lFlags, BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, UnlockInstance)(THIS_ BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, RefreshInstance)(THIS_ long lFlags, IMosClassObject FAR* pObj) PURE;
    STDMETHOD_(SCODE, RefreshInstanceAsync)(THIS_ long lFlags, IMosClassObject FAR* pObj, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, GetObjectByPath)(THIS_ BSTR ObjectPath, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetObjectByPathAsync)(THIS_ BSTR ObjectPath, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecQuery)(THIS_ BSTR QueryFormat, BSTR Query, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, ExecQueryAsync)(THIS_ BSTR QueryFormat, BSTR Query, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecQueryIndirect)(THIS_ BSTR QueryObjectPath, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, ExecQueryIndirectAsync)(THIS_ BSTR QueryObjectPath, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecMethod)(THIS_ BSTR Object, BSTR MethodEncodingFormat, void FAR* InboundEncoding, void FAR* FAR* OutboundEncoding) PURE;
    STDMETHOD_(SCODE, GetErrorInformation)(THIS_ long LocaleId, BSTR FAR* pErrorInfo) PURE;
};

DEFINE_GUID(IID_IMosLocator,0xDC12A687L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosLocator */
#undef INTERFACE
#define INTERFACE IMosLocator

DECLARE_INTERFACE_(IMosLocator, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosLocator methods */
    STDMETHOD_(SCODE, ConnectServer)(THIS_ BSTR ObjectPath, BSTR User, BSTR Password, long lFlags, IMosProvider FAR* FAR* pNamespace) PURE;
};

DEFINE_GUID(CLSID_MosLocator,0xD85ADEF1L,0xDD7F,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

#ifdef __cplusplus
class MosLocator;
#endif

DEFINE_GUID(CLSID_MosClassObject,0xD85ADEF2L,0xDD7F,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

#ifdef __cplusplus
class MosClassObject;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\renameclassdialog.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: renameclassdialog.cpp
//
// Description:
//	This file implements the CRenameClassDIalog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX,
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a new name for an
//			existing class.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CClassTree
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "classnav.h"
#include "RenameClassDIalog.h"
#include "wbemidl.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//****************************************************************************
//
// CRenameClassDIalog::CRenameClassDIalog
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
CRenameClassDIalog::CRenameClassDIalog(CClassNavCtrl *pParent)
	: CDialog(CRenameClassDIalog::IDD, NULL)
{
	//{{AFX_DATA_INIT(CRenameClassDIalog)
	m_csatOldName = _T("");
	m_csNewName = _T("");
	//}}AFX_DATA_INIT
	m_pParent = pParent;
}

// ***************************************************************************
//
// CRenameClassDIalog::DoDataExchange
//
// Description:
//	  Called by the framework to exchange and validate dialog data.
//
// Parameters:
//	  pDX			A pointer to a CDataExchange object.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CRenameClassDIalog::DoDataExchange(CDataExchange* pDX)
{

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRenameClassDIalog)
	DDX_Text(pDX, IDC_STATICOLDCLASS, m_csatOldName);
	DDX_Text(pDX, IDC_EDIT1, m_csNewName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameClassDIalog, CDialog)
	//{{AFX_MSG_MAP(CRenameClassDIalog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*	EOF:  renameclassdialog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClassNav.rc
//
#define IDS_CLASSNAV                    1
#define IDD_ABOUTBOX_CLASSNAV           1
#define IDB_CLASSNAV                    1
#define IDI_ABOUTDLL                    1
#define IDS_CLASSNAV_PPG                2
#define IDS_CLASSNAV_PPG_CAPTION        100
#define IDD_PROPPAGE_CLASSNAV           100
#define CG_IDR_POPUP_A_TREE_CTRL        101
#define CG_IDD_PROGRESS                 102
#define CG_IDC_PROGDLG_STATUS           103
#define IDB_BITMAPCLASS                 201
#define IDC_EDIT1                       201
#define IDB_BITMAPCHECKED               202
#define IDC_EDITPARENT                  203
#define IDB_BITMAPTREE                  204
#define IDC_STATICOLDCLASS              204
#define IDB_BITMAPNEWCLASS              205
#define IDC_NSENTRYCTRLINITNAMESPACE    205
#define IDD_DIALOGADDCLASS              206
#define IDB_BITMAPCHECKEDNEW            206
#define IDD_DIALOGRENAMECLASS           207
#define IDB_BITMAPDELETED               207
#define IDB_BITMAPADDD                  208
#define IDD_DIALOGSEARCHFORCLASS        208
#define IDB_BITMAPADDU                  209
#define IDB_BITMAPDELETEU               210
#define IDB_TOOLBARADDDELETE            211
#define IDC_LIST_SEARCH_RESULTS         212
#define IDC_BUTTON_SEARCH               213
#define IDR_TOOLBARADDDELETE            214
#define IDI_ICONPLACEHOLDER             216
#define IDI_ICONPLACEHOLDERCHECKED      217
#define IDB_BITMAPCHECKS                217
#define IDI_ICONOBJECTCLASS             218
#define IDD_DIALOGINITNAMESPACE         218
#define IDI_ICONOBJECTCLASSCHECKED      219
#define IDI_ICONASSOCCLASS              220
#define IDI_ICONASSOCCLASSCHECKED       221
#define IDC_CHECK_SEARCH_CLASS          222
#define IDC_CHECK_SEARCH_DESCRIPTIONS   223
#define IDC_CHECK_SEARCH_PROPERTIES     224
#define ID_VIEWOBJECT                   32768
#define ID_SETROOT                      32769
#define ID_CLEAREXTENDEDSELECTION       32770
#define ID_BUTTON32773                  32773
#define ID_BUTTONADD                    32773
#define ID_BUTTON32774                  32774
#define ID_BUTTONDELETE                 32774
#define ID_POPUP_SEARCHFORCLASS         32775
#define ID_BUTTONGO                     32776
#define ID_POPUP_SELECTALL              32777
#define ID_BUTTON32778                  32778
#define ID_BUTTONCLASSSEARCH            32779
#define ID_MENUITEMREFRESH              32780
#define ID_POPUP_ADDCLASS               32781
#define ID_POPUP_DELETECLASS            32782
#define ID_POPUP_RENAMECLASS            32783


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        225
#define _APS_NEXT_COMMAND_VALUE         32784
#define _APS_NEXT_CONTROL_VALUE         225
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\treedroptarget.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: treedroptarget.h
//
// Description:
//	This file defines the CTreeDropTarget class which is a part of the  
//	Class Explorer OCX, it is a subclass of the Microsoft COleDropTarget
//  and provides an implementation for the base class' virtual member
//	functions specialized for the CClassTree class.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	CClassTree
//	 
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

//****************************************************************************
//
// CLASS:  CTreeDropTarget
//
// Description:
//	  This class is a subclass of the Microsoft COleDropTarget.  It provides 
//	  an implementation for the base class' virtual member functions 
//	  specialized for the CClassTree class.
//
// Public members:
//	
//	  CTreeDropTarget	Public constructor.
//	  OnDrop			Called when data is dropped.
//	  OnDropEx			Called when the an extended drop occurs.
//	  OnDragEnter		Called when the drag cursor first enters a window.
//	  OnDragOver		Called when the drag cursor drags across the window.
//	  OnDragLeave		Called when the drag cursor leaves the window
//	  OnDragScroll		Called to when the drag cursor is in the scroll area 
//						of a window. 	  
//
//============================================================================
//
// CTreeDropTarget::CTreeDropTarget
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassTree *pControl		Tree that contains the drop target.
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CTreeDropTarget::OnDrop
//
// Description:
//	  Called when a drop occurs in the class tree.
//
// Parameters:
//	  CWnd* pWnd	The window the drop occured on.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DROPEFFECT dropEffect
//					The effect that the user chose for the drop operation
//	  CPoint point	Window coord.
//
// Returns:
// 	  BOOL			Nonzero if the drop is successful; otherwise 0.
//
//============================================================================
//
// CTreeDropTarget::OnDragEnter
//
// Description:
//	  Called when the drag cursor first enters a window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.  
//
//============================================================================
//
// CTreeDropTarget::OnDragOver
//
// Description:
//	  Called when the drag cursor drags across the window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.  
//
//============================================================================
//
// CTreeDropTarget::OnDropEx
//
// Description:
//	  Called when the an extended drop occurs. 
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.  
//
//============================================================================
//
// CTreeDropTarget::OnDragLeave
//
// Description:
//	  Called when the drag cursor leaves the window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//
// Returns:
// 	  VOID  
//
//============================================================================
//
// CTreeDropTarget::OnDragScroll
//
// Description:
//	  Called to when the drag cursor is in the scroll area of a window. 
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.  
//
//****************************************************************************

#ifndef __OCXOLEDROPTARGET_HEADER
#define __OCXOLEDROPTARGET_HEADER


class CClassTree;

class CTreeDropTarget  :public COleDropTarget 
{
public:
	CTreeDropTarget(CClassTree *pControl);

	// Overrides of COleDropTarget virtual functions

	// Called when data is dropped.
	virtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
			DROPEFFECT dropEffect, CPoint point);
	// Called when the drag cursor first enters a window
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, 
		COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	// Called when the drag cursor drags across the window.
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
	// Called when the drag cursor leaves the window
	virtual void OnDragLeave(CWnd* pWnd);
	// Called to when the drag cursor is in the scroll area of a window.
	virtual DROPEFFECT OnDragScroll(CClassTree* pWnd, DWORD dwKeyState, 
	CPoint point);

protected:
	CClassTree *m_pControl;
	virtual DROPEFFECT FilterDropEffect
		(DROPEFFECT dropEffect, DROPEFFECT dwEffects);
	BOOL m_bScrolling;
public: 
	// This macro defines the OLE COM interface for the drop target.
	// COM defines the essential nature of an OLE Component. In OLE,
	// a component object is made up of a set of data and functions 
	// that manipulate the data. The functions are grouped into sets 
	// which are called interfaces.  The only way to gain access to 
	// COM object is through an interface pointer and the interface's
	// methods.  OnDropEx is not part of the interface.  The interface
	// methods call the CTreeDropTarget member functions which call
	// the CClassTree C++ object's methods.
	//
	// This interface is implemented as a C++ object which is contained
	// in the CTreeDropTarget class.  
	BEGIN_INTERFACE_PART(DropTarget, IDropTarget)
		STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
		STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
		STDMETHOD(DragLeave)();
		STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
		DROPEFFECT(OnDragScroll)(CWnd*, DWORD ,CPoint);
	END_INTERFACE_PART(DropTarget)
	
	// The
	//   DECLARE_INTERFACE_MAP()
	// macro allows the above interface to be added to the
	// control's interface map which serves to create aggregated
	// OLE components.
	DECLARE_INTERFACE_MAP()
	
};

// This is a safe macro to be used in place of calling Release
// directly on an interface pointer.
#define RELEASE(lpUnk) do \
	{ if ((lpUnk) != NULL) { (lpUnk)->Release(); (lpUnk) = NULL; } } \
	while (0)



#endif

/*	EOF:  treedroptarget.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\arraygrid.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _ArrayGrid_h
#define _ArrayGrid_h


#include "gc.h"

class CArrayGrid : public CGrid
{
public:
	CArrayGrid(BOOL bNumberRows);
	~CArrayGrid();
	void SetObjectParams(IWbemServices* psvc, CString& sClassname);
	SCODE Load(CGridCell* pgc);
	SCODE Save();

	SCODE GetValueAt(SAFEARRAY* psa, long lRow, COleVariant& var);
	SCODE SaveValueAt(SAFEARRAY* psa, long lRow);

	void OnRowHandleDoubleClicked(int iRow);
	void OnCellDoubleClicked(int iRow, int iCol); // Override base class method
	virtual BOOL OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus);
	virtual BOOL OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual BOOL OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnCellContentChange(int iRow, int iCol);
	virtual int CompareRows(int iRow1, int iRow2, int iSortOrder);
	virtual SCODE GetObjectClass(CString& sClass, int iRow, int iCol);
	virtual IWbemServices* GetWbemServicesForObject(int iRow, int iCol) {return m_psvc; }

	virtual BOOL GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bTargetGetsEditCommands);
	virtual void ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu);
	virtual BOOL OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnCellClicked(int iRow, int iCol);
//	virtual void OnCellClickedEpilog(int iRow, int iCol);



	BOOL CanEdit() {return TRUE; }
	CIMTYPE Cimtype() {return m_cimtype; }
//	void ChangeType(VARTYPE vt, CimType cimtype);

	CIMTYPE m_cimtype;
	BOOL GetModified();
	BOOL SetModified(BOOL bModified);
	BOOL IsReadOnly() {return m_bReadOnly; }
	BOOL IsBooleanCell(int iRow, int iCol);
	void SetBooleanCellValue(int iRow, int iCol, BOOL bValue);


//	BOOL GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands);
	//{{AFX_MSG(CArrayGrid)
	//}}AFX_MSG

	afx_msg void OnCmdCreateValue();
	afx_msg void OnContextMenu(CWnd*, CPoint point);

	DECLARE_MESSAGE_MAP()

private:
	void ClearEmptyRow();
	int IndexOfEmptyRow();
	void AddRow();
	BOOL m_bModified;
	BOOL m_bReadOnly;
	CPoint m_ptContextMenu;
	CString m_sClassname;
	IWbemServices* m_psvc;
	CGridCell* m_pgcEdit;
};




#endif //_ArrayGrid_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\renameclassdialog.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: renameclassdialog.h
//
// Description:
//	This file declares the CRenameClassDIalog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Class Explorer OCX, 
//	and it performs the following functions:
//		a.  Allows the user to type in the name of a new name for an
//			existing class.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by:
//	CClassTree 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CRenameClassDIalog
//
// Description:
//	  This class which is a subclass of the MFC CDialog class.  It allows the 
//	  user to type in a new name for an existing class.
//
// Public members:
//	
//	  CRenameClassDIalog	Public constructor.
//	  SetOldName			Sets initial value of the name of an existing 
//							class.
//	  SetNewName			Sets initial value of the new name of an existing 
//							class.
//	  GetNewName			Gets the new name.
//
//============================================================================
//
// CRenameClassDIalog::CRenameClassDIalog
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CRenameClassDIalog::SetOldName
//
// Description:
//	  Sets the initial value of the class' current name.
//
// Parameters:
//	  CString *pcs			Class' current name.
//
// Returns:
// 	  VOID
//
//============================================================================
//
// CRenameClassDIalog::SetNewName
//
// Description:
//	  Sets the initial value of the class' new name.
//
// Parameters:
//	  CString *pcs			Class' current name.
//
// Returns:
// 	  VOID
//
//============================================================================
//
// CRenameClassDIalog::GetNewName
//
// Description:
//	  Gets the value of the class' new name.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  CString				Class' new name.
//
//****************************************************************************

#ifndef _CRenameClassDialog_H_
#define _CRenameClassDialog_H_

class CClassNavCtrl;

class CRenameClassDIalog : public CDialog
{
public:

	CRenameClassDIalog(CClassNavCtrl *pParent = NULL);   // standard constructor
	void SetOldName(CString *pcs) {m_csatOldName = *pcs;}
	void SetNewName(CString *pcs) {m_csNewName = *pcs;}
	CString GetNewName() {return m_csNewName;}

protected:

	//{{AFX_DATA(CRenameClassDIalog)
	enum { IDD = IDD_DIALOGRENAMECLASS };
	CString	m_csatOldName;
	CString	m_csNewName;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRenameClassDIalog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CClassNavCtrl *m_pParent;
	// Generated message map functions
	//{{AFX_MSG(CRenameClassDIalog)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

/*	EOF:  renameclassdialog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\arraygrid.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996, 1997 by Microsoft Corporation
//
//  ArrayGrid.cpp
//
//  This file contains the implementation for the array grid that is
//  displayed for cells containing arrays.
//
//  a-larryf    08-May-97   Created.
//
//***************************************************************************

#include "precomp.h"
#include "globals.h"
#include "gc.h"
#include "gca.h"
#include "gridhdr.h"
#include "grid.h"
#include "resource.h"
#include "ArrayGrid.h"
#include "hmmverr.h"
#include "utils.h"
#include "DlgObjectEditor.h"



#define CX_COLUMN 200



BEGIN_MESSAGE_MAP(CArrayGrid, CGrid)
	//{{AFX_MSG_MAP(CGrid)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_CMD_CREATE_VALUE, OnCmdCreateValue)
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()


CArrayGrid::CArrayGrid(BOOL bNumberRows)
{
	m_psvc = NULL;
	AddColumn(CX_COLUMN, _T("Value"));
	m_bModified = FALSE;
	NumberRows(bNumberRows, FALSE);
	SetNullCellDrawMode(FALSE);
}



CArrayGrid::~CArrayGrid()
{
	if (m_psvc != NULL) {
		m_psvc->Release();
	}
}



//************************************************************
// CArrayGrid::GetValueAt
//
// Copy a value from the safe array to the a variant.
//
// Parameters:
//		SAFEARRAY* psa
//			Pointer to the source SAFEARRAY containing the value.
//
//		long lIndex
//			The element's index.
//
//		COleVariant& var
//			The variant to copy the value to.
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL if the operation could not
//			be done because of an invalid type, etc.
//
//***************************************************************
SCODE CArrayGrid::GetValueAt(SAFEARRAY* psa, long lIndex, COleVariant& var)
{
	var.Clear();

	HRESULT hr;
	VARTYPE vt = VtFromCimtype(m_cimtype);
	switch(vt) {
	case VT_BOOL:
		hr = SafeArrayGetElement(psa, &lIndex, &var.boolVal);
		var.vt = VT_BOOL;
		break;
	case VT_BSTR:
		hr = SafeArrayGetElement(psa, &lIndex, &var.bstrVal);
		var.vt = VT_BSTR;
		break;
	case VT_I2:
		hr = SafeArrayGetElement(psa, &lIndex, &var.iVal);
		var.vt = VT_I2;
		break;
	case VT_I4:
		hr = SafeArrayGetElement(psa, &lIndex, &var.lVal);
		var.vt = VT_I4;
		break;
	case VT_R4:
		hr = SafeArrayGetElement(psa, &lIndex, &var.fltVal);
		var.vt = VT_R4;
		break;
	case VT_R8:
		hr = SafeArrayGetElement(psa, &lIndex, &var.dblVal);
		var.vt = VT_R8;
		break;
	case VT_UI1:
		hr = SafeArrayGetElement(psa, &lIndex, &var.bVal);
		var.vt = VT_UI1;
		break;
	case VT_UNKNOWN:
		hr = SafeArrayGetElement(psa, &lIndex, &var.punkVal);
		if (SUCCEEDED(hr)) {
			var.punkVal->AddRef();
			var.vt = VT_UNKNOWN;
		}
		break;
	default:
		ASSERT(FALSE);
		return E_FAIL;
		break;
	}
	return S_OK;
}



//**************************************************************
// CArrayGrid::SaveValueAt
//
// Copy the value at the specified cell to the corresponding
// element in the safe array.
//
// Parameters:
//		SAFEARRAY* psa
//			Pointer to the destination safe array.
//
//		long lRow
//			The row index of the cell (the column index is assumed to
//			be zero).
//
// Returns:
//		SCODE
//			S_OK if the value was copied successfully, FALSE otherwise.
//
//**************************************************************
SCODE CArrayGrid::SaveValueAt(SAFEARRAY* psa, long lRow)
{
	CGridCell& gc = GetAt(lRow, 0);

	COleVariant var;
	CIMTYPE cimtype;
	HRESULT hr;

	gc.GetValue(var, cimtype);
	VARTYPE vt = VtFromCimtype(cimtype);
	if (var.vt == VT_NULL) {
		switch(vt) {
		case VT_BSTR:
			var = "";
			break;
		default:
			var.ChangeType(vt);
			break;
		}
	}


	switch(vt) {
	case VT_BOOL:
		hr = SafeArrayPutElement(psa, &lRow, &var.boolVal);
		break;
	case VT_BSTR:
		hr = SafeArrayPutElement(psa, &lRow, var.bstrVal);
		break;
	case VT_I2:
		hr = SafeArrayPutElement(psa, &lRow, &var.iVal);
		break;
	case VT_I4:
		hr = SafeArrayPutElement(psa, &lRow, &var.lVal);
		break;
	case VT_R4:
		hr = SafeArrayPutElement(psa, &lRow, &var.fltVal);
		break;
	case VT_R8:
		hr = SafeArrayPutElement(psa, &lRow, &var.dblVal);
		break;
	case VT_UI1:
		hr = SafeArrayPutElement(psa, &lRow, &var.bVal);
		break;
	case VT_UNKNOWN:
		if (var.vt != VT_NULL) {
			var.punkVal->AddRef();
			hr = SafeArrayPutElement(psa, &lRow, var.punkVal);
		}
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	// !!!CR: Should test the "hr" value above at this point.
	return S_OK;
}




//**************************************************************
// CArrayGrid::Save
//
// Copy the array from the grid into the variant.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if the copy is successful, otherwise E_FAIL if
//			the grid contains an invalid value.
//
//**************************************************************
SCODE CArrayGrid::Save()
{
	SCODE sc;
	sc = SyncCellEditor();
	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_INVALID_CELL_VALUE,  sc,  FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}


	SAFEARRAY *psaDst;
	LONG nRows = GetRows() - 1;
	VARTYPE vt = VtFromCimtype(m_cimtype);
	MakeSafeArray(&psaDst, vt, nRows);

	m_pgcEdit->m_varValue.Clear();
	m_pgcEdit->m_varValue.vt = VT_ARRAY | vt;
	m_pgcEdit->m_varValue.parray = psaDst;

	for (LONG lRow = 0; lRow < nRows; ++lRow) {
		SaveValueAt(psaDst, lRow);
	}
	return S_OK;
}




//********************************************************
// CArrayGrid::Load
//
// Load the array from the variant into this grid.
//
// Parameters:
//		[in] CGidCell* pgcEdit
//			The grid cell to edit.
//
// Returns:
//		Nothing.
//
//********************************************************
SCODE CArrayGrid::Load(CGridCell* pgcEdit)
{
	m_pgcEdit = pgcEdit;
	m_cimtype = pgcEdit->GetCimtype() & CIM_TYPEMASK;
	m_bReadOnly = pgcEdit->IsReadonly();
	m_bModified = FALSE;

	COleVariant varValue;
	CGridCell* pgc;


	if (!m_bReadOnly) {
		// Insert an "empty" row at the bottom if we allow editing.
		AddRow();
	}

	if (pgcEdit->IsArray()  && !pgcEdit->IsNull()) {
		COleVariant var;
		CIMTYPE cimtype;

		// !!!CR: If getting the variant copies it, we should find a more
		// !!!CR: efficient way to do this.
		pgcEdit->GetValue(var, cimtype);


		SAFEARRAY* psa = var.parray;
		long lLBound;
		long lUBound;
		SafeArrayGetLBound(psa, 1, &lLBound);
		SafeArrayGetUBound(psa, 1, &lUBound);


		int nValues = lUBound - lLBound + 1;
		int iRowDst = 0;
		for (int iIndex=0; iIndex < nValues; ++iIndex) {
			AddRow();
			pgc = &GetAt(iRowDst, 0);

			SCODE sc = GetValueAt(psa, iIndex, varValue);
			if (FAILED(sc)) {
				DeleteRowAt(iRowDst, FALSE);
				continue;
			}
			++iRowDst;

			pgc->SetValue(CELLTYPE_VARIANT, varValue, m_cimtype);
			if (m_bReadOnly) {
				pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
			}
			pgc->SetModified(FALSE);
		}
	}

	return S_OK;
}




//*******************************************************
// CArrayGrid::AddRow
//
// Add a row to the array grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//******************************************************
void CArrayGrid::AddRow()
{
	int iEmptyRow = IndexOfEmptyRow();

	if (iEmptyRow != NULL_INDEX) {
		if (IsBooleanCell(iEmptyRow, 0)) {
			CGridCell* pgcEmpty = &GetAt(iEmptyRow, 0);
			if (pgcEmpty->IsNull()) {
				SetBooleanCellValue(iEmptyRow, 0, FALSE);
				RefreshCellEditor();
			}
		}
	}


	int nRows = GetRows();
	InsertRowAt(nRows);

	const CGcType& typeEdit = m_pgcEdit->type();

	CGcType type;
	type.SetCellType((CellType) typeEdit);
	type.SetCimtype(((CIMTYPE) typeEdit) & ~CIM_FLAG_ARRAY);

	CGridCell* pgc = &GetAt(nRows, 0);
	pgc->SetToNull();
	pgc->ChangeType(type);


	int iLastRow = GetRows() - 1;
	if (iLastRow >= 0) {
		EnsureRowVisible(iLastRow);
	}

	RedrawWindow();
}

BOOL CArrayGrid::IsBooleanCell(int iRow, int iCol)
{
	ASSERT(iRow != NULL_INDEX);
	ASSERT(iCol != NULL_INDEX);

	// Initialize the boolean value that we're editing to true
	CGridCell* pgc = &GetAt(iRow, iCol);
	CGcType type = pgc->type();
	CIMTYPE cimtype = (CIMTYPE) type;

	BOOL bIsBoolean = ((cimtype & ~CIM_FLAG_ARRAY) == CIM_BOOLEAN);
	return bIsBoolean;
}


void CArrayGrid::SetBooleanCellValue(int iRow, int iCol, BOOL bValue)
{
	ASSERT(iRow != NULL_INDEX);
	ASSERT(iCol != NULL_INDEX);
	ASSERT(IsBooleanCell(iRow, iCol));

	// Initialize the boolean value that we're editing to true
	CGridCell* pgc = &GetAt(iRow, iCol);
	CGcType type = pgc->type();
	CIMTYPE cimtype = (CIMTYPE) type;
	COleVariant varValue;
	varValue.ChangeType(VT_BOOL);
	varValue.boolVal = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	pgc->SetValue(type, varValue);
}


BOOL CArrayGrid::OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	int iSelectedRow;
	int iSelectedCol;
	GetSelectedCell(iSelectedRow, iSelectedCol);
	if (iRow!=iSelectedRow || iCol!=iSelectedCol) {
		OnCellClicked(iRow, iCol);
	}

	return FALSE;
}


//**********************************************************
// CArrayGrid::OnCellClickedEpilog
//
// The grid class calls this method when a cell is clicked.
//
// Parameters:
//		int iRow
//			The row index of the clicked cell.
//
//		int iCol
//			The column index of the clicked cell.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CArrayGrid::OnCellClicked(int iRow, int iCol)
{
	OnCellDoubleClicked(iRow, iCol);
}


//********************************************************************
// CArrayGrid::OnCellFocusChange
//
// This virtual method is called by the CGrid base class to notify
// derived classes when the focus is about to change from one cell
// to another.
//
// Paramters:
//		[in] int iRow
//			The row index of the cell.
//
//		[in] int iCol
//			The column index of the cell.  If iCol is NULL_INDEX and
//			iRow is valid, then an entire row is being selected.
//
//		[in] int iNextRow
//			The next row that will be selected.  This parameter is provided
//			as a hint and is valid only if bGotFocus is FALSE.
//
//		[in] int iNextCol
//			The column index of the next cell that will get the focus when the
//			current cell is loosing focus.  This parameter is provided as a hint and
//			is valid only if bGotFocus is FALSE.
//
//		[in] BOOL bGotFocus
//			TRUE if the cell is getting the focus, FALSE if the cell is
//			about to loose the focus.
//
// Returns:
//		TRUE if it is OK for the CGrid class to complete the focus change
//		FALSE if the focus change should be aborted.
//
//*********************************************************************
BOOL CArrayGrid::OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus)
{
	SCODE sc;
	if (!bGotFocus) {
		sc = SyncCellEditor();
		if (FAILED(sc)) {
			HmmvErrorMsg(IDS_INVALID_CELL_VALUE,  sc,   FALSE, NULL, _T(__FILE__),  __LINE__);
			return FALSE;
		}

		if ((iRow != NULL_INDEX ) && (iCol != NULL_INDEX)) {
			CGridCell* pgc = &GetAt(iRow, iCol);
			if (pgc->IsNull()) {
				// Null cells are now allowed.
				int iEmptyRow = IndexOfEmptyRow();
				if (iRow != iEmptyRow) {
					return FALSE;
				}
			}
		}

	}
	return TRUE;
}




//******************************************************
// CArrayGrid::OnCellDoubleClicked
//
// This method overrides CGrid equivallent so that a new
// row can be created when the used double-clicks the
// empty row at the bottom of the grid if it exists.
//
// Parameters:
//		int iRow
//			The row index.
//
//		int iCol
//			The column index.
//
// Returns:
//		Nothing.
//
//*******************************************************
void CArrayGrid::OnCellDoubleClicked(int iRow, int iCol)
{
	int iEmptyRow = IndexOfEmptyRow();
	if (!m_bReadOnly && iRow==iEmptyRow) {

		SCODE sc = SyncCellEditor();
		if (FAILED(sc)) {
			HmmvErrorMsg(IDS_INVALID_CELL_VALUE,  sc,   FALSE, NULL, _T(__FILE__),  __LINE__);
			return;
		}

		EndCellEditing();
		SelectCell(iEmptyRow, 0, TRUE);

		CGridCell* pgcEmpty = &GetAt(iEmptyRow, 0);

		switch((CIMTYPE) pgcEmpty->type()) {
		case CIM_OBJECT:
		case CIM_DATETIME:
			if (pgcEmpty->IsNull()) {
				return;
			}
			break;
		default:
			if (pgcEmpty->IsNull()) {
				pgcEmpty->SetDefaultValue();
				RefreshCellEditor();
			}
			break;
		}

		// Add a new empty row with a null value.
		if (((m_cimtype & ~CIM_FLAG_ARRAY))!=CIM_OBJECT || (m_psvc != NULL)) {
			SelectCell(NULL_INDEX, NULL_INDEX);
			AddRow();
			RedrawCell(iEmptyRow, 0);
		}
		SelectCell(iRow, iCol);
	}
}


//*********************************************************
// CArrayGrid::ClearEmptyRow()
//
// Clear the emtpy row to an empty string with CELLTYPE_VOID.
// Doing so gives the user the appearance of an empty cell that
// he or she can set the cursor on.
//
// This is useful after editing a new row and then aborting the
// edit.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CArrayGrid::ClearEmptyRow()
{
	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow == NULL_INDEX) {
		return;
	}

	CGcType type(CELLTYPE_VARIANT, CIM_STRING);
	CGridCell& gc = GetAt(iEmptyRow, 0);
	gc.SetValue(type, _T(""));
}

//**********************************************************
// CArrayGrid::OnRowHandleDoubleClicked
//
// Override the CGrid method to create a new row when the
// row handle of the empty row is double-clicked.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CArrayGrid::OnRowHandleDoubleClicked(int iRow)
{
	OnCellDoubleClicked(iRow, 0);

#if 0
	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow == NULL_INDEX || (iRow < iEmptyRow)) {
		return;
	}

	AddRow();

	CGridCell* pgc = &GetAt(iEmptyRow, 0);
	if (pgc->RequiresSpecialEditing()) {
		BeginCellEditing();
		pgc->DoSpecialEditing();
		if (pgc->IsNull()) {
			DeleteRowAt(IndexOfEmptyRow(), TRUE);
			ClearEmptyRow();
		}
		EndCellEditing();
		SelectCell(iEmptyRow, 0);
		RedrawCell(iEmptyRow, 0);
	}
#endif //0

}






//*****************************************************************************
// CArrayGrid::OnCellChar
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a WM_CHAR message was recieved.
//
// Parameters:
//		int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		int iCol
//			The column index of the cell that the keystroke occurred in.
//
//		UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CArrayGrid::OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// Check to see if we are on the "empty" row at the bottom of the grid.
	// If so, then create a new property.
	EnsureRowVisible(iRow);

	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX  && iRow==iEmptyRow) {
		AddRow();
		CGridCell* pgc = &GetAt(iRow, iCol);
		if (pgc->RequiresSpecialEditing()) {
			BeginCellEditing();
			pgc->DoSpecialEditing();
			if (pgc->IsNull()) {
				if (((CIMTYPE) pgc->type()) == CIM_OBJECT) {
					DeleteRowAt(IndexOfEmptyRow(), TRUE);
					ClearEmptyRow();
				}
			}
			EndCellEditing();
			SelectCell(iEmptyRow, 0);
			RedrawCell(iEmptyRow, 0);
		}
	}


	// We don't handle this event.
	return FALSE;
}




//***********************************************************
// CArrayGrid::IndexOfEmptyRow
//
// Return the index of the empty row at the bottom of the grid.
// If the array is read-only, then return NULL_INDEX.
//
// Parameters:
//		None.
//
// Returns:
//		int
//			The index of the empty row at the bottom of the grid
//			or NULL_INDEX if there is no empty row.
//
//***********************************************************
int CArrayGrid::IndexOfEmptyRow()
{
	if (m_bReadOnly) {
		return NULL_INDEX;
	}
	else {
		return GetRows() - 1;
	}
}



//***********************************************************
// CArrayGrid::GetModified
//
// Check to see if the grid has been modified.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the grid was modified, FALSE otherwise.
//
//************************************************************
BOOL CArrayGrid::GetModified()
{
	return m_bModified;
}





//************************************************************
// CArrayGrid::SetModified
//
// Set the modified flag of all the grid cells to the given value.
//
// Parameters:
//		BOOL bModified
//			The new value to set the modified flag to.
//
// Returns:
//		BOOL
//			The previous value of the m_bModified flag.
//
//************************************************************
BOOL CArrayGrid::SetModified(BOOL bModified)
{
	BOOL bInitialValue = m_bModified;

	int nRows = m_bReadOnly ? GetRows() : GetRows() -1;
	for (int iRow = 0; iRow < nRows; ++iRow) {
		CGridCell* pgc = &GetAt(iRow, 0);
		pgc->SetModified(bModified);
	}
	bModified = bModified;
	return bInitialValue;
}



//*******************************************************************
// CArrayGrid::OnCellContentChange
//
// Override this virtual method in CGrid to detect changes to a grid
// cell.
//
// Parameters:
//		int iRow
//			The row index of the cell modified.
//
//		int iCol
//			The column index of the cell modified.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CArrayGrid::OnCellContentChange(int iRow, int iCol)
{
	if (!m_bReadOnly) {
		int iEmptyRow = IndexOfEmptyRow();
		if (iRow == iEmptyRow) {
			SCODE sc = SyncCellEditor();
			if (SUCCEEDED(sc)) {
				CGridCell* pgc = &GetAt(iRow, iCol);
				if (!pgc->IsNull() && (m_psvc != NULL)) {
					AddRow();
				}
			}
		}
	}
	m_bModified = TRUE;
}




//*****************************************************************************
// CArrayGrid::OnRowKeyDown
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a key was pressed while the focus was set to a grid cell.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		[in] UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		[in] UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		[in] UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CArrayGrid::OnRowKeyDown(
	/* in */ int iRow,
	/* in */ UINT nChar,
	/* in */ UINT nRepCnt,
	/* in */ UINT nFlags)
{

	switch(nChar) {
	case VK_DELETE:
		if (m_bReadOnly) {
			MessageBeep(MB_ICONEXCLAMATION);
		}
		else {
			int iEmptyRow = IndexOfEmptyRow();
			if ((iRow != NULL_INDEX) && (iRow != iEmptyRow)) {
				DeleteRowAt(iRow);
				m_bModified = TRUE;
			}
		}

		return TRUE;
	}



	// We don't handle this event.
	return FALSE;
}



//*******************************************************************
// CArrayGrid::CompareRows
//
// This is a virtual method override that compares two rows in the grid
// using the column index as the sort criteria.
//
// Parameters:
//		int iRow1
//			The index of the first row.
//
//		int iRow2
//			The index of the second row.
//
//		int iSortColumn
//			The column index.
//
// Returns:
//		>0 if row 1 is greater than row 2
//		0  if row 1 equal zero
//		<0 if row 1 is less than zero.
//
//********************************************************************
int CArrayGrid::CompareRows(int iRow1, int iRow2, int iSortColumn)
{
	int iResult;

	switch (iSortColumn) {
	case 0:
		// Sort first by name
		iResult = CompareCells(iRow1, iRow2, 0);
		return iResult;
	}
	return 0;
}



//*********************************************************************
// CPropGrid::GetCellEditContextMenu
//
// Get the context menu for the specified cell.
//
// Parameters:
//		[in] int iRow
//
//		[in] int iCol
//			The column index for the specified cell.
//
//		[out] CWnd*& pwndTarget
//			The target window
//
//		[out] CMenu& menu
//			This CMenu object is loaded with the desired menu.
//
//		[in] BOOL& bWantEditCommands
//			TRUE if the caller wants the commands for editing a cell.
//
// Returns:
//		BOOL
//			TRUE if a context menu exists for the specified cell.
//
//********************************************************************
BOOL CArrayGrid::GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands)
{
	bWantEditCommands = FALSE;
	VERIFY(menu.LoadMenu(IDR_ARRAYEDIT_MENU));

	pwndTarget = this;
	return TRUE;
}




//***********************************************************************
// CArrayGrid::ModifyCellEditContextMenu
//
// The cell editor calls this method just prior to displaying the context
// menu when the user right-clicks.  This method gives classes derived from
// CGrid a chance to modify the context menu depending on the current situation.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell that was right-clicked.
//
//		[in] int iCol
//			The column index of the cell that was right-clicked.
//
//		[in/out] CMenu& menu
//			A reference to the context menu that you can modify.
//
// Returns:
//		Nothing.
//
//************************************************************************
void CArrayGrid::ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu)
{

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	if (iRow == IndexOfEmptyRow()) {
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}

	return;

#if 0
	// We may want to put the following code back in someday, so I didn't delete it yet.


	BOOL bIsSystemProperty = FALSE;
	COleVariant varPropName;
	CIMTYPE cimtype = 0;

	CGridCell& gc = GetAt(iRow, ICOL_PROP_NAME);
	gc.GetValue(varPropName, cimtype);

	BOOL bCanShowPropQualifiers = TRUE;
	if (iRow == IndexOfEmptyRow()) {
		bCanShowPropQualifiers = FALSE;
	}
	else
	{
		if (cimtype != CIM_STRING || varPropName.vt != VT_BSTR)
		{
			bCanShowPropQualifiers = FALSE;
		}
		else
		{
			if (IsSystemProperty(varPropName.bstrVal))
			{
				bCanShowPropQualifiers = FALSE;
			}
		}
	}

	pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, bCanShowPropQualifiers ? MF_ENABLED : MF_DISABLED | MF_GRAYED);

	CGridCell *gcValue = NULL;
	if (m_psvc == NULL) {
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}
	else {

		if(HasCol(ICOL_PROP_VALUE))
		{
			gcValue = &GetAt(iRow, ICOL_PROP_VALUE);
			BOOL bCanCreateObject = gcValue->IsObject() && gcValue->IsNull();
			BOOL bCanCreateArray = gcValue->IsArray() && gcValue->IsNull();
			BOOL bIsReadonly = gcValue->IsReadonly();

			if(gcValue && (bIsReadonly || !(bCanCreateObject || bCanCreateArray)))
			{
				pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
			}
		}
		else
		{
			pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
		}
	}



	if (iCol != ICOL_PROP_VALUE)
	{
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
	}
	else
	{
		BOOL bCanSetToNull = FALSE;
		if (!(gc.GetFlags() & CELLFLAG_READONLY))
		{
			bCanSetToNull = TRUE;
		}
		pPopup->EnableMenuItem(ID_CMD_SET_CELL_TO_NULL, bCanSetToNull ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
	}

	// store for the cmd handlers.
	m_curRow = &GetRowAt(iRow);
	OnBuildContextMenu(pPopup, iRow);
#endif //0

}



void CArrayGrid::OnCmdCreateValue()
{
	if (m_psvc == NULL) {
		return;
	}

	int iRow = NULL_INDEX;
	int iCol = NULL_INDEX;
	if (!PointToCell(m_ptContextMenu, iRow, iCol)) {
		return;
	}
	if (iCol != 0) {
		return;
	}



	if (iRow != IndexOfEmptyRow()) {
		return;
	}

	EndCellEditing();
	SyncCellEditor();
	SelectCell(iRow, 0);
	AddRow();



	CGridCell& gc = GetAt(iRow, 0);
	BOOL bIsNull = gc.IsNull();
	BOOL bIsArray = gc.IsArray();
	BOOL bIsObject = gc.IsObject();

	if (!bIsNull) {
		return;
	}

	if (bIsArray) {
		gc.EditArray();
	}
	else if (bIsObject) {

		LPUNKNOWN lpunk = gc.GetObject();
		if (lpunk != NULL) {
			lpunk->Release();
			return;
		}

		COleVariant varPropname;
		CDlgObjectEditor dlg;
		dlg.CreateEmbeddedObject(m_psvc, m_sClassname, &gc);

		RedrawCell(iRow, 0);
	}
}



//*******************************************************************
// CArrayGrid::OnContextMenu
//
// This method is called to display the context menu (right button menu).
//
// Parameters:
//		CWnd*
//
//		CPoint ptContextMenu
//			The place where the right moust button was clicked.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CArrayGrid::OnContextMenu(CWnd* pwnd, CPoint ptContextMenu)
{
	// CG: This function was added by the Pop-up Menu component


	m_ptContextMenu = ptContextMenu;
	ScreenToClient(&m_ptContextMenu);

	int iRow;
	int iCol;
	BOOL bClickedCell = PointToCell(m_ptContextMenu, iRow, iCol);
	if (!bClickedCell) {
		iCol = NULL_INDEX;
		BOOL bClickedRowHandle = PointToRowHandle(m_ptContextMenu, iRow);
		if (!bClickedRowHandle) {
			iRow = NULL_INDEX;
		}
	}


	if (iRow == IndexOfEmptyRow()) {
		iRow = NULL_INDEX;
		iCol = NULL_INDEX;
	}
	else {
		return;
	}



	CMenu menu;
	VERIFY(menu.LoadMenu(IDR_ARRAYEDIT_MENU1));

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	if ((m_cimtype & ~CIM_FLAG_ARRAY) != CIM_OBJECT) {
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
	}


	if (iRow == NULL_INDEX) {
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}



	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, ptContextMenu.x, ptContextMenu.y,
		this);
}


SCODE CArrayGrid::GetObjectClass(CString& sClassname, int iRow, int iCol)
{
	sClassname = m_sClassname;
	if (sClassname.IsEmpty()) {
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}



void CArrayGrid::SetObjectParams(IWbemServices* psvc, CString& sClassname)
{
	if (m_psvc != NULL) {
		m_psvc->Release();
	}
	if (psvc != NULL) {
		psvc->AddRef();
	}
	m_psvc = psvc;
	m_sClassname = sClassname;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\buttons.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// buttons.cpp : implementation file
//

#include "precomp.h"
#include "buttons.h"
#include "CellEdit.h"
//#include "notify.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHmmvButton

CHmmvButton::CHmmvButton(long lButtonID)
{
	m_lButtonID = lButtonID;
}

CHmmvButton::~CHmmvButton()
{
}


BEGIN_MESSAGE_MAP(CHmmvButton, CButton)
	//{{AFX_MSG_MAP(CHmmvButton)
	ON_CONTROL_REFLECT(BN_CLICKED, OnClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHmmvButton message handlers

void CHmmvButton::OnClicked()
{
	if (m_pClient != NULL) {
		m_pClient->CatchEvent(m_lButtonID);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\classnav\treedroptarget.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: treedroptarget.cpp
//
// Description:
//	This file implements the CTreeDropTarget class which is a part of the
//	Class Explorer OCX, it is a subclass of the Microsoft COleDropTarget
//  and provides an implementation for the base classes virtual member
//	functions specialized for the CClassTree class.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CClassTree
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#include "precomp.h"
#include "afxpriv.h"
#include "AFXCONV.H"
#include "wbemidl.h"
#include "olemsclient.h"
#include "CClassTree.h"
#include "TreeDropTarget.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "TreeDropTarget.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Required by the framework.  It adds the interface pointer
// to the base classes interface map.
BEGIN_INTERFACE_MAP(CTreeDropTarget, COleDropTarget)
	INTERFACE_PART(CTreeDropTarget, IID_IDropTarget, DropTarget)
END_INTERFACE_MAP()

//***************************************************************************
//
// CTreeDropTarget::CTreeDropTarget
//
// Description:
//	  This member function is the public constructor.  It initializes the
//	  state of member variables.
//
// Parameters:
//	  CClassTree *pControl		Tree that contains the drop target.
//
// Returns:
// 	  NONE
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
CTreeDropTarget::CTreeDropTarget
(CClassTree *pControl)
	:	m_pControl (pControl),
		m_bScrolling (FALSE)
{
	return;
}

//***************************************************************************
//
// CTreeDropTarget::OnDragEnter
//
// Description:
//	  Called when the drag cursor first enters a window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::OnDragEnter
(CWnd* pWnd, COleDataObject* pDataObject, DWORD grfKeyState,
 CPoint point)
{
	if (!pWnd || !m_pControl)
	{
	   return DROPEFFECT_NONE;
	}

	// Cascade the operation to the control's drag and drop
	// handler.
	return m_pControl ->
		OnDragEnter(pDataObject, grfKeyState, point);

}

//***************************************************************************
//
// CTreeDropTarget::OnDragOver
//
// Description:
//	  Called when the drag cursor drags across the window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::OnDragOver
(CWnd* pWnd, COleDataObject* pDataObject, DWORD grfKeyState,
 CPoint point)
{
	if (!pWnd || !m_pControl)
	{
	   return DROPEFFECT_NONE;
	}


	// Cascade the operation to the control's drag and drop
	// handler.
	return m_pControl ->
		OnDragOver(pDataObject, grfKeyState, point);
}

//***************************************************************************
//
// CTreeDropTarget::OnDrop
//
// Description:
//	  Called by OLE when a drop operation occurs in the window for whom
//	  this drop target is registered.
//
// Parameters:
//	  CWnd* pWnd	The window the drop occured on.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DROPEFFECT dropEffect
//					The effect that the user chose for the drop operation
//	  CPoint point	Window coord.
//
// Returns:
// 	  BOOL			Nonzero if the drop is successful; otherwise 0.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
BOOL CTreeDropTarget::OnDrop
(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect,
 CPoint point)
{

	if (!pWnd || !m_pControl)
	{
	   return DROPEFFECT_NONE;
	}


	// Cascade the operation to the control's drag and drop
	// handler.
	return m_pControl ->
		OnDrop(pDataObject, dropEffect, point);
}

//***************************************************************************
//
// CTreeDropTarget::OnDropEx
//
// Description:
//	  Called when the an extended drop occurs.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  COleDataObject* pDataObject
//					The dropped data object.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::OnDropEx
(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect,
 DROPEFFECT dropEffectList, CPoint point)
{

	if (!pWnd || !m_pControl)
	{
	   return DROPEFFECT_NONE;
	}


	// Cascade the operation to the control's drag and drop
	// handler.
	return m_pControl ->
		OnDropEx(pDataObject, dropEffect, dropEffectList, point);
}

//***************************************************************************
//
// CTreeDropTarget::OnDragLeave
//
// Description:
//	  Called when the drag cursor leaves the window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//
// Returns:
// 	  VOID
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
void CTreeDropTarget::OnDragLeave(CWnd* pWnd)
{
	if (!pWnd || !m_pControl)
	{
	   return;
	}


	// Cascade the operation to the control's drag and drop
	// handler.
	m_pControl -> OnDragLeave();
	return;
}

//***************************************************************************
//
// CTreeDropTarget::OnDragScroll
//
// Description:
//	  Called to when the drag cursor is in the scroll area of a window.
//
// Parameters:
//	  CWnd* pWnd	The window.
//	  DWORD grfKeyState
//					The key state.
//	  CPoint point	Window coord.
//
// Returns:
// 	  DROPEFFECT	The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::OnDragScroll
(CClassTree* pWnd, DWORD dwKeyState, CPoint point)
{
	if (!pWnd || !m_pControl)
	{
	   return DROPEFFECT_NONE;
	}

	DROPEFFECT dropEffect = m_pControl->OnDragScroll(dwKeyState, point);

	// DROPEFFECT_SCROLL means do the default
	if (dropEffect != DROPEFFECT_SCROLL)
		return dropEffect;

	// get client rectangle of destination window
	CRect rectClient;
	pWnd->GetClientRect(&rectClient);
	CRect rect = rectClient;

	// hit-test against inset region
	// nTimerID != MAKEWORD(-1, -1) when in scroll area
	UINT nTimerID = MAKEWORD(-1, -1);
	rect.InflateRect(-nScrollInset, -nScrollInset);

	if (rectClient.PtInRect(point) && !rect.PtInRect(point))
	{
		// determine which way to scroll along both X & Y axis
		if (point.x < rect.left)
			nTimerID = MAKEWORD(SB_LINEUP, HIBYTE(nTimerID));
		else if (point.x >= rect.right)
			nTimerID = MAKEWORD(SB_LINEDOWN, HIBYTE(nTimerID));
		if (point.y < rect.top)
			nTimerID = MAKEWORD(LOBYTE(nTimerID), SB_LINEUP);
		else if (point.y >= rect.bottom)
			nTimerID = MAKEWORD(LOBYTE(nTimerID), SB_LINEDOWN);

		// check for valid scroll first

		BOOL bEnableScroll = FALSE;
		bEnableScroll = pWnd->OnScroll(nTimerID, 0, FALSE);
		if (!bEnableScroll)
			nTimerID = MAKEWORD(-1, -1);
	}

	if (nTimerID == MAKEWORD(-1, -1))
	{
		if (m_nTimerID != MAKEWORD(-1, -1))
		{
			// send fake OnDragEnter when transition from scroll->normal
			COleDataObject dataObject;
			dataObject.Attach(m_lpDataObject, FALSE);
			OnDragEnter(pWnd, &dataObject, dwKeyState, point);
			m_nTimerID = MAKEWORD(-1, -1);
		}
		return DROPEFFECT_NONE;
	}

	// save tick count when timer ID changes
	DWORD dwTick = GetTickCount();
	if (nTimerID != m_nTimerID)
	{
		m_dwLastTick = dwTick;
		m_nScrollDelay = nScrollDelay;
	}

	// scroll if necessary
	if (dwTick - m_dwLastTick > m_nScrollDelay)
	{
		pWnd->OnScroll(nTimerID, 0, TRUE);
		m_dwLastTick = dwTick;
		m_nScrollDelay = nScrollInterval;
	}
	if (m_nTimerID == MAKEWORD(-1, -1))
	{
		// send fake OnDragLeave when transitioning from normal->scroll
		OnDragLeave(pWnd);
	}

	m_nTimerID = nTimerID;
	// check for force link
#ifndef _MAC
	if ((dwKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
	if ((dwKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_LINK;
	// check for force copy
#ifndef _MAC
	else if ((dwKeyState & MK_CONTROL) == MK_CONTROL)
#else
	else if ((dwKeyState & MK_OPTION) == MK_OPTION)
#endif
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_COPY;
	// check for force move
	else if ((dwKeyState & MK_ALT) == MK_ALT ||
		(dwKeyState & MK_SHIFT) == MK_SHIFT)
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_MOVE;
	// default -- recommended action is move
	else
		dropEffect = DROPEFFECT_SCROLL|DROPEFFECT_MOVE;
	return dropEffect;
}

//***************************************************************************
//
// CTreeDropTarget::FilterDropEffect
//
// Description:
//	  Make sure that the source allows the operation and make simple
//	  substitutions if not.
//
// Parameters:
//	  DROPEFFECT dropEffect		The operation requested by the user
//	  DROPEFFECT dwEffects		The operations allowed by the target
//
// Returns:
// 	  DROPEFFECT				The potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::FilterDropEffect
(DROPEFFECT dropEffect, DROPEFFECT dwEffects)
{
	// Return allowed dropEffect and DROPEFFECT_NONE.
	if ((dropEffect & dwEffects) != 0)
		return dropEffect;

	switch (dropEffect)
	{
	// The case where the operation whats to copy but the
	// data source only allows a move.
	case DROPEFFECT_COPY:
		if (dwEffects & DROPEFFECT_MOVE)
			return DROPEFFECT_MOVE;
		break;
	// The case where the operation whats to move but the
	// data source only allows a copy.
	case DROPEFFECT_MOVE:
		if (dwEffects & DROPEFFECT_COPY)
			return DROPEFFECT_COPY;
		break;
	default:
		break;
	}

	return DROPEFFECT_NONE;
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::AddRef
//
// Description:
//	  IDropTarget interface AddRef.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  ULONG				The value of the new reference count.  For diagnostic
//						purpose only, the value is not guaranteed to be
//						stable.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
STDMETHODIMP_(ULONG) CTreeDropTarget::XDropTarget::AddRef()
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX_(CTreeDropTarget, DropTarget)
	// We are an aggregate object to defer to the aggregate's add
	// reference.
	return pThis->ExternalAddRef();
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::Release
//
// Description:
//	  IDropTarget interface Release.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  ULONG				The value of the new reference count.  For diagnostic
//						purpose only, the value is not guaranteed to be
//						stable.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
STDMETHODIMP_(ULONG) CTreeDropTarget::XDropTarget::Release()
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX_(CTreeDropTarget, DropTarget)
	// We are an aggregate object to defer to the aggregate's release.
	return pThis->ExternalRelease();
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::QueryInterface
//
// Description:
//	  IDropTarget interface QueryInterface.
//
// Parameters:
//	  REFIID iid,			Identifier of the requested interface
//    LPVOID* ppvObj		Receives an indirect pointer to the object
//
// Returns:
// 	  HRESULT 				Result code.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
STDMETHODIMP CTreeDropTarget::XDropTarget::QueryInterface
(REFIID iid, LPVOID* ppvObj)
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX_(CTreeDropTarget, DropTarget)

	// This interface is the IID_IDropTarget for the aggregate.
	// It will also stand in for IID_IUnknown.
	// We are deep in the heart of the COM here!
	if ((iid == IID_IDropTarget) || (iid == IID_IUnknown))
	{
		AddRef();
		*ppvObj = (void *) this;
		return S_OK;
	}
	// Other wise re defer to the aggregate.
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::DragEnter
//
// Description:
//	  IDropTarget interface DragEnter.
//
// Parameters:
//	IDataObject * pDataObject	Pointer to the interface of the source data
//								object.
//	DWORD grfKeyState			Current state of keyboard modifier keys
//	POINTL pt					Pointer to the current cursor coordinates
//	DWORD * pdwEffect			Pointer to the effect of the drag-and-drop
//								operation
//
// Returns:
// 	  HRESULT 				Result code.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
HRESULT CTreeDropTarget::XDropTarget::DragEnter
(LPDATAOBJECT lpDataObject, DWORD dwKeyState, POINTL pt,
 LPDWORD pdwEffect)
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX(CTreeDropTarget, DropTarget)

	SCODE sc = E_UNEXPECTED;

	if (!pThis || !pdwEffect || !lpDataObject)
	{
	   return sc;
	}

	// IF we have an OLE execption we will just return E_UNEXPECTED
	// to the OLE routine.
	try
	{
		// Store the lpDataObject in member var m_lpDataObject
		// after adding a reference to it.  The reference will
		// be released when/if a drop takes place or the drop
		// cursor leaves the OLE control.
		lpDataObject->AddRef();
		// Just in case we will release any COleDatObject
		// we are holding, which should be none.
		RELEASE(pThis->m_lpDataObject);
		// Store it.
		pThis -> m_lpDataObject = lpDataObject;

		CWnd* pWnd = (CWnd*) pThis->m_pControl;

		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// Check first for entering scroll area.
		DROPEFFECT dropEffect = OnDragScroll
			(pWnd, dwKeyState, point);

		// If we are not in the scroll area cascade up the
		// food chain to the CTreeDropTarget member function.
		if ((dropEffect & DROPEFFECT_SCROLL) == 0)
		{
			COleDataObject dataObject;
			// Attach BOOL bAutoRelease set to FALSE so that the
			// OLE data object is not released when the COleDataObject
			// object is destroyed.
			dataObject.Attach(lpDataObject, FALSE);
			// Cascade the drag enter up the food chain.
			dropEffect = pThis->OnDragEnter
				(pWnd, &dataObject, dwKeyState, point);
		}
		*pdwEffect =
			// Make sure that the source allows the operation
			// and make simple substitutions if not.
			pThis -> FilterDropEffect(dropEffect, *pdwEffect);
		sc = S_OK;
	}

	catch(COleException* e)
	{
        e ->Delete();
    }

	return sc;
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::DragOver
//
// Description:
//	  IDropTarget interface DragOver.
//
// Parameters:
//	DWORD grfKeyState			Current state of keyboard modifier keys
//	POINTL pt					Pointer to the current cursor coordinates
//	DWORD * pdwEffect			Pointer to the effect of the drag-and-drop
//								operation
//
// Returns:
// 	  HRESULT 					Result code.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
HRESULT CTreeDropTarget::XDropTarget::DragOver
(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX(CTreeDropTarget, DropTarget)

	SCODE sc = E_UNEXPECTED;

	if (!pThis || !pdwEffect || !pThis->m_lpDataObject)
	{
	   return sc;
	}

	// IF we have an OLE execption we will just return E_UNEXPECTED
	// to the OLE routine.
	try
	{
		CWnd* pWnd = (CWnd*) pThis->m_pControl;

		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// Check first for entering scroll area.
		DROPEFFECT dropEffect = OnDragScroll
			(pWnd, dwKeyState, point);

		// If we are not in the scroll area cascade up the
		// food chain to the CTreeDropTarget member function.
		if ((dropEffect & DROPEFFECT_SCROLL) == 0)
		{
			COleDataObject dataObject;
			// Attach BOOL bAutoRelease set to FALSE so that the
			// OLE data object is not released when the COleDataObject
			// object is destroyed.
			dataObject.Attach(pThis->m_lpDataObject, FALSE);
			// Cascade the drag over up the food chain.
			dropEffect = pThis->OnDragOver
				(pWnd, &dataObject, dwKeyState, point);
		}
		*pdwEffect =
			// Make sure that the source allows the operation
			// and make simple substitutions if not.
			pThis -> FilterDropEffect
			(dropEffect, *pdwEffect);
		sc = S_OK;
	}

	catch(COleException* e)
	{
        e ->Delete();
    }
	return sc;
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::DragLeave
//
// Description:
//	  IDropTarget interface DragLeave.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  HRESULT 				Result code.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
HRESULT CTreeDropTarget::XDropTarget::DragLeave()
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX(CTreeDropTarget, DropTarget)

	SCODE sc = E_UNEXPECTED;

	CWnd* pWnd = (CWnd*) pThis->m_pControl;

	if (!pWnd)
	{
		return sc;
	}

	// IF we have an OLE execption we will just return E_UNEXPECTED
	// to the OLE routine.
	try
	{
		// Cancel drag scrolling.
		pThis->m_nTimerID = MAKEWORD(-1, -1);

		// Cascade the drag leave up the food chain.
		pThis->OnDragLeave(pWnd);
		sc = S_OK;
	}

	catch(COleException* e)
	{
        e ->Delete();
    }
	// Release cached data object because we will not release it
	// automatically when it is destroyed.  If it is not released
	// here its reference count is not <= 1 when an attempt is made to
	// destroy it.  That will result in the OLE COM interface never being
	// released, which is a very bad memory leak.
	RELEASE(pThis->m_lpDataObject);

	return sc;
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::Drop
//
// Description:
//	  IDropTarget interface Drop.
//
// Parameters:
//	IDataObject * pDataObject	Pointer to the interface of the source data
//								object.
//	DWORD grfKeyState			Current state of keyboard modifier keys
//	POINTL pt					Pointer to the current cursor coordinates
//	DWORD * pdwEffect			Pointer to the effect of the drag-and-drop
//								operation
//
// Returns:
// 	  HRESULT 				Result code.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
HRESULT CTreeDropTarget::XDropTarget::Drop
(LPDATAOBJECT lpDataObject, DWORD dwKeyState, POINTL pt,
 LPDWORD pdwEffect)
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX(CTreeDropTarget, DropTarget)

	SCODE sc = E_UNEXPECTED;

	 if (!pThis || !pdwEffect || !lpDataObject)
	{
	   return sc;
	}


	// IF we have an OLE execption we will just return E_UNEXPECTED
	// to the OLE routine.
	try
	{
		// Cancel drag scrolling.
		pThis->m_nTimerID = MAKEWORD(-1, -1);

		CWnd* pWnd = (CWnd*) pThis->m_pControl;

		COleDataObject dataObject;
		// Attach BOOL bAutoRelease set to FALSE so that the
		// OLE data object is not released when the COleDataObject
		// object is destroyed.
		dataObject.Attach(lpDataObject, FALSE);

		CPoint point((int)pt.x, (int)pt.y);
		pWnd->ScreenToClient(&point);

		// Make sure that the source allows the operation
		// and make simple substitutions if not.
		DROPEFFECT dropEffect =
			pThis -> FilterDropEffect
			// OnDragOver will clean up focus rect and return
			// a drop effect.
			(pThis->OnDragOver
				(pWnd, &dataObject, dwKeyState, point),
			*pdwEffect);

		// Check for a right mouse button operation and implementation
		// of OnDropEx.
		DROPEFFECT temp =
			pThis->OnDropEx
			(pWnd, &dataObject, dropEffect, *pdwEffect, point);

		if (temp != -1)
		{
			// OnDropEx was implemented, return its drop effect
			dropEffect = temp;
		}
		else if
			(((dropEffect & DROPEFFECT_MOVE) == DROPEFFECT_MOVE)
			||
			((dropEffect & DROPEFFECT_COPY) == DROPEFFECT_COPY))
		{
			if (!pThis->OnDrop
				(pWnd, &dataObject, dropEffect, point))
				dropEffect = DROPEFFECT_NONE;
		}
		else
		{
			// Drop operation is not allowed so clean up the window.
			pThis->OnDragLeave(pWnd);
		}

		// Release cached data object because we will not release it
		// automatically when it is destroyed.
		RELEASE(pThis->m_lpDataObject);
		*pdwEffect = dropEffect;
		sc = S_OK;
	}

	catch(COleException* e)
	{
        e ->Delete();
    }

	return sc;
}

//***************************************************************************
//
// CTreeDropTarget::XDropTarget::OnDragScroll
//
// Description:
//	  IDropTarget interface OnDragScroll.
//
// Parameters:
//	CWnd*						Window.
//	DWORD grfKeyState			Current state of keyboard modifier keys
//	CPoint point				Current cursor coordinates
//
// Returns:
// 	  DROPEFFECT 				Potential drop effect.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//***************************************************************************
DROPEFFECT CTreeDropTarget::XDropTarget::OnDragScroll
(CWnd* pWnd, DWORD dwKeyState,
	CPoint point)
{
	// METHOD_PROLOGUE_EX_ macro binds the containing class object
	// pointer to pThis.
	METHOD_PROLOGUE_EX(CTreeDropTarget, DropTarget)

	if (!pThis || !pWnd || !pThis->m_lpDataObject)
	{
	   return DROPEFFECT_NONE;
	}


	DROPEFFECT dropEffect =
		pThis->OnDragScroll
		(reinterpret_cast<CClassTree *>(pWnd), dwKeyState, point);

	return dropEffect;
}

/*	EOF:  treedroptarget.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\buttons.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _buttons_h
#define _buttons_h

// buttons.h : header file
//
class CCellEdit;


/////////////////////////////////////////////////////////////////////////////
// CHmmvButton window
class CHmmvButton : public CButton
{
// Construction
public:
	CHmmvButton(long lButtonID);

// Attributes
public:
	CCellEdit* m_pClient;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHmmvButton)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHmmvButton();
	

	// Generated message map functions
protected:
	//{{AFX_MSG(CHmmvButton)
	afx_msg void OnClicked();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	long m_lButtonID;
};

/////////////////////////////////////////////////////////////////////////////

#endif //_buttons_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\celledit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  CellEdit.cpp
//
//  This file implements a grid cell editor for the CGrid class used in hmmv
//  (the HMOM object viewer).  This GridCell editor is customized for hmmv such
//  that it understands certain datatypes.
//
//  This class could be generalized such that it could be used as a "generic" cell
//  editor base class so that different types of cell editors could be plugged
//  into the grid class.
//
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#include "precomp.h"
#include "resource.h"
#include "globals.h"
#include "CellEdit.h"
#include "grid.h"
#include "gca.h"
#include "gridhdr.h"
#include "globals.h"
#include "core.h"
#include "utils.h"
#include "notify.h"
#include "DlgObjectType.h"



#define CX_COMBO_DROP 16			// Width of the combo-drop button
#define CX_COMBO_DROP_MARGIN 1		// Margin on right side of combo drop button
#define CY_COMBO_DROP_MARGIN 1		// Margin on bottom side of combo drop botton
#define CY_EDIT_LISTBOX_MAX 100		// The maximum height of the combo listbox
#define CY_EDIT_LISTBOX_MIN 30		// The minimum height of the combo listbox
#define CX_EDIT_LISTBOX_MIN 90		// The minimum width of the listbox
#define CX_EDIT_LISTBOX_EXTEND 110	// The width of the listbox when extended


#define CTL_C 3



//************************************************************************
// Define how the strings in the combo box are mapped back to variant type
// values.  This is necessary so that the type of buddy cells can be changed
// when a cell containing a type is changed.
//
//************************************************************************


TMapStringToLong amapAttribType[] = {
	{IDS_ATTR_TYPE_BSTR, CIM_STRING},
	{IDS_ATTR_TYPE_BOOL, CIM_BOOLEAN},
	{IDS_ATTR_TYPE_I4, CIM_SINT32},
	{IDS_ATTR_TYPE_R8, CIM_REAL64},

	{IDS_ATTR_TYPE_BSTR_ARRAY, CIM_STRING | CIM_FLAG_ARRAY},
	{IDS_ATTR_TYPE_BOOL_ARRAY, CIM_BOOLEAN | CIM_FLAG_ARRAY},
	{IDS_ATTR_TYPE_I4_ARRAY, CIM_SINT32 | CIM_FLAG_ARRAY},
	{IDS_ATTR_TYPE_R8_ARRAY, CIM_REAL64 | CIM_FLAG_ARRAY}
};



CMapStringToLong mapAttribType;
// CMapStringToLong mapCimType;




//*************************************************************
// String arrays for the strings that appear in the drop-down
// combo for cells that have enumerated values.
//
// The strings in these arrays are loaded from the string table
// by passing an array of the strings resource IDs to the CXStringArray
// constructor.
//
//*************************************************************


UINT auiCimtypeStrings[] =
	{
	IDS_CIMTYPE_UINT8,
	IDS_CIMTYPE_SINT8,				// I2
	IDS_CIMTYPE_UINT16,				// VT_I4	Unsigned 16-bit integer
	IDS_CIMTYPE_CHAR16,				// VT_I2    16 bit character.
	IDS_CIMTYPE_SINT16,				// VT_I2	Signed 16-bit integer
	IDS_CIMTYPE_UINT32,				// VT_I4	Unsigned 32-bit integer
	IDS_CIMTYPE_SINT32,					// VT_I4	Signed 32-bit integer
	IDS_CIMTYPE_UINT64,				// VT_BSTR	Unsigned 64-bit integer
	IDS_CIMTYPE_SINT64,				// VT_BSTR	Signed 64-bit integer
	IDS_CIMTYPE_STRING,				// VT_BSTR	UCS-2 string
	IDS_CIMTYPE_BOOL,				// VT_BOOL	Boolean
	IDS_CIMTYPE_REAL32,				// VT_R4	IEEE 4-byte floating-point
	IDS_CIMTYPE_REAL64,				// VT_R8	IEEE 8-byte floating-point
	IDS_CIMTYPE_DATETIME,			// VT_BSTR	A string containing a date-time
	IDS_CIMTYPE_REF,				// VT_BSTR	Weakly-typed reference

	IDS_CIMTYPE_UINT8_ARRAY,
	IDS_CIMTYPE_SINT8_ARRAY,		// I2
	IDS_CIMTYPE_UINT16_ARRAY,		// VT_I4	Unsigned 16-bit integer
	IDS_CIMTYPE_CHAR16_ARRAY,		// VT_I2    16 bit character.
	IDS_CIMTYPE_SINT16_ARRAY,		// VT_I2	Signed 16-bit integer
	IDS_CIMTYPE_UINT32_ARRAY,		// VT_I4	Unsigned 32-bit integer
	IDS_CIMTYPE_SINT32_ARRAY,			// VT_I4	Signed 32-bit integer
	IDS_CIMTYPE_UINT64_ARRAY,		// VT_BSTR	Unsigned 64-bit integer
	IDS_CIMTYPE_SINT64_ARRAY,		// VT_BSTR	Signed 64-bit integer
	IDS_CIMTYPE_STRING_ARRAY,		// VT_BSTR	UCS-2 string
	IDS_CIMTYPE_BOOL_ARRAY,			// VT_BOOL	Boolean
	IDS_CIMTYPE_REAL32_ARRAY,		// VT_R4	IEEE 4-byte floating-point
	IDS_CIMTYPE_REAL64_ARRAY,		// VT_R8	IEEE 8-byte floating-point
	IDS_CIMTYPE_DATETIME_ARRAY,		// VT_BSTR	A string containing a date-time
	IDS_CIMTYPE_REF_ARRAY,			// VT_BSTR	Weakly-typed reference
	IDS_CIMTYPE_OBJECT_ARRAY,		// VT_UNKNOWN	Weakly-typed embedded instance
	IDS_CIMTYPE_OBJECT_DLG
	};

UINT auiCimtypeScalarStrings[] =
	{
	IDS_CIMTYPE_UINT8,
	IDS_CIMTYPE_SINT8,				// I2
	IDS_CIMTYPE_UINT16,				// VT_I4	Unsigned 16-bit integer
	IDS_CIMTYPE_CHAR16,				// VT_I2	16 bit character
	IDS_CIMTYPE_SINT16,				// VT_I2	Signed 16-bit integer
	IDS_CIMTYPE_UINT32,				// VT_I4	Unsigned 32-bit integer
	IDS_CIMTYPE_SINT32,				// VT_I4	Signed 32-bit integer
	IDS_CIMTYPE_UINT64,				// VT_BSTR	Unsigned 64-bit integer
	IDS_CIMTYPE_SINT64,				// VT_BSTR	Signed 64-bit integer
	IDS_CIMTYPE_STRING,				// VT_BSTR	UCS-2 string
	IDS_CIMTYPE_BOOL,				// VT_BOOL	Boolean
	IDS_CIMTYPE_REAL32,				// VT_R4	IEEE 4-byte floating-point
	IDS_CIMTYPE_REAL64,				// VT_R8	IEEE 8-byte floating-point
	IDS_CIMTYPE_DATETIME,			// VT_BSTR	A string containing a date-time
	IDS_CIMTYPE_REF,				// VT_BSTR	Weakly-typed reference
//	IDS_CIMTYPE_OBJECT,				// VT_UNKNOWN	Weakly-typed embedded instance
	IDS_CIMTYPE_OBJECT_DLG
	};

UINT auiAttrTypeStrings[] =
	{
	IDS_ATTR_TYPE_BSTR,
	IDS_ATTR_TYPE_BOOL,
	IDS_ATTR_TYPE_I4,
	IDS_ATTR_TYPE_R8,
	IDS_ATTR_TYPE_BSTR_ARRAY,
	IDS_ATTR_TYPE_BOOL_ARRAY,
	IDS_ATTR_TYPE_I4_ARRAY,
	IDS_ATTR_TYPE_R8_ARRAY
	};


UINT auiBoolStrings[] =
	{
	IDS_TRUE,
	IDS_FALSE
	};





CXStringArray saAttrType;
CXStringArray saCimType;
CXStringArray saCimtypeScalar;
CXStringArray saScope;
CXStringArray saBoolValues;





/////////////////////////////////////////////////////////////////////////////
// CCellEdit



//***********************************************************
// CCellEdit::CCellEdit
//
// Construct the CellEdit class.  CellEdit is used for
// editing cells in the grid.  The cell type determines the
// edit mode that will be used.
//
// Currently, only two edit modes are supported.  A CEdit is used
// for generic text.  Combo-box editing is used for any type that
// has an enumeration.  Note that combo-box editing is implemented
// using a separate drop-down button, edit box, and list box to
// get the correct look and feel (the standard combo-box always
// draws an ugly border within the cell)
//
//
// Parameters:
//		See the MFC documentation for header control notification
//		messages.
//
// Returns:
//		Nothing.
//
//************************************************************
CCellEdit::CCellEdit() : m_btnCombo(NOTIFY_CELL_EDIT_COMBO_DROP_CLICKED)
{
	m_clrTextDirty = COLOR_DIRTY_CELL_TEXT;	// Modified text is drawn in blue
	m_clrTextClean = COLOR_CLEAN_CELL_TEXT;	// Unmodified text is drawn in black
	m_clrBkgnd = RGB( 255, 255, 255 );
	m_brBkgnd.CreateSolidBrush( m_clrBkgnd );
	m_bWasInitiallyDirty = FALSE;
	m_pGrid = NULL;
	m_pwndParent = NULL;
	m_btnCombo.m_pClient = this;
	m_lbCombo.m_pClient = this;
	m_pgc = NULL;
	m_iRow = NULL_INDEX;
	m_iCol = NULL_INDEX;
	m_lGridClickTime = 0;
	m_pwndContextMenuTarget = NULL;
	m_bPropagateChange = NULL;
	m_bUIActive = FALSE;
	m_bEditWithComboOnly = FALSE;

	m_pgcCopy = NULL;
	m_ptypeSave = new CGcType;

	// Initialize the type maps if they haven't been initialized yet.

	mapAttribType.Load(amapAttribType, sizeof(amapAttribType) / sizeof(TMapStringToLong));
//	mapCimType.Load(amapCimType, sizeof(amapCimType) / sizeof(TMapStringToLong));

	// Initialize the string tables if they haven't been initialized yet.

	saAttrType.Load(auiAttrTypeStrings, sizeof(auiAttrTypeStrings)/sizeof(UINT));
	saBoolValues.Load(auiBoolStrings, sizeof(auiBoolStrings)/sizeof(UINT));
	saCimType.Load(auiCimtypeStrings, sizeof(auiCimtypeStrings)/sizeof(UINT));
	saCimtypeScalar.Load(auiCimtypeScalarStrings, sizeof(auiCimtypeScalarStrings)/sizeof(UINT));
}



CCellEdit::~CCellEdit()
{
	delete m_ptypeSave;
	delete m_pgcCopy;
}


BEGIN_MESSAGE_MAP(CCellEdit, CEdit)
	//{{AFX_MSG_MAP(CCellEdit)
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_CHAR()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_CONTEXTMENU()
	ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_COMMAND(ID_CMD_SET_CELL_TO_NULL, OnCmdSetCellToNull)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_PASTE, OnPaste)
END_MESSAGE_MAP()




LRESULT CCellEdit::OnPaste(WPARAM wParam, LPARAM lParam)
{
	// bug#58239
	if (IsNull())
		m_bIsNull = FALSE;
	return CEdit::Default();
}


//***************************************************************
// CCellEdit::SetCell
//
// Set the editor's contents to the given cell.
//
// Parameters:
//		CGridCell* pGridCell
//			Pointer to the grid cell to set the editor's contents to.
//
//		int iRow
//			The row index of the cell in the grid.
//
//		int iCol
//			The column index of the cell in the grid.
//
// Returns:
//		BOOL
//			TRUE if the cell editor wants the focus, FALSE otherwise.
//
//****************************************************************
BOOL CCellEdit::SetCell(CGridCell* pGridCell, int iRow, int iCol)
{
	ShowCombo(SW_HIDE);


	m_bPropagateChange = FALSE;

	m_iRow = iRow;
	m_iCol = iCol;

	m_pgc = pGridCell;

	m_pwndContextMenuTarget = NULL;

	SetReadOnly(FALSE);

	// Set or remove the enumereration that will be shown in the
	// drop-down combo.
	SetEnumeration();



	BOOL bReadOnly = TRUE;

	// Set the value that appears in the CEdit
	if (pGridCell == NULL) {
		m_menuContext.DestroyMenu();
		SetWindowText(_T(""), FALSE);

		SetReadOnly(TRUE);
		m_bIsNull = TRUE;

	}
	else {
		bReadOnly = pGridCell->IsReadonly() || (pGridCell->GetFlags() &CELLFLAG_READONLY);

		// Save a copy of the current state of the grid cell so that the
		// state can be restored if the user hits escape.
		if (m_pgcCopy) {
			delete m_pgcCopy;
		}
		m_pgcCopy = new CGridCell(*pGridCell);


		m_bIsNull = pGridCell->IsNull();

		if (m_bIsNull) {
			CString sEmpty;
			if (m_pGrid->ShowNullAsEmpty()) {
				sEmpty = _T("<empty>");
			}
			SetWindowText(sEmpty, FALSE);
		}
		else {
			CString sValue;
			CIMTYPE cimtype;
			pGridCell->GetValue(sValue, cimtype);
			SetWindowText(sValue, pGridCell->GetModified());
		}
		SetReadOnly(bReadOnly | m_bEditWithComboOnly);
	}

	BOOL bWantsFocus;
	int nComboCount = m_lbCombo.GetCount();
	if (!bReadOnly && m_lbCombo.m_hWnd!=NULL && nComboCount > 0) {

		m_btnCombo.ShowWindow(SW_SHOW);

		switch(m_pgc->GetType()) {
		case CELLTYPE_ATTR_TYPE:
		case CELLTYPE_CIMTYPE:
		case CELLTYPE_CIMTYPE_SCALAR:
			// Don't show any caret when doing combo style editing.
			SetSel(-1, 0);
			bWantsFocus = FALSE;
			break;
		default:
			SetSel(0, -1);
			bWantsFocus = TRUE;
		};

	}
	else {
		// Select everything when doing normal editing.
		SetSel(GetWindowTextLength( ), 0);
		bWantsFocus = TRUE;
	}

	m_bPropagateChange = TRUE;
	return bWantsFocus;
}



//**********************************************************
// CCellEdit::SetEnumeration
//
// This method examines the cell being edited and sets up the
// enumeration listbox if an enumeration is required to edit the
// cell.  An enumeration will be displayed if the combo listbox
// is not empty.
//
// Parameters:
//		CGridCell* m_pgc
//			The grid cell is passed in via this class member.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::SetEnumeration()
{
	// If there is no grid cell, then there is no enumeration.
	m_bEditWithComboOnly = FALSE;
	m_lbCombo.ResetContent();
	if ((m_pgc == NULL) ||
			(m_pgc->GetFlags() & CELLFLAG_READONLY) ||
			m_pgc->IsReadonly()) {
		ShowCombo(SW_HIDE);
		Layout();
		return;
	}



	CStringArray saEnumValues;
	BOOL bProhibitEditing = TRUE;

	// Setup enumerations for the following:
	//	 1. Boolean values
	//	 2. Attribute type names.
	//	 3. HMOM attribute scope.
	//   4. Variant type names.
	switch(m_pgc->GetType()) {
	case CELLTYPE_CIMTYPE:
		LoadListBox(saCimType);
		break;
	case CELLTYPE_CIMTYPE_SCALAR:
		LoadListBox(saCimtypeScalar);
		break;
	case CELLTYPE_CHECKBOX:
	case CELLTYPE_PROPMARKER:
	case CELLTYPE_VOID:
		break;
	default:
		switch(m_pgc->GetVariantType()) {
		case VT_BOOL:
			LoadListBox(saBoolValues);
			break;
		case VT_BSTR:
			switch(m_pgc->GetType()) {
			case CELLTYPE_ATTR_TYPE:
				LoadListBox(saAttrType);
				break;
			case CELLTYPE_CIMTYPE:
				LoadListBox(saCimType);
				break;
			case CELLTYPE_CIMTYPE_SCALAR:
				LoadListBox(saCimtypeScalar);
				break;
			default:
				m_pGrid->GetCellEnumStrings(m_iRow, m_iCol, saEnumValues);
				if (saEnumValues.GetSize() > 0) {
					LoadListBox(saEnumValues);
					bProhibitEditing = FALSE;
				}
				break;
			}
			break;
		default:
			ShowCombo(SW_HIDE);
			break;
		}
	}

	if (m_lbCombo.GetCount() > 0) {
		if (bProhibitEditing) {
			m_bEditWithComboOnly = TRUE;
		}
	}
	Layout();
}





//*********************************************************
// CCellEdit::LoadListBox
//
// Load the listbox with the enumeration strings.
//
// Parameters:
//		CStringArray& sa
//			A string array containing the strings to fill
//			the listbox with.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CCellEdit::LoadListBox(CStringArray& sa)
{
	LONG nStrings = (LONG) sa.GetSize();
	for (LONG iString=0; iString < nStrings; ++iString) {
		m_lbCombo.AddString(sa[iString]);
	}
}







//**********************************************************
// CCellEdit::GetEditRect
//
// Calculate the rectangle that will be used to display
// the CEdit part of the cell editor.  Note that the cell editor
// may consist of the CEdit, the listbox for the drop-down combo
// and the combo-drop button.
//
// Parameters:
//		[out] RECT& rcEdit
//			The place to return the rectangle for the CEdit portion
//			of the cell editor.
//
//		[in] BOOL bNeedsComboButton
//			TRUE if a combo button needs to be displayed in the cell
//			and the CEdit part of the cell should be reduced in size
//			so that it doesn't overlap the button.
//
//		[in] CRect& rcComboButton
//			The rectangle where the combo button will be placed.  This
//			is valid only if bNeedsComboButton is TRUE.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::GetEditRect(RECT& rcEdit, BOOL bNeedsComboButton, CRect& rcComboButton)
{
	rcEdit.left = m_rcCell.left + CX_CELL_MARGIN;
	if (rcEdit.left > m_rcCell.right) {
		rcEdit.left = m_rcCell.right;
	}

	rcEdit.right = m_rcCell.right - CX_CELL_MARGIN;
	if (m_lbCombo.m_hWnd && (m_lbCombo.GetCount() > 0)) {
		// A combo is being displayed, so make room for the drop-down button.
		rcEdit.right -= CX_COMBO_DROP + CX_COMBO_DROP_MARGIN;
	}
	if (rcEdit.right < rcEdit.left) {
		rcEdit.right = rcEdit.left;
	}


	rcEdit.top = m_rcCell.top + CY_CELL_MARGIN;
	if (rcEdit.top > m_rcCell.bottom) {
		rcEdit.top = m_rcCell.bottom;
	}
	rcEdit.bottom = m_rcCell.bottom - CY_CELL_MARGIN;
	if (rcEdit.bottom < rcEdit.top) {
		rcEdit.bottom = rcEdit.top;
	}

	if (bNeedsComboButton) {
		if (rcEdit.right > rcComboButton.left) {
			rcEdit.right = rcComboButton.left;
		}
	}
	else {
		CRect rcParent;
		m_pwndParent->GetClientRect(rcParent);
		if (rcEdit.right > rcParent.right) {
			rcEdit.right = rcParent.right;
		}
	}
}




//**********************************************************
// CCellEdit::GetListBoxRect
//
// Calculate the rectangle that will be used to display
// the CListBox part of the cell editor.  Note that the cell editor
// may consist of the CEdit, the listbox for the drop-down combo
// and the combo-drop button.
//
// Parameters:
//		RECT& rcListBox
//			The place to return the rectangle for the CListBox portion
//			of the cell editor.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::GetListBoxRect(RECT& rcListBox)
{
	CRect rcParent;
	m_pwndParent->GetClientRect(rcParent);

	// Figure out what the desired and the minimum sizes are for
	// the listbox.  cyText is the desired size.  cyMin is the
	// minimum size.
	int cyText = 0;
	if (m_lbCombo.m_hWnd != NULL ) {
		cyText = m_lbCombo.GetCount() * CY_FONT;
	}
	if (cyText > CY_EDIT_LISTBOX_MAX) {
		cyText = CY_EDIT_LISTBOX_MAX;
	}

	int cyMin = CY_EDIT_LISTBOX_MIN;
	if (cyMin > cyText) {
		cyMin = cyText;
	}



	// Make sure the listbox doesn't go beyond the parent's client area
	rcListBox.left = m_rcCell.left;
	rcListBox.right = m_rcCell.right;
	if ((rcListBox.right - rcListBox.left) < CX_EDIT_LISTBOX_MIN) {
		rcListBox.right = m_rcCell.left + CX_EDIT_LISTBOX_EXTEND;
	}
	if (rcListBox.right > rcParent.right) {
		rcListBox.right = rcParent.right;
		rcListBox.left = rcParent.right - CX_EDIT_LISTBOX_EXTEND;
	}
	if (rcListBox.left < rcParent.left) {
		rcListBox.left = rcParent.left;
	}


	if ((m_rcCell.bottom + cyMin) > rcParent.bottom) {
		// Place the listbox above the cell rectangle
		rcListBox.top = m_rcCell.top - cyText;
		if (rcListBox.top < rcParent.top) {
			rcListBox.top = rcParent.top;
		}
		rcListBox.bottom = m_rcCell.top + 1;
	}
	else {
		// Place the listbox below the cell rectangle
		rcListBox.top = m_rcCell.bottom - 1;
		rcListBox.bottom = m_rcCell.bottom + cyText;
		if (rcListBox.bottom > rcParent.bottom) {
			rcListBox.bottom = rcParent.bottom;
		}
	}
}


//**********************************************************
// CCellEdit::GetComboButtonRect
//
// Calculate the rectangle that will be used to display
// the CButton part of the cell editor.  Note that the cell editor
// may consist of the CEdit, the listbox for the drop-down combo
// and the combo-drop button.
//
// Parameters:
//		RECT& rcButton
//			The place to return the rectangle for the CButton portion
//			of the cell editor.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::GetComboButtonRect(RECT& rcButton)
{
	rcButton.left = m_rcCell.right - CX_COMBO_DROP - CX_COMBO_DROP_MARGIN;
	if (rcButton.left < m_rcCell.left) {
		rcButton.left = m_rcCell.left;
	}
	rcButton.top = m_rcCell.top;
	rcButton.right = m_rcCell.right - CX_COMBO_DROP_MARGIN;
	rcButton.bottom = m_rcCell.bottom - CY_COMBO_DROP_MARGIN;


	// If the cell is entirely to the right of the parent's client rectangle,
	// just return the button rectangle that we've calculated.
	CRect rcParent;
	m_pwndParent->GetClientRect(rcParent);
	if (m_rcCell.left > rcParent.right) {
//		ASSERT(FALSE);
		return;
	}

	// If the right side of the cell is obscured by the right edge of the
	// window, move the button left so that it is visible.
	int cxButton = rcButton.right - rcButton.left;
	if (rcButton.right > rcParent.right) {

		// Fix up the boundary conditions to prevent the button from
		// extending outside of the cell.
		rcButton.left = rcParent.right - cxButton;
		if (rcButton.left < m_rcCell.left) {
			rcButton.left = m_rcCell.left;
		}

		rcButton.right = rcButton.left + cxButton;
		if (rcButton.right > m_rcCell.right) {
			rcButton.right = m_rcCell.right;
		}
	}
}





//**********************************************************
// CCellEdit::FixBuddyCell
//
// When a cell containing the "type" of buddy cell changes, then
// it may be necessary fix the value of the buddy cell to
// reflect the type change.
//
// Parameters:
//		None
//
// Returns:
//		Nothing
//
//**********************************************************
void CCellEdit::FixBuddyCell()
{
	// If there is no buddy for the cell being edited, then
	// there is nothing to do.
	int iColBuddy =  m_pgc->GetBuddy();
	if (iColBuddy == NULL_INDEX) {
		return;
	}
	CGridCell* pgcBuddy = &m_pGrid->GetAt(m_iRow, iColBuddy);

	// Get the value of this cell and map the value to a variant type.
	BOOL bFoundType;
	CString sType;
	GetWindowText(sType);

	CGcType typeBuddy = pgcBuddy->type();
	CGcType type = m_pgc->type();

	long lTemp;
	switch((CellType) type) {
	case CELLTYPE_ATTR_TYPE:
		bFoundType = mapAttribType.Lookup(sType, lTemp);
		typeBuddy.SetCimtype((CIMTYPE) lTemp);
		ASSERT(bFoundType);
		break;
	case CELLTYPE_CIMTYPE:
	case CELLTYPE_CIMTYPE_SCALAR:
		MapDisplayTypeToGcType(typeBuddy, sType);
		typeBuddy.SetCellType(CELLTYPE_VARIANT);	// MapDisplayTypeToGcType modifies the CellType
		bFoundType = TRUE;
		break;
	default:
		ASSERT(FALSE);
		return;
		break;
	}


	// If the new type is different from the buddy's current type,
	// then change the type of the buddy  to the new type and redraw it.
	if (typeBuddy != pgcBuddy->type()) {
		pgcBuddy->ChangeType(typeBuddy);
		m_pGrid->DrawCell(m_iRow, iColBuddy);
	}
}


//****************************************************************
// CCellEdit::GetStrongDisplayType
//
// When the user selects a type from


//**************************************************************
// CCellEdit::GetGcTypeFromCombo
//
// This method is called when the user releases the mouse button
// when selecting a type from the drop-down combo.  The type is
// returned as a CGcType value that will carry with it the necessary
// information for strongly typed references and objects, strongly
// typed arrays of references and strongly typed arrays of objects.
//
// The CGcType value can then be mapped back into a displayable type
// that the user sees, and so on.
//
// Parameters:
//		[out] CGcType& type
//			The type value is returned here.
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CCellEdit::ComboSelectDisplayType(CGcType& type, LPCTSTR pszDisplayType)
{

	MapDisplayTypeToGcType(type, pszDisplayType);
	CIMTYPE cimtype = (CIMTYPE) type;
	CIMTYPE cimtypeT = cimtype & ~CIM_FLAG_ARRAY;
	switch(cimtypeT) {
	case CIM_OBJECT:
	case CIM_REFERENCE:
		break;
	default:
		return S_OK;
	}

	// The type selected from the combo box may be "object" or "ref".  In the
	// event that the buddy (value) cell is already of type "object" or "ref",
	// we want to get the cimtype string from the buddy so that we can preserve
	// the classname for strongly typed references and objects.
	CString sCimtype;

	int iColBuddy =  m_pgc->GetBuddy();
	if (iColBuddy == NULL_INDEX) {
		sCimtype = type.CimtypeString();
	}
	else {
		CGridCell* pgcBuddy = &m_pGrid->GetAt(m_iRow, iColBuddy);
		CGcType typeBuddy = pgcBuddy->type();
		CIMTYPE cimtypeBuddy = (CIMTYPE) typeBuddy;
		CIMTYPE cimtypeTBuddy = cimtypeBuddy & ~CIM_FLAG_ARRAY;


		if (cimtypeT == cimtypeTBuddy) {
			// Get the cimtype string from the buddy since it is the
			// same basic type (object or reference).  This is done
			// to preserve the class name when the buddy cell is
			// strongly typed.
			sCimtype = typeBuddy.CimtypeString();
		}
		else {
			// Changing an object to a reference or vice versa, so just use
			// the basic "object" or "reference" for the cimtype string since
			// it doesn't really make sense to preserve the classname if the
			// buddy is strongly typed.
			sCimtype = type.CimtypeString();
		}
	}



	CDlgObjectType dlg;

	switch (cimtypeT) {
	case CIM_OBJECT:
		dlg.EditObjType(m_pgc->Grid(), sCimtype);
		type.SetCimtype(cimtype, sCimtype);
		break;
	case CIM_REFERENCE:
		dlg.EditRefType(m_pgc->Grid(), sCimtype);
		type.SetCimtype(cimtype, sCimtype);
		break;
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}


	return S_OK;

}



//**********************************************************
// CCellEdit::CatchEvent
//
// Catch events sent from the listbox or the combo-drop button.
//
// Parameters:
//		long lEvent
//			The event id.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::CatchEvent(long lEvent)
{
	int iItem;
	CString sText;
	BOOL bChangedCimtype = FALSE;

	CGcType type;

	switch(lEvent) {
	case NOTIFY_CELL_EDIT_COMBO_DROP_CLICKED:
		// Control comes here when the user clicks the combo-drop
		// button.  When this happens, the listbox is shown and the
		// focus is set to the listbox, etc.
		if (m_lbCombo.IsWindowVisible()) {
			m_lbCombo.ShowWindow(SW_HIDE);
			SetFocus();
		}
		else {


			CEdit::GetWindowText(sText);
			CellType celltype = m_pgc->GetType();
			switch(celltype) {
			case CELLTYPE_CIMTYPE_SCALAR:
			case CELLTYPE_CIMTYPE:
				*m_ptypeSave = m_pgc->type();
				if (HasObjectPrefix(sText)) {
					sText.LoadString(IDS_CIMTYPE_OBJECT_DLG);
				}
				else if (::IsPrefix(_T("ref"), sText)) {
					sText = "ref";
				}
				break;
			}




			iItem = m_lbCombo.FindString(-1, sText);
			if (iItem >= 0) {
				m_lbCombo.SetCurSel(iItem);
			}
			m_lbCombo.ShowWindow(SW_SHOW);
			m_lbCombo.SetFocus();

		}
		break;
	case NOTIFY_CELL_EDIT_LISTBOX_LBUTTON_UP:
		m_lbCombo.ShowWindow(SW_HIDE);
		ComboSelectionChanged();
		SetFocus();
#if 0

		// Control comes here when the user completes
		// a selection of a value in the list box.
		// Now it is necessary to hide the list box
		// and set the cell's value to the selection

		bModifyPrev = GetModify();

		// Hide the list box and copy the selected value to the edit box.
		iItem = m_lbCombo.GetCurSel();
		if (iItem >= 0) {
			m_lbCombo.GetText(iItem, sText);

			CellType celltype = m_pgc->GetType();
			if ((celltype == CELLTYPE_CIMTYPE) || (celltype == CELLTYPE_CIMTYPE_SCALAR)) {

				//SelectCimtypeFromCombo();
				sc = ComboSelectDisplayType(type, sText);
				if (FAILED(sc)) {
					return;
				}

				bChangedCimtype = (type != *m_ptypeSave);
				::MapGcTypeToDisplayType(sText, type);
			}

			m_bIsNull = FALSE;
			CEdit::SetWindowText(sText);
			SetModify(TRUE);
		}
		bModified = GetModify();

		// If the modification flag changed, then redraw the window
		// so that the text appears in the correct color.
		FixBuddyCell();

		if (bChangedCimtype) {
			m_pGrid->OnChangedCimtype(m_iRow, m_iCol);
		}


		if (GetModify() != bModifyPrev) {
			if (m_pgc) {
				m_pgc->SetModified(bModified);
			}
			if (m_pGrid) {
				m_pGrid->SyncCellEditor();
				m_pGrid->NotifyCellModifyChange();
				RedrawWindow();
			}
		}

		m_pGrid->SyncCellEditor();
		m_pGrid->OnEnumSelection(m_iRow, m_iCol);
		SetFocus();
#endif //0
		break;
	}
}

void CCellEdit::ComboSelectionChanged()
{

	// Control comes here when the user completes
	// a selection of a value in the list box.
	// Now it is necessary to hide the list box
	// and set the cell's value to the selection

	SCODE sc;
	BOOL bModifyPrev = GetModify();
	BOOL bChangedCimtype = FALSE;
	int iItem;
	CString sText;
	CGcType type;

	// Hide the list box and copy the selected value to the edit box.
	m_lbCombo.ShowWindow(SW_HIDE);
	iItem = m_lbCombo.GetCurSel();
	if (iItem >= 0) {
		m_lbCombo.GetText(iItem, sText);

		CellType celltype = m_pgc->GetType();
		if ((celltype == CELLTYPE_CIMTYPE) || (celltype == CELLTYPE_CIMTYPE_SCALAR)) {

			//SelectCimtypeFromCombo();
			sc = ComboSelectDisplayType(type, sText);
			if (FAILED(sc)) {
				return;
			}

			bChangedCimtype = (type != *m_ptypeSave);
			::MapGcTypeToDisplayType(sText, type);
		}

		m_bIsNull = FALSE;
		CEdit::SetWindowText(sText);
		SetModify(TRUE);
	}

	BOOL bModified = GetModify();

	// If the modification flag changed, then redraw the window
	// so that the text appears in the correct color.
	FixBuddyCell();

	if (bChangedCimtype) {
		m_pGrid->OnChangedCimtype(m_iRow, m_iCol);
	}


	if (GetModify() != bModifyPrev) {
		if (m_pgc) {
			m_pgc->SetModified(bModified);
		}
		if (m_pGrid) {
			m_pGrid->SyncCellEditor();
			m_pGrid->NotifyCellModifyChange();
			RedrawWindow();
		}
	}

	m_pGrid->SyncCellEditor();
	m_pGrid->OnEnumSelection(m_iRow, m_iCol);
	SetFocus();

}


BOOL CCellEdit::EditRefType(BOOL& bChangedReftype)
{
	bChangedReftype = FALSE;

#if 0

	CString sCurrentText;
	GetWindowText(sCurrentText);

	SCODE sc;
	CString sClass;


	CDlgObjectType dlg;
	sc = ClassFromReftype(sCurrentText, sClass);
	if (SUCCEEDED(sc)) {
		sText = sCurrentText;
		dlg.SetReftype(sCurrentText);
		bChangedReftype = TRUE;
	}
	int iResult = dlg.DoModal();

	switch(iResult) {
	case IDOK:
		sText = dlg.Cimtype();
		if (sText.CompareNoCase(sCurrentText)==0) {
			return;
		}
		bChangedReftype = TRUE;
		break;
	case IDCANCEL:
		return FALSE;
		break;
	}

#endif //0
	return bChangedReftype;
}

//**********************************************************
// CCellEdit::RedrawWindow
//
// Redraw this window and its siblings (the combo listbox and button).
//
// Parameters:
//		None
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::RedrawWindow()
{
	CEdit::RedrawWindow();
	if (m_btnCombo.IsWindowVisible()) {
		m_btnCombo.RedrawWindow();
	}

	if (m_lbCombo.IsWindowVisible()) {
		m_lbCombo.RedrawWindow();
	}

}






//*************************************************************************
// CCellEdit::Create
//
// Create the cell editor window.
//
// Parameters:
//		DWORD dwStyle
//			The window style.
//
//		RECT& rcCell
//			The rectangle that the editor is to occupy in the grid.
//
//		CWnd* pwndParent
//			The parent window.
//
//		UINT nID
//			The window ID
//
// Returns:
//		BOOL
//			TRUE if the window was successfully created, FALSE otherwise.
//
//**************************************************************************
BOOL CCellEdit::Create( DWORD dwStyle, const RECT& rcCell, CWnd* pwndParent, UINT nID )
{
	m_rcCell = rcCell;
	m_pwndParent = pwndParent;

	CRect rcComboButton;
	BOOL bNeedsComboButton = UsesComboEditing();
	if (bNeedsComboButton) {
		GetComboButtonRect(rcComboButton);
	}


	CRect rcEdit;
	GetEditRect(rcEdit, bNeedsComboButton, rcComboButton);



	BOOL bDidCreate;
	bDidCreate = CEdit::Create(dwStyle | ES_LEFT /* | ES_AUTOHSCROLL */ , rcEdit, pwndParent, nID);
	if (!bDidCreate) {
		return FALSE;
	}



	DWORD dwListBoxStyle;
	dwListBoxStyle =  WS_CHILD | LBS_STANDARD | LBS_WANTKEYBOARDINPUT ;


	CRect rcListBox;
	GetListBoxRect(rcListBox);
	bDidCreate = m_lbCombo.Create(dwListBoxStyle, rcListBox, pwndParent, GenerateWindowID());



	// Create the combo button
	DWORD dwButtonStyle  = (dwStyle & WS_VISIBLE) | WS_CHILD | BS_PUSHBUTTON;
	bDidCreate = m_btnCombo.Create(NULL, dwButtonStyle, rcComboButton, pwndParent, GenerateWindowID());
	if (bDidCreate) {

		m_bmComboDrop.LoadBitmap(MAKEINTRESOURCE(IDB_COMBO_DROP));
        m_btnCombo.ModifyStyle(0, BS_BITMAP);
		m_btnCombo.SetBitmap((HBITMAP) m_bmComboDrop);
	}


	return bDidCreate;
}




//*******************************************************
// CCellEdit::Layout
//
// Layout the cell editors parts.  This include the CEdit,
// the CButton for the combo-drop button, and the CListBox
// for the enumeration. Each of these windows are moved to
// the desired position in the grid.  However, it may be the
// case that one or more of these siblings are not visible.
// For example, the CListBox portion of the window is visible
// only if the combo-drop button was clicked and there is
// an enumeration to show.
//
// Parameters:
//		BOOL bRepaint
//			TRUE if the windows should be repainted.
//
// Returns:
//		Nothing.
//
//*******************************************************
void CCellEdit::Layout(BOOL bRepaint)
{
	CRect rc;
	CRect rcCurrent;

	CRect rcComboButton;
	BOOL bNeedsComboButton = UsesComboEditing();
	if (bNeedsComboButton) {
		GetComboButtonRect(rcComboButton);
	}


	if (m_hWnd) {
		GetEditRect(rc, bNeedsComboButton, rcComboButton);
		CEdit::GetWindowRect(rcCurrent);
		m_pwndParent->ScreenToClient(rcCurrent);
		if (!rc.EqualRect(&rcCurrent)) {
			CEdit::MoveWindow(rc, bRepaint);
		}
	}


	if (m_btnCombo.m_hWnd) {
		GetComboButtonRect(rc);
		m_btnCombo.GetWindowRect(rcCurrent);
		m_pwndParent->ScreenToClient(rcCurrent);
		if (!rc.EqualRect(&rcCurrent)) {
			m_btnCombo.MoveWindow(rc, bRepaint);
		}
	}

	if (m_lbCombo.m_hWnd) {
		GetListBoxRect(rc);
		m_lbCombo.GetWindowRect(rcCurrent);
		m_lbCombo.ClientToScreen(rcCurrent);
		if (!rc.EqualRect(&rcCurrent)) {
			m_lbCombo.MoveWindow(rc, bRepaint);
		}
	}

}




//******************************************************
// CCellEdit::SetFont
//
// Set the font to the specified font.
//
// Parameters:
//		CFont* pfont
//			The font to select.
//
//		BOOL bRedraw
//			TRUE if the windows should be redrawn.
//
// Returns:
//		Nothing.
//
//*******************************************************
void CCellEdit::SetFont(CFont* pfont, BOOL bRedraw)
{
	if (m_hWnd) {
		CEdit::SetFont(pfont, bRedraw);
	}

	if (m_lbCombo.m_hWnd) {
		m_lbCombo.SetFont(pfont, bRedraw);
	}
}



//*********************************************************
// CCellEdit::ShowWindow
//
// Show or hide the cell editor.
//
// Parameters:
//		int nCmdShow
//			See the MFC documentation for CWnd::ShowWindow
//
// Return:
//		BOOL
//			TRUE if the window was previously visible.
//
//**********************************************************
BOOL CCellEdit::ShowWindow( int nCmdShow )
{
	BOOL bWasVisible = CEdit::ShowWindow(nCmdShow);

	// If the listbox is empty, then this is not an enumeration,
	// so keep the combo button and listbox hidden.
	if (nCmdShow == SW_SHOW) {
		if ((m_lbCombo.m_hWnd!=NULL) && (m_lbCombo.GetCount() == 0)) {
			return bWasVisible;
		}
	}


#if 0
	// Pass the show command on to the listbox and combo button.

	if (nCmdShow != SW_SHOW) {
		if (m_lbCombo.m_hWnd) {
			m_lbCombo.ShowWindow(nCmdShow);
		}
	}


	if (m_btnCombo.m_hWnd) {
		m_btnCombo.ShowWindow(nCmdShow);
	}
#endif //0

	if (nCmdShow == SW_HIDE) {
		ShowCombo(SW_HIDE);
		if ((m_iRow != NULL_INDEX ) && (m_iCol != NULL_INDEX)) {
			m_pGrid->DrawCell(m_iRow, m_iCol);
		}
	}

	return bWasVisible;
}


void CCellEdit::ShowCombo(int nCmdShow)
{
	int i = 0;
	if (nCmdShow == SW_SHOW) {
		i = 2;
	}

	if (m_lbCombo.m_hWnd != NULL) {
		m_lbCombo.ShowWindow(nCmdShow);
	}
	if (m_btnCombo.m_hWnd != NULL) {
		m_btnCombo.ShowWindow(nCmdShow);
	}
}


//**************************************************************
// CCellEdit::MoveWindow
//
// Move the cell editor to a new location on the grid.
//
// Parameters:
//		LPRECT lpRect
//			A pointer to the destination rectangle.
//
//		BOOL bRepaint
//			TRUE if the cell editor should be repainted.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CCellEdit::MoveWindow( LPCRECT lpRect, BOOL bRepaint)
{
	m_rcCell = *lpRect;
	Layout(bRepaint);
}



//************************************************************
// CCellEdit::CtlColor
//
// Method for WM_CTLCOLOR to select the colors for this CCellEdit
// control.
//
// Parameters:
//		See the MFC documentation for OnCtlColor
//
// Returns:
//		HBRUSH
//			The brush handle that the background will be painted with.
//			A NULL value means use the parent's handler for CtlColor().
//
//***************************************************************
HBRUSH CCellEdit::CtlColor(CDC* pDC, UINT nCtlColor)
{
	if (GetModify()) {
		pDC->SetTextColor(m_clrTextDirty);
	}
	else {
		pDC->SetTextColor(m_clrTextClean);
	}


	pDC->SetBkColor( m_clrBkgnd );	// text bkgnd
	return m_brBkgnd;				// ctl bkgnd
}



//***************************************************************
// CCellEdit::RevertToInitialValue
//
// Revert the cell to its initial value.  This method is called
// when an ESC cahracter is entered.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CCellEdit::RevertToInitialValue()
{
	if (m_pgcCopy) {
		*m_pgc = *m_pgcCopy;
	}
	SetCell(m_pgc, m_iRow, m_iCol);
	FixBuddyCell();
}


BOOL CCellEdit::IsBooleanCell()
{
	if (m_pgc == NULL) {
		return FALSE;
	}

	CGcType type = m_pgc->type();
	CIMTYPE cimtype = (CIMTYPE) type;

	BOOL bIsBoolean = ((cimtype & ~CIM_FLAG_ARRAY) == CIM_BOOLEAN);
	return bIsBoolean;
}


void CCellEdit::SetBooleanCellValue(BOOL bValue)
{
	ASSERT(IsBooleanCell());

	// Initialize the boolean value that we're editing to true
	CGcType type = m_pgc->type();
	CIMTYPE cimtype = (CIMTYPE) type;
	COleVariant varValue;
	varValue.ChangeType(VT_BOOL);
	varValue.boolVal = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	m_pgc->SetValue(type, varValue);
	m_bIsNull = FALSE;
}

BOOL CCellEdit::GetBooleanCellValue()
{
	ASSERT(IsBooleanCell());
	if (m_pgc != NULL) {

		COleVariant var;
		CIMTYPE cimtype;
		m_pgc->GetValue(var, cimtype);
		if (var.vt != VT_BOOL) {
			return FALSE;
		}
		return var.boolVal;
	}
	return FALSE;
}

//***************************************************************
// CCellEdit::OnChar
//
// Called for each character entered into the edit box.
//
// We trap this message so that we can correct the "modify" flag
// to reflect the possibility that the initial text value was
// dirty to start with.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CCellEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{

	BOOL bModifyInitial = GetModify();
	SCODE sc;
	switch (nChar) {
	case VK_TAB:
	case ESC_CHAR:
	case CTL_C:
		break;
	default:
		if (m_pgc && (m_pgc->GetFlags() & CELLFLAG_READONLY)) {
			Beep(1700, 40);
			return;
		}
		break;
	}


	switch (nChar) {
	case VK_TAB:
		return;
	case ESC_CHAR:
		RevertToInitialValue();
		return;
	}


	CString sText;
	if (IsBooleanCell()) {
		BOOL bVal = TRUE;
		switch (nChar) {
		case ' ':
			// Toggle the value.
			bVal = GetBooleanCellValue();
			bVal = !bVal;
			break;
		case 'N':
		case 'n':
		case 'f':
		case 'F':
		case '0':
			bVal = FALSE;
			break;
		default:
			break;
		}
		SetBooleanCellValue(bVal);
		if (bVal) {
			sText.LoadString(IDS_TRUE);
		}
		else {
			sText.LoadString(IDS_FALSE);
		}
		SetWindowText(sText, TRUE);
	}

	else if (UsesComboEditing()) {
		GetWindowText(sText);
		if (m_bEditWithComboOnly) {
			sc = m_lbCombo.MapCharToItem(sText, nChar);
			if (SUCCEEDED(sc)) {
				SetWindowText(sText, TRUE);
				int iItem = m_lbCombo.FindString(0, sText);
				ASSERT(iItem >= 0);
				m_lbCombo.SetCurSel(iItem);
				ComboSelectionChanged();
			}
		}
	}



	// Notify the grid that a WM_CHAR occurred in the cell.
	if (m_pGrid) {
		m_pGrid->OnCellChar(m_iRow,
					  m_iCol,
					  nChar, nRepCnt, nFlags);
	}




	if (m_lbCombo.GetCount()>0) {
		// If this cell contains an enumeration, it doesn't make sense to
		// allow the user to directly enter the value.  They should use the
		// drop-down instead.
		switch(m_pgc->GetType()) {
		case CELLTYPE_ATTR_TYPE:
		case CELLTYPE_CIMTYPE:
		case CELLTYPE_CIMTYPE_SCALAR:
			return;
		};
	}

	BOOL bModifyPrev = GetModify();

	if (IsNull()) {
		SetWindowText(_T(""), TRUE);
		m_bIsNull = FALSE;
		RedrawWindow();
	}

	CEdit::OnChar(nChar, nRepCnt, nFlags);
	if ((nChar == CONTROL_Z_CHAR)) {
		CString sText;
		GetWindowText(sText);
		if (sText != m_sInitialText) {
			SetModify(TRUE);
		}
		else {
			SetModify(FALSE);
		}
	}

	// If the modification flag changed, then redraw the window
	// so that the text appears in the correct color.
	if (m_pGrid) {
		if (GetModify() != bModifyInitial) {
			m_pGrid->NotifyCellModifyChange();
		}
	}

	if (GetModify() != bModifyPrev) {
		RedrawWindow();
	}
}




//******************************************************************
// CCellEdit::SetWindowText
//
// This version of SetWindowText has an extra parameter to indicate
// whether or not the text value should be displayed in the "dirty"
// color.
//
// Parameters:
//		CString& sText
//			The text to display.
//
//		BOOL bIsDirtyText
//			TRUE if the text is initially dirty.  This could happen if
//			the user edits a field, thus making it dirty, selects another
//			field and then comes back to the same "dirty" field.
//
//*****************************************************************
void CCellEdit::SetWindowText(LPCTSTR pszText, BOOL bIsDirtyText)
{
	m_bWasInitiallyDirty = bIsDirtyText;
	m_sInitialText = pszText;
	CEdit::SetWindowText(pszText);
	SetModify(bIsDirtyText);
	RedrawWindow();
}



//**********************************************************
// CCellEdit::ReplaceSel
//
// This version of ReplaceSel marks the text as "dirty" and
// the redraws the window in the new color if the previous
// text was clean.
//
// Parameters:
//		LPCTSTR pszText
//			Pointer to the new window text.
//
//		BOOL bCanUndo
//			TRUE if undo operations are allowed.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CCellEdit::ReplaceSel(LPCTSTR pszText, BOOL bCanUndo)
{
	BOOL bModifyPrev = GetModify();
	CEdit::ReplaceSel(pszText, bCanUndo);
	SetModify(TRUE);

	if (GetModify() != bModifyPrev) {
		if (m_pGrid) {
			m_pGrid->NotifyCellModifyChange();
		}
		RedrawWindow();
	}
}



//******************************************************************
// CCellEdit::OnLButtonDown
//
// When the mouse is clicked on the CEdit part of the cell editor,
// hide the drop-down list if it is not already hidden.
//
// Parameters:
//		See the MFC documentation for WM_LBUTTONDOWN
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CCellEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	CEdit::OnLButtonDown(nFlags, point);

	// Check to see if the cell editor was double clicked.  If so,
	// tell the parent that a double click occurred.
	UINT uiDblClickTime = ::GetDoubleClickTime();
	LONG lClickTime = GetMessageTime();
	LONG ldtClick;
	if (lClickTime > m_lGridClickTime) {
		ldtClick = lClickTime - m_lGridClickTime;
	}
	else {
		ldtClick = m_lGridClickTime - lClickTime;
	}

	if (ldtClick < (LONG) ::GetDoubleClickTime()) {
		// Double click detected.
		CPoint ptGrid = point;
		ClientToScreen(&ptGrid);
		m_pGrid->ScreenToClient(&ptGrid);

		m_pGrid->SetFocus();
		m_pGrid->NotifyDoubleClk(nFlags, ptGrid);
	}


	if (UsesComboEditing()) {
		switch(m_pgc->GetType()) {
		case CELLTYPE_ATTR_TYPE:
		case CELLTYPE_CIMTYPE:
		case CELLTYPE_CIMTYPE_SCALAR:
			// Remove the selection.
			SetSel(-1, 0);
			return;
		};

	}

	if (m_lbCombo.IsWindowVisible()) {
		m_lbCombo.ShowWindow(SW_HIDE);
	}
}


//******************************************************************
// CCellEdit::OnLButtonDown
//
// When the mouse is double-clicked on the CEdit part of the cell editor,
// hide the drop-down list if it is not already hidden then pass the double-click
// on to the grid control.
//
// Parameters:
//		See the MFC documentation for WM_LBUTTONDBLCLICK
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CCellEdit::OnLButtonDblClk(UINT nFlags, CPoint point)
{

	if (m_lbCombo.IsWindowVisible()) {
		m_lbCombo.ShowWindow(SW_HIDE);
	}

	if (m_pGrid) {
		ClientToScreen(&point);
		m_pGrid->ScreenToClient(&point);
		m_pGrid->NotifyDoubleClk(nFlags, point);
	}
}


//****************************************************************
// CCellEdit::UsesComboEditing
//
// Check to see if a combo box is used for the editing.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***************************************************************
BOOL CCellEdit::UsesComboEditing()
{
	if (!::IsWindow(m_lbCombo.m_hWnd)) {
		return FALSE;
	}

	BOOL bUseComboEditing = m_lbCombo.GetCount() > 0;
	return bUseComboEditing;

}




BOOL CCellEdit::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{

		case VK_TAB:
			m_pGrid->OnTabKey(GetKeyState(VK_SHIFT) < 0);
			return TRUE;
		}
		break;
	}

	return CEdit::PreTranslateMessage(pMsg);
}




/////////////////////////////////////////////////////////////////////////////
// CLbCombo
//
// This class is the listbox that drops down when the combo-drop button is
// clicked in the cell editor.  This class exists for the sole purpose of
// notifying its sibling (the CEdit part of the cell editor) when a selection
// is made in the combo box.
//
/////////////////////////////////////////////////////////////////////////////
CLbCombo::CLbCombo()
{
	m_pClient = NULL;
	m_bUIActive = FALSE;
}

CLbCombo::~CLbCombo()
{
}


BEGIN_MESSAGE_MAP(CLbCombo, CListBox)
	//{{AFX_MSG_MAP(CLbCombo)
	ON_WM_LBUTTONUP()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLbCombo message handlers


//****************************************************************
// CLbCombo::OnLButtonUp
//
// When the mouse button is released, send a message to the sibling
// window so that it can get the current selection.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CLbCombo::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CListBox::OnLButtonUp(nFlags, point);

	m_pClient->CatchEvent(NOTIFY_CELL_EDIT_LISTBOX_LBUTTON_UP);
}







void CCellEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{

	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);


	BOOL bWasModified = GetModify();
	if (m_pGrid) {
		if (m_pGrid->OnCellKeyDown(m_iRow,
					  m_iCol,
					  nChar, nRepCnt, nFlags)) {

			// The derived class handled the keydown,
			// so just set the modified state.
			BOOL bIsModified = GetModify();
			if (!bWasModified && bIsModified) {
				if (m_pGrid) {
					m_pGrid->NotifyCellModifyChange();
				}
			}
			return;
		}
	}


	// The derived class, did not handle this keydown
	// event.
	switch(nChar) {
	case VK_UP:
		m_pGrid->OnRowUp();
		return;
	case VK_DOWN:
		m_pGrid->OnRowDown();
		return;
	case VK_TAB:
		m_pGrid->OnTabKey(GetKeyState(VK_SHIFT) < 0);
		return;
	case VK_DELETE:
		if (m_pgc && (m_pgc->GetFlags() & CELLFLAG_READONLY)) {
			Beep(1700, 40);
		}
		return;
	}


	BOOL bIsModified = GetModify();
	if (!bWasModified && bIsModified) {
		if (m_pGrid) {
			m_pGrid->NotifyCellModifyChange();
		}
	}
}


//*********************************************************
// CCellEdit::OnSetFocus
//
// Hook out OnSetFocus so that we can prevent the focus from
// ever being set to the combo box.  In the future it might
// be nice to allow the user to select the text in the combo
// box so that it can be copied, etc.
//
// Parameters:
//		CWnd* pOldWnd
//			Pointer to the window loosing the focus.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CCellEdit::OnSetFocus(CWnd* pOldWnd)
{
	if (m_lbCombo.m_hWnd!=NULL && m_lbCombo.GetCount() > 0) {
		// Don't allow the focus to be set on a combo box.
		switch(m_pgc->GetType()) {
		case CELLTYPE_ATTR_TYPE:
		case CELLTYPE_CIMTYPE:
		case CELLTYPE_CIMTYPE_SCALAR:
			return;
			break;
		};

	}

	CEdit::OnSetFocus(pOldWnd);

	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		RequestUIActive();
	}
}


void CCellEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}

void CCellEdit::OnContextMenu(CWnd* pWnd, CPoint pt)
{
	m_menuContext.DestroyMenu();
	BOOL bUseCustomMenu = m_pGrid->GetCellEditContextMenu
									(m_iRow, m_iCol,
									m_pwndContextMenuTarget,
									m_menuContext,
									m_bContextMenuTargetWantsEditCommands);

	// Pass the coordinates of the context menu click on to the grid.  Also
	// check to see if it wants to display and track the context menu directly.
	if (m_pGrid->OnCellEditContextMenu(pWnd, pt)) {
		return;
	}

	if (bUseCustomMenu) {

		CMenu* pPopup = m_menuContext.GetSubMenu(0);
		ASSERT(pPopup != NULL);


		DWORD dwStyle = GetStyle();
		BOOL bIsReadonly = dwStyle & ES_READONLY;

		BOOL bEnableCopy = TRUE;
		BOOL bEnableCut = TRUE;
		BOOL bEnablePaste = TRUE;
		BOOL bEnableSelectAll = TRUE;
		BOOL bEnableClear = TRUE;


		int nStartChar;
		int nEndChar;

		GetSel(nStartChar, nEndChar );
		if (nStartChar >= nEndChar) {
			// There is nothing to select, so disable the appropriate menu items
			bEnableCopy = FALSE;
			bEnableCut = FALSE;
			bEnableClear = FALSE;
		}
		if (!CanUndo()) {
			pPopup->EnableMenuItem(ID_EDIT_UNDO, MF_DISABLED | MF_GRAYED);
		}


		CString sText;
		GetWindowText(sText);
		if (sText.GetLength() == 0) {
			// There is no text to select
			bEnableSelectAll = FALSE;
		}


		COleDataObject *pdata = new COleDataObject;
		BOOL bDidAttach = pdata->AttachClipboard();
		BOOL bCanPaste = FALSE;
		if (bDidAttach) {
			if (pdata->IsDataAvailable(CF_TEXT)) {
				bCanPaste = TRUE;
			}
		}
		if (!bCanPaste) {
			// There is no text available for pasting.
			pPopup->EnableMenuItem(ID_EDIT_PASTE, MF_DISABLED | MF_GRAYED);
		}



		if (bIsReadonly) {
			bEnableCut = FALSE;
			bEnablePaste = FALSE;
			bEnableClear = FALSE;
		}

		pPopup->EnableMenuItem(ID_EDIT_COPY, bEnableCopy ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
		pPopup->EnableMenuItem(ID_EDIT_CUT, bEnableCut ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
		pPopup->EnableMenuItem(ID_EDIT_PASTE, bEnablePaste ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
		pPopup->EnableMenuItem(ID_EDIT_CLEAR, bEnableClear ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
		pPopup->EnableMenuItem(ID_EDIT_SELECT_ALL, bEnableSelectAll ? MF_ENABLED : MF_DISABLED | MF_GRAYED);


		m_pGrid->ModifyCellEditContextMenu(m_iRow, m_iCol, m_menuContext);
		pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, this);

	}
	else {
		m_pwndContextMenuTarget = NULL;
		CEdit::OnContextMenu(pWnd, pt);
	}

}

void CCellEdit::OnEditClear()
{
	Clear();
}

void CCellEdit::OnEditCopy()
{
	Copy();
}

void CCellEdit::OnEditCut()
{
	Cut();
}

void CCellEdit::OnEditPaste()
{
	Paste();
}

void CCellEdit::OnEditSelectAll()
{
	SetSel(0, -1);
}

void CCellEdit::OnEditUndo()
{
	Undo();
}


BOOL CCellEdit::OnCommand( WPARAM wParam, LPARAM lParam )
{
	if (m_pwndContextMenuTarget) {
		CMenu* pPopup = m_menuContext.GetSubMenu(0);
		ASSERT(pPopup != NULL);

		UINT nItems = pPopup->GetMenuItemCount( );
		for (UINT iItem =0; iItem < nItems; ++iItem) {
			UINT uiMenuItem = pPopup->GetMenuItemID(iItem);
			if (uiMenuItem == wParam) {
				if (m_bContextMenuTargetWantsEditCommands) {
					// Send all commands to the target, even the editing commands.
					m_pwndContextMenuTarget->SendMessage(WM_COMMAND, wParam, lParam);
					return TRUE;
				}

				switch(uiMenuItem) {
				case ID_EDIT_CUT:
				case ID_EDIT_COPY:
				case ID_EDIT_PASTE:
				case ID_EDIT_CLEAR:
				case ID_EDIT_SELECT_ALL:
				case ID_EDIT_UNDO:
				case ID_CMD_SET_CELL_TO_NULL:
					break;
				default:
					m_pwndContextMenuTarget->SendMessage(WM_COMMAND, wParam, lParam);
					return TRUE;
				}
			}
		}
	}

	return CEdit::OnCommand(wParam, lParam);
}





//********************************************************************
// CCellEdit::SetToNull
//
// Set the value of the current cell to NULL.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CCellEdit::SetToNull()
{

	DWORD dwStyle = GetStyle();
	BOOL bIsReadonly = dwStyle & ES_READONLY;
	if (bIsReadonly) {
		return;
	}

	if (IsNull()) {
		return;
	}

	BOOL bModified = GetModify();

	CString sEmpty;
	if (m_pGrid->ShowNullAsEmpty()) {
		sEmpty = "<empty>";
	}

	SetWindowText(sEmpty, TRUE);
	m_bIsNull = TRUE;



	// If the modification flag changed, then redraw the window
	// so that the text appears in the correct color.
	FixBuddyCell();
	if (GetModify() != bModified) {
		if (m_pgc) {
			m_pgc->SetModified(bModified);
		}
		if (m_pGrid) {
			m_pGrid->NotifyCellModifyChange();
			RedrawWindow();
		}
	}

}

BOOL CCellEdit::IsNull()
{
#if 0
	if (m_bIsNull) {
		CString sText;
		GetWindowText(sText);
		BOOL bTextIsEmpty = sText=="<empty>";
		if (!bTextIsEmpty) {
			m_bIsNull = FALSE;
		}
	}
#endif //0

	return m_bIsNull;
}

void CCellEdit::OnCmdSetCellToNull()
{
	SetToNull();
}

void CCellEdit::OnChange()
{
	if (m_pGrid) {
		if (m_bPropagateChange) {
			m_pGrid->NotifyCellModifyChange();
		}
	}
}



void CCellEdit::RequestUIActive()
{
	if (m_pGrid) {
		m_pGrid->OnRequestUIActive();
	}
}

void CLbCombo::OnSetFocus(CWnd* pOldWnd)
{
	CListBox::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		m_pClient->RequestUIActive();
	}

}

void CLbCombo::OnKillFocus(CWnd* pNewWnd)
{
	CListBox::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}



void CLbCombo::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	switch(nChar) {
	case ESC_CHAR:
		m_pClient->CatchEvent(NOTIFY_CELL_EDIT_LISTBOX_LBUTTON_UP);
		return;
	case VK_TAB:
		return;
	}

	CListBox::OnChar(nChar, nRepCnt, nFlags);
}


//********************************************************************
// CLbCombo::MapCharToItem
//
// Map a character to an item in the list.  This is used when the
// user types a character to cycle through the values in the list
// that start with the given character.
//
// Parameters:
//		CString& sValue
//
//		UINT nChar
//
// Returns:
//		Nothing.
//
//********************************************************************
SCODE CLbCombo::MapCharToItem(CString& sValue, UINT nChar)
{
	nChar = toupper(nChar);
	UINT nCharItem;

	int nItems = GetCount();
	int iItem;

	// If the user repeatedly hits the same character, cycle through the values
	// that start with that character.
	int iValue = -1;
	if (sValue.GetLength() > 0) {
		UINT nCharValue = (UINT) toupper(sValue[0]);
		if (nCharValue == nChar) {
			ASSERT(LB_ERR < 0);
			iValue = FindString(-1, sValue);
		}
	}


	CString sItem;
	if (iValue >= 0)  {
		// The value string was found in the list, so start looking at the
		// first item past this value for another one that starts with the
		// same given character.
		for (iItem = iValue + 1; iItem < nItems; ++iItem) {
			GetText(iItem, sItem);
			if (sItem.GetLength() > 0) {
				nCharItem = (UINT) toupper(sItem[0]);
				if (nCharItem == nChar) {
					sValue = sItem;
					return S_OK;
				}
			}
		}

		// Start over at the beginning of the list and continue up the
		// the current value looking for an item that starts with the specified
		// character.
		for (iItem = 0; iItem < iValue; ++iItem) {
			GetText(iItem, sItem);
			if (sItem.GetLength() > 0) {
				nCharItem = (UINT) toupper(sItem[0]);
				if (nCharItem == nChar) {
					sValue = sItem;
					return S_OK;
				}
			}
		}
		sValue = "";
		return E_FAIL;
	}
	else {
		// No string in the list matches the current value, so look through the
		// entire list from the beginning for an item that starts with the given
		// character.
		for (iItem = 0; iItem < nItems; ++iItem) {
			GetText(iItem, sItem);
			if (sItem.GetLength() > 0) {
				nCharItem = (UINT) toupper(sItem[0]);
				if (nCharItem == nChar) {
					sValue = sItem;
					return S_OK;
				}
			}
		}
		sValue = "";
		return E_FAIL;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\core.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _core_h
#define _core_h


#if 0
enum GridString {
	IDGS_TRUE = 0,
	IDGS_FALSE,
	IDGS_EMPTY_STRING
};

enum GridResource {
	GR_STRING_TRUE,			// String for "TRUE"
	GR_STRING_FALSE,			// String for "FALSE"
	GR_STRING_EMPTY  	// String for "<empty>"
};

#endif //0



/////////////////////////////////////////////////////////////////////////////
// CGridCore
//
// This window is the core of the grid implementation.  The CGrid class is 
// a wrapper around this CGridCore class.
//
// This is a sibling to the CGridHdr window.
//
/////////////////////////////////////////////////////////////////////////////
class CGridCore : public CWnd
{
// Construction
public:
	CGridCore();
	BOOL EntireRowIsSelected(int iRow);
	BOOL EntireRowIsSelected();
	BOOL Create(CRect& rc, UINT nId, BOOL bVisible);
	void GetVisibleRect(CRect& rcVisible) {GetClientRect(rcVisible); ClientToGrid(rcVisible); }

	void DrawSelectionFrame(CDC* pdc, CRect& rcFrame, BOOL bShow);
	void RefreshCellEditor();
	SCODE SyncCellEditor();
	BOOL GetCellRect(int iRow, int iCol, CRect& rc);
	BOOL GetCellTextRect(int iRow, int iCol, CRect& rc);
	BOOL GetCellEditRect(int iRow, int iCol, CRect& rc);

	void ExcludeRowHandlesRect(CDC* pdc);
	void DrawRows(CDC* pdc, int iStartRow, int nRows, BOOL bDrawGrid);
	void DrawCellText(CDC* pdc, int iRow, int iCol);
	void DrawCell(int iRow, int iCol);

	void EndCellEditing();
	BOOL BeginCellEditing();
	BOOL IsEditingCell() {return m_edit.GetCell() != NULL; }

	void DrawGrid(CDC* pdc, int iStartRow, int nRows);
	int  RowHeight() {return m_cyFont + 2 * m_sizeMargin.cy; }
	void OnInitialPaint(CDC* pdc);
	BOOL PointToCell(CPoint point, int& iRow, int& iCol);
	BOOL PointToRow(CPoint pt, int& iRow);
	BOOL PointToRowHandle(CPoint pt, int& iRow);
	int GetMaxValueWidth(int iCol);

	BOOL SelectCell(int iRow, int iCell, BOOL bForceBeginEdit=FALSE);
	void SelectRow(int iRow);
//	void GetGridFont(CFont& font);
	void EnsureRowVisible(int iRow);
	CGridCell& GetAt(int iRow, int iCol) {return m_aGridCell.GetAt(iRow, iCol); }
	int GetRows() {return m_aGridCell.GetRows(); }
	int GetCols() {return m_aGridCell.GetCols(); }
	int GetVisibleCols();
	void InsertRowAt(int iRow);
	int AddRow();
	void DeleteRowAt(int iRow, BOOL bUpdateWindow);
	void AddColumn(int iWidth, LPCTSTR pszTitle);
	void SetColumnWidth(int iCol, int cx, BOOL bRedraw=TRUE);
	void InsertColumnAt(int iCol, int iWidth, LPCTSTR pszTitle );
	void Clear(BOOL bUpdateWindow=TRUE);
	void ClearRows(BOOL bUpdateWindow=TRUE);
	BOOL WasModified(); 
	void SetModified(BOOL bWasModified);

	void SetCellModified(int iRow, int iCol, BOOL bWasModified);
	void NotifyCellModifyChange();
	int ColWidth(int iCol) {if (m_aiColWidths.GetSize() > iCol) {return m_aiColWidths[iCol];} else return 0; }
	CString& ColTitle(int iCol) {return m_asColTitles[iCol]; }
	CFont& GetFont() {return m_font; }
	void UpdateScrollRanges();
	void OnTabKey(BOOL bShiftKeyDepressed);
	void OnRowDown();
	void OnRowUp();

	BOOL OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	BOOL OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	void SortGrid(int iRowFirst, int iRowLast, int iSortColumn, BOOL bAscending=TRUE, BOOL bRedrawWindow=FALSE);
	void SetRowHandleWidth(int cxRowHandles) {m_cxRowHandles = cxRowHandles; }
	int GetRowHandleWidth() {return m_cxRowHandles; }
	void GetRowRect(int iRow, CRect& rcRow);
	void GridToClient(CRect& rc);
	void ClientToGrid(CRect& rc); 
	void GridToClient(CPoint& pt);
	void ClientToGrid(CPoint& pt);
	BOOL GetColPos(int iCol);
	BOOL GetVisibleColPos(int iCol);
	int  MapVisibleColToAbsoluteCol(int iVisibleCol);

	void DrawRowHandles(CDC* pdc);

	void SwapRows(int iRow1, int iRow2) {m_aGridCell.SwapRows(iRow1, iRow2); }
	int GetSelectedRow() { return m_aGridCell.m_iSelectedRow;}
	void GetSelectedCell(int& iRow, int& iCol) {iRow = m_aGridCell.m_iSelectedRow; iCol = m_aGridCell.m_iSelectedCol; }
	void SetParent(CGrid* pGrid);
	BOOL NumberRows(BOOL bNumberRows, BOOL bRedraw=TRUE);
	BOOL IsNumberingRows() {return m_bNumberRows; }
	void OnChangedCimtype(int iRow, int iCol) { m_pParent->OnChangedCimtype(iRow, iCol); }
	void OnRequestUIActive() {m_pParent->OnRequestUIActive(); }
	void GetCellEnumStrings(int iRow, int iCol, CStringArray& sa) {m_pParent->GetCellEnumStrings(iRow, iCol, sa); }
	void OnEnumSelection(int iRow, int iCol) {m_pParent->OnEnumSelection(iRow, iCol); }
	CGridRow& GetRowAt(int iRow) { return m_aGridCell.GetRowAt(iRow); }

	// Method for overriding the context menu.
	BOOL OnCellEditContextMenu(CWnd* pwnd, CPoint ptContextMenu) {return m_pParent->OnCellEditContextMenu(pwnd, ptContextMenu); }
	BOOL GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands);
	void ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu);


	// Methods for manipulating the row and column tag values.  The tags
	// are DWORDS that are available for use any way you see fit.
	void SetColTagValue(int iCol, DWORD dwTagValue) {m_adwColTags[iCol] = dwTagValue; }
	DWORD GetColTagValue(int iCol) {return m_adwColTags[iCol]; }
	void SetRowTagValue(int iRow, DWORD dwTagValue);
	DWORD GetRowTagValue(int iRow);
	int OnBeginSort(int& nEditStartSel, int& nEditEndSel);
	void OnEndSort(int iSelectedRow, int nEditStartSel, int nEditEndSel);

	void SetNullCellDrawMode(BOOL bShowEmptyText=TRUE) {m_bShowEmptyCellAsText = bShowEmptyText; }
	BOOL ShowNullAsEmpty() {return m_bShowEmptyCellAsText; }


// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridCore)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGridCore();
	void NotifyDoubleClk(UINT nFlags, CPoint point);

	// Generated message map functions
protected:
	//{{AFX_MSG(CGridCore)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void StopMouseTracking();
	void GetRowHandlesRect(CRect& rc);
	void DrawRowHandle(CDC* pdc, CRect& rc);
	void ExcludeHiddenRows(CDC* pdc, int& iStartRow, int& nRows);
	void CalcVisibleCells(CDC* pdc, int& iColLeft, int& iRowTop, int& iColRight, int& iRowBottom);
	void UpdateEditorPosition();
	void UpdateOrigin();
	void ShowSelectionFrame(BOOL bShow);
	BOOL IsSelectedCell(int iRow, int iCol);
	inline BOOL IsFullRowSelection(int iRow, int iCol);
	void InvalidateRowRect(int iRow);
	void InvalidateRowRect();
	inline CGridCell* SelectedCell();	
	inline BOOL SomeCellIsSelected();
	
	inline void ClearSelection();
	inline BOOL IsNullCell(int iRow, int iCol);

	BOOL IsControlChar(UINT nChar, UINT nFlags);
	void ScrollGrid(int nBar, int iNewPos);
//	void DrawRowHandles(CDC* pdc, int iStartRow, int nRows);
	void DrawArrayPicture(CDC* pdc, CRect& rcCell, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell);
	void DrawObjectPicture(CDC* pdc, CRect& rcCell, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell);
	void DrawCheckboxPicture(CDC* pdc, CRect& rcCell, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell, CGridCell* pgc);
	void DrawCellBitmap(CDC* pdc, CRect& rcCell, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell, CGridCell* pgc);
	void DrawPropmarker(CDC* pdc, CRect& rcCell, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell, CGridCell* pgc);
	void DrawTime(CDC* pdc, CRect& rcCell, CRect& rcCellText, COLORREF clrForeground, COLORREF clrBackground, BOOL bHighlightCell, CGridCell* pgc);
	CSize MeasureFullCellSize(CDC* pdc, int iRow, int iCol);


	CStringArray m_asColTitles;
	CDWordArray m_aiColWidths;
	CDWordArray m_adwColTags;
	CGridCellArray m_aGridCell;
	CSize m_sizeMargin;
	int m_cyFont;
	int m_nLineThickness;
	BOOL m_bDidInitialPaint;
	BOOL m_bTrackingMouse;
	BOOL m_bRunningScrollTimer;
	int m_iScrollDirection;
	int m_nRowsClient;
	int m_nWholeRowsClient;
	int m_iScrollSpeed;
	CCellEdit m_edit;
	CFont m_font;
	BOOL m_bIsScrolling;

	BOOL m_bWasModified;
	CGrid* m_pParent;
	CPoint m_ptOrigin;
	int m_cxRowHandles;
	void UpdateRowHandleWidth();
	BOOL m_bNumberRows;
	BOOL m_bUIActive;
	BOOL m_bShowEmptyCellAsText;
};




#endif //_core_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\celledit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  CellEdit.h
//
//  This file contains the class definitions for the grid cell editor. For more
//  information, please see CellEdit.cpp.
//
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#ifndef _CellEdit_h
#define _CellEdit_h

//#include "notify.h"

#include "buttons.h"



class CGridCore;
class CGridCell;
class CCellEdit;
class CGcType;

/////////////////////////////////////////////////////////////////////////////
// CLbCombo window
// 
// This class implements the listbox that drops down when the combo-drop 
// button is clicked in the cell editor.  
//
/////////////////////////////////////////////////////////////////////////////
class CLbCombo : public CListBox
{
// Construction
public:
	CLbCombo();

// Attributes
public:
	CCellEdit* m_pClient;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLbCombo)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLbCombo();
	SCODE MapCharToItem(CString& sValue, UINT nChar);

	// Generated message map functions
protected:
	//{{AFX_MSG(CLbCombo)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	BOOL m_bUIActive;
};



/////////////////////////////////////////////////////////////////////////////
// The CCellEdit class.
//
// This class implements the core of the grid cell editor.  The grid cell editor
// is made up of three parts, a CEdit, a CButton, and a CListBox.  The CButton
// and CListBox are used to implement the combo-drop button and enumeration list
// respectively.
//
// A standard combo-box was not used as the base class because there was no
// way to turn off the border drawing and, thus, there was no way to get the
// desired look and feel.  Also, a custom implementation gives us more flexibility.
//
//////////////////////////////////////////////////////////////////////////////
class CCellEdit : public CEdit
{
// Construction
public:
	CCellEdit();
	BOOL Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID );
	void SetGrid(CGridCore* pGrid) {m_pGrid = pGrid; }
	virtual BOOL OnCommand( WPARAM wParam, LPARAM lParam );
  
	BOOL ShowWindow( int nCmdShow );
	void MoveWindow( LPCRECT lpRect, BOOL bRepaint = TRUE );
	void SetFont(CFont* pfont, BOOL bRedraw=FALSE);
//	void MoveCombo();
	void CatchEvent(long lEvent);
	BOOL SetCell(CGridCell* pGridCell, int iRow, int iCol);
	CGridCell* GetCell() {return m_pgc; }
	BOOL UsesComboEditing(); 

	void NotifyGridClicked(LONG lClickTime) {m_lGridClickTime = lClickTime; }
	void RevertToInitialValue();
	BOOL IsNull();
	void SetToNull();
	void RequestUIActive();

// Attributes
public:
	COLORREF m_clrTextDirty;
	COLORREF m_clrTextClean;
	COLORREF m_clrBkgnd;
	CBrush m_brBkgnd;
	BOOL m_bWasInitiallyDirty;
	CString m_sInitialText;

// Operations
public:
	void SetWindowText(LPCTSTR pszText, BOOL bIsDirtyText);
	void ReplaceSel(LPCTSTR pszText, BOOL bCanUndo);
	void EditRectFromCellRect(RECT& rcEdit, const RECT& rcCell);
	void RedrawWindow();


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCellEdit)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCellEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCellEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnEditClear();
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnEditPaste();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditUndo();
	afx_msg void OnCmdSetCellToNull();
	afx_msg void OnChange();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	afx_msg LRESULT OnPaste(WPARAM wParam, LPARAM lParam);

	DECLARE_MESSAGE_MAP()
private:
//	void CalcComboRects(const RECT& rcEdit, const RECT& rcParent, RECT& rcListBox, RECT& rcComboButton);
	SCODE ComboSelectDisplayType(CGcType& type, LPCTSTR pszDisplayType);
	void SelectComboItemByChar(UINT nChar);
	void ComboSelectionChanged();
	void GetEditRect(RECT& rcEdit, BOOL bNeedsCombo, CRect& rcCombo);
	void GetListBoxRect(RECT& rcListBox);
	void GetComboButtonRect(RECT& rcComboButton);
	void Layout(BOOL bRepaint=TRUE);
	void LoadListBox(CStringArray& sa);
	void FixBuddyCell();
	void SetEnumeration();
	void ShowCombo(int nCmdShow);
	BOOL EditRefType(BOOL& bChangedReftype);
	BOOL IsBooleanCell();
	void SetBooleanCellValue(BOOL bValue);
	BOOL GetBooleanCellValue();


	CGridCore* m_pGrid;
	CWnd* m_pwndParent;
	CLbCombo m_lbCombo;
	CBitmap m_bmComboDrop;
	CHmmvButton m_btnCombo;
	CRect m_rcCell;
	CGridCell* m_pgc;
	CGridCell* m_pgcCopy;
	int m_iRow;
	int m_iCol;
	LONG m_lGridClickTime;

	CMenu m_menuContext;
	CWnd* m_pwndContextMenuTarget;
	BOOL m_bContextMenuTargetWantsEditCommands;
	BOOL m_bIsNull;
	BOOL m_bPropagateChange;
	BOOL m_bUIActive;
	BOOL m_bEditWithComboOnly;
	CGcType* m_ptypeSave;
};



/////////////////////////////////////////////////////////////////////////////


#define COLOR_DIRTY_CELL_TEXT  RGB(0, 0, 255)  // Clean cell text color = BLUE
#define COLOR_CLEAN_CELL_TEXT RGB(0, 0, 0)     // Dirty cell text color = BLACK

#define CONTROL_Z_CHAR 0x01a				// The "undo" character
#define ESC_CHAR       0x1b

#endif // _CellEdit_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\core.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "resource.h"
#include "globals.h"
#include "notify.h"
#include "gc.h"
#include "gca.h"
#include "gridhdr.h"
#include "grid.h"
#include "celledit.h"
#include "core.h"
#include "utils.h"
#include <afxctl.h>
#include <afxcmn.h>

extern HINSTANCE g_hInstance;

#define CX_SMALL_ROWHANDLE  16
#define CX_ROW_INDEX_MARGIN 3	// The margin on each side of the row index in the row handle
#define CY_ROW_INDEX_MARGIN 2

#define CX_EXTRA 4
#define CX_CHECKBOX   16
#define CX_ARRAY_PICTURE 48
#define CX_OBJECT_PICTURE 48
#define CX_PROPMARKER 16
#define CY_PROPMARKER 16

enum {ID_TIMER_SCROLL=1, ID_EDIT1};
enum {TIMER_SCROLL_UP = 0, TIMER_SCROLL_DOWN, TIMER_SCROLL_NONE };


extern AFX_EXTENSION_MODULE HmmvgridDLL;

//***************************************************************
// The scrolling throttle.
//
// These constants are used to define a variable-speed scrolling
// throttle.  For example, moving the mouse just below the
// edge of the window wil result in slow scrolling.  Moving the
// mouse far below the bottom edge of the window results in fast
// scrolling.
//**************************************************************
#define STOP_SCROLL_MILLISECONDS		  0
#define SLOW_SCROLL_MILLISECONDS		400
#define MEDIUM_SCROLL_MILLISECONDS		150
#define FAST_SCROLL_MILLISECONDS		 25

#define CY_SLOW_SCROLL_THROTTLE		7
#define CY_MEDIUM_SCROLL_THROTTLE   20

#define KEY_BACKSPACE			0x008
#define KEY_FLAG_EXTENDEDKEY	(1<<8)
#define KEY_FLAG_CONTEXTCODE	(1<<13)

#define CX_TIME_TEXT_INDENT  18
#define CX_CELL_EDIT_MARGIN 1
#define CY_CELL_EDIT_MARGIN 1

#define CY_HEADER 16
#define CY_BORDER_MERGE 0

#define DEFAULT_COLUMN 1


#define DX_HORZ_SCROLL 16	// Scroll 16 pixels at a time horizontally



//*****************************************************************
// CGridCore::CGridCore
//
// Constructor for the CGridCore class.
//
// General initialization is done.  The grid is initialized to
// no columns and no rows.
//
// I considered specifying an initial row and column count, but the
// columns need header strings, so I allow the user to call AddColumn,
// and AddRow after construction instead.
//
// Parameters:
//		None.
//****************************************************************
CGridCore::CGridCore() : m_aGridCell(0, 0)
{
	m_bUIActive = FALSE;

	m_edit.SetGrid(this);

	m_cxRowHandles = CX_SMALL_ROWHANDLE;
	m_ptOrigin.x = 0;
	m_ptOrigin.y = 0;

	m_nRowsClient = 0;
	m_nWholeRowsClient = 0;
	m_sizeMargin.cx = CX_CELL_MARGIN;
	m_sizeMargin.cy = CY_CELL_MARGIN;
	m_bDidInitialPaint = FALSE;
	m_bTrackingMouse = FALSE;
	m_bRunningScrollTimer = FALSE;
	m_iScrollDirection = TIMER_SCROLL_NONE;
	m_iScrollSpeed = STOP_SCROLL_MILLISECONDS;
	m_bIsScrolling = FALSE;

	m_cyFont = CY_FONT;
	m_nLineThickness = 1;

	GetViewerFont(m_font, m_cyFont, FW_NORMAL);

	m_bWasModified = FALSE;
	m_pParent = NULL;
	m_bNumberRows = FALSE;
	m_bShowEmptyCellAsText = TRUE;
}

CGridCore::~CGridCore()
{
	if (m_bRunningScrollTimer) {
		KillTimer(ID_TIMER_SCROLL);
	}
}


//*******************************************************************
// CGridCore::ExcludeRowHandlesRect
//
// Exclude the rectangle containing the row handles so that
// nothing draws over them.
//
// Parameters:
//		CDC* pdc
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::ExcludeRowHandlesRect(CDC* pdc)
{
	CRect rcRowHandles;
	GetRowHandlesRect(rcRowHandles);
	ClientToGrid(rcRowHandles);
	pdc->ExcludeClipRect(rcRowHandles);
}




//**********************************************************************
// CGridCore::DrawCell
//
// This method redraws the entire cell.
//
// Parameters:
//		int iRow
//			The row index of the cell.
//
//		int iCol
//			The column index of the cell.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CGridCore::DrawCell(int iRow, int iCol)
{
	if (!::IsWindow(m_hWnd)) {
		return;
	}

	CDC* pdc = GetDC();
	CPoint ptOrgTemp = m_ptOrigin;
	ptOrgTemp.x = - m_ptOrigin.x;
	ptOrgTemp.y = - m_ptOrigin.y;
	pdc->SetWindowOrg(ptOrgTemp);


	CFont* pOldFont;
	pOldFont = pdc->SelectObject(&m_font);
	ASSERT(pOldFont);

	ExcludeRowHandlesRect(pdc);
	DrawCellText(pdc, iRow, iCol);


	pdc->SelectObject(pOldFont);
	ReleaseDC(pdc);
}



//***********************************************************
// CGridCore::GetMaxValueWidth
//
// Measure the width of each cell in the specified column and
// return the maximum width.  This is used when the user
// double-clicks the divider in the grid header to resize the
// column so that the widest value is completely visible.
//
// Parameters:
//		[in] int iCol
//			The column width.
//
// Returns:
//		int
//			The width of the widest value in the column.
//
//************************************************************
int CGridCore::GetMaxValueWidth(int iCol)
{
	int nRows = GetRows();
	if (nRows <= 0) {
		return 0;
	}


	CDC* pdc = GetDC();
	CFont* pOldFont;
	pOldFont = pdc->SelectObject(&m_font);
	ASSERT(pOldFont);


	// Iterate through each of the rows searching for the widest cell value.
	CSize size;
	int cxMax = 0;
	for (int iRow = 0; iRow < nRows; ++iRow) {
		size = MeasureFullCellSize(pdc, iRow, iCol);
		if (size.cx > cxMax) {
			cxMax = size.cx;
		}
	}


	pdc->SelectObject(pOldFont);
	ReleaseDC(pdc);
	return cxMax;

}




//**********************************************************************
// CGridCore::MeasureFullCellSize
//
// Measure the cell text for a given cell.
//
// Parameters:
//		CDC* pdc
//			Pointer to the window's display context
//
//		int iRow
//			The row index of the cell.
//
//		int iCol
//			The column index of the cell.
//
// Returns:
//		Nothing.
//
//**********************************************************************
CSize CGridCore::MeasureFullCellSize(CDC* pdc, int iRow, int iCol)
{
	CSize size(0, 0);
	size.cx = 2 * CX_CELL_EDIT_MARGIN;
	size.cy = RowHeight();

	// Do nothing to draw a NULL cell
	if (IsNullCell(iRow, iCol)) {
		return size;
	}


	// Get a pointer to the cell to draw
	CGridCell* pCell = &m_aGridCell.GetAt(iRow, iCol);
	CString sValue;
	int nSize;


	CSize sizeTemp;
	CellType iType = pCell->GetType();
	switch(iType) {
	case CELLTYPE_CHECKBOX:
		size.cx += CX_PROPMARKER;
		size.cx += 1;
		return size;
		break;
	case CELLTYPE_PROPMARKER:
		size.cx += CX_PROPMARKER;
		size.cx += 1;
		return size;
		break;
	case CELLTYPE_VARIANT:
		if (pCell->IsNull()) {
			if (!m_bShowEmptyCellAsText) {
				return size;
			}
		}
		else {
			if (pCell->IsArray()) {
				size.cx += CX_ARRAY_PICTURE;
				size.cx += CX_EXTRA;
				return size;
				break;
			}

			CIMTYPE cimtype = pCell->GetCimtype();
			switch(cimtype) {
			case CIM_DATETIME:
				pCell->GetValue(sValue, cimtype);
				nSize = sValue.GetLength();
				sizeTemp = pdc->GetTextExtent( sValue, nSize);
				size.cx += sizeTemp.cx + CX_TIME_TEXT_INDENT;
				size.cx += CX_EXTRA;
				return size;
				break;
			case CIM_OBJECT:
				size.cx += CX_OBJECT_PICTURE;
				size.cx += CX_EXTRA;
				return size;
				break;
			}
		}
	}



	// Measure the size of the string.
	CIMTYPE cimtype;
	pCell->GetValue(sValue, cimtype);
	nSize = sValue.GetLength();
	CSize sizeText;
	sizeText  = pdc->GetTextExtent( sValue, nSize);
	size.cx += sizeText.cx;
	size.cx += CX_EXTRA;
	return size;
}






//*************************************************************
// CGridCore::ShowSelectionFrame
//
// Show or hide the cell selection frame depending on the bShow
// parameter.
//
// Parameters:
//		BOOL bShow
//			TRUE to show the selection frame, FALSE to hide it.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CGridCore::ShowSelectionFrame(BOOL bShow)
{
	if (!SomeCellIsSelected()) {
		return;
	}

	CDC* pdc = GetDC();
	CPoint ptOrgTemp = m_ptOrigin;
	ptOrgTemp.x = - m_ptOrigin.x;
	ptOrgTemp.y = - m_ptOrigin.y;
	pdc->SetWindowOrg(ptOrgTemp);

	CRect rcCell;
	GetCellRect(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol, rcCell);
	DrawSelectionFrame(pdc, rcCell, bShow);
	ReleaseDC(pdc);
}




//**********************************************************
// CGridCore::DrawSelectionFrame
//
// Draw the cell selection frame.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
//		CRect& rcFrame
//			The cell's selection fram rectangle.
//
//		BOOL bRemove
//			TRUE if this is a call to remove the selection frame.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::DrawSelectionFrame(CDC* pdc, CRect& rcFrame, BOOL bShow)
{
	ExcludeRowHandlesRect(pdc);


	CBrush* pbrSelection = CBrush::FromHandle(
					(HBRUSH)GetStockObject(bShow ? BLACK_BRUSH : WHITE_BRUSH));

	CBrush* pbrGridline = CBrush::FromHandle((HBRUSH)GetStockObject(LTGRAY_BRUSH));



	// The selection frame consists of an black rectangle one pixel outside
	// of the cell rectangle.  The outer rectangle is drawn so that it does
	// not over-draw the gridlines.  Also it is drawn so that there is a
	// chunk missing from the bottom-right corner so that it looks like Excel.

	CRect rc;
	if (!bShow && (rcFrame.left < 0)) {
		// For the portion of the selection frame that covers the face part of the
		// row handle, fill it with the 3DFACE color to remove the selection.

		CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
		// To hide the left edge when it appears over the row handle, draw the
		// left edge in the 3DFACE color.

		// Fill the dot at the top-left corner of the outer rectangle.
		rc.SetRect(rcFrame.left - 2, rcFrame.top - 2, rcFrame.left-1, rcFrame.top -1);
		pdc->FillRect(&rc, &br3DFACE);

		// Fill the line along the left side of the outer rectangle.
		rc.SetRect(rcFrame.left - 2, rcFrame.top, rcFrame.left - 1, rcFrame.bottom - 1);
		pdc->FillRect(&rc, &br3DFACE);
	}
	else {
		// Fill the dot at the top-left corner of the outer rectangle.
		rc.SetRect(rcFrame.left - 2, rcFrame.top - 2, rcFrame.left-1, rcFrame.top -1);
		pdc->FillRect(&rc, pbrSelection);

		// Fill the line along the left side of the outer rectangle.
		rc.SetRect(rcFrame.left - 2, rcFrame.top, rcFrame.left - 1, rcFrame.bottom - 1);
		pdc->FillRect(&rc, pbrSelection);
	}


	// Fill the dot at the bottom-left corner of the outer rectangle.
	rc.SetRect(rcFrame.left - 2, rcFrame.bottom, rcFrame.left - 1, rcFrame.bottom + 1);
	pdc->FillRect(&rc, pbrSelection);


	// Fill the line along the bottom side of the outer rectangle.
	rc.SetRect(rcFrame.left, rcFrame.bottom, rcFrame.right - 4, rcFrame.bottom + 1);
	pdc->FillRect(&rc, pbrSelection);


	// Fill the dot at the bottom-left corner of the square at the bottom-right corner of
	// of the outer frame.
	rc.SetRect(rcFrame.right - 3, rcFrame.bottom, rcFrame.right -1, rcFrame.bottom + 2);
	pdc->FillRect(&rc, pbrSelection);

	// Fill the dot at the bottom-right corner of the square at the bottom-right corner of the
	// outer frame.
	rc.SetRect(rcFrame.right, rcFrame.bottom, rcFrame.right+2, rcFrame.bottom + 2);
	pdc->FillRect(&rc, pbrSelection);


	// Fill the line along the top side of the outer rectangle
	rc.SetRect(rcFrame.left, rcFrame.top - 2, rcFrame.right-1, rcFrame.top -1);
	pdc->FillRect(&rc, pbrSelection);

	// Fill the dot at the top-right of the outer frame.
	rc.SetRect(rcFrame.right, rcFrame.top - 2, rcFrame.right+1, rcFrame.top -1);
	pdc->FillRect(&rc, pbrSelection);

	// Fill the vertical line along the right-size of the outer frame.
	rc.SetRect(rcFrame.right, rcFrame.top, rcFrame.right+1, rcFrame.bottom -4);
	pdc->FillRect(&rc, pbrSelection);

	// Fill the dot at the top-right corner of the little square at the bottom-right corner
	// of the outer frame.
	rc.SetRect(rcFrame.right, rcFrame.bottom - 3, rcFrame.right+2, rcFrame.bottom -1);
	pdc->FillRect(&rc, pbrSelection);



	//-----------------------------------------------------------
	// The outer frame is complete, now draw the inner frame.
	//-----------------------------------------------------------

	// Inner frame: horizontal line on top.
	rc.SetRect(rcFrame.left, rcFrame.top, rcFrame.right - 1, rcFrame.top + 1);
	pdc->FillRect(&rc, pbrSelection);

	// Inner frame: vertical line on left.
	rc.SetRect(rcFrame.left, rcFrame.top+1, rcFrame.left + 1, rcFrame.bottom - 1);
	pdc->FillRect(&rc, pbrSelection);

	// Inner frame: horizontal line on bottom.
	rc.SetRect(rcFrame.left + 1, rcFrame.bottom - 2, rcFrame. right - 4, rcFrame.bottom - 1);
	pdc->FillRect(&rc, pbrSelection);

	// Small square: top-left corner.
	rc.SetRect(rcFrame.right - 3, rcFrame.bottom - 3, rcFrame.right - 1, rcFrame.bottom - 1);
	pdc->FillRect(&rc, pbrSelection);


	// Inner frame: vertical line on right
	rc.SetRect(rcFrame.right - 2, rcFrame.top, rcFrame.right - 1, rcFrame.bottom - 4);
	pdc->FillRect(&rc, pbrSelection);

}


void CGridCore::DrawArrayPicture(
	CDC* pdc,
	CRect& rcCell,
	COLORREF clrForeground,
	COLORREF clrBackground,
	BOOL bHighlightCell
	)
{

	COLORREF clrArray = RGB(224, 224, 224);
	CBrush brArray(clrArray);
	CRect rcFillArray;
	rcFillArray = rcCell;
	rcFillArray.DeflateRect(2, 2);

	pdc->FillRect(rcFillArray, &brArray);
	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}

	CBitmap bm;
	BOOL bDidLoad;
	bDidLoad = bm.LoadBitmap(IDB_ARRAY);
	if (bDidLoad) {
		CSize size = bm.GetBitmapDimension();
		size.cx = 32;
		size.cy = 15;

		CPictureHolder pict;
		pict.CreateFromBitmap(&bm);
		CRect rcBitmap;
		rcBitmap.left = rcFillArray.left;;
		rcBitmap.right = rcBitmap.left + size.cx;
		rcBitmap.top = rcCell.top + (rcCell.Height() - size.cy) / 2;
		rcBitmap.bottom = rcBitmap.top + size.cy;
		pict.Render(pdc, rcBitmap, rcCell);
	}
}


void CGridCore::DrawObjectPicture(
	CDC* pdc,
	CRect& rcCell,
	COLORREF clrForeground,
	COLORREF clrBackground,
	BOOL bHighlightCell
	)
{
	COLORREF clrArray = RGB(224, 224, 224);
	CBrush brArray(clrArray);
	CRect rcFillArray;
	rcFillArray = rcCell;
	rcFillArray.DeflateRect(2, 2);

	pdc->FillRect(rcFillArray, &brArray);
	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}
	CBitmap bm;
	BOOL bDidLoad;
	bDidLoad = bm.LoadBitmap(IDB_OBJECT);
	if (bDidLoad) {
		CSize size = bm.GetBitmapDimension();
		size.cx = 34;
		size.cy = 15;

		CPictureHolder pict;
		pict.CreateFromBitmap(&bm);
		CRect rcBitmap;
		rcBitmap.left = rcFillArray.left;;
		rcBitmap.right = rcBitmap.left + size.cx;
		rcBitmap.top = rcCell.top + (rcCell.Height() - size.cy) / 2;
		rcBitmap.bottom = rcBitmap.top + size.cy;
		pict.Render(pdc, rcBitmap, rcCell);
	}
}

void CGridCore::DrawCheckboxPicture(
	CDC* pdc,
	CRect& rcCell,
	COLORREF clrForeground,
	COLORREF clrBackground,
	BOOL bHighlightCell,
	CGridCell* pgc
	)
{
	BOOL bChecked = pgc->GetCheck();

	COLORREF clrArray = RGB(224, 224, 224);
	CBrush brArray(clrArray);
	CRect rcFillArray;
	rcFillArray = rcCell;
	rcFillArray.DeflateRect(2, 2);


	CBrush br;
	CBrush* pbrWhite = br.FromHandle( (HBRUSH) GetStockObject(WHITE_BRUSH));
	pdc->FillRect(rcFillArray, pbrWhite);


	if (bChecked) {
		if (bHighlightCell) {
			bHighlightCell = FALSE;
			pdc->SetTextColor(clrForeground);
			pdc->SetBkColor(clrBackground);
		}

		CBitmap bm;
		BOOL bDidLoad;
		BOOL bModified = pgc->GetModified();
		UINT idBitmap;
		if (bModified) {
			idBitmap = IDB_CHECKBOX_MODIFIED;
		}
		else {
			idBitmap = IDB_CHECKBOX_UNMODIFIED;
		}

		bDidLoad = bm.LoadBitmap(idBitmap);
		if (bDidLoad) {
			CSize size = bm.GetBitmapDimension();
			size.cx = 11;
			size.cy = 9;

			CPictureHolder pict;
			pict.CreateFromBitmap(&bm);
			CRect rcBitmap;
			rcBitmap.left = rcFillArray.left;;
			rcBitmap.right = rcBitmap.left + size.cx;
			rcBitmap.top = rcCell.top + (rcCell.Height() - size.cy) / 2;
			rcBitmap.bottom = rcBitmap.top + size.cy;
			pict.Render(pdc, rcBitmap, rcCell);
		}
	}
}




//***************************************************************************
//

void CGridCore::DrawTime(
	CDC* pdc,
	CRect& rcCell,
	CRect& rcCellText,
	COLORREF clrForeground,
	COLORREF clrBackground,
	BOOL bHighlightCell,
	CGridCell* pgc
	)
{
	BOOL bChecked = pgc->GetCheck();

	COLORREF clrArray = RGB(224, 224, 224);
	CBrush brArray(clrArray);
	CRect rcFillArray;
	rcFillArray = rcCell;
	rcFillArray.DeflateRect(2, 2);


	CBrush br;
	CBrush* pbrWhite = br.FromHandle( (HBRUSH) GetStockObject(WHITE_BRUSH));
	pdc->FillRect(rcFillArray, pbrWhite);


	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}

	CBitmap bm;
	BOOL bDidLoad;
	BOOL bModified = pgc->GetModified();
	UINT idBitmap;
	idBitmap = IDB_TIMEHANDLE;

	bDidLoad = bm.LoadBitmap(idBitmap);
	if (bDidLoad) {
		CSize size = bm.GetBitmapDimension();
		size.cx = 15;
		size.cy = 15;

		CPictureHolder pict;
		pict.CreateFromBitmap(&bm);
		CRect rcBitmap;
		rcBitmap.left = rcFillArray.left;;
		rcBitmap.right = rcBitmap.left + size.cx;
		rcBitmap.top = rcCell.top + (rcCell.Height() - size.cy) / 2;
		rcBitmap.bottom = rcBitmap.top + size.cy;
		pict.Render(pdc, rcBitmap, rcCell);
	}

	if (bDidLoad) {
		rcCellText.left += CX_TIME_TEXT_INDENT;
	}


	// Get the cell's value and draw it.
	CString sValue;
	pgc->GetTimeString(sValue);
	pdc->ExtTextOut(rcCellText.left, rcCellText.top, ETO_CLIPPED, rcCellText, sValue, sValue.GetLength(), NULL);


	// If the cell was highlighted, restore the foreground and background colors
	// to their previous colors.
	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}
}



void CGridCore::DrawPropmarker(
	CDC* pdc,
	CRect& rcCell,
	COLORREF clrForeground,
	COLORREF clrBackground,
	BOOL bHighlightCell,
	CGridCell* pgc
	)
{
	if (pgc->GetType() != CELLTYPE_PROPMARKER) {
		ASSERT(FALSE);
		return;
	}



	// Place a 16 X 16 icon in the center of the cell;
	CRect rcIcon;
	rcIcon.top = (rcCell.top + rcCell.bottom) / 2 - 8;
	rcIcon.bottom = rcIcon.top + CY_PROPMARKER;
	rcIcon.left =  (rcCell.left + rcCell.right) / 2 - 8;
	rcIcon.right = rcIcon.left + CX_PROPMARKER;
	rcCell.DeflateRect(1, 1);


	BOOL bIconHasArea = rcIcon.IntersectRect(rcCell, rcIcon);
	if (!bIconHasArea) {
		return;
	}

	CSize size;
	size.cx = rcIcon.Width();
	size.cy = rcIcon.Height();


	CBrush br;
	CBrush* pbrWhite = br.FromHandle( (HBRUSH) GetStockObject(WHITE_BRUSH));
	pdc->FillRect(rcIcon, pbrWhite);



	PropMarker propmarker = pgc->GetPropmarker();

	WORD idiIcon;

	switch(propmarker) {
	case PROPMARKER_NONE:
		return;
		break;
	case PROPMARKER_INHERITED:
		idiIcon = IDI_MARKER_INHERITED;
		break;
	case PROPMARKER_KEY:
		idiIcon = IDI_MARKER_KEY;
		break;
	case PROPMARKER_LOCAL:
		idiIcon = IDI_MARKER_LOCAL;
		break;
	case PROPMARKER_RINHERITED:
		idiIcon = IDI_MARKER_RINHERITED;
		break;
	case PROPMARKER_RLOCAL:
		idiIcon = IDI_MARKER_RLOCAL;
		break;
	case PROPMARKER_RSYS:
		idiIcon = IDI_MARKER_RSYS;
		break;
	case PROPMARKER_SYS:
		idiIcon = IDI_MARKER_SYS;
		break;
	case METHODMARKER_IN:
		idiIcon = IDI_MARKER_METHIN;
		break;
	case METHODMARKER_INOUT:
		idiIcon = IDI_MARKER_METHINOUT;
		break;
	case METHODMARKER_OUT:
		idiIcon = IDI_MARKER_METHOUT;
		break;
	case METHODMARKER_RETURN:
		idiIcon = IDI_MARKER_METHRETURN;
		break;
	}



	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}

	BOOL bModified = pgc->GetModified();

	HICON hicon;
	hicon = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(idiIcon),  IMAGE_ICON, 0, 0, LR_SHARED);
	BOOL bNeedsClip = (rcIcon.Width() < 16) || (rcIcon.Height() < 16);
	if (bNeedsClip) {
		pdc->IntersectClipRect(&rcCell);
	}

	::DrawIconEx(pdc->m_hDC, rcIcon.left, rcIcon.top, hicon,
					16, 16,
					0,
					NULL,
					DI_NORMAL);

	if (bNeedsClip) {
		pdc->SelectClipRgn(NULL, RGN_COPY);
	}

}



//**********************************************************************
// CGridCore::DrawCellText
//
// Draw the cell text for a given cell.
//
// Parameters:
//		CDC* pdc
//			Pointer to the window's display context
//
//		int iRow
//			The row index of the cell.
//
//		int iCol
//			The column index of the cell.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CGridCore::DrawCellText(CDC* pdc, int iRow, int iCol)
{

	// Do nothing to draw a NULL cell
	if (IsNullCell(iRow, iCol)) {
		if (!EntireRowIsSelected(iRow)) {
			return;
		}
	}


	// Erase the old cell contents
	CRect rcCell;
	if (!GetCellRect(iRow, iCol, rcCell)) {
		// The cell isn't visible, so do nothing.
		return;
	}

	// Draw the cell frame
	if (IsSelectedCell(iRow, iCol)) {
		// If the cell editor is active, just redraw the cell editor
		if (m_edit.GetCell() != NULL) {
			if (m_edit.IsWindowVisible()) {
				m_edit.RedrawWindow();
				return;
			}
		}
	}

	rcCell.right -= 1;
	rcCell.bottom -= 1;


	// Get a pointer to the cell to draw
	CGridCell* pCell = &m_aGridCell.GetAt(iRow, iCol);


	// Select the foreground and background colors depending on the
	// characteristics of the cell being drawn.
	BOOL bHighlightCell = FALSE;
	COLORREF clrForeground = RGB(0, 0, 0);
	COLORREF clrBackground = RGB(255, 255, 255);

	CBrush brBackground(clrBackground);



	if (EntireRowIsSelected(iRow)) {
		bHighlightCell = TRUE;
		clrForeground = pdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
		clrBackground = pdc->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		CBrush brHighlight(GetSysColor(COLOR_HIGHLIGHT));
		pdc->FillRect(rcCell, &brHighlight);
	}
	else {
		pdc->FillRect(rcCell, &brBackground);
		if (pCell->GetModified()) {
			pdc->SetTextColor(COLOR_DIRTY_CELL_TEXT);
		}
		else {
			pdc->SetTextColor(COLOR_CLEAN_CELL_TEXT);
		}
		pdc->FillRect(rcCell, &brBackground);
	}


	// Get the rectangle that the text will be drawn into.
	CRect rcCellText;
	GetCellTextRect(iRow, iCol, rcCellText);

	BOOL bDrawValue = TRUE;
	BOOL bDone = FALSE;
	CellType iType = pCell->GetType();
	switch(iType) {
	case CELLTYPE_CHECKBOX:
		DrawCheckboxPicture(pdc, rcCell, clrForeground, clrBackground, bHighlightCell, pCell);
		bDone = TRUE;
		break;
	case CELLTYPE_PROPMARKER:
		DrawPropmarker(pdc, rcCell, clrForeground, clrBackground, bHighlightCell, pCell);
		bDone = TRUE;
		break;
	case CELLTYPE_VARIANT:

		if (pCell->IsNull()) {
			if (!m_bShowEmptyCellAsText) {
				bDrawValue = FALSE;
			}
		}
		else {
			if (pCell->IsArray()) {
				DrawArrayPicture(pdc, rcCell, clrForeground, clrBackground, bHighlightCell);
				bDone = TRUE;
				break;
			}

			CIMTYPE cimtype = pCell->GetCimtype();
			switch(cimtype) {
			case CIM_DATETIME:
				DrawTime(pdc, rcCell, rcCellText, clrForeground, clrBackground, bHighlightCell, pCell);
				bDone = TRUE;
				break;
			case CIM_OBJECT:
				DrawObjectPicture(pdc, rcCell, clrForeground, clrBackground, bHighlightCell);
				bDone = TRUE;
				break;
			}
		}
	}

	if (bDone) {
		// If the cell was highlighted, restore the foreground and background colors
		// to their previous colors.
		if (bHighlightCell) {
			bHighlightCell = FALSE;
			pdc->SetTextColor(clrForeground);
			pdc->SetBkColor(clrBackground);
		}
		return;
	}




	// Get the cell's value and draw it.
	if (bDrawValue) {
		CString sValue;
		CIMTYPE cimtype;
		pCell->GetValue(sValue, cimtype);
		pdc->ExtTextOut(rcCellText.left, rcCellText.top, ETO_CLIPPED, rcCellText, sValue, sValue.GetLength(), NULL);
	}


	// If the cell was highlighted, restore the foreground and background colors
	// to their previous colors.
	if (bHighlightCell) {
		bHighlightCell = FALSE;
		pdc->SetTextColor(clrForeground);
		pdc->SetBkColor(clrBackground);
	}
}

//**********************************************************
// CGridCore::InsertColumnAt
//
// Append a new column to the grid.
//
// Parameters:
//		int iWidth
//			The width of the column in client coordinates
//
//		LPCTSTR pszTitle
//			Pointer to a string containing the column's title.
//
//
// Returns:
//		Nothing.
//***********************************************************
void CGridCore::AddColumn(int iWidth, LPCTSTR pszTitle)
{
	InsertColumnAt(GetCols(), iWidth, pszTitle);
	UpdateScrollRanges();
}



//************************************************************
// CGridCore::AddRow
//
// Add an empty row to the grid.
//
// Parameters:
//		None.
//
// Returns:
//		The index of the new row.
//
//************************************************************
int CGridCore::AddRow()
{
	int iRow = GetRows();
	InsertRowAt(m_aGridCell.GetRows());
	return iRow;
}




//************************************************************
// CGridCore::InsertRowAt
//
// Insert an empty row to the grid.
//
// Parameters:
//		int iRow
//			The place to insert the row (this will be the index of
//			the new row).
//
// Returns:
//		The index of the new row.
//
//************************************************************
void CGridCore::InsertRowAt(int iRow)
{
	m_aGridCell.InsertRowAt(iRow);
	UpdateRowHandleWidth();
	UpdateScrollRanges();
}





//***********************************************************
// CGridCore::DeleteRowAt
//
// Remove the specified row in the grid.
//
// Parameters:
//		[in] int iRow
//			The index of the row to delete.
//
//		[in] BOOL bUpdateWindow
//			TRUE if the window should be updated.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::DeleteRowAt(int iRow, BOOL bUpdateWindow)
{
	ASSERT(iRow < GetRows());

	BOOL bEntireRowWasSelected = EntireRowIsSelected();
	BOOL bDeletedCurrentRow = (iRow == m_aGridCell.m_iSelectedRow);
	if (bDeletedCurrentRow) {
		EndCellEditing();
	}

	if (m_aGridCell.m_iSelectedRow == iRow) {
		m_aGridCell.m_iSelectedRow = NULL_INDEX;
	}
	m_aGridCell.DeleteRowAt(iRow);

	if (bDeletedCurrentRow) {
		int nRows = GetRows();
		int iRowSelect = iRow;
		if ((nRows == 0) || !bEntireRowWasSelected) {
			iRowSelect = NULL_INDEX;
		}
		else if (iRow >= nRows) {
			iRowSelect = nRows - 1;
		}
		else {
			iRowSelect = iRow;
		}

        SetModified(true);
		SelectRow(iRowSelect);
	}
	UpdateEditorPosition();
	if (bUpdateWindow) {
		RedrawWindow();
	}
}




//*********************************************************
// CGridCore::InsertColumnAt
//
// Insert a new column such that the new column's index
// after the insertion is the specified column index.
//
// Parameters:
//		int iCol
//			The index where the new column is to be inserted
//
//		int iWidth
//			The width of the column in client coordinates.
//
//		LPCTSTR pszTitle
//			Pointer to a string containing the column's title.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridCore::InsertColumnAt(int iCol, int iWidth, LPCTSTR pszTitle)
{
	m_aGridCell.InsertColumnAt(iCol);
	m_aiColWidths.SetAtGrow(iCol, iWidth);
	m_adwColTags.SetAtGrow(iCol, 0);
	m_asColTitles.SetAtGrow(iCol, pszTitle);
}




//*********************************************************
// CGridCore::SetColumnWidth
//
// Change the width of an existing column.  This may make it
// necesary to redraw the window.
//
// Parameters:
//		int iCol
//			The index of the column to change.
//
//		int cx
//			The new width of the column in client coordinates.
//
//		BOOL bRedraw
//			TRUE if the window should be redrawn.  A value of
//			FALSE allows multiple columns to be changed without
//			any intervening redraws.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CGridCore::SetColumnWidth(int iCol, int cx, BOOL bRedraw)
{
	ASSERT(cx > 0);
	if (m_aiColWidths[iCol] != (DWORD)cx) {
		m_aiColWidths[iCol] = cx;
		// The cell editor will have to be moved if it to the right of the
		// specified column.
		if (m_aGridCell.m_iSelectedRow != NULL_INDEX) {
			if (iCol <= m_aGridCell.m_iSelectedCol) {
				UpdateEditorPosition();
			}
		}

		UpdateScrollRanges();

		if (bRedraw) {
			RedrawWindow();
		}

	}
}




//******************************************************************
// CGridCore::NotifyCellModifyChange
//
// This method is called when an event occurs that results in the
// contents of a cell being modified.  This event is passed on
// to any clients that may be interested in the event.
//
// See "notify.h" and "notify.cpp" to understand how to become a
// client.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::NotifyCellModifyChange()
{
	m_pParent->OnCellContentChange(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);

#if 0
	CDistributeEvent* pNotify = m_pParent->GetNotify();
	if (pNotify != NULL) {
		pNotify->SendEvent(NOTIFY_GRID_MODIFICATION_CHANGE);
	}
#endif //0
}





//*******************************************************************
// CGridCore::SetParent
//
// This method must be called from the CGrid constructor after the CGridCore
// object is created.
//
// Parameters:
//		CGrid* pGrid
//			Pointer to the grid.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::SetParent(CGrid* pGrid)
{
	m_pParent = pGrid;
	m_aGridCell.SetGrid(pGrid);
}



//*******************************************************************
// CGridCore::Create
//
// Create the CGridCore window.
//
// Parameters:
//		CRect& rc
//			The rectangle in the parent's client area that this window
//			should occupy.
//
//		UINT nId
//			The window id.
//
//		BOOL bVisible
//			TRUE if the grid window should be initially visible.
//
// Returns:
//		BOOL
//			TRUE if the grid window was created successfully.
//
//********************************************************************
BOOL CGridCore::Create(CRect& rc, UINT nId, BOOL bVisible)
{

	DWORD dwStyle = WS_VSCROLL | WS_HSCROLL | WS_CHILD | WS_CLIPCHILDREN;

	if (bVisible) {
		dwStyle |= WS_VISIBLE;
	}


	BOOL bDidCreate = CWnd::Create(NULL, _T("CGridCore"), dwStyle, rc, (CWnd*) m_pParent, nId);
	if (!bDidCreate) {
		return FALSE;
	}

	UpdateScrollRanges();
	UpdateRowHandleWidth();
	return bDidCreate;
}


BEGIN_MESSAGE_MAP(CGridCore, CWnd)
	//{{AFX_MSG_MAP(CGridCore)
	ON_WM_VSCROLL()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_TIMER()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SHOWWINDOW()
	ON_WM_RBUTTONDOWN()
	ON_WM_HSCROLL()
	ON_WM_ERASEBKGND()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGridCore message handlers

//*************************************************************
// CGridCore::CalcVisibleCells
//
// Calculate the indexes of the cells that are visible within
// the clip rectangle.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
//		int& iColLeft
//			The index of the first column visible at the left of the clipbox.
//
//		int& iRowTop
//			The index of the first row visible at the top of the clipbox.
//
//		int iColRight
//			The index of the last column visible at the right of the clipbox.
//
//		int iRowBottom
//			The index of the last row visible at the bottom of the clipbox.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CGridCore::CalcVisibleCells(CDC* pdc,
								int& iColLeft,
								int& iRowTop,
								int& iColRight,
								int& iRowBottom)
{


	CRect rcClip;
//	pdc->GetClipBox(rcClip);
	GetVisibleRect(rcClip);


	int cyRow = RowHeight();
	iRowTop = rcClip.top / cyRow;
	iRowBottom = (rcClip.bottom + cyRow - 1) / cyRow;


	iColLeft = 0;
	iColRight = 0;
	int nCols = GetCols();

	// Starting at column zero scan through the columns from left to
	// right to determine which columns are visible.
	int ix = 0;
	for (int iCol = 0; iCol < nCols; ++iCol) {
		int cxCol = ColWidth(iCol);
		// Is this the first column visible on the left?
		if ((iColLeft==0) && (ix + cxCol > rcClip.left)) {
			iColLeft = iCol;
		}

		// Is this the last column visible on the right?
		if (ix + cxCol > rcClip.right) {
			iColRight = iCol;
			break;
		}
		ix += cxCol;
	}

	// Bound the column and row indexes by the actual number of columns
	// and rows.
	if (iColRight > GetCols()) {
		iColRight = GetCols();
	}

	if (iRowBottom > GetRows()) {
		iRowBottom = GetRows();
	}
}





//***************************************************************
// CGridCore::ExcludeHiddenRows
//
// Adjust the row starting index and count to exclude hidden rows
// so that they aren't drawn.
//
// Parameters:
//		int& iStartRow
//			The index of the first row being drawn.
//
//		int& nRows
//			The number of rows being drawn.
//
//	Returns:
//		Nothing
//
//*****************************************************************
void CGridCore::ExcludeHiddenRows(CDC* pdc, int& iStartRow, int& nRows)
{
	if (nRows <= 0) {
		return;
	}

	int iColVisibleLeft, iRowVisibleTop, iColVisibleRight, iRowVisibleBottom;

	CalcVisibleCells(pdc, iColVisibleLeft,
						  iRowVisibleTop,
						  iColVisibleRight,
						  iRowVisibleBottom);


	if (iRowVisibleTop > iStartRow) {
		nRows = nRows - (iRowVisibleTop - iStartRow);
		if (nRows <= 0) {
			nRows = 0;
			return;
		}
		iStartRow = iRowVisibleTop;
	}

	ASSERT(nRows > 0);
	if ((iStartRow + nRows-1) > (iRowVisibleBottom)) {
		nRows = nRows - ((iStartRow + nRows - 1) - iRowVisibleBottom);
		if (nRows < 0) {
			nRows = 0;
		}
	}
}

//*********************************************************
// CGridCore::DrawRows
//
// Draw the specified rows and (optionally) the grid.
//
// Parameters:
//		CDC* pdc
//			Pointer to the device context
//
//		int iStartRow
//			The zero-based index of the row to start drawing at.
//
//		int nRows
//			The number of rows to draw.
//
//		BOOL bDrawGrid
//			TRUE if the grid lines should be drawn, FALSE otherwise.
//
//***********************************************************
void CGridCore::DrawRows(CDC* pdc, int iStartRow, int nRows, BOOL bDrawGrid)
{

	ExcludeHiddenRows(pdc, iStartRow, nRows);
	if (nRows == 0) {
		return;
	}


	if (bDrawGrid) {
		DrawGrid(pdc, iStartRow, nRows);
	}



	int iRow = iStartRow;
	int nColsGrid = m_aGridCell.GetCols();
	while (--nRows >= 0) {
		for (int iCol = 0; iCol < nColsGrid; ++iCol) {
			DrawCellText(pdc, iRow, iCol);
		}
		++iRow;
	}
}




//************************************************************************
// CGridCore::DrawRowHandle
//
// Draw a row handle on the left side of the grid.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
//		CRect& rcHandle
//			The rectangle to draw the row handle in.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CGridCore::DrawRowHandle(CDC* pdc, CRect& rcHandle)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	// If the handle is empty, draw nothing.
	if ((rcHandle.Width() <=0) || (rcHandle.Height() <= 0)) {
		return;
	}
	CRect rcFill;


	// The top edge
	rcFill.left = rcHandle.left;
	rcFill.top = rcHandle.top;
	rcFill.bottom = rcHandle.top + 1;
	rcFill.right = rcHandle.right - 1;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));

	// The right edge
	rcFill.left = rcHandle.right - 1;
	rcFill.bottom = rcHandle.bottom - 1;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));

	// The bottom edge
	rcFill.top = rcHandle.bottom - 1;
	rcFill.left = rcHandle.left;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));

	// If the row handle is so small that you only see the black border then return now.
	if ((rcHandle.Width() < 3) || (rcHandle.Height() < 3)) {
		return;
	}

	// Draw one pixel of highlight on the left edge
	rcFill.left = rcHandle.left;
	rcFill.right = rcHandle.left + 1;
	rcFill.top = rcFill.top + 1;
	rcFill.bottom = rcFill.bottom - 1;
	pdc->FillRect(rcFill, &br3DHILIGHT);

	// Draw one pixel of highlight on the top edge.
	rcFill.left = rcHandle.left;
	rcFill.right = rcHandle.right -1;
	rcFill.top = rcFill.top + 1;
	rcFill.bottom = rcFill.top + 2;
	pdc->FillRect(rcFill, &br3DHILIGHT);


	// If the handle is too small to show any face color then return now.
	if ((rcHandle.Width() < 4) || (rcHandle.Height() < 4)) {
		return;
	}
	rcFill.left = rcHandle.left + 1;
	rcFill.right = rcHandle.right - 2;
	rcFill.top = rcHandle.top + 2;
	rcFill.bottom = rcHandle.bottom;
	pdc->FillRect(rcFill, &br3DFACE);



}





//***********************************************************
// CGridCore::GetRowHandlesRect
//
// Get the rectangle that contains the row handles in client
// coordinates.
//
// Parameters:
//		CRect& rc
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::GetRowHandlesRect(CRect& rc)
{
	CRect rcClient;
	GetClientRect(rcClient);
	rc.left = 0;
	rc.right = m_cxRowHandles;
	rc.top = 0;
	rc.bottom = rcClient.bottom;
}





//**********************************************************
// CGridCore::DrawGrid
//
// Draw the grid lines that delimit the boundaries of each
// cell.
//
// Parameters:
//		CDC* pdc
//			Pointer to the device context to draw into
//
//		int iStartRow
//			The row index to start drawing at.
//
//		int nRows
//			The number of rows to draw.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CGridCore::DrawGrid(CDC* pdc, int iStartRow, int nRows)
{
	int cyRow = RowHeight();
	CRect rc;


	CRect rcClip;
	pdc->GetClipBox(rcClip);

	// Draw the horizontal grid line at the bottom of the row. Note that this
	// code assumes that it isn't necessary to draw the line at the top of the
	// row because it overlaps the bottom of the previous row.
	rc.top = (iStartRow + 1) * cyRow - 1;
	rc.bottom = rc.top + 1;
	rc.left = rcClip.left;
	rc.right = rcClip.right;

	for (int i=0; i< nRows; ++i) {

		pdc->FillRect(rc, CBrush::FromHandle((HBRUSH)GetStockObject(LTGRAY_BRUSH)));

		rc.top += cyRow;
		rc.bottom += cyRow;

	}



	// Draw the vertical grid lines that separate the columns
	rc.top = iStartRow * cyRow - 1;
	rc.bottom = rc.top + nRows * cyRow + 1;
	rc.left = -1;
	rc.right = 0;


	int nCols = m_aGridCell.GetCols();
	for (i=0; i< nCols; ++i) {
		rc.left += m_aiColWidths[i];
		rc.right += m_aiColWidths[i];
		pdc->FillRect(rc, CBrush::FromHandle((HBRUSH)GetStockObject(LTGRAY_BRUSH)));
	}
}


//******************************************************
// CGridCore::GetCellRect
//
// Get the bounding rectangle for the specified grid cell.
//
// Parameters:
//		int iRow
//			The grid cell's row index.
//
//		int iCol
//			The grid cell's column index
//
//		CRect& rc
//			A reference to the place to return the specified
//			cell's bounding rectangle.
//
// Returns:
//		BOOL
//			TRUE if the cell is at least partially visible in the
//			client rectangle. FALSE if it falls completely outside
//			of the client rectangle.
//
//*********************************************************
BOOL CGridCore::GetCellRect(int iRow, int iCol, CRect& rc)
{
	ASSERT(iRow>=0 && iRow < m_aGridCell.GetRows());
	ASSERT(iCol>=0 && iCol < m_aGridCell.GetCols());
	ASSERT(m_aGridCell.GetCols() == m_aiColWidths.GetSize());

	int cyRow = RowHeight();
	rc.top = iRow * cyRow;;
	rc.left =  0;
	rc.left = GetColPos(iCol);
	rc.bottom = rc.top + cyRow;
	rc.right = rc.left + m_aiColWidths[iCol];

	BOOL bNotEmpty;
#if 0
///////////////////////////
	CRect rcClient;
	GetClientRect(rcClient);

	CRect rcCell;
	rcCell = rc;
	GridToClient(rcCell);

	CRect rcIntersect;
	bNotEmpty = rcIntersect.IntersectRect(rcCell, rcClient);



	CRect rcVis1;
	GetClientRect(rcVis1);
	ClientToGrid(rcVis1);

	GridToClient(rcVis1);

///////////////////
#endif //0

	// Check to see if the cell is visible
	CRect rcVisible;
	GetVisibleRect(rcVisible);
	bNotEmpty = rcVisible.IntersectRect(rcVisible, rc);
	return bNotEmpty;
}


//**************************************************************
// CGridCore::GetColPos
//
// Get the horizontal coordinate of the left edge of the column.
//
// Parameters:
//		int iCol
//			The index of the column.
//
// Returns:
//		Nothing.
//
//*************************************************************
BOOL CGridCore::GetColPos(int iCol)
{
	int ixCol = 0;
	for (int i =0; i < iCol; ++i) {
		ixCol += m_aiColWidths[i];
	}
	return ixCol;
}


//*****************************************************
// CGridCore::GetCellTextRect
//
// Get the rectangle that bounds the area occupied by the
// cell's text.
//
// Parameters:
//		int iRow
//			The cell's row index.
//
//		int iCol
//			The cell's column index.
//
//		CRect& rc
//			The place to return the bounding rectangle for
//			the specified cell's text.
//
// Returns:
//		TRUE if any portion of the cell is visible.
//		The cell's text rectangle by reference.
//
//*******************************************************
BOOL CGridCore::GetCellTextRect(int iRow, int iCol, CRect& rc)
{
	ASSERT(iRow>=0 && iRow < m_aGridCell.GetRows());
	ASSERT(iCol>=0 && iCol < m_aGridCell.GetCols());

	BOOL bCellVisible = GetCellRect(iRow, iCol, rc);
	rc.top += m_sizeMargin.cy;
	rc.bottom -= m_sizeMargin.cy;
	rc.left += m_sizeMargin.cx;
	rc.right -= m_sizeMargin.cx;
	return bCellVisible;
}

//*****************************************************
// CGridCore::GetCellEditRect
//
// Get the rectangle that bounds the area occupied by the
// cell's editor.  This rectangle is inset one pixel from
// the cell's frame rectangle.
//
// Parameters:
//		int iRow
//			The cell's row index.
//
//		int iCol
//			The cell's column index.
//
//		CRect& rc
//			The place to return the bounding rectangle for
//			the specified cell's text.
//
// Returns:
//		TRUE if any portion of the cell is visible.
//		The cell's text rectangle by reference.
//
//*******************************************************
BOOL CGridCore::GetCellEditRect(int iRow, int iCol, CRect& rc)
{
	ASSERT(iRow>=0 && iRow < m_aGridCell.GetRows());
	ASSERT(iCol>=0 && iCol < m_aGridCell.GetCols());

	BOOL bCellVisible = GetCellRect(iRow, iCol, rc);
	rc.left = rc.left + CX_CELL_EDIT_MARGIN;
	rc.right = rc.right - CX_CELL_EDIT_MARGIN;
	rc.top = rc.top + CY_CELL_EDIT_MARGIN;
	rc.bottom = rc.bottom - CY_CELL_EDIT_MARGIN;

	return bCellVisible;
}




//***************************************************************
// CGridCore::RefreshCellEditor
//
// This method reloads the cell editor with the contents of the
// current cell.  This is necessary to keep the cell editor's
// contents in sync with the cell in the event that the cell's
// contents change through any means other than the user interacting
// with the cell editor.
//
// Parameters: None.
//
// Returns: Nothing.
//
//***************************************************************
void CGridCore::RefreshCellEditor()
{
	if ((m_aGridCell.m_iSelectedRow != NULL_INDEX) &&
		(m_aGridCell.m_iSelectedCol != NULL_INDEX)) {
		m_edit.SetCell(&GetAt(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol),
			m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
	}
}



//***************************************************************
// CGridCore::SyncCellEditor
//
// This method checks to see if the current cell has been modified
// in the cell editor.  If it has, then it copies the contents of
// the cell editor to the current cell.
//
// Parameters: None.
//
// Returns:
//		SCODE
//			S_OK if the value could be synced, a failure code if
//			the cell editor contained a value that could not be
//			copied to the cell.
//
//***************************************************************
SCODE CGridCore::SyncCellEditor()
{
	SCODE sc = S_OK;

	if (m_edit.GetCell()) {
		if (m_edit.GetModify()) {
			CGridCell* pGridCell = SelectedCell();
			ASSERT(pGridCell == m_edit.GetCell());

			if (m_edit.IsNull()) {
				pGridCell->SetToNull();
			}
			else {
				CString sValue;
				m_edit.GetWindowText(sValue);

				const CGcType& type = pGridCell->type();
				CIMTYPE cimtype = (CIMTYPE) type;
				CellType celltype = (CellType) type;
				if ((celltype == CELLTYPE_VARIANT) || (celltype == CELLTYPE_CIMTYPE_SCALAR)) {
					if (!::IsValidValue(cimtype, sValue, FALSE)) {
						return E_FAIL;
					}
				}

				sc = pGridCell->SetValue(pGridCell->GetType(), sValue, cimtype);
				if (FAILED(sc)) {
					return sc;
				}
				pGridCell->SetModified(TRUE);
			}
			m_bWasModified = TRUE;
		}
	}
	return sc;
}




//****************************************************************
// CGridCore::SetModified
//
// Set the modified flag for this CGridCore object.
//
// Parameters:
//		BOOL bWasModified
//			TRUE if a cell anywhere within the grid was modified.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CGridCore::SetModified(BOOL bWasModified)
{
	m_bWasModified = bWasModified;

	int nRows = GetRows();
	int nCols = GetCols();
	if (!bWasModified) {
		CGridRow* pRow;
		for (int iRow =0; iRow < nRows; ++iRow) {
			pRow = &GetRowAt(iRow);
			pRow->SetModified(FALSE);
		}
		if (::IsWindow(m_edit.m_hWnd)) {
			m_edit.SetModify(FALSE);
		}
	}
}



//****************************************************************
// CGridCore::SetCellModified
//
// Mark an individual cell as being clean or dirty.
//
// Parameters:
//		int iRow
//			The cell's row index.
//
//		int iCol
//			The cell's column index.
//
//		BOOL bWasModified
//			TRUE to mark the cell as "dirty".
//			FALSE to mark the cell as "clean".
//
// Returns:
//		Nothing.
//
//****************************************************************
void CGridCore::SetCellModified(int iRow, int iCol, BOOL bWasModified)
{
	CGridCell* pCell = &GetAt(iRow, iCol);
	ASSERT(pCell != NULL);

	pCell->SetModified(bWasModified);
	if ((m_aGridCell.m_iSelectedRow == iRow) &&
		(iCol==m_aGridCell.m_iSelectedCol)) {
		m_edit.SetModify(bWasModified);
		m_edit.RedrawWindow();
	}
}


//***********************************************************
// CGridCore::OnBeginSort
//
// Call this method prior to beginning a sort of the grid.  This
// hides the cell editor and returns the index of the currently
// selected row.  The caller should update the current row index
// if that row is moved during the sort and pass it back in to
// CGridCore::OnEndSort so that the cell editor's position can
// be updated and the selected row index is also updated.
//
// Parameters:
//		[out] int& nEditStartSel
//			The start of the cell editor's selection.
//
//		[out] int& nEditEndSel
//			The end of the cell editor's selection.
//
//
// Returns:
//		int
//			The index of the currently selected row, NULL_INDEX
//			if no row is selected.
//
//***********************************************************
int CGridCore::OnBeginSort(int& nEditStartSel, int& nEditEndSel)
{
	SyncCellEditor();
	if (IsEditingCell()) {
		m_edit.GetSel(nEditStartSel, nEditEndSel);
		m_edit.ShowWindow(SW_HIDE);
	}
	return m_aGridCell.m_iSelectedRow;
}



//***********************************************************
// CGridCore::OnEndSort
//
// Call this method after a sort on the grid is completed.  The
// index of the currently selected row is passed in.  This index
// should have been updated if the current row was moved.
//
// Parameters:
//		[in] int iSelectedRow
//			The index of the selected row.  This index should have
//			been updated prior to calling this method if the
//			currently selected row was moved.
//
//		[in] int nEditStartSel
//			The start of the cell editor's selection.
//
//		[in] int nEditEndSel
//			The end of the cell editor's selection.
// Returns:
//		Nothing.
//
//***********************************************************
void CGridCore::OnEndSort(int iSelectedRow, int nEditStartSel, int nEditEndSel)
{
	m_aGridCell.m_iSelectedRow = iSelectedRow;
	if (::IsWindow(m_hWnd)) {
		if (iSelectedRow != NULL_INDEX) {
			EnsureRowVisible(iSelectedRow);
		}
	}

	if (m_aGridCell.m_iSelectedRow != NULL_INDEX) {
		if (IsEditingCell()) {
			UpdateEditorPosition();
			m_edit.ShowWindow(SW_SHOW);
			m_edit.SetFocus();
			m_edit.SetSel(nEditStartSel, nEditEndSel);
		}
	}
}


//***************************************************************
// CGridCore::OnHScroll
//
// Handle the horizontal scroll message.
//
// Parameters:
//		See the MFC documentation
//
// Returns:
//		Nothing.
//
//***************************************************************
void CGridCore::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	int nCurPos = GetScrollPos(SB_HORZ);
	int nMinPos, nMaxPos;
	GetScrollRange(SB_HORZ, &nMinPos, &nMaxPos);

	CRect rcClient;

	// To improve the scrolling appearance and performance, the cell editing window
	// is hidden while the scroll is in progress.
	if (nSBCode != SB_ENDSCROLL) {
		if (!m_bIsScrolling) {
			m_bIsScrolling = TRUE;
			SyncCellEditor();
			if (IsEditingCell()) {
				m_edit.ShowWindow(SW_HIDE);
				DrawCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
			}
		}
	}

	CRect rcCellEdit;
	int iNewPos;		// The new scroll position
	int cxAvailable;

	switch(nSBCode) {
	case SB_RIGHT:
		iNewPos = nMaxPos;
		break;
	case SB_LEFT:
		iNewPos = 0;
		break;
	case SB_LINELEFT:
		iNewPos = (nCurPos > nMinPos) ? nCurPos - 1 : nMinPos;
		break;
	case SB_LINERIGHT:
		iNewPos = (nCurPos < nMaxPos) ? nCurPos + 1 : nMaxPos;
		break;
	case SB_PAGELEFT:
		GetClientRect(rcClient);
		iNewPos = nCurPos;
		cxAvailable = rcClient.Width() - m_cxRowHandles;

		while (iNewPos > 0) {
			cxAvailable -= ColWidth(iNewPos);
			if (cxAvailable < 0) {
				break;
			}
			--iNewPos;
		}
		if (iNewPos == nCurPos) {
			--iNewPos;
		}
		if (iNewPos <= 0) {
			iNewPos = 0;
		}
		break;
	case SB_PAGERIGHT:
		GetClientRect(rcClient);
		iNewPos = nCurPos;
		cxAvailable = rcClient.Width() - m_cxRowHandles;
		while (iNewPos <= nMaxPos) {
			cxAvailable -= ColWidth(iNewPos);
			if (cxAvailable < 0) {
				break;
			}
			++iNewPos;
		}
		if (iNewPos == nCurPos) {
			++iNewPos;
		}
		if (iNewPos > nMaxPos) {
			iNewPos = nMaxPos;
		}
		break;
	case SB_ENDSCROLL:
		if (m_aGridCell.m_iSelectedRow != NULL_INDEX) {
			if (IsEditingCell()) {
				UpdateEditorPosition();
				m_edit.ShowWindow(SW_SHOW);
			}
		}
		m_bIsScrolling = FALSE;
		return;
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iNewPos = nPos;
		break;
	default:
		ASSERT(FALSE);
		iNewPos = nCurPos;
		return;
	}


	ScrollGrid(SB_HORZ, iNewPos);
}


//***************************************************************
// CGridCore::OnVScroll
//
// Handle the vertical scroll message.
//
// Parameters:
//		See the MFC documentation
//
// Returns:
//		Nothing.
//
//***************************************************************
void CGridCore::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{

	// Get the 32 bit values.
	SCROLLINFO si;
	int nCurPos;
	if (GetScrollInfo(SB_VERT, &si)) {
		nCurPos = si.nPos;
		switch(nSBCode) {
		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			nPos = si.nTrackPos;
			break;
		}
	}
	else {
		ASSERT(FALSE);
		nCurPos = GetScrollPos(SB_VERT);
	}

	int nMinPos, nMaxPos;
	GetScrollRange(SB_VERT, &nMinPos, &nMaxPos);



	// To improve the scrolling appearance and performance, the cell editing window
	// is hidden while the scroll is in progress.
	if (nSBCode != SB_ENDSCROLL) {
		if (!m_bIsScrolling) {
			m_bIsScrolling = TRUE;
			SyncCellEditor();
			if (IsEditingCell()) {
				m_edit.ShowWindow(SW_HIDE);
				DrawCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
			}
		}
	}

	int iNewPos;		// The new scroll position

	switch(nSBCode) {
	case SB_BOTTOM:
		iNewPos = nMaxPos;
		break;
	case SB_ENDSCROLL:
		if (m_aGridCell.m_iSelectedRow != NULL_INDEX) {
			if (IsEditingCell()) {
				UpdateEditorPosition();
				m_edit.ShowWindow(SW_SHOW);
			}
		}
		m_bIsScrolling = FALSE;
		return;
		break;
	case SB_LINEDOWN:
		iNewPos = (nCurPos < nMaxPos) ? nCurPos + 1 : nMaxPos;
		break;
	case SB_LINEUP:
		iNewPos = (nCurPos > nMinPos) ? nCurPos - 1 : nMinPos;
		break;
	case SB_PAGEDOWN:
		if ((nCurPos + m_nWholeRowsClient - 1) < nMaxPos) {
			iNewPos = nCurPos + m_nWholeRowsClient - 1;
		}
		else {
			iNewPos = nMaxPos;
		}
		break;
	case SB_PAGEUP:
		if (nCurPos - (m_nWholeRowsClient - 1) > nMinPos) {
			iNewPos = nCurPos - m_nWholeRowsClient;
		}
		else {
			iNewPos = nMinPos;
		}
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iNewPos = nPos;
		break;
	case SB_TOP:
		iNewPos = nMinPos;
		break;
	default:
		ASSERT(FALSE);
		iNewPos = nCurPos;
		return;
	}

	ScrollGrid(SB_VERT, iNewPos);

}





//********************************************************************
// CGridCore::DrawRowhandles
//
// Draw the row handles along the left side of the grid.
//
// Parameters:
//		[in] CDC* pdc
//			Pointer to the display context.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::DrawRowHandles(CDC* pdc)
{

	// If there are no row handles, do nothing.
	int cxHandle = m_cxRowHandles;
	if (cxHandle <= 0) {
		return;
	}

	// If the row doesn't have a height, do nothing.
	int cyRow = RowHeight();
	if (cyRow <= 0) {
		return;
	}


	CRect rcClient;
	GetClientRect(rcClient);



	CRect rcRowHandles;
	GetClientRect(rcRowHandles);
	rcRowHandles.top += rcClient.top;
	rcRowHandles.right = m_cxRowHandles;
	rcRowHandles.bottom = rcRowHandles.top + rcClient.Height();


	// If the row handles are completely clipped out, then do nothing.
	CRect rcPaint;
	if (pdc->GetClipBox(rcPaint) != NULLREGION  ) {
		// The top and bottom of the paint rectangle need to be aligned with the top and
		// bottom edges of partially obscured row handles.
		rcPaint.top = (rcPaint.top  / cyRow) * cyRow;
		rcPaint.bottom = (rcPaint.bottom + (cyRow - 1))/cyRow * cyRow ;
	}
	else {
		rcPaint = rcRowHandles;
	}

	// Draw the vertical line on the right that separates the row handles from
	// the data.
	CRect rcFill;
	rcFill.left = rcRowHandles.right - 1;
	rcFill.right = rcRowHandles.right;
	rcFill.top = rcRowHandles.top;
	rcFill.bottom = rcRowHandles.bottom;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


	// Define a rectangle for a handle that slides from the top to
	// the bottom of the stack of row handles as they are drawn.
	CRect rcHandle(rcRowHandles);
	rcHandle.top = rcRowHandles.top;
	rcHandle.bottom = rcHandle.top + cyRow;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	COLORREF clrTextSave;
	COLORREF  clrBackgroundSave;
	clrTextSave = pdc->SetTextColor(COLOR_CLEAN_CELL_TEXT);
	clrBackgroundSave = pdc->SetBkColor(GetSysColor(COLOR_3DFACE));

	int iHandleNumber = GetScrollPos(SB_VERT);
	TCHAR szBuffer[32];
	int nChars;
	LONG nHandles = ((rcPaint.bottom - rcHandle.top) + (cyRow - 1)) / cyRow;
	CRect rcText = rcHandle;
	rcText.top += CY_ROW_INDEX_MARGIN;
	rcText.bottom -= CY_ROW_INDEX_MARGIN;
	for (LONG lRow =0; lRow < nHandles; ++lRow) {

		// The horizontal divider at the bottom of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.right;
		rcFill.top = rcHandle.bottom - 1;
		rcFill.bottom = rcHandle.bottom;
		pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


		// The horizontal highlight across the top of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.right - 1;
		rcFill.top = rcHandle.top;
		rcFill.bottom = rcHandle.top + 1;
		pdc->FillRect(rcFill, &br3DHILIGHT);

		// The vertical highlight on the left of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.left + 1;
		rcFill.top = rcHandle.top + 1;
		rcFill.bottom = rcHandle.bottom - 1;
		pdc->FillRect(rcFill, &br3DHILIGHT);


		// The face of the row handle.
		rcFill.left = rcHandle.left + 1;
		rcFill.right = rcHandle.right - 1;
		rcFill.top = rcHandle.top + 1;
		rcFill.bottom = rcHandle.bottom - 1;
		pdc->FillRect(rcFill, &br3DFACE);


		if (m_bNumberRows) {
			_stprintf(szBuffer, _T("%ld"), iHandleNumber + 1);
			++iHandleNumber;

			nChars = _tcslen(szBuffer);
			pdc->DrawText(szBuffer, nChars, rcText, DT_CENTER);
		}

		// Increment to the next row.
		rcHandle.top += cyRow;
		rcHandle.bottom += cyRow;
		rcText.top += cyRow;
		rcText.bottom += cyRow;
	}
	pdc->SetTextColor(clrTextSave);
	pdc->SetBkColor(clrBackgroundSave);

}



//***********************************************************
// CGridCore::OnPaint
//
// Handle the WM_PAINT message.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGridCore::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	UpdateScrollRanges();


	ShowSelectionFrame(FALSE);



	if (!m_bDidInitialPaint) {
		// Do any initialization that requires this CWnd to have a valid m_hWnd
		m_bDidInitialPaint = FALSE;
		OnInitialPaint(&dc);
	}




	// Select the font that we will be drawing with
	CFont* pOldFont;
	pOldFont = dc.SelectObject(&m_font);
	ASSERT(pOldFont);


	// Compute the starting row and row count such that it includes all
	// the rows that are visible or paritally visible in the update rectangle.

	int iStartRow = dc.m_ps.rcPaint.top / RowHeight();
	int nRows = (dc.m_ps.rcPaint.bottom + (RowHeight() - 1)) / RowHeight() - iStartRow;




	iStartRow += GetScrollPos(SB_VERT);
	if (iStartRow + nRows > m_aGridCell.GetRows()) {
		nRows = m_aGridCell.GetRows() - iStartRow;
	}

	// Draw the row handles, then exclude the rectangle they occupy so that
	// they aren't redrawn.
	DrawRowHandles(&dc);

	CRect rcRowHandles;
	GetRowHandlesRect(rcRowHandles);
	dc.ExcludeClipRect(&rcRowHandles);

	// Erase the background
	if (dc.m_ps.fErase) {
		dc.FillRect(&dc.m_ps.rcPaint, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	}


	if (EntireRowIsSelected()) {
		// An entire row is selected, so draw the selection highlight in the portion of
		// the grid that may appear to the right of the last data column.
		int nCols = GetCols();
		CRect rcSelection;
		GetRowRect(m_aGridCell.m_iSelectedRow, rcSelection);
		++rcSelection.left;
		--rcSelection.bottom;

		if (rcSelection.IntersectRect(&rcSelection, &dc.m_ps.rcPaint)) {
			CBrush brHighlight(GetSysColor(COLOR_HIGHLIGHT));
			dc.FillRect(rcSelection, &brHighlight);
		}
	}



	// Switch to grid coordinates for the remainder of the window.
	CPoint ptOrgTemp = m_ptOrigin;
	ptOrgTemp.x = - m_ptOrigin.x;
	ptOrgTemp.y = - m_ptOrigin.y;
	dc.SetWindowOrg(ptOrgTemp);



	// Draw the rows of the grid.
	DrawRows(&dc, iStartRow, nRows, TRUE);

	// Restore the previously selected font.
	dc.SelectObject(pOldFont);
	ShowSelectionFrame(TRUE);

}



//********************************************************
// CGridCore::UpdateScrollRanges
//
// Update the scroll ranges so that the scroll bars correspond
// to the window size and contents.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridCore::UpdateScrollRanges()
{
	if (m_hWnd == NULL) {
		return;
	}

	int nMinPos, nMaxPos;

	CRect rcClient;
	GetClientRect(rcClient);


	nMinPos = 0;

	// First update the vertical scroll range
	int nRowsClient = rcClient.Height() / RowHeight();
	int nRowsGrid = m_aGridCell.GetRows();

	if (nRowsClient > nRowsGrid) {
		nMaxPos = 0;
	}
	else {
		nMaxPos = nRowsGrid - nRowsClient;
	}
	SetScrollRange(SB_VERT, nMinPos, nMaxPos);




	// Now do the horizontal scroll range
	ASSERT(nMinPos == 0);

	nMaxPos = GetVisibleCols() - 1;
	if (nMaxPos < 0) {
		nMaxPos = 0;
	}

	SetScrollRange(SB_HORZ, nMinPos, nMaxPos);
	UpdateOrigin();

}


//******************************************************
// CGridCore::GetVisibleCols
//
// Get the number of columns that have a non-zero width.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//******************************************************
int CGridCore::GetVisibleCols()
{
	int nColsVisible = 0;
	int nCols = GetCols();
	for (int iCol = 0; iCol < nCols; ++iCol) {
		int cxCol = ColWidth(iCol);
		if (cxCol > 0) {
			++nColsVisible;
		}
	}
	return nColsVisible;
}



//*********************************************************
// CGridCore::GetVisibleColPos
//
// Compute the horizontal starting position of the specified
// visible column.  This method treats the zero-width columns
// as if they don't exist.
//
// This method makes it easy to scroll horizontally to the
// next visible column even though there may be several zero
// width (hidden) columns between visible (non-zero-width)
// columns.
//
// Parameters:
//		[in] iColTarget
//			The desired column index such that zero width columns
//			are treated as if they didn't exist in the grid.
//
// Returns:
//		The horizontal pixel position of the start of the column.
//
//***********************************************************
int CGridCore::GetVisibleColPos(int iColTarget)
{
	int iColVisible = 0;
	int ixCol = 0;
	int nCols = GetCols();
	for (int iCol = 0; iCol < nCols; ++iCol) {
		//
		int cxCol = ColWidth(iCol);
		if ((iColVisible == iColTarget) && (cxCol > 0)) {
			return ixCol;
		}

		// Continue the search for the desired visible column
		if (cxCol > 0) {
			++iColVisible;
			ixCol += cxCol;
		}
	}

	ASSERT(FALSE);
	return 0;
}



//******************************************************
// CGridCore::MapVisibleColToAbsoluteCol
//
// Given a "visible" column index, map it to an absolute
// column index.  Note that visible column indexes treat
// zero-width columns as if they are non-existant.
//
// Parameters:
//		[in] int iColTarget
//			The visible column index that we want to map
//			to an absolute column index.
//
// Returns:
//		The absolute column index.
//
//*******************************************************
int  CGridCore::MapVisibleColToAbsoluteCol(int iColTarget)
{
	int nCols = GetCols();
	int iColVisible = 0;
	for (int iCol = 0; iCol < nCols; ++iCol) {
		int cxCol = ColWidth(iCol);
		if (cxCol > 0) {
			if (iColVisible == iColTarget) {
				return iCol;
			}
			++iColVisible;
		}
	}
	return 0;
}


//****************************************************
// CGridCore::OnInitialPaint
//
// This method is called the first time the grid is painted.
//
// Parameters:
//		CDC* pdc
//
// Returns:
//		Nothing.
//
//****************************************************
void CGridCore::OnInitialPaint(CDC* pdc)
{
	m_bDidInitialPaint = TRUE;
	SetFont(&m_font);




	// !!!CR: Why is the size hardcoded here?
	CRect rcEdit(10, 10, 150, 24);
	m_edit.Create(WS_CHILD | ES_AUTOHSCROLL, rcEdit, this, GenerateWindowID());
	m_edit.SetFont(&m_font, FALSE);

	SelectCell(NULL_INDEX, NULL_INDEX);
}


//*********************************************************************
// CGridCore::WasModified
//
// Return TRUE if the grid was modified such that there is something
// new to "save".
//
//*********************************************************************
BOOL CGridCore::WasModified()
{
	return m_bWasModified ||  ((m_edit.m_hWnd != NULL) && m_edit.GetModify());
}



//*****************************************************************
// CGridCore::PointToRow
//
// Check to see if a point in the client window hit a row and, if so,
// return the row index.
//
// Parameters:
//		CPoint pt
//			The point to test.
//
//		int& iRow
//			The row index is returned here.
//
// Returns:
//		The row index via iRow.
//
//******************************************************************
BOOL CGridCore::PointToRow(CPoint pt, int& iRow)
{
	int nRows = m_aGridCell.GetRows();
	if (nRows == 0) {
		return FALSE;
	}

	pt -= m_ptOrigin;
	if (pt.y < 0) {
		return FALSE;
	}


	// Map the vertical position to a row.  Return FALSE
	// if it falls below the last grid row.
	iRow = pt.y / RowHeight();
	if (iRow >= nRows) {
		return FALSE;
	}
	return TRUE;
}




//*****************************************************************
// CGridCore::PointToRowHandle
//
// Check to see if a point in the client window hit a row handle and, if so,
// return the row index.
//
// Parameters:
//		CPoint pt
//			The point to test.
//
//		int& iRow
//			The row index is returned here.
//
// Returns:
//		The row index via iRow.
//
//******************************************************************
BOOL CGridCore::PointToRowHandle(CPoint pt, int& iRow)
{
	if (PointToRow(pt, iRow)) {
		if (pt.x >= 0 && (pt.x <= m_cxRowHandles)) {
			return TRUE;
		}
	}
	return FALSE;
}

//*******************************************************
// CGridCore::PointToCell
//
// Map a point within the client rectangle to a grid cell.
//
// Parameters:
//		CPoint point
//			The point to map to a grid cell.
//
//		int& iRow
//			A reference to the place to return the cell's row index.
//
//		int& iCol
//			A reference to the place to return the cell's column index.
//
// Returns:
//		TRUE if the point falls within a visible grid cell.
//		FALSE otherwise.
//
//*******************************************************************
BOOL CGridCore::PointToCell(CPoint point, int& iRow, int& iCol)
{
	iRow = NULL_INDEX;
	iCol = NULL_INDEX;

	CRect rcClient;
	GetClientRect(rcClient);
	if (!rcClient.PtInRect(point)) {
		return FALSE;
	}

	if (point.x < m_cxRowHandles) {
		return FALSE;
	}

	point -= m_ptOrigin;

	// The right edge of the row handles is one pixel to the left of the
	// left edge of column zero.
	if (point.x < 0) {
		return FALSE;
	}

	int nRows = m_aGridCell.GetRows();
	if (nRows == 0) {
		return FALSE;
	}

	int nCols = m_aGridCell.GetCols();
	if (nCols == 0) {
		return FALSE;
	}


	// Map the vertical position to a row.  Return FALSE
	// if it falls below the last grid row.
	iRow = point.y / RowHeight();
	if (iRow >= nRows) {
		return FALSE;
	}



	// Loop through the columns to determine the column index
	int ix = m_aiColWidths[0];
	iCol = 0;

	while (TRUE) {
		if ((point.x < ix) || (iCol == nCols - 1)) {
			return TRUE;
		}

		++iCol;
		ix += m_aiColWidths[iCol];
	}
}


//***********************************************************
// CGridCore::IsSelectedCell
//
// Check to see if the given cell is the currently selected
// cell.
//
// Parameters:
//		int iRow
//			The row index of the cell.
//
//		int iCol
//			The column index of the cell.
//
// Returs:
//		TRUE if the specified cell is the currently selected cell.
//
//**************************************************************
BOOL CGridCore::IsSelectedCell(int iRow, int iCol)
{
	return iRow==m_aGridCell.m_iSelectedRow &&
		   iCol==m_aGridCell.m_iSelectedCol;

}


//***********************************************************
// CGridCore::EntireRowIsSelected
//
// Check to see if the entire row is currently selected.  A full-row
// selection is defined by a valid row index and a column index of
// NULL_INDEX.
//
// Parameters:
//		int iRow
//			The row index of the cell.
// Returs:
//		TRUE if the specified row is has a full-selection on it.
//
//**************************************************************
BOOL CGridCore::EntireRowIsSelected(int iRow)
{
	return iRow!=NULL_INDEX &&
		   iRow==m_aGridCell.m_iSelectedRow &&
		   NULL_INDEX == m_aGridCell.m_iSelectedCol;
}




//***********************************************************
// CGridCore::EntireRowIsSelected
//
// Check to see if the current row is entirely selected.  A full-row
// selection is defined by a valid row index and a column index of
// NULL_INDEX.
//
// Parameters:
//		None.
//
// Returs:
//		TRUE if the specified row is has a full-selection on it.
//
//**************************************************************
BOOL CGridCore::EntireRowIsSelected()
{
	return EntireRowIsSelected(m_aGridCell.m_iSelectedRow);
}


//******************************************************************
// CGridCore::OnLButtonDblClk
//
// When a cell is double clicked, the parent CGrid object may want to
// be notified.  For example, a client of CGrid may want to display
// a dialog or some such thing.
//
// Parameters:
//		See the MFC documentation for WM_LBUTTONDBLCLK
//
// Returns:
//		Nothing.
//
//******************************************************************
void CGridCore::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDblClk(nFlags, point);



	NotifyDoubleClk(nFlags, point);
}


//***************************************************************
// CGridCore::NotifyDoubleClk
//
// This method is called when a LButtonDoubleClk event is detected.
// This is handled separately from the CGrid::OnLButtonDblClck
// method because the notification can also come from a child window,
// such as the cell editor, and in that case the event should not
// be passed on to grid CWnd::OnLButtonDoublClk.
//
// Parameters:
//		See the MFC documentation for CWnd::OnLButtonDoubleClk
//
// Returns:
//		Nothing.
//
//***************************************************************
void CGridCore::NotifyDoubleClk(UINT nFlags, CPoint point)
{
	int iRow, iCol;
	BOOL bPointInCell;
	BOOL bPointInRowHandle;
	bPointInCell = PointToCell(point, iRow, iCol);
	bPointInRowHandle = PointToRowHandle(point, iRow);


	if (bPointInCell || bPointInRowHandle) {
		if (m_bTrackingMouse) {
			// Turn off the auto-scrolling timer.
			if (m_bRunningScrollTimer) {
				KillTimer(ID_TIMER_SCROLL);
				m_bRunningScrollTimer = FALSE;
			}

			// Stop tracking the mouse
			m_bTrackingMouse = FALSE;
			ReleaseCapture();

		}


		if (bPointInCell) {
			m_pParent->OnCellDoubleClicked(iRow, iCol);
		}
		else {
			m_pParent->OnRowHandleDoubleClicked(iRow);
		}
	}

}





//*************************************************************
// CGridCore::StopMouseTracking
//
// Stop tracking the mouse if mouse tracking is in effect.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::StopMouseTracking()
{
	if (m_bTrackingMouse) {
		// Turn off the auto-scrolling timer.
		if (m_bRunningScrollTimer) {
			KillTimer(ID_TIMER_SCROLL);
			m_bRunningScrollTimer = FALSE;
		}

		// Stop tracking the mouse
		m_bTrackingMouse = FALSE;
		ReleaseCapture();
	}
}



//*************************************************************
// CGridCore::OnLButtonDown
//
// Handle a mouse click.  If the mouse is clicked over one of
// the visible cells, then the corresponding grid row is
// selected.
//
// Also, this may be the start of an auto-scroll that occurs
// when the user click's the mouse and then drags it above
// or below the client rectangle.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::OnLButtonDown(UINT nFlags, CPoint point)
{



	CWnd::OnLButtonDown(nFlags, point);

	CWnd* pwndHadFocus = GetFocus();
	BOOL bClickedCell;
	int iRow, iCol;
	bClickedCell = PointToCell(point, iRow, iCol);


	BOOL bFocusChangeFailed = FALSE;
	if (bClickedCell) {
		if (!SelectCell(iRow, iCol)) {
			StopMouseTracking();

			if (pwndHadFocus && ::IsWindow(pwndHadFocus->m_hWnd)) {
				pwndHadFocus->SetFocus();
			}
			return;
		}

		CGridCell* pgc = &GetAt(iRow, iCol);

		if (pgc->IsCheckbox()) {
			DWORD dwFlags = pgc->GetFlags();
			if (!(dwFlags & CELLFLAG_READONLY)) {
				pgc->SetCheck(!pgc->GetCheck());
				DrawCell(iRow, iCol);
			}
			m_pParent->OnCellClicked(iRow, iCol);
			return;
		}

		if (pgc->RequiresSpecialEditing()) {
			pgc->DoSpecialEditing();
			m_pParent->OnCellClicked(iRow, iCol);
			return;
		}


		m_edit.SetFocus();
	}
	else {
		if (!SelectCell(NULL_INDEX, NULL_INDEX)) {
			StopMouseTracking();

			if (pwndHadFocus && ::IsWindow(pwndHadFocus->m_hWnd)) {
				pwndHadFocus->SetFocus();
			}
			return;
		}
	}


	m_edit.NotifyGridClicked(GetMessageTime());


	BOOL bPointInRowHandle;
	bPointInRowHandle = PointToRowHandle(point, iRow);
	if (bPointInRowHandle) {
		m_pParent->OnRowHandleClicked(iRow);
		SelectRow(iRow);
		return;
	}



	if (!bClickedCell) {
		return;
	}


	SyncCellEditor();
	m_pParent->OnCellClicked(iRow, iCol);


	if (IsSelectedCell(iRow, iCol)) {
		// The cell is already selected, so there is nothing to do.
		return;
	}
	else {
		if (!m_pParent->OnCellFocusChange(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol, iRow, iCol, FALSE)) {
			// The parent says that the current cell shouldn't give up the focus.
			StopMouseTracking();

			if (pwndHadFocus && ::IsWindow(pwndHadFocus->m_hWnd)) {
				pwndHadFocus->SetFocus();
			}

			return;
		}
	}


	// Control comes here only if a different cell is being selected from
	// what was previously selected.

	int iRowPrev = m_aGridCell.m_iSelectedRow;
	int iColPrev = m_aGridCell.m_iSelectedCol;

	// Remove the selection from the currently selected cell.
	//SelectCell(NULL_INDEX, NULL_INDEX);


	if (!m_pParent->OnCellFocusChange(iRow, iCol, NULL_INDEX, NULL_INDEX, TRUE)) {
		SelectCell(iRowPrev, iColPrev);
		StopMouseTracking();
		if (pwndHadFocus && ::IsWindow(pwndHadFocus->m_hWnd)) {
			pwndHadFocus->SetFocus();
		}
		return;
	}



	SelectCell(iRow, iCol);
	m_pParent->OnCellClickedEpilog(iRow, iCol);


	// Capture the mouse and start tracking it in case the user
	// wants to do mouse-driven scrolling.
	SetCapture();


	m_bTrackingMouse = TRUE;
	m_edit.ShowWindow(SW_HIDE);


}



//***********************************************************
// CGridCore::OnLButtonUp
//
// Handle the mouse-up event.
//
// This terminates the mouse tracking and mouse-driven
// scrolling that may be going on.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CGridCore::OnLButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonUp(nFlags, point);
	if (m_bTrackingMouse) {
		// Turn off the auto-scrolling timer.
		StopMouseTracking();

		// After an auto-scroll, the cell editor needs to be
		// placed over the currently selected cell and made visible.
		if (IsEditingCell()) {
			UpdateEditorPosition();

			int iRow, iCol;
			GetSelectedCell(iRow, iCol);
			CGridCell& gc = GetAt(iRow, iCol);

			VARTYPE vtCell = gc.GetVariantType();
			if (gc.IsArray() || gc.IsCheckbox() || (vtCell == VT_UNKNOWN)) {
				m_edit.ShowWindow(SW_HIDE);
			}
			else {
				m_edit.ShowWindow(SW_SHOW);
				if (!m_edit.UsesComboEditing()) {
					m_edit.SetFocus();
				}
			}
		}
	}
}





//***********************************************************
// CGridCore::OnMouseMove
//
// The mouse move event that occurs when tracking the mouse.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CGridCore::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd::OnMouseMove(nFlags, point);
	if (m_bTrackingMouse) {

		CRect rcClient;
		GetClientRect(rcClient);
		int iScrollPos;

		// If the mouse is above or below the client rectangle, then
		// we need to do auto scrolling.
		iScrollPos = GetScrollPos(SB_VERT);
		if ((point.y < 0) || (point.y > rcClient.bottom)) {

			int cyFromFrame;
			int nMilliseconds;
			// Compute how the distance from point.y to the nearest horizontal
			// border of the client rectangle.
			if (point.y < 0) {
				cyFromFrame = - point.y;
			}
			else {
				cyFromFrame = point.y - rcClient.bottom;
			}


			// Compute the scrolling speed depending on how far the mouse is
			// from the edge of the client rectangle.  There are three different
			// scrolling speeds.  The speeds are in units of milliseconds, which
			// is the time between scrolling events.
			if (cyFromFrame < CY_SLOW_SCROLL_THROTTLE) {
				nMilliseconds = SLOW_SCROLL_MILLISECONDS;
			}
			else if (cyFromFrame < CY_MEDIUM_SCROLL_THROTTLE) {
				nMilliseconds = MEDIUM_SCROLL_MILLISECONDS;
			}
			else {
				nMilliseconds = FAST_SCROLL_MILLISECONDS;
			}


			if (m_bRunningScrollTimer) {
				// A scrolling timer is already running.  Update it with the new
				// scrolling speed.
				if (nMilliseconds != m_iScrollSpeed) {
					KillTimer(ID_TIMER_SCROLL);
					SetTimer(ID_TIMER_SCROLL, nMilliseconds, NULL);
					m_iScrollSpeed = nMilliseconds;
				}
			}
			else {
				// No scrolling timer is running, so start one now.
				m_bRunningScrollTimer = TRUE;
				m_iScrollDirection = (point.y < 0) ? TIMER_SCROLL_UP : TIMER_SCROLL_DOWN;

				SetTimer(ID_TIMER_SCROLL, nMilliseconds, NULL);
				OnTimer(ID_TIMER_SCROLL);
			}
		}
		else {
			// Point.y falls within the client rectangle.  If a scrolling timer
			// is running, then stop it now.
			if (m_bRunningScrollTimer) {
				KillTimer(ID_TIMER_SCROLL);
				m_bRunningScrollTimer = FALSE;
			}


			int iRow, iCol;
			BOOL bClickedCell;
			BOOL bClickedRowHandle;
			bClickedRowHandle = PointToRowHandle(point, iRow);
			if (bClickedRowHandle) {
				SelectRow(iRow);
			}
			else {
				bClickedCell = PointToCell(point, iRow, iCol);
				if (bClickedCell) {
					if (!IsSelectedCell(iRow, iCol)) {
						SelectCell(iRow, iCol);
					}
				}
			}
		}
	}
}


//*****************************************************************
// CGridCore::InvalidateRowRect
//
// Invalidate the entire row rectangle.  This is useful when the
// highlighting on a row changes.
//
// Parameters:
//		int iRow
//			The row to invalidate.
//
// Returns:
//		None.
//
//******************************************************************
void CGridCore::InvalidateRowRect(int iRow)
{
	if (iRow == NULL_INDEX) {
		return;
	}

	CRect rcRow;
	GetRowRect(iRow, rcRow);
	InvalidateRect(rcRow);
//	UpdateWindow();
}


//*****************************************************************
// CGridCore::InvalidateRowRect
//
// Invalidate the rectangle conatining the entire current row.
//
// Parameters:
//		None.
//
// Returns:
//		None.
//
//******************************************************************
void CGridCore::InvalidateRowRect()
{
	if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
		return;
	}

	InvalidateRowRect(m_aGridCell.m_iSelectedRow);
}



//*******************************************************
// CGridCore::EndCellEditing
//
// End the cell editing session.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************
void CGridCore::EndCellEditing()
{
	if (m_edit.m_hWnd) {
		if (m_edit.GetCell()) {
			SyncCellEditor();
		}
		m_edit.ShowWindow(SW_HIDE);
		m_edit.SetCell(NULL, NULL_INDEX, NULL_INDEX);
	}
}



//********************************************************
// CGridCore::BeginCellEditing
//
// Start editing the current cell.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			True if the cell editor wants the focus.
//
//********************************************************
BOOL CGridCore::BeginCellEditing()
{

	if (!SomeCellIsSelected()) {
		return FALSE;
	}

	m_edit.ShowWindow(SW_HIDE);

	CGridCell* pGridCell;
	BOOL bWantsFocus;

	pGridCell = &m_aGridCell.GetAt(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
	VARTYPE vtCell = pGridCell->GetVariantType();
	if (pGridCell->IsArray() || (vtCell == VT_UNKNOWN)) {
		return FALSE;
	}


	UpdateEditorPosition();

	bWantsFocus = m_edit.SetCell(pGridCell, m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
	if (!m_bTrackingMouse) {
		m_edit.ShowWindow(SW_SHOW);
	}
	return bWantsFocus;
}



void CGridCore::UpdateEditorPosition()
{
	if (!SomeCellIsSelected()) {
		return;
	}

	CRect rcCellEdit;
	BOOL bCellIsVisible = GetCellEditRect(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol, rcCellEdit);


	int cxEdit = rcCellEdit.Width();
	int cyEdit = rcCellEdit.Height();
	GridToClient(rcCellEdit);




	// Keep the editor rectangle to the right of the row handles, but adjust
	// the formatting rectangle so that the text is aligned correctly.
	if (rcCellEdit.left < (m_cxRowHandles + CX_CELL_EDIT_MARGIN)) {
		rcCellEdit.left = m_cxRowHandles + CX_CELL_EDIT_MARGIN;
	}
	if (rcCellEdit.right < (m_cxRowHandles + CX_CELL_EDIT_MARGIN)) {
		rcCellEdit.right = m_cxRowHandles + CX_CELL_EDIT_MARGIN;
	}


	m_edit.MoveWindow(rcCellEdit, TRUE);
}


//*******************************************************
// CGridCore::SelectCell
//
// Select the specified row in the grid.  This causes
// the cell in the left colum to be highlighted and
// the cell editor to be placed over the right column.
// The cell editor is initialized to the cell value.
//
// Parameters:
//		int iRow
//			The index of the row to select.  A value of NULL_INDEX
//			means no row is selected.
//
//		int iCol
//			The index of the column.
//
//		BOOL bForceBeginEdit
//			TRUE to force a BeginCellEdit.
//
// Returns:
//		BOOL
//			TRUE if the selection was successful.
//			FALSE if the selection failed.
//
//****************************************************
BOOL CGridCore::SelectCell(int iRow, int iCol, BOOL bForceBeginEdit)
{

	// If an entire row is selected, turn the selection off.
	CRect rcRow;
	if (EntireRowIsSelected(m_aGridCell.m_iSelectedRow)) {
		if (iRow==m_aGridCell.m_iSelectedRow && iCol==m_aGridCell.m_iSelectedCol) {
			// This is a redundant call to reselect the row.
			return TRUE;
		}

	} else {
		if (IsSelectedCell(iRow, iCol)) {
			// There is nothing to do if the same cell is being selected again.
			return TRUE;
		}

	}


	if (m_pParent) {
		if (!m_pParent->OnCellFocusChange(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol, iRow, iCol, FALSE)) {
			return FALSE;
		}
	}


	EndCellEditing();


	// Hide selection frame if its visible.
	ShowSelectionFrame(FALSE);




	// At this point the selection on the previous cell has been turned off.
	// Now we must turn on the selection for the new cell.

	ASSERT(iRow < m_aGridCell.GetRows());



	if (EntireRowIsSelected()) {
		InvalidateRowRect();
	}

	// If this is a request to turn off cell selection, invalidate
	// anything that might need to be repainted and clear the selection.
	if (iRow==NULL_INDEX && iCol==NULL_INDEX) {
		m_aGridCell.m_iSelectedRow = iRow;
		m_aGridCell.m_iSelectedCol = iCol;
		if(m_pParent)
			m_pParent->OnSetToNoSelection();

		return TRUE;
	}




	if (!m_pParent->OnCellFocusChange(iRow, iCol, NULL_INDEX, NULL_INDEX, TRUE)) {
		return FALSE;
	}


	// Check to see if we're selecting a full-row.  If so, update the
	// current indexes, and invalidate the specified row so that it will
	// be redrawn in the highlight color.
	if (IsFullRowSelection(iRow, iCol)) {
		m_aGridCell.m_iSelectedRow = iRow;
		m_aGridCell.m_iSelectedCol = iCol;
		InvalidateRowRect(iRow);
		UpdateWindow();
		return TRUE;
	}



	CRect rcCell;
	CString sValue;


	// Select the specified row.  This copies the cell's value to the cell
	// editor.  It also sets the currently selected row index so that
	// the left column of the row will be highlighted when it is redrawn.
	m_aGridCell.m_iSelectedRow = iRow;
	m_aGridCell.m_iSelectedCol = iCol;
	ShowSelectionFrame(TRUE);


	CGridCell& gc = GetAt(iRow, iCol);
	BOOL bIsArray = gc.IsArray();
	BOOL bIsObject = gc.IsObject();
	BOOL bIsCheckbox = gc.IsCheckbox();
	BOOL bIsTime = gc.IsTime();
	CellType iCellType = gc.GetType();


	BOOL bIsEditable = TRUE;
	if (!bForceBeginEdit) {
			bIsEditable = (iCellType != CELLTYPE_PROPMARKER) &&
				!bIsArray &&
				!bIsObject &&
				!bIsCheckbox &&
				!bIsTime;
	}

	BOOL bWantsFocus = FALSE;
	if (bIsEditable) {
		CGridCell* pgc = &GetAt(iRow, iCol);
		if (pgc->RequiresSpecialEditing()) {
			pgc->DoSpecialEditing();
		}
		else {
			bWantsFocus = BeginCellEditing();
		}
	}

	if (bWantsFocus) {
		m_edit.SetFocus();
	}
	else {
		SetFocus();
	}

	UpdateWindow();
	return TRUE;
}


//***************************************************************************
// CGridCore::GetRowRect
//
// Get the rectangle that contains the specified row.
//
// Parameters:
//		int iRow
//			The desired row.
//
//		CRect rcRow
//			The row rectangle.
//
// Returns:
//		The rectangle containing the specified row in client coordinates.
//
//**************************************************************************
void CGridCore::GetRowRect(int iRow, CRect& rcRow)
{
	if (iRow == NULL_INDEX) {
		return;
	}

	CRect rcClient;
	GetClientRect(rcClient);

	// First calculate the row rectangle in grid coordinates, but
	// we don't care about the right side yet, so we'll just use
	// a value of zero for rcRow.right.
	int cyRow = RowHeight();
	rcRow.top = iRow * cyRow;
	rcRow.bottom = rcRow.top + cyRow;
	rcRow.left = 0;
	rcRow.right = 0;

	// Convert to client coordinates and make the row go all the way to the
	// right side of the grid.
	GridToClient(rcRow);
	rcRow.right = rcClient.right;
	if (rcRow.left < m_cxRowHandles) {
		rcRow.left = m_cxRowHandles;
	}

}


//***************************************************************************
// CGridCore::SelectRow
//
// Select an entire row in the grid.
//
// Parameters:
//		int iRow
//			The row to select.
//
// Returns:
//		Nothing.
//
//***************************************************************************
void CGridCore::SelectRow(int iRow)
{
	if (iRow != NULL_INDEX) {
		SetFocus();
	}

	if (EntireRowIsSelected(iRow)) {
		// Do nothing if the row is already selected.
		return;
	}

	SelectCell(iRow, NULL_INDEX);

}




//*****************************************************************
// CGridCore::OnTimer
//
// This method handles windows timer events.  The grid control uses
// a timer to handle mouse driven scrolling.  When the user clicks
// within the client area and then drags above or below the client
// rect, then a timer is started and the grid is scrolled once per
// timer event.  The timer is killed when the user moves the mouse
// back into the client area or releases the mouse.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CGridCore::OnTimer(UINT nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	CWnd::OnTimer(nIDEvent);

	int nScrollPos, nMinScrollPos, nMaxScrollPos;
	GetScrollRange(SB_VERT, &nMinScrollPos, &nMaxScrollPos);
	nScrollPos = GetScrollPos(SB_VERT);


	switch(m_iScrollDirection)
	{
	case TIMER_SCROLL_UP:
		if (nScrollPos > 0) {
			ScrollGrid(SB_VERT, nScrollPos - 1);
			SelectCell(nScrollPos - 1, m_aGridCell.m_iSelectedCol);
		}
		break;
	case TIMER_SCROLL_DOWN:
		if (nScrollPos < nMaxScrollPos) {
			ScrollGrid(SB_VERT, nScrollPos + 1);
			if ((nScrollPos + m_nRowsClient) < m_aGridCell.GetRows()) {
				SelectCell(nScrollPos + m_nRowsClient, m_aGridCell.m_iSelectedCol);
			}
			else {
				SelectCell(m_aGridCell.GetRows() - 1, m_aGridCell.m_iSelectedCol);
			}
		}
	}
}




//**************************************************
// CGridCore::OnSize
//
// This method is called when the client area size is
// changed.
//
// Parameters:
//		See the MFC documentation
//
// Returns:
//		Nothing.
//
//***************************************************
void CGridCore::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	m_nRowsClient = (cy + RowHeight() - 1) / RowHeight();
	m_nWholeRowsClient = cy / RowHeight();
	UpdateEditorPosition();
}





//*********************************************************
// CGridCore::IsControlChar
//
// Return TRUE if the specified character from the OnChar
// event is a control character.  This method is used to
// filter out non-displayable characters so they don't
// get passed to the cell editor.
//
// Parameters:
//		UINT nChar
//			Same as nChar from the OnChar method.
//
//		UINT nFlags
//			Same as nFlags from the OnChar method.
//
// Returns:
//		TRUE if the character is a non-displayable control
//		character, FALSE otherwise.
//
//********************************************************
BOOL CGridCore::IsControlChar(UINT nChar, UINT nFlags)
{
	return (nChar < _T(' ') ||
		   (nFlags & KEY_FLAG_EXTENDEDKEY) ||
		   (nFlags & KEY_FLAG_CONTEXTCODE));
}



//**************************************************************
// CGridCore::OnCellKeyDown
//
// Call this method to notify derived classes when a keydown event
// occurs for a grid cell.  Note that the keydown event could originate
// with this CGrid class, the CCellEdit class, or possibly others in the
// future.
//
//
// Parameters:
//		int iRow
//			The row index.
//
//		int iCol
//			The column index.
//
//		UINT nChar
//			The nChar parameter from WM_KEYDOWN.
//
//		UINT nRepCnt
//			The nRepCnt parameter from WM_KEYDOWN.
//
//		UINT nFlags
//			The nFlags parameter from WM_KEYDOWN.
//
// Returns:
//		BOOL
//			TRUE if the keydown event is handled (if TRUE, the caller assumes
//			that no further action is required for the WM_KEYDOWN message).
//
//****************************************************************
BOOL CGridCore::OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	return m_pParent->OnCellKeyDown(iRow, iCol, nChar, nRepCnt, nFlags);
}


//**************************************************************
// CGridCore::OnCellKeyDown
//
// Call this method to notify derived classes when a W event
// occurs for a grid cell.  Note that the keydown event could originate
// with this CGrid class, the CCellEdit class, or possibly others in the
// future.
//
//
// Parameters:
//		int iRow
//			The row index.
//
//		int iCol
//			The column index.
//
//		UINT nChar
//			The nChar parameter from WM_KEYDOWN.
//
//		UINT nRepCnt
//			The nRepCnt parameter from WM_KEYDOWN.
//
//		UINT nFlags
//			The nFlags parameter from WM_KEYDOWN.
//
// Returns:
//		BOOL
//			TRUE if the keydown event is handled (if TRUE, the caller assumes
//			that no further action is required for the WM_KEYDOWN message).
//
//****************************************************************
BOOL CGridCore::OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	return m_pParent->OnCellChar(iRow, iCol, nChar, nRepCnt, nFlags);
}




//*************************************************************
// CGridCore::OnKeyDown
//
// The handler for the keydown event is here to help implement
// the grid behavior where the contents of the cell editor
// get replace by the first character the user types if he or she
// selects a cell and has not edited it in any other way yet.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CGridCore::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (SomeCellIsSelected()) {

		m_pParent->OnCellKeyDown(
						m_aGridCell.m_iSelectedRow,
						m_aGridCell.m_iSelectedCol,
						nChar,
						nRepCnt,
						nFlags);
	}
	else if (EntireRowIsSelected()) {
		m_pParent->OnRowKeyDown(
						m_aGridCell.m_iSelectedRow,
						nChar,
						nRepCnt,
						nFlags);
	}


	CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
	CGridCell* pgc;
	int iRow, iCol;

	// The derived class, did not handle this keydown
	// event.
	switch(nChar) {
	case VK_UP:
		OnRowUp();
		return;
	case VK_DOWN:
		OnRowDown();
		return;
	case VK_TAB:
		OnTabKey(GetKeyState(VK_SHIFT) < 0);
		return;
	case VK_DELETE:
		GetSelectedCell(iRow, iCol);
		if (iRow == NULL_INDEX) {
			Beep(1700, 40);
		}
		else {
			if (iCol != NULL_INDEX) {
				pgc = &GetAt(iRow, iCol);
				if (pgc && (pgc->GetFlags() & CELLFLAG_READONLY)) {
					Beep(1700, 40);
				}
			}
		}
		return;

	}

}



//*********************************************************************
// CGridCore::OnTabKey
//
// This method is called when the user presses the tab key.
// This shifts the grid selection left or right depending on the state of the
// shift key.
//
// Parameters:
//		BOOL bShiftKeyDepressed
//			TRUE if the shift key is depressed.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CGridCore::OnTabKey(BOOL bShiftKeyDepressed)
{
	if (bShiftKeyDepressed) {
		// The shift key is depressed, so do a back tab.
		if (m_aGridCell.m_iSelectedCol == 0) {
			if (m_aGridCell.m_iSelectedRow != NULL_INDEX) {
				SelectRow(m_aGridCell.m_iSelectedRow);
			}
		}
		else if (m_aGridCell.m_iSelectedCol > 0) {
			SelectCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol - 1);
		}

	}
	else {
		if (m_aGridCell.m_iSelectedCol < m_aGridCell.GetCols() - 1) {
			SelectCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol + 1);
		}
	}
	EnsureRowVisible(m_aGridCell.m_iSelectedRow);
}


void CGridCore::OnRowUp()
{
	if (EntireRowIsSelected()) {
		if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
		}
		else if (m_aGridCell.m_iSelectedRow > 0) {
			EnsureRowVisible(m_aGridCell.m_iSelectedRow - 1);
			SelectRow(m_aGridCell.m_iSelectedRow - 1);
		}
		else {

		}

	}
	else {
		if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
		}
		else if (m_aGridCell.m_iSelectedRow > 0) {
			EnsureRowVisible(m_aGridCell.m_iSelectedRow - 1);
			SelectCell(m_aGridCell.m_iSelectedRow - 1, m_aGridCell.m_iSelectedCol);
		}
		else {

		}
	}

}


void CGridCore::OnRowDown()
{
	if (EntireRowIsSelected()) {
		if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
		}
		else if (m_aGridCell.m_iSelectedRow < (GetRows() - 1)) {
			EnsureRowVisible(m_aGridCell.m_iSelectedRow + 1);
			SelectRow(m_aGridCell.m_iSelectedRow + 1);
		}
		else {

		}

	}
	else {
		if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
		}
		else if (m_aGridCell.m_iSelectedRow < (GetRows() - 1)) {
			EnsureRowVisible(m_aGridCell.m_iSelectedRow + 1);
			SelectCell(m_aGridCell.m_iSelectedRow + 1, m_aGridCell.m_iSelectedCol);
		}
		else {

		}
	}

}




//*******************************************************************
// CGridCore::PreTranslateMessage
//
// Handle PreTranslateMessage so that we can implement a keyboard
// interface that mimics what the Visual BASIC property sheet does.
//
// Parameters:
//		See the MFC documentation.
//
//*******************************************************************
BOOL CGridCore::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	// CG: This block was added by the Pop-up Menu component
	{
		// Shift+F10: show pop-up menu.
		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
		{
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			CPoint point = rect.TopLeft();
			point.Offset(5, 5);
			OnContextMenu(NULL, point);

			return TRUE;
		}
	}




	if (pMsg->hwnd != m_hWnd) {
		return CWnd::PreTranslateMessage(pMsg);
	}


	int nMinPos, nMaxPos;
	int iRow;
	int iCol;
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_HOME:
			if (GetRows() > 0) {
				iCol = m_aGridCell.m_iSelectedCol;
				if (iCol==NULL_INDEX) {
					iCol = 0;
				}
				SetScrollPos(SB_VERT, 0);
				SelectCell(0, iCol);
				EnsureRowVisible(0);
				RedrawWindow();
			}
			return TRUE;

		case VK_END:
			iRow = GetRows() - 1;
			if (iRow >= 0) {
				GetScrollRange(SB_VERT, &nMinPos, &nMaxPos);
				SetScrollPos(SB_VERT, nMaxPos);
				RedrawWindow();

				iCol = m_aGridCell.m_iSelectedCol;
				if (iCol == NULL_INDEX) {
					iCol = 0;
				}
				SelectCell(iRow, iCol);
				EnsureRowVisible(iRow);
			}
			return TRUE;

		case VK_PRIOR:		// Page up
			if (SomeCellIsSelected() && m_aGridCell.m_iSelectedRow > 0) {
				iRow = m_aGridCell.m_iSelectedRow - (m_nWholeRowsClient - 1);
				if (iRow < 0) {
					iRow = 0;
				}
				SelectCell(iRow, m_aGridCell.m_iSelectedCol);
				EnsureRowVisible(iRow);
			}

			return TRUE;

		case VK_NEXT:		// Page down
			if (SomeCellIsSelected()) {
				iRow = m_aGridCell.m_iSelectedRow + (m_nWholeRowsClient - 1);
				if (iRow >= m_aGridCell.GetRows()) {
					iRow = m_aGridCell.GetRows() - 1;
					if (iRow < 0) {
						iRow = 0;
					}
				}
				SelectCell(iRow, m_aGridCell.m_iSelectedCol);
				EnsureRowVisible(iRow);
			}

			return TRUE;

		case VK_LEFT:
			if (EntireRowIsSelected()) {
				if (m_aGridCell.m_iSelectedRow > 0) {
					SelectRow(m_aGridCell.m_iSelectedRow - 1);
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			else {
				if (SomeCellIsSelected()) {
					if (m_aGridCell.m_iSelectedCol > 0) {
						SelectCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol - 1);
					}
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			return TRUE;
			break;
		case VK_UP:
			if (EntireRowIsSelected()) {
				if (m_aGridCell.m_iSelectedRow > 0) {
					SelectRow(m_aGridCell.m_iSelectedRow - 1);
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			else {
				if (SomeCellIsSelected()) {
					if (m_aGridCell.m_iSelectedRow > 0) {
						SelectCell(m_aGridCell.m_iSelectedRow - 1, m_aGridCell.m_iSelectedCol);
					}
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			return TRUE;
			break;
		case VK_RIGHT:
			if (EntireRowIsSelected()) {
				if (m_aGridCell.m_iSelectedRow < (GetRows() - 1)) {
					SelectRow(m_aGridCell.m_iSelectedRow + 1);
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			else {
				if (SomeCellIsSelected()) {
					if (m_aGridCell.m_iSelectedCol < m_aGridCell.GetCols() - 1) {
						SelectCell(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol + 1);
					}
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			return TRUE;
			break;
		case VK_DOWN:
			if (EntireRowIsSelected()) {
				if (m_aGridCell.m_iSelectedRow < (GetRows() - 1)) {
					SelectRow(m_aGridCell.m_iSelectedRow + 1);
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			else {
				if (SomeCellIsSelected()) {
					if (m_aGridCell.m_iSelectedRow < m_aGridCell.GetRows() - 1) {
						SelectCell(m_aGridCell.m_iSelectedRow + 1, m_aGridCell.m_iSelectedCol);
					}
					EnsureRowVisible(m_aGridCell.m_iSelectedRow);
				}
			}
			return TRUE;
		case VK_TAB:
			if (SomeCellIsSelected()) {
				OnTabKey(GetKeyState(VK_SHIFT) < 0);
			}
			return TRUE;
		case VK_BACK:
			if (SomeCellIsSelected()) {
				m_edit.ReplaceSel(_T(""), TRUE);
				m_edit.SetFocus();
			}
			return TRUE;
		}
		break;
	}

	return CWnd::PreTranslateMessage(pMsg);
}





//*********************************************************************
// CGridCore::EnsureRowVisible
//
// Ensure that the specified row is completely visible within the
// client rectangle.
//
// Parameters:
//		int iRow
//			The index of the row to make visible.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CGridCore::EnsureRowVisible(int iRow)
{
	if (iRow == NULL_INDEX) {
		return;
	}

	int nMinPos, nMaxPos, nCurPos;
	nCurPos = GetScrollPos(SB_VERT);
	GetScrollRange(SB_VERT, &nMinPos, &nMaxPos);

	if (iRow < nCurPos) {

		ScrollGrid(SB_VERT, iRow);
	}
	else {
		CRect rcClient;
		GetClientRect(rcClient);
		int nWholeRowsClient = rcClient.Height() / RowHeight();

		if (iRow >= (nCurPos + nWholeRowsClient)) {
			ScrollGrid(SB_VERT, iRow - nWholeRowsClient + 1);
		}
	}
	UpdateEditorPosition();
}



//************************************************************
// CGridCore::ScrollGrid
//
// Scroll the grid to the specified position.
//
// Parameters:
//		int nBar
//			SB_VERT or SB_HORZ
//
//		int nPos
//			The position to scroll to.
//
// Returns:
//		Nothing.
//************************************************************
void CGridCore::ScrollGrid(int nBar, int nPos)
{
	int cxScroll = 0;
	int cyScroll = 0;
	int nMinPos, nMaxPos, nCurPos;


	CRect rcScroll;
	GetClientRect(rcScroll);
	rcScroll.left += m_cxRowHandles;	// Don't scroll the row handles.
//	rcScroll.right += m_cxRowHandles;


	int cxScrollNew;
	int cxScrollCur;

	switch(nBar) {
	case SB_VERT:
		nCurPos = GetScrollPos(SB_VERT);
		GetScrollRange(SB_VERT, &nMinPos, &nMaxPos);
		ASSERT(nPos <= nMaxPos);
		ASSERT(nPos >= nMinPos);

		cyScroll = (nCurPos - nPos) * RowHeight();
		cxScroll = 0;

		break;
	case SB_HORZ:
		nCurPos = GetScrollPos(SB_HORZ);
		GetScrollRange(SB_HORZ, &nMinPos, &nMaxPos);
		ASSERT(nPos <= nMaxPos);
		ASSERT(nPos >= nMinPos);


		cxScrollCur = GetVisibleColPos(nCurPos);
		cxScrollNew = GetVisibleColPos(nPos);
		cxScroll = cxScrollCur - cxScrollNew;

		cyScroll = 0;

		break;
	default:
		ASSERT(FALSE);
		break;
	}


	if ((cxScroll != 0) || (cyScroll!=0)) {
		// Do physical scrolling only if the scroll position has changed.

		UpdateWindow();
		ShowSelectionFrame(FALSE);
		SetScrollPos(nBar, nPos);
		UpdateOrigin();
		BOOL bEditorVisible = FALSE;
		if (::IsWindow(m_edit.m_hWnd)) {
			bEditorVisible = m_edit.IsWindowVisible();
			if (bEditorVisible) {
				m_edit.ShowWindow(SW_HIDE);
			}
		}


		ScrollWindowEx(cxScroll, cyScroll, rcScroll, rcScroll, NULL, NULL, SW_ERASE | SW_INVALIDATE  | SW_SCROLLCHILDREN );

		if (m_cxRowHandles > 0) {
			CRect rcRowHandles;
			rcRowHandles.left = rcScroll.left - m_cxRowHandles;
			rcRowHandles.right = rcScroll.left;
			rcRowHandles.top = rcScroll.top;
			rcRowHandles.bottom = rcScroll.bottom;
			ScrollWindowEx(0, cyScroll, rcRowHandles, rcRowHandles, NULL, NULL, SW_ERASE | SW_INVALIDATE  | SW_SCROLLCHILDREN );
		}


		UpdateEditorPosition();
		if (bEditorVisible) {
			m_edit.ShowWindow(SW_SHOW);
			m_edit.SetFocus();
		}
		ShowSelectionFrame(TRUE);

		CRgn rgnUpdate;
		GetUpdateRgn(&rgnUpdate);
		RedrawWindow(NULL, &rgnUpdate);
	}
}



//********************************************************************
// CGridCore::UpdateOrigin
//
// Update the origin to correspond to the current scroll position.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CGridCore::UpdateOrigin()
{
	int iCol = MapVisibleColToAbsoluteCol(GetScrollPos(SB_HORZ));
	m_ptOrigin.x = - GetColPos(iCol);
	m_ptOrigin.y = - GetScrollPos(SB_VERT) * RowHeight();

	// bug on checked build - if there are no headers, this will
	// access violate because it will try to get the width of
	// header '0'
	if(iCol < GetCols())
		m_pParent->SetHeaderScrollOffset(iCol, -m_ptOrigin.x);

	m_ptOrigin.x += m_cxRowHandles;
}




//*******************************************************************
// CGridCore::Clear
//
// Delete the entire contents of the grid.
//
// Parameters:
//		[in] BOOL bUpdateWindow
//			TRUE if the window should be updated after clearing the grid.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::Clear(BOOL bUpdateWindow)
{
	EndCellEditing();
	m_aGridCell.DeleteAll();
	m_aiColWidths.RemoveAll();
	m_adwColTags.RemoveAll();

	m_asColTitles.RemoveAll();

	if (bUpdateWindow && m_hWnd!=NULL) {
		RedrawWindow();
	}
	ASSERT(GetCols() == 0);
	ASSERT(GetRows() == 0);
}



//*******************************************************************
// CGridCore::ClearRows
//
// Delete all the rows from entire contents of the grid.
//
// Parameters:
//		[in] BOOL bUpdateWindow
//			TRUE if the window should be updated after clearing the rows.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGridCore::ClearRows(BOOL bUpdateWindow)
{
	EndCellEditing();
	m_aGridCell.DeleteAllRows();

	if (bUpdateWindow && m_hWnd!=NULL) {
		RedrawWindow();
	}
}


// !!!CR: It looks like we don't need to handle WM_SHOWWINDOW for CGridCore
void CGridCore::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CWnd::OnShowWindow(bShow, nStatus);

}





//********************************************************************
// CGridCore::SortGrid
//
// Sort the specified range of rows in the grid.
//
// Parameters:
//		int iRowFirst
//			The index of the first row to sort.
//
//		int iRowLast
//			The index of the last row to sort.
//
//		int iSortColumn
//			The primary column to sort by.
//
//		BOOL bAscending
//			TRUE for an ascending sort order, FALSE for a descending sort order.
//
//		BOOL bRedrawWindow
//			TRUE to redraw the window after the sort.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CGridCore::SortGrid(int iRowFirst, int iRowLast, int iSortColumn, BOOL bAscending, BOOL bRedrawWindow)
{
	if (m_pParent == NULL) {
		return;
	}

	// Copy the contents of the editor back to the grid.
	SyncCellEditor();
	BOOL bIsEditingCell;

	bIsEditingCell = IsEditingCell();
	if (bIsEditingCell) {
		m_edit.ShowWindow(SW_HIDE);
	}


	m_aGridCell.Sort(m_pParent, iRowFirst, iRowLast, iSortColumn, bAscending);



	if (bIsEditingCell) {
		UpdateEditorPosition();  // Need to update the currently selected row when sorting.
		ASSERT(m_aGridCell.m_iSelectedRow != NULL_INDEX);
		EnsureRowVisible(m_aGridCell.m_iSelectedRow);
		m_edit.ShowWindow(SW_SHOW);
	}
	else if (EntireRowIsSelected()) {
		EnsureRowVisible(m_aGridCell.m_iSelectedRow);
	}

	if (bRedrawWindow) {
		RedrawWindow();
	}
}



void CGridCore::OnRButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CWnd::OnRButtonDown(nFlags, point);

}




BOOL CGridCore::OnEraseBkgnd(CDC* pdc)
{
	CRect rc;
	pdc->GetClipBox(&rc);
	pdc->FillRect(&rc, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));

	return TRUE;
}

void CGridCore::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	m_pParent->OnCellChar(m_aGridCell.m_iSelectedRow,
				  m_aGridCell.m_iSelectedCol,
				  nChar, nRepCnt, nFlags);


	switch(nChar) {
	case VK_TAB:
		return;
	}

	// If the grid has the focus and some cell is selected, then switch the focus
	// to that cell and behave as if the user had typed the character(s) into the
	// cell.
	if (SomeCellIsSelected()) {
		CGridCell* pgc = &GetAt(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
		if (pgc->RequiresSpecialEditing()) {
			// If the cell requies special editing, typing in a cell should not
			// do anything.
			return;
		}


		switch (nChar) {
		case ESC_CHAR:
			m_edit.RevertToInitialValue();
			return;
		}



		DWORD dwFlags = SelectedCell()->GetFlags();

		CString sValue;
		while (nRepCnt > 0) {
			sValue = sValue + (TCHAR) nChar;
			--nRepCnt;
		}


		if (m_pParent->OnBeginCellEditing(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol)) {

			BOOL bWantsFocus = BeginCellEditing();
			if (!(SelectedCell()->GetFlags() & CELLFLAG_READONLY)
				&& !m_edit.UsesComboEditing()) {

				m_edit.ReplaceSel(sValue, TRUE);
			}
			if (bWantsFocus) {
				m_edit.SetFocus();
			}
		}

	}
	else if (EntireRowIsSelected()) {
		// Entire row is selected
		switch (nChar) {
		case VK_UP:
			if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
				SelectRow(0);
			}
			else if (m_aGridCell.m_iSelectedRow > 0) {
				SelectRow(m_aGridCell.m_iSelectedRow - 1);
			}
			break;
		case VK_DOWN:
			if (m_aGridCell.m_iSelectedRow == NULL_INDEX) {
				SelectRow(0);
			}
			else if (m_aGridCell.m_iSelectedRow < (GetRows() - 1)) {
				SelectRow(m_aGridCell.m_iSelectedRow + 1);
			}
			break;

		}



	}

//	CWnd::OnChar(nChar, nRepCnt, nFlags);

}

void CGridCore::GridToClient(CRect& rc)
{
	rc += m_ptOrigin;
}

void CGridCore::ClientToGrid(CRect& rc)
{
	rc -= m_ptOrigin;
}



void CGridCore::GridToClient(CPoint& pt)
{
	pt += m_ptOrigin;
}

void CGridCore::ClientToGrid(CPoint& pt)
{
	pt -= m_ptOrigin;
}

BOOL CGridCore::GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands)
{
	return m_pParent->GetCellEditContextMenu(iRow, iCol, pwndTarget, menu, bWantEditCommands);
}

void CGridCore::ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu)
{
	m_pParent->ModifyCellEditContextMenu(iRow, iCol, menu);
}


CGridCell* CGridCore::SelectedCell()
{
	if (SomeCellIsSelected()) {
		return &GetAt(m_aGridCell.m_iSelectedRow, m_aGridCell.m_iSelectedCol);
	}
	else {
		return NULL;
	}
}

BOOL CGridCore::IsNullCell(int iRow, int iCol)
{
	if ((iRow==NULL_INDEX) || (iCol==NULL_INDEX) ) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


void CGridCore::ClearSelection()
{
	m_aGridCell.m_iSelectedRow = NULL_INDEX;
	m_aGridCell.m_iSelectedCol = NULL_INDEX;
}

BOOL CGridCore::IsFullRowSelection(int iRow, int iCol)
{
	return iRow!=NULL_INDEX && iCol==NULL_INDEX;
}

BOOL CGridCore::SomeCellIsSelected()
{
	return m_aGridCell.m_iSelectedRow != NULL_INDEX && m_aGridCell.m_iSelectedCol!=NULL_INDEX;
}



void CGridCore::UpdateRowHandleWidth()
{
	int cxRowHandlesInitial = m_cxRowHandles;

	if (m_hWnd == NULL || !m_bNumberRows) {
		m_cxRowHandles = CX_SMALL_ROWHANDLE;
		if (m_cxRowHandles != cxRowHandlesInitial) {
			m_pParent->NotifyRowHandleWidthChanged();
		}
		return;
	}

	static TCHAR szDigits[] = _T("888888888888");
	CRect rcClient;
	GetClientRect(rcClient);
	int cyRow = RowHeight();
	long nRows = (rcClient.Height() + (cyRow - 1)) / cyRow;
	if (nRows < GetRows()) {
		nRows = GetRows();
	}
	int nDigits = 1;
	long nValue = nRows + 1;
	while (nValue > 9) {
		nValue = nValue / 10;
		++nDigits;
	}

	ASSERT(nDigits >0 && nDigits <= sizeof(szDigits)/sizeof(TCHAR));

	CDC* pdc = GetDC();
	CFont* pOldFont;
	pOldFont = pdc->SelectObject(&m_font);
	ASSERT(pOldFont);

	CSize size;
	size =  pdc->GetTextExtent(szDigits, nDigits);

	pdc->SelectObject(pOldFont);
	ReleaseDC(pdc);


	size.cx += 2 * CX_ROW_INDEX_MARGIN;
	m_cxRowHandles = size.cx + 2 * CX_ROW_INDEX_MARGIN;
	if (m_cxRowHandles < CX_SMALL_ROWHANDLE ) {
		m_cxRowHandles = CX_SMALL_ROWHANDLE;
	}

	if (m_cxRowHandles != cxRowHandlesInitial) {
		m_pParent->NotifyRowHandleWidthChanged();
	}
}



//***********************************************************
// CGridCore::NumberRows
//
// Turn row numbering on or off.
//
// Parameters:
//		BOOL bNumberRows
//			TRUE if the row index should be drawn in the row
//			handle, FALSE if the row handles should not be
//			numbered.
//
//	    BOOL bRedraw
//			TRUE if the window should be redrawn, FALSE otherwise.
//
// Returns:
//		Nothing.
//
//***********************************************************
BOOL CGridCore::NumberRows(BOOL bNumberRows, BOOL bRedraw)
{
	BOOL bWasNumberingRows = m_bNumberRows;
	m_bNumberRows = bNumberRows;
	UpdateRowHandleWidth();
	return bWasNumberingRows;
}







void CGridCore::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		OnRequestUIActive();
	}

}

void CGridCore::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}



//******************************************************************
// CGridCore::OnMouseWheel
//
// Handle WM_MOUSEWHEEL because we don't inherit from CScrollView.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		See the MFC documentation.
//
//******************************************************************
BOOL CGridCore::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
//		return CWnd::OnMouseWheel(nFlags, zDelta, pt);


	zDelta = zDelta / 120;

	int iPos = GetScrollPos(SB_VERT);
	int iMaxPos = GetScrollLimit(SB_VERT);

	// Handle the cases where the scroll is a no-op.
	if (zDelta == 0 ) {
		return TRUE;
	}
	else if (zDelta < 0) {
		if (iPos == iMaxPos) {
			return TRUE;
		}
	}
	else if (zDelta > 0) {
		if (iPos == 0) {
			return TRUE;
		}
	}



	iPos = iPos - zDelta;
	if (iPos < 0) {
		iPos = 0;
	}
	else if (iPos >= iMaxPos) {
		iPos = iMaxPos - 1;
		if (iPos < 0) {
			return TRUE;
		}
	}

	UINT wParam;
	wParam = (iPos << 16) | SB_THUMBPOSITION;

	SendMessage(WM_VSCROLL, wParam);
	return TRUE;

}



//************************************************************
// CGridCore::SetRowTagValue
//
// Set the tag value for the specified row.  The tag value is
// a DWORD available to clients of the grid.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
//		[in] DWORD dwTagValue
//			The tag value.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCore::SetRowTagValue(int iRow, DWORD dwTagValue)
{
	CGridRow& row = GetRowAt(iRow);
	row.SetTagValue(dwTagValue);

}



//************************************************************
// CGridCore::GetRowTagValue
//
// Get the tag value for the specified row.  The tag value is
// a DWORD available to clients of the grid.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
// Returns:
//		DWORD dwTagValue
//			The tag value.
//
//************************************************************
DWORD CGridCore::GetRowTagValue(int iRow)
{
	CGridRow& row = GetRowAt(iRow);
	DWORD dwTag = row.GetTagValue();
	return dwTag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgobjecteditor.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "svbase.h"
//}}AFX_INCLUDES
#if !defined(AFX_DLGOBJECTEDITOR_H__F58FDB53_6DB8_11D1_84F1_00C04FD7BB08__INCLUDED_)
#define AFX_DLGOBJECTEDITOR_H__F58FDB53_6DB8_11D1_84F1_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgObjectEditor.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgObjectEditor dialog

class CGridCell;

class CDlgObjectEditor : public CDialog
{
// Construction
public:
	CDlgObjectEditor(CWnd* pParent = NULL);   // standard constructor
	BOOL EditEmbeddedObject(IWbemServices* psvc, CString& sClassname, CGridCell* pgc);
	BOOL CreateEmbeddedObject(IWbemServices* psvc, CString& sClassname, CGridCell* pgc);

// Dialog Data
	//{{AFX_DATA(CDlgObjectEditor)
	enum { IDD = IDD_EDIT_OBJECT };
	CStatic	m_statHelptext;
	CEdit	m_edtClassname;
	CButton	m_btnOkProxy;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgObjectEditor)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgObjectEditor)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnOkProxy();
	afx_msg void OnGetWbemServicesSingleviewctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CGridCell* m_pgc;
	IWbemServices* m_psvc;
	IWbemClassObject* m_pco;
	IWbemClassObject* m_pcoEdit;
	BOOL m_bCreatingObject;
	BOOL m_bDidSelectClass;
	CString m_sClassname;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGOBJECTEDITOR_H__F58FDB53_6DB8_11D1_84F1_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgarray.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGARRAY_H__07A103C1_B740_11D0_846E_00C04FD7BB08__INCLUDED_)
#define AFX_DLGARRAY_H__07A103C1_B740_11D0_846E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


// DlgArray.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgArray dialog


#ifndef _WBEMSVC_H
#define _WBEMSVC_H
#include "wbemidl.h"
#endif

class CGridCell;
class CGrid;
class CVar;
class CArrayGrid;
class CDlgArray : public CDialog
{
// Construction
public:
	CDlgArray(BOOL bNumberRows, CWnd* pParent = NULL);   // standard constructor
	~CDlgArray();
	BOOL EditValue(IWbemServices* psvc, CString& sPropName, CGridCell* pgc);

// Dialog Data
	//{{AFX_DATA(CDlgArray)
	enum { IDD = IDD_ARRAY };
	CStatic	m_statIcon;
	CButton	m_btnOK;
	CButton	m_btnCancel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgArray)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgArray)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnProxy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CArrayGrid* m_pag;

	void LoadGrid();
	void CreateArray(COleVariant& var);

	BOOL m_bWasModified;
	CString m_sName;
	CString m_sClassname;
	CGridCell* m_pgcEdit;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGARRAY_H__07A103C1_B740_11D0_846E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgarray.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgArray.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "globals.h"
#include "DlgArray.h"
#include "gc.h"
#include "gca.h"
#include "celledit.h"
#include "gridhdr.h"
#include "grid.h"
#include "utils.h"
#include "arraygrid.h"
#include "hmmverr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ROW_COUNT 14

/////////////////////////////////////////////////////////////////////////////
// CDlgArray dialog
#define CX_VALUE 200

CDlgArray::CDlgArray(BOOL bNumberRows, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgArray::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgArray)
	//}}AFX_DATA_INIT


	m_pag = new CArrayGrid(bNumberRows);
}



CDlgArray::~CDlgArray()
{
	delete m_pag;
}

void CDlgArray::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgArray)
	DDX_Control(pDX, IDC_ARRAY_DLG_ICON, m_statIcon);
	DDX_Control(pDX, IDOK_PROXY, m_btnOK);
	DDX_Control(pDX, IDCANCEL, m_btnCancel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgArray, CDialog)
	//{{AFX_MSG_MAP(CDlgArray)
	ON_BN_CLICKED(IDOK_PROXY, OnProxy)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgArray message handlers


void CDlgArray::CreateArray(COleVariant& var)
{
	var.Clear();

	SAFEARRAY *psa = NULL;
	MakeSafeArray(&psa, VT_BSTR, 0);

	var.vt = VT_BSTR | VT_ARRAY;
	var.parray = psa;

}



BOOL CDlgArray::EditValue(IWbemServices* psvc, CString& sName, CGridCell* pgc)
{
	m_pgcEdit = pgc;
	CIMTYPE  cimtype = (CIMTYPE) pgc->type();

	if ((cimtype & ~CIM_FLAG_ARRAY) == CIM_OBJECT) {
		CString sClassname;
		::ClassFromCimtype(pgc->type().CimtypeString(), sClassname);
		m_pag->SetObjectParams(psvc, sClassname);
	}


	m_bWasModified = FALSE;
	m_sName = sName;

	HWND hwndFocus1 = ::GetFocus();

	pgc->Grid()->PreModalDialog();
	DoModal();
	pgc->Grid()->PostModalDialog();

	// Attempt to restore the window focus back to its original state
	// if it has changed.
	HWND hwndFocus2 = ::GetFocus();
	if ((hwndFocus1 != hwndFocus2) && ::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}

	return m_bWasModified;
}





BOOL CDlgArray::OnInitDialog()
{
	CDialog::OnInitDialog();

	SetWindowText(m_sName);

	// TODO: Add extra initialization here
	CRect rcOK;
	m_btnOK.GetClientRect(rcOK);
	m_btnOK.ClientToScreen(rcOK);
	ScreenToClient(rcOK);


	CRect rcIcon;
	m_statIcon.GetClientRect(rcIcon);
	m_statIcon.ClientToScreen(rcIcon);
	ScreenToClient(rcIcon);



	CRect rcGrid;


	GetClientRect(rcGrid);
	rcGrid.top = rcIcon.bottom + 8;
	rcGrid.bottom = rcGrid.top + m_pag->RowHeight() * ROW_COUNT - 1;
	rcGrid.left += 8;
	rcGrid.right -= 8;
	BOOL bDidCreateGrid;
	bDidCreateGrid = m_pag->Create(rcGrid, this, 100, TRUE);
	m_pag->SetColumnWidth(0, rcGrid.Width() - m_pag->GetRowHandleWidth(), FALSE);
	m_pag->Load(m_pgcEdit);


//	m_pag->m_vt =m_vt;
//	m_pag->Load(*m_pvarEdit, m_bReadOnly, m_vt);

	m_pag->RedrawWindow();


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//*********************************************************
// CDlgArray::OnOK
//
// Handle the ENTER key.  Instead of closing the dialog, we
// move the cell selection to the next cell.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CDlgArray::OnOK()
{
	SCODE sc;
	sc = m_pag->SyncCellEditor();
	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_INVALID_CELL_VALUE,  sc,   FALSE, NULL, _T(__FILE__),  __LINE__);
		return;
	}






	// Hitting ENTER selects the next row.  This allows the user
	// to conveniently enter a series of values.
	long nRows = m_pag->GetRows();
	long iRow = m_pag->GetSelectedRow();
	CGridCell* pgc = &m_pag->GetAt(iRow, 0);
	if (pgc->IsNull()) {
		return;
	}


	if (iRow < (nRows-1)) {
		if (m_pag->IsEditingCell()) {
			m_pag->EndCellEditing();
		}
		m_pag->EnsureRowVisible(iRow + 1);
		m_pag->UpdateWindow();
		m_pag->SelectCell(iRow+1, 0);
	}
}





//*************************************************************
// CDlgArray::OnProxy
//
// This method is called when the user clicks OK in the array
// dialog.  The standard IDOK is not used on the OK button so
// that the user can hit ENTER when entering a value in the array
// without closing the dialog.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CDlgArray::OnProxy()
{
	if (!m_pgcEdit->IsReadonly()) {
		// This does not save the array of dispatch pointers.
		m_pag->Save();
		m_bWasModified = m_pag->GetModified();
	}


	CDialog::OnOK();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgobjecttype.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgObjectType.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "DlgObjectType.h"
#include "utils.h"
#include "grid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgObjectType dialog


CDlgObjectType::CDlgObjectType(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgObjectType::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgObjectType)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgObjectType::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgObjectType)
	DDX_Control(pDX, IDC_CLASSNAME, m_edtClassname);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgObjectType, CDialog)
	//{{AFX_MSG_MAP(CDlgObjectType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgObjectType message handlers

BOOL CDlgObjectType::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_edtClassname.SetWindowText(m_sClass);
	SetWindowText(m_sTitle);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgObjectType::OnOK()
{
	CDialog::OnOK();
	m_edtClassname.GetWindowText(m_sClass);
}




int CDlgObjectType::EditObjType(CGrid* pGrid, CString& sCimtype)
{
	m_sTitle = "Object Type";

	SCODE sc;
	sc = ClassFromCimtype(sCimtype, m_sClass);
	if (FAILED(sc)) {
		m_sClass = "";
	}

	CString sClassPrev;
	sClassPrev = m_sClass;

	pGrid->PreModalDialog();
	int iResult = (int) DoModal();
	pGrid->PostModalDialog();

	if (iResult != IDOK) {
		m_sClass = sClassPrev;
	}

	if (::IsEmptyString(m_sClass)) {
		sCimtype = "object";
	}
	else {
		sCimtype = "object:" + m_sClass;
	}

	return iResult;
}



int CDlgObjectType::EditRefType(CGrid* pGrid, CString& sCimtype)
{
	m_sTitle = "Reference Type";
	SCODE sc;
	sc = ClassFromCimtype(sCimtype, m_sClass);

	if (FAILED(sc)) {
		m_sClass = "";
	}

	CString sClassPrev;
	sClassPrev = m_sClass;

	pGrid->PreModalDialog();
	int iResult = (int) DoModal();
	pGrid->PostModalDialog();

	if (iResult != IDOK) {
		m_sClass = sClassPrev;
	}

	if (::IsEmptyString(m_sClass)) {
		sCimtype = "ref";
	}
	else {
		sCimtype = "ref:" + m_sClass;
	}


	return iResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgobjecteditor.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgObjectEditor.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "DlgObjectEditor.h"
#include "grid.h"
#include "svbase.h"
#include "utils.h"
#include "hmmverr.h"


#define CY_HELPTEXT 16
#define CY_HELPTEXT_MARGIN 8



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif





/////////////////////////////////////////////////////////////////////////////
// CDlgObjectEditor dialog


CDlgObjectEditor::CDlgObjectEditor(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgObjectEditor::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgObjectEditor)
	//}}AFX_DATA_INIT

	m_pgc = NULL;
	m_pco = NULL;
	m_pcoEdit = NULL;
	m_bCreatingObject = FALSE;
}


void CDlgObjectEditor::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgObjectEditor)
	DDX_Control(pDX, IDC_STAT_HELPTEXT, m_statHelptext);
	DDX_Control(pDX, IDC_EDIT_CLASSNAME, m_edtClassname);
	DDX_Control(pDX, IDC_OK_PROXY, m_btnOkProxy);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgObjectEditor, CDialog)
	//{{AFX_MSG_MAP(CDlgObjectEditor)
	ON_BN_CLICKED(IDC_OK_PROXY, OnOkProxy)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgObjectEditor message handlers



BOOL CDlgObjectEditor::EditEmbeddedObject(IWbemServices* psvc, CString& sClassname, CGridCell* pgc)
{
	m_psvc = psvc;
	m_sClassname = sClassname;

	m_bCreatingObject = FALSE;
	m_pgc = pgc;

	LPUNKNOWN lpunk = m_pgc->GetObject();
	if (lpunk == NULL) {
		return FALSE;
	}

	HRESULT hr = lpunk->QueryInterface(IID_IWbemClassObject, (void**) &m_pco);
	SCODE sc;
	sc = GetScode(hr);
	if (FAILED(sc)) {
		lpunk->Release();
		m_pco = NULL;
		ASSERT(m_pco == NULL);
		ASSERT(m_pcoEdit == NULL);
		return FALSE;
	}
	lpunk->Release();
	lpunk = NULL;

	sc = m_pco->Clone(&m_pcoEdit);
	if (FAILED(sc)) {

		m_pco->Release();
		m_pco = NULL;
		ASSERT(m_pco == NULL);
		ASSERT(m_pcoEdit == NULL);
		return FALSE;
	}

	HWND hwndFocus1 = ::GetFocus();

	m_pgc->Grid()->PreModalDialog();
	int iResult = (int) DoModal();
	m_pgc->Grid()->PostModalDialog();

	// If the window focus has changed, attempt to restore it back to
	// the initial state.
	HWND hwndFocus2 = ::GetFocus();
	if ((hwndFocus1 != hwndFocus2) && ::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}

	BOOL bModified = FALSE;
	if (iResult == IDOK) {

		m_pgc->ReplaceObject((LPUNKNOWN) m_pcoEdit);
		bModified = TRUE;
	}

	m_pcoEdit->Release();
	m_pcoEdit = NULL;

	m_pco->Release();
	m_pco = NULL;

	ASSERT(m_pco == NULL);
	ASSERT(m_pcoEdit == NULL);
	return bModified;
}


BOOL CDlgObjectEditor::CreateEmbeddedObject(IWbemServices* psvc, CString& sClassname, CGridCell* pgc)
{
	ASSERT(psvc != NULL);
	m_psvc = psvc;


	ASSERT(m_pco == NULL);
	ASSERT(m_pcoEdit == NULL);

	m_sClassname = sClassname;

	m_bCreatingObject = TRUE;
	m_pgc = pgc;

	LPUNKNOWN lpunk = m_pgc->GetObject();
	if (lpunk != NULL) {
		ASSERT(FALSE);
		lpunk->Release();
		return FALSE;
	}

	HWND hwndFocus1 = ::GetFocus();

	m_pgc->Grid()->PreModalDialog();
	int iResult = (int) DoModal();
	m_pgc->Grid()->PostModalDialog();

	// If the window focus has changed, attempt to restore it back to
	// the initial state.
	HWND hwndFocus2 = ::GetFocus();
	if ((hwndFocus1 != hwndFocus2) && ::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}


	if (iResult == IDOK) {
		m_pgc->ReplaceObject((LPUNKNOWN) m_pcoEdit);
	}

	if (m_pcoEdit != NULL) {
		m_pcoEdit->Release();
		m_pcoEdit = NULL;
	}

	if (m_pco) {
		m_pco->Release();
		m_pco = NULL;
	}

	ASSERT(m_pco == NULL);
	ASSERT(m_pcoEdit == NULL);

	// The object was modified only if the user clicked OK
	return (iResult==IDOK);
}


BOOL CDlgObjectEditor::OnInitDialog()
{
	CDialog::OnInitDialog();

	SCODE sc = S_OK;

	m_bDidSelectClass = FALSE;
	if (m_bCreatingObject) {
		m_btnOkProxy.EnableWindow(TRUE);
	}
	else {
		CBSTR bsPropName;
		bsPropName = _T("__CLASS");
		COleVariant varPropValue;


		CIMTYPE cimtype;
		sc = m_pcoEdit->Get((CBSTR) bsPropName, 0, &varPropValue, &cimtype, NULL);
		if (SUCCEEDED(sc) && (cimtype == CIM_STRING)) {
			m_sClassname = varPropValue.bstrVal;
			m_edtClassname.SetWindowText(m_sClassname);
			m_edtClassname.EnableWindow(FALSE);
		}
		else {
			// !!!CR: Need to put up a dialog.
			ASSERT(FALSE);
		}


	}



	BOOL bSetFocusOnClassname = FALSE;
	BOOL bCellReadonly = m_pgc->IsReadonly();
	CSingleViewChild* psv;
	psv = (CSingleViewChild*) (void*) GetDlgItem(IDC_SINGLEVIEWCTRL);

	psv->SetEditMode(bCellReadonly ? EDITMODE_BROWSER : EDITMODE_STUDIO);

	DWORD_PTR dwTag = m_pgc->GetTagValue();
	//BOOL bExistsInDatabase = dwTag & CELL_TAG_EMBEDDED_OBJECT_IN_DATABASE;
	// !!!CR: How do we know whether or not this exists in the database?
	long bExistsInDatabase = FALSE;

	// Show the help message only when the user needs to enter the classname.
	m_statHelptext.ShowWindow(SW_HIDE);

	if (m_bCreatingObject) {
		if (!m_sClassname.IsEmpty()) {
			m_edtClassname.SetWindowText(m_sClassname);
			OnOK();
			m_edtClassname.EnableWindow(FALSE);
		}
		else {
			bSetFocusOnClassname = TRUE;
			m_edtClassname.SetFocus();

			CRect rcSvClient;
			psv->GetClientRect(rcSvClient);
			psv->ClientToScreen(rcSvClient);
			ScreenToClient(rcSvClient);

			CRect rcHelptext;
			rcHelptext.top = rcSvClient.top;
			rcHelptext.left = rcSvClient.left;
			rcHelptext.bottom = rcSvClient.top + CY_HELPTEXT;
			rcHelptext.right = rcSvClient.right;

			rcSvClient.top += CY_HELPTEXT + CY_HELPTEXT_MARGIN;
			psv->MoveWindow(rcSvClient);

			m_statHelptext.MoveWindow(rcHelptext);
			m_statHelptext.ShowWindow(SW_SHOW);

		}
		sc = psv->SelectObjectByPointer((LPUNKNOWN) m_psvc, (LPUNKNOWN) m_pcoEdit, bExistsInDatabase);
	}
	else {
		sc = psv->SelectObjectByPointer((LPUNKNOWN) m_psvc, (LPUNKNOWN) m_pcoEdit, bExistsInDatabase);
	}

	if (m_pcoEdit == NULL) {
		m_btnOkProxy.EnableWindow(FALSE);
	}

	return !bSetFocusOnClassname;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//*****************************************************************
// CDlgObjectEditor::OnOK
//
// This method is called when the user hits the "Enter" key while
// editing the classname edit box text.  Note that OnOK just signals
// us create an instance of the class specified in the edit box.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CDlgObjectEditor::OnOK()
{
	CString sClassname;
	m_edtClassname.GetWindowText(sClassname);

	DWORD dwFlags = m_pgc->GetFlags();
	BOOL bChildReadOnly = dwFlags & CELLFLAG_READONLY;
	if (bChildReadOnly) {
		return;
	}

	if (m_pcoEdit != NULL) {
		if (m_sClassname == sClassname) {
			return;
		}

		int iResult;
		CString sMessage;
		CString sTitle;
		sTitle.LoadString(IDS_WBEM_EMBEDDED_OBJECT);
		sMessage.LoadString(IDS_WARN_REPLACE_INSTANCE);
		iResult = MessageBox(sMessage, sTitle, MB_OKCANCEL);
		if (iResult == IDCANCEL) {
			return;
		}
	}



	// Switch to a different object for editing.
	CSingleViewChild* psv;
	psv = (CSingleViewChild*) (void*) GetDlgItem(IDC_SINGLEVIEWCTRL);

	SCODE sc = S_OK;
	if (m_pcoEdit != NULL) {
		sc = psv->SelectObjectByPointer((LPUNKNOWN) NULL, (LPUNKNOWN) NULL, FALSE);
		m_pcoEdit->Release();
		m_pcoEdit = NULL;
		m_btnOkProxy.EnableWindow(FALSE);
	}




	// First get the specified class
	CBSTR bsClassname = sClassname;
	sc = S_OK;

	CString sFormat;
	IWbemClassObject* pcoClass = NULL;
	HRESULT hr;
	if (m_psvc == NULL) {
		sc = E_FAIL;
	}
	else {
		hr = m_psvc->GetObject((BSTR) bsClassname, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pcoClass, NULL);
		sc = GetScode(hr);
	}
	TCHAR szMessage[512];
	if (FAILED(sc)) {
		sFormat.LoadString(IDS_INVALID_CLASS_NAME);

		_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) sClassname);
		HmmvErrorMsg(szMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		m_edtClassname.SetSel(0, -1);
		return;
	}

	// Now spawn an instance of the class.
	ASSERT(m_pcoEdit == NULL);
	hr = pcoClass->SpawnInstance(0, &m_pcoEdit);
	if (FAILED(sc)) {
		pcoClass->Release();

		sFormat.LoadString(IDS_ERR_CANT_CREATE_INSTANCE);
		_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) sClassname);

		HmmvErrorMsg(szMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		m_edtClassname.SetSel(0, -1);

		return;
	}
	pcoClass->Release();
	pcoClass = NULL;


	// Select the newly spawned instance in the SingleView control.
	psv->SetEditMode(EDITMODE_STUDIO);
	sc = psv->SelectObjectByPointer((LPUNKNOWN) m_psvc, (LPUNKNOWN) m_pcoEdit, FALSE);
	if (SUCCEEDED(sc)) {
		m_btnOkProxy.EnableWindow(TRUE);
	}
	m_sClassname = sClassname;

}

void CDlgObjectEditor::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();
}

void CDlgObjectEditor::OnOkProxy()
{
	CSingleViewChild* psv;
	psv = (CSingleViewChild*) (void*) GetDlgItem(IDC_SINGLEVIEWCTRL);
	SCODE sc;
	sc = psv->SaveData();
	if (SUCCEEDED(sc)) {
		CDialog::OnOK();
	}

}




BEGIN_EVENTSINK_MAP(CDlgObjectEditor, CDialog)
    //{{AFX_EVENTSINK_MAP(CSvDlg)
	ON_EVENT(CDlgObjectEditor, IDC_SINGLEVIEWCTRL, 6 /* GetWbemServices */, OnGetWbemServicesSingleviewctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CDlgObjectEditor::OnGetWbemServicesSingleviewctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	CGrid* pGrid = m_pgc->Grid();
	pGrid->GetWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgobjecttype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGOBJECTTYPE_H__9621ED31_2937_11D1_84A5_00C04FD7BB08__INCLUDED_)
#define AFX_DLGOBJECTTYPE_H__9621ED31_2937_11D1_84A5_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgObjectType.h : header file
//

class CGrid;

/////////////////////////////////////////////////////////////////////////////
// CDlgObjectType dialog

class CDlgObjectType : public CDialog
{
// Construction
public:
	CDlgObjectType(CWnd* pParent = NULL);   // standard constructor
//	LPCTSTR Cimtype() {return (LPCTSTR) m_sCimtype; }
//	void SetCimtype(LPCTSTR pszCimtype);
	BOOL EditObjType(CGrid* pGrid, CString& sObjtype);
	int EditRefType(CGrid* pGrid, CString& sReftype);



// Dialog Data
	//{{AFX_DATA(CDlgObjectType)
	enum { IDD = IDD_OBJECT_TYPE };
	CEdit	m_edtClassname;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgObjectType)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgObjectType)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CString m_sClass;
	CString m_sTitle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGOBJECTTYPE_H__9621ED31_2937_11D1_84A5_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgtime.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgTime.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "hmmverr.h"
#include "DlgTime.h"
#include "TimePicker.h"
#include "gc.h"
#include "grid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


enum {ID_TIMEPICKER=100, ID_DATEPICKER};


/////////////////////////////////////////////////////////////////////////////
// CDlgTime dialog


CDlgTime::CDlgTime(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgTime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgTime)
	//}}AFX_DATA_INIT

	m_pTimePicker = NULL;
	m_pDatePicker = NULL;
    m_bIsInterval = FALSE;
	m_pgc = NULL;
}

//----------------------------------------------------
CDlgTime::~CDlgTime()
{
	delete m_pTimePicker;
    if(!m_bIsInterval)
    {
    	delete m_pDatePicker;
    }
}

//----------------------------------------------------
void CDlgTime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgTime)
	DDX_Control(pDX, IDC_TIME_LABEL, m_timeLabel);
	DDX_Control(pDX, IDC_TIMEZONE, m_comboZone);
   	DDX_Control(pDX, IDC_INTERVAL, m_interval);
	//}}AFX_DATA_MAP
}

//----------------------------------------------------

BEGIN_MESSAGE_MAP(CDlgTime, CDialog)
	//{{AFX_MSG_MAP(CDlgTime)
	ON_EN_SETFOCUS(IDC_INTERVAL, OnSetfocusInterval)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgTime message handlers

#define CX_MARGIN 10
#define CY_MARGIN 7
#define CY_DATE_HEIGHT 14
#define CY_DATETIME 28

BOOL CDlgTime::OnInitDialog()
{
	CDialog::OnInitDialog();


    // Combobox for time zones.
	CRect rcComboClient;
	m_comboZone.GetClientRect(rcComboClient);
	int cyDateTime = rcComboClient.Height() + 3;

	CRect rcClient;
	GetClientRect(rcClient);

    // date picker.
	CRect rcTime;
	rcTime.left = rcClient.left + CX_MARGIN;
	rcTime.top = rcClient.top + CY_MARGIN;
	rcTime.right = rcClient.right - CX_MARGIN;
	rcTime.bottom = rcTime.top + cyDateTime;


	BOOL bDidCreate;

    if(m_bIsInterval)
    {
        m_pDatePicker = m_interval.FromHandle(m_interval.m_hWnd);
        ((CEdit *)m_pDatePicker)->SetLimitText(8);
        ((CEdit *)m_pDatePicker)->SetWindowText(m_days);
        m_comboZone.ShowWindow(SW_HIDE);
        m_timeLabel.ShowWindow(SW_HIDE);
        SetWindowText(_T("Interval"));
    }
    else
    {
        m_interval.ShowWindow(SW_HIDE);
		GetDlgItem(IDC_INTERVAL2)->ShowWindow(SW_HIDE);
//        m_interval.DestroyWindow();

        // use the DatePicker instead.
	    m_pDatePicker = new CTimePicker;
	    bDidCreate = ((CTimePicker*)m_pDatePicker)->CustomCreate(0, rcTime, this, ID_DATEPICKER);
	    if (bDidCreate)
        {
		    ((CTimePicker*)m_pDatePicker)->ShowWindow(SW_SHOW);
	    }
    }

    // time picker.
	CRect rcDate;
	rcDate.left = rcClient.left + CX_MARGIN;
	rcDate.top = rcTime.bottom + 2 * CY_MARGIN;
	rcDate.right = rcClient.right - CX_MARGIN;
	rcDate.bottom = rcDate.top + cyDateTime;

    m_pTimePicker = new CTimePicker;
	bDidCreate = m_pTimePicker->CustomCreate(DTS_TIMEFORMAT, rcDate, this, ID_TIMEPICKER);
	if(bDidCreate  && m_bIsInterval)
    {
        /*
        TCHAR buf[30];
        // get the user defined time format string.
        if(GetLocaleInfo(LOCALE_USER_DEFAULT,
                        LOCALE_STIMEFORMAT,
                        buf, 30))
        {
            //look for the last 's'.

            // append 'X'.
*/

            // set the format.
            HWND picker = m_pTimePicker->GetSafeHwnd();
            DateTime_SetFormat(picker, _T("HH'h 'mm'm 'ss's'"));

		m_pTimePicker->ShowWindow(SW_SHOW);
	}

	SYSTEMTIME systime;
	BOOL x = DateTime_SetSystemtime(m_pTimePicker->m_hWnd, GDT_VALID, &m_systime);
	DateTime_GetSystemtime(m_pTimePicker->m_hWnd, &systime);
    if(!m_bIsInterval)
    {
    	DateTime_SetSystemtime(m_pDatePicker->m_hWnd, GDT_VALID, &m_systime);
    }

	LoadComboBoxWithZones();

	int iZone = MapOffsetToZone(m_nOffsetMinutes);
	m_comboZone.SetCurSel(iZone);

	BOOL bIsReadOnly = m_pgc->IsReadonly();

	if (bIsReadOnly) {
		m_comboZone.EnableWindow(FALSE);
		m_interval.EnableWindow(FALSE);
	}


	if (bIsReadOnly) {
		m_comboZone.EnableWindow(FALSE);
		m_timeLabel.EnableWindow(FALSE);
		if (m_pTimePicker) {
			m_pTimePicker->EnableWindow(FALSE);
		}
		if (m_pDatePicker) {
			m_pDatePicker->EnableWindow(FALSE);
		}
	}





	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//**************************************************************
// CDlgTime::EditTime
//
// Edit a time value.
//
// Parameters:
//		[in, out] COleVariant& varTime
//			A variant which may either be a VT_BSTR or a VT_NULL.
//			If it is a VT_BSTR, the bstrVal member contains the time
//			string in DTMF format.  If VT_NULL, a default time
//			should be displayed in the dialog.
//
// Returns:
//		The edited time is returned via the varTime parameter.
//
// DTMF time format: YYYYMMDDhhmmssuuuuuu+/-GGG
//				Y = year, M = month, D = day, m = minute, s = seconds
//				u = microseconds, G = offset from Greenwich mean time.
//
// DTMF interval format: DDDDDDDDhhmmssuuuuuu:000
//				D = day, m = minute, s = seconds, u = microseconds.
//**************************************************************
BOOL CDlgTime::EditTime(CGridCell* pgcTime)
{
	HWND hwndFocus = ::GetFocus();
	m_pgc = pgcTime;

	if(!pgcTime->IsValid())
	{
		if(IDOK != MessageBox(L"The cell value is not compatible with its type\nDo you wish to set the cell value to <empty> before continuing?", L"Invalid Value", MB_OKCANCEL))
			return FALSE;
		pgcTime->SetToNull();
	}

	SCODE sc;
	BOOL bWasNull = pgcTime->IsNull();

	// if null...
	if(bWasNull)
	{
		// look at the qualifier.
		m_bIsInterval = pgcTime->GetFlags() & CELLFLAG_INTERVAL;
	}
	else
	{
		// look at the actual value.
		m_bIsInterval = pgcTime->IsInterval();
	}

    // put the cell's time into the class vars.
    if(m_bIsInterval)
    {
	    sc = pgcTime->GetInterval(m_days, m_systime);
        m_nOffsetMinutes = 0;
	    ASSERT(sc == S_OK);
    }
    else
    {
	    sc = pgcTime->GetTime(m_systime, m_nOffsetMinutes);
	    ASSERT(sc == S_OK);
    }

    // display the time editor.
	pgcTime->Grid()->PreModalDialog();
	int iResult = (int) DoModal();
	pgcTime->Grid()->PostModalDialog();
	if((iResult == IDOK) && (!m_pgc->IsReadonly()))
    {
        // move the new time back into the cell.
        if(m_bIsInterval)
        {
		    sc = pgcTime->SetInterval(m_days, m_systime);
		    ASSERT(sc == S_OK);
        }
        else
        {
		    sc = pgcTime->SetTime(m_systime, m_nOffsetMinutes);
		    ASSERT(sc == S_OK);
        }

		if ((hwndFocus != NULL) && ::IsWindow(hwndFocus)) {
			::SetFocus(hwndFocus);
		}
		return TRUE;
	}
	else // user cancelled....
    {
        // set it back to null.
		if(bWasNull && !pgcTime->IsNull())
        {
			pgcTime->SetToNull();
		}
	}

	if ((hwndFocus != NULL) && ::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}
	return FALSE;
}

//----------------------------------------------------
typedef struct tagZones
{
	TCHAR* m_szZone;
	int m_nMinutes;
} ZONE_MAP;

ZONE_MAP aZoneMap[] =
{
	{_T("GMT -12:00"), -(12 * 60)},
	{_T("GMT -11:00"), -(11 * 60)},
	{_T("GMT -10:00"), -(10 * 60)},
	{_T("GMT -09:00"), -(9 * 60)},
	{_T("GMT -08:00"), -(8 * 60)},
	{_T("GMT -07:00"), -(7 * 60)},
	{_T("GMT -06:00"), -(6 * 60)},
	{_T("GMT -05:00"), -(5 * 60)},
	{_T("GMT -04:00"), -(4 * 60)},
	{_T("GMT -03:30"), -(3 * 60 + 30)},
	{_T("GMT -03:00"), -(3 * 60)},
	{_T("GMT -02:00"), -(2 * 60)},
	{_T("GMT -01:00"), -(1 * 60)},
	{_T("GMT"), 0},
	{_T("GMT +01:00"), (1 * 60)},
	{_T("GMT +02:00"), (2 * 60)},
	{_T("GMT +03:00"), (3 * 60)},
	{_T("GMT +03:30"), (3 * 60 + 30)},
	{_T("GMT +04:00"), (4 * 60)},
	{_T("GMT +04:30"), (4 * 60 + 30)},
	{_T("GMT +05:00"), (5 * 60)},
	{_T("GMT +05:30"), (5 * 60 + 30)},
	{_T("GMT +06:00"), (6 * 60)},
	{_T("GMT +07:00"), (7 * 60)},
	{_T("GMT +08:00"), (8 * 60)},
	{_T("GMT +09:00"), (9 * 60)},
	{_T("GMT +09:30"), (9 * 60 + 30)},
	{_T("GMT +10:00"), (10 * 60)},
	{_T("GMT +11:00"), (11 * 60)},
	{_T("GMT +12:00"), (12 * 60)}
};

//----------------------------------------------------
void CDlgTime::LoadComboBoxWithZones()
{
	int nZones = sizeof(aZoneMap) / sizeof(ZONE_MAP);
	for (int iZone =0; iZone < nZones; ++iZone)
    {
		m_comboZone.AddString(aZoneMap[iZone].m_szZone);
	}
}

//----------------------------------------------------
int CDlgTime::MapZoneToOffset()
{
	int iZone = m_comboZone.GetCurSel();
	ASSERT(iZone >= 0 && iZone < (sizeof(aZoneMap) / sizeof(ZONE_MAP)));
	int nOffsetMinutes = aZoneMap[iZone].m_nMinutes;
	return nOffsetMinutes;
}

//----------------------------------------------------
int CDlgTime::MapOffsetToZone(int iOffsetMinutes)
{
	int nZones = sizeof(aZoneMap) / sizeof(ZONE_MAP);

	if (iOffsetMinutes < aZoneMap[0].m_nMinutes)
    {
		HmmvErrorMsg(IDS_ERR_TIMEZONE_RANGE,  S_OK,
                        FALSE,  NULL, _T(__FILE__),  __LINE__);
		return 0;
	}

	if (iOffsetMinutes > aZoneMap[nZones - 1].m_nMinutes)
    {
		HmmvErrorMsg(IDS_ERR_TIMEZONE_RANGE,  S_OK,
                        FALSE,  NULL, _T(__FILE__),  __LINE__);
		ASSERT(FALSE);
		return nZones - 1;
	}



	for (int iZone =0; iZone < nZones; ++iZone)
    {
		if (iOffsetMinutes <= aZoneMap[iZone].m_nMinutes)
        {
			if (aZoneMap[iZone].m_nMinutes == iOffsetMinutes)
            {
				return iZone;
			}


			// The offset is sonewhere between this entry and
			// the previous one.  Pick the entry that is closest
			// to the specified offset.
			HmmvErrorMsg(IDS_ERR_TIMEZONE_RANGE,  S_OK,
                            FALSE,  NULL, _T(__FILE__),  __LINE__);

			int iDelta1 = iOffsetMinutes - aZoneMap[iZone-1].m_nMinutes;
			int iDelta2 = aZoneMap[iZone].m_nMinutes - iOffsetMinutes;
			ASSERT(iDelta1 > 0);
			ASSERT(iDelta2 > 0);
			if (iDelta1 > iDelta2)
            {
				return iZone;
			}
			else
            {
				return iZone - 1;
			}
		}
	}
	ASSERT(FALSE);
	return nZones - 1;
}

//----------------------------------------------------
void CDlgTime::OnOK()
{
    if(m_bIsInterval)
    {
        m_pDatePicker->GetWindowText(m_days);
		m_systime.wYear = 1900;
		m_systime.wMonth = 1;
		m_systime.wDayOfWeek = 1;
		m_systime.wDay = 1;
    }
    else // itsa dateTime...
    {
    	SYSTEMTIME systimeDate;
        DWORD dwResultDate = DateTime_GetSystemtime(m_pDatePicker->m_hWnd, &systimeDate);
	    if(dwResultDate == GDT_VALID)
        {
		    m_systime.wYear = systimeDate.wYear;
		    m_systime.wMonth = systimeDate.wMonth;
		    m_systime.wDayOfWeek = systimeDate.wDayOfWeek;
		    m_systime.wDay = systimeDate.wDay;
	    }
    }

	SYSTEMTIME systimeTime;
	DWORD dwResultTime = DateTime_GetSystemtime(m_pTimePicker->m_hWnd, &systimeTime);
	if(dwResultTime == GDT_VALID)
    {
		m_systime.wHour = systimeTime.wHour;
		m_systime.wMinute = systimeTime.wMinute;
		m_systime.wSecond = systimeTime.wSecond;
		m_systime.wMilliseconds = systimeTime.wMilliseconds;
	}

	m_nOffsetMinutes = MapZoneToOffset();

	CDialog::OnOK();
}

//----------------------------------------------------
BOOL CDlgTime::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
    LPNMHDR hdr = (LPNMHDR)lParam;
    LPNMDATETIMECHANGE lpChange;
	switch(hdr->code)
    {
    case DTN_DATETIMECHANGE:
        {
            lpChange = (LPNMDATETIMECHANGE)lParam;
            DoDateTimeChange(lpChange);
        }
		break;

    case DTN_FORMATQUERY:
        {
            LPNMDATETIMEFORMATQUERY lpDTFQuery = (LPNMDATETIMEFORMATQUERY)lParam;
            // Process DTN_FORMATQUERY to ensure that the control
            // displays callback information properly.
            DoFormatQuery(hdr->hwndFrom, lpDTFQuery);
        }
		break;

    case DTN_FORMAT:
        {
            LPNMDATETIMEFORMAT lpNMFormat = (LPNMDATETIMEFORMAT) lParam;
            // Process DTN_FORMAT to supply information about callback
            // fields (fields) in the DTP control.
            DoFormat(hdr->hwndFrom, lpNMFormat);
        }
		break;

    case DTN_WMKEYDOWN:
        {
            LPNMDATETIMEWMKEYDOWN lpDTKeystroke =
                        (LPNMDATETIMEWMKEYDOWN)lParam;
            // Process DTN_WMKEYDOWN to respond to a user's keystroke in
            // a callback field.
            DoWMKeydown(hdr->hwndFrom, lpDTKeystroke);
        }
		break;

	}    // All of the above notifications require the owner to return zero.
    return FALSE;
}

//----------------------------------------------------
void CDlgTime::DoFormatQuery(HWND hwndDP,
                              LPNMDATETIMEFORMATQUERY lpDTFQuery)
{
    HDC hdc;
    HFONT hFont, hOrigFont;

    //  Prepare the device context for GetTextExtentPoint32 call.
    hdc = ::GetDC(hwndDP);
    hFont = (HFONT)GetFont();

    if(!hFont)
        hFont = (HFONT)::GetStockObject(DEFAULT_GUI_FONT);

    hOrigFont = (HFONT)SelectObject(hdc, hFont);

    // Check to see if this is the callback segment desired. If so,
    // use the longest text segment to determine the maximum
    // width of the callback field, and then place the information into
    // the NMDATETIMEFORMATQUERY structure.
    if(!_tcscmp(_T("XX"),lpDTFQuery->pszFormat))
        GetTextExtentPoint32(hdc, _T("88888"), 5,
                                &lpDTFQuery->szMax);

    // Reset the font in the device context; then release the context.
    SelectObject(hdc,hOrigFont);
    ::ReleaseDC(hwndDP, hdc);
}

//----------------------------------------------------
void CDlgTime::DoFormat(HWND hwndDP,
                          LPNMDATETIMEFORMAT lpDTFormat)
{
    _stprintf(lpDTFormat->szDisplay,_T("%6.6u"),
                lpDTFormat->st.wMilliseconds);

    int x = 1;
}
//----------------------------------------------------
void CDlgTime::DoWMKeydown(HWND hwndDP,
                           LPNMDATETIMEWMKEYDOWN lpDTKeystroke)
{
    short delta =1;
    if(!_tcscmp(lpDTKeystroke->pszFormat,_T("XX")))
    {
        switch(lpDTKeystroke->nVirtKey)
        {
        case VK_DOWN:
        case VK_SUBTRACT:
            delta = -1;  // fall through
        case VK_UP:
        case VK_ADD:
                lpDTKeystroke->st.wMilliseconds += delta;
                break;
        }
    }
}

//----------------------------------------------------
void CDlgTime::DoDateTimeChange(LPNMDATETIMECHANGE lpChange)
{
	switch(lpChange->nmhdr.idFrom)
    {
	case ID_DATEPICKER:
		m_systime.wYear = lpChange->st.wYear;
		m_systime.wMonth = lpChange->st.wMonth;
		m_systime.wDay = lpChange->st.wDay;
		break;
	case ID_TIMEPICKER:
		m_systime.wHour = lpChange->st.wHour;
		m_systime.wMinute = lpChange->st.wMinute;
		m_systime.wSecond = lpChange->st.wSecond;
		m_systime.wMilliseconds = lpChange->st.wMilliseconds;
		break;
	}
}

void CDlgTime::OnSetfocusInterval()
{
	m_interval.SetSel(0, -1);
}
/////////////////////////////////////////////////////////////////////////////
// CEdtInterval

CEdtInterval::CEdtInterval()
{
}

CEdtInterval::~CEdtInterval()
{
}


BEGIN_MESSAGE_MAP(CEdtInterval, CEdit)
	//{{AFX_MSG_MAP(CEdtInterval)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEdtInterval message handlers

void CEdtInterval::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CEdit::OnLButtonDown(nFlags, point);
	SetSel(0, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\dlgtime.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGTIME_H__F2F813C2_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_)
#define AFX_DLGTIME_H__F2F813C2_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgTime.h : header file
//

class CGridCell;


/////////////////////////////////////////////////////////////////////////////
// CEdtInterval window

class CEdtInterval : public CEdit
{
// Construction
public:
	CEdtInterval();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEdtInterval)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEdtInterval();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEdtInterval)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDlgTime dialog
class CTimePicker;

class CDlgTime : public CDialog
{
// Construction
public:
	CDlgTime(CWnd* pParent = NULL);   // standard constructor
	~CDlgTime();
	BOOL EditTime(CGridCell* pgc);


// Dialog Data
	//{{AFX_DATA(CDlgTime)
	enum { IDD = IDD_TIME };
	CEdtInterval m_interval;
	CStatic	m_timeLabel;
	CComboBox	m_comboZone;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgTime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgTime)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSetfocusInterval();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CTimePicker* m_pTimePicker;
	CWnd *m_pDatePicker;

    CString m_days;

    BOOL m_bIsInterval;
	SYSTEMTIME m_systime;
	int m_nOffsetMinutes;

	void DoDateTimeChange(LPNMDATETIMECHANGE lpChange);
	void LoadComboBoxWithZones();
	int MapZoneToOffset();
	int MapOffsetToZone(int iOffsetMinutes);
    void DoFormatQuery(HWND hwndDP,  
                       LPNMDATETIMEFORMATQUERY lpDTFQuery);
    void DoFormat(HWND hwndDP, 
                  LPNMDATETIMEFORMAT lpDTFormat);
    void DoWMKeydown(HWND hwndDP, 
                     LPNMDATETIMEWMKEYDOWN lpDTKeystroke);
	CGridCell* m_pgc;
};


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGTIME_H__F2F813C2_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gca.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef _gca_h
#define _gca_h


class CGridCell;
class CGrid;
class CGridRow;




////////////////////////////////////////////////////////////////////////
// CGridCellArray
//
// A class to implement a two-dimensional array of grid cells.
//
// Note that this class only stores the data and does not have
// rendering capability.
///////////////////////////////////////////////////////////////////////
class CGridCellArray
{
public:
	CGridCellArray(int nRows, int nCols);
	~CGridCellArray();
	void SetGrid(CGrid* pGrid) {m_pGrid = pGrid; }
	CGridCell& GetAt(int iRow, int iCol);
	CGridRow& GetRowAt(int iRow);
	void GetSize(int& nRows, int& nCols) {nRows = m_nRows; nCols = m_nCols; }
	int GetRows() {return m_nRows; }
	int GetCols() {return m_nCols; }

	void AddRow() { InsertRowAt(m_nRows); }
	void InsertRowAt(int iRow);
	void DeleteRowAt(int iRow);

	void AddColumn() {InsertColumnAt(m_nCols); }
	void InsertColumnAt(int iCol);
	void DeleteColumnAt(int iCol);
	void DeleteAllRows();
	void DeleteAll();
	void SetRowState(int iRow, int iMask, int iState);
	void GetRowState(int iRow, int& iState);
	void SwapRows(int iRow1, int iRow2);
	void Sort(CGrid* pGrid, int iRowFirst, int iRowLast, int iSortColumn, BOOL bAscending);
	int m_iSelectedRow;
	int m_iSelectedCol;


private:
	void RenumberRows(int iStartRow=0);

//	CWordArray m_aiRowState;
	CPtrArray m_aRows;
	int m_nCols;
	int m_nRows;
	CGrid* m_pGrid;
};



#endif //_gca_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gc.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _gc_h
#define _gc_h

#include "wbemidl.h"

class CGrid;
class CArrayGrid;
class CGridRow;

///////////////////////////////////////////////////////////////////////////
// CGridCell
//
// A class to implement one cell in the grid.
//
// Note that this class only stores the data and does not have
// any rendering capability.
//////////////////////////////////////////////////////////////////////////


#define CELLFLAG_READONLY  1
#define CELLFLAG_ARRAY     2
#define CELLFLAG_INTERVAL  4
#define CELLFLAG_NOTNULL   8
#define CELLFLAG_IMPLEMENTED   16

#define ICOL_ARRAY_VALUE  4
#define ICOL_ARRAY_NAME   2


enum CellType 
	{	
		CELLTYPE_VOID=0,			// An empty cell.
		CELLTYPE_ATTR_TYPE,			// An attribute type.
		CELLTYPE_NAME,				// A property or attribute name.
		CELLTYPE_VARIANT,			// A variant value.
		CELLTYPE_CIMTYPE_SCALAR,	// A cimtype that is not an array
		CELLTYPE_CIMTYPE,			// A cimtype
		CELLTYPE_CHECKBOX,			// A checkbox
		CELLTYPE_PROPMARKER,		// A property marker icon
		CELLTYPE_ENUM_TEXT			// An enum edit box.
	};



enum PropMarker 
	{
		PROPMARKER_NONE,			// A default, "blank" property marker.
		PROPMARKER_KEY,				// A key property
		PROPMARKER_RLOCAL,			// A read-only local property
		PROPMARKER_LOCAL,			// A read/write local property
		PROPMARKER_RINHERITED,		// Read-only inherited
		PROPMARKER_INHERITED,
		PROPMARKER_RSYS,			// A read-only system property
		PROPMARKER_SYS,				// A system property
		METHODMARKER_IN,			// method's input parm.
		METHODMARKER_OUT,			// method's output parm.
		METHODMARKER_INOUT,			// method's input/output parm.
		METHODMARKER_RETURN			// method's return value.
	};




#include "gctype.h"



class __declspec(dllexport) CGridCell
{
public:
	CGridCell(CGrid* pgrid, CGridRow* pRow);
	CGridCell(CGridCell& gcSrc);
	const CGcType& type() {return  m_type; }

	BOOL IsObject() {return m_type.IsObject(); }
	BOOL IsArray() {return m_type.IsArray(); } 
	BOOL IsCheckbox() {return m_type.IsCheckbox(); }
	BOOL IsTime(){return m_type.IsTime(); }
	BOOL IsReadonly() {return m_dwFlags & CELLFLAG_READONLY; }
	BOOL IsNull() {return m_varValue.vt == VT_NULL; }
	BOOL IsValid();

	CGrid* Grid() {return m_pGrid; }

	
	SCODE SetValueForQualiferType(VARTYPE vt);
	SCODE SetValueForQualifierType(VARTYPE vt);

	SCODE SetValue(CGcType& type, LPCTSTR pszValue);
	SCODE SetValue(CGcType& type, VARIANTARG& var);
	SCODE SetValue(CGcType& type, UINT idResource);
	SCODE SetValue(CGcType& type, BSTR bsValue);

	SCODE SetValue(CellType iType, LPCTSTR pszValue, CIMTYPE cimtype);
	SCODE SetValue(CellType iType, VARIANTARG& var, CIMTYPE cimtype, LPCTSTR pszCimtype=NULL);
	SCODE SetValue(CellType iType, UINT idResource);
	SCODE SetValue(CellType iType, BSTR bsValue, CIMTYPE cimtype);
	void Clear();

	BOOL HasValidValue();


	void GetValue(CString& sValue, CIMTYPE& cimtype);
	UINT GetValue() {return m_idResource; }
	void GetValue(COleVariant& var, CIMTYPE& cimtype);

	void FindCellPos(int& iRow, int& iCol);
	void SetThisCellToCurrentTime();

	// The property marker flags are for cells of CELLTYPE_PROPMARKER only.
	// The marker flags are used to mark cells as being 
	void SetPropmarker(PropMarker propmarker); 
	PropMarker GetPropmarker() {return m_propmarker; }

	DWORD SetFlags(DWORD dwMask, DWORD dwFlags);
	DWORD GetFlags() {return m_dwFlags; }
	void SetTagValue(DWORD_PTR dwTagValue) {m_dwTagValue = dwTagValue; }
	DWORD_PTR GetTagValue() {return m_dwTagValue; }
	void SetModified(BOOL bModified);
	BOOL GetModified() {return m_bWasModified; }
	void SetBuddy(int iColBuddy) {m_iColBuddy = iColBuddy; }
	int GetBuddy() {return m_iColBuddy; }
	void SetType(CellType iType) {m_type.SetCellType(iType); m_saEnum.RemoveAll(); }
	CellType GetType() {return (CellType) m_type; }
	void SetToNull();
	VARTYPE GetVariantType() {return (VARTYPE) m_type; }

	void SetEnumeration(CStringArray& saEnumValues);
	CGridCell& operator=(CGridCell& gcSrc);
	void MakeArray(BOOL bIsArray) {m_type.MakeArray(); }
	void EditArray();
	void EditTime();
	LPUNKNOWN GetObject();
	void ReplaceObject(LPUNKNOWN lpunk);
	void EditObject();

	BOOL GetCheck();
	void SetCheck(BOOL bChecked);
	void SetEnum(CStringArray& sa);
	CStringArray& GetEnum();

	CIMTYPE GetCimtype() {return (CIMTYPE) m_type; }
	void SetCimtype(CIMTYPE cimtype, LPCTSTR pszCimtype=NULL);

	bool IsInterval(void);
	SCODE GetTimeString(CString& sTime);
	SCODE SetTime(SYSTEMTIME& systime, int nOffset);
	SCODE GetTime(SYSTEMTIME& systime, int& nOffset);
    SCODE GetInterval(CString& sTime, SYSTEMTIME &st);
    SCODE SetInterval(CString sTime, SYSTEMTIME st);

	void DoSpecialEditing();
	BOOL RequiresSpecialEditing();


	int Compare(CGridCell* pgc);
	SCODE ChangeVariantType(VARTYPE vt);
	SCODE ChangeType(const CGcType& type);

	void SetShowArrayRowNumbers(BOOL bNumberArrayRows) {m_bNumberArrayRows = bNumberArrayRows;}

private:

	void ChangeArrayType(CIMTYPE cimtypeDst);
	SCODE CopyObjectArray(COleVariant& varDst, COleVariant& varSrc);
	LPCTSTR MapCimtypeToString(CIMTYPE cimtype);

	// Cell comparison methods.
	int CompareCimtypeValues(CGridCell* pgc);
	int CompareCimtypeUint8(CGridCell* pgc);
	int CompareCimtypeSint8(CGridCell* pgc);
	int CompareCimtypeUint16(CGridCell* pgc);
	int CompareCimtypeSint16(CGridCell* pgc);
	int CompareCimtypeSint32(CGridCell* pgc);
	int CompareCimtypeUint32(CGridCell* pgc);
	int CompareCimtypeUint64(CGridCell* pgc);
	int CompareCimtypeSint64(CGridCell* pgc);
	int CompareCimtypeString(CGridCell* pgc);
	int CompareCimtypeBool(CGridCell* pgc);
	int CompareCimtypeReal32(CGridCell* pgc);
	int CompareCimtypeReal64(CGridCell* pgc);
	int CompareCimtypeDatetime(CGridCell* pgc);
	int CompareCimtypeChar16(CGridCell* pgc);
	int CompareCimtypes(CGridCell* pgc);

	int CompareDifferentCelltypes(CGridCell* pgc);
	int DefaultCompare(CGridCell* pgc);

	int CompareStrings(CGridCell* pgc);

	__int64 ToInt64(SCODE& sc);
	unsigned __int64 ToUint64(SCODE& sc);
	BOOL IsNumber(LPCTSTR pszValue);
	int CompareNumberToString(unsigned __int64 ui64Op1, LPCTSTR pszValue);
	void SetDefaultValue();

	CGcType m_type;
	COleVariant m_varValue;
	BOOL m_bWasModified; 
	BOOL m_bIsKey;
	int m_iColBuddy;
	DWORD m_dwFlags;
	DWORD_PTR m_dwTagValue;
	CStringArray m_saEnum;
	friend class CArrayGrid;
	UINT m_idResource;
	PropMarker m_propmarker;

	CGrid* m_pGrid;
	CGridRow* m_pRow;

	BOOL m_bNumberArrayRows; // Should array dialogs show row numbers (defaults to TRUE)
};



class __declspec(dllexport) CGridRow
{
public:
	CGridRow(CGrid* pGrid, int nCols);
	~CGridRow();

	CGrid* Grid() {return m_pGrid; }
	int GetRow() {return m_iRow; }


	// the flags are probably unused, but grep the code to make sure
	// before you use it.
	DWORD GetFlags() {return m_dwFlags; }
	void SetFlags(DWORD dwFlags) {m_dwFlags = dwFlags; }

	// The tag value is free to be used for anything you want
	DWORD GetTagValue() {return m_dwTag; }
	void SetTagValue(DWORD dwTag) {m_dwTag = dwTag; }

	void GetMethodSignatures(IWbemClassObject **inSig, IWbemClassObject **outSig) 
						{*inSig = m_inSig; *outSig = m_outSig; }
	void SetMethodSignatures(IWbemClassObject *inSig, IWbemClassObject *outSig) 
						{m_inSig = inSig; m_outSig = outSig; }

	int GetCurrMethodID(void) {return m_currID;};
	void SetCurrMethodID(int val) {if(m_currID != -1) m_currID = val;};
	
	void AddColumn() {InsertColumnAt((int) m_aCells.GetSize()); }
	void InsertColumnAt(int iCol);
	void DeleteColumnAt(int iCol);

	void SetModified(BOOL bModified = TRUE);
	BOOL GetModified() {return m_bModified; }

	CGridCell& operator[](int iCol);
	int FindCol(CGridCell* pgc);
	void FindCell(CGridCell* pgc, int& iRow, int& iCol);


	void SetState(int iMask, int iState);
	int GetState() {return m_iState; }

	// The flavor, readonly, and IsKey flags apply only to rows that
	// are properties.
	long GetFlavor() {return m_lFlavor; }
	void SetFlavor(long lFlavor) {m_lFlavor = lFlavor; }

	void SetReadonly(BOOL bReadonly = TRUE) {m_bReadonly = bReadonly; }
	void SetReadonlyEx(BOOL bReadonly = TRUE);
	BOOL IsReadonly() {return m_bReadonly; }

	void SetIsKey(BOOL bIsKey = FALSE) {m_bIsKey = bIsKey; }
	BOOL IsKey() {return m_bIsKey; }
	int GetSize() {return (int) m_aCells.GetSize(); }
	void Redraw();

private:
	friend class CGridCellArray;
	CGrid* m_pGrid;
	int m_iRow;
	CPtrArray m_aCells;
	long m_lFlavor;
	DWORD m_dwFlags;
	DWORD m_dwTag;
	BOOL m_bModified;
	BOOL m_bReadonly;
	BOOL m_bIsKey;
	int m_iState;

	// for method storage
	IWbemClassObject *m_inSig, *m_outSig;
	// for methodID management.
	int m_currID;
};

#endif //_gc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gca.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "globals.h"
#include "gca.h"
#include "grid.h"
#include "celledit.h"
#include "core.h"





//*****************************************************
// CGridCellArray::~CGridCellArray
//
// The destructor for the grid cell array.
//
//****************************************************
CGridCellArray::~CGridCellArray()
{
	DeleteAllRows();
}


//*****************************************************
// CGridCellArray::CGridCellArray
//
// The constructor for an array of grid cells.
//
//******************************************************
CGridCellArray::CGridCellArray(int nRows, int nCols)
{
	m_pGrid = NULL;

	m_nCols = 0;
	m_nRows = 0;
	m_iSelectedRow = -1;
	m_iSelectedCol = 1;

	while (--nRows >= 0 ) {
		AddRow();
	}

	while (--nCols >= 0) {
		AddColumn();
	}
	RenumberRows();

	ASSERT(m_nRows == m_aRows.GetSize());
}




//*************************************************************
// CGridCellArray::SetRowState
//
// Set the specified state flags for the given row.
//
// Parameters:
//		int iRow
//			The row to modify.
//
//		int iMask
//			A mask with ones where the state bits will be modified.
//
//		int iState
//			The bits in the fields specified by iMask will be stored
//			into the row's state flags.  Other bits in the row's state
//			flags will not be modified.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CGridCellArray::SetRowState(int iRow, int iMask, int iState)
{
	ASSERT(m_nRows == m_aRows.GetSize());

	CGridRow& row = GetRowAt(iRow);
	row.SetState(iMask, iState);
}




//**************************************************************
// CGridCellArray::GetRowState
//
// Return the state of the specified row.
//
// Parameters:
//		int iRow
//			The row index.
//
//		int& iState
//			The place to return the row's state.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCellArray::GetRowState(int iRow, int& iState)
{
	ASSERT(m_nRows == m_aRows.GetSize());

	CGridRow& row  = GetRowAt(iRow);
	iState = (int) row.GetState();
}






//*************************************************
// CGridCellArray::GetAt
//
// Get the grid cell at the specified coordinates.
//
// Parameters:
//		int iRow
//			The zero-based row index of the cell.
//
//		int iCol
//			The zero-based column index of the cell.
//
//*************************************************
CGridCell& CGridCellArray::GetAt(int iRow, int iCol)
{
	ASSERT(m_nRows == m_aRows.GetSize());
	ASSERT((iRow >= 0 ) && (iRow < m_aRows.GetSize()));

	CGridRow& row = GetRowAt(iRow);
	return row[iCol];
}





//*************************************************
// CGridCellArray::InsertRowAt
//
// Insert an empty row in the grid cell array at the
// specified location.
//
// Parameters:
//		int iRow
//			This specifies where the row will be inserted.
//			After the insertion, this is the index of the
//			new row.
//
// Returns:
//		Nothing.
//*************************************************
void CGridCellArray::InsertRowAt(int iRow)
{
	ASSERT(m_nRows == m_aRows.GetSize());
	CGridRow* pRow = new CGridRow(m_pGrid, m_nCols);
	m_aRows.InsertAt(iRow, pRow, 1);
	++m_nRows;

	RenumberRows(iRow);

	ASSERT(m_nRows == m_aRows.GetSize());
}



//****************************************************
// CGridCellArray::SwapRows
//
// Swap the specified rows.  This method is used by
// the sort algorithm.
//
// Parameters:
//		int iRow1
//			Index of the first row.
//
//		int iRow2
//			Index of the second row.
//
// Returns:
//		Nothing.
//
//*****************************************************
void CGridCellArray::SwapRows(int iRow1, int iRow2)
{
	ASSERT(m_nRows == m_aRows.GetSize());

	// Swap the row pointers in the row array.
	CGridRow* pRow1 = (CGridRow*) m_aRows[iRow1];
	CGridRow* pRow2 = (CGridRow*) m_aRows[iRow2];
	m_aRows[iRow1] = pRow2;
	m_aRows[iRow2] = pRow1;

	// Swap the row indexes
	int iRow1T = pRow1->m_iRow;
	pRow1->m_iRow = pRow2->m_iRow;
	pRow2->m_iRow = iRow1T;

	// If the selected row moved, update the selection index.
	if (m_iSelectedRow == iRow1) {
		m_iSelectedRow = iRow2;
	}
	else if (m_iSelectedRow == iRow2) {
		m_iSelectedRow = iRow1;
	}
}



//****************************************************
// CGridCellArray::DeleteRowAt
//
// Delete the specified row from the array of grid cells.
//
// Parameters:
//		int iRow
//			The zero-based index of the row to delete.
//
//****************************************************
void CGridCellArray::DeleteRowAt(int iRow)
{
	ASSERT(iRow < m_aRows.GetSize());
	ASSERT(m_nRows == m_aRows.GetSize());


	CGridRow* pRow =  (CGridRow*) m_aRows[iRow];
	m_aRows.RemoveAt(iRow);
	--m_nRows;

	delete pRow;
	if (iRow < m_nRows) {
		RenumberRows(iRow);
	}
	ASSERT(m_nRows == m_aRows.GetSize());
}






//********************************************************
// CGridCellArray::InsertColumnAt
//
// Insert a column at the specified index.
//
// Parameters:
//		int iCol
//			After the insertion, the new column has this index.
//			This is a zero-based index.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridCellArray::InsertColumnAt(int iCol)
{
	ASSERT(m_nRows == m_aRows.GetSize());
	for (int iRow=0; iRow < m_nRows; ++iRow) {
		CGridRow& row = GetRowAt(iRow);
		row.InsertColumnAt(iCol);
	}
	++m_nCols;
	ASSERT(m_nRows == m_aRows.GetSize());
}






//*********************************************************
// CGridCellArray::DeleteColumnAt
//
// Remove the column at the specified index.
//
// Parameters:
//		int iCol
//			The zero-based index of the column to remove.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGridCellArray::DeleteColumnAt(int iCol)
{
	ASSERT(m_nRows == m_aRows.GetSize());
	for (int iRow = 0; iRow < m_nRows; ++iRow) {
		CGridRow& row = GetRowAt(iRow);
		row.DeleteColumnAt(iCol);
	}
	--m_nCols;
	ASSERT(m_nRows == m_aRows.GetSize());
}



//************************************************************
// CGridCellArray::DeleteAll
//
// Delete all the rows and columns from the grid-cell array.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCellArray::DeleteAll()
{
	ASSERT(m_nRows == m_aRows.GetSize());

	while (m_nRows > 0) {
		DeleteRowAt(m_nRows - 1);
	}

	m_nCols = 0;
	m_iSelectedRow = NULL_INDEX;
	m_iSelectedCol = NULL_INDEX;

	ASSERT(m_nRows == m_aRows.GetSize());
}








//************************************************************
// The CSortElement class is used to implement sorting via the
// standard qsort algorithm.  qsort does not allow you to pass
// any auxilary information to the comparison function such as
// the primary sort column, ascending flag, etc.  Thus this extra
// information must be stored along with the elements being sorted.
//
// Sorting is done by copying the CGridRow pointers and this
// auxilary information into an array of CSortElement instances,
// sorting the CSortElement array, and then copying the CGridRow
// pointers back to the CGridCellArray.
//
//*************************************************************

class CSortElement
{
public:
	CSortElement(CGridRow* pRow, int iColumn, BOOL bAscending);
	int Compare(const CSortElement& se2) const;
	CGridRow* GridRow() {return m_pRow; }
private:
	CGridRow* m_pRow;
	int m_iSortColumn;		// Sort column;
};

#define HIGH_BIT (1 << ((8 * sizeof(char) * sizeof(int)) - 1))


CSortElement::CSortElement(CGridRow* pRow, int iColumn, BOOL bAscending)
{
	ASSERT((iColumn & HIGH_BIT) == 0);
	ASSERT(HIGH_BIT != 0);

	m_pRow = pRow;
	// Encode the ascending flag in the sign of the sort column index.
	if (bAscending) {
		m_iSortColumn = iColumn;
	}
	else {
		m_iSortColumn = iColumn | HIGH_BIT;
	}
}

//**********************************************************
// CSortElement::Compare
//
// Compare two rows represented by a pair of CSortElement
// instances.
//
// Parameters:
//		const CSortElement& se2
//			The second CSortElement (the first one is this instance).
//
//
// Returns:
//		>0 if CSortElement1 > CSortElement2
//
//		=0 if CSortElement1 == CSortElement2
//
//		<0 if CSortElement1 < CSortElement2
//
//
//*************************************************************
int CSortElement::Compare(const CSortElement& se2) const
{
	int iSortColumn = m_iSortColumn & ~HIGH_BIT;
	BOOL bAscending = m_iSortColumn & HIGH_BIT;

	CGrid* pGrid = m_pRow->Grid();
	int iRow1 = m_pRow->GetRow();
	int iRow2 = se2.m_pRow->GetRow();

	int iResult = pGrid->CompareRows(iRow1, iRow2,  iSortColumn);
	if (bAscending) {
		iResult = - iResult;
	}
	return iResult;
}



//**********************************************************
// fnCompareRows
//
// This is the quicksort comparison function for comparing
// two CSortElement instances. Each CSortElement instance
// contains a pointer to a corresponding grid row, the primary
// sort column index, and whether the row is ascending or
// descending.
//
// Parameters:
//		const void *arg1
//			A pointer to the first CSortElement pointer.
//
//		const void *arg2
//			A pointer to the second CSortElement pointer.
//
// Returns:
//		>0 if CSortElement1 > CSortElement2
//
//		=0 if CSortElement1 == CSortElement2
//
//		<0 if CSortElement1 < CSortElement2
//
//
//*************************************************************
static int fnCompareRows( const void *arg1, const void *arg2 )
{
	const CSortElement* pse1 = *(const CSortElement**) arg1;
	const CSortElement* pse2 = *(const CSortElement**) arg2;

	int iResult = pse1->Compare(*pse2);

	return iResult;
}



//************************************************************
// CGridCellArray::Sort
//
// Sort a range of rows.
//
//
// Parameters:
//		[in] CGrid* pGrid
//			Pointer to the grid.  This is required so that the grid's row
//			comparison method can be called.  The row comparison method
//			is typically overridden by a class derived from CGrid so that
//
//		[in] int iRowFirst
//			The index of first row in the range to be sorted.
//
//		[in] int iRowLast
//			The index of the last row in the range to be sorted.
//
//		[in] int iSortColumn
//			The index of the column to use as the primary sort key.  The actual
//			semantics of this parameter are defined by the CompareRows method in
//			the grid.  Typically CompareRows will be overridden in the derived
//			class to define the semantics of a row comparison.
//
//
//		[in] BOOL bAscending
//			TRUE if the rows should be sorted into ascending order, FALSE
//			to sort in descending order.
//
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCellArray::Sort(CGrid* pGrid, int iRowFirst, int iRowLast, int iSortColumn, BOOL bAscending)
{
	int nElements = iRowLast - iRowFirst + 1;
	if (nElements <= 1) {
		return ;
	}

	CGridCore* pcore = pGrid->GridCore();
	int iSelectedRow = NULL_INDEX;
	int iSelectedCol = NULL_INDEX;
	int nEditStartSel;
	int nEditEndSel;
	BOOL bWasEditing = pGrid->IsEditingCell();

	iSelectedRow = pcore->OnBeginSort(nEditStartSel, nEditEndSel);


	// Sorting is done by copying the CGridRow pointers and
	// auxilary information into an array of CSortElement instances,
	// sorting the CSortElement array, and then copying the CGridRow
	// pointers back to the CGridCellArray.

	CSortElement** apse = new CSortElement*[nElements];

	int i;
	for (i=0; i< nElements; ++i) {
		CGridRow* pRow = (CGridRow*) m_aRows[i + iRowFirst];
		apse[i] = new CSortElement(pRow, iSortColumn, bAscending);
	}

	qsort(apse, nElements, sizeof(CSortElement*),  fnCompareRows);

	BOOL bMovedSelectedRow = FALSE;
	CSortElement* pse;
	for (i=0; i < nElements; ++i) {
		pse = apse[i];
		CGridRow* pRow = apse[i]->GridRow();

		if (iSelectedRow != NULL_INDEX) {
			if (!bMovedSelectedRow && (iSelectedRow == pRow->GetRow())) {
				iSelectedRow = i + iRowFirst;
				bMovedSelectedRow = TRUE;
			}
		}
		m_aRows[i + iRowFirst] = apse[i]->GridRow();
		delete pse;
	}
	delete apse;

	RenumberRows(iRowFirst);
	pcore->OnEndSort(iSelectedRow, nEditStartSel, nEditEndSel);
	if (::IsWindow(pGrid->m_hWnd)) {
		pGrid->RedrawWindow();
	}
}



//************************************************************
// CGridCellArray::DeleteAllRows
//
// Delete all the rows from the grid-cell array.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCellArray::DeleteAllRows()
{
	ASSERT(m_nRows == m_aRows.GetSize());

	while (m_nRows > 0) {
		DeleteRowAt(m_nRows - 1);
	}

	m_iSelectedRow = NULL_INDEX;
	m_iSelectedCol = NULL_INDEX;
	ASSERT(m_nRows == 0);
	ASSERT(m_aRows.GetSize() == 0);
}

//************************************************************
// CGridCellArray::DeleteAllRows
//
// Renumber the rows starting at the specified row.  This is done
// so that a grid cell can quickly find its own position in the
// grid so that it can draw itself.
//
// Parameters:
//		[in] int iStartRow
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridCellArray::RenumberRows(int iStartRow)
{
	ASSERT(m_nRows == m_aRows.GetSize());

	int nRows = (int) m_aRows.GetSize();
	if ((iStartRow <0 ) || (iStartRow >= nRows)) {
		ASSERT(nRows==0);
		return;
	}

	for (int iRow = iStartRow; iRow < nRows; ++iRow) {
		CGridRow* pRow = (CGridRow*) m_aRows[iRow];
		pRow->m_iRow = iRow;
	}
	ASSERT(m_nRows == m_aRows.GetSize());

}





//************************************************************
// CGridCellArray::GetRowAt
//
// Get the CGridRow at the specified row index.
//
// Parameters:
//		[in] int Row
//
// Returns:
//		CGridRow&
//			A reference to the selected row.
//
//************************************************************
CGridRow& CGridCellArray::GetRowAt(int iRow)
{
	ASSERT((iRow >= 0) && (iRow < m_aRows.GetSize()));
	ASSERT(m_nRows == m_aRows.GetSize());

	CGridRow* pRow = (CGridRow*) m_aRows[iRow];
	return *pRow;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\globals.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _globals_h
#define _globals_h


#define CX_CELL_MARGIN 3
#define CY_CELL_MARGIN 2
#define CY_FONT 15


#endif //_globals_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gc.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "resource.h"
#include "grid.h"
#include "celledit.h"
#include "gca.h"
#include "core.h"
#include "utils.h"
#include "DlgArray.h"
#include "wbemidl.h"
#include "DlgObjectEditor.h"
#include "DlgTime.h"

//-----------------------------------------------------------
class CWbemTime
{
public:
	CWbemTime(BOOL bShouldBeInterval);
	BOOL SetDMTF(BSTR wszText, bool AssumedDateTime);
	BSTR GetDMTF();

	void SetTime(SYSTEMTIME& st, int nOffset);
	void GetTime(SYSTEMTIME& st, int& nOffset);
	void GetTime(CString& sTime);

    void GetInterval(CString& sTime, SYSTEMTIME &st);
    void SetInterval(CString sTime, SYSTEMTIME st);
    int LocalTimezoneOffset(void);

	BOOL IsValid() {return m_valid;}

    bool m_dateTime;
	bool m_bUsingAsterisks;
private:
    void Init(void);
    int Valid(BSTR wszText);

    WCHAR m_sYear[5];
	WCHAR m_sMonth[3];
	WCHAR m_sDay[3];
	WCHAR m_sIntervalDay[9];
	WCHAR m_sHour[3];
	WCHAR m_sMinute[3];
	WCHAR m_sSecond[3];
	WCHAR m_sMicros[7];
	WCHAR m_sOffsetMinutes[4];
	WCHAR m_sSign;

    bool m_valid;
	BOOL m_bShouldBeInterval; // This is supposed to be an interval
};


//===========================================================
CWbemTime::CWbemTime(BOOL bShouldBeInterval)
{
	m_bShouldBeInterval = bShouldBeInterval;
    Init();
}

//-----------------------------------------------------------
void CWbemTime::Init(void)
{
    memset(m_sYear, 0, 10);
	memset(m_sMonth, 0, 6);
	memset(m_sDay, 0, 6);
	memset(m_sIntervalDay, 0, 18);
	memset(m_sHour, 0, 6);
	memset(m_sMinute, 0, 6);
	memset(m_sSecond, 0, 6);
	memset(m_sMicros, 0, 14);
	wcscpy(m_sOffsetMinutes, L"000");

    m_valid = false;
    m_dateTime = true;
	m_bUsingAsterisks = false;
}

//-----------------------------------------------------------
void CWbemTime::GetTime(CString& sTime)
{
    //TODO: use GetLocaleInfo and GetTimeFormat()

    if(!m_valid)
    {
        sTime.LoadString(m_bUsingAsterisks?IDS_UNSUPPORTED_DATE_FORMAT:IDS_INVALID_CELL_VALUE);
        return;
    }

    char szTime[256];

    // if its an interval....
    if(m_dateTime)
    {
	    int nHour = _wtoi(m_sHour);
	    CString sAmPm;

	    if(nHour < 12)
        {
		    sAmPm = "AM";
		    if(nHour == 0)
            {
			    nHour = 12;
		    }
	    }
	    else
        {
		    sAmPm = "PM";
		    if(nHour > 12)
            {
			    nHour -= 12;
		    }
	    }

	    int nOffsetMinutes = _wtoi(m_sOffsetMinutes);
        int posMinutes = nOffsetMinutes;
	    if(m_sSign == L'-')
        {
		    nOffsetMinutes = -nOffsetMinutes;
	    }

        // special case for GMT zone.
        if(nOffsetMinutes == 0)
        {
		    sprintf(szTime, "%S/%S/%S  %d:%02S:%02S %S  GMT",
			    m_sMonth, m_sDay, &m_sYear[2],
			    nHour, m_sMinute, m_sSecond, sAmPm);
	    }
	    else // has a timezone offset.
        {
		    int nOffsetHoursDisplay = posMinutes / 60;
		    int nOffsetMinutesDisplay = posMinutes - (nOffsetHoursDisplay * 60);

		    sprintf(szTime, "%S/%S/%S  %2d:%S:%S %s  GMT%C%02d:%02d",
			    m_sMonth, m_sDay, &m_sYear[2],
			    nHour, m_sMinute, m_sSecond, sAmPm,
			    m_sSign, nOffsetHoursDisplay, nOffsetMinutesDisplay);
	    }
    }
    else  // its an interval.
    {
   		sprintf(szTime, "%Sd %Sh %Sm %Ss %Su",
			m_sIntervalDay,
			m_sHour, m_sMinute, m_sSecond, m_sMicros);
    }

	sTime = szTime;
}

//-----------------------------------------------------------
#define ITSA_BADFORMAT -5
#define ITSA_USING_ASERISKS -4
#define ITSA_BAD_PREFIX -3
#define ITSA_GOT_LETTERS -2
#define ITSA_MISSING_DECIMAL -1
#define ITSA_WRONG_SIZE 0
#define ITSA_DATETIME 1
#define ITSA_INTERVAL 2

int CWbemTime::Valid(BSTR wszText)
{
    int retval = ITSA_DATETIME;

    if(SysStringLen(wszText) != 25)
        retval = ITSA_WRONG_SIZE; // wrong size.

    else if(wszText[14] != L'.')
        retval = ITSA_MISSING_DECIMAL;   // missing decimal

    else if(wcsspn(wszText, L"0123456789-+:.") != 25)
        retval = ITSA_GOT_LETTERS;

    else if(retval > 0)
    {
        if(wszText[21] == L'+')
            retval = ITSA_DATETIME;
        else if(wszText[21] == L'-')
            retval = ITSA_DATETIME;
        else if(wszText[21] == L':')
            retval = ITSA_INTERVAL;
        else
            retval = ITSA_BAD_PREFIX;   // wrong utc prefix.
    }

	if(ITSA_GOT_LETTERS == retval && (wcsspn(wszText, L"0123456789-+:.*") == 25))
		retval = ITSA_USING_ASERISKS;

	// Make sure if the qualifier said interval, its an interval
	if(ITSA_DATETIME == retval && m_bShouldBeInterval)
		retval = ITSA_BADFORMAT;

	// Make sure if the qualifier does not say interval, its not an interval
	if(ITSA_INTERVAL == retval && m_bShouldBeInterval == FALSE)
		retval = ITSA_BADFORMAT;

	// Make sure intervals end in '0'
	if(ITSA_INTERVAL == retval && 3 != wcsspn(&wszText[22], L"0"))
		retval = ITSA_BADFORMAT;

    return retval;
}

//-----------------------------------------------------------
BOOL CWbemTime::SetDMTF(BSTR wszText, bool AssumedDateTime)
{
    int v = 0;
    BOOL retval = FALSE;

    // reinit.
    Init();

//	BOOL bTime = IsTime();
    // validate it.
    if((v = Valid(wszText)) > 0)
    {
        m_valid = true;

        // parse it, common stuff.
        wcsncpy(m_sHour, &wszText[8], 2);
        wcsncpy(m_sMinute, &wszText[10], 2);
        wcsncpy(m_sSecond, &wszText[12], 2);
        wcsncpy(m_sMicros, &wszText[15], 6);
        wcsncpy(m_sOffsetMinutes, &wszText[22], 3);
        m_sSign = wszText[21];

        // format specific stuff...
        if(v == ITSA_DATETIME)
        {
            m_dateTime = true;
            wcsncpy(m_sYear, &wszText[0], 4);
            wcsncpy(m_sMonth, &wszText[4], 2);
            wcsncpy(m_sDay, &wszText[6], 2);

            //claim victory.
            retval = TRUE;
        }
        else if(v == ITSA_INTERVAL)
        {
            m_dateTime = false;
            wcsncpy(m_sIntervalDay, &wszText[0], 8);

            //claim victory.
            retval = TRUE;
        }
    }
    else // cant tell by format so trust the asumption.
    {
        m_dateTime = AssumedDateTime;
    }
	if(ITSA_USING_ASERISKS == v)
		m_bUsingAsterisks = true;
    return retval;
}


//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(void)
//
//  Description:  Gets the time in DMTF string datetime format. User must call
//	SysFreeString with the result. If bLocal is true, then the time is given
//	in the local timezone, else the time is given in GMT.
//
//  Return: NULL if not OK.
//
//***************************************************************************
BSTR CWbemTime::GetDMTF()
{
	WCHAR szTemp[26];
    memset(szTemp, 0, 52);

    if(!m_valid)
        return (BSTR)NULL;

    if(m_dateTime)
    {
	    wcscpy(szTemp, m_sYear);
	    wcscat(szTemp, m_sMonth);
	    wcscat(szTemp, m_sDay);
    }
    else
    {
	    wcscpy(szTemp, m_sIntervalDay);
    }
	wcscat(szTemp, m_sHour);
	wcscat(szTemp, m_sMinute);
	wcscat(szTemp, m_sSecond);
	wcscat(szTemp, L".");
	wcscat(szTemp, m_sMicros);
	wcsncat(szTemp, &m_sSign, 1);
	wcscat(szTemp, m_sOffsetMinutes);

    ASSERT(wcslen(szTemp) == 25);

    return SysAllocString(szTemp);
}


//***************************************************************************
//
//  WBEMTime::GetTime(SYSTEMTIME&  st, int& nOffsetMinutes)
//
// Get the SYSTEMTIME from this CWbemTime object.  The returned
// SYSTEMTIME does not account for the timezone offset.
//
// Parameters:
//		[out] SYSTEMTIME& st
//			The systemtime is returned here.
//
//		[out] int& nOffsetMinutesMinutes
//			The GMT offset in minutes is returned here.
//
//
//***************************************************************************
void CWbemTime::GetTime(SYSTEMTIME& st, int& nOffsetMinutes)
{
    ASSERT(m_dateTime);

    if(m_valid)
    {
        st.wYear = (WORD)_wtoi(m_sYear);
        st.wMonth = (WORD)_wtoi(m_sMonth);
        st.wDay = (WORD)_wtoi(m_sDay);
        st.wHour = (WORD)_wtoi(m_sHour);
        st.wMinute = (WORD)_wtoi(m_sMinute);
        st.wSecond = (WORD)_wtoi(m_sSecond);
        st.wMilliseconds = _wtoi(m_sMicros) / 1000;

	    nOffsetMinutes = _wtoi(m_sOffsetMinutes);
        if(m_sSign == L'-')
            nOffsetMinutes = -nOffsetMinutes;
    }
    else
    {
		GetLocalTime(&st);
		nOffsetMinutes = LocalTimezoneOffset();
    }
}

//------------------------------------------------------------
void CWbemTime::SetTime(SYSTEMTIME& st, int nOffsetMinutes)
{
    Init();
    m_dateTime = true;
    m_valid = true;

    swprintf(m_sYear, L"%-4d", st.wYear);
    swprintf(m_sMonth, L"%02d", st.wMonth);
    swprintf(m_sDay, L"%02d", st.wDay);

    swprintf(m_sHour, L"%02d", st.wHour);
    swprintf(m_sMinute, L"%02d", st.wMinute);
    swprintf(m_sSecond, L"%02d", st.wSecond);
    swprintf(m_sMicros, L"%06d", ((long) st.wMilliseconds) * 1000);

    int tempMins = nOffsetMinutes;

    if(tempMins < 0)
    {
        tempMins = -tempMins;
        m_sSign = L'-';
    }
    else
    {
        m_sSign = L'+';
    }
    swprintf(m_sOffsetMinutes, L"%03d", tempMins);
}

//------------------------------------------------------------
void CWbemTime::GetInterval(CString& sTime, SYSTEMTIME &st)
{
    ASSERT(!m_dateTime);

    sTime = CString(m_sIntervalDay);

    st.wYear = 1900;
    st.wMonth = 1;
    st.wDay = 1;
    st.wHour = (WORD)_wtoi(m_sHour);
    st.wMinute = (WORD)_wtoi(m_sMinute);
    st.wSecond = (WORD)_wtoi(m_sSecond);
    st.wMilliseconds = _wtoi(m_sMicros) / 1000;
}

//------------------------------------------------------------
void CWbemTime::SetInterval(CString sTime, SYSTEMTIME st)
{
    Init();
    m_dateTime = false;
    m_valid = true;

	long lTime;
	_stscanf(sTime, _T("%ld"), &lTime);
	if (lTime < 0) {
		lTime = 0;
	}
	else if (lTime > 99999999) {
		lTime = 99999999;
	}
    swprintf(m_sIntervalDay, L"%08ld", lTime);


    swprintf(m_sHour, L"%02d", st.wHour);
    swprintf(m_sMinute, L"%02d", st.wMinute);
    swprintf(m_sSecond, L"%02d", st.wSecond);
    swprintf(m_sMicros, L"%06d", ((long) st.wMilliseconds) * 1000);
    m_sSign = L':';
	wcscpy(m_sOffsetMinutes, L"000");
}

//--------------------------------------------------------
int CWbemTime::LocalTimezoneOffset(void)
{
    TIME_ZONE_INFORMATION tzi;
    int retval = 0;

    switch(GetTimeZoneInformation(&tzi))
    {
    case TIME_ZONE_ID_UNKNOWN:
    case TIME_ZONE_ID_STANDARD:
        retval = -(tzi.Bias + tzi.StandardBias);
        break;
    case TIME_ZONE_ID_DAYLIGHT:
        retval = -(tzi.Bias + tzi.DaylightBias);
        break;
    case TIME_ZONE_ID_INVALID:
        // failure
        break;

    } //endswitch

    return retval;
}

//*************************************************************
// CGridCell::CGridCell
//
// Constructor for CGridCell.
//
// Parameters:
//		[in] CGrid* pGrid
//			Pointer to the grid containing this grid cell.
//
//*************************************************************
CGridCell::CGridCell(CGrid* pGrid, CGridRow* pRow)
{
	m_pRow = pRow;
	m_dwTagValue = 0;
	m_dwFlags = 0;
	ToBSTR(m_varValue);
	m_iColBuddy = NULL_INDEX;
	m_bWasModified = FALSE;
	m_pGrid = pGrid;
	m_propmarker  = PROPMARKER_NONE;
	m_bNumberArrayRows = TRUE;
	ASSERT(m_pGrid != NULL);
}

void CGridCell::Clear()
{
	m_type.SetCellType(CELLTYPE_VOID);
	m_type.SetCimtype(CIM_EMPTY);
	m_varValue.Clear();
	m_propmarker = PROPMARKER_NONE;
	SetModified(FALSE);
}


//************************************************************
// CGridCell::CGridCell
//
// Copy constructor for the gridcell class.
//
// Parameters:
//		[in] CGridCell& gcSrc
//			The grid cell used to initialize this grid cell.
//
// Returns:
//		Nothing.
//
//************************************************************
CGridCell::CGridCell(CGridCell& gcSrc)
{
	*this = gcSrc;
	ASSERT(m_pGrid != NULL);
}

void CGridCell::SetPropmarker(PropMarker propmarker)
{
	m_propmarker = propmarker;
	m_type.SetCellType(CELLTYPE_PROPMARKER);
	m_dwFlags |= CELLFLAG_READONLY;
}


//***************************************************************
// CGridCell::SetModified
//
// Set this grid cell's modification flag.  If the cell's modification
// state changes from unmodified to modified, then notifiy the grid
// that the change occured.
//
// Parameters:
//		BOOL bModified
//			TRUE to mark the cell as modified, FALSE to mark it as
//			unmodified.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CGridCell::SetModified(BOOL bModified)
{
	BOOL bWasModified = m_bWasModified;
	m_bWasModified = bModified;


	if (bModified) {
		m_pRow->SetModified(TRUE);

	}
	else if (bWasModified) {
		// If this cell is changing from a modified to an unmodifed, then
		// the row modification flag may need to be updated if all other
		// cells in the row are also unmodified.
		int nCells = m_pRow->GetSize();
		BOOL bRowModified = FALSE;
		for (int iCell = 0; iCell < nCells; ++iCell) {
			CGridCell* pgc = &(*m_pRow)[iCell];
			if (pgc != this) {
				if (pgc->GetModified()) {
					bRowModified = TRUE;
					break;
				}
			}
		}
		m_pRow->SetModified(bRowModified);
	}


	if (!bWasModified && bModified) {
		if (m_pGrid) {
			m_pGrid->NotifyCellModifyChange();

			int iRow, iCol;
			m_pRow->FindCell(this, iRow, iCol);
			m_pGrid->OnCellContentChange(iRow, iCol);
		}
	}
}


#if 0
TMapStringToLong amapCimType[] = {
	{IDS_CIMTYPE_UINT8, VT_UI1	},
	{IDS_CIMTYPE_SINT8,	VT_I2},				// I2
	{IDS_CIMTYPE_UINT16, VT_I4},			// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_SINT16, VT_I2},			// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_UINT32, VT_I4},			// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_SINT32, VT_I4},				// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64, VT_BSTR},			// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64, VT_BSTR},			// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING, VT_BSTR},			// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL, VT_BOOL},			// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32, VT_R4},			// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64, VT_R8},			// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME, VT_BSTR},		// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF, VT_BSTR},				// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_CHAR16, VT_I2},			// VT_I2	16-bit UCS-2 character
	{IDS_CIMTYPE_OBJECT, VT_UNKNOWN},		// VT_UNKNOWN	Weakly-typed embedded instance

	{IDS_CIMTYPE_UINT8_ARRAY, VT_ARRAY | VT_UI1	},
	{IDS_CIMTYPE_SINT8_ARRAY,	VT_ARRAY | VT_I2},		// I2
	{IDS_CIMTYPE_UINT16_ARRAY, VT_ARRAY | VT_I4},		// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_SINT16_ARRAY, VT_ARRAY | VT_I2},		// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_UINT32_ARRAY, VT_ARRAY | VT_I4},		// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_I4_ARRAY, VT_ARRAY | VT_I4},			// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64_ARRAY, VT_ARRAY | VT_BSTR},		// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64_ARRAY, VT_ARRAY | VT_BSTR},		// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING_ARRAY, VT_ARRAY | VT_BSTR},		// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL_ARRAY, VT_ARRAY | VT_BOOL},		// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32_ARRAY, VT_ARRAY | VT_R4},		// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64_ARRAY, VT_ARRAY | VT_R8},		// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME_ARRAY, VT_ARRAY | VT_BSTR},	// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF_ARRAY, VT_ARRAY | VT_BSTR},		// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_CHAR16_ARRAY, VT_ARRAY | VT_I2},		// VT_I2	16-bit UCS-2 character
	{IDS_CIMTYPE_OBJECT_ARRAY, VT_ARRAY | VT_UNKNOWN}	// VT_DISPATCH	Weakly-typed embedded instance

};
CMapStringToLong mapCimType;
#endif //0







//**************************************************************
// CGridCell::EditTime
//
// Edit a cell containing a datetime value.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CGridCell::EditTime()
{
	if (!IsTime()) {
		ASSERT(FALSE);
		return;
	}

	m_pGrid->EndCellEditing();


	CDlgTime dlg;
	BOOL bWasModified = dlg.EditTime(this);


	if (!m_bWasModified && bWasModified) {
		SetModified(TRUE);
	}

	int iRow, iCol;
	FindCellPos(iRow, iCol);
	ASSERT(iRow != NULL_INDEX);
	ASSERT(iCol != NULL_INDEX);

	m_pGrid->RedrawCell(iRow, iCol);
}




//**************************************************************
// CGridCell::EditArray
//
// Edit a cell containing an array.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CGridCell::EditArray()
{

	int iRow, iCol;
	FindCellPos(iRow, iCol);
	ASSERT(iRow != NULL_INDEX);

	m_pGrid->EndCellEditing();



	IWbemServices* psvc = NULL;
	if ((((CIMTYPE)m_type) & CIM_TYPEMASK) == CIM_OBJECT) {
		psvc = m_pGrid->GetWbemServicesForObject(iRow, iCol);
	}

	CString sArrayName;
	m_pGrid->GetArrayName(sArrayName, iRow, iCol);


	CDlgArray dlg(m_bNumberArrayRows);
	BOOL bWasModified;
	bWasModified = dlg.EditValue(psvc, sArrayName, this);


	if (!m_bWasModified && bWasModified) {
		SetModified(TRUE);
	}
	m_pGrid->RedrawCell(iRow, iCol);
}



void CGridCell::EditObject()
{
	int iRow, iCol;
#if 0
	FindCellPos(this, iRow, iCol);
	m_pGrid->EditCellObject(this, iRow, iCol);
#endif //0

	m_pGrid->EndCellEditing();

	FindCellPos(iRow, iCol);
	ASSERT(iRow != NULL_INDEX);
//	ASSERT(iCol == ICOL_ARRAY_VALUE);

//	CGridCell& gcName = m_pGrid->GetAt(iRow, ICOL_ARRAY_NAME);
//	CString sPropertyName;

//	VARTYPE vt;
//	gcName.GetValue(sPropertyName, vt);

	CDlgObjectEditor dlg;
	BOOL bWasModified;

	IWbemServices* psvc = m_pGrid->GetWbemServicesForObject(iRow, iCol);

	CString sClassname;
	m_pGrid->GetObjectClass(sClassname, iRow, iCol);
	if (sClassname.IsEmpty()) {
		// Get the classname here.

	}
	if (m_varValue.vt == VT_NULL) {
		bWasModified = dlg.CreateEmbeddedObject(psvc, sClassname, this);
	}
	else {
		bWasModified = dlg.EditEmbeddedObject(psvc, sClassname, this);
	}
	if (!m_bWasModified && bWasModified) {
		SetModified(TRUE);
	}

	m_pGrid->RedrawCell(iRow, iCol);
}



BOOL CGridCell::RequiresSpecialEditing()
{
	if (((CellType) m_type) == CELLTYPE_PROPMARKER) {
		return TRUE;
	}


	if (IsObject()) {
		return TRUE;
	}

	if (IsArray()) {
		return TRUE;
	}

	if (IsTime()) {
		return TRUE;
	}
	return FALSE;
}


void CGridCell::DoSpecialEditing()
{
	if (((CellType) m_type) == CELLTYPE_PROPMARKER) {
		// It makes no sense to edit a property marker, so do nothing.
		return;
	}

	if (IsNull() &&  IsReadonly()) {
		// It makes no sense to edit a null property if the cell is read-only.
		return;
	}

	if (IsArray()) {
		EditArray();
		return;
	}

	if (IsObject()) {
		EditObject();
		return;
	}


	if (IsTime()) {
		EditTime();
		return;
	}
}


//**************************************************************
// CGridCell::SetToNull
//
// Set the cell value to NULL.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CGridCell::SetToNull()
{
	if (m_dwFlags & CELLFLAG_READONLY) {
		ASSERT(FALSE);
		return;
	}

	if (m_varValue.vt != VT_NULL) {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_NULL);
		SetModified(TRUE);
	}
}

//************************************************************
// CGridCell::operator=
//
// Assignment operator for a GridCell.
//
// Parameters:
//		[in] CGridCell& gcSrc
//			The grid cell used to initialize this grid cell.
//
// Returns:
//		Nothing.
//
//************************************************************
CGridCell& CGridCell::operator=(CGridCell& gcSrc)
{
	m_type = gcSrc.m_type;

	m_varValue = gcSrc.m_varValue;
	m_bWasModified = gcSrc.m_bWasModified;
	m_iColBuddy = gcSrc.m_iColBuddy;
	m_dwFlags = gcSrc.m_dwFlags;
	m_dwTagValue = gcSrc.m_dwTagValue;

	m_idResource = gcSrc.m_idResource;
	m_propmarker = gcSrc.m_propmarker;
	m_bIsKey = gcSrc.m_bIsKey;
	m_pGrid = gcSrc.m_pGrid;
	m_pRow = gcSrc.m_pRow;


	m_saEnum.RemoveAll();
	int nStrings = (int) gcSrc.m_saEnum.GetSize();
	for (int i=0; i<nStrings; ++i) {
		m_saEnum.SetAtGrow(i, gcSrc.m_saEnum[i]);
	}


	return *this;
}



//************************************************************
// CGridCell::SetFlags
//
// Set the grid cell flags. Note, these flags have specific meaning
// to the grid.  The "tag" value and not "flags" should be used if you need
// to save a DWORD to the grid cell.
//
// Parameters:
//		DWORD dwMask
//			Only the bits set in this mask will be modified.
//
//	    DWORD dwValue
//			The flag values.
//
// Returns:
//		DWORD
//			The previous value of "flags"
//
//************************************************************
DWORD CGridCell::SetFlags(DWORD dwMask, DWORD dwValue)
{
	DWORD dwFlagsPrev = m_dwFlags;
	m_dwFlags  = (m_dwFlags & ~dwMask) | (dwMask & dwValue);
	return dwFlagsPrev;
}

//*************************************************************
// CGridCell::SetValueForQualifierType
//
// Set the value of the cell to one of the qualifier types.  The
// CGridCell class is responsible for looking up the type string
// for the specified type.
//
// Parameters:
//		[in] VARTYPE vt;
//
// Returns:
//		SCODE
//			S_OK if everything was successful.
//
//*************************************************************
SCODE CGridCell::SetValueForQualifierType(VARTYPE vt)
{
	UINT ids;
	switch(vt) {
	case VT_BOOL:
		ids = IDS_ATTR_TYPE_BOOL;
		break;
	case VT_BSTR:
		ids = IDS_ATTR_TYPE_BSTR;
		break;
	case VT_I4:
		ids = IDS_ATTR_TYPE_I4;
		break;
	case VT_R8:
		ids = IDS_ATTR_TYPE_R8;
		break;

	case VT_BOOL | VT_ARRAY:
		ids = IDS_ATTR_TYPE_BOOL_ARRAY;
		break;
	case VT_BSTR | VT_ARRAY:
		ids = IDS_ATTR_TYPE_BSTR_ARRAY;
		break;
	case VT_I4 | VT_ARRAY:
		ids = IDS_ATTR_TYPE_I4_ARRAY;
		break;
	case VT_R8 | VT_ARRAY:
		ids = IDS_ATTR_TYPE_R8_ARRAY;
		break;
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}


	CString sTypeName;
	sTypeName.LoadString(ids);
	m_varValue.Clear();
	m_varValue = sTypeName;

	m_type.SetCellType(CELLTYPE_ATTR_TYPE);
	m_dwFlags = 0;
	m_dwTagValue = 0;
	m_type.SetCimtype(CIM_STRING);
	m_saEnum.RemoveAll();
	m_idResource = 0;
	m_bIsKey = FALSE;
	m_propmarker = PROPMARKER_NONE;

	SetModified(TRUE);

	return S_OK;
}


SCODE CGridCell::SetValue(CGcType& type, LPCTSTR pszValue)
{
	SCODE sc;
	sc = SetValue((CellType) type, pszValue, (CIMTYPE) type);
	return sc;
}

SCODE CGridCell::SetValue(CGcType& type, VARIANTARG& var)
{
	SCODE sc;
	sc = SetValue((CellType) type, var, (CIMTYPE) type, type.CimtypeString());
	return sc;
}

SCODE CGridCell::SetValue(CGcType& type, UINT idResource)
{
	SCODE sc;
	sc = SetValue((CellType) type, idResource);
	return sc;
}

SCODE CGridCell::SetValue(CGcType& type, BSTR bstrValue)
{
	SCODE sc;
	sc = SetValue((CellType) type, bstrValue, (CIMTYPE) type);
	return sc;
}


SCODE CGridCell::ChangeType(const CGcType& type)
{
	if (m_type == type) {
		return S_OK;
	}
	CGcType typePrev;
	typePrev = m_type;
	m_type = type;
	SetModified(TRUE);



	if (((CIMTYPE) typePrev) != ((CIMTYPE) type)) {
		if (((CIMTYPE) type) & CIM_FLAG_ARRAY) {
			SetToNull();
		}
		else {
			switch((CIMTYPE) type) {
			case CIM_OBJECT:	// No conversion from any other type to object.
			case CIM_REFERENCE:
			case CIM_DATETIME:	// No conversion from any other type to datetime
				SetToNull();
				break;
			}

			switch((CIMTYPE) typePrev) {
			case CIM_OBJECT:	// No conversion from object to any other type
			case CIM_REFERENCE:
			case CIM_DATETIME:	// No conversion from datetime to any other type
				SetToNull();
				break;
			}



			if (m_varValue.vt != VT_NULL) {
				VARTYPE vt = (VARTYPE) m_type;
				ChangeVariantType(vt);

				if ( ((CIMTYPE) type) == CIM_DATETIME) {
					SetThisCellToCurrentTime();
				}
			}
		}
	}


	return S_OK;
}



//*************************************************************
// CGridCell::SetValue
//
// Set the value of this cell to a resource id.  This method should
// only be called for celltypes that represent resource values, such
// as icons.
//
// Parameters:
//		[in] CellType iType
//			The type of this cell.
//
//		[in] UINT idResource
//			The id of the resource that represents this cell.
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CGridCell::SetValue(CellType iType, UINT idResource)
{
	m_type.SetCellType(iType);
	m_type.SetCimtype(CIM_EMPTY);

	m_idResource = idResource;
	m_varValue.Clear();
	SetModified(TRUE);
	return S_OK;
}


//************************************************************
// CGridCell::SetValue
//
// Set the value of the grid cell to the specified variant value.
//
// Parameters:
//		[in] CellType iType
//			The cell type.
//
//		[in] VARIANTARG& var
//			The value of the cell.
//
//		[in] CIMTYPE cimtype
//			The value's cimtype.
//
//		[in] LPCTSTR pszCimtype
//			The cimtype qualifier string.
//
// Returns:
//		SCODE
//			S_OK if the assignement was successful,otherwise a failure code.
//
//************************************************************
SCODE CGridCell::SetValue(CellType iType, VARIANTARG& var, CIMTYPE cimtype, LPCTSTR pszCimtype)
{
	CGridCell gcSave = *this;

	// !!!CR: This api should be changed so that the GgType is passed in
	// !!!CR: directly.
	m_type.SetCimtype(cimtype, pszCimtype);
	m_type.SetCellType(iType);



	try {
		if (var.vt == VT_BOOL) {
			if (var.boolVal) {
				var.boolVal = VARIANT_TRUE;
			}
			else {
				var.boolVal = VARIANT_FALSE;
			}
		}
		m_varValue = var;

		SetModified(TRUE);
	}
	catch (CException*) {
		*this = gcSave;
		return E_FAIL;
	}

	// If the time is an empty string versus a null value, set the
	// cell's value to the current time.
	if (((CIMTYPE) m_type) == CIM_DATETIME) {
		if (m_varValue.vt == VT_BSTR) {
			if (*m_varValue.bstrVal == 0) {
				SetThisCellToCurrentTime();
			}
		}
	}

	return S_OK;
}


//*******************************************************
// CGridCell::SetValue
//
// Set the grid cell's value.
//
// Parameters:
//		[in] CellType iType
//			The cell type.
//
//		[in] BSTR bstr
//			The value to set the cell to.
//
//		[in] CIMTYPE cimtype
//			The value's cimtype.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//******************************************************
SCODE CGridCell::SetValue(CellType iType, BSTR bstr, CIMTYPE cimtype)
{
	SCODE sc;
	CString sValue;
	sValue = bstr;

	sc = SetValue(iType, sValue, cimtype);
	return sc;
}




//*******************************************************
// CGridCell::SetValue
//
// Set the grid cell's value.  This version of SetValue
// retains the original type of the cell.  For example, if
// the original type was VT_I4, then the string is converted
// to an integer.
//
// Parameters:
//		[in] CellType iType
//			The cell type.
//
//		[in] LPCTSTR pszValue
//			The value to set the cell to.
//
//		[in] CIMTYPE cimtype
//			The value's cimtype string.
//
// Returns:
//		SCODE
//			S_OK if successful, a failure code otherwise.
//
//******************************************************
SCODE CGridCell::SetValue(CellType iType, LPCTSTR pszValue, CIMTYPE cimtype)
{
	SCODE sc;
	CGcType type;
	type.SetCellType(iType);
	sc = type.SetCimtype(cimtype);
	if (FAILED(sc)) {
		return sc;
	}
	if (type.IsArray()) {
		return E_FAIL;
	}

	m_type = type;


	unsigned __int64 ui64Value;
	__int64 i64Value;


	int nFields;
	long lVal;
	CString sValue;
	switch((CIMTYPE) m_type) {

	case CIM_UINT32:
		StripWhiteSpace(sValue, pszValue);
		nFields = _stscanf((LPCTSTR) sValue, _T("%lu"), &lVal);
		if (nFields != 1) {
			return E_FAIL;
		}

		m_varValue.Clear();
		m_varValue.ChangeType(VT_I4);
		m_varValue.lVal = lVal;
		return S_OK;
		break;
	case CIM_UINT16:
		StripWhiteSpace(sValue, pszValue);
		nFields = _stscanf((LPCTSTR) sValue, _T("%lu"), &lVal);
		if (nFields != 1) {
			return E_FAIL;
		}
		if (lVal & ~0x0ffff) {
			return E_FAIL;
		}

		m_varValue.Clear();
		m_varValue.ChangeType(VT_I4);
		m_varValue.lVal = lVal;
		return S_OK;
		break;
	case CIM_UINT64:
		StripWhiteSpace(sValue, pszValue);
		pszValue = sValue;
		m_varValue = _T("0");
		sc = ::AToUint64(pszValue, ui64Value);
		if (FAILED(sc)) {
			return E_FAIL;
		}
		m_varValue = sValue;
		return S_OK;
		break;
	case CIM_SINT64:
		StripWhiteSpace(sValue, pszValue);
		pszValue = sValue;
		m_varValue = _T("0");
		sc = ::AToSint64(pszValue, i64Value);
		if (FAILED(sc)) {
			return E_FAIL;
		}
		m_varValue = sValue;
		return S_OK;
		break;
	}


	CGridCell gcSave = *this;


	VARTYPE vt = (VARTYPE) m_type;
	try
	{

		m_varValue = pszValue;
		m_varValue.ChangeType(vt);
	}
	catch(CException*)
	{
		// Check to see if the value was "empty"
		while (*pszValue) {
			if (iswspace(*pszValue)) {
				++pszValue;
			}
			else {
				break;
			}
		}

		if (*pszValue == 0) {
			// Assigning an empty string to a value is the same as clearing it.
			m_varValue.Clear();
			m_varValue.ChangeType(vt);
		}
		else {
			*this = gcSave;
			return E_FAIL;
		}
	}



	SetModified(TRUE);
	return S_OK;
}



//********************************************************
// CGridCell::GetValue
//
// Get the display string corresponding to the contents of
// a grid cell.
//
// Parameters:
//		[out] CString& sValue
//			The place to return the display string.
//
//		[out] CIMTYPE& cimtype
//			The place to return the value's cimtype.
//
//
// Returns:
//		Nothing.
//
//*******************************************************
void CGridCell::GetValue(CString& sValue, CIMTYPE& cimtype)
{
	cimtype = (CIMTYPE) m_type;


	LPTSTR pszBuffer;
	switch((CIMTYPE) m_type) {
	case CIM_UINT32:
	case CIM_UINT16:
		if (m_varValue.vt == VT_I4) {
			pszBuffer =  sValue.GetBuffer(32);
			_stprintf(pszBuffer, _T("%lu%"), m_varValue.lVal);
			sValue.ReleaseBuffer();
			return;
		}
		break;
	}





	switch(m_varValue.vt) {
	case VT_BOOL:
		// For BOOL values, map the numeric value to
		// "true" or "false"
		if (m_varValue.boolVal) {
			sValue.LoadString(IDS_TRUE);

		}
		else {
			sValue.LoadString(IDS_FALSE);
		}
		break;
	case VT_NULL:
		sValue = _T("<empty>");
		break;
	default:
		VariantToCString(sValue, m_varValue);
		break;
	}
}



//**************************************************************
// CGridCell::GetValue
//
// Copy the grid cell's value to the specified variant.
//
// Parameters:
//		[out] VARIANTARG& var
//			The place to return the cell's value.
//
//		[out] CIMTYPE& cimtype
//			The place to return the cell's cimtype.
//
//
// Returns:
//		Nothing.
//
//**************************************************************
void CGridCell::GetValue(COleVariant& var, CIMTYPE& cimtype)
{
	cimtype = (CIMTYPE) m_type;
	if (m_varValue.vt == VT_BOOL) {
		if (m_varValue.boolVal) {
			m_varValue.boolVal = VARIANT_TRUE;
		}
		else {
			m_varValue.boolVal = VARIANT_FALSE;
		}
	}

	if ((m_varValue.vt & VT_ARRAY) && ((m_varValue.vt & VT_TYPEMASK) == VT_UNKNOWN)) {
		CopyObjectArray(var, m_varValue);
	}
	else {
		var = m_varValue;
	}
}




//*******************************************************************
// CGridCell::CopyObjectArray
//
// Copy a variant containing an array of objects to another variant.  This
// operation does not create additional object instances, it just copies
// references to the objects contained in the array.
//
// Note that just assiging one COleVariant to the other does not work
// correctly.
//
// Parameters:
//		[out] COleVariant& varDst
//			The array is returned here and the original contents are cleared.
//
//		[in] COleVariant& varSrc
//			The source array is passed in through this variant.
//
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL if not.
//
//********************************************************************
SCODE CGridCell::CopyObjectArray(COleVariant& varDst, COleVariant& varSrc)
{
	varDst.Clear();

	// Verify that the source array is an array of objects.
	if (!(varSrc.vt & VT_ARRAY) || !(varSrc.vt & VT_UNKNOWN)) {
		ASSERT(FALSE);
		return E_FAIL;
	}


	long lLBound;
	long lUBound;
	SAFEARRAY *psaSrc = varSrc.parray;
	SafeArrayGetLBound(psaSrc, 1, &lLBound);
	SafeArrayGetUBound(psaSrc, 1, &lUBound);


	LONG nRows = lUBound - lLBound + 1;


	SAFEARRAY *psaDst;
	VARTYPE vt = VT_UNKNOWN;
	MakeSafeArray(&psaDst, VT_UNKNOWN, nRows);

	varDst.vt = VT_ARRAY | VT_UNKNOWN;
	varDst.parray = psaDst;

	HRESULT hr;
	LPUNKNOWN punkVal;
	for (LONG lRow = 0; lRow < nRows; ++lRow) {
		punkVal = NULL;
		hr = SafeArrayGetElement(psaSrc, &lRow, &punkVal);
		punkVal->AddRef();
		hr = SafeArrayPutElement(psaDst, &lRow, punkVal);
	}
	return S_OK;
}




//*************************************************************
// CGridCell::ChangeArrayType
//
// Change the type of the array contained in m_varValue.
//
// Parameters:
//		CIMTYPE	cimtypeDst
//			The desired cimtype.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CGridCell::ChangeArrayType(CIMTYPE cimtypeDst)
{
	if (!(m_varValue.vt & VT_ARRAY)) {
		ASSERT(FALSE);
		return;
	}

	ASSERT(cimtypeDst & CIM_FLAG_ARRAY);
	if (cimtypeDst == (CIMTYPE) m_type) {
		// The cimtype didn't change, so do nothing.
		return;
	}


	SetToNull();
	m_pGrid->RefreshCellEditor();
	return;


#if 0
	// We punted on changing the type of an array because we couldn't get
	// it to work quite right in time for the first release.  Hopefully
	// we can get this to work later on.

	switch(cimtypeDst & ~CIM_FLAG_ARRAY) {
	case CIM_DATETIME:
	case CIM_OBJECT:
		// No type conversion is available for datetime or objects.
		SetToNull();
		m_pGrid->RefreshCellEditor();
		return;
	}

	CIMTYPE cimtypeT = (CIMTYPE) m_type & ~CIM_FLAG_ARRAY;

	switch(((CIMTYPE) m_type) & ~CIM_FLAG_ARRAY) {
	case CIM_OBJECT:
		// No conversion from object to any other type.
		SetToNull();
		m_pGrid->RefreshCellEditor();
		return;
	}





	CGcType typeDst;
	typeDst.SetCimtype(cimtypeDst);

	VARTYPE vtDst = (VARTYPE) typeDst;
	if (m_varValue.vt == vtDst) {
		m_type.SetCimtype(cimtypeDst);
		return;
	}



	SAFEARRAY* psaSrc = m_varValue.parray;
	long lLBound;
	long lUBound;
	SafeArrayGetLBound(psaSrc, 1, &lLBound);
	SafeArrayGetUBound(psaSrc, 1, &lUBound);

	VARIANT var;
	VariantInit(&var);


    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lUBound - lLBound + 1;
	SAFEARRAY* psaDst;
    psaDst = SafeArrayCreate(vtDst & VT_TYPEMASK, 1, rgsabound);
	if (psaDst == NULL) {
		ASSERT(FALSE);
		return;
	}

	for (long lIndex=lLBound; lIndex <= lUBound; ++lIndex) {
		VariantClear(&var);
		switch(m_varValue.vt & VT_TYPEMASK) {
		case VT_BOOL:
			SafeArrayGetElement(psaSrc, &lIndex, &var.boolVal);
			var.vt = VT_BOOL;
			break;
		case VT_BSTR:
			SafeArrayGetElement(psaSrc, &lIndex, &var.bstrVal);
			var.vt = VT_BSTR;
			break;
		case VT_I2:
			SafeArrayGetElement(psaSrc, &lIndex, &var.iVal);
			var.vt = VT_I2;
			break;
		case VT_I4:
			SafeArrayGetElement(psaSrc, &lIndex, &var.lVal);
			var.vt = VT_I4;
			break;
		case VT_R4:
			SafeArrayGetElement(psaSrc, &lIndex, &var.fltVal);
			var.vt = VT_R4;
			break;
		case VT_R8:
			SafeArrayGetElement(psaSrc, &lIndex, &var.dblVal);
			var.vt = VT_R8;
			break;
		case VT_UI1:
			SafeArrayGetElement(psaSrc, &lIndex, &var.bVal);
			var.vt = VT_UI1;
			break;
		default:
			ASSERT(FALSE);
			break;
		}

		HRESULT hr;

		COleVariant varTemp;
		varTemp = L"2";
		hr = VariantChangeType(&varTemp, &varTemp, 0, VT_I4);





		SCODE sc;
		hr = VariantChangeType(&var, &var, 0, vtDst & VT_TYPEMASK);

		sc = GetScode(hr);
		if (FAILED(sc)) {
			VariantClear(&var);
			hr = VariantChangeType(&var, &var, 0, vtDst & VT_TYPEMASK);
			sc = GetScode(hr);
			ASSERT(SUCCEEDED(sc));
		}


		switch(vtDst & VT_TYPEMASK) {
		case VT_BOOL:
			SafeArrayPutElement(psaDst, &lIndex, &var.boolVal);
			break;
		case VT_BSTR:
			SafeArrayPutElement(psaDst, &lIndex, &var.bstrVal);
			break;
		case VT_I2:
			SafeArrayPutElement(psaDst, &lIndex, &var.iVal);
			break;
		case VT_I4:
			SafeArrayPutElement(psaDst, &lIndex, &var.lVal);
			break;
		case VT_R4:
			SafeArrayPutElement(psaDst, &lIndex, &var.fltVal);
			break;
		case VT_R8:
			SafeArrayPutElement(psaDst, &lIndex, &var.dblVal);
			break;
		case VT_UI1:
			SafeArrayPutElement(psaDst, &lIndex, &var.bVal);
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}
	VariantClear(&var);

	SafeArrayDestroy(psaSrc);
	m_varValue.parray = psaDst;
	m_varValue.vt = vtDst;
	m_type.SetCimtype(cimtypeDst);
#endif //0
}


//********************************************************
// CGridCell::ChangeVariantType
//
// Change type of the variant value stored in this grid cell to
// the specified type.  If the value can't be converted, a default
// value is supplied.
//
// Parameters:
//		[in] VARTYPE vt
//			The variant type to change to.
//
// Returns:
//		SCODE
//
//**********************************************************
SCODE CGridCell::ChangeVariantType(VARTYPE vt)
{
	if (m_varValue.vt == vt) {
		return S_OK;
	}

	ASSERT(vt != VT_NULL);

	if (vt & VT_ARRAY) {
		m_type.MakeArray(TRUE);
		if (m_varValue.vt & VT_ARRAY) {
			ChangeArrayType(vt);
		}
		else {
			m_varValue.Clear();
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = 0;
			SAFEARRAY* psaDst;
			psaDst = SafeArrayCreate(vt & ~VT_ARRAY, 1, rgsabound);
			m_varValue.parray = psaDst;
			m_varValue.vt = vt;
		}
		return S_OK;
	}
	else {
		if (m_varValue.vt & VT_ARRAY) {
			m_varValue.Clear();
		}
		m_type.MakeArray(FALSE);
	}



	SCODE sc = S_OK;
//	COleVariant varSave = m_varValue;

	COleVariant varDefault;
	try
	{
		m_varValue.ChangeType(vt);
	}
	catch(CException*  )
	{
		if (vt == VT_UNKNOWN) {
			m_varValue.Clear();
			m_varValue.ChangeType(VT_NULL);
		}
		else {
			m_varValue.Clear();
			varDefault.ChangeType(vt);
			m_varValue = varDefault;
		}
		sc = E_FAIL;
	}

	SetModified(TRUE);
	return sc;
}



//*******************************************************
// CGridCell::SetDefaultValue
//
// Set the defalt value for the given variant type when a
// conversion error occurs.
//
// Parameters:
//		int iType
//			The variant type.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridCell::SetDefaultValue()
{
	CIMTYPE cimtype = (CIMTYPE) m_type;

	m_varValue.Clear();

	switch(cimtype) {
	case CIM_EMPTY:
		break;
	case CIM_SINT8:
	case CIM_CHAR16:
	case CIM_SINT16:
		m_varValue.vt = VT_I2;
		m_varValue.iVal = 0;
		break;
	case CIM_UINT8:
		m_varValue.vt = VT_UI1;
		m_varValue.bVal = 0;
		break;
	case CIM_UINT16:
	case CIM_UINT32:
	case CIM_SINT32:
		m_varValue.vt = VT_I4;
		m_varValue.lVal = 0;
		break;
	case CIM_SINT64:
	case CIM_UINT64:
		m_varValue = "0";
		break;
	case CIM_STRING:
	case CIM_DATETIME:
	case CIM_REFERENCE:
		m_varValue = "";
		break;
	case CIM_REAL32:
		m_varValue.vt = VT_R4;
		m_varValue.fltVal = 0.0;
		break;
	case CIM_REAL64:
		m_varValue.vt = VT_R8;
		m_varValue.dblVal = 0.0;
		break;
	case CIM_BOOLEAN:
		m_varValue.vt = VT_BOOL;
		m_varValue.boolVal = VARIANT_TRUE;
		break;
	case CIM_OBJECT:
		break;
	default:
		break;
	}

	SetModified(TRUE);

}



LPUNKNOWN CGridCell::GetObject()
{
	ASSERT(IsObject());

	if (m_varValue.vt == VT_NULL) {
		return NULL;
	}

	LPUNKNOWN lpunk = m_varValue.punkVal;
	if (lpunk != NULL) {
		lpunk->AddRef();
	}
	return lpunk;
}

void CGridCell::ReplaceObject(LPUNKNOWN lpunk)
{
	ASSERT(lpunk != NULL);
	ASSERT(IsObject());
	if (!IsObject()) {
		return;
	}

	if (m_varValue.vt == VT_UNKNOWN) {
		LPUNKNOWN lpunkRelease = m_varValue.pdispVal;
		if (lpunkRelease != NULL) {
			lpunkRelease->Release();
		}
	}

	lpunk->AddRef();
	m_varValue.punkVal = lpunk;
	m_varValue.vt = VT_UNKNOWN;
	SetModified(TRUE);

}


void CGridCell::SetCheck(BOOL bCheck)
{
	if (((CellType) m_type) != CELLTYPE_CHECKBOX) {
		return;
	}

	if (m_varValue.vt == VT_BOOL) {
		if (m_varValue.boolVal == bCheck) {
			return;
		}
	}

	if (m_varValue.vt != VT_BOOL) {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_BOOL);
	}

	m_varValue.boolVal = bCheck?VARIANT_TRUE:VARIANT_FALSE;
	SetModified(TRUE);
}


void CGridCell::SetCimtype(CIMTYPE cimtype, LPCTSTR pszCimtype)
{
	CIMTYPE cimtypePrev = (CIMTYPE) m_type;
	m_type.SetCimtype(cimtype, pszCimtype);

	if (m_varValue.vt != VT_NULL) {
		VARTYPE vt = (VARTYPE) m_type;
		ChangeVariantType(vt);

		if ((cimtype != cimtypePrev) && (cimtype == CIM_DATETIME)) {
			SetThisCellToCurrentTime();
		}
	}
}



BOOL CGridCell::GetCheck()
{
	if (((CellType) m_type) != CELLTYPE_CHECKBOX) {
		return FALSE;
	}

	if (m_varValue.vt != VT_BOOL) {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_BOOL);
	}

	return m_varValue.boolVal;
}


SCODE CGridCell::GetTime(SYSTEMTIME& st, int& nOffsetMinutes)
{
	if (!IsTime()) {
		ASSERT(FALSE);
		return E_FAIL;
	}

	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	nOffsetMinutes = 0;
	if (m_varValue.vt == VT_BSTR) {
		time.SetDMTF(m_varValue.bstrVal, true);
		time.GetTime(st, nOffsetMinutes);
	}
	else {
		GetLocalTime(&st);
		nOffsetMinutes = time.LocalTimezoneOffset();
	}
	return S_OK;
}

SCODE CGridCell::SetTime(SYSTEMTIME& systime, int nOffset)
{
	if (!IsTime()) {
		ASSERT(FALSE);
		return E_FAIL;
	}


	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	time.SetTime(systime, nOffset);

	BSTR bstrDMTF = time.GetDMTF();
	if (bstrDMTF) {
		m_varValue = bstrDMTF;
		::SysFreeString(bstrDMTF);
	}
	else {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_NULL);
	}
	return S_OK;
}

SCODE CGridCell::GetTimeString(CString& sTime)
{
	if (!IsTime()) {
		ASSERT(FALSE);
		return E_FAIL;
	}

	int nOffsetMinutes = 0;
	SYSTEMTIME st;
	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	if (m_varValue.vt == VT_BSTR)
    {
		time.SetDMTF(m_varValue.bstrVal, true);
	}
	else
    {
		GetLocalTime(&st);
		time.SetTime(st, time.LocalTimezoneOffset());
	}

	time.GetTime(sTime);

	return S_OK;
}
//-----------------------------------------------------------
bool CGridCell::IsInterval(void)
{
	if(!IsTime())
    {
		return false;
	}

	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	if(m_varValue.vt == VT_BSTR)
    {
		time.SetDMTF(m_varValue.bstrVal, false);
		return !time.m_dateTime;
	}

	return false;
}

BOOL CGridCell::IsValid()
{
	if(!IsTime())
    {
		return false;
	}

	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	if(m_varValue.vt == VT_BSTR)
    {
		time.SetDMTF(m_varValue.bstrVal, false);
		return time.IsValid();
	}

	return IsNull();

}

//-----------------------------------------------------------
SCODE CGridCell::GetInterval(CString& sTime, SYSTEMTIME &st)
{
	if(!IsTime())
    {
		ASSERT(FALSE);
		return E_FAIL;
	}

	int nOffsetMinutes = 0;
	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	if (m_varValue.vt == VT_BSTR)
    {
		time.SetDMTF(m_varValue.bstrVal, false);
		time.GetInterval(sTime, st);
	}
	else
    {
        // default interval 'zero'.
        sTime = "00000000";
        st.wYear = 1900;
        st.wMonth = 1;
        st.wDayOfWeek = 1;
        st.wDay = 1;
        st.wHour = 0;
        st.wMinute = 0;
        st.wSecond = 0;
        st.wMilliseconds = 0;
	}

	return S_OK;
}

//-----------------------------------------------------------
SCODE CGridCell::SetInterval(CString sTime, SYSTEMTIME st)
{
	if(!IsTime())
    {
		ASSERT(FALSE);
		return E_FAIL;
	}

	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);
	time.SetInterval(sTime, st);

	BSTR bstrDMTF = time.GetDMTF();
	if(bstrDMTF)
    {
		m_varValue = bstrDMTF;
		::SysFreeString(bstrDMTF);
	}
	else
    {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_NULL);
	}
	return S_OK;
}


void CGridCell::SetThisCellToCurrentTime()
{
	if (m_varValue.vt != VT_BSTR) {
		m_varValue.Clear();
		m_varValue.ChangeType(VT_BSTR);
	}

	SYSTEMTIME st;
	CWbemTime time((m_dwFlags & CELLFLAG_INTERVAL) != 0);

	GetLocalTime(&st);
	time.SetTime(st, time.LocalTimezoneOffset());

	CString sTime;
	sTime = time.GetDMTF();
	m_varValue = sTime;
	m_type.SetCimtype(CIM_DATETIME);
}



//***********************************************************
// CGridCell::FindCellPos
//
// Find this cell's row and column index in the grid.
//
// Parameters:
//		[out] int& iRow
//			The row index is returned here.
//
//		[out] int& iCol
//			The column index is returned here.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGridCell::FindCellPos(int& iRow, int& iCol)
{
	iRow = m_pRow->GetRow();
	iCol = m_pRow->FindCol(this);
}




//**************************************************************
// CGridCell::CompareDifferentCelltypes
//
// Compare this cell to another cell that has a different cell type.
// Noremally, only cells of the same celltype will be compared since
// all cells in a column of a grid are normally the same type.  This
// method is implemented just  in case the celltypes in a column are
// different one day.  In the event that it is used one day, a better
// comparison algorithm should be used.  For example, there are multiple
// celltypes whos value is represented by a string and a string
// comparison could be used, etc.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareDifferentCelltypes(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) != ((CellType)pgc->m_type));

	int iResult;
	switch((CellType) m_type) {
	case CELLTYPE_CIMTYPE_SCALAR:
		if (((CellType) pgc->m_type) == CELLTYPE_VARIANT) {
			iResult = CompareStrings(pgc);
			return iResult;
		}

		break;
	case CELLTYPE_VARIANT:
		if (((CellType) pgc->m_type) == CELLTYPE_CIMTYPE_SCALAR) {
			iResult = CompareStrings(pgc);
			return iResult;
		}

		break;
	}

	if (((CellType) m_type) < ((CellType) pgc->m_type)) {
		return -1;
	}
	else {
		return 1;
	}
}




//**************************************************************
// CGridCell::CompareCimtypeUint8
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_UINT8.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeUint8(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_UINT8);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;


	__int64 i64Val;
	unsigned __int64 ui64Val;




	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
		ASSERT(pgc->m_varValue.vt == VT_UI1);
		if ((unsigned int) m_varValue.bVal < (unsigned int) pgc->m_varValue.bVal) {
			return -1;
		}
		else if (m_varValue.bVal == pgc->m_varValue.bVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:				// VT_I2
		ASSERT(pgc->m_varValue.vt == VT_I2);
		if (pgc->m_varValue.iVal < 0) {
			return 1;
		}
		else if (((unsigned int) m_varValue.bVal) < (unsigned int) pgc->m_varValue.iVal) {
			return -1;
		}
		else if (((unsigned int) m_varValue.bVal) == (unsigned int) pgc->m_varValue.iVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
		ASSERT(pgc->m_varValue.vt == VT_I4);
		ASSERT(pgc->m_varValue.lVal >= 0);

		if (pgc->m_varValue.lVal < 0) {
			return 1;
		}
		else if (((unsigned long) m_varValue.bVal) < (unsigned long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((unsigned long) m_varValue.bVal) == (unsigned long) pgc->m_varValue.lVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_CHAR16:
	case CIM_SINT16:				// VT_I2	Signed 16-bit integer
		if (pgc->m_varValue.iVal < 0) {
			return 1;
		}

		if (((unsigned int) m_varValue.bVal) < (unsigned int) pgc->m_varValue.iVal) {
			return -1;
		}
		else if (((unsigned int) m_varValue.bVal) == (unsigned int) pgc->m_varValue.iVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
		if (pgc->m_varValue.lVal < 0) {
			return 1;
		}

		if (((unsigned long) m_varValue.bVal) < (unsigned long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((unsigned long) m_varValue.bVal) == (unsigned long) pgc->m_varValue.lVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_UINT32:				// VT_I4	Unsigned 32-bit integer
		if (((unsigned long) m_varValue.bVal) < (unsigned long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((unsigned long) m_varValue.bVal) ==  (unsigned long) pgc->m_varValue.lVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;


	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		sValue = pgc->m_varValue.bstrVal;
		ui64Val = atoi64(sValue);
		if (m_varValue.bVal < ui64Val) {
			return -1;
		}
		else if (m_varValue.bVal == ui64Val) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_SINT64:				// VT_BSTR	Signed 64-bit integer
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		sValue = pgc->m_varValue.bstrVal;
		i64Val = atoi64(sValue);
		if (i64Val < 0) {
			return -1;
		}

		if (m_varValue.bVal < i64Val) {
			return -1;
		}
		else if (m_varValue.bVal == i64Val) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		sValue = pgc->m_varValue.bstrVal;

		i64Val = atoi64(sValue);
		if (((int) m_varValue.bVal) < i64Val) {
			return -1;
		}
		else if (m_varValue.bVal == i64Val) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		return CompareCimtypes(pgc);
		break;
	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.bVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.bVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.bVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.bVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	default:
		return CompareCimtypes(pgc);
		break;
	}
	return iResult;
}


//**************************************************************
// CGridCell::CompareCimtypes
//
// Compare two cells based only on the cimtypes.  This is used
// when comparing two cells of different cimtypes when there is
// no practical way to compare the values in a meaningful way.
//
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypes(CGridCell* pgc)
{
	CIMTYPE cimtype1 = (CIMTYPE) m_type;
	CIMTYPE cimtype2 = (CIMTYPE) pgc->m_type;
	if (cimtype1 < cimtype2) {
		return -1;
	}
	else if (cimtype1 == cimtype2) {
		return 0;
	}
	else {
		return 1;
	}
}



//**************************************************************
// CGridCell::CompareCimtypeSint8
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_UINT8.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeSint8(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_SINT8);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Val1;
	__int64 i64Val2;
	unsigned __int64 ui64Val1;
	unsigned __int64 ui64Val2;

	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_EMPTY:
		return -1;
	case CIM_UINT8:			// VT_UI1
		ASSERT(pgc->m_varValue.vt == VT_UI1);
		if (m_varValue.iVal < 0) {
			return -1;
		}

		if ((int) m_varValue.iVal < (int) pgc->m_varValue.bVal) {
			return -1;
		}
		else if ((int) m_varValue.iVal == (int) pgc->m_varValue.bVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:				// VT_I2
		ASSERT(pgc->m_varValue.vt == VT_I2);
		if (((int) m_varValue.iVal) < (int) pgc->m_varValue.iVal) {
			return -1;
		}
		else if (((int) m_varValue.iVal) == (int) pgc->m_varValue.iVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
		ASSERT(pgc->m_varValue.vt == VT_I4);
		ASSERT(pgc->m_varValue.lVal >= 0);
		if (m_varValue.iVal < 0) {
			return -1;
		}

		if (((long) m_varValue.iVal) < (long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((long) m_varValue.iVal) == (long) pgc->m_varValue.lVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_CHAR16:
	case CIM_SINT16:				// VT_I2	Signed 16-bit integer
		if (((int) m_varValue.iVal) < (int) pgc->m_varValue.iVal) {
			return -1;
		}
		else if (((int) m_varValue.iVal) == (int) pgc->m_varValue.iVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
		if (((int) m_varValue.iVal) < (long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((int) m_varValue.iVal) == (long) pgc->m_varValue.lVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_UINT32:				// VT_I4	Unsigned 32-bit integer
		if ((long) m_varValue.iVal < 0) {
			return -1;
		}

		if (((unsigned long) m_varValue.iVal) < (unsigned long) pgc->m_varValue.lVal) {
			return -1;
		}
		else if (((unsigned long) m_varValue.iVal) ==  (unsigned long) pgc->m_varValue.iVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;


	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		if (m_varValue.iVal < 0) {
			return -1;
		}


		sValue = pgc->m_varValue.bstrVal;
		ui64Val2 = atoi64(sValue);
		ui64Val1 = (unsigned int) m_varValue.iVal;

		if (ui64Val1 < ui64Val2) {
			return -1;
		}
		else if (ui64Val1 == ui64Val2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_SINT64:				// VT_BSTR	Signed 64-bit integer
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		sValue = pgc->m_varValue.bstrVal;

		i64Val1 = m_varValue.iVal;
		i64Val2 = atoi64(sValue);

		if (i64Val1 < i64Val2) {
			return -1;
		}
		else if (i64Val1 == i64Val2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		sValue = pgc->m_varValue.bstrVal;

		i64Val2 = atoi64(sValue);
		if (((int) m_varValue.iVal) < i64Val2) {
			return -1;
		}
		else if (m_varValue.iVal == i64Val2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		return -1;
	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.iVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.iVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.iVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.iVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	default:
		return CompareCimtypes(pgc);
		break;
	}
	return iResult;
}


int CGridCell::CompareNumberToString(unsigned __int64 ui64Op1, LPCTSTR pszValue)
{
	if (!IsNumber(pszValue)) {
		return -1;
	}

	__int64 i64Op2 = atoi64(pszValue);
	if (i64Op2 < 0) {
		return 1;
	}

	if (ui64Op1 < (unsigned __int64) i64Op2) {
		return -1;
	}
	else if (ui64Op1 == (unsigned __int64) i64Op2) {
		return 0;
	}
	else {
		return 1;
	}

}

__int64 CGridCell::ToInt64(SCODE& sc)
{
	__int64 i64Val = 0;
	sc = S_OK;
	CString sValue;

	switch(((CellType) m_type)) {
	case CELLTYPE_VOID:	// An empty cell.
	case CELLTYPE_ATTR_TYPE:			// An attribute type.
	case CELLTYPE_NAME:				// A property or attribute name.
	case CELLTYPE_CIMTYPE_SCALAR:	// A cimtype that is not an array
	case CELLTYPE_CIMTYPE:			// A cimtype
	case CELLTYPE_CHECKBOX:			// A checkbox
	case CELLTYPE_PROPMARKER:		// A property marker icon
	case CELLTYPE_ENUM_TEXT:			// An enum edit box.
		sc = E_FAIL;		// Non numeric value
		return 0;

	case CELLTYPE_VARIANT:			// A variant value.
		if (m_varValue.vt == VT_NULL) {
			sc = E_FAIL;
			return 0;
		}

		switch(((CIMTYPE) m_type)) {
		case CIM_UINT8:				// VT_UI1
			ASSERT(m_varValue.vt == VT_UI1);
			i64Val = m_varValue.bVal;
			break;
		case CIM_SINT8:				// VT_I2
			ASSERT(m_varValue.vt == VT_I2);
			i64Val = m_varValue.iVal;
			break;
		case CIM_UINT16:			// VT_I4	Unsigned 16-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			i64Val = m_varValue.lVal;
			break;
		case CIM_CHAR16:
		case CIM_SINT16:			// VT_I2	Signed 16-bit integer
			ASSERT(m_varValue.vt == VT_I2);
			i64Val = m_varValue.iVal;
			break;
		case CIM_SINT32:			// VT_I4	Signed 32-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			i64Val = m_varValue.lVal;
			break;
		case CIM_UINT32:			// VT_I4	Unsigned 32-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			i64Val = (unsigned long) m_varValue.lVal;
			break;
		case CIM_UINT64:			// VT_BSTR	Unsigned 64-bit integer
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			i64Val = atoi64(sValue);
			break;
		case CIM_SINT64:			// VT_BSTR	Signed 64-bit integer
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			i64Val = atoi64(sValue);
			break;
		case CIM_STRING:			// VT_BSTR	UCS-2 string
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			if (!IsNumber(sValue)) {
				sc = E_FAIL;
				i64Val = 0;
			}
			sValue = m_varValue.bstrVal;
			i64Val = atoi64(sValue);
			break;
		case CIM_BOOLEAN:				// VT_BOOL	Boolean
			ASSERT(m_varValue.vt == VT_BOOL);
			if (m_varValue.boolVal) {
				i64Val = 1;
			}
			else {
				i64Val = 0;
			}
			break;
		case CIM_REAL32:			// VT_R4	IEEE 4-byte floating-point
			ASSERT(m_varValue.vt == VT_R4);
			i64Val = (__int64) m_varValue.fltVal;
			break;
		case CIM_REAL64:			// VT_R8	IEEE 8-byte floating-point
			ASSERT(m_varValue.vt == VT_R8);
			i64Val = (__int64) m_varValue.dblVal;
			break;
		case CIM_DATETIME:			// VT_BSTR	A string containing a date-time
			ASSERT(m_varValue.vt == VT_BSTR);
			i64Val = 0;
			sc = E_FAIL;
			break;
		case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
		case CIM_OBJECT:			// VT_UNKNOWN	Weakly-typed embedded instance
			i64Val = 0;
			sc = E_FAIL;
			break;


		}
		break;
	}
	return i64Val;



}







unsigned __int64 CGridCell::ToUint64(SCODE& sc)
{
	unsigned __int64 ui64Val = 0;
	__int64 i64Val = 0;
	sc = S_OK;
	CString sValue;

	switch(((CellType) m_type)) {
	case CELLTYPE_VOID:	// An empty cell.
	case CELLTYPE_ATTR_TYPE:			// An attribute type.
	case CELLTYPE_NAME:				// A property or attribute name.
	case CELLTYPE_CIMTYPE_SCALAR:	// A cimtype that is not an array
	case CELLTYPE_CIMTYPE:			// A cimtype
	case CELLTYPE_CHECKBOX:			// A checkbox
	case CELLTYPE_PROPMARKER:		// A property marker icon
	case CELLTYPE_ENUM_TEXT:			// An enum edit box.
		sc = E_FAIL;		// Non numeric value
		return 0;

	case CELLTYPE_VARIANT:			// A variant value.
		if (m_varValue.vt == VT_NULL) {
			sc = E_FAIL;
			return 0;
		}

		switch(((CIMTYPE) m_type)) {
		case CIM_UINT8:				// VT_UI1
			ASSERT(m_varValue.vt == VT_UI1);
			ui64Val = m_varValue.bVal;
			break;
		case CIM_SINT8:				// VT_I2
			ASSERT(m_varValue.vt == VT_I2);
			ui64Val = m_varValue.iVal;
			break;
		case CIM_UINT16:			// VT_I4	Unsigned 16-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			ui64Val = m_varValue.lVal;
			break;
		case CIM_CHAR16:
		case CIM_SINT16:			// VT_I2	Signed 16-bit integer
			ASSERT(m_varValue.vt == VT_I2);
			ui64Val = m_varValue.iVal;
			break;
		case CIM_SINT32:			// VT_I4	Signed 32-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			ui64Val = m_varValue.lVal;
			break;
		case CIM_UINT32:			// VT_I4	Unsigned 32-bit integer
			ASSERT(m_varValue.vt == VT_I4);
			ui64Val = (unsigned long) m_varValue.lVal;
			break;
		case CIM_UINT64:			// VT_BSTR	Unsigned 64-bit integer
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			ui64Val = atoi64(sValue);
			break;
		case CIM_SINT64:			// VT_BSTR	Signed 64-bit integer
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			ui64Val = atoi64(sValue);
			break;
		case CIM_STRING:			// VT_BSTR	UCS-2 string
			ASSERT(m_varValue.vt == VT_BSTR);
			sValue = m_varValue.bstrVal;
			if (!IsNumber(sValue)) {
				sc = E_FAIL;
				ui64Val = 0;
			}
			sValue = m_varValue.bstrVal;
			i64Val = atoi64(sValue);
			if (i64Val >= 0) {
				ui64Val = (unsigned __int64) i64Val;
			}
			else {
				sc = E_FAIL;
				ui64Val = 0;
			}
			break;
		case CIM_BOOLEAN:				// VT_BOOL	Boolean
			ASSERT(m_varValue.vt == VT_BOOL);
			if (m_varValue.boolVal) {
				ui64Val = 1;
			}
			else {
				ui64Val = 0;
			}
			break;
		case CIM_REAL32:			// VT_R4	IEEE 4-byte floating-point
			ASSERT(m_varValue.vt == VT_R4);
			ui64Val = (unsigned __int64) m_varValue.fltVal;
			break;
		case CIM_REAL64:			// VT_R8	IEEE 8-byte floating-point
			ASSERT(m_varValue.vt == VT_R8);
			ui64Val = (unsigned __int64) m_varValue.dblVal;
			break;
		case CIM_DATETIME:			// VT_BSTR	A string containing a date-time
			ASSERT(m_varValue.vt == VT_BSTR);
			ui64Val = 0;
			sc = E_FAIL;
			break;
		case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
		case CIM_OBJECT:			// VT_UNKNOWN	Weakly-typed embedded instance
			ui64Val = 0;
			sc = E_FAIL;
			break;


		}
		break;
	}
	return ui64Val;
}


BOOL CGridCell::IsNumber(LPCTSTR pszValue)
{
	// Skip any leading white space.
	while (*pszValue != 0) {
		if (!iswspace(*pszValue)) {
			break;
		}
		++pszValue;
	}

	if (*pszValue == '-' || *pszValue=='+') {
		++pszValue;
	}

	BOOL bSawDigit = FALSE;
	while (isdigit(*pszValue)) {
		bSawDigit = TRUE;
		++pszValue;
	}


	// Skip any trailing white space.
	while (*pszValue != 0) {
		if (!iswspace(*pszValue)) {
			break;
		}
		++pszValue;
	}

	if (bSawDigit && *pszValue==0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


//**************************************************************
// CGridCell::CompareCimtypeUint16
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_UINT16.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeUint16(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_UINT16);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op1, ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		ui64Op1 = ToUint64(sc);
		ui64Op2 = pgc->ToUint64(sc);
		if (ui64Op1 < ui64Op2) {
			return -1;
		}
		else if (ui64Op1 == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if ((i64Op2 < 0) || (ui64Op1 > (unsigned __int64) i64Op2)) {
			return 1;
		}
		else if (ui64Op1 == (unsigned __int64) i64Op2) {
			return 0;
		}
		else {
			return -1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(ui64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.lVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.lVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.lVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.lVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;


	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}


//**************************************************************
// CGridCell::CompareCimtypeSint16
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_SINT16.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeSint16(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT((((CIMTYPE) m_type) == CIM_SINT16) || (((CIMTYPE)m_type) == CIM_CHAR16));
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op1, i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		i64Op1 = ToInt64(sc);
		if (i64Op1 < 0) {
			return -1;
		}

		ui64Op2 = pgc->ToUint64(sc);
		if (((unsigned __int64) i64Op1) < ui64Op2) {
			return -1;
		}
		else if (((unsigned __int64)i64Op1) == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if (i64Op1 < i64Op2) {
			return -1;
		}
		else if (i64Op1 == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(i64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.iVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.iVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.iVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.iVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);

	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}

//**************************************************************
// CGridCell::CompareCimtypeSint32
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_SINT32.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeSint32(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_SINT32);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op1, i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		i64Op1 = ToInt64(sc);
		if (i64Op1 < 0) {
			return -1;
		}

		ui64Op2 = pgc->ToUint64(sc);
		if (((unsigned __int64) i64Op1) < ui64Op2) {
			return -1;
		}
		else if (((unsigned __int64)i64Op1) == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if (i64Op1 < i64Op2) {
			return -1;
		}
		else if (i64Op1 == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(i64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.lVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.lVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.lVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.lVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}




//**************************************************************
// CGridCell::CompareCimtypeUint32
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_UINT32.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeUint32(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_UINT32);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(m_varValue.vt == VT_I4);
	ASSERT(pgc->m_varValue.vt != NULL);


	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op1, ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		ui64Op1 = ToUint64(sc);
		ui64Op2 = pgc->ToUint64(sc);
		if (ui64Op1 < ui64Op2) {
			return -1;
		}
		else if (ui64Op1 == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if ((i64Op2 < 0) || (ui64Op1 > (unsigned __int64) i64Op2)) {
			return 1;
		}
		else if (ui64Op1 == (unsigned __int64) i64Op2) {
			return 0;
		}
		else {
			return -1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(ui64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (((float) m_varValue.lVal) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) m_varValue.lVal) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (((double) m_varValue.lVal) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) m_varValue.lVal) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;


	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}





//**************************************************************
// CGridCell::CompareCimtypeUint64
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_UINT64.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeUint64(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_UINT64);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(m_varValue.vt == VT_BSTR);
	ASSERT(pgc->m_varValue.vt != NULL);


	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op1, ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		ui64Op1 = ToUint64(sc);
		ui64Op2 = pgc->ToUint64(sc);
		if (ui64Op1 < ui64Op2) {
			return -1;
		}
		else if (ui64Op1 == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if ((i64Op2 < 0) || (ui64Op1 > (unsigned __int64) i64Op2)) {
			return 1;
		}
		else if (ui64Op1 == (unsigned __int64) i64Op2) {
			return 0;
		}
		else {
			return -1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		ui64Op1 = ToUint64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(ui64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		ui64Op1 = ToUint64(sc);
		ASSERT(SUCCEEDED(sc));

		if (((float)(__int64) ui64Op1) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) (__int64) ui64Op1) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		ui64Op1 = ToUint64(sc);
		ASSERT(SUCCEEDED(sc));

		if (((double) (__int64) ui64Op1) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) (__int64) ui64Op1) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;


	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}

//**************************************************************
// CGridCell::CompareCimtypeSint64
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_SINT64.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeSint64(CGridCell* pgc)
{
	ASSERT(((CellType)m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_SINT64);
	ASSERT(m_varValue.vt == VT_BSTR);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op1, i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		// Compare this unsigned 16 bit value to an unsigned operand.
		i64Op1 = ToInt64(sc);
		if (i64Op1 < 0) {
			return -1;
		}

		ui64Op2 = pgc->ToUint64(sc);
		if (((unsigned __int64) i64Op1) < ui64Op2) {
			return -1;
		}
		else if (((unsigned __int64)i64Op1) == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		i64Op2 = pgc->ToInt64(sc);
		if (i64Op1 < i64Op2) {
			return -1;
		}
		else if (i64Op1 == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		sOp2 = pgc->m_varValue.bstrVal;
		iResult = CompareNumberToString(i64Op1, sOp2);
		return iResult;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		i64Op1 = ToInt64(sc);

		if (((float) i64Op1) < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (((float) i64Op1) == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		i64Op1 = ToInt64(sc);
		if (((double) i64Op1) < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (((double) i64Op1) == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}



//**************************************************************
// CGridCell::CompareCimtypeString
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_STRING.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeString(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_STRING);
	ASSERT(m_varValue.vt == VT_BSTR);
	ASSERT(pgc->m_varValue.vt != NULL);
	CIMTYPE cimtype;

	int iResult = 0;
	CString sValue;

	__int64 i64Op1, i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op2;



	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_EMPTY:
		return -1;
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
		i64Op1 = ToInt64(sc);
		if (FAILED(sc)) {
			GetValue(sOp1, cimtype);
			pgc->GetValue(sOp2, cimtype);
			iResult = sOp1.CompareNoCase(sOp2);
			return iResult;
		}


		if (i64Op1 < 0) {
			return -1;
		}

		ui64Op2 = pgc->ToUint64(sc);
		if (((unsigned __int64) i64Op1) < ui64Op2) {
			return -1;
		}
		else if (((unsigned __int64)i64Op1) == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc);
		if (FAILED(sc)) {
			GetValue(sOp1, cimtype);
			pgc->GetValue(sOp2, cimtype);
			iResult = sOp1.CompareNoCase(sOp2);
			return iResult;
		}

		i64Op2 = pgc->ToInt64(sc);
		if (i64Op1 < i64Op2) {
			return -1;
		}
		else if (i64Op1 == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_STRING:			// VT_BSTR	UCS-2 string
		ASSERT(pgc->m_varValue.vt == VT_BSTR);

		iResult = ::CompareNoCase(m_varValue.bstrVal, pgc->m_varValue.bstrVal);
		return iResult;
	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:			// VT_UNKNOWN	Weakly-typed embedded instance
		return -1;

	default:
	case CIM_BOOLEAN:				// VT_BOOL	Boolean
	case CIM_REAL32:			// VT_R4	IEEE 4-byte floating-point
	case CIM_REAL64:			// VT_R8	IEEE 8-byte floating-point
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}


//**************************************************************
// CGridCell::CompareCimtypeBool
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_BOOL.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeBool(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_BOOLEAN);
	ASSERT(m_varValue.vt == VT_BOOL);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;

	unsigned __int64 ui64Op2;

	switch(((CIMTYPE) pgc->m_type))
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer


		ui64Op2 = pgc->ToUint64(sc);
		if (!m_varValue.boolVal && ui64Op2) {
			return -1;
		}
		else if (m_varValue.boolVal && !ui64Op2) {
			return 1;
		}
		else {
			return 0;
		}

		break;

	case CIM_SINT8:			// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
	case CIM_BOOLEAN:				// VT_BOOL	Boolean
		i64Op2 = pgc->ToInt64(sc);
		if (!m_varValue.boolVal && i64Op2) {
			return -1;
		}
		else if (m_varValue.boolVal && !i64Op2) {
			return 1;
		}
		else {
			return 0;
		}
		break;
	case CIM_REAL32:			// VT_R4	IEEE 4-byte floating-point
		if (!m_varValue.boolVal && pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (m_varValue.boolVal && !pgc->m_varValue.fltVal) {
			return 1;
		}
		else {
			return 0;
		}
		break;
	case CIM_REAL64:			// VT_R8	IEEE 8-byte floating-point
		if (!m_varValue.boolVal && pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (m_varValue.boolVal && !pgc->m_varValue.dblVal) {
			return 1;
		}
		else {
			return 0;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:			// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
	case CIM_STRING:			// VT_BSTR	UCS-2 string
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}



//**************************************************************
// CGridCell::CompareCimtypeReal32
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_REAL32
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeReal32(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_REAL32);
	ASSERT(m_varValue.vt == VT_R4);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;




	switch((CIMTYPE) pgc->m_type)
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		if (m_varValue.fltVal < 0) {
			return -1;
		}

		i64Op2 = pgc->ToInt64(sc);
		if (m_varValue.fltVal < i64Op2) {
			return -1;
		}
		else if (m_varValue.fltVal == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op2 = pgc->ToInt64(sc);
		if (m_varValue.fltVal < i64Op2) {
			return -1;
		}
		else if (m_varValue.fltVal == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (m_varValue.fltVal < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (m_varValue.fltVal == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (m_varValue.fltVal < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (m_varValue.fltVal == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}



//**************************************************************
// CGridCell::CompareCimtypeReal64
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_REAL64
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeReal64(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_REAL64);
	ASSERT(m_varValue.vt == VT_R8);
	ASSERT(pgc->m_varValue.vt != NULL);

	int iResult = 0;
	CString sValue;

	__int64 i64Op2;
	CString sOp1, sOp2;
	SCODE sc = S_OK;


	switch((CIMTYPE)pgc->m_type)
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		if (m_varValue.fltVal < 0) {
			return -1;
		}

		i64Op2 = pgc->ToInt64(sc);
		if (m_varValue.dblVal < i64Op2) {
			return -1;
		}
		else if (m_varValue.dblVal == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op2 = pgc->ToInt64(sc);
		if (m_varValue.dblVal < i64Op2) {
			return -1;
		}
		else if (m_varValue.dblVal == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		if (m_varValue.dblVal < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (m_varValue.dblVal == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		if (m_varValue.dblVal < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (m_varValue.dblVal == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		iResult = DefaultCompare(pgc);
		return iResult;
	}
	return iResult;
}



//**************************************************************
// CGridCell::CompareCimtypeDatetime
//
// Compare this cell to another cell.  Both cells are of CELLTYPE_VARIANT
// and the cimtype of this cell is CIMTYPE_DATETIME
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::CompareCimtypeDatetime(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(((CIMTYPE) m_type) == CIM_DATETIME);
	ASSERT(m_varValue.vt == VT_BSTR);
	ASSERT(pgc->m_varValue.vt != NULL);
	CIMTYPE cimtype;

	int iResult = 0;
	CString sValue;

	__int64 i64Op1, i64Op2;
	CString sOp1, sOp2;
	SCODE sc1, sc2;
	sc1 = S_OK;
	sc2 = S_OK;

	unsigned __int64 ui64Op1;
	unsigned __int64 ui64Op2;

	switch((CIMTYPE) pgc->m_type)
	{
	case CIM_UINT8:			// VT_UI1
	case CIM_UINT16:		// VT_I4	Unsigned 16-bit integer
	case CIM_UINT32:		// VT_I4	Unsigned 32-bit integer
	case CIM_UINT64:		// VT_BSTR	Unsigned 64-bit integer
	case CIM_BOOLEAN:			// VT_BOOL	Boolean
		ui64Op1 = ToUint64(sc1);
		ui64Op2 = pgc->ToUint64(sc2);
		if (FAILED(sc1) || FAILED(sc2)) {
			GetValue(sOp1, cimtype);
			pgc->GetValue(sOp2, cimtype);
			iResult = sOp1.CompareNoCase(sOp2);
			return iResult;
		}
		if (ui64Op1 < ui64Op2) {
			return -1;
		}
		else if (ui64Op1 == ui64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_SINT8:			// VT_I2
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:		// VT_I2	Signed 16-bit integer
	case CIM_SINT32:		// VT_I4	Signed 32-bit integer
	case CIM_SINT64:		// VT_BSTR	Signed 64-bit integer
		// Compare this unsigned 16 bit value to a signed operand
		i64Op1 = ToInt64(sc1);
		i64Op2 = pgc->ToInt64(sc2);
		if (FAILED(sc1) || FAILED(sc2)) {
			iResult = DefaultCompare(pgc);
			return iResult;
		}
		if (i64Op1 < i64Op2) {
			return -1;
		}
		else if (i64Op1 == i64Op2) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL32:		// VT_R4	IEEE 4-byte floating-point
		i64Op1 = ToInt64(sc1);
		if (FAILED(sc1)) {
			iResult = DefaultCompare(pgc);
			return iResult;
		}

		if (i64Op1 < pgc->m_varValue.fltVal) {
			return -1;
		}
		else if (i64Op1 == pgc->m_varValue.fltVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		i64Op1 = ToInt64(sc1);
		if (i64Op1 < pgc->m_varValue.dblVal) {
			return -1;
		}
		else if (i64Op1 == pgc->m_varValue.dblVal) {
			return 0;
		}
		else {
			return 1;
		}
		break;

	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_EMPTY:
		return CompareCimtypes(pgc);
	default:
	case CIM_DATETIME:		// VT_BSTR	A string containing a date-time
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		iResult = DefaultCompare(pgc);
		return iResult;
		break;
	}
	return iResult;
}





//**************************************************************
// CGridCell::DefaultCompare
//
// Compare this cell to another by doing a case insensitive comparison
// of the string values of the two cells.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the second operand of the comparison.  The first
//			operand is this grid cell.
//
// Returns:
//		-1 if this cell is less than the second operand.
//		0  if this cell is equal to the second operand.
//		1  if this cell is greater than the second operand.
//
//************************************************************
int CGridCell::DefaultCompare(CGridCell* pgc)
{
	CString sOp1, sOp2;
	CIMTYPE cimtype;
	GetValue(sOp1, cimtype);
	GetValue(sOp2, cimtype);
	int iResult = sOp1.CompareNoCase(sOp2);
	return iResult;
}

//************************************************************
// CGridCell::CompareStrings
//
// This method is called to compare two cells that contain string
// values in their m_varValue members.
//
// Parameters:
//		[in] CGridCell* pgc
//			A pointer to the second operand of the comparison.  The
//			first operand is this cell.
//
// Returns:
//		<0  If operand1 is less than operand2
//		0	If operand1 is equal to operand2
//		>0  If operand1 is greater than operand2
//
//**************************************************************
int CGridCell::CompareStrings(CGridCell* pgc)
{
	if (m_varValue.vt == VT_NULL) {
		if (pgc->m_varValue.vt != VT_NULL) {
			return -1;
		}
		else if (pgc->m_varValue.vt == VT_NULL) {
			return 0;
		}
		else {
			return 1;
		}
	}

	if (pgc->m_varValue.vt == VT_NULL) {
		return 1;
	}


	int iResult;
	if ((m_varValue.vt != VT_BSTR) || (pgc->m_varValue.vt != VT_BSTR) ) {
		CString sValueThis;
		CIMTYPE cimtypeThis;
		GetValue(sValueThis, cimtypeThis);

		CString sValueThat;
		CIMTYPE cimtypeThat;
		pgc->GetValue(sValueThat, cimtypeThat);

		iResult = sValueThis.CompareNoCase(sValueThat);
		return iResult;
	}

	iResult = ::CompareNoCase(m_varValue.bstrVal, pgc->m_varValue.bstrVal);
	return iResult;
}




//************************************************************
// CGridCell::CompareCimtypeValues
//
// This method is called when this GridCell is a CELLTYPE_VARIANT.
// The cells of CELLTYPE_VARIANT may consist of many different
// cimtypes.  Each of these cimtypes needs to be handled differently
// when comparing values.  For example, it may be necessary to compare
// two dates to each other or a date to a string, etc.
//
// Parameters:
//		[in] CGridCell* pgc
//			A pointer to the second operand of the comparison.  The
//			first operand is this cell.
//
// Returns:
//		<0  If operand1 is less than operand2
//		0	If operand1 is equal to operand2
//		>0  If operand1 is greater than operand2
//
//**************************************************************
int CGridCell::CompareCimtypeValues(CGridCell* pgc)
{
	ASSERT(((CellType) m_type) == CELLTYPE_VARIANT);
	ASSERT(((CellType) pgc->m_type) == CELLTYPE_VARIANT);
	ASSERT(m_varValue.vt != VT_NULL);
	ASSERT(pgc->m_varValue.vt != NULL);

	// An array value is larger than any non-array value.
	// If both cells are arrays, we consider them equal.
	if (IsArray() ) {
		if (pgc->IsArray()) {
			return 0;
		}
		else {
			return 1;
		}
	}
	if (pgc->IsArray()) {
		return -1;
	}


	int iResult = 0;

	// At this point, we know we are comparing cells that
	// have the same cimtypes.
	switch((CIMTYPE) m_type) {
	case CIM_EMPTY:			//
		if (((CIMTYPE)pgc->m_type) != CIM_EMPTY) {
			return -1;
		}
		else {
			return 0;
		}
		break;

	case CIM_UINT8:
		iResult = CompareCimtypeUint8(pgc);
		break;
	case CIM_SINT8:				// I2
		iResult = CompareCimtypeSint8(pgc);
		break;
	case CIM_UINT16:				// VT_I4	Unsigned 16-bit integer
		iResult = CompareCimtypeUint16(pgc);
		break;
	case CIM_CHAR16:		// VT_I2
	case CIM_SINT16:				// VT_I2	Signed 16-bit integer
		iResult = CompareCimtypeSint16(pgc);
		break;
	case CIM_SINT32:				// VT_I4	Signed 32-bit integer
		iResult = CompareCimtypeSint32(pgc);
		break;
	case CIM_UINT32:				// VT_I4	Unsigned 32-bit integer
		iResult = CompareCimtypeUint32(pgc);
		break;
	case CIM_UINT64:				// VT_BSTR	Unsigned 64-bit integer
		iResult = CompareCimtypeUint64(pgc);
		break;
	case CIM_SINT64:				// VT_BSTR	Signed 64-bit integer
		iResult = CompareCimtypeSint64(pgc);
		break;
	case CIM_STRING:				// VT_BSTR	UCS-2 string
		iResult = CompareCimtypeString(pgc);
		break;
	case CIM_BOOLEAN:				// VT_BOOL	Boolean
		iResult = CompareCimtypeBool(pgc);
		break;
	case CIM_REAL32:				// VT_R4	IEEE 4-byte floating-point
		iResult = CompareCimtypeReal32(pgc);
		break;
	case CIM_REAL64:				// VT_R8	IEEE 8-byte floating-point
		iResult = CompareCimtypeReal64(pgc);
		break;
	case CIM_DATETIME:			// VT_BSTR	A string containing a date-time
		iResult = CompareCimtypeDatetime(pgc);
		break;
	case CIM_OBJECT:				// VT_UNKNOWN	Weakly-typed embedded instance
	case CIM_REFERENCE:				// VT_BSTR	Weakly-typed reference
		if (((CIMTYPE) m_type) < ((CIMTYPE) pgc->m_type)) {
			return -1;
		}
		else if (((CIMTYPE) m_type) == ((CIMTYPE) pgc->m_type)) {
			return 0;
		}
		else {
			return 1;
		}
		break;
	default:
		iResult = DefaultCompare(pgc);
		break;
	}

	return iResult;
}


int CGridCell::Compare(CGridCell* pgc)
{
	int iResult = 0;

	// Handle the case where either cell is void
	if (((CellType) m_type) == CELLTYPE_VOID) {
		// A "void" is less than anything else
		if (((CellType) pgc->m_type) == CELLTYPE_VOID) {
			return 0;
		}
		else {
			return -1;
		}
	}

	if (((CellType) pgc->m_type) == CELLTYPE_VOID) {
		return 1;
	}





	// Handle the case where either operand contains a NULL value.
	if (IsNull()) {
		if (pgc->IsNull()) {
			// Both operands are null, use the order of the cell types to
			// distinguish othewise identical cells.
			if (((CellType) m_type) == ((CellType) pgc->m_type)) {
				return 0;
			}
			else if (((CellType) m_type) > ((CellType) pgc->m_type)) {
				return 1;
			}
			else {
				return -1;
			}
		}
		else {
			// Less: Left operand NULL, right operant non-null
			return -1;
		}
	}
	if (pgc->IsNull()) {
		// Greater: Left operand not null, right operand null
		return 1;
	}



	if (((CellType) m_type) != ((CellType) pgc->m_type)) {
		iResult = CompareDifferentCelltypes(pgc);
		return iResult;
	}


	switch (((CellType) m_type))
	{
	case CELLTYPE_ATTR_TYPE:
	case CELLTYPE_NAME:
	case CELLTYPE_CIMTYPE_SCALAR:
	case CELLTYPE_CIMTYPE:
	case CELLTYPE_ENUM_TEXT:
	default:
		switch((CellType) pgc->m_type) {
		case CELLTYPE_CHECKBOX:
		case CELLTYPE_PROPMARKER:
			// Any attribute type is greater than any checkbox of propmarker.
			return 1;
			break;
		default:
			iResult = CompareStrings(pgc);
			return iResult;
			break;
		}
		break;
	case CELLTYPE_CHECKBOX:
		switch((CellType) pgc->m_type) {
		case CELLTYPE_CHECKBOX:
			if ((m_varValue.vt==VT_BOOL) && (pgc->m_varValue.vt == VT_BOOL)) {
				if (!m_varValue.boolVal && pgc->m_varValue.boolVal) {
					return -1;
				}
				else if (!m_varValue.boolVal && !pgc->m_varValue.boolVal) {
					return 0;
				}
				else if (m_varValue.boolVal && pgc->m_varValue.boolVal) {
					return 0;
				}
				else {
					return 1;
				}
			}
			else {
				if (m_varValue.vt < pgc->m_varValue.vt) {
					return -1;
				}
				else if (m_varValue.vt == pgc->m_varValue.vt) {
					return 0;
				}
				else {
					return 1;
				}
			}


			break;
		default:
			if (((CellType) m_type) < ((CellType) pgc->m_type)) {
				return -1;
			}
			else if (((CellType) m_type) == ((CellType) pgc->m_type)) {
				return 0;
			}
			else {
				return 1;
			}
			break;
		}


		break;
	case CELLTYPE_PROPMARKER:
		switch((CellType) pgc->m_type) {
		case CELLTYPE_PROPMARKER:
			if (m_propmarker == pgc->m_propmarker) {
				return 0;
			}
			else if (m_propmarker > pgc->m_propmarker) {
				return 1;
			}
			else {
				return -1;
			}
			break;
		default:
			if (((CellType) m_type) < ((CellType) pgc->m_type)) {
				return -1;
			}
			else if (((CellType) m_type) == ((CellType) pgc->m_type)) {
				return 0;
			}
			else {
				return 1;
			}
			break;
		}
		break;
	case CELLTYPE_VARIANT:
		iResult = CompareCimtypeValues(pgc);
		return iResult;

	}


}








CGridRow::CGridRow(CGrid* pGrid, int nCols)
{
	m_dwTag = 0;
	m_pGrid = pGrid;
	m_iRow = NULL_INDEX;
	m_lFlavor = 0;
	m_dwFlags = 0;
	m_bModified = FALSE;
	m_bReadonly = FALSE;
	m_iState = 0;
	for (int iCol=0; iCol < nCols; ++iCol) {
		CGridCell* pgc = new CGridCell(pGrid, this);
		m_aCells.Add(pgc);
	}
	m_inSig = NULL;
	m_outSig = NULL;
	m_currID = 0;

}


CGridRow::~CGridRow()
{
	int nCols = (int) m_aCells.GetSize();
	for (int iCol = 0; iCol < nCols; ++iCol) {
		CGridCell* pgc = (CGridCell*) m_aCells[iCol];
		delete pgc;
	}
	m_aCells.RemoveAll();
}





void CGridRow::SetState(int iMask, int iState)
{
	iState = iState & iMask;
	m_iState = (m_iState & ~iMask) | iState;
}

CGridCell& CGridRow::operator[](int iCol)
{
	ASSERT((iCol >= 0) && (iCol < m_aCells.GetSize()));
	return * (CGridCell*) m_aCells[iCol];
}


//********************************************************
// CGridRow::FindCol
//
// Given a pointer to a grid cell that appears in this row,
// return its column index.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to a grid cell that appears in one of the
//			columns of this row.
//
// Returns:
//		The cell's column index.
//
//********************************************************
int CGridRow::FindCol(CGridCell* pgc)
{
	int nCols = (int) m_aCells.GetSize();
	for (int iCol=0; iCol<nCols; ++iCol) {
		if (pgc == m_aCells[iCol]) {
			return iCol;
		}
	}
	return NULL_INDEX;
}



//********************************************************
// CGridRow::FindCell
//
// Given a pointer to a grid cell that appears in this row,
// return its row and column index.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to a grid cell that appears in one of the
//			columns of this row.
//
//		[out] int& iRow
//			This is where the row index is returned.  NULL_INDEX if the
//			cell isn't found.
//
//		[out] int& iCol
//			This is where the column index is returned.  NULL_INDEX if the
//			cell isn't found.
//
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridRow::FindCell(CGridCell* pgc, int& iRow, int& iCol)
{
	iCol = FindCol(pgc);
	if (iCol == NULL_INDEX) {
		iRow = NULL_INDEX;
	}
	else {
		iRow = m_iRow;
	}

}



//*********************************************
// CGridRow::SetReadonlyEx
//
// Mark the row and all of the cells in the row
// as readonly.  This method should probably
// just replace CGridRow::SetReadonly, but it is
// not clear at this time whether this change in
// semantics will break the code elsewhere.
//
// Parameters:
//		[in] BOOL bReadonly
//
// Returns:
//		Nothing.
//
//**********************************************
void CGridRow::SetReadonlyEx(BOOL bReadonly)
{
	int nCols = (int) m_aCells.GetSize();
	for (int iCol=0; iCol<nCols; ++iCol) {
		CGridCell* pgc = (CGridCell*) m_aCells[iCol];
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
	}
}




//********************************************************
// CGridRow::InsertColumnAt
//
// Insert a column at the specified index.
//
// Parameters:
//		int iCol
//			After the insertion, the new column has this index.
//			This is a zero-based index.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridRow::InsertColumnAt(int iCol)
{
	CGridCell* pgc = new CGridCell(m_pGrid, this);
	m_aCells.InsertAt(iCol, pgc, 1);
}




//********************************************************
// CGridRow::SetModified
//
// Set the rows modified flag.  Setting it to FALSE also
// clears the modified flag for each cell in the row.
//
// Parameters:
//		[in] BOOL bModified
//			TRUE to mark the entire row as modified, FALSE
//			otherwise.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridRow::SetModified(BOOL bModified)
{
	m_bModified = bModified;

	if (!bModified) {
		int nCells = GetSize();
		for (int iCell=0; iCell < nCells; ++iCell) {
			CGridCell* pgc = (CGridCell*) m_aCells[iCell];
			pgc->SetModified(FALSE);
		}
	}
}



//***********************************************************
// CGridRow::Redraw
//
// Redraw this row.
//
// Paramters:
//		None.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CGridRow::Redraw()
{
	int nCells = (int) m_aCells.GetSize();
	for (int iCell=0; iCell < nCells; ++iCell) {
		m_pGrid->RedrawCell(m_iRow, iCell);
	}
}


//*********************************************************
// CGridCellArray::DeleteColumnAt
//
// Remove the column at the specified index.
//
// Parameters:
//		int iCol
//			The zero-based index of the column to remove.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGridRow::DeleteColumnAt(int iCol)
{
	ASSERT((iCol >=0) && (iCol < m_aCells.GetSize()));
	CGridCell* pgc = (CGridCell*) m_aCells[iCol];
	m_aCells.RemoveAt(iCol);
	delete pgc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gctype.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "gctype.h"
#include "gc.h"

#include "utils.h"




//***************************************************
// The purpose of the CGcType class is to encapsulate
// all of the type information for a grid cell.
//
// The members that make up the gridcell type are:
//		The CellType.  This is type describes the general
//		use of the cell.
//
//		The CIMTYPE.  This is the CIMOM cimtype value.  In
//		addition to the basic cimtypes, this value also contains
//		the CIM_FLAG_ARRAY bit. The CIMTYPE value and the
//		cimtype string member are not interchangeable because
//		the cimtype string does not contain any indication of
//		whether or not the value is an array.
//
//		The cimtype string.  This is the same as the cimtype
//		qualifier.  It contains no information about whether or
//		not the type is an array.  However it does contain information
//		about the referenced class if the type is an CIMOM object or a
//		CIMOM reference.
//
//********************************************************




CGcType::CGcType()
{
	m_iCellType = CELLTYPE_VOID;
	m_vt = VT_NULL;
	m_cimtype = CIM_STRING;
	m_sCimtype = "";
}



CGcType::CGcType(CellType iCellType, CIMTYPE cimtype)
{
	m_iCellType = iCellType;
	m_vt = VtFromCimtype(cimtype);
	m_cimtype = cimtype;
	SCODE sc = MapCimtypeToString(m_sCimtype, cimtype);
}


CGcType::CGcType(CellType iCellType, CIMTYPE cimtype, LPCTSTR pszCimtype)
{
	m_iCellType = iCellType;
	m_vt = VtFromCimtype(cimtype);
	m_cimtype = cimtype;
	m_sCimtype = pszCimtype;

}



void CGcType::SetCellType(CellType iCellType)
{

	m_iCellType = iCellType;
}


SCODE CGcType::SetCimtype(CIMTYPE cimtype, LPCTSTR pszCimtype)
{

	m_cimtype = cimtype;
	m_vt = VtFromCimtype(m_cimtype);
	if ((pszCimtype == NULL) || (*pszCimtype==0)) {
		SCODE sc = ::MapCimtypeToString(m_sCimtype, cimtype);
		ASSERT(SUCCEEDED(sc));
//		m_sCimtype.Empty();
	}
	else {
		m_sCimtype = pszCimtype;

		// Check to make sure that the cimtype string makes sense for the
		// specified cimtype.
		SCODE sc;
		CIMTYPE cimtypeCheck;
		sc = MapStringToCimtype(pszCimtype, cimtypeCheck);
		if (FAILED(sc)) {
			return sc;
		}

		if (cimtypeCheck != (cimtype  & ~CIM_FLAG_ARRAY)) {
			return E_FAIL;
		}
	}


	return S_OK;
}


SCODE CGcType::SetCimtype(CIMTYPE cimtype)
{

	SCODE sc;
	CString sCimtype;
	m_cimtype = cimtype;
	m_vt = VtFromCimtype(m_cimtype);
	sc = MapCimtypeToString(m_sCimtype, cimtype);
	return sc;
}



CGcType& CGcType::operator =(const CGcType& gctypeSrc)
{

	m_iCellType = gctypeSrc.m_iCellType;
	m_vt = gctypeSrc.m_vt;
	m_cimtype = gctypeSrc.m_cimtype;
	m_sCimtype = gctypeSrc.m_sCimtype;
	return *this;
}

BOOL CGcType::operator ==(const CGcType& type2) const
{

	if (m_iCellType != type2.m_iCellType) {
		return FALSE;
	}
	if (m_cimtype != type2.m_cimtype) {
		return FALSE;
	}
	if (m_sCimtype.CompareNoCase(type2.m_sCimtype) != 0) {
		return FALSE;
	}
	return TRUE;
}


BOOL CGcType::IsTime() const
{
	BOOL bIsVariant = (m_iCellType == CELLTYPE_VARIANT);
	BOOL bIsCimTime = (m_cimtype == CIM_DATETIME);
	BOOL bIsTime = bIsVariant & bIsCimTime;
	return bIsTime;
}


BOOL CGcType::IsCheckbox() const
{
	BOOL bIsCheckbox = (m_iCellType == CELLTYPE_CHECKBOX);
	return bIsCheckbox;
}



BOOL CGcType::IsObject() const
{
	if ((m_cimtype & CIM_TYPEMASK) == CIM_OBJECT) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


void CGcType::MakeArray(BOOL bIsArray)
{
	if (bIsArray) {
		m_cimtype |= CIM_FLAG_ARRAY;
	}
	else {
		m_cimtype &= ~CIM_FLAG_ARRAY;
	}
}


//***************************************************
// CGcType::DisplayTypeString
//
// Return display type that corresponds to this cimtype.
// The display type is the string that the user sees
// for a cell's type.
//
// Parameters:
//		[out] CString& sDisplayType
//			The display type value is returned here.
//
// Returns:
//		Nothing.
//
//**************************************************
void CGcType::DisplayTypeString(CString& sDisplayType) const
{
	::MapGcTypeToDisplayType(sDisplayType, *this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\grid.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  grid.cpp
//
//  This file contains the implementation for the HMOM object viewer grid.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************


#include "precomp.h"
#include "resource.h"
#include "grid.h"
#include "globals.h"
#include "notify.h"
#include "gca.h"
#include "gridhdr.h"
#include "celledit.h"
#include "core.h"
#include "utils.h"
#include "globals.h"
#include <afxctl.h>
#include <afxcmn.h>


#define CY_HEADER 16
#define CY_BORDER_MERGE 0

#define GS_TRUE _T("TRUE")
#define GS_FALSE _T("FALSE")
#define GS_EMPTY_STRING _T("<empty>")



/////////////////////////////////////////////////////////////////////////////
// CGridSync
//
// This class provides you with a simple way to syncronize the grid cell editor
// before making changes to the grid or accessing the values in the grid.
//
// To syncronize the grid with the grid cell editor, just declare an instance of
// the CGridSync class in the method that will be doing the editing.

CGridSync::CGridSync(CGrid* pGrid)
{
	m_pGrid = pGrid;
	m_sc = pGrid->BeginSerialize();
}

CGridSync::~CGridSync()
{
	m_pGrid->EndSerialize();
}


/////////////////////////////////////////////////////////////////////////////
// CGrid














/////////////////////////////////////////////////////////////////////////////
// CGrid
//
// This is grid class that most clients will want to use.  It contains
// both CGridHdr and a CGridCore client windows.
//
/////////////////////////////////////////////////////////////////////////////
CGrid::CGrid()
{
	m_bUIActive = FALSE;
	m_pcore = new CGridCore;
	m_phdr = new CHdrWnd(this);
	m_cxHeaderScrollOffset = 0;
	m_phdr->Header().m_pGrid = this;
	m_cxRowHandles = 0;
	m_pcore->SetParent(this);
	m_bmAscendingIndicator.LoadBitmap(IDB_ASCENDING_INDICATOR);
	m_bmDescendingIndicator.LoadBitmap(IDB_DESCENDING_INDICATOR);
	m_icolSortIndicator = NULL_INDEX;
}

CGrid::~CGrid()
{
	delete m_pcore;
	delete m_phdr;
}


BEGIN_MESSAGE_MAP(CGrid, CWnd)
	//{{AFX_MSG_MAP(CGrid)
	ON_WM_SHOWWINDOW()
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP

END_MESSAGE_MAP()









//*************************************************************
// CGrid::Create
//
// Create the CGrid window.
//
// Parameters:
//		CRect& rc
//			The rectangle in the parent's client area where this
//			CGrid window will be placed.
//
//		CWnd* pwndParent
//			A pointer to the parent window.
//
//		UINT nId
//			The window ID
//
//		BOOL bVisible
//			TRUE if the CGrid window should be initially visible, FALSE
//			otherwise.
//
// Returns:
//		BOOL
//			TRUE if the window was created successfully.
//
//***************************************************************
BOOL CGrid::Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible)
{

	DWORD dwStyle = WS_BORDER | WS_CHILD;
	if (bVisible) {
		dwStyle |= WS_VISIBLE;
	}


	// Create this window.  It will be the parent of the header control and
	// the CGridCore windows.
	BOOL bDidCreate = CWnd::Create(NULL, _T("CGridCore"), dwStyle, rc, pwndParent, nId);
	if (!bDidCreate) {
		return FALSE;
	}

	// Create the header control as a child window.
	CRect rcHeader;
	rcHeader.left = 0;
	rcHeader.top = 0;
	rcHeader.right = rc.right - rc.left;
	rcHeader.bottom = CY_HEADER;


	dwStyle = WS_CHILD | HDS_BUTTONS | HDS_HORZ;
	if (bVisible) {
		dwStyle |= WS_VISIBLE;
	}

	bDidCreate = m_phdr->Create(dwStyle, rcHeader, this, nId);
	if (!bDidCreate) {
		return FALSE;
	}

	InitializeHeader();

	// Create the CGridCore window as a child of this window.
	CRect rcGridCore = rcHeader;
	rcGridCore.top = rcHeader.bottom + CY_BORDER_MERGE;
	rcGridCore.bottom = rc.bottom;

	bDidCreate = m_pcore->Create(rcGridCore, nId, bVisible);
	if (!bDidCreate) {
		return FALSE;
	}

	SizeChildren();
	return bDidCreate;
}


CGridCore* CGrid::GridCore()
{
	return m_pcore;
}

void CGrid::UpdateScrollRanges()
{
	m_pcore->UpdateScrollRanges();
}



void CGrid::OnCellContentChange(int iRow, int iCol)
{
	// The default behavior for this virtual function is to do nothing.
}

void CGrid::OnCellClicked(int iRow, int iCol)
{
	// The default behavior for this virtual function is to do nothing.
}

void CGrid::OnCellClickedEpilog(int iRow, int iCol)
{
	// The default behavior for this virtual function is to do nothing.
}

BOOL CGrid::OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	return FALSE;
}

BOOL CGrid::OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	return FALSE;
}

BOOL CGrid::OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	return FALSE;
}


BOOL CGrid::OnBeginCellEditing(int iRow, int iCol)
{
	return TRUE;
}


BOOL CGrid::OnQueryRowExists(int iRow)
{
	return TRUE;
}


void CGrid::OnHeaderItemClick(int iItem)
{
}


BOOL CGrid::GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands)
{
	return FALSE;
}


void CGrid::ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu)
{
}

BOOL CGrid::OnCellEditContextMenu(CWnd* pwnd, CPoint ptContextMenu)
{
	return FALSE;
}


int CGrid::CompareRows(int iRow1, int iRow2, int iSortOrder)
{
	return 0;
}



void CGrid::BeginCellEditing()
{
	m_pcore->BeginCellEditing();
}


void CGrid::EndCellEditing()
{
	m_pcore->EndCellEditing();
}

BOOL CGrid::IsEditingCell()
{
	return m_pcore->IsEditingCell();
}



void CGrid::RefreshCellEditor()
{
	m_pcore->RefreshCellEditor();
}


SCODE CGrid::BeginSerialize()
{
	return m_pcore->SyncCellEditor();
}

void CGrid::EndSerialize()
{
}


SCODE CGrid::SyncCellEditor()
{
	return m_pcore->SyncCellEditor();
}

int  CGrid::RowHeight()
{
	return m_pcore->RowHeight();
}

void CGrid::SelectCell(int iRow, int iCol, BOOL bForceBeginEdit)
{
	m_pcore->SelectCell(iRow, iCol, bForceBeginEdit);
}

void CGrid::SelectRow(int iRow)
{
	m_pcore->SelectRow(iRow);
}




void CGrid::EnsureRowVisible(int iRow)
{
	m_pcore->EnsureRowVisible(iRow);
}

CGridCell& CGrid::GetAt(int iRow, int iCol)
{
	return m_pcore->GetAt(iRow, iCol);
}

int CGrid::GetRows()
{
	return m_pcore->GetRows();
}


int CGrid::GetCols()
{
	return m_pcore->GetCols();
}


int CGrid::GetSelectedRow()
{
	return m_pcore->GetSelectedRow();
}


void CGrid::GetSelectedCell(int& iRow, int& iCol)
{
	m_pcore->GetSelectedCell(iRow, iCol);
}


BOOL CGrid::EntireRowIsSelected()
{
	return m_pcore->EntireRowIsSelected();
}


void CGrid::InsertRowAt(int iRow)
{
	m_pcore->InsertRowAt(iRow);
}


int CGrid::AddRow()
{
	return m_pcore->AddRow();
}


void CGrid::DeleteRowAt(int iRow, BOOL bUpdateWindow)
{
	m_pcore->DeleteRowAt(iRow, bUpdateWindow);
}


//void CGrid::InsertColumnAt(int iCol, int iWidth, LPCTSTR pszTitle );
//	void Clear(BOOL bUpdateWindow=TRUE);

void CGrid::ClearRows(BOOL bUpdateWindow)
{
	m_pcore->ClearRows(bUpdateWindow);
}


BOOL CGrid::WasModified()
{
	return m_pcore->WasModified();
}

void CGrid::SetModified(BOOL bWasModified)
{
	m_pcore->SetModified(bWasModified);
}

int CGrid::ColWidth(int iCol)
{
	return m_pcore->ColWidth(iCol);
}

int CGrid::ColWidthFromHeader(int iCol)
{
	return m_phdr->Header().ColWidthFromHeader(iCol);
}

CString& CGrid::ColTitle(int iCol)
{
	return m_pcore->ColTitle(iCol);
}


void CGrid::SetCellModified(int iRow, int iCol, BOOL bWasModified)
{
	m_pcore->SetCellModified(iRow, iCol, bWasModified);
}


int CGrid::GetRowHandleWidth()
{
	return m_pcore->GetRowHandleWidth();
}


int CGrid::CompareCells(int iRow1, int iRow2, int iCol)
{
	return CompareCells(iRow1, iCol, iRow2, iCol);
}


void CGrid::NotifyCellModifyChange()
{
	m_pcore->NotifyCellModifyChange();
}





//*********************************************************
// CGrid::AddColumn
//
// Add a column to the grid header.
//
// Parameters:
//		int iWidth
//			The column width
//
//		LPCTSTR pszTitle
//			A pointer to the column title.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGrid::AddColumn(int iWidth, LPCTSTR pszTitle)
{
	InsertColumnAt(GetCols(), iWidth, pszTitle);

}



//********************************************************
// CGrid::Clear
//
// Delete all rows and columns from the grid.
//
// Parameters:
//		[in] BOOL bUpdateWindow
//			TRUE if the window should be updated after clearing the grid.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGrid::Clear(BOOL bUpdateWindow)
{
	m_pcore->Clear(bUpdateWindow);

	int nCols = m_phdr->Header().GetItemCount();
	while (--nCols >= 0) {
		m_phdr->Header().DeleteItem(nCols);
	}

	m_phdr->Header().SelectColumn(0);
	m_aSortAscending.RemoveAll();

	if (bUpdateWindow) {
		if (m_phdr->m_hWnd) {
			m_phdr->RedrawWindow();
		}
	}
}





//********************************************************
// CGrid::InsertColumnAt
//
// Insert a new column at the specified index.
//
// Parameters:
//		int iCol
//			The column index where the new column will be inserted.
//
//		int iWidth
//			The width of the column.
//
//		LPCTSTR pszTitle
//			Pointer to the column's title.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGrid::InsertColumnAt(int iCol, int iWidth, LPCTSTR pszTitle )
{
	ASSERT(m_aSortAscending.GetSize() == GetCols());
	m_aSortAscending.InsertAt(iCol, TRUE);
	m_pcore->InsertColumnAt(iCol, iWidth, pszTitle);
	ASSERT(m_aSortAscending.GetSize() == GetCols());

	// If the header doesn't exist or doesn't have a window
	// yet, then we must delay adding the title to the header
	// until it is initialized later.
	if (m_phdr->m_hWnd!=NULL) {
		HD_ITEM item;
		item.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH | HDI_LPARAM | HDI_BITMAP;
		item.hbm = NULL;
		item.fmt = HDF_LEFT;
		item.lParam = MAKELPARAM(TRUE,iWidth);

		item.cxy = iWidth;
		item.pszText = (LPTSTR) (void*) pszTitle;
		item.cchTextMax = _tcslen(pszTitle);
		m_phdr->Header().InsertItem(iCol, &item);
	}
}





//********************************************************
// CGrid::InitializeHeader
//
// Initialize the header control with the column titles.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CGrid::InitializeHeader()
{
	HD_ITEM item;
	item.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH | HDI_LPARAM  | HDI_BITMAP;
	item.hbm = NULL;
	item.fmt = HDF_LEFT;
	item.lParam = FALSE;

	m_phdr->Header().SetFont(&m_pcore->GetFont());
	int nCols = GetCols();
	for (int iCol = 0; iCol < nCols; ++iCol) {
		item.cxy = ColWidth(iCol);

		item.lParam = MAKELPARAM(TRUE,item.cxy);

		CString* psTitle = &ColTitle(iCol);

		item.pszText = (LPTSTR) (void*) (LPCTSTR) *psTitle;
		item.cchTextMax = psTitle->GetLength();
		m_phdr->Header().InsertItem(iCol, &item);
	}
}




//***********************************************************
// CGrid::SetHeaderSortIndicator
//
// Set the sort indicator on the column header to show whether
// the column is sorted in ascending or descending order.
//
// Parameters:
//		int iCol
//			The column index of the cell that was double clicked.
//
//		BOOL bAscending
//			TRUE if the ASCENDING sort indicator should be shown,
//			FALSE if the DESCENDING sort indicator should be shown.
//
//		BOOL bNone
//			TRUE if no sort indicator should be displayed for the
//			specified column.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::SetHeaderSortIndicator(int iCol, BOOL bAscending, BOOL bNone)
{

	HD_ITEM item;
	CHeaderCtrl* phdr = &m_phdr->Header();

	TCHAR szTitle[128];


	// Remove the sort indicator from the current sort indicator column
	// by deleting the header item and then inserting a header item with
	// just the text.  Don't do this if the column hasn't changed because
	// we will just delete it and insert it again anyway.
	static CString sTitle;
	if (m_icolSortIndicator!=NULL_INDEX) {
		if (iCol != m_icolSortIndicator) {

			item.mask = HDI_TEXT | HDI_WIDTH | HDI_LPARAM;
			szTitle[0] = 0;
			ASSERT(m_icolSortIndicator != -1);
			item.pszText = szTitle;
			// a-judypo fix
			item.cchTextMax = sizeof(szTitle) - 1;
			phdr->GetItem(m_icolSortIndicator, &item);

			item.mask = HDI_TEXT | HDI_FORMAT | HDI_WIDTH | HDI_LPARAM | HDI_BITMAP;
			item.pszText = szTitle;
			item.cchTextMax = sizeof(szTitle) - 1;
			item.cchTextMax = _tcslen(szTitle);
			item.fmt = HDF_LEFT;
			item.hbm = NULL;

			ASSERT(m_icolSortIndicator != -1);
			phdr->DeleteItem(m_icolSortIndicator);
			ASSERT(m_icolSortIndicator != -1);
			phdr->InsertItem(m_icolSortIndicator, &item);
		}
	}

	if (bNone) {
		return;
	}


	// At this point, the previous sort indicator has been
	// removed.  Now insert a new one.
	item.pszText = szTitle;
	item.cchTextMax = sizeof(szTitle) - 1;


	sTitle.Empty();
	item.mask = HDI_TEXT | HDI_WIDTH | HDI_FORMAT | HDI_LPARAM;
	item.fmt = HDF_LEFT;
	phdr->GetItem(iCol, &item);


	item.mask = HDI_TEXT | HDI_FORMAT | HDI_LPARAM;
	item.cchTextMax = _tcslen(szTitle);

	phdr->DeleteItem(iCol);
	CBitmap* pbm = NULL;

	if (!bNone) {
		item.mask = item.mask | HDI_BITMAP;
		item.fmt = item.fmt | HDF_BITMAP_ON_RIGHT;

		if (bAscending) {
			item.hbm = (HBITMAP) m_bmAscendingIndicator;
		}
		else {
			item.hbm = (HBITMAP) m_bmDescendingIndicator;
		}
	}

	int iColInsert = phdr->InsertItem(iCol, &item);
	m_icolSortIndicator = iCol;
	phdr->RedrawWindow();

}


//***********************************************************
// CGrid::OnCellDoubleClicked
//
// This is the default handler for double clicking a cell.  It
// does nothing, but derived classes can override this method
// to do something more interesting.
//
// Parameters:
//		int iRow
//			The row index of the cell that was double clicked.
//
//		int iCol
//			The column index of the cell that was double clicked.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::OnCellDoubleClicked(int iRow, int iCol)
{
}


//***********************************************************
// CGrid::OnRowHandleDoubleClicked
//
// This is the default handler for double clicking a row handle.  It
// does nothing, but derived classes can override this method
// to do something more interesting.
//
// Parameters:
//		int iRow
//			The row index of the cell that was double clicked.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::OnRowHandleDoubleClicked(int iRow)
{
}



//***********************************************************
// CGrid::OnRowhandleClicked
//
// This is the default handler for clicking a row handle.  It
// does nothing, but derived classes can override this method
// to do something more interesting.
//
// Parameters:
//		int iRow
//			The row index of the cell that was double clicked.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::OnRowHandleClicked(int iRow)
{
}



//***********************************************************
// CGrid::OnShowWindow
//
// Handle the ShowWindow command.  Since CGrid contains two sibling
// windows (CGridCore and CHeaderCtrl) it is necessary to pass
// the ShowWindow command on to both siblings.
//
// Parameters:
//		See the MFC documentation for CWnd::ShowWindow
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CWnd::OnShowWindow(bShow, nStatus);

	int nShowCmd = bShow ? SW_SHOW : SW_HIDE;

	if (m_pcore->m_hWnd) {
		m_pcore->ShowWindow(nShowCmd);
	}

	if (m_phdr->m_hWnd) {
		m_phdr->ShowWindow(nShowCmd);
	}
}



//***********************************************************
// CGrid::OnSize
//
// Handle the WM_SIZE command.  Since CGrid contains two sibling
// windows (CGridCore and CHeaderCtrl) it is necessary to pass
// the WM_SIZE command on to both siblings.
//
// Parameters:
//		See the MFC documentation for CWnd::OnSize
//
// Returns:
//		Nothing.
//
//************************************************************
void CGrid::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	SizeChildren();
}


//******************************************************************
// CGrid::GetColumnPos
//
// Get the position of the left edge of the specified column.
//
// Parameters:
//		int iCol
//			The index of the desired column.
//
// Returns:
//		The position of the left edge of the column.
//
//******************************************************************
int CGrid::GetColumnPos(int iCol)
{
	int ix = 0;
	for (int iLoop=0; iLoop < iCol; ++iLoop) {
		ix += ColWidth(iLoop);
	}
	return ix;
}




//*****************************************************************
// CGrid::SizeChildren
//
// Size the child windows of this grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CGrid::SizeChildren()
{
	CRect rcClient;
	GetClientRect(rcClient);

	int cx = rcClient.Width();
	int cy = rcClient.Height();


	// At this point in time, we haven't decided whether the row handles
	// should go in the CGrid or CGridCore, but regardless of where they
	// are drawn, we want to have the corner stub.
	int cxRowHandles = m_cxRowHandles;
	if (cxRowHandles == 0) {
		cxRowHandles = m_pcore->GetRowHandleWidth();
	}

	// Adjust the width of the header control, but not its height
	CRect rc(0, 0, cx, CY_HEADER);
	if (m_phdr->m_hWnd) {
		CRect rcHeader;
		rcHeader.left = cxRowHandles;
		rcHeader.right = rcClient.right;
		rcHeader.top = 0;
		rcHeader.bottom = CY_HEADER;

		m_phdr->MoveWindow(rcHeader);
		m_phdr->OnGridSizeChanged();
	}

	// Adjust the size of the CGridCore window to be the entire client
	// area minus the rectangle consumed by the header control.
	rc.top = rc.bottom - CY_BORDER_MERGE;
	rc.bottom = cy;
	rc.left = m_cxRowHandles;
	if (m_pcore->m_hWnd) {
		m_pcore->MoveWindow(rc);
	}
}

//*************************************************************
// CGrid::OnCellFocusChange
//
// This is a virtual method that may be overridden in derived
// classes to catch the "focus" change event.
//
// Parameters:
//		[in] int iRow
//			The row index of the affected cell.
//
//		[in] int iCol
//			The column index of the affected cell.
//
//		[in] int iNextRow
//			The next row that will be selected.  This parameter is provided
//			as a hint and is valid only if bGotFocus is FALSE.
//
//		[in] int iNextCol
//			The column index of the next cell that will get the focus when the
//			current cell is loosing focus.  This parameter is provided as a hint and
//			is valid only if bGotFocus is FALSE.
//
//		[in] BOOL bGotFocus
//			TRUE if focus is being changed to the specified cell.
//			FALSE if this is a request for the current cell to
//			release the focus.
//
// Returns:
//		If bGotFocus is TRUE, then return TRUE to allow the focus to
//		be set to the new cell or return FALSE to prevent the focus
//		from being set to the new cell.
//
//      If bGotFocus is FALSE, then this is a request to release the
//		focus from the specified cell.  Return TRUE to allow the specified
//		cell to loose the focus. Return FALSE to prevent the specified cell
//		from loosing the focus.
//
//*******************************************************************
BOOL CGrid::OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus)
{
	return TRUE;
}







void CGrid::SetHeaderScrollOffset(int iCol, int cxOffset)
{
	// Adjust the width of the header control, but not its height
	int dxScroll = cxOffset + m_cxHeaderScrollOffset;
	m_cxHeaderScrollOffset = cxOffset;
	if (m_phdr->m_hWnd) {
		m_phdr->SetScrollOffset(iCol, cxOffset);
		m_phdr->UpdateWindow();
	}
}



//******************************************************************
// CGrid::PointToCell
//
// Convert a point in CGrid's client coordinates to corresponding
// grid cell's coordinates.
//
// Parameters:
//		[in] CPoint pt
//			The point in CGrid's client coordinate space.
//
//		[out] int& iRow
//			The place where the cell's row index is returned.
//
//		[out] int& iCol
//			The place where the cell's column index is returned.
//
// Returns:
//		TRUE if the point hit a cell, otherwise FALSE.
//
//*******************************************************************
BOOL CGrid::PointToCell(CPoint pt, int& iRow, int& iCol)
{
	// GridCore's version of PointToCell works in its own client
	// coordinates, so we need to offset  the vertical coordinate
	// to account for the space consumed by CGrid's header control.
	pt.y = pt.y - ( CY_HEADER + CY_BORDER_MERGE );


	return m_pcore->PointToCell(pt, iRow, iCol);
}


//******************************************************************
// CGrid::PointToRow
//
// Convert a point in CGrid's client coordinates to corresponding
// row index.
//
// Parameters:
//		[in] CPoint pt
//			The point in CGrid's client coordinate space.
//
//		[out] int& iRow
//			The place where the row index is returned.
//
//
// Returns:
//		TRUE if the point hit a row, otherwise FALSE.
//
//*******************************************************************
BOOL CGrid::PointToRow(CPoint pt, int& iRow)
{
	// GridCore's version of PointToRow works in its own client
	// coordinates, so we need to offset  the vertical coordinate
	// to account for the space consumed by CGrid's header control.
	pt.y = pt.y - ( CY_HEADER + CY_BORDER_MERGE );


	return m_pcore->PointToRow(pt, iRow);
}



//******************************************************************
// CGrid::PointToRowHandle
//
// Convert a point in CGrid's client coordinates to corresponding
// row handle index.
//
// Parameters:
//		[in] CPoint pt
//			The point in CGrid's client coordinate space.
//
//		[out] int& iRow
//			The place where the row index is returned.
//
//
// Returns:
//		TRUE if the point hit a row handle, otherwise FALSE.
//
//*******************************************************************
BOOL CGrid::PointToRowHandle(CPoint pt, int& iRow)
{
	// GridCore's version of PointToHandle works in its own client
	// coordinates, so we need to offset  the vertical coordinate
	// to account for the space consumed by CGrid's header control.
	pt.y = pt.y - ( CY_HEADER + CY_BORDER_MERGE );


	return m_pcore->PointToRowHandle(pt, iRow);
}


//********************************************************************
// CGrid::DrawCornerStub
//
// Draw the "stub" in the top-left corner of the window when row handles
// are displayed.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGrid::DrawCornerStub(CDC* pdc)
{
	// Check to see if the grid has row handles.  If so, draw the little rectangle
	// at the top left corner that is bordered on the right by the grid header and
	// bordered on the bottom by the row handles.

	int cxRowHandles = m_cxRowHandles;
	if (cxRowHandles == 0) {
		cxRowHandles = m_pcore->GetRowHandleWidth();
	}
	if (cxRowHandles == 0) {
		return;
	}


	CRect rcFill;
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	// Draw a two-pixel 3D highlight along the top edge.
	rcFill.left = 0;
	rcFill.right = cxRowHandles - 1;
	rcFill.top = 0;
	rcFill.bottom = 2;
	pdc->FillRect(rcFill, &br3DHILIGHT);

	// Draw a two-pixel 3D highlight along the left edge.
	rcFill.left = 0;
	rcFill.right = 2;
	rcFill.top = 0;
	rcFill.bottom = CY_HEADER - 1;
	pdc->FillRect(rcFill, &br3DHILIGHT);


	// Fill the face of the button.
	rcFill.left = 2;
	rcFill.right = cxRowHandles - 2;
	rcFill.top = 2;
	rcFill.bottom = CY_FONT - 2;
	pdc->FillRect(rcFill, &br3DFACE);

	// Draw a one-pixel shadow on the bottom edge.
	rcFill.left = 2;
	rcFill.right = cxRowHandles - 1;
	rcFill.top = CY_FONT - 2;
	rcFill.bottom = CY_FONT - 1;
	pdc->FillRect(rcFill, &br3DSHADOW);

	rcFill.left = 1;
	rcFill.right = cxRowHandles - 1;
	rcFill.top = CY_FONT - 1;
	rcFill.bottom = CY_FONT;
	pdc->FillRect(rcFill, &br3DSHADOW);


	// Draw a one-pixel shadow on the right edge.
	rcFill.left = cxRowHandles - 3;
	rcFill.right = cxRowHandles - 2;
	rcFill.top = 2;
	rcFill.bottom = CY_FONT - 2;
	pdc->FillRect(rcFill, &br3DSHADOW);

	// Draw the second vertical part of the shadow on the right.
	rcFill.left = cxRowHandles - 2;
	rcFill.right = cxRowHandles - 1;
	rcFill.top = 1;
	rcFill.bottom = CY_FONT - 1;
	pdc->FillRect(rcFill, &br3DSHADOW);


	// Draw a one-pixel black border on the right edge.
	rcFill.left = cxRowHandles - 1;
	rcFill.right = cxRowHandles;
	rcFill.top = 0;
	rcFill.bottom = CY_FONT;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


	// Draw a one-pixel black border on the bottom edge.
	rcFill.left = 0;
	rcFill.right = cxRowHandles;
	rcFill.top = CY_FONT;
	rcFill.bottom = CY_FONT + 1;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));
}


//********************************************************************
// CGrid::DrawRowhandles
//
// Draw the row handles along the left side of the grid.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGrid::DrawRowHandles(CDC* pdc)
{
	// If there are no row handles, do nothing.
	int cxHandle = m_cxRowHandles;
	if (cxHandle <= 0) {
		return;
	}

	// If the row doesn't have a height, do nothing.
	int cyRow = m_pcore->RowHeight();
	if (cyRow <= 0) {
		return;
	}


	CRect rcClient;
	GetClientRect(rcClient);


	CRect rcClientChild;
	m_pcore->GetClientRect(rcClientChild);

	CRect rcRowHandles;
	GetClientRect(rcRowHandles);
	rcRowHandles.top += CY_HEADER;
	rcRowHandles.right = m_cxRowHandles;
	rcRowHandles.bottom = rcRowHandles.top + rcClientChild.Height();

	pdc->IntersectClipRect(rcRowHandles);

	// If the row handles are completely clipped out, then do nothing.
	CRect rcPaint;
	if (pdc->GetClipBox(rcPaint) != NULLREGION  ) {
		// The top and bottom of the paint rectangle need to be aligned with the top and
		// bottom edges of partially obscured row handles.
		rcPaint.top = ((rcPaint.top  - CY_HEADER) / cyRow) * cyRow + CY_HEADER;
		rcPaint.bottom = ((rcPaint.bottom - CY_HEADER) + (cyRow - 1))/cyRow * cyRow + CY_HEADER;
	}
	else {
		rcPaint = rcRowHandles;
	}

	// Draw the vertical line on the right that separates the row handles from
	// the data.
	CRect rcFill;
	rcFill.left = rcRowHandles.right - 1;
	rcFill.right = rcRowHandles.right;
	rcFill.top = rcRowHandles.top;
	rcFill.bottom = rcRowHandles.bottom;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


	// Define a rectangle for a handle that slides from the top to
	// the bottom of the stack of row handles as they are drawn.
	CRect rcHandle(rcRowHandles);
	rcHandle.top = rcRowHandles.top;
	rcHandle.bottom = rcHandle.top + cyRow;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	int nHandles = rcPaint.Height() / cyRow;

	while (--nHandles >= 0) {

		// The horizontal divider at the bottom of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.right;
		rcFill.top = rcHandle.bottom - 1;
		rcFill.bottom = rcHandle.bottom;
		pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


		// The horizontal highlight across the top of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.right - 1;
		rcFill.top = rcHandle.top;
		rcFill.bottom = rcHandle.top + 1;
		pdc->FillRect(rcFill, &br3DHILIGHT);

		// The vertical highlight on the left of the row handle.
		rcFill.left = rcHandle.left;
		rcFill.right = rcHandle.left + 1;
		rcFill.top = rcHandle.top + 1;
		rcFill.bottom = rcHandle.bottom - 1;
		pdc->FillRect(rcFill, &br3DHILIGHT);


		// The face of the row handle.
		rcFill.left = rcHandle.left + 1;
		rcFill.right = rcHandle.right - 1;
		rcFill.top = rcHandle.top + 1;
		rcFill.bottom = rcHandle.bottom - 1;
		pdc->FillRect(rcFill, &br3DFACE);

		// Increment to the next row.
		rcHandle.top += cyRow;
		rcHandle.bottom += cyRow;
	}


	// don't clip.
	pdc->SelectClipRgn(NULL, RGN_COPY);


	// If the CGridCore displays a horizontal scroll bar, then the
	// CGrid must fill in the "empty" area just to the left of the
	// horizontal scroll bar.
	//
	// The CGridCore displays the horizontal scroll bar, then the
	// height of m_GridCore will be less that the height of the
	// client area plus the header height.
	int cyHScrollBarChild = (rcClient.Height() - CY_HEADER) - rcClientChild.Height();
	if (cyHScrollBarChild <= 0) {
		return;
	}



//	CBrush brScrollBar(GetSysColor(COLOR_SCROLLBAR));
	CRect rcStub;


	rcStub.left = 0;
	rcStub.right = m_cxRowHandles;
	rcStub.bottom = rcClient.bottom;
	rcStub.top = rcClient.bottom - cyHScrollBarChild;
	pdc->FillRect(rcStub, &br3DFACE);

	rcFill.top = rcStub.top;
	rcFill.left = rcStub.left;
	rcFill.right = rcStub.right;
	rcFill.bottom = rcStub.top + 1;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));


	rcFill.top = rcStub.top;
	rcFill.bottom = rcStub.bottom;
	rcFill.left = rcStub.right - 1;
	rcFill.right = rcStub.right;
	pdc->FillRect(rcFill, CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));

	// The dark gray line on the left
	rcFill.top = rcStub.top + 3;
	rcFill.bottom = rcStub.bottom - 2;
	rcFill.left = rcStub.left + 2;
	rcFill.right = rcStub.left + 3;
	pdc->FillRect(rcFill, &br3DSHADOW);


	// The dark gray line on the top
	rcFill.top = rcStub.top + 3;
	rcFill.bottom = rcStub.top + 4;
	rcFill.left = rcStub.left + 1;
	rcFill.right = rcStub.right - 2;
	pdc->FillRect(rcFill, &br3DSHADOW);

	// The highlight on the bottom
	rcFill.top = rcStub.bottom - 3;
	rcFill.bottom = rcStub.bottom - 2;
	rcFill.left = rcStub.left + 2;
	rcFill.right = rcStub.right - 2;;
	pdc->FillRect(rcFill, &br3DHILIGHT);

	// The highlight on the right
	rcFill.top = rcStub.top + 2;
	rcFill.bottom = rcStub.bottom - 2;
	rcFill.left = rcStub.right - 4;
	rcFill.right = rcStub.right - 3;;
	pdc->FillRect(rcFill, &br3DHILIGHT);
}






//******************************************************************
// CGrid::ColumnIsAscending
//
// Return the sort order flag for the specified column.
//
// Parameters:
//		[in] const int iCol
//			The index of the desired column.
//
// Returns:
//		BOOL
//			TRUE if the specified column's sort order is ascending, FALSE
//			if it is descending.
//
//******************************************************************
//
BOOL CGrid::ColumnIsAscending(const int iCol) const
{
	ASSERT(iCol>= 0 && iCol < m_aSortAscending.GetSize());
	if (iCol <0 || iCol >= m_aSortAscending.GetSize()) {
		return TRUE;
	}

	return m_aSortAscending[iCol];
}



//****************************************************************
// CGrid::SetSortDirection
//
// Set the sort direction for the given column.  Note that this does
// not actually resort any of the grid rows. To resort the grid, you
// must call SortGrid.
//
// Parameters:
//		const int iCol
//			The column who's sort order flag will be changed.
//
//		const BOOL bSortAscending
//			TRUE to set the sort direction for the column to ascending,
//			FALSE to set the sort direction to descending.
//
// Returns:
//		Nothing.
//
//******************************************************************
void CGrid::SetSortDirection(const int iCol, const BOOL bSortAscending)
{
	ASSERT( iCol >=0 && iCol < m_aSortAscending.GetSize());
	if (iCol < 0 || iCol >= m_aSortAscending.GetSize()) {
		return;
	}

	m_aSortAscending[iCol] = (WORD) bSortAscending;
}



//*******************************************************************
// CGrid::ClearAllSortDirectionFlags
//
// Clears the sort direction flags for all of the columns.  The
// sort order for each column is set to ascending.  Note that this
// changes the state of the sort order flags, but does not resort the
// grid.  Call SortGrid to resort the grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CGrid::ClearAllSortDirectionFlags()
{
	INT_PTR nFlags = m_aSortAscending.GetSize();
	for (INT_PTR iFlag=0; iFlag<nFlags; ++iFlag) {
		m_aSortAscending[iFlag] = TRUE;
	}
}



//********************************************************************
// CGrid::SortGrid
//
// Sort the specified rows of the grid using the current sor order for the
// specified column.
//
// Parameters:
//		[in] int iRowFirst
//			The first row in the range of rows to sort.
//
//		[in] int iRowLast
//			The last row in the range of rows to sort.
//
//		[in] int iSortColumn
//			The index of the column to use as the primary sort key.
//
//		[in] BOOL bRedrawWindow=FALSE
//			TRUE to redraw the window.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CGrid::SortGrid(int iRowFirst, int iRowLast, int iSortColumn, BOOL bRedrawWindow)
{
	m_phdr->Header().SelectColumn(iSortColumn);
	BOOL bColumnIsAscending = ColumnIsAscending(iSortColumn);
	m_pcore->SortGrid(iRowFirst, iRowLast, iSortColumn, bColumnIsAscending, bRedrawWindow);
}


//*******************************************************************
// CGrid::CompareCells
//
// This method compares two cells in different rows but the same column.
//
// Parameters:
//		int iRow1
//			The row index of the first cell.
//
//		int iCol1
//			The column index of the first cell.
//
//		int iRow2
//			The row index of the second row.
//
//		int iCol2
//			The column index of the second cell.
//
// Returns:
//		>0 if row 1 is greater than row 2
//		0  if row 1 equal zero
//		<0 if row 1 is less than zero.
//
//********************************************************************
int CGrid::CompareCells(int iRow1, int iCol1, int iRow2,  int iCol2)
{
	CGridCell* pgc1 = &GetAt(iRow1, iCol1);
	CGridCell* pgc2 = &GetAt(iRow2, iCol2);

	int iResult = pgc1->Compare(pgc2);
	return iResult;

#if 0
	CString sValue1;
	CString sValue2;
	int iResult;

	VARTYPE vt1;
	VARTYPE vt2;
	GetAt(iRow1, iCol1).GetValue(sValue1, vt1);
	GetAt(iRow2, iCol2).GetValue(sValue2, vt2);
	iResult = sValue1.Compare(sValue2);
	if (iResult == 0) {
		iResult = vt1 > vt2;
	}
#endif //0

	return iResult;
}



void CGrid::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	DrawCornerStub(&dc);
	DrawRowHandles(&dc);

	// Do not call CWnd::OnPaint() for painting messages
}



//**********************************************************
// CGrid::RedrawRow
//
// Redraw the specified row of the grid.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGrid::RedrawRow(int iRow)
{
	ASSERT(iRow < GetRows());

	CGridRow& row = GetRowAt(iRow);
	row.Redraw();
}

//**********************************************************
// CGrid::RedrawCell
//
// Redraw the specified grid cell.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
//		[in] iCol
//			The column index.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGrid::RedrawCell(int iRow, int iCol)
{
	if (!::IsWindow(m_hWnd)) {
		return;
	}

	m_pcore->DrawCell(iRow, iCol);
}




void CGrid::SetColumnWidth(int iCol, int cx, BOOL bRedraw)
{
	m_phdr->Header().SetColumnWidth(iCol, cx, FALSE);
	m_pcore->SetColumnWidth(iCol, cx, FALSE);
	if (bRedraw && (m_hWnd!=NULL)) {
		RedrawWindow();
	}
}






//************************************************************************
// CGrid::PreTranslateMessage
//
// PreTranslateMessage is hooked out to detect the OnContextMenu event.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		TRUE if the message is handled here.
//
//*************************************************************************
BOOL CGrid::PreTranslateMessage(MSG* pMsg)
{
	// CG: This block was added by the Pop-up Menu component
	{
		// Shift+F10: show pop-up menu.
		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
		{
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			CPoint point = rect.TopLeft();
			point.Offset(5, 5);
			OnContextMenu(NULL, point);

			return TRUE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}



#if 0
//***************************************************************
// CGrid::FindCellPosition
//
// Given a cell pointer, find its row and column indexes.  This is
// required because the cell has no other way to directly determine
// its position.
//
// Parameters:
//		[in] CGridCell* pgc
//			Pointer to the grid cell to find.
//
//		[out] int& iRow
//			The row index of the cell if found, NULL_INDEX if the
//			cell is not found.
//
//		[out] int& iCol
//			The column index of the cell if found, NULL_INDEX if the cell
//			is not found.
//
// Returns:
//		The row and column indexes of the cell by reference.
//
//***************************************************************
void CGrid::FindCellPosition(CGridCell* pgc, int& iRow, int& iCol)
{
	pgc->FindCellPos(iRow, iCol);

}

#endif //0



BOOL CGrid::NumberRows(BOOL bNumberRows, BOOL bRedraw)
{
	BOOL bWasNumberingRows = m_pcore->NumberRows(bNumberRows, FALSE);
	if (bRedraw &&  m_hWnd!=NULL) {
		RedrawWindow();
	}
	return bWasNumberingRows;
}

BOOL CGrid::IsNumberingRows()
{
	return m_pcore->IsNumberingRows();
}




CFont& CGrid::GetGridFont()
{
	return m_pcore->GetFont();
}


void CGrid::NotifyRowHandleWidthChanged()
{
	SizeChildren();

}


void CGrid::OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	// Do nothing unless this virtual function is overridden.  If nothing is done
	// it just means that no one was listening to the event.
	return;
}



//*******************************************************
// CGrid::EditCellObject
//
// Edit a cell containing an embedded object.
//
// Parameters:
//		[in] CGridCell* pgc
//			The grid cell to edit.
//
//		[in] int iRow
//			The row index of the cell to edit.
//
//		[in] int iCol
//			The column index of the cell to edit.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGrid::EditCellObject(CGridCell* pgc, int iRow, int iCol)
{

}


//*******************************************************
// CGrid::EditCellObject
//
// Edit a cell containing an embedded object.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell to edit.
//
//		[in] int iCol
//			The column index of the cell to edit.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGrid::OnChangedCimtype(int iRow, int iCol)
{

}



//*******************************************************
// CGrid::OnRequestUIActive()
//
// Notify the derived class that there is a request to
// become UI active.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGrid::OnRequestUIActive()
{
}

void CGrid::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		OnRequestUIActive();
		if (m_pcore && ::IsWindow(m_pcore->m_hWnd)) {
			m_pcore->SetFocus();
		}
	}

}

void CGrid::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}


//**********************************************************
// CGrid::GetCellEnumStrings
//
// The cell editor calls this method to get any enumeration
// strings that should be displayed for the grid cell in a
// drop-down combo.
//
// Parameters:
//		[in] int iRow
//			The cell's row index.
//
//		[in] int iCol
//			The cell's column index.
//
//		[out] CStringArray& sa
//			The enumeration strings are returned in this string array.
//
// Returns;
//		Nothing.
//
//***********************************************************
void CGrid::GetCellEnumStrings(int iRow, int iCol, CStringArray& sa)
{
	sa.RemoveAll();
}


//**********************************************************
// CGrid::OnEnumSelection
//
// The cell editor calls this method when the user makes a
// selection from a drop-down combo.
//
// Parameters:
//		[in] int iRow
//			The cell's row index.
//
//		[in] int iCol
//			The cell's column index.
//
//
// Returns;
//		Nothing.
//
//***********************************************************
void CGrid::OnEnumSelection(int iRow, int iCol)
{
}




//**********************************************************
// CGrid::PreModalDialog
//
// The grid calls this method just prior to putting up a modal
// dialog.  OleControls can hook this virtual function out to
// call COleControl::PreModalDialog when necessary.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGrid::PreModalDialog()
{
}


//**********************************************************
// CGrid::PostModalDialog
//
// The grid calls this method just after putting up a modal
// dialog.  OleControls can hook this virtual function out to
// call COleControl::PostModalDialog when necessary.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CGrid::PostModalDialog()
{
}



//**********************************************************
// CGrid::GetRowAt
//
// The cell editor calls this method when the user makes a
// selection from a drop-down combo.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
// Returns;
//		CGridRow&
//			A reference to the specified grid row.
//
//***********************************************************
CGridRow& CGrid::GetRowAt(int iRow)
{
	return m_pcore->GetRowAt(iRow);
}






//**********************************************************
// CGrid::SetRowModified
//
// This method marks a row as modified or unmodified depending
// on the bModified parameter.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
//		[in] BOOL bModified
//			TRUE if the row should be marked as "modified".
//
// Returns;
//		Nothing.
//
//***********************************************************
void CGrid::SetRowModified(int iRow, BOOL bModified)
{
	CGridRow& row = GetRowAt(iRow);
	row.SetModified(bModified);

}





//**********************************************************
// CGrid::GetRowModified
//
// This method gets the "modified" state of a given row.
//
// Parameters:
//		[in] int iRow
//			The row index.
//
// Returns;
//		BOOL
//			TRUE if the row was modified.
//
//***********************************************************
BOOL CGrid::GetRowModified(int iRow)
{
	CGridRow& row = GetRowAt(iRow);
	BOOL bModified = row.GetModified();
	return bModified;
}



//**********************************************************
// CGrid::GetWbemServices
//
// Get the WBEM services pointer for a given namespace.
//
// This method is called when editing an embedded object and
// the embedded object contains a property with an embedded
// object.  The SingleView control that lives on the object
// editor dialog will fire a GetWbemServices event which is
// propagated up through the control hierarchy.
//
// Parameters:
//		[in] LPCTSTR szNamespace
//			The namespace.
//
//		[out] VARIANT FAR* pvarUpdatePointer
//
//		[out] VARIANT FAR* pvarServices
//
//		[out] VARIANT FAR* pvarSc
//			The status code is returned here.
//
//		[out] VARIANT FAR* pvarUserCancel
//			A boolean flag indicating whether or not the
//			user cancelled the login.
//
//
// Returns;
//		BOOL
//			TRUE if the row was modified.
//
//***********************************************************
void CGrid::GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{


}


void CGrid::SetColTagValue(int iCol, DWORD dwTagValue)
{
	m_pcore->SetColTagValue(iCol, dwTagValue);
}

DWORD CGrid::GetColTagValue(int iCol)
{
	return m_pcore->GetColTagValue(iCol);
}
void CGrid::SetRowTagValue(int iRow, DWORD dwTagValue)
{
	m_pcore->SetRowTagValue(iRow, dwTagValue);
}

DWORD CGrid::GetRowTagValue(int iRow)
{
	return m_pcore->GetRowTagValue(iRow);
}

void CGrid::SetColVisibility(int iCol, BOOL bVisible)
{
	m_phdr->Header().SetColVisibility(iCol, bVisible);
}

void CGrid::SetNullCellDrawMode(BOOL bShowEmptyText)
{
	m_pcore->SetNullCellDrawMode(bShowEmptyText);
}

BOOL CGrid::ShowNullAsEmpty()
{
	return m_pcore->ShowNullAsEmpty();
}



int CGrid::GetMaxValueWidth(int iCol)
{
	return m_pcore->GetMaxValueWidth(iCol);
}

void CGrid::SwapRows(int iRow1, int iRow2, BOOL bRedraw)
{
	m_pcore->SwapRows(iRow1, iRow2);
	if (bRedraw) {
		RedrawRow(iRow1);
		RedrawRow(iRow2);
		UpdateWindow();
	}
}



void CGrid::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	int iSelectedRow;

	CWnd::OnChar(nChar, nRepCnt, nFlags);
	switch (nChar) {
	case VK_TAB:
		iSelectedRow = GetSelectedRow();
		if (GetKeyState(VK_SHIFT) < 0) {
			// Tab forward should move to the next row.
			if (iSelectedRow == NULL_INDEX) {
				SelectRow(0);
			}
			else if (iSelectedRow < (GetRows() - 1)) {
				SelectRow(iSelectedRow + 1);
			}
		}
		else {
			// Shift tab moves the row up one.
			if (iSelectedRow == NULL_INDEX) {
				SelectRow(0);
			}
			else if (iSelectedRow > 0) {
				SelectRow(iSelectedRow - 1);
			}
		}
		return;
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gridhdr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "resource.h"
#include "globals.h"

#include "gridhdr.h"
#include "grid.h"
#include "utils.h"



#define MAX_TITLE 1024		// The maximum property name is limited to 1024 bytes.


/////////////////////////////////////////////////////////////////////////////
// CHdrWnd
//
// The only purpose of this class is to contain a CGridHeader window so that
// the CGridHeader can easily be scrolled left in right in a manner such
// that the portions of the CGridHeader that would otherwise extend to the
// left of the CHdrWnd's client rectangle are clipped.
//
// !!!CR: Is there a better way to do this?  It seems like a waste of a
// !!!CR: window.  If there were some way to set the window origin withou
// !!!CR: having to reference the paint time DC, then this class would not
// !!!CR: be necessary.
//
/////////////////////////////////////////////////////////////////////////////


CHdrWnd::CHdrWnd(CGrid* pGrid)
{
	m_pGrid = pGrid;
	m_ixScrollOffset = 0;
	m_iColScrollOffset = 0;
	m_bUIActive = FALSE;
}

CHdrWnd::~CHdrWnd()
{
}


BEGIN_MESSAGE_MAP(CHdrWnd, CWnd)
	//{{AFX_MSG_MAP(CHdrWnd)
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHdrWnd message handlers

//*************************************************************************
// CHdrWnd::OnSize
//
// Catch the WM_ONSIZE message.  This is necessary for resizing the CGridHeader
// control that is contained within this window.  The CGridHeader is sized
// so that its right edge is flush against the right edge of the client rectangle
// of this window.  The left edge of the CGridHeader may extend to the left
// of the client edge of this window and is thus clipped.  This gives the
// appearance of scrolling the grid header without the necessity of changing the
// implementation of the header control.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//**************************************************************************
void CHdrWnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	if (m_hdr.m_hWnd) {
		CRect rc;
		GetClientRect(rc);
		rc.left = -m_ixScrollOffset;
		m_hdr.MoveWindow(rc);
		m_hdr.FixColWidths();
	}
}


void CHdrWnd::OnGridSizeChanged()
{
	m_hdr.FixColWidths();

}



//***********************************************************************
// CHdrWnd::Create
//
// Create the header window.  Essentially, this just creates a minimal
// window with the CGridHeader window inside of it.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//***********************************************************************
BOOL CHdrWnd::Create(DWORD dwChildStyle, CRect& rc, CWnd* pwndParent, UINT nId)
{

	DWORD dwStyle = WS_CHILD;
	if (dwChildStyle & WS_VISIBLE) {
		dwStyle |= WS_VISIBLE;
	}

	BOOL bDidCreateWnd = CWnd::Create(NULL, _T("CHdrWnd"), dwStyle, rc, pwndParent, nId);
	if (!bDidCreateWnd) {
		return FALSE;
	}

	bDidCreateWnd = m_hdr.Create(dwChildStyle | WS_VISIBLE, rc, this, GenerateWindowID());
	return bDidCreateWnd;
}

//***********************************************************************
// CHdrWnd::SetScrollOffset
//
// Move the CGridHeader within this window so that its right edge is flush
// against the right edge of this window's client rectangle and the left
// edge of the CGridHeader is offset by the specified amount from the left
// edge of the client rectangle of this window.
//
// Parameters:
//		[in] int iCol
//
//		[in] int ixScrollOffset
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CHdrWnd::SetScrollOffset(int iCol, int ixScrollOffset)
{
	m_iColScrollOffset = iCol;
	m_hdr.m_iColScrollOffset = iCol;
	m_ixScrollOffset = ixScrollOffset;


	CRect rc;
	GetClientRect(rc);
	rc.left = -ixScrollOffset;
	m_hdr.MoveWindow(rc);

	if (iCol != NULL_INDEX) {
		int cxColHdr = m_hdr.ColWidthFromHeader(iCol);
		int cxColGrid = m_pGrid->ColWidth(iCol);
		m_hdr.FixColWidths();
	}
}




/////////////////////////////////////////////////////////////////////////////
// CGrid message handlers
/////////////////////////////////////////////////////////////////////////////
// CGridHdr

CGridHdr::CGridHdr()
{
	m_pGrid = NULL;
	m_bIsSettingColumnWidth = FALSE;
	m_iSelectedColumn = 0;
	m_iColScrollOffset = 0;
}

CGridHdr::~CGridHdr()
{
}


BEGIN_MESSAGE_MAP(CGridHdr, CHeaderCtrl)
	//{{AFX_MSG_MAP(CGridHdr)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP

	ON_NOTIFY_REFLECT(HDN_ITEMCHANGED, OnItemChanged)
	ON_NOTIFY_REFLECT(HDN_ITEMCHANGING, OnItemChanging)
	ON_NOTIFY_REFLECT(HDN_ITEMCLICK, OnItemClick)
	ON_NOTIFY_REFLECT(HDN_DIVIDERDBLCLICK, OnDividerDblClick)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGridHdr message handlers
//***********************************************************
// CGridHdr::OnItemChanged
//
// Catch a change to a header control item so that we can resize
// the grid when the header divider lines are moved.
//
// Parameters:
//		See the MFC documentation for header control notification
//		messages.
//
// Returns:
//		Nothing.
//
//************************************************************

void CGridHdr::OnItemChanged(NMHDR *pNMHDR, LRESULT* pResult)
{
	if (m_bIsSettingColumnWidth) {
		return;
	}

	if (m_pGrid) {
		HD_NOTIFY FAR* pHdNotify = (HD_NOTIFY FAR *) (void*) pNMHDR;


		HD_ITEM hdItem;
		int iItem = pHdNotify->iItem;

		// Get the width of the header control item and set width
		// of the corresponding column in the grid to match the
		// width of the header control item.
		hdItem.mask = HDI_WIDTH;
		BOOL bGotItem = GetItem(iItem, &hdItem );
		if (bGotItem) {
			// The grid does horizontal scrolling by entire columns.  This
			// means that if a column is greater than the width of the header's
			// client rectangle, then the user can never see the right side of
			// the column.  This also prevents the user from ever shrinking the
			// column width if it is greater than the client width.
			CRect rcGridClient;
			m_pGrid->GetClientRect(rcGridClient);
			int cxMax = rcGridClient.Width() - m_pGrid->GetRowHandleWidth();

			if (hdItem.cxy > cxMax) {
				hdItem.mask = HDI_WIDTH;
				hdItem.cxy = cxMax;

				m_bIsSettingColumnWidth = TRUE;
				BOOL bDidSetItem = SetItem(iItem, &hdItem);
				m_bIsSettingColumnWidth = FALSE;
			}

			m_pGrid->SetColumnWidth(iItem, hdItem.cxy, TRUE);
			FixColWidths();
		}
	}
}

void CGridHdr::OnItemChanging(NMHDR *pNMHDR, LRESULT* pResult)
{
	*pResult =  FALSE;

	if (m_hWnd == NULL) {
		return;
	}

	if (m_pGrid) {
		HD_NOTIFY FAR* pHdNotify = (HD_NOTIFY FAR *) (void*) pNMHDR;
		int iItem = pHdNotify->iItem;
		HD_ITEM item;
		item.mask = HDI_LPARAM ;
		GetItem(iItem, &item);
		if (LOWORD(item.lParam) == FALSE){
			*pResult =  TRUE;
		}
	}

}

void CGridHdr::SetColumnWidth(int iCol, int cx, BOOL bRedraw)
{
	if (m_hWnd == NULL) {
		return;
	}




	// Get visibility
	HD_ITEM item;
	item.mask = HDI_LPARAM ;
	GetItem(iCol, &item);
	int nVisible = LOWORD(item.lParam);

	HD_ITEM hdItem;

	// Get the width of the header control item and set width
	// of the corresponding column in the grid to match the
	// width of the header control item.
	hdItem.mask = HDI_WIDTH | HDI_LPARAM;
	hdItem.cxy = cx;
	hdItem.lParam = MAKELPARAM(nVisible,cx);

	m_bIsSettingColumnWidth = TRUE;
	SetItem(iCol, &hdItem );
	m_bIsSettingColumnWidth = FALSE;

	if (bRedraw) {
		RedrawWindow();
	}
}

int CGridHdr::ColWidthFromHeader(int iCol)
{
	HD_ITEM item;
	item.mask = HDI_LPARAM ;
	GetItem(iCol, &item);
	return HIWORD(item.lParam);
}

//***********************************************************
// CGridHdr::OnItemClick
//
// Catch a "item clicked" notification message from the header
// control.
//
// Parameters:
//		See the MFC documentation for header control notification
//		messages.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridHdr::OnItemClick(NMHDR *pNMHDR, LRESULT* pResult)
{
	if (m_pGrid) {
		HD_NOTIFY FAR* pHdNotify = (HD_NOTIFY FAR *) (void*) pNMHDR;
		if (pHdNotify->iItem == m_iSelectedColumn) {
			// Flip the sort order if currently selected column header was clicked.
			BOOL bAscending = m_pGrid->ColumnIsAscending(m_iSelectedColumn);
			m_pGrid->SetSortDirection(m_iSelectedColumn, !bAscending);
		}
		m_pGrid->OnHeaderItemClick(pHdNotify->iItem);
	}
}



//***********************************************************
// CGridHdr::OnDividerDblClick
//
// Catch a divider double-clicked notification message from the header
// control.
//
// Parameters:
//		See the MFC documentation for header control notification
//		messages.
//
// Returns:
//		Nothing.
//
//************************************************************
void CGridHdr::OnDividerDblClick(NMHDR *pNMHDR, LRESULT* pResult)
{
	if (m_pGrid) {
		HD_NOTIFY FAR* pHdNotify = (HD_NOTIFY FAR *) (void*) pNMHDR;

		int iCol = pHdNotify->iItem;
		int cxMax = m_pGrid->GetMaxValueWidth(iCol);

		// Limit the width of the header to one pixel less than the width of the grid
		// so that the header divider line will always be visible.
		//
		// This may result in the width of the column in the grid being wider than
		// the width of the header item for the corresponding column.  This
		// discrepency is corrected if the window is resized so that it grows.
		CRect rcClientGrid;
		m_pGrid->GetClientRect(rcClientGrid);
		int cxGrid = rcClientGrid.Width();
		int cxColHdr = cxMax;
		if (cxColHdr> cxGrid - 1) {
			cxColHdr = cxGrid - 1;
		}


#if 0

		HD_ITEM hdItem;

		hdItem.mask = HDI_WIDTH;
		hdItem.cxy = cxColHdr;
		m_bIsSettingColumnWidth = TRUE;
		SetItem(iCol, &hdItem );
#endif //0



		m_bIsSettingColumnWidth = FALSE;
		m_pGrid->SetColumnWidth(iCol, cxMax, TRUE);
		FixColWidths();

//		RedrawWindow();

	}
}


void CGridHdr::OnSetFocus(CWnd* pOldWnd)
{
	CHeaderCtrl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		m_pGrid->OnRequestUIActive();
	}

}

void CGridHdr::OnKillFocus(CWnd* pNewWnd)
{
	CHeaderCtrl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;
}

void CHdrWnd::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		m_pGrid->OnRequestUIActive();
	}

}

void CHdrWnd::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;
}

void CGridHdr::SetColVisibility(int iCol, BOOL bVisible)
{
	if (m_hWnd == NULL) {
		return;
	}

	if (GetItemCount() <= iCol){
		return;
	}

	TCHAR szTitle[MAX_TITLE];
	HD_ITEM item;
	item.mask = HDI_LPARAM  | HDI_BITMAP | HDI_FORMAT   | HDI_TEXT   | HDI_WIDTH;
	item.pszText = szTitle;
	item.cchTextMax = sizeof(szTitle) - 1;
	GetItem(iCol, &item);


	item.hbm = NULL;
	LPARAM lParam = MAKELPARAM(bVisible,HIWORD(item.lParam));
	item.lParam = lParam;

	if (!bVisible){
		m_pGrid->SetColumnWidth(iCol, 0, FALSE);
		item.cxy = 0;
		DeleteItem(iCol);
		InsertItem(iCol, &item);

	}
	else {
		int nWidth = HIWORD(item.lParam);
		m_pGrid->SetColumnWidth(iCol, nWidth , FALSE);
		item.cxy = nWidth;
		DeleteItem(iCol);
		InsertItem(iCol, &item);


	}
}


//********************************************************
// CGridHdr::FindLastVisibleCol
//
// Find the column index of the last column that is at
// least partially visible.
//
// Parameters:
//		None.
//
// Returns:
//		The column index of the last visible column.
//
//********************************************************
int CGridHdr::FindLastVisibleCol()
{
	int nCols = m_pGrid->GetCols();
	CRect rcGrid;
	m_pGrid->GetClientRect(rcGrid);
	int cxGrid = rcGrid.Width();
	int cxMaxHdr = cxGrid - m_pGrid->GetRowHandleWidth();

	for (int iCol = m_iColScrollOffset; iCol < nCols; ++iCol) {
		int cxColGrid = m_pGrid->ColWidth(iCol);
		cxMaxHdr -= cxColGrid;
		if (cxMaxHdr <= 0) {
			return iCol;
		}
	}
	if (nCols > 0) {
		return nCols - 1;
	}
	else {
		return 0;
	}
}




//********************************************************
// CGridHdr::FixColWidths
//
// Fix the column widths of the header items to keep them
// in sync with the column widths in the grid.  This is
// necessary because the column width of a header item
// may be less than the column width of the corresponding
// item so that the user can grab the divider line on
// the last visible column and resize the column.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
void CGridHdr::FixColWidths()
{
	CRect rcGrid;
	m_pGrid->GetClientRect(rcGrid);
	int cxGrid = rcGrid.Width();
	int cxMaxHdr = cxGrid - m_pGrid->GetRowHandleWidth();
	int iLastVisibleCol = FindLastVisibleCol();


	BOOL bChangedColWidth = FALSE;
	int nCols = m_pGrid->GetCols();
	for (int iCol = 0; iCol < nCols; ++iCol) {
		int cxColGrid = m_pGrid->ColWidth(iCol);
		int cx = cxColGrid;
		if (iCol == iLastVisibleCol) {
			if (cx > cxMaxHdr) {
				cx = cxMaxHdr;
			}
		}

		int cxColHdr = ColWidthFromHeader(iCol);
		if (cx != cxColHdr) {
			SetColumnWidth(iCol, cx, FALSE);
			bChangedColWidth = TRUE;
		}
	}
	if (bChangedColWidth) {
		RedrawWindow();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\grid.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  grid.h
//
//  This file contains the class definitions for the HMOM object viewer grid. 
//	For more information, please see grid.cpp.
//
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************


#ifndef _grid_h
#define _grid_h

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include <afxdisp.h>
#include "gc.h"

#ifndef _WBEMSVC_H
#define _WBEMSVC_H
#include "wbemidl.h"
#endif

#define NULL_INDEX -1




//class CHeaderCtrl;
class CGridCore;
class CHdrWnd;
class CGridCell;
class CGridRow;

enum {EDITMODE_BROWSER=0, EDITMODE_STUDIO=1, EDITMODE_READONLY=2};

/////////////////////////////////////////////////////////////////////////////
// CGrid window
// 
// The grid window consists of two child windows -- a header control and
// a GridCore window.
//
////////////////////////////////////////////////////////////////////////////

// The linkage must be declared differently when the grid is built from
// when it is used so that the export/import is done correctly.
#ifdef BUILD_HMMVGRID
#define FUNKY_LINKAGE __declspec(dllexport)
#else
#define FUNKY_LINKAGE __declspec(dllimport)
#endif 

class FUNKY_LINKAGE  CGrid : public CWnd
//class AFX_EXT_CLASS  CGrid : public CWnd
{
// Construction
public:
	CGrid();

// Attributes
public:

// Operations
public:
	CGridCore* GridCore();
	BOOL Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Notification methods that can be hooked out.
	void UpdateScrollRanges();
	virtual IWbemServices* GetWbemServicesForObject(int iRow, int iCol) {return NULL; }
	virtual void GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);

	virtual void EditCellObject(CGridCell* pgc, int iRow, int iCol);
	virtual void OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	virtual BOOL OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus);
	virtual void OnCellContentChange(int iRow, int iCol);
	virtual void OnCellClicked(int iRow, int iCol);
	virtual void OnSetToNoSelection() {}
	virtual void OnCellClickedEpilog(int iRow, int iCol);
	virtual void OnRowHandleClicked(int iRow);
	virtual void OnCellDoubleClicked(int iRow, int iCol);
	virtual BOOL OnCellKeyDown(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual BOOL OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnRowHandleDoubleClicked(int iRow);
	virtual BOOL OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual BOOL OnBeginCellEditing(int iRow, int iCol);
	virtual BOOL OnQueryRowExists(int iRow);
	virtual void OnHeaderItemClick(int iItem);
	virtual void OnChangedCimtype(int iRow, int iCol);
//	virtual CDistributeEvent* GetNotify() {return NULL; }
	virtual void OnRequestUIActive();
	virtual void GetCellEnumStrings(int iRow, int iCol, CStringArray& sa);
	virtual void OnEnumSelection(int iRow, int iCol);
	virtual SCODE GetObjectClass(CString& sClass, int iRow, int iCol) {sClass.Empty(); return E_FAIL; }
	virtual SCODE GetArrayName(CString& sName, int iRow, int iCol){ sName.Empty(); return E_FAIL; }

	// Methods for overriding the cell editor's context menu.
	virtual BOOL OnCellEditContextMenu(CWnd* pwnd, CPoint ptContextMenu);
	virtual BOOL GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands);
	virtual void ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu);


	virtual void PreModalDialog();
	virtual void PostModalDialog();



	// Sorting methods that can be hooked out.
	virtual int CompareRows(int iRow1, int iRow2, int iSortOrder);
	virtual int CompareCells(int iRowCell1, int iColCell1, int iRowCell2, int iColCell2);

	void SetHeaderSortIndicator(int iCol, BOOL bAscending, BOOL bNone=FALSE);

	BOOL NumberRows(BOOL bNumberRows, BOOL bRedraw=TRUE);
	void SwapRows(int iRow1, int iRow2, BOOL bRedraw=TRUE);
	BOOL IsNumberingRows();

	BOOL PointToCell(CPoint point, int& iRow, int& iCol);
	BOOL PointToRow(CPoint pt, int& iRow);
	BOOL PointToRowHandle(CPoint pt, int& iRow);

	void BeginCellEditing();
	void EndCellEditing();
	BOOL IsEditingCell();

	void AddColumn(int iWidth, LPCTSTR pszTitle);

	void RefreshCellEditor();
	SCODE BeginSerialize();
	void EndSerialize();
	SCODE SyncCellEditor();
	int  RowHeight();
	void SelectCell(int iRow, int iCol, BOOL bForceBeginEdit=FALSE);
	void SelectRow(int iRow);
	CFont& GetGridFont();
	void EnsureRowVisible(int iRow);
	CGridCell& GetAt(int iRow, int iCol);
	int GetRows();
	int GetCols();
	int GetSelectedRow();
	void GetSelectedCell(int& iRow, int& iCol);
	BOOL EntireRowIsSelected();
	void InsertRowAt(int iRow);
	int AddRow();
	void DeleteRowAt(int iRow, BOOL bUpdateWindow = TRUE);
	void InsertColumnAt(int iCol, int iWidth, LPCTSTR pszTitle );
	void Clear(BOOL bUpdateWindow=TRUE);
	void ClearRows(BOOL bUpdateWindow=TRUE);
	BOOL WasModified();
	void SetModified(BOOL bWasModified);
	int ColWidth(int iCol);
	int ColWidthFromHeader(int iCol);
	int GetMaxValueWidth(int iCol);
	CString& ColTitle(int iCol);
	void SetCellModified(int iRow, int iCol, BOOL bWasModified);
	void SetColumnWidth(int iCol, int cx, BOOL bRedraw); 
	void SetColVisibility(int iCol, BOOL bVisible);
	void SetHeaderScrollOffset(int iCol, int cxOffset);
	int GetColumnPos(int iCol);
	void DrawCornerStub(CDC* pdc);
	void DrawRowHandles(CDC* pdc);
	int GetRowHandleWidth();
	void RedrawCell(int iRow, int iCol);
	void RedrawRow(int iRow);
	void NotifyRowHandleWidthChanged();

	// Methods for manipulating the row and column tag values.  The tags
	// are DWORDS that are available for use any way you see fit.
	void SetColTagValue(int iCol, DWORD dwTagValue);
	DWORD GetColTagValue(int iCol);
	void SetRowTagValue(int iRow, DWORD dwTagValue);
	DWORD GetRowTagValue(int iRow);

	// Grid sorting methods.
	//     The grid provides the storage for the sort direction, but the
	//     derived classes are responsible for manip
	//     Also see CompareRows and OnHeaderItemClicked above.
	BOOL ColumnIsAscending(const int iCol) const;
	void SetSortDirection(const int iCol, const BOOL bSortAscending);
	void ClearAllSortDirectionFlags();  // Resets all sort flags to ascending.
	void SortGrid(int iRowFirst, int iRowLast, int iSortColumn, BOOL bRedrawWindow=FALSE);
	int CompareCells(int iRow1, int iRow2, int iCol);
	void NotifyCellModifyChange();
//	void FindCellPosition(CGridCell* pgc, int& iRow, int& iCol);
	CGridRow& GetRowAt(int iRow);


	void SetRowModified(int iRow, BOOL bModified = TRUE);
	BOOL GetRowModified(int iRow);

	void SetNullCellDrawMode(BOOL bShowEmptyText=TRUE);
	BOOL ShowNullAsEmpty();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGrid)
	//}}AFX_VIRTUAL


// Implementation
public:
	virtual ~CGrid();

protected:
	// Generated message map functions
	//{{AFX_MSG(CGrid)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	void InitializeHeader();
	void SizeChildren();
	CGridCore* m_pcore;
	CHdrWnd* m_phdr;
	int m_cxHeaderScrollOffset;
	int m_cxRowHandles;
	CWordArray m_aSortAscending;
	BOOL m_bUIActive;
	CBitmap m_bmAscendingIndicator;
	CBitmap m_bmDescendingIndicator;
	int m_icolSortIndicator;
};





/////////////////////////////////////////////////////////////////////////////









class __declspec(dllexport) CGridSync
{
public:
	CGridSync(CGrid* pGrid);
	~CGridSync();
	SCODE m_sc;
private:
	CGrid* m_pGrid;
};



extern void __declspec(dllexport) InitializeHmmvGrid();




#endif _grid_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gctype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _gctype_h
#define _gctype_h

enum CellType;

class __declspec(dllexport) CGcType
{
public:
	CGcType();
	CGcType(CellType iCellType, CIMTYPE cimtype);
	CGcType(CellType iCellType, CIMTYPE cimtype, LPCTSTR pszCimtype);

	// Methods to set the celltype and cimtype components of the type
	void SetCellType(CellType iCellType);
	SCODE SetCimtype(CIMTYPE cimtype);
	SCODE SetCimtype(CIMTYPE cimtype, LPCTSTR pszCimtype);

	operator CellType() const {return m_iCellType; }
	operator CIMTYPE() const {return m_cimtype; }
	operator VARTYPE() const {return m_vt; }

	LPCTSTR CimtypeString() const {return m_sCimtype; }
	CIMTYPE Cimtype() const {return m_cimtype; }
	VARTYPE Vartype() const {return m_vt; }
	CellType GetCellType() const {return m_iCellType; }
	void DisplayTypeString(CString& sDisplayType) const;


	CGcType& operator =(const CGcType& gctypeSrc);
	BOOL operator==(const CGcType& type2) const;
	BOOL operator!=(const CGcType& type2) const {return !(*this == type2);  }

	// Helper functions
	BOOL IsTime() const;
	BOOL IsCheckbox() const;
	BOOL IsObject() const;
	BOOL IsArray() const {return m_cimtype & CIM_FLAG_ARRAY; } 
	void MakeArray(BOOL bIsArray = TRUE);


private:

	CellType m_iCellType;
	VARTYPE m_vt;
	CIMTYPE m_cimtype;
	CString m_sCimtype;
};

#endif //_gctype_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\gridhdr.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _gridhdr_h
#define _gridhdr_h



class CGrid;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGridHdr window
//
// This is the header that appears at the top of the grid.  This is a sibling
// to the CGridCore window.
//
/////////////////////////////////////////////////////////////////////////////
class CGridHdr : public CHeaderCtrl
{
// Construction
public:
	CGridHdr();

// Attributes
public:
	CGrid* m_pGrid;
	int m_iColScrollOffset;

// Operations
public:
	void SelectColumn(int iColumn) {m_iSelectedColumn = iColumn ;}
	int GetSelectedColumn() {return m_iSelectedColumn; }
	void SetColumnWidth(int iCol, int cx, BOOL bRedraw);
	void SetColVisibility(int iCol, BOOL bVisible);
	int ColWidthFromHeader(int iCol);
	void FixColWidths();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridHdr)
	//}}AFX_VIRTUAL

	afx_msg void OnItemChanged(NMHDR *pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChanging(NMHDR *pNMHDR, LRESULT* pResult);
	afx_msg void OnItemClick(NMHDR *pNMHDR, LRESULT* pResult);
	afx_msg void OnDividerDblClick(NMHDR *pNMHDR, LRESULT* pResult);

// Implementation
public:
	virtual ~CGridHdr();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGridHdr)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	int FindLastVisibleCol();

	int m_iSelectedColumn;
	BOOL m_bIsSettingColumnWidth;
	BOOL m_bUIActive;
};



/////////////////////////////////////////////////////////////////////////////
// CHdrWnd window

class CHdrWnd : public CWnd
{
// Construction
public:
	CHdrWnd(CGrid* pGrid);
	CGridHdr& Header() {return m_hdr; }
	void SetScrollOffset(int iCol, int ixScrollOffset);
	BOOL Create(DWORD dwStyle, CRect& rc, CWnd* pwndParent, UINT nId);
	void OnGridSizeChanged();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHdrWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHdrWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHdrWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CGridHdr m_hdr;
	int m_ixScrollOffset;
	int m_iColScrollOffset;
	BOOL m_bUIActive;
	CGrid* m_pGrid;
};

#endif _gridhdr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\hmmverr.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.h
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************

#ifndef _hmmv_error_h

struct IHmmClassObject;
extern void HmmvReleaseErrorObject(IHmmClassObject *&  pcoError);

extern void HmmvErrorMsg(
		LPCTSTR szUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

#endif //_hmmv_error_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\hmmverr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.cpp
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************


#include "precomp.h"
#include <wbemidl.h>
#include "hmmverr.h"
#include <MsgDlgExterns.h>

//*********************************************************************
// HmmvReleaseErrorObject
//
// Releases an error object if it hasn't already been released.
//
// Parameters:
//		[in/out] IWbemClassObject *&  pcoError
//			A reference to the error object pointer.
//
//	Returns:
//		Nothing.
//
//********************************************************************
void HmmvReleaseErrorObject(IWbemClassObject *&  pcoError)
{
	if (pcoError)
	{
		pcoError->Release();
		pcoError = NULL;
	}
}


//********************************************************************************
// LogMsg
//
// Write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szMessage
//			The error message string.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.
//
//		[in] int nLine
//			The line number where the error occurred.
//
// Returns:
//		Nothing.
//
//************************************************************************************
static void LogMsg(LPCTSTR szMessage, LPCTSTR szFile, int nLine)
{

}


//*******************************************************************************
// ErrorMsg
//
// Display an error dialog and write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szUserMsg
//			The user message to display in the dialog box.
//
//		[in] SCODE sc
//			The HMOM status code.
//
//		[in] LPCTSTR szLogMsg
//			The message to write to the log.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] int nLine
//			The line where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] BOOL bLog
//			TRUE to write a message to the log file.
//
// Returns:
//			Nothing.
//
//*************************************************************************************************
void HmmvErrorMsg(
		LPCTSTR szUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog
)
{

	CString sUserMsg(szUserMsg);
	BSTR bstrUserMsg = sUserMsg.AllocSysString();

	DisplayUserMessage(L"WMI Object Viewer", bstrUserMsg, sc, bUseErrorObject);

	::SysFreeString(bstrUserMsg);

	if (bLog)
	{
		LogMsg(szLogMsg,  szFile, nLine);
	}
}


//*******************************************************************************
// ErrorMsg
//
// This function is the same as the previous ErrorMsg except that it
// takes a string resource ID as its first parameter rather than a
// string pointer.
//
// Parameters:
//		Same as ErrorMsg above except for idsUserMsg which is
//		the resource id of the error message string.
//
// Returns:
//		Nothing.
//
//*********************************************************************************
extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog)
{
	CString sUserMsg;
	sUserMsg.LoadString(idsUserMsg);
	HmmvErrorMsg((LPCTSTR) sUserMsg, sc, bUseErrorObject, szLogMsg, szFile, nLine, bLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\hmmvgrid.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// hmmvgrid.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static AFX_EXTENSION_MODULE HmmvgridDLL = { NULL, NULL };

HINSTANCE g_hInstance;
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	g_hInstance = hInstance;

	// Remove this if you use lpReserved
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("HMMVGRID.DLL Initializing!\n");

		// Extension DLL one-time initialization
		if (!AfxInitExtensionModule(HmmvgridDLL, hInstance))
			return 0;

		// Insert this DLL into the resource chain
		// NOTE: If this Extension DLL is being implicitly linked to by
		//  an MFC Regular DLL (such as an ActiveX Control)
		//  instead of an MFC application, then you will want to
		//  remove this line from DllMain and put it in a separate
		//  function exported from this Extension DLL.  The Regular DLL
		//  that uses this Extension DLL should then explicitly call that
		//  function to initialize this Extension DLL.  Otherwise,
		//  the CDynLinkLibrary object will not be attached to the
		//  Regular DLL's resource chain, and serious problems will
		//  result.

		new CDynLinkLibrary(HmmvgridDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("HMMVGRID.DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(HmmvgridDLL);
	}
	return 1;   // ok
}


void __declspec(dllexport) InitializeHmmvGrid()
{
		new CDynLinkLibrary(HmmvgridDLL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	hmmvgrid.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2D254984_C894_11D0_8478_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__2D254984_C894_11D0_8478_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2D254984_C894_11D0_8478_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\svbase.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "svbase.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild

IMPLEMENT_DYNCREATE(CSingleViewChild, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild properties

CString CSingleViewChild::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleViewChild::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleViewChild::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleViewChild::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleViewChild::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild operations

long CSingleViewChild::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleViewChild::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleViewChild::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleViewChild::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleViewChild::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleViewChild::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleViewChild::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleViewChild::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleViewChild::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleViewChild::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleViewChild::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleViewChild::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleViewChild::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleViewChild::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleViewChild::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleViewChild::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\svbase.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild wrapper class

class CSingleViewChild : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleViewChild)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\notify.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _notify_h
#define _notify_h

#if 0
//********************************************************
// This include file contains the class definition for generic
// event notification.  Other classes use these classes to
// maintain of list of clients that must be notified when
// an event occurs.
//
// The client "catches" the event by deriving a class from the
// CNotifyClient base class and overriding the "SendEvent" method.
// The event source will call the SendEvent method for each
// client on its notification list.
//
//***********************************************************


//*******************************************************
// The CNotifyClient class is used as the base class for
// clients that want to "catch" events.
//
//*******************************************************
class CNotifyClient
{
public:
	virtual void CatchEvent(long lEvent);
	void SendEvent(long lEvent) {CatchEvent(lEvent); }
};



//********************************************************
// The CDistributeEvent class is used to store a list of
// clients that must be notified when a particular event
// occurs.  When the "SendEvent" method is called, all 
// clients are notified.
//
//********************************************************
class CDistributeEvent
{
public:
	void AddClient(CNotifyClient* pNotify);
	void RemoveClient(CNotifyClient* pClient);
	void SendEvent(LONG lEvent);
private:
	CPtrArray m_paClients;
};

#endif //0



enum {NOTIFY_GRID_MODIFICATION_CHANGE, 
	  NOTIFY_SAVE_BUTTON_CLICKED,
	  NOTIFY_CELL_EDIT_COMBO_DROP_CLICKED,
	  NOTIFY_CELL_EDIT_LISTBOX_LBUTTON_UP,
	  NOTIFY_OBJECT_SAVE_SUCCESSFUL};
#endif //_notify_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\notify.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "notify.h"


//****************************************************************
// CNotifyClient::CatchEvent
//
// The default action for this virtual function is to do nothing.
// Classes that derive from this base class can override this function
// to "catch" events sent to the notification client.
//
// Parameters:
//		long lEvent
//			The event code.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CNotifyClient::CatchEvent(long lEvent)
{
}



//****************************************************************
// CDistributeEvent::AddClient
//
// Add a client to the event distribution list.
//
// Parameters:
//		CNotifyClient* pClient
//			Pointer to a client to send notification events to.
//			Note that the caller is responsible for allocating
//			and deleting this the client.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CDistributeEvent::AddClient(CNotifyClient* pClient)
{
	m_paClients.Add(pClient);
}


//*****************************************************************
// CDistributeEvent::RemoveClient
//
// Remove a client from the event distribution list.
//
// Parameters:
//		CNotifyClient* pClient
//			Pointer to the client to remove from the list.  Note that
//			the pointer is removed from the list, but not deleted.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CDistributeEvent::RemoveClient(CNotifyClient* pClient)
{
	// Search for the specified client and remove it if found.
	LONG nClients = m_paClients.GetSize();
	for (LONG iClient = 0; iClient<nClients; ++iClient) {
		CNotifyClient* pClientTemp = (CNotifyClient*) m_paClients[iClient];
		if (pClientTemp == pClient) {
			m_paClients.RemoveAt(iClient);
			break;
		}
	}
}



//*****************************************************************
// CNotifyArray::SendEvent
//
// Call this method to send an event to all the clients on this
// notification list.
//
// Parameters:
//		LONG lEvent
//			The event value.  The sender and client understand what
//			the values mean.
//
// Returns:
//		Nothing.
//
//******************************************************************
void CDistributeEvent::SendEvent(LONG lEvent)
{
	// Send the specified event to all clients
	LONG nClients = m_paClients.GetSize();
	for (LONG iClient = 0; iClient<nClients; ++iClient) {
		CNotifyClient* pClient = (CNotifyClient*) m_paClients[iClient];
		pClient->SendEvent(lEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hmmvgrid.rc
//
#define IDOK2                           3
#define IDI_ARRAY_CAPTION               134
#define IDD_EDIT_OBJECT                 135
#define IDB_CHECKBOX                    137
#define IDB_CHECKBOX_UNMODIFIED         137
#define IDD_OBJECT_TYPE                 138
#define IDD_TIME                        142
#define IDB_TIMEHANDLE                  145
#define IDB_PROPMARKER_SYSPROP          147
#define IDI_MARKER_LOCAL                148
#define IDI_MARKER_SYS                  149
#define IDI_MARKER_INHERITED            150
#define IDI_MARKER_KEY                  151
#define IDI_MARKER_RSYS                 152
#define IDI_MARKER_RINHERITED           153
#define IDI_MARKER_RLOCAL               154
#define IDB_ASCENDING_INDICATOR         155
#define IDI_MARKER_METHIN               155
#define IDB_DESCENDING_INDICATOR        156
#define IDI_MARKER_METHINOUT            156
#define IDI_MARKER_METHOUT              157
#define IDI_MARKER_METHRETURN           158
#define IDC_ARRAY_DLG_ICON              1000
#define IDC_SINGLEVIEWCTRL1             1001
#define IDC_SINGLEVIEWCTRL2             1002
#define IDC_SINGLEVIEWCTRL              1002
#define IDC_EDIT1                       1003
#define IDC_CLASSNAME                   1003
#define IDC_EDIT_CLASSNAME              1003
#define IDC_INTERVAL                    1003
#define IDC_OK_PROXY                    1004
#define IDC_TIMEZONE                    1008
#define IDOK_PROXY                      1010
#define IDC_TIME_LABEL                  1011
#define IDC_STAT_HELPTEXT               1012
#define IDC_INTERVAL2                   1013
#define MOD_OFFSET                      3000
#define IDS_VT_BOOL                     3001
#define IDS_VT_BSTR                     3002
#define IDS_VT_I2                       3003
#define IDS_VT_I4                       3004
#define IDS_VT_R4                       3005
#define IDS_VT_R8                       3006
#define IDS_VT_UI1                      3007
#define IDS_ARRAY_VT_BOOL               3008
#define IDS_ARRAY_VT_BSTR               3009
#define IDS_ARRAY_VT_I2                 3010
#define IDS_ARRAY_VT_I4                 3011
#define IDS_ARRAY_VT_R4                 3012
#define IDS_ARRAY_VT_R8                 3013
#define IDS_ARRAY_VT_UI1                3014
#define IDS_ATTR_TYPE_BSTR              3015
#define IDS_ATTR_TYPE_BOOL              3016
#define IDS_ATTR_TYPE_I4                3017
#define IDS_ATTR_TYPE_R8                3018
#define IDS_TRUE                        3019
#define IDS_FALSE                       3020
#define IDS_INVALID_CELL_VALUE          3021
#define IDS_VT_DISPATCH                 3022
#define IDS_VT_UNKNOWN                  3022
#define IDS_CIMTYPE_UINT8               3023
#define IDS_CIMTYPE_SINT8               3024
#define IDS_CIMTYPE_UINT16              3025
#define IDS_CIMTYPE_SINT16              3026
#define IDS_CIMTYPE_UINT32              3027
#define IDS_CIMTYPE_I4                  3028
#define IDS_CIMTYPE_SINT32              3028
#define IDS_CIMTYPE_UINT64              3029
#define IDS_CIMTYPE_SINT64              3030
#define IDS_CIMTYPE_STRING              3031
#define IDS_CIMTYPE_BOOL                3032
#define IDS_CIMTYPE_REAL32              3033
#define IDS_CIMTYPE_REAL64              3034
#define IDS_CIMTYPE_DATETIME            3035
#define IDS_CIMTYPE_REF                 3036
#define IDS_ERR_TIMEZONE_RANGE          3037
#define IDS_CIMTYPE_OBJECT              3038
#define IDS_CIMTYPE_UINT8_ARRAY         3039
#define IDS_CIMTYPE_SINT8_ARRAY         3040
#define IDS_CIMTYPE_UINT16_ARRAY        3041
#define IDS_CIMTYPE_SINT16_ARRAY        3042
#define IDS_CIMTYPE_UINT32_ARRAY        3043
#define IDS_CIMTYPE_I4_ARRAY            3044
#define IDS_CIMTYPE_SINT32_ARRAY        3044
#define IDS_CIMTYPE_UINT64_ARRAY        3045
#define IDS_CIMTYPE_SINT64_ARRAY        3046
#define IDS_CIMTYPE_STRING_ARRAY        3047
#define IDS_CIMTYPE_BOOL_ARRAY          3048
#define IDS_CIMTYPE_REAL32_ARRAY        3049
#define IDS_CIMTYPE_REAL64_ARRAY        3050
#define IDS_CIMTYPE_DATETIME_ARRAY      3051
#define IDS_CIMTYPE_REF_ARRAY           3052
#define IDS_CIMTYPE_CHAR16_ARRAY        3053
#define IDS_CIMTYPE_OBJECT_ARRAY        3054
#define IDS_CIMTYPE_OBJECT_DLG          3055
#define IDS_OBJECT_PREFIX               3056
#define IDS_WARN_REPLACE_INSTANCE       3057
#define IDS_INVALID_CLASS_NAME          3058
#define IDS_ERR_CANT_CREATE_INSTANCE    3059
#define IDS_CIMTYPE_CHAR16              3060
#define IDS_CIMTYPE_EMPTY               3061
#define IDS_CIMTYPE_UNEXPECTED          3062
#define IDS_CIMTYPE_ARRAY_PREFIX        3063
#define IDS_ERR_INVALID_VALUE           3064
#define IDS_REF_PREFIX                  3065
#define IDS_WBEM_EMBEDDED_OBJECT        3066
#define IDS_ATTR_TYPE_BSTR_ARRAY        3067
#define IDS_ATTR_TYPE_BOOL_ARRAY        3068
#define IDS_ATTR_TYPE_I4_ARRAY          3069
#define IDS_ATTR_TYPE_R8_ARRAY          3070
#define IDS_UNSUPPORTED_DATE_FORMAT     3071
#define IDR_DEFAULT_MENU                3129
#define IDB_COMBO_DROP                  3130
#define IDR_ARRAYEDIT_MENU              3130
#define IDD_ARRAY                       3131
#define IDR_ARRAYEDIT_MENU1             3131
#define IDB_ARRAY                       3132
#define IDB_OBJECT                      3133
#define IDB_CHECKBOX_MODIFIED           3134
#define IDB_PROPMARKER_SYSPROPKEY       3135
#define IDB_PROPMARKER_KEY              3136
#define IDB_PROPMARKER_INHERITED        3137
#define IDB_PROPMARKER_INHERITEDKEY     3138
#define ID_CMD_SET_CELL_TO_NULL         32771
#define ID_CREATE_VALUE                 32772
#define ID_MCD_CREATE_VALUE             32773
#define ID_CMD_CREATE_VALUE             32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        158
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\timepicker.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TimePicker.cpp : implementation file
//

#include "precomp.h"
//#include "hmmvgrid.h"
#include "TimePicker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTimePicker

CTimePicker::CTimePicker()
{
}

CTimePicker::~CTimePicker()
{
}


BEGIN_MESSAGE_MAP(CTimePicker, CWnd)
	//{{AFX_MSG_MAP(CTimePicker)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTimePicker message handlers

BOOL CTimePicker::CustomCreate(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	// TODO: Add your specialized code here and/or call the base class

	static BOOL bDidInit = FALSE;
	if (!bDidInit) {

		INITCOMMONCONTROLSEX icex;
		icex.dwSize = sizeof(icex);
		icex.dwICC = ICC_DATE_CLASSES;
		InitCommonControlsEx(&icex);
		bDidInit = TRUE;
	}


	dwStyle |= WS_BORDER|WS_CHILD|WS_VISIBLE;

	return CWnd::Create(DATETIMEPICK_CLASS,
				  _T("DateTime"),
				   dwStyle,
				   rect,
				   pParentWnd,
				   nID,
				   NULL);


	//return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}



BOOL CTimePicker::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
    // NOTE USED.
#if 0
    LPNMHDR hdr = (LPNMHDR)lParam;
    LPNMDATETIMECHANGE lpChange;
	switch(hdr->code){
    case DTN_DATETIMECHANGE:{
        lpChange = (LPNMDATETIMECHANGE)lParam;
        DoDateTimeChange(lpChange);        }
		break;
    case DTN_FORMATQUERY:{
        LPNMDATETIMEFORMATQUERY lpDTFQuery = (LPNMDATETIMEFORMATQUERY)lParam;
        // Process DTN_FORMATQUERY to ensure that the control
        // displays callback information properly.
        DoFormatQuery(hdr->hwndFrom, lpDTFQuery);        }
		break;
    case DTN_FORMAT:{
        LPNMDATETIMEFORMAT lpNMFormat = (LPNMDATETIMEFORMAT) lParam;
        // Process DTN_FORMAT to supply information about callback
        // fields (fields) in the DTP control.
        DoFormat(hdr->hwndFrom, lpNMFormat);        }
		break;
    case DTN_WMKEYDOWN:{            LPNMDATETIMEWMKEYDOWN lpDTKeystroke =
                        (LPNMDATETIMEWMKEYDOWN)lParam;
        // Process DTN_WMKEYDOWN to respond to a user's keystroke in
        // a callback field.
        DoWMKeydown(hdr->hwndFrom, lpDTKeystroke);        }
		break;

	}    // All of the above notifications require the owner to return zero.
#endif //0
    return FALSE;
}

void CTimePicker::DoDateTimeChange(LPNMDATETIMECHANGE lpChange)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\utils.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "utils.h"
#include "resource.h"
#include "gctype.h"
#include "wbemidl.h"
#include "gc.h"
#include "hmmverr.h"


//********************************************************
// StripWhiteSpace
//
// Strip all leading and trailing white space out of a string value.
//
// Parameters:
//		[out] CString& sValue
//			The value is returned here.
//
//		[in] LPCTSTR pszValue
//			The string to strip the whitespace from.
//
// Returns:
//		Nothing.
//
//********************************************************
void StripWhiteSpace(CString& sValue, LPCTSTR pszValue)
{
	sValue = _T("");

	// Skip leading spaces
	while (*pszValue) {
		if (isspace(*pszValue)) {
			++pszValue;
		}
		else {
			break;
		}
	}

	// Search for the end of the string.
	LPCTSTR pszEnd = pszValue;
	while (*pszEnd) {
		++pszEnd;
	}

	// Seach backwards for the first non-space character
	--pszEnd;
	while(pszEnd > pszValue) {
		if (isspace(*pszEnd)) {
			--pszEnd;
		}
		else {
			break;
		}
	}

	// Copy everything from the first non-space to the last non-space characters.
	while (pszValue <= pszEnd) {
		sValue += *pszValue++;
	}


}



// One day we will add cell value validation here.
LPCTSTR EatWhite(LPCTSTR psz)
{
	TCHAR ch;
	ch = *psz;
	while (isspace(ch)) {
		ch = *++psz;
	}
	return psz;
}

__int64 atoi64(LPCTSTR pszValue)
{
#ifdef _UNICODE
	char szValue[256];
	wcstombs(szValue, pszValue, sizeof(szValue));
	return _atoi64(szValue);
#else
	return _atoi64(pszValue);
#endif
}

//*************************************************************
// AToUint32
//
// Convert an ASCII string to a uint32 value while doing overflow
// detection.
//
// Parameters:
//		[in/out] LPCTSTR& pszValue
//			Pointer to the numeric string to be converted.  On return
//			it will point just past the last digit eaten by this method.
//
//		[out] ULONG& uiValue
//			The converted value is returned here.
//
// Returns:
//		SCODE
//			S_OK if a value is returned without error.  E_FAIL if no digits
//			were converted or there was an overflow error.
//
//*****************************************************************
SCODE AToUint32(LPCTSTR& pszValue, ULONG& uiValue)
{
	uiValue = 0;
	int nDigits = 0;
	int iDigit;
	ULONG uiValueInitial;
	while (iDigit = *pszValue) {
		if (!::isdigit(iDigit)) {
			break;
		}
		iDigit -= '0';

		// Factor in the next digit after saving the initial value.
		uiValueInitial = uiValue;
		uiValue = uiValue * 10 + iDigit;

		// Check for overflow by doing the inverse of what we did to factor in
		// the next digit to see if we can get back to what we started with.
		int iInverseDigit = uiValue % 10;
		ULONG uiInverseValue  = (uiValue - iInverseDigit) / 10;
		if ((iInverseDigit != iDigit) || (uiInverseValue != uiValueInitial)) {
			// An overflow occurred, so report the failure.
			uiValue = uiValueInitial;
			return E_FAIL;
		}
		++nDigits;
		++pszValue;
	}


	if (nDigits == 0) {
		return E_FAIL;
	}

	return S_OK;
}



//*************************************************************
// AToUint64
//
// Convert an ASCII string to a uint32 value while doing overflow
// detection.
//
// Parameters:
//		[in/out] LPCTSTR& pszValue
//			Pointer to the numeric string to be converted.  On return
//			it will point just past the last digit eaten by this method.
//
//		[out] unsigned __int64& uiValue
//			The converted value is returned here.
//
// Returns:
//		SCODE
//			S_OK if a value is returned without error.  E_FAIL if no digits
//			were converted or there was an overflow error.
//
//*****************************************************************
SCODE AToUint64(LPCTSTR& pszValue, unsigned __int64& uiValue)
{
	uiValue = 0;
	int nDigits = 0;
	int iDigit;
	unsigned __int64 uiValueInitial;
	while (iDigit = *pszValue) {
		if (!::isdigit(iDigit)) {
			break;
		}
		iDigit -= '0';

		// Factor in the next digit after saving the initial value.
		uiValueInitial = uiValue;
		uiValue = uiValue * 10 + iDigit;

		// Check for overflow by doing the inverse of what we did to factor in
		// the next digit to see if we can get back to what we started with.
		int iInverseDigit = (int) (uiValue % 10);
		unsigned __int64 uiInverseValue  = (uiValue - iInverseDigit) / 10;
		if ((iInverseDigit != iDigit) || (uiInverseValue != uiValueInitial)) {
			// An overflow occurred, so report the failure.
			uiValue = uiValueInitial;
			return E_FAIL;
		}
		++nDigits;
		++pszValue;
	}


	if (nDigits == 0) {
		return E_FAIL;
	}

	return S_OK;
}


//*************************************************************
// AToSint64
//
// Convert an ASCII string to a sint64 value while doing overflow
// detection.
//
// Parameters:
//		[in/out] LPCTSTR& pszValue
//			Pointer to the numeric string to be converted.  On return
//			it will point just past the last digit eaten by this method.
//
//		[out] __int64& uiValue
//			The converted value is returned here.
//
// Returns:
//		SCODE
//			S_OK if a value is returned without error.  E_FAIL if no digits
//			were converted or there was an overflow error.
//
//*****************************************************************
SCODE AToSint64(LPCTSTR& pszValue, __int64& iValue)
{
	pszValue = EatWhite(pszValue);

	// Handle the sign.
	BOOL bIsNegative = FALSE;
	if (*pszValue == _T('+')) {
		++pszValue;
	}
	else if (*pszValue == _T('-')) {
		bIsNegative = TRUE;
		++pszValue;
	}


	iValue = 0;
	int nDigits = 0;
	int iDigit;
	__int64 iValueInitial;
	while (iDigit = *pszValue) {
		if (!::isdigit(iDigit)) {
			break;
		}
		iDigit -= '0';

		// Factor in the next digit after saving the initial value.
		iValueInitial = iValue;
		iValue = iValue * 10 + iDigit;

		// Check for overflow by doing the inverse of what we did to factor in
		// the next digit to see if we can get back to what we started with.
		int iInverseDigit = (int) (iValue % 10);
		__int64 iInverseValue  = (iValue - iInverseDigit) / 10;
		if ((iInverseDigit != iDigit) || (iInverseValue != iValueInitial)) {
			// An overflow occurred, so report the failure.
			iValue