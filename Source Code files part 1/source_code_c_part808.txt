                            &BufferSize,
                                              MEM_RESERVE | MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                DbgPrint ("RtlInitializeProfile : secondary alloc VM failed %lx\n",Status);
                return Status;
            }

            ProfileObject[NumberOfProfileObjects].SecondaryBuffer = Buffer;

            Status = NtCreateProfile (
                        &ProfileObject[NumberOfProfileObjects].SecondaryHandle,
                        CurrentProcessHandle,
                        ProfileObject[NumberOfProfileObjects].CodeStart,
                        ProfileObject[NumberOfProfileObjects].CodeLength,
                        ProfileObject[NumberOfProfileObjects].BucketSize,
                        ProfileObject[NumberOfProfileObjects].SecondaryBuffer,
                        ProfileObject[NumberOfProfileObjects].BufferSize,
                        SecondaryProfileSource,
                        (KAFFINITY)-1);

            if (Status != STATUS_SUCCESS) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                DbgPrint("create profile %wZ failed - status %lx\n",
                       ProfileObject[NumberOfProfileObjects].ImageName,Status);
                return Status;
            }
        }

        NumberOfProfileObjects++;

        if (NumberOfProfileObjects == MAX_PROFILE_COUNT) {
            break;
        }
    }

    NtSetIntervalProfile(ProfileInterval,ProfileSource);
    if (UseSecondaryProfile) {
        NtSetIntervalProfile(ProfileInterval,SecondaryProfileSource);
    }

    for (i = 0; i < NumberOfProfileObjects; i++) {

        Status = NtStartProfile (ProfileObject[i].Handle);

        if (Status == STATUS_WORKING_SET_QUOTA) {

            //
            // Increase the working set to lock down a bigger buffer.
            //

            GetProcessWorkingSetSize(CurrentProcessHandle,&WsMin,&WsMax);

            WsMax += 10*ProfilePageSize + ProfileObject[i].BufferSize;
            WsMin += 10*ProfilePageSize + ProfileObject[i].BufferSize;

            SetProcessWorkingSetSize(CurrentProcessHandle,WsMin,WsMax);

            Status = NtStartProfile (ProfileObject[i].Handle);
        }

        if (Status != STATUS_SUCCESS) {
            if (pModuleInformation != NULL) {
                LocalFree (pModuleInformation);
            }

            DbgPrint("start profile %wZ failed - status %lx\n",
                ProfileObject[i].ImageName, Status);
            return Status;
        }

        if (UseSecondaryProfile) {
            Status = NtStartProfile (ProfileObject[i].SecondaryHandle);

            if (Status == STATUS_WORKING_SET_QUOTA) {

                //
                // Increase the working set to lock down a bigger buffer.
                //

                GetProcessWorkingSetSize(CurrentProcessHandle,&WsMin,&WsMax);

                WsMax += 10*ProfilePageSize + ProfileObject[i].BufferSize;
                WsMin += 10*ProfilePageSize + ProfileObject[i].BufferSize;

                SetProcessWorkingSetSize(CurrentProcessHandle,WsMin,WsMax);

                Status = NtStartProfile (ProfileObject[i].SecondaryHandle);
            }

            if (Status != STATUS_SUCCESS) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                DbgPrint("start secondary profile %wZ failed - status %lx\n",
                    ProfileObject[i].ImageName, Status);
                return Status;
            }
        }
    }

    if (pModuleInformation != NULL) {
        LocalFree (pModuleInformation);
    }
    return Status;
}


unsigned long
Percent(
    unsigned long arg1,
    unsigned long arg2,
    unsigned long * Low
    )
{
    unsigned long iarg1 = arg1;
    unsigned __int64 iarg2 = arg2 * 100000;
    unsigned long diff, High;

    diff = (unsigned long) (iarg2 / iarg1);
    while (diff > 100000) {
        diff /= 100000;
    }
    High = diff / 1000;
    *Low = diff % 1000;
    return(High);
}

NTSTATUS
PsStopAndAnalyzeProfile(
    VOID
    )
{
    NTSTATUS status;
    ULONG CountAtSymbol;
    ULONG SecondaryCountAtSymbol;
    NTSTATUS Status;
    ULONG_PTR Va;
    HANDLE ProfileHandle;
    CHAR Line[512];
    ULONG i, n, High, Low;
    PULONG Buffer, BufferEnd, Counter, InitialCounter;
    PULONG SecondaryBuffer;
    PULONG SecondaryInitialCounter;
    ULONG TotalCounts;
    ULONG ByteCount;
    IMAGEHLP_MODULE ModuleInfo;
    SIZE_T dwDisplacement;

    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    __try {
        // If there's a problem faulting in the symbol handler, just return.

        //
        // initialize the symbol handler
        //
        ThisSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
        LastSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        LastSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
        SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE | SYMOPT_OMAP_FIND_NEAREST);
        SymInitialize( SYM_HANDLE, NULL, FALSE );
        SymGetSearchPath( SYM_HANDLE, SymbolSearchPathBuf, sizeof(SymbolSearchPathBuf) );

        ZeroMemory( BadSymBuffer, sizeof(BadSymBuffer) );
        BadSymbol->Name[0] = (BYTE)lstrlen("No Symbol Found");
        lstrcpy( &BadSymbol->Name[1], "No Symbol Found" );
        BadSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        BadSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

        ProfileHandle = CreateFile(
                            OutputFile,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if ( ProfileHandle == INVALID_HANDLE_VALUE ) {
            return STATUS_UNSUCCESSFUL;
        }

        for (i = 0; i < NumberOfProfileObjects; i++) {
            Status = NtStopProfile (ProfileObject[i].Handle);
            Status = NtClose (ProfileObject[i].Handle);
            ASSERT (NT_SUCCESS (Status));
            if (UseSecondaryProfile) {
                Status = NtClose (ProfileObject[i].SecondaryHandle);
                ASSERT (NT_SUCCESS (Status));
            }
        }

        if (MAX_PROFILE_COUNT == NumberOfProfileObjects) {
            _snprintf (Line, sizeof (Line) / sizeof (Line[0]),
                       "Overflowed the maximum number of modules: %d\n",
                       MAX_PROFILE_COUNT);
            Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
            PsWriteProfileLine(ProfileHandle,Line);
        }

        //
        // The new profiler
        //
        for (i = 0; i < NumberOfProfileObjects; i++)  {

            UseLastSymbol = FALSE;
            CountAtSymbol = 0;
            SecondaryCountAtSymbol = 0;

            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer;
            Counter = BufferEnd;

            if (UseSecondaryProfile) {
                SecondaryBuffer = ProfileObject[i].SecondaryBuffer;
            }

            TotalCounts = 0;
            while (Counter > Buffer) {
                Counter -= 1;
                TotalCounts += *Counter;
            }

            if (!TotalCounts) {
                // Don't bother wasting time loading symbols
                continue;
            }

            if (SymLoadModule( SYM_HANDLE, NULL, ProfileObject[i].ImageFileName, NULL,
                                                    (DWORD_PTR)ProfileObject[i].ImageBase, 0)
                    && SymGetModuleInfo(SYM_HANDLE, (DWORD_PTR)ProfileObject[i].ImageBase, &ModuleInfo)
                    && (ModuleInfo.SymType != SymNone)
                )
            {
                ProfileObject[i].SymbolsLoaded = TRUE;
            } else {
                ProfileObject[i].SymbolsLoaded = FALSE;
            }

            _snprintf (Line, sizeof (Line) / sizeof (Line[0]), "%d,%wZ,Total%s\n",
                       TotalCounts,
                       ProfileObject[i].ImageName,
                       (ProfileObject[i].SymbolsLoaded) ? "" : " (NO SYMBOLS)");

            Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
            PsWriteProfileLine(ProfileHandle,Line);

            if (ProfileObject[i].SymbolsLoaded) {

                InitialCounter = Buffer;
                if (UseSecondaryProfile) {
                    SecondaryInitialCounter = SecondaryBuffer;
                }
                for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
                    if ( *Counter ) {

                        //
                        // Now we have an an address relative to the buffer
                        // base.
                        //

                        Va = ((PUCHAR)Counter - (PUCHAR)Buffer);
                        Va = Va * ( 1 << (ProfileObject[i].BucketSize - 2));

                        //
                        // Add in the image base and the base of the
                        // code to get the Va in the image
                        //

                        Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;

                        if (SymGetSymFromAddr( SYM_HANDLE, Va, &dwDisplacement, ThisSymbol )) {
                            if ( UseLastSymbol && LastSymbol->Address == ThisSymbol->Address ) {
                                CountAtSymbol += *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                            } else {
                                if ( UseLastSymbol && LastSymbol->Address ) {
                                    if ( CountAtSymbol || SecondaryCountAtSymbol) {
                                        if (!UseSecondaryProfile) {
                                            _snprintf (Line, sizeof (Line) / sizeof (Line[0]), "%d,%wZ,%s (%08lx)\n",
                                                        CountAtSymbol,
                                                        ProfileObject[i].ImageName,
                                                        LastSymbol->Name,
                                                        LastSymbol->Address
                                                        );
                                        } else {
                                            if (SecondaryCountAtSymbol != 0) {
                                                High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                                                _snprintf (Line,
                                                           sizeof (Line) / sizeof (Line[0]),
                                                           "%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                                            CountAtSymbol,
                                                            SecondaryCountAtSymbol,
                                                            High, Low,
                                                            ProfileObject[i].ImageName,
                                                            LastSymbol->Name,
                                                            LastSymbol->Address
                                                            );
                                            } else {
                                                _snprintf (Line,
                                                           sizeof (Line) / sizeof (Line[0]),
                                                           "%d,%d, -- ,%wZ,%s (%08lx)\n",
                                                           CountAtSymbol,
                                                           SecondaryCountAtSymbol,
                                                           ProfileObject[i].ImageName,
                                                           LastSymbol->Name,
                                                           LastSymbol->Address
                                                           );
                                            }
                                        }
                                        Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                        PsWriteProfileLine(ProfileHandle,Line);
                                        if (ShowAllHits) {
                                            while (InitialCounter < Counter) {
                                                if (*InitialCounter) {
                                                    Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                                    Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                                    Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                                    if (!UseSecondaryProfile) {
                                                        _snprintf (Line,
                                                                   sizeof (Line) / sizeof (Line[0]),
                                                                   "\t%p:%d\n",
                                                                   Va,
                                                                   *InitialCounter);
                                                    } else {
                                                        if (*SecondaryInitialCounter != 0) {
                                                            High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                                            _snprintf (Line,
                                                                       sizeof (Line) / sizeof (Line[0]),
                                                                       "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                                       Va,
                                                                       *InitialCounter,
                                                                       *SecondaryInitialCounter,
                                                                       High, Low);
                                                        } else {
                                                            _snprintf (Line,
                                                                       sizeof (Line) / sizeof (Line[0]),
                                                                       "\t%p:%d, %d, --\n",
                                                                       Va,
                                                                       *InitialCounter,
                                                                       *SecondaryInitialCounter);
                                                        }
                                                    }
                                                    Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                                    PsWriteProfileLine(ProfileHandle, Line);
                                                }
                                                ++InitialCounter;
                                                ++SecondaryInitialCounter;
                                            }
                                        }

                                    }
                                }
                                InitialCounter = Counter;
                                CountAtSymbol = *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryInitialCounter = SecondaryBuffer + (Counter-Buffer);
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                                memcpy( LastSymBuffer, symBuffer, sizeof(symBuffer) );
                                UseLastSymbol = TRUE;
                            }
                        } else {
                            if (CountAtSymbol || SecondaryCountAtSymbol) {
                                if (!UseSecondaryProfile) {
                                    _snprintf (Line,
                                               sizeof (Line) / sizeof (Line[0]),
                                               "%d,%wZ,%s (%08lx)\n",
                                               CountAtSymbol,
                                               ProfileObject[i].ImageName,
                                               LastSymbol->Name,
                                               LastSymbol->Address
                                               );
                                } else {
                                    if (SecondaryCountAtSymbol != 0) {
                                        High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                                        _snprintf (Line,
                                                   sizeof (Line) / sizeof (Line[0]),
                                                   "%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                                   CountAtSymbol,
                                                   SecondaryCountAtSymbol,
                                                   High, Low,
                                                   ProfileObject[i].ImageName,
                                                   LastSymbol->Name,
                                                   LastSymbol->Address
                                                   );
                                    } else {
                                        _snprintf (Line,
                                                   sizeof (Line) / sizeof (Line[0]),
                                                  "%d,%d, -- ,%wZ,%s (%08lx)\n",
                                                   CountAtSymbol,
                                                   SecondaryCountAtSymbol,
                                                   ProfileObject[i].ImageName,
                                                   LastSymbol->Name,
                                                   LastSymbol->Address
                                                   );
                                    }
                                }
                                Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                PsWriteProfileLine(ProfileHandle,Line);
                                if (ShowAllHits) {
                                    while (InitialCounter < Counter) {
                                        if (*InitialCounter) {
                                            Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                            Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                            Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                            if (!UseSecondaryProfile) {
                                                _snprintf (Line,
                                                           sizeof (Line) / sizeof (Line[0]),
                                                           "\t%p:%d\n",
                                                           Va,
                                                           *InitialCounter);
                                            } else {
                                                if (*SecondaryInitialCounter != 0) {
                                                    High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                                    _snprintf (Line,
                                                               sizeof (Line) / sizeof (Line[0]),
                                                               "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                               Va,
                                                               *InitialCounter,
                                                               *SecondaryInitialCounter,
                                                               High,Low);
                                                } else {
                                                    _snprintf (Line,
                                                               sizeof (Line) / sizeof (Line[0]),
                                                               "\t%p:%d, %d, --\n",
                                                               Va,
                                                               *InitialCounter,
                                                               *SecondaryInitialCounter);
                                                }
                                            }
                                            Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                            PsWriteProfileLine(ProfileHandle, Line);
                                        }
                                        ++InitialCounter;
                                        ++SecondaryInitialCounter;
                                    }
                                }

                                InitialCounter = Counter;
                                CountAtSymbol = *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryInitialCounter = SecondaryBuffer + (Counter-Buffer);
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                                memcpy( LastSymBuffer, BadSymBuffer, sizeof(BadSymBuffer) );
                                UseLastSymbol = TRUE;
                            }
                            else {
                                _snprintf (Line,
                                           sizeof (Line) / sizeof (Line[0]),
                                           "%d,%wZ,Unknown (%p)\n",
                                           CountAtSymbol,
                                           ProfileObject[i].ImageName,
                                           Va
                                            );
                                Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                PsWriteProfileLine(ProfileHandle, Line);
                            }
                        }
                    }
                }

                if ( CountAtSymbol || SecondaryCountAtSymbol ) {
                    if (!UseSecondaryProfile) {
                        _snprintf (Line,
                                   sizeof (Line) / sizeof (Line[0]),
                                   "%d,%wZ,%s (%08lx)\n",
                                   CountAtSymbol,
                                   ProfileObject[i].ImageName,
                                   LastSymbol->Name,
                                   LastSymbol->Address
                                   );
                    } else {
                        if (SecondaryCountAtSymbol != 0) {
                            High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                            _snprintf (Line,
                                       sizeof (Line) / sizeof (Line[0]),
                                       "%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                       CountAtSymbol,
                                       SecondaryCountAtSymbol,
                                       High, Low,
                                       ProfileObject[i].ImageName,
                                       LastSymbol->Name,
                                       LastSymbol->Address
                                       );
                        } else {
                            _snprintf (Line,
                                       sizeof (Line) / sizeof (Line[0]),
                                       "%d,%d, -- ,%wZ,%s (%08lx)\n",
                                       CountAtSymbol,
                                       SecondaryCountAtSymbol,
                                       ProfileObject[i].ImageName,
                                       LastSymbol->Name,
                                       LastSymbol->Address
                                       );
                        }
                    }
                    Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                    PsWriteProfileLine(ProfileHandle,Line);
                    if (ShowAllHits) {
                        while (InitialCounter < Counter) {
                            if (*InitialCounter) {
                                Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                if (!UseSecondaryProfile) {
                                    _snprintf (Line,
                                               sizeof (Line) / sizeof (Line[0]),
                                               "\t%p:%d\n",
                                               Va,
                                               *InitialCounter);
                                } else {
                                    if (*SecondaryInitialCounter != 0) {
                                        High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                        _snprintf (Line,
                                                   sizeof (Line) / sizeof (Line[0]),
                                                   "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                   Va,
                                                   *InitialCounter,
                                                   *SecondaryInitialCounter,
                                                   High, Low);
                                    } else {
                                        _snprintf (Line,
                                                   sizeof (Line) / sizeof (Line[0]),
                                                   "\t%p:%d, %d, --\n",
                                                   Va,
                                                   *InitialCounter,
                                                   *SecondaryInitialCounter);
                                    }
                                }
                                Line[sizeof (Line) / sizeof (Line[0]) - 1] = '\0';
                                PsWriteProfileLine(ProfileHandle, Line);
                            }
                            ++InitialCounter;
                            ++SecondaryInitialCounter;
                        }
                    }
                }
                SymUnloadModule( SYM_HANDLE, (DWORD_PTR)ProfileObject[i].ImageBase);
            }
        }

        for (i = 0; i < NumberOfProfileObjects; i++) {
            Buffer = ProfileObject[i].Buffer;
            RtlZeroMemory(Buffer,ProfileObject[i].BufferSize);
        }
        CloseHandle(ProfileHandle);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return STATUS_SUCCESS;
}

BOOLEAN
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(DllHandle);
        if ( NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {
            PsParseCommandLine();
            PsInitializeAndStartProfile();
        }
        break;

    case DLL_PROCESS_DETACH:
        if ( NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {
            PsStopAndAnalyzeProfile();
        }
        break;

    }

    return TRUE;
}


char *
Mystrtok (
    char * string,
    const char * control
    )
{
    unsigned char *str;
    const unsigned char *ctrl = control;

    unsigned char map[32];
    int count;

    static char *nextoken;

    /* Clear control map */
    for (count = 0; count < 32; count++)
        map[count] = 0;

    /* Set bits in delimiter table */
    do {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    /* Initialize str. If string is NULL, set str to the saved
     * pointer (i.e., continue breaking tokens out of the string
     * from the last strtok call) */
    if (string)
        str = string;
    else
        str = nextoken;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token iff this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
        str++;

    string = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str++ )
        if ( map[*str >> 3] & (1 << (*str & 7)) ) {
            *str++ = '\0';
            break;
        }

    /* Update nextoken (or the corresponding field in the per-thread data
     * structure */
    nextoken = str;

    /* Determine if a token has been found. */
    if ( string == str )
        return NULL;
    else
        return string;
}


VOID
PsParseCommandLine(
    VOID
    )
{
    PCHAR CommandLine;
    PCHAR Argument;
    HANDLE MappingHandle;
    PPROFILE_SOURCE_MAPPING ProfileMapping;

    //
    // The original command line is in a shared memory section
    // named "ProfileStartupParameters"
    //
    MappingHandle = OpenFileMapping(FILE_MAP_WRITE,
                                    FALSE,
                                    "ProfileStartupParameters");
    if (MappingHandle != NULL) {
        CommandLine = MapViewOfFile(MappingHandle,
                                    FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0);
        if (!CommandLine) {
            CloseHandle(MappingHandle);
            return;
        }
    } else {
        return;
    }

    Argument = Mystrtok(CommandLine," \t");

    while (Argument != NULL) {
        if ((Argument[0] == '-') ||
            (Argument[0] == '/')) {
            switch (Argument[1]) {
                case 'a':
                case 'A':
                    ShowAllHits = TRUE;
                    break;

                case 'b':
                case 'B':
                    PowerOfBytesCoveredPerBucket = atoi(&Argument[2]);
                    break;

                case 'f':
                case 'F':
                        //
                        // The arg area is unmapped so we copy the string
                                        //
                    OutputFile = HeapAlloc(GetProcessHeap(), 0,
                                            lstrlen(&Argument[2]) + 1);
                    lstrcpy(OutputFile, &Argument[2]);

                case 'i':
                case 'I':
                    ProfileInterval = atoi(&Argument[2]);
                    break;

                case 'k':
                case 'K':
                    fKernel = TRUE;
                    break;

                case 's':
                    ProfileMapping = ProfileSourceMapping;
                    while (ProfileMapping->Name != NULL) {
                        if (_stricmp(ProfileMapping->Name, &Argument[2])==0) {
                            ProfileSource = ProfileMapping->Source;
                            break;
                        }
                        ++ProfileMapping;
                    }
                    break;

                case 'S':
                    ProfileMapping = ProfileSourceMapping;
                    while (ProfileMapping->Name != NULL) {
                        if (_stricmp(ProfileMapping->Name, &Argument[2])==0) {
                            SecondaryProfileSource = ProfileMapping->Source;
                            UseSecondaryProfile = TRUE;
                            break;
                        }
                        ++ProfileMapping;
                    }
                    break;

            }
        }

        Argument = Mystrtok(NULL," \t");
    }

    UnmapViewOfFile(CommandLine);
    CloseHandle(MappingHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\process.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

#include <stddef.h>


BOOL
WINAPI
EnumProcesses(
  DWORD * lpidProcess,
  DWORD cb,
  LPDWORD lpcbNeeded
  )
{
  DWORD  cbProcessInformation;
  LPVOID  pvProcessInformation;
  NTSTATUS Status;
  DWORD  ibCur, i;
  DWORD  cdwMax;
  DWORD  TotalOffset;

  cbProcessInformation = 32768;
Retry:
  pvProcessInformation = LocalAlloc(LMEM_FIXED, cbProcessInformation);

  if (pvProcessInformation == NULL) {
        return(FALSE);
  }

  Status = NtQuerySystemInformation(
                SystemProcessInformation,
                pvProcessInformation,
                cbProcessInformation,
                NULL
                );

  if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {
        LocalFree((HLOCAL) pvProcessInformation);

        cbProcessInformation += 32768;
        goto Retry;
  }

  if ( !NT_SUCCESS(Status) ) {
        LocalFree((HLOCAL) pvProcessInformation);
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
  }

  TotalOffset = 0;
  ibCur = 0;

  cdwMax = cb / sizeof(DWORD);
  i = 0;

  for (;;) {
        PSYSTEM_PROCESS_INFORMATION pProcessInformation;

        pProcessInformation = (PSYSTEM_PROCESS_INFORMATION)
                           ((BYTE *) pvProcessInformation + TotalOffset);

        if (i < cdwMax) {
          try {
                lpidProcess[i] = HandleToUlong(pProcessInformation->UniqueProcessId);
          } except (EXCEPTION_EXECUTE_HANDLER) {
                LocalFree((HLOCAL) pvProcessInformation);

                SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                return(FALSE);
          }
          i++;
        }

        ibCur = pProcessInformation->NextEntryOffset;
        TotalOffset += ibCur;

        if (ibCur == 0) {
          break;
        }
  };

  try {
        *lpcbNeeded = i * sizeof(DWORD);
  } except (EXCEPTION_EXECUTE_HANDLER) {
        LocalFree((HLOCAL) pvProcessInformation);

        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
  }

  LocalFree((HLOCAL) pvProcessInformation);

  return(TRUE);
}


BOOL
WINAPI
GetProcessMemoryInfo (
  HANDLE hProcess,
  PPROCESS_MEMORY_COUNTERS ppsmemCounters,
  DWORD cb
  )

/*++

Routine Description:

  This function returns all the PSVM_COUNTERS for a process.

Arguments:

  hProcess - Handle for the process being queried.

  ppsmemCounters - Points to buffer that will receive the PROCESS_MEMORY_COUNTERS.

  cb - size of ppsmemCounters

Return Value:

  The return value is TRUE or FALSE.

--*/

{
  NTSTATUS Status;
  VM_COUNTERS_EX VmCounters;
  BOOL fEx;

  // Try to feel if the ptr passed is NULL and if not,
  // is it long enough for us.

  try {
         ppsmemCounters->PeakPagefileUsage = 0;
        }
  except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

  if (cb < sizeof(PROCESS_MEMORY_COUNTERS)) {
    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return(FALSE);
  } else if (cb < sizeof(PROCESS_MEMORY_COUNTERS_EX)) {
    fEx = FALSE;
  } else {
    fEx = TRUE;
  }

  Status = NtQueryInformationProcess(
                hProcess,
                ProcessVmCounters,
                &VmCounters,
                sizeof(VmCounters),
                NULL
                );

  if ( !NT_SUCCESS(Status) )
  {
   SetLastError( RtlNtStatusToDosError( Status ) );
   return( FALSE );
  }

  if (fEx) {
      ppsmemCounters->cb                     = sizeof(PROCESS_MEMORY_COUNTERS_EX);
  } else {
      ppsmemCounters->cb                     = sizeof(PROCESS_MEMORY_COUNTERS);
  }
  ppsmemCounters->PageFaultCount             = VmCounters.PageFaultCount;
  ppsmemCounters->PeakWorkingSetSize         = VmCounters.PeakWorkingSetSize;
  ppsmemCounters->WorkingSetSize             = VmCounters.WorkingSetSize;
  ppsmemCounters->QuotaPeakPagedPoolUsage    = VmCounters.QuotaPeakPagedPoolUsage;
  ppsmemCounters->QuotaPagedPoolUsage        = VmCounters.QuotaPagedPoolUsage;
  ppsmemCounters->QuotaPeakNonPagedPoolUsage = VmCounters.QuotaPeakNonPagedPoolUsage;
  ppsmemCounters->QuotaNonPagedPoolUsage     = VmCounters.QuotaNonPagedPoolUsage;
  ppsmemCounters->PagefileUsage              = VmCounters.PagefileUsage;
  ppsmemCounters->PeakPagefileUsage          = VmCounters.PeakPagefileUsage;
  if (fEx) {
    ((PPROCESS_MEMORY_COUNTERS_EX)ppsmemCounters)->PrivateUsage = VmCounters.PrivateUsage;
  }
  return(TRUE);
}


BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    )
{
    NTSTATUS Status;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessWorkingSetWatch,
                NULL,
                0
                );
    if ( NT_SUCCESS(Status) || Status == STATUS_PORT_ALREADY_SET || Status == STATUS_ACCESS_DENIED ) {
        return TRUE;
        }
    else {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return FALSE;
        }
}

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    )
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessWorkingSetWatch,
                (PVOID *)lpWatchInfo,
                cb,
                NULL
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return FALSE;
        }
}

DWORD
WINAPI
GetProcessImageFileNameW(
    HANDLE hProcess,
    LPWSTR lpImageFileName,
    DWORD nSize
    )
{
    PUNICODE_STRING Buffer;
    ULONG           BufferSize,
                    ReturnLength;
    NTSTATUS        Status;

    BufferSize = sizeof(UNICODE_STRING) + nSize * 2;

    Buffer = LocalAlloc(LMEM_FIXED, BufferSize);

    if (! Buffer) {
        ReturnLength = 0;
        goto cleanup;
    }

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessImageFileName,
                                       Buffer,
                                       BufferSize,
                                       NULL);

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (! NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        ReturnLength = 0;
        goto cleanup_buffer;
    }

    RtlCopyMemory(lpImageFileName,
                  Buffer->Buffer,
                  Buffer->Length);

    ReturnLength = Buffer->Length >> 1;

    if (ReturnLength < nSize) {
        lpImageFileName[ReturnLength] = UNICODE_NULL;
    }

 cleanup_buffer:
    LocalFree((HLOCAL) Buffer);

 cleanup:
    return ReturnLength;
}

DWORD
WINAPI
GetProcessImageFileNameA(
    HANDLE hProcess,
    LPSTR lpImageFileName,
    DWORD nSize
    )
{
    PUNICODE_STRING Buffer;
    ULONG           BufferSize,
                    ReturnLength;
    NTSTATUS        Status;

    BufferSize = sizeof(UNICODE_STRING) + nSize * 2;

    Buffer = LocalAlloc(LMEM_FIXED, BufferSize);

    if (! Buffer) {
        ReturnLength = 0;
        goto cleanup;
    }

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessImageFileName,
                                       Buffer,
                                       BufferSize,
                                       NULL);

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (! NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        ReturnLength = 0;
        goto cleanup_buffer;
    }

    ReturnLength = WideCharToMultiByte(CP_ACP,
                                       0,
                                       Buffer->Buffer,
                                       Buffer->Length,
                                       lpImageFileName,
                                       nSize,
                                       NULL,
                                       NULL);

    if (ReturnLength) {
        //
        // WideCharToMultiByte includes the trailing NULL in its
        // count; we do not.
        //
        --ReturnLength;
    }

 cleanup_buffer:
    LocalFree((HLOCAL) Buffer);

 cleanup:
    return ReturnLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\makefile.inc ===
$(O)\win32k\services.tab: $(WINDOWS_INC_PATH)\services.tab
    @-mkdir $(O)\win32k
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\kernel\services.tab: $(BASE_INC_PATH)\services.tab
    @-mkdir $(O)\kernel
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

syssvc.h: $(O)\kernel\services.tab syssvc.stb
    gensrv -d . -e c -g . -stubs syssvc.h -sstb syssvc.stb -B $(O)\kernel

w32svc.h: $(O)\win32k\services.tab w32svc.stb
    gensrv -d . -e c -g . -stubs w32svc.h -sstb w32svc.stb -B -R $(O)\win32k

svcnames.c: syssvc.h w32svc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\ws.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    QUOTA_LIMITS QuotaLimits;
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessQuotaLimits,
                                       &QuotaLimits,
                                       sizeof(QuotaLimits),
                                       NULL);

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    // The following signals a desire to empty the working set

    QuotaLimits.MinimumWorkingSetSize = (SIZE_T)-1;
    QuotaLimits.MaximumWorkingSetSize = (SIZE_T)-1;

    Status = NtSetInformationProcess(hProcess,
                                     ProcessQuotaLimits,
                                     &QuotaLimits,
                                     sizeof(QuotaLimits));

    if ( !NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    return(TRUE);
}


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    )
{
    NTSTATUS Status;

    Status = NtQueryVirtualMemory(hProcess,
                                  NULL,
                                  MemoryWorkingSetInformation,
                                  pv,
                                  cb,
                                  NULL);

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\ntimer.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <..\ztools\inc\tools.h>

#define NUMBER_SERVICE_TABLES 2
#define BUFFER_SIZE 1024

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    );

extern UCHAR *CallTable[];

ULONG SystemCallBufferStart[BUFFER_SIZE];
ULONG SystemCallBufferDone[BUFFER_SIZE];
ULONG Index[BUFFER_SIZE];
ULONG CallData[BUFFER_SIZE];

#define MAX_PROCESSOR 16
SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoStart;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoDone;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoStart[MAX_PROCESSOR];
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoDone[MAX_PROCESSOR];

#define vdelta(FLD) (VdmInfoDone.FLD - VdmInfoStart.FLD)

#ifdef i386
    SYSTEM_VDM_INSTEMUL_INFO VdmInfoStart;
    SYSTEM_VDM_INSTEMUL_INFO VdmInfoDone;
#endif

HANDLE
GetServerProcessHandle( VOID )
{
    HANDLE Process;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;
    NTSTATUS Status;

    RtlInitUnicodeString(&Unicode, L"\\WindowsSS");
    InitializeObjectAttributes(
        &Obja,
        &Unicode,
        0,
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Process,
                PROCESS_ALL_ACCESS,
                &Obja,
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        printf("OpenProcess Failed %lx\n",Status);
        Process = NULL;
        }
    return Process;
}

BOOL WINAPI
CtrlcHandler(
    ULONG CtrlType
    )
{
    //
    // Ignore control C interrupts.  Let child process deal with them
    // if it wants.  If it doesn't then it will terminate and we will
    // get control and terminate ourselves
    //
    return TRUE;
}


int
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s;
    BOOL bFull;
    BOOL bOneLine;
    BOOL bSyscall;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL b;
    VM_COUNTERS ServerVmInfoStart, ServerVmInfoDone, ProcessVmInfoStart, ProcessVmInfoDone;
    KERNEL_USER_TIMES Times, ServerStart, ServerDone, ProcessStart, ProcessDone;
    NTSTATUS Status;
    TIME_FIELDS Etime,Utime,Ktime,Itime;
    LARGE_INTEGER RunTime;
    LARGE_INTEGER IdleTime;
    HANDLE OtherProcess;
    ULONG i;
    CHAR ch;
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG Temp;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    PSYSTEM_CALL_COUNT_INFORMATION SystemCallInfoStart;
    PSYSTEM_CALL_COUNT_INFORMATION SystemCallInfoDone;
    PULONG SystemCallTableStart;
    PULONG SystemCallTableDone;
    ULONG NumberOfCounts;
    PULONG p;
    BOOL bShowHelpMsg = FALSE;

    argv;
    envp;

    ConvertAppToOem( argc, argv );
    OtherProcess = NULL;
    ProcessHandle = NULL;
    if ( (argc < 2) ) {
        bShowHelpMsg = TRUE;
    }

    SetConsoleCtrlHandler( CtrlcHandler, TRUE );

    ProcessId = 0;

    s = GetCommandLine();
    if( s != NULL ) {
        CharToOem( s, s );
    }
    bFull = FALSE;
    bOneLine = FALSE;
    bSyscall = FALSE;

    //
    // skip blanks
    //
    while( (NULL != s) && (*s > ' '))s++;

    //
    // get to next token
    //
    while((NULL != s) && (*s == ' ')) s++;

    while ((NULL != s) && ( *s == '-' ) || ( *s == '/' )) {
        s++;
        //if "-" or "/" only specified.. display help/usage
        if ( '\0' == *s )
        {
             bShowHelpMsg = TRUE;
             break;
        }

        while (*s > ' ') {
            switch (*s) {
                case '1' :
                    bOneLine = TRUE;
                    break;

                case 'c' :
                case 'C' :
                    bSyscall = TRUE;
                    break;

                case 'f' :
                case 'F' :
                    bFull = TRUE;
                    break;

                case 's' :
                case 'S' :
                    OtherProcess = GetServerProcessHandle();
                    break;

                case 'P':
                case 'p':
                    // pid takes decimal argument
                    s++;
                    do
                        ch = *s++;
                    while (ch == ' ' || ch == '\t');

                    while (ch >= '0' && ch <= '9') {
                        Temp = ProcessId * 10 + ch - '0';
                        if (Temp < ProcessId) {
                                printf("pid number overflow\n");
                                ExitProcess(1);
                                }
                        ProcessId = Temp;
                        ch = *s++;
                        }
                    if (!ProcessId) {
                        printf("bad pid '%ld'\n", ProcessId);
                        ExitProcess(1);
                        }
                    s--;
                    if ( *s == ' ' ) s--;
                    break;

                case 'h':
                case 'H':
                case '?':
                    bShowHelpMsg = TRUE;
                    break;

                default :
                    break;
                }
            s++;
            }
        //
        // get to next token
        //
        while(*s==' ')s++;
        }

    // see if this is just a request for command line help.

    if ( bShowHelpMsg ) {
        puts("\n"
             "Usage: ntimer [-1 -f -s] name-of-image [parameters]...\n"
             "\n"
             "    Displays the Elapsed, Kernel, User and Idle time of the\n"
             "    image specified in the command line\n"
             "\n"
             "         -1  displays output on one line\n"
             "         -f  displays the process page faults, total\n"
             "             system interrupts, context switches and system\n"
             "             calls\n"
             "         -s  indicates the name of the image is that of a\n"
             "             server process. Press Ctrl-C to get the times.");
        ExitProcess(1);
    }

    if ( ProcessId ) {
        ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcessId);
        }
    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    if (bOneLine) {
        bSyscall = FALSE;
    }

    if (bSyscall) {
        Status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)SystemCallBufferStart,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        bSyscall = FALSE;
        if (!NT_SUCCESS(Status)) {
            printf("Failed to query system call performance information: %x\n", Status);
        } else {

            SystemCallInfoStart = (PVOID)SystemCallBufferStart;
            SystemCallInfoDone = (PVOID)SystemCallBufferDone;

            //
            // Make sure that the number of tables reported by the kernel matches
            // our list.
            //

            if (SystemCallInfoStart->NumberOfTables != NUMBER_SERVICE_TABLES) {
                printf("System call table count (%d) doesn't match NTIMER's count (%d)\n",
                        SystemCallInfoStart->NumberOfTables, NUMBER_SERVICE_TABLES);
            } else {

                //
                // Make sure call count information is available for base services.
                //

                p = (PULONG)(SystemCallInfoStart + 1);

                SystemCallTableStart = (PULONG)(SystemCallInfoStart + 1) + NUMBER_SERVICE_TABLES;
                SystemCallTableDone = (PULONG)(SystemCallInfoDone + 1) + NUMBER_SERVICE_TABLES;

                if (p[0] == 0) {
                    printf("No system call count information available for base services\n");
                } else {

                    //
                    // If there is a hole in the count information (i.e., one set of services
                    // doesn't have counting enabled, but a subsequent one does, then our
                    // indexes will be off, and we'll display the wrong service names.
                    //

                    i = 2;
                    for ( ; i < NUMBER_SERVICE_TABLES; i++ ) {
                        if ((p[i] != 0) && (p[i-1] == 0)) {
                            printf("One or more call count tables empty.  NTIMER can't report\n");
                            break;
                        }
                    }
                    if ( i >= NUMBER_SERVICE_TABLES ) {
                        bSyscall = TRUE;
                        NumberOfCounts = SystemCallInfoStart->Length
                                            - sizeof(SYSTEM_CALL_COUNT_INFORMATION)
                                            - NUMBER_SERVICE_TABLES * sizeof(ULONG);
                    }
                }
            }
        }
    }


    if ( OtherProcess ) {
        Status = NtQueryInformationProcess(
                    OtherProcess,
                    ProcessTimes,
                    &ServerStart,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( ProcessHandle ) {
        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessTimes,
                    &ProcessStart,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( bFull ) {

        if ( OtherProcess ) {
            Status = NtQueryInformationProcess(
                        OtherProcess,
                        ProcessVmCounters,
                        &ServerVmInfoStart,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }

        if ( ProcessHandle ) {
            Status = NtQueryInformationProcess(
                        ProcessHandle,
                        ProcessVmCounters,
                        &ProcessVmInfoStart,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
        else {
            ZeroMemory(&ProcessVmInfoStart,sizeof(VM_COUNTERS));
            }
#ifdef i386
        Status = NtQuerySystemInformation(
                    SystemVdmInstemulInformation,
                    &VdmInfoStart,
                    sizeof(VdmInfoStart),
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query vdm information\n");
            ExitProcess((DWORD)Status);
            }
#endif
        Status = NtQuerySystemInformation(
           SystemBasicInformation,
           &BasicInfo,
           sizeof(BasicInfo),
           NULL
        );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query basic information\n");
            ExitProcess((DWORD)Status);
            }

        Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                        (PVOID)&ProcessorInfoStart,
                        sizeof (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
                        NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query preocessor performance information\n");
            ExitProcess((DWORD)Status);
            }

        }


    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfoStart,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    ContextSwitches = SystemInfoStart.ContextSwitches;
    FirstLevelFills = SystemInfoStart.FirstLevelTbFills;
    SecondLevelFills = SystemInfoStart.SecondLevelTbFills;
    b = CreateProcess(
            NULL,
            s,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInformation
            );

    if ( !b ) {
        printf("CreateProcess(%s) failed %d\n",s,GetLastError());
        ExitProcess(GetLastError());
        }

    WaitForSingleObject(ProcessInformation.hProcess,(DWORD)-1);

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfoDone,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (!bOneLine) {
        printf("\nContextSwitches - %d\nFirst level fills = %d\nSecond level fills = %d\n",
               SystemInfoDone.ContextSwitches - ContextSwitches,
               SystemInfoDone.FirstLevelTbFills - FirstLevelFills,
               SystemInfoDone.SecondLevelTbFills - SecondLevelFills);
    }

    if ( OtherProcess ) {
        Status = NtQueryInformationProcess(
                    OtherProcess,
                    ProcessTimes,
                    &ServerDone,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( ProcessHandle ) {
        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessTimes,
                    &ProcessDone,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }
    else {

        Status = NtQueryInformationProcess(
                    ProcessInformation.hProcess,
                    ProcessTimes,
                    &Times,
                    sizeof(Times),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( bFull ) {
        if ( OtherProcess ) {
            Status = NtQueryInformationProcess(
                        OtherProcess,
                        ProcessVmCounters,
                        &ServerVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }

        if ( ProcessHandle ) {
            Status = NtQueryInformationProcess(
                        ProcessHandle,
                        ProcessVmCounters,
                        &ProcessVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
        else {
            Status = NtQueryInformationProcess(
                        ProcessInformation.hProcess,
                        ProcessVmCounters,
                        &ProcessVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
#ifdef i386
        Status = NtQuerySystemInformation(
                    SystemVdmInstemulInformation,
                    &VdmInfoDone,
                    sizeof(VdmInfoStart),
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query vdm information\n");
            ExitProcess((DWORD)Status);
            }
#endif

        Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                        (PVOID)&ProcessorInfoDone,
                        sizeof (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
                        NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query preocessor performance information\n");
            ExitProcess((DWORD)Status);
            }

        }

    if ( bSyscall ) {
        Status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)SystemCallBufferDone,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query system call performance information: %x\n", Status);
            bSyscall = FALSE;
            }
        }

    RunTime.QuadPart = Times.ExitTime.QuadPart - Times.CreateTime.QuadPart;
    IdleTime.QuadPart = SystemInfoDone.IdleProcessTime.QuadPart -
                        SystemInfoStart.IdleProcessTime.QuadPart;
    RtlTimeToTimeFields ( (PLARGE_INTEGER)&IdleTime, &Itime);
    if ( ProcessHandle ) {
        RunTime.QuadPart = ProcessDone.UserTime.QuadPart -
                                                ProcessStart.UserTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Utime);
        RunTime.QuadPart = ProcessDone.KernelTime.QuadPart -
                                                ProcessStart.KernelTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Ktime);

        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("ProcessTimes            ");

            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }
    else {
        RtlTimeToTimeFields((PLARGE_INTEGER) &RunTime, &Etime);
        RtlTimeToTimeFields(&Times.UserTime, &Utime);
        RtlTimeToTimeFields(&Times.KernelTime, &Ktime);

        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Etime.Hour,
                    Etime.Minute,
                    Etime.Second,
                    Etime.Milliseconds,
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("\nETime( %3ld:%02ld:%02ld.%03ld ) ",
                    Etime.Hour,
                    Etime.Minute,
                    Etime.Second,
                    Etime.Milliseconds
                    );
            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld )\n",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }

    if ( OtherProcess ) {
        RunTime.QuadPart = ServerDone.UserTime.QuadPart -
                                                ServerStart.UserTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Utime);
        RunTime.QuadPart = ServerDone.KernelTime.QuadPart -
                                                ServerStart.KernelTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Ktime);
        printf("ServerTimes             ");


        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld )\n",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }

    if ( bFull ) {
        ULONG InterruptCount;
        ULONG PreviousInterruptCount;
#ifdef i386
        ULONG EmulationTotal;
#endif

        PreviousInterruptCount = 0;
        for (i=0; i < (ULONG)BasicInfo.NumberOfProcessors; i++) {
            PreviousInterruptCount += ProcessorInfoStart[i].InterruptCount;
            }

        InterruptCount = 0;
        for (i=0; i < (ULONG)BasicInfo.NumberOfProcessors; i++) {
            InterruptCount += ProcessorInfoDone[i].InterruptCount;
            }

        if (bOneLine) {
            printf(" %ld",ProcessVmInfoDone.PageFaultCount - ProcessVmInfoStart.PageFaultCount);
            if (OtherProcess) {
                printf(" %ld",ServerVmInfoDone.PageFaultCount - ServerVmInfoStart.PageFaultCount);
                }
            printf(" %ld", InterruptCount - PreviousInterruptCount);
            printf(" %ld", SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches);
            printf(" %ld", SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls);
            }
        else {
            printf("\n");
            printf("Process PageFaultCount      %ld\n",ProcessVmInfoDone.PageFaultCount - ProcessVmInfoStart.PageFaultCount);
            if (OtherProcess) {
                printf("Server  PageFaultCount      %ld\n",ServerVmInfoDone.PageFaultCount - ServerVmInfoStart.PageFaultCount);
                }
            printf("Total Interrupts            %ld\n", InterruptCount - PreviousInterruptCount);
            printf("Total Context Switches      %ld\n", SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches);
            printf("Total System Calls          %ld\n", SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls);
        }

        if (ProcessHandle) {
#ifdef i386
            printf("\n");
            printf("Total OpcodeHLT             %ld\n", vdelta(OpcodeHLT         ));
            printf("Total OpcodeCLI             %ld\n", vdelta(OpcodeCLI         ));
            printf("Total OpcodeSTI             %ld\n", vdelta(OpcodeSTI         ));
            printf("Total BopCount              %ld\n", vdelta(BopCount          ));
            printf("Total SegmentNotPresent     %ld\n", vdelta(SegmentNotPresent ));
            printf("Total OpcodePUSHF           %ld\n", vdelta(OpcodePUSHF       ));
            printf("Total OpcodePOPF            %ld\n", vdelta(OpcodePOPF        ));
            printf("Total VdmOpcode0F           %ld\n", vdelta(VdmOpcode0F       ));
            printf("Total OpcodeINSB            %ld\n", vdelta(OpcodeINSB        ));
            printf("Total OpcodeINSW            %ld\n", vdelta(OpcodeINSW        ));
            printf("Total OpcodeOUTSB           %ld\n", vdelta(OpcodeOUTSB       ));
            printf("Total OpcodeOUTSW           %ld\n", vdelta(OpcodeOUTSW       ));
            printf("Total OpcodeINTnn           %ld\n", vdelta(OpcodeINTnn       ));
            printf("Total OpcodeINTO            %ld\n", vdelta(OpcodeINTO        ));
            printf("Total OpcodeIRET            %ld\n", vdelta(OpcodeIRET        ));
            printf("Total OpcodeINBimm          %ld\n", vdelta(OpcodeINBimm      ));
            printf("Total OpcodeINWimm          %ld\n", vdelta(OpcodeINWimm      ));
            printf("Total OpcodeOUTBimm         %ld\n", vdelta(OpcodeOUTBimm     ));
            printf("Total OpcodeOUTWimm         %ld\n", vdelta(OpcodeOUTWimm     ));
            printf("Total OpcodeINB             %ld\n", vdelta(OpcodeINB         ));
            printf("Total OpcodeINW             %ld\n", vdelta(OpcodeINW         ));
            printf("Total OpcodeOUTB            %ld\n", vdelta(OpcodeOUTB        ));
            printf("Total OpcodeOUTW            %ld\n", vdelta(OpcodeOUTW        ));

            EmulationTotal = vdelta(OpcodeHLT         )+
                             vdelta(OpcodeCLI         )+
                             vdelta(OpcodeSTI         )+
                             vdelta(BopCount          )+
                             vdelta(SegmentNotPresent )+
                             vdelta(OpcodePUSHF       )+
                             vdelta(OpcodePOPF        )+
                             vdelta(VdmOpcode0F       )+
                             vdelta(OpcodeINSB        )+
                             vdelta(OpcodeINSW        )+
                             vdelta(OpcodeOUTSB       )+
                             vdelta(OpcodeOUTSW       )+
                             vdelta(OpcodeINTnn       )+
                             vdelta(OpcodeINTO        )+
                             vdelta(OpcodeIRET        )+
                             vdelta(OpcodeINBimm      )+
                             vdelta(OpcodeINWimm      )+
                             vdelta(OpcodeOUTBimm     )+
                             vdelta(OpcodeOUTWimm     )+
                             vdelta(OpcodeINB         )+
                             vdelta(OpcodeINW         )+
                             vdelta(OpcodeOUTB        )+
                             vdelta(OpcodeOUTW        )
                             ;

            if (bOneLine) {
                printf(" %ld %ld", EmulationTotal, EmulationTotal*515);
                }
            else {
                printf("\n");
                printf("Total Emulation             %ld * 515clocks = %ld cycles\n", EmulationTotal, EmulationTotal*515);
                }
#endif
        }

        if (bSyscall) {
            for (i = 0; i < NumberOfCounts; i += 1) {
                CallData[i] = SystemCallTableDone[i] - SystemCallTableStart[i];
            }

            SortUlongData(NumberOfCounts, Index, CallData);

            for (i = 0; i < NumberOfCounts; i += 1) {
                if (CallData[Index[i]] == 0) {
                    break;
                }
                printf("%8ld calls to %s\n", CallData[Index[i]], CallTable[Index[i]]);
            }
        }

        if (bOneLine) {
            printf("\n");
            }
    } else {
        printf("\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\pcall.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcall.c

Abstract:

    This module contains the Windows NT system call display status.

Author:

    Lou Perazzoli (LouP) 5-feb-1992.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define NUMBER_SERVICE_TABLES 4

//
// Define forward referenced routine prototypes.
//

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    );

#define BUFFER_SIZE 1024
#define DELAY_TIME 1000
#define TOP_CALLS 15

extern UCHAR *CallTable[];

ULONG Index[BUFFER_SIZE];
ULONG CountBuffer1[BUFFER_SIZE];
ULONG CountBuffer2[BUFFER_SIZE];
ULONG CallData[BUFFER_SIZE];

SYSTEM_CONTEXT_SWITCH_INFORMATION SystemSwitchInformation1;
SYSTEM_CONTEXT_SWITCH_INFORMATION SystemSwitchInformation2;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    BOOLEAN Active;
    BOOLEAN CountSort;
    NTSTATUS status;
    ULONG i;
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    KPRIORITY SetBasePriority;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    DWORD NumRead;
    SMALL_RECT Window;
    PSYSTEM_CALL_COUNT_INFORMATION CallCountInfo[2];
    PSYSTEM_CALL_COUNT_INFORMATION CurrentCallCountInfo;
    PSYSTEM_CALL_COUNT_INFORMATION PreviousCallCountInfo;
    PULONG CallCountTable[2];
    PULONG CurrentCallCountTable;
    PULONG PreviousCallCountTable;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION SwitchInfo[2];
    PSYSTEM_CONTEXT_SWITCH_INFORMATION CurrentSwitchInfo;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION PreviousSwitchInfo;
    ULONG Current;
    ULONG Previous;
    LARGE_INTEGER TimeDifference;
    ULONG ContextSwitches;
    ULONG FindAny;
    ULONG FindLast;
    ULONG IdleAny;
    ULONG IdleCurrent;
    ULONG IdleLast;
    ULONG PreemptAny;
    ULONG PreemptCurrent;
    ULONG PreemptLast;
    ULONG SwitchToIdle;
    ULONG TotalSystemCalls;
    ULONG SleepTime=1000;
    BOOLEAN ConsoleMode=TRUE;
    ULONG TopCalls=TOP_CALLS;
    BOOLEAN LoopMode = FALSE;
    BOOLEAN ShowSwitches = TRUE;
    PULONG p;
    ULONG NumberOfCounts;

    while (argc > 1) {
        argv++;
        if (_stricmp(argv[0],"-l") == 0) {
            LoopMode = TRUE;
            ConsoleMode = FALSE;
            TopCalls = BUFFER_SIZE;
            argc--;
            continue;
        }
        if (_stricmp(argv[0],"-s") == 0) {
            ShowSwitches = FALSE;
            argc--;
            continue;
        }
        SleepTime = atoi(argv[0]) * 1000;
        ConsoleMode = FALSE;
        TopCalls = BUFFER_SIZE;
        argc--;
    }

    SetBasePriority = (KPRIORITY)12;

    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    Current = 0;
    Previous = 1;

    CallCountInfo[0] = (PVOID)CountBuffer1;
    CallCountInfo[1] = (PVOID)CountBuffer2;
    CallCountTable[0] = (PULONG)(CallCountInfo[0] + 1) + NUMBER_SERVICE_TABLES;
    CallCountTable[1] = (PULONG)(CallCountInfo[1] + 1) + NUMBER_SERVICE_TABLES;
    SwitchInfo[0] = &SystemSwitchInformation1;
    SwitchInfo[1] = &SystemSwitchInformation2;

    Current = 0;
    Previous = 1;
    CurrentCallCountInfo = CallCountInfo[0];
    CurrentCallCountTable = CallCountTable[0];
    CurrentSwitchInfo = SwitchInfo[0];
    PreviousCallCountInfo = CallCountInfo[1];
    PreviousCallCountTable = CallCountTable[1];
    PreviousSwitchInfo = SwitchInfo[1];

    //
    // Query system information and get the initial call count data.
    //

    status = NtQuerySystemInformation(SystemCallCountInformation,
                                      (PVOID)PreviousCallCountInfo,
                                      BUFFER_SIZE * sizeof(ULONG),
                                      NULL);

    if (NT_SUCCESS(status) == FALSE) {
        printf("Query count information failed %lx\n",status);
        return(status);
    }

    //
    // Make sure that the number of tables reported by the kernel matches
    // our list.
    //

    if (PreviousCallCountInfo->NumberOfTables != NUMBER_SERVICE_TABLES) {
        printf("System call table count (%d) doesn't match PCALL's count (%d)\n",
                PreviousCallCountInfo->NumberOfTables, NUMBER_SERVICE_TABLES);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Make sure call count information is available for base services.
    //

    p = (PULONG)(PreviousCallCountInfo + 1);

    if (p[0] == 0) {
        printf("No system call count information available for base services\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // If there is a hole in the count information (i.e., one set of services
    // doesn't have counting enabled, but a subsequent one does, then our
    // indexes will be off, and we'll display the wrong service names.
    //

    for ( i = 2; i < NUMBER_SERVICE_TABLES; i++ ) {
        if ((p[i] != 0) && (p[i-1] == 0)) {
            printf("One or more call count tables empty.  PCALL can't run\n");
            return STATUS_UNSUCCESSFUL;
        }
    }

    NumberOfCounts = (PreviousCallCountInfo->Length
                        - sizeof(SYSTEM_CALL_COUNT_INFORMATION)
                        - NUMBER_SERVICE_TABLES * sizeof(ULONG)) / sizeof(ULONG);

    //
    // Query system information and get the performance data.
    //

    if (ShowSwitches) {
        status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          (PVOID)PreviousSwitchInfo,
                                          sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION),
                                          NULL);

        if (NT_SUCCESS(status) == FALSE) {
            printf("Query context switch information failed %lx\n",status);
            return(status);
        }
    }

    if (ConsoleMode) {
        GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &sbi);

        Window.Left = 0;
        Window.Top = 0;
        Window.Right = 79;
        Window.Bottom = 23;

        dest.X = 0;
        dest.Y = 23;

        ci.Char.AsciiChar = ' ';
        ci.Attributes = sbi.wAttributes;

        SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                             TRUE,
                             &Window);

        cp.X = 0;
        cp.Y = 0;

        Sm.Left      = 0;
        Sm.Top       = 0;
        Sm.Right     = 79;
        Sm.Bottom    = 22;

        ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                                  &Sm,
                                  NULL,
                                  dest,
                                  &ci);

        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cp);
    }


    //
    // Display title.
    //

    printf( "   Count   System Service\n");
    printf( "_______________________________________________________________\n");

    cp.X = 0;
    cp.Y = 2;

    Sm.Left      = 0;
    Sm.Top       = 2;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScreenHandle = GetStdHandle(STD_INPUT_HANDLE);

    Active = TRUE;
    CountSort = TRUE;
    while(TRUE) {

        Sleep(SleepTime);

        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }

            if (InputRecord.EventType == KEY_EVENT) {

                switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                case 'p':
                case 'P':
                    Active = FALSE;
                    break;

                case 'q':
                case 'Q':
                    ExitProcess(0);
                    break;

                default:
                    Active = TRUE;
                    break;
                }
            }
        }

        //
        // If not active, then sleep for 1000ms and attempt to get input
        // from the keyboard again.
        //

        if (Active == FALSE) {
            Sleep(1000);
            continue;
        }

        if (ConsoleMode) {

            //
            // Scroll the screen buffer down to make room for the next display.
            //

            ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                                      &Sm,
                                      NULL,
                                      dest,
                                      &ci);

            SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cp);
        }

        //
        // Query system information and get the call count data.
        //

        status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)CurrentCallCountInfo,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        if (NT_SUCCESS(status) == FALSE) {
            printf("Query count information failed %lx\n",status);
            return(status);
        }

        //
        // Query system information and get the performance data.
        //

        if (ShowSwitches) {
            status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                              (PVOID)CurrentSwitchInfo,
                                              sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION),
                                              NULL);

            if (NT_SUCCESS(status) == FALSE) {
                printf("Query context switch information failed %lx\n",status);
                return(status);
            }
        }

        //
        // Compute number of system calls for each service, the total
        // number of system calls, and the total time for each serviced.
        //

        TotalSystemCalls = 0;
        for (i = 0; i < NumberOfCounts; i += 1) {
            CallData[i] = CurrentCallCountTable[i] - PreviousCallCountTable[i];
            TotalSystemCalls += CallData[i];
        }

        //
        // Sort the system call data.
        //

        SortUlongData(NumberOfCounts, Index, CallData);

        //
        // Compute context switch information.
        //

        if (ShowSwitches) {
            ContextSwitches =
                CurrentSwitchInfo->ContextSwitches - PreviousSwitchInfo->ContextSwitches;

            FindAny = CurrentSwitchInfo->FindAny - PreviousSwitchInfo->FindAny;
            FindLast = CurrentSwitchInfo->FindLast - PreviousSwitchInfo->FindLast;
            IdleAny = CurrentSwitchInfo->IdleAny - PreviousSwitchInfo->IdleAny;
            IdleCurrent = CurrentSwitchInfo->IdleCurrent - PreviousSwitchInfo->IdleCurrent;
            IdleLast = CurrentSwitchInfo->IdleLast - PreviousSwitchInfo->IdleLast;
            PreemptAny = CurrentSwitchInfo->PreemptAny - PreviousSwitchInfo->PreemptAny;
            PreemptCurrent = CurrentSwitchInfo->PreemptCurrent - PreviousSwitchInfo->PreemptCurrent;
            PreemptLast = CurrentSwitchInfo->PreemptLast - PreviousSwitchInfo->PreemptLast;
            SwitchToIdle = CurrentSwitchInfo->SwitchToIdle - PreviousSwitchInfo->SwitchToIdle;
        }

        //
        // Display the top services.
        //

        printf("\n");
        for (i = 0; i < TopCalls; i += 1) {
            if (CallData[Index[i]] == 0) {
                break;
            }

            printf("%8ld    %s\n",
                   CallData[Index[i]],
                   CallTable[Index[i]]);
        }

        printf("\n");
        printf("Total System Calls            %6ld\n", TotalSystemCalls);

        if (ShowSwitches) {
            printf("\n");
            printf("Context Switch Information\n");
            printf("    Find any processor        %6ld\n", FindAny);
            printf("    Find last processor       %6ld\n", FindLast);
            printf("    Idle any processor        %6ld\n", IdleAny);
            printf("    Idle current processor    %6ld\n", IdleCurrent);
            printf("    Idle last processor       %6ld\n", IdleLast);
            printf("    Preempt any processor     %6ld\n", PreemptAny);
            printf("    Preempt current processor %6ld\n", PreemptCurrent);
            printf("    Preempt last processor    %6ld\n", PreemptLast);
            printf("    Switch to idle            %6ld\n", SwitchToIdle);
            printf("\n");
            printf("    Total context switches    %6ld\n", ContextSwitches);
        }

        //
        // Delay for the sleep interval swap the information buffers and
        // perform another iteration.
        //

        if (!ConsoleMode) {
            _flushall();
        }

        if ((ConsoleMode == FALSE) && (LoopMode == FALSE)) {
            ExitProcess(0);
        }

        Current = 1 - Current;
        Previous = 1 - Previous;
        CurrentCallCountInfo = CallCountInfo[Current];
        CurrentCallCountTable = CallCountTable[Current];
        CurrentSwitchInfo = SwitchInfo[Current];
        PreviousCallCountInfo = CallCountInfo[Previous];
        PreviousCallCountTable = CallCountTable[Previous];
        PreviousSwitchInfo = SwitchInfo[Previous];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\sortcall.c ===
#include <nt.h>

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    )

{

    LONG i;
    LONG j;
    ULONG k;

    //
    // Initialize the index array.
    //

    i = 0;
    do {
        Index[i] = i;
        i += 1;
    } while (i < (LONG)Count);

    //
    // Perform an indexed bubble sort on long data.
    //

    i = 0;
    do {
        for (j = i; j >= 0; j -= 1) {
            if (Data[Index[j]] >= Data[Index[j + 1]]) {
                break;
            }

            k = Index[j];
            Index[j] = Index[j + 1];
            Index[j + 1] = k;
        }

        i += 1;
    } while (i < (LONG)(Count - 1));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\acledit.h ===
BOOL
InitializeAclEditor(
    VOID
    );

BOOL
EditNtObjectSecurity(
    HWND    hwndOwner,
    HANDLE  Object,
    LPWSTR  ObjectName
    );


BOOL
EditTokenDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Token,
    LPWSTR  ObjectName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\timeit.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <..\ztools\inc\tools.h>

#define MAX_PROCESSOR 16
SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoStart;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoDone;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoStart[MAX_PROCESSOR];

BOOLEAN IgnoreNonZeroExitCodes;
BOOLEAN ForceSort;
BOOLEAN RemoveKeys;
LPSTR KeyNameToRemove;
LONG KeyEntriesToTrim;

BOOL WINAPI
CtrlcHandler(
    ULONG CtrlType
    )
{
    //
    // Ignore control C interrupts.  Let child process deal with them
    // if it wants.  If it doesn't then it will terminate and we will
    // get control and terminate ourselves
    //
    return TRUE;
}


void
Usage( void )
{
    fprintf( stderr, "Usage: TIMEIT [-f filename] [-a] [-c] [-i] [-d] [-s] [-t] [-k keyname | -r keyname] [commandline...]\n" );
    fprintf( stderr, "where:        -f specifies the name of the database file where TIMEIT\n" );
    fprintf( stderr, "                 keeps a history of previous timings.  Default is .\\timeit.dat\n" );
    fprintf( stderr, "              -k specifies the keyname to use for this timing run\n" );
    fprintf( stderr, "              -r specifies the keyname to remove from the database.  If\n" );
    fprintf( stderr, "                 keyname is followed by a comma and a number then it will\n" );
    fprintf( stderr, "                 remove the slowest (positive number) or fastest (negative)\n" );
    fprintf( stderr, "                 times for that keyname.\n" );
    fprintf( stderr, "              -a specifies that timeit should display average of all timings\n" );
    fprintf( stderr, "                 for the specified key.\n" );
    fprintf( stderr, "              -i specifies to ignore non-zero return codes from program\n" );
    fprintf( stderr, "              -d specifies to show detail for average\n" );
    fprintf( stderr, "              -s specifies to suppress system wide counters\n" );
    fprintf( stderr, "              -t specifies to tabular output\n" );
    fprintf( stderr, "              -c specifies to force a resort of the data base\n" );
    exit( 1 );
}

typedef struct _TIMEIT_RECORD {
    UCHAR KeyName[ 24 ];
    ULONG GetVersionNumber;
    LARGE_INTEGER ExitTime;
    ULONG ExitCode;
    USHORT Flags;
    USHORT NumberOfRecordsInAverage;

    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER ProcessTime;

    ULONG SystemCalls;
    ULONG ContextSwitches;
    ULONG InterruptCount;
    ULONG PageFaultCount;

    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
} TIMEIT_RECORD, *PTIMEIT_RECORD;


#define TIMEIT_RECORD_SYSTEMINFO 0x0001


#define TIMEIT_VERSION 1

typedef struct _TIMEIT_FILE {
    ULONG VersionNumber;
    ULONG NumberOfRecords;
    TIMEIT_RECORD Records[ 1 ];
} TIMEIT_FILE, *PTIMEIT_FILE;


void
DisplayRecord(
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    );

int
__cdecl
TimeitSortRoutine(
    const void *arg1,
    const void *arg2
    )
{
    PTIMEIT_RECORD p1 = (PTIMEIT_RECORD)arg1;
    PTIMEIT_RECORD p2 = (PTIMEIT_RECORD)arg2;
    int cmp;


    cmp = _stricmp( p1->KeyName, p2->KeyName );
    if (cmp == 0) {
        if (p1->ElapsedTime.QuadPart < p2->ElapsedTime.QuadPart) {
            cmp = -1;
            }
        else
        if (p1->ElapsedTime.QuadPart > p2->ElapsedTime.QuadPart) {
            cmp = 1;
            }
        }

    return cmp;
}

void
UnmapDataBase(
    PTIMEIT_FILE pf
    )
{
    FlushViewOfFile( pf, 0 );
    UnmapViewOfFile( pf );
}

PTIMEIT_FILE
MapDataBase(
    LPSTR DataBaseFileName,
    BOOLEAN WriteAccess,
    PTIMEIT_RECORD p,
    PULONG ActualNumberOfRecords
    )
{
    DWORD BytesWritten;
    HANDLE hf, hm;
    TIMEIT_FILE Temp;
    PTIMEIT_FILE pf;
    ULONG i;
    BOOLEAN RecordsDeleted;
    DWORD FileSize;
    BOOLEAN DeleteRecord, BackupFlag;
    LONG KeyEntriesLeftToTrim;

    hf = CreateFile( DataBaseFileName,
                     WriteAccess ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     p != NULL ? OPEN_ALWAYS : OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                   );
    if (hf == INVALID_HANDLE_VALUE) {
        return NULL;
        }
    if (p != NULL && GetLastError() != ERROR_ALREADY_EXISTS) {
        Temp.VersionNumber = TIMEIT_VERSION;
        Temp.NumberOfRecords = 0;
        WriteFile( hf, &Temp, FIELD_OFFSET( TIMEIT_FILE, Records ), &BytesWritten, NULL );
        }

    FileSize = SetFilePointer( hf, 0, NULL, FILE_END );
    if (p != NULL) {
        if (!WriteFile( hf, p, sizeof( *p ), &BytesWritten, NULL )) {
            CloseHandle( hf );
            return NULL;
            }

        SetEndOfFile( hf );
        FileSize += BytesWritten;
        }

retrymap:
    hm = CreateFileMapping( hf,
                            NULL,
                            WriteAccess ? PAGE_READWRITE | SEC_COMMIT : PAGE_READONLY,
                            0,
                            0,
                            NULL
                          );
    if (hm == NULL) {
        CloseHandle( hf );
        return NULL;
        }

    pf = MapViewOfFile( hm, WriteAccess ? FILE_MAP_WRITE : FILE_MAP_READ, 0, 0, 0 );
    if (pf != NULL) {
        if (p != NULL) {
            pf->NumberOfRecords += 1;
            }

        if (FileSize > FIELD_OFFSET( TIMEIT_FILE, Records )) {
            *ActualNumberOfRecords = (FileSize - FIELD_OFFSET( TIMEIT_FILE, Records )) / sizeof( TIMEIT_RECORD );
            }
        else {
            *ActualNumberOfRecords = 0;
            }

        if (WriteAccess && RemoveKeys && KeyNameToRemove != NULL) {
            if (pf->NumberOfRecords != *ActualNumberOfRecords) {
                pf->NumberOfRecords = *ActualNumberOfRecords;
                }

            KeyEntriesLeftToTrim = KeyEntriesToTrim;
            RecordsDeleted = FALSE;
            for (i=0; i<pf->NumberOfRecords; i++) {
                if ((*KeyNameToRemove == '\0'&& pf->Records[i].KeyName[0] == '\0') ||
                    !_strnicmp( KeyNameToRemove, pf->Records[i].KeyName, 24 )) {
                    DeleteRecord = FALSE;
                    BackupFlag = FALSE;
                    if (KeyEntriesToTrim) {
                        if (KeyEntriesLeftToTrim < 0) {
                            DeleteRecord = TRUE;
                            KeyEntriesLeftToTrim += 1;
                            }
                        else
                        if (KeyEntriesLeftToTrim > 0) {
                            if ((i+1) == pf->NumberOfRecords ||
                                _strnicmp( KeyNameToRemove, pf->Records[i+1].KeyName, 24 )
                               ) {
                                DeleteRecord = TRUE;
                                KeyEntriesLeftToTrim -= 1;
                                BackupFlag = TRUE;
                                }
                            }
                        }
                    else {
                        DeleteRecord = TRUE;
                        }

                    if (DeleteRecord) {
                        RecordsDeleted = TRUE;
                        FileSize -= sizeof( TIMEIT_RECORD );
                        if (i < --(pf->NumberOfRecords)) {
                            memmove( &pf->Records[i],
                                     &pf->Records[i+1],
                                     (pf->NumberOfRecords - i + 1) * sizeof( TIMEIT_RECORD )
                                   );
                            }
                        i -= 1;
                        if (BackupFlag) {
                            i -= 1;
                            }
                        }
                    }
                }

            if (RecordsDeleted) {
                RemoveKeys = FALSE;
                CloseHandle( hm );
                UnmapDataBase( pf );
                SetFilePointer( hf, FileSize, NULL, FILE_BEGIN );
                SetEndOfFile( hf );
                goto retrymap;
                }
            }

        if (WriteAccess) {
            qsort( pf->Records,
                   pf->NumberOfRecords,
                   sizeof( TIMEIT_RECORD ),
                   TimeitSortRoutine
                 );
            }
        }

    CloseHandle( hm );
    CloseHandle( hf );

    return pf;
}


void
AccumulateRecord(
    PTIMEIT_RECORD pavg,
    PTIMEIT_RECORD p
    )
{
    ULONG n;

    if (p != NULL) {
        if (!IgnoreNonZeroExitCodes || p->ExitCode != 0) {
            pavg->ElapsedTime.QuadPart += p->ElapsedTime.QuadPart;
            pavg->ProcessTime.QuadPart += p->ProcessTime.QuadPart;

            if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
                pavg->Flags |= TIMEIT_RECORD_SYSTEMINFO;
                pavg->SystemCalls     += p->SystemCalls;
                pavg->ContextSwitches += p->ContextSwitches;
                pavg->InterruptCount  += p->InterruptCount;
                pavg->PageFaultCount  += p->PageFaultCount;

                pavg->IoReadTransferCount.QuadPart  += p->IoReadTransferCount.QuadPart;
                pavg->IoWriteTransferCount.QuadPart += p->IoWriteTransferCount.QuadPart;
                pavg->IoOtherTransferCount.QuadPart += p->IoOtherTransferCount.QuadPart;
                }

            pavg->NumberOfRecordsInAverage += 1;
            }
        }
    else {
        n = pavg->NumberOfRecordsInAverage;
        if (n > 1 && n != 0xFFFF) {
            pavg->ElapsedTime.QuadPart /= n;
            pavg->ProcessTime.QuadPart /= n;

            if (pavg->Flags & TIMEIT_RECORD_SYSTEMINFO) {
                pavg->SystemCalls /= n;
                pavg->ContextSwitches /= n;
                pavg->InterruptCount /= n;
                pavg->PageFaultCount /= n;

                pavg->IoReadTransferCount.QuadPart /= n;
                pavg->IoWriteTransferCount.QuadPart /= n;
                pavg->IoOtherTransferCount.QuadPart /= n;
                }
            }
        }

    return;
}


void
UpdateDataBase(
    LPSTR DataBaseFileName,
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    )
{
    PTIMEIT_FILE pf;
    PTIMEIT_RECORD p1;
    ULONG i, NumberOfRecords;


    pf = MapDataBase( DataBaseFileName, TRUE, p, &NumberOfRecords );
    if (pf == NULL) {
        fprintf( stderr, "Unable to access data base file '%s' (%u)\n",
                 DataBaseFileName, GetLastError()
               );
        return;
        }

    if (pf->VersionNumber != TIMEIT_VERSION) {
        fprintf( stderr, "Invalid version number (%u) in data base file '%s'\n",
                 pf->VersionNumber, DataBaseFileName
               );
        exit( 1 );
        }

    if (pavg != NULL) {
        memset( pavg, 0, sizeof( *pavg ) );
        pavg->GetVersionNumber = GetVersion();
        for (i=0; i<pf->NumberOfRecords; i++) {
            p1 = &pf->Records[ i ];
            if (!_stricmp( p1->KeyName, p->KeyName )) {
                AccumulateRecord( pavg, p1 );
                }
            }
        AccumulateRecord( pavg, NULL );
        }

    UnmapDataBase( pf );

    DisplayRecord( p, pavg );
    return;
}

char *PlatformStrings[] = {
    "Windows NT",
    "Win32s",
    "Windows 95",
    "unknown"
};

char *Days[] = {
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
};

char *Months[] = {
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
};

void
DisplayRecord(
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    )
{
    LARGE_INTEGER LocalExitTime;
    TIME_FIELDS ExitTime, ElapsedTime, ProcessTime;

    fprintf( stderr, "\n" );
    fprintf( stderr,
             "Version Number:   %s %u.%u (Build %u)\n",
             PlatformStrings[ (p->GetVersionNumber >> 30) & 0x3 ],
             p->GetVersionNumber & 0xFF,
             (p->GetVersionNumber >> 8) & 0xFF,
             (p->GetVersionNumber >> 16) & 0x3FFF
           );
    if (pavg != NULL) {
        fprintf( stderr, "Average is for %u runs\n", pavg->NumberOfRecordsInAverage );
        }

    FileTimeToLocalFileTime( (LPFILETIME)&p->ExitTime, (LPFILETIME)&LocalExitTime );
    RtlTimeToTimeFields( &LocalExitTime, &ExitTime );
    fprintf( stderr,
             "Exit Time:        %u:%02u %s, %s, %s %u %u\n",
             ExitTime.Hour > 12 ? ExitTime.Hour - 12 : ExitTime.Hour,
             ExitTime.Minute,
             ExitTime.Hour > 12 ? "pm" : "am",
             Days[ ExitTime.Weekday ],
             Months[ ExitTime.Month-1 ],
             ExitTime.Day,
             ExitTime.Year
           );

    RtlTimeToTimeFields( &p->ElapsedTime, &ElapsedTime );
    fprintf( stderr,
             "Elapsed Time:     %u:%02u:%02u.%03u",
             ElapsedTime.Hour,
             ElapsedTime.Minute,
             ElapsedTime.Second,
             ElapsedTime.Milliseconds
           );
    if (pavg != NULL) {
        RtlTimeToTimeFields( &pavg->ElapsedTime, &ElapsedTime );
        fprintf( stderr,
                 "  Average: %u:%02u:%02u.%03u",
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds
               );
        }
    fprintf( stderr, "\n" );

    RtlTimeToTimeFields( &p->ProcessTime, &ProcessTime );
    fprintf( stderr,
             "Process Time:     %u:%02u:%02u.%03u",
             ProcessTime.Hour,
             ProcessTime.Minute,
             ProcessTime.Second,
             ProcessTime.Milliseconds
           );
    if (pavg != NULL) {
        RtlTimeToTimeFields( &pavg->ProcessTime, &ProcessTime );
        fprintf( stderr,
                 "  Average: %u:%02u:%02u.%03u",
                 ProcessTime.Hour,
                 ProcessTime.Minute,
                 ProcessTime.Second,
                 ProcessTime.Milliseconds
               );
        }
    fprintf( stderr, "\n" );    

    if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
        fprintf( stderr, "System Calls:     %-11u", p->SystemCalls );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->SystemCalls );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Context Switches: %-11u", p->ContextSwitches );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->ContextSwitches );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Page Faults:      %-11u", p->PageFaultCount );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->PageFaultCount );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Read:       %-11u", p->IoReadTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoReadTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Written:    %-11u", p->IoWriteTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoReadTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Other:      %-11u", p->IoOtherTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoOtherTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );
        }

}

BOOLEAN DisplayDataBaseFirstTime;

void
DisplayDataBaseAverage(
    PTIMEIT_RECORD p,
    BOOLEAN ShowDetailForAverage,
    BOOLEAN TabularOutput
    )
{
    LARGE_INTEGER LocalExitTime;
    TIME_FIELDS ExitTime, ElapsedTime, ProcessTime;

    AccumulateRecord( p, NULL );

    if (DisplayDataBaseFirstTime) {
        if (TabularOutput) {
            fprintf( stderr, "Runs Name                      Elapsed Time   Process Time    System   Context    Page    Total I/O\n" );
            fprintf( stderr, "                                                               Calls  Switches   Faults\n" );
            }

        DisplayDataBaseFirstTime = FALSE;
        }
    else
    if (!TabularOutput) {
        fprintf( stderr, "\n\n" );
        }

    if (TabularOutput) {
        if (p->KeyName[0] == '\0') {
            FileTimeToLocalFileTime( (LPFILETIME)&p->ExitTime, (LPFILETIME)&LocalExitTime );
            RtlTimeToTimeFields( &LocalExitTime, &ExitTime );
            sprintf( p->KeyName,
                     "%02u/%02u/%4u %02u:%02u %s",
                     ExitTime.Month,
                     ExitTime.Day,
                     ExitTime.Year,
                     ExitTime.Hour > 12 ? ExitTime.Hour - 12 : ExitTime.Hour,
                     ExitTime.Minute,
                     ExitTime.Hour > 12 ? "pm" : "am"
                   );
            }

        if (p->NumberOfRecordsInAverage == 0) {
            fprintf( stderr, "    " );
            }
        else
        if (p->NumberOfRecordsInAverage == 0xFFFF) {
            fprintf( stderr, "EXCL" );
            }
        else {
            fprintf( stderr, "%-4u", p->NumberOfRecordsInAverage );
            }
        RtlTimeToTimeFields( &p->ElapsedTime, &ElapsedTime );
        fprintf( stderr, " %-24s %3u:%02u:%02u.%03u",
                 p->KeyName,
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds
               );

        RtlTimeToTimeFields( &p->ProcessTime, &ProcessTime );
        fprintf( stderr, " %3u:%02u:%02u.%03u",
                 ProcessTime.Hour,
                 ProcessTime.Minute,
                 ProcessTime.Second,
                 ProcessTime.Milliseconds
               );

        if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
            fprintf( stderr, " %9u %9u %8u%12u",
                     p->SystemCalls,
                     p->ContextSwitches,
                     p->PageFaultCount,
                     p->IoReadTransferCount.QuadPart +
                        p->IoWriteTransferCount.QuadPart +
                        p->IoOtherTransferCount.QuadPart
                   );
            }
        fprintf( stderr, "\n" );
        if (ShowDetailForAverage &&
            p->NumberOfRecordsInAverage != 0 &&
            p->NumberOfRecordsInAverage != 0xFFFF
           ) {
            fprintf( stderr, "\n" );
            }
        }
    else {
        if (p->NumberOfRecordsInAverage == 0) {
            fprintf( stderr, "Detail Record included in average below\n" );
            }
        else
        if (p->NumberOfRecordsInAverage == 0xFFFF) {
            fprintf( stderr, "Detail Record excluded from average below\n" );
            }
        else {
            fprintf( stderr,
                     "Average for %s key over %u runs\n",
                     p->KeyName,
                     p->NumberOfRecordsInAverage
                   );
            }

        DisplayRecord( p, NULL );
        }
}

void
DisplayDataBase(
    LPSTR DataBaseFileName,
    LPSTR KeyName,
    BOOLEAN ShowDetailForAverage,
    BOOLEAN TabularOutput
    )
{
    TIMEIT_RECORD Averages, Detail;
    PTIMEIT_RECORD p, pPrev, pNext;
    PTIMEIT_FILE pf;
    ULONG i, j;
    ULONG NumberOfRecords, NumberOfRecordsInGroup, CurrentRecordInGroup, NumberOfRecordsToTrim;

    pf = MapDataBase( DataBaseFileName,
                      (BOOLEAN)(ForceSort | RemoveKeys),
                      NULL,
                      &NumberOfRecords
                    );
    if (pf == NULL) {
        fprintf( stderr, "Unable to access data base file '%s' (%u)\n",
                 DataBaseFileName, GetLastError()
               );
        exit( 1 );
        }

    if (pf->VersionNumber != TIMEIT_VERSION) {
        fprintf( stderr, "Invalid version number (%u) in data base file '%s'\n",
                 pf->VersionNumber, DataBaseFileName
               );
        exit( 1 );
        }

    pPrev = NULL;
    DisplayDataBaseFirstTime = TRUE;
    for (i=0; i<NumberOfRecords; i++) {
        p = &pf->Records[ i ];
        if (i == 0 || _stricmp( p->KeyName, Averages.KeyName )) {
            if (i != 0 && (KeyName == NULL || !_stricmp( KeyName, Averages.KeyName ))) {
                DisplayDataBaseAverage( &Averages, ShowDetailForAverage, TabularOutput );
                }

            pNext = p+1;
            NumberOfRecordsInGroup = 1;
            for (j=i+1; j<NumberOfRecords; j++) {
                if (!_stricmp( p->KeyName, pNext->KeyName )) {
                    NumberOfRecordsInGroup += 1;
                    }
                else {
                    break;
                    }

                pNext += 1;
                }

            CurrentRecordInGroup = 0;
            NumberOfRecordsToTrim = NumberOfRecordsInGroup / 10;
            memset( &Averages, 0, sizeof( Averages ) );
            strncpy( Averages.KeyName, p->KeyName, sizeof(Averages.KeyName) - 1 );
            Averages.GetVersionNumber = p->GetVersionNumber;
            }

        Detail = *p;
        Detail.KeyName[0] = '\0';

        CurrentRecordInGroup += 1;
        if (CurrentRecordInGroup <= NumberOfRecordsToTrim ||
            CurrentRecordInGroup > (NumberOfRecordsInGroup-NumberOfRecordsToTrim)
           ) {
            //
            // Ignore fastest and slowest records
            //
            Detail.NumberOfRecordsInAverage = 0xFFFF;
            }
        else {
            Detail.NumberOfRecordsInAverage = 0;
            }

        if (ShowDetailForAverage && (KeyName == NULL || !_stricmp( KeyName, p->KeyName ))) {
            DisplayDataBaseAverage( &Detail, ShowDetailForAverage, TabularOutput );
            }

        if (Detail.NumberOfRecordsInAverage != 0xFFFF) {
            AccumulateRecord( &Averages, p );
            }
        }

    if (i != 0 && (KeyName == NULL || !_stricmp( KeyName, Averages.KeyName ))) {
        DisplayDataBaseAverage( &Averages, ShowDetailForAverage, TabularOutput );
        }
}


int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s, s1, KeyName, CommandLine, DataBaseFileName;
    BOOL b;
    NTSTATUS Status;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    KERNEL_USER_TIMES Times;
    TIMEIT_RECORD t, Averages;
    BOOLEAN DisplayAverage;
    BOOLEAN ShowDetailForAverage;
    BOOLEAN TabularOutput;
    BOOLEAN SuppressSystemInfo;


    //
    // Console API's are OEM, so make it so for us as well
    //
    ConvertAppToOem( argc, argv );

    // printf( "sizeof( TIMEIT_RECORD ) == 0x%x\n", sizeof( TIMEIT_RECORD ) );

    IgnoreNonZeroExitCodes = FALSE;
    ShowDetailForAverage = FALSE;
    SuppressSystemInfo = FALSE;
    TabularOutput = FALSE;
    DisplayAverage = FALSE;
    DataBaseFileName = "timeit.dat";
    CommandLine = NULL;
    KeyName = NULL;
    RemoveKeys = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-') {
            while (*++s) {
                switch(tolower( *s )) {
                    case 'd':
                        ShowDetailForAverage = TRUE;
                        break;

                    case 's':
                        SuppressSystemInfo = TRUE;
                        break;

                    case 't':
                        TabularOutput = TRUE;
                        break;

                    case 'a':
                        DisplayAverage = TRUE;
                        break;

                    case 'f':
                        if (--argc) {
                            DataBaseFileName = *++argv;
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -f switch\n" );
                            Usage();
                            }
                        break;

                    case 'i':
                        IgnoreNonZeroExitCodes = TRUE;
                        break;

                    case 'k':
                        if (--argc) {
                            KeyName = *++argv;
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -k switch\n" );
                            Usage();
                            }
                        break;

                    case 'c':
                        ForceSort = TRUE;
                        break;

                    case 'r':
                        RemoveKeys = TRUE;
                        if (--argc) {
                            KeyNameToRemove = *++argv;
                            if (s1 = strchr(KeyNameToRemove, ',')) {
                                *s1++ = '\0';
                                KeyEntriesToTrim = atoi(s1);
                                }
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;

                    default:
                        fprintf( stderr, "Invalid switch -%c\n", *s );
                        Usage();
                        break;
                    }
                }
            }
        else {
            if (KeyName == NULL) {
                KeyName = s;
                }

            CommandLine = GetCommandLine();
            while (*CommandLine && *CommandLine <= ' ') {
                CommandLine += 1;
                }
            while (*CommandLine && *CommandLine > ' ') {
                CommandLine += 1;
                }

            CommandLine = strstr( CommandLine, s );
            break;
            }
        }

    if (CommandLine == NULL) {
        DisplayDataBase( DataBaseFileName, KeyName, ShowDetailForAverage, TabularOutput );
        exit( 0 );
        }

    memset( &StartupInfo,0,sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof(StartupInfo);

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &BasicInfo,
                                       sizeof( BasicInfo ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "Unable to query basic system information (%x)\n", Status );
        exit( RtlNtStatusToDosError( Status ) );
        }

    if (!SuppressSystemInfo) {
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           (PVOID)&SystemInfoStart,
                                           sizeof( SystemInfoStart ),
                                           NULL
                                         );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "Unable to query system performance data (%x)\n", Status );
            exit( RtlNtStatusToDosError( Status ) );
            }
        }

    if (!CreateProcess( NULL,
                        CommandLine,
                        NULL,
                        NULL,
                        TRUE,
                        0,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation
                      )
       ) {
        fprintf( stderr,
                 "CreateProcess( '%s' ) failed (%u)\n",
                 CommandLine,
                 GetLastError()
               );
        exit( GetLastError() );
        }

    SetConsoleCtrlHandler( CtrlcHandler, TRUE );

    WaitForSingleObject( ProcessInformation.hProcess, INFINITE );

    Status = NtQueryInformationProcess( ProcessInformation.hProcess,
                                        ProcessTimes,
                                        &Times,
                                        sizeof( Times ),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "Unable to query process times (%x)\n", Status );
        exit( RtlNtStatusToDosError( Status ) );
        }

    if (!SuppressSystemInfo) {
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           (PVOID)&SystemInfoDone,
                                           sizeof( SystemInfoDone ),
                                           NULL
                                         );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "Unable to query system performance data (%x)\n", Status );
            exit( RtlNtStatusToDosError( Status ) );
            }
        }

    memset( &t, 0, sizeof( t ) );
    strncpy( t.KeyName, KeyName, sizeof(t.KeyName) - 1 );
    t.GetVersionNumber = GetVersion();
    GetExitCodeProcess( ProcessInformation.hProcess, &t.ExitCode );
    t.ExitTime.QuadPart = Times.ExitTime.QuadPart;
    t.ElapsedTime.QuadPart = Times.ExitTime.QuadPart - Times.CreateTime.QuadPart;

    // total process time ...
    t.ProcessTime.QuadPart = Times.KernelTime.QuadPart + Times.UserTime.QuadPart;

    if (!SuppressSystemInfo) {
        t.SystemCalls = SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls;
        t.ContextSwitches = SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches;
        t.PageFaultCount = SystemInfoDone.PageFaultCount - SystemInfoStart.PageFaultCount;

        t.IoReadTransferCount.QuadPart = SystemInfoDone.IoReadTransferCount.QuadPart -
                                         SystemInfoStart.IoReadTransferCount.QuadPart;
        t.IoReadTransferCount.QuadPart += (SystemInfoDone.PageReadCount -
                                           SystemInfoStart.PageReadCount) * BasicInfo.PageSize;
        t.IoReadTransferCount.QuadPart += (SystemInfoDone.CacheReadCount -
                                           SystemInfoStart.CacheReadCount) * BasicInfo.PageSize;

        t.IoWriteTransferCount.QuadPart = SystemInfoDone.IoWriteTransferCount.QuadPart -
                                          SystemInfoStart.IoWriteTransferCount.QuadPart;
        t.IoWriteTransferCount.QuadPart += (SystemInfoDone.DirtyPagesWriteCount -
                                            SystemInfoStart.DirtyPagesWriteCount) * BasicInfo.PageSize;
        t.IoWriteTransferCount.QuadPart += (SystemInfoDone.MappedPagesWriteCount -
                                            SystemInfoStart.MappedPagesWriteCount) * BasicInfo.PageSize;

        t.IoOtherTransferCount.QuadPart = SystemInfoDone.IoOtherTransferCount.QuadPart -
                                          SystemInfoStart.IoOtherTransferCount.QuadPart;

        t.Flags |= TIMEIT_RECORD_SYSTEMINFO;
        }

    UpdateDataBase( DataBaseFileName, &t, DisplayAverage ? &Averages : NULL );

    exit( t.ExitCode );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\pstat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pstat.c

Abstract:

    This module contains the Windows NT process/thread status display.

Author:

    Lou Perazzoli (LouP) 25-Oct-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

VOID
PrintLoadedDrivers(
    VOID
    );

ULONG CurrentBufferSize;

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "VirtualMemory",
    "PageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";

BOOLEAN fUserOnly = TRUE;
BOOLEAN fSystemOnly = TRUE;
BOOLEAN fVerbose = FALSE;
BOOLEAN fPrintIt;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PUCHAR LargeBuffer1;
    NTSTATUS status;
    NTSTATUS Status;
    ULONG i;
    ULONG TotalOffset = 0;
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;
    LARGE_INTEGER Time;
    LPSTR lpstrCmd;
    CHAR ch;
    ANSI_STRING pname;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    SetFileApisToOEM();
    lpstrCmd = GetCommandLine();
    if( lpstrCmd != NULL ) {
        CharToOem( lpstrCmd, lpstrCmd );
    }


    LargeBuffer1 = VirtualAlloc (NULL,
                                 MAX_BUFFER_SIZE,
                                 MEM_RESERVE,
                                 PAGE_READWRITE);
    if (LargeBuffer1 == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    if (VirtualAlloc (LargeBuffer1,
                      BUFFER_SIZE,
                      MEM_COMMIT,
                      PAGE_READWRITE) == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBufferSize = BUFFER_SIZE;

    do
        ch = *lpstrCmd++;
    while (ch != ' ' && ch != '\t' && ch != '\0');
    while (ch == ' ' || ch == '\t')
        ch = *lpstrCmd++;
    while (ch == '-') {
        ch = *lpstrCmd++;

        //  process multiple switch characters as needed

        do {
            switch (ch) {

                case 'U':
                case 'u':
                    fUserOnly = TRUE;
                    fSystemOnly = FALSE;
                    ch = *lpstrCmd++;
                    break;

                case 'S':
                case 's':
                    fUserOnly = FALSE;
                    fSystemOnly = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'V':
                case 'v':
                    fVerbose = TRUE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    printf("bad switch '%c'\n", ch);
                    ExitProcess(1);
                }
            }
        while (ch != ' ' && ch != '\t' && ch != '\0');

        //  skip over any following white space

        while (ch == ' ' || ch == '\t')
            ch = *lpstrCmd++;
        }


    status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(SYSTEM_BASIC_INFORMATION),
                NULL
                );

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
        }

    status = NtQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDayInfo,
                sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                NULL
                );

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
        }

    Time.QuadPart = TimeOfDayInfo.CurrentTime.QuadPart -
                                    TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields ( &Time, &UpTime);

    printf("Pstat version 0.3:  memory: %4ld kb  uptime:%3ld %2ld:%02ld:%02ld.%03ld \n\n",
                BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize/1024),
                UpTime.Day,
                UpTime.Hour,
                UpTime.Minute,
                UpTime.Second,
                UpTime.Milliseconds);

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)LargeBuffer1;
    status = NtQuerySystemInformation(
                SystemPageFileInformation,
                PageFileInfo,
                CurrentBufferSize,
                NULL
                );

    if (NT_SUCCESS(status)) {

        //
        // Print out the page file information.
        //

        if (PageFileInfo->TotalSize == 0) {
            printf("no page files in use\n");
        } else {
            for (; ; ) {
                printf("PageFile: %wZ\n", &PageFileInfo->PageFileName);
                printf("\tCurrent Size: %6ld kb  Total Used: %6ld kb   Peak Used %6ld kb\n",
                        PageFileInfo->TotalSize*(BasicInfo.PageSize/1024),
                        PageFileInfo->TotalInUse*(BasicInfo.PageSize/1024),
                        PageFileInfo->PeakUsage*(BasicInfo.PageSize/1024));
                if (PageFileInfo->NextEntryOffset == 0) {
                    break;
                }
                PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(
                          (PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
            }
        }
    }

retry:
    status = NtQuerySystemInformation(
                SystemProcessInformation,
                LargeBuffer1,
                CurrentBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (VirtualAlloc (LargeBuffer1,
                          CurrentBufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE) == NULL) {
            printf("Memory commit failed\n");
            return 0;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    while (TRUE) {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Query perf Failed %lx\n",Status);
        return 0;
    }

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Query file cache Failed %lx\n",Status);
        return 0;
    }

    NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
        );

    SumWorkingSet += FileCache.CurrentSize/1024;
    printf (
         "\n Memory:%7ldK Avail:%7ldK  TotalWs:%7ldK InRam Kernel:%5ldK P:%5ldK\n",
                              BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                              PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                              SumWorkingSet,
                              (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                              (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
                              );
    printf(
         " Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK\n",
                              PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                              SumCommit,
                              PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                              PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                              PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                              PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
                              );
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    printf("\n");


    printf("    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\n");

    printf("                           %6ld %8ld                         %s\n",
        FileCache.CurrentSize/1024,
        FileCache.PageFaultCount,
        "File Cache"
        );
    while (TRUE) {

        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            }

        RtlTimeToElapsedTimeFields ( &ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

        printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
            UserTime.Hour,
            UserTime.Minute,
            UserTime.Second,
            UserTime.Milliseconds,
            KernelTime.Hour,
            KernelTime.Minute,
            KernelTime.Second,
            KernelTime.Milliseconds
            );

        printf("%6ld %8ld %7ld",
            ProcessInfo->WorkingSetSize / 1024,
            ProcessInfo->PageFaultCount,
            ProcessInfo->PrivatePageCount / 1024
            );

        printf(" %2ld %4ld %3ld %3ld %s\n",
            ProcessInfo->BasePriority,
            ProcessInfo->HandleCount,
            ProcessInfo->NumberOfThreads,
            HandleToUlong(ProcessInfo->UniqueProcessId),
            ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
            ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
            );

        if ( pname.Buffer ) {
            RtlFreeAnsiString(&pname);
            }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }


    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    printf("\n");
    while (TRUE) {
        fPrintIt = FALSE;
        if ( (ProcessInfo->ImageName.Buffer && fUserOnly) ||
             (ProcessInfo->ImageName.Buffer==NULL && fSystemOnly) ) {

            fPrintIt = TRUE;

            pname.Buffer = NULL;
            if ( ProcessInfo->ImageName.Buffer ) {
                RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
                }
            printf("pid:%3lx pri:%2ld Hnd:%5ld Pf:%7ld Ws:%7ldK %s\n",
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->PageFaultCount,
                ProcessInfo->WorkingSetSize / 1024,
                ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                );

            if ( pname.Buffer ) {
                RtlFreeAnsiString(&pname);
                }

            }
        i = 0;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        if (ProcessInfo->NumberOfThreads) {
            printf(" tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\n");
            }
        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            if ( fPrintIt ) {

                printf(" %3lx  %2ld %9ld %p",
                    ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                    ThreadInfo->ContextSwitches,
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
                    );

                printf(" %2ld:%02ld:%02ld.%03ld %2ld:%02ld:%02ld.%03ld",
                    UserTime.Hour,
                    UserTime.Minute,
                    UserTime.Second,
                    UserTime.Milliseconds,
                    KernelTime.Hour,
                    KernelTime.Minute,
                    KernelTime.Second,
                    KernelTime.Milliseconds
                    );

                printf(" %s%s\n",
                    StateTable[ThreadInfo->ThreadState],
                    (ThreadInfo->ThreadState == 5) ?
                            WaitTable[ThreadInfo->WaitReason] : Empty
                    );
                }
            ThreadInfo += 1;
            i += 1;
            }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        if ( fPrintIt ) {
            printf("\n");
            }
        }

    PrintLoadedDrivers();

    return 0;
}


typedef struct _MODULE_DATA {
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE {
    PUCHAR MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
    PMODULE_DATA Sum,
    PMODULE_DATA Current
    )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}
VOID
PrintModuleSeperator(
    VOID
    )
{
    printf("------------------------------------------------------------------------------\n");
}

VOID
PrintModuleHeader(
    VOID
    )
{
    printf("  ModuleName Load Addr   Code    Data   Paged           LinkDate\n");
    PrintModuleSeperator();
}

VOID
PrintModuleLine(
    LPSTR ModuleName,
    PMODULE_DATA Current,
    PRTL_PROCESS_MODULE_INFORMATION Module
    )
{
    if ( Module ) {
        printf("%12s %p %7d %7d %7d %s",
            ModuleName,
            Module->ImageBase,
            Current->CodeSize,
            Current->DataSize,
            Current->PagedSize,
            Current->TimeDateStamp ? ctime((time_t *)&Current->TimeDateStamp) : "\n"
            );
        }
    else {
        printf("%12s          %7d %7d %7d\n",
            ModuleName,
            Current->CodeSize,
            Current->DataSize,
            Current->PagedSize
            );
        }
}

VOID
GetModuleData(
    HANDLE hFile,
    PMODULE_DATA Mod
    )
{
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int i;
    ULONG Size;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return;
        }

    LoadedImage.MappedAddress = MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) {
        return;
        }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
        }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
        }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for(Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!_strnicmp(Section->Name,"PAGE", 4 )) {
            Mod->PagedSize += Size;
            }
        else if (!_stricmp(Section->Name,"INIT" )) {
            Mod->InitSize += Size;
            }
        else if (!_stricmp(Section->Name,".bss" )) {
            Mod->BssSize = Size;
            }
        else if (!_stricmp(Section->Name,".edata" )) {
            Mod->ExportDataSize = Size;
            }
        else if (!_stricmp(Section->Name,".idata" )) {
            Mod->ImportDataSize = Size;
            }
        else if (!_stricmp(Section->Name,".rsrc" )) {
            Mod->ResourceDataSize = Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            Mod->CodeSize += Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
            Mod->DataSize += Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_READ) {
            Mod->RoDataSize += Size;
            }
        else {
            Mod->DataSize += Size;
            }
        }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}

VOID
PrintLoadedDrivers(
    VOID
    )
{

    ULONG i;
    PCHAR s;
    HANDLE FileHandle;
    CHAR KernelPath[MAX_PATH];
    CHAR DriversPath[MAX_PATH];
    PCHAR ModuleInfo;
    ULONG ModuleInfoLength;
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;

    printf("\n");
    //
    // Locate system drivers.
    //

    ModuleInfoLength = 64000;
    while (1) {
        ModuleInfo = malloc (ModuleInfoLength);
        if (ModuleInfo == NULL) {
            printf ("Failed to allocate memory for module information buffer of size %d\n",
                    ModuleInfoLength);
            return;
        }
        Status = NtQuerySystemInformation (
                        SystemModuleInformation,
                        ModuleInfo,
                        ModuleInfoLength,
                        &ReturnedLength);

        if (!NT_SUCCESS(Status)) {
            free (ModuleInfo);
            if (Status == STATUS_INFO_LENGTH_MISMATCH &&
                ReturnedLength > ModuleInfoLength) {
                ModuleInfoLength = ReturnedLength;
                continue;
            }
            printf("query system info failed status - %lx\n",Status);
            return;
        }
        break;
    }
    GetSystemDirectory(KernelPath,sizeof(KernelPath));
    strcpy(DriversPath,KernelPath);
    strcat(DriversPath,"\\Drivers");
    ZeroMemory(&Sum,sizeof(Sum));
    PrintModuleHeader();

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) {

        ZeroMemory(&Current,sizeof(Current));
        s = &Module->FullPathName[ Module->OffsetToFileName ];

        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);

        FileHandle = CreateFile(
                        s,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                            s,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );

            }

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
            }

        SumModuleData(&Sum,&Current);
        PrintModuleLine(s,&Current,Module);
        Module++;
        }
    PrintModuleSeperator();
    PrintModuleLine("Total",&Sum,NULL);
    free (ModuleInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pstat\svcnames.c ===
#include <nt.h>

#include "syssvc.h"
#include "w32svc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\acledit.c ===
/****************************************************************************

   PROGRAM: ACLEDIT.C

   PURPOSE: Contains routines that edit security on Nt objects

****************************************************************************/

#include "pviewp.h"
#include <sedapi.h>


//
// Define the type of a pointer to the DACL editor fn
//

typedef DWORD (*LPFNDACLEDITOR) (   HWND,
                                    HANDLE,
                                    LPWSTR,
                                    PSED_OBJECT_TYPE_DESCRIPTOR,
                                    PSED_APPLICATION_ACCESSES,
                                    LPWSTR,
                                    PSED_FUNC_APPLY_SEC_CALLBACK,
                                    ULONG_PTR,
                                    PSECURITY_DESCRIPTOR,
                                    BOOLEAN,
                                    BOOLEAN,    // CantWriteDacl
                                    LPDWORD,
                                    DWORD  );


//
// Declare globals used to reference dynamically loaded ACLEditor module
//

HMODULE hModAclEditor = NULL;
LPFNDACLEDITOR lpfnDaclEditor = NULL;






//
// Define security information for each type of object
//



//
// Define the maximum number of accesses per object type
//

#define MAX_ACCESSES    30


//
// Define structure to contain the security information for
// an object type
//

typedef struct _OBJECT_TYPE_SECURITY_INFO {
    LPWSTR  TypeName;
    SED_HELP_INFO HelpInfo ;
    SED_OBJECT_TYPE_DESCRIPTOR SedObjectTypeDescriptor;
    GENERIC_MAPPING GenericMapping;
    SED_APPLICATION_ACCESSES AppAccesses ;
    SED_APPLICATION_ACCESS AppAccess[MAX_ACCESSES];

} OBJECT_TYPE_SECURITY_INFO, *POBJECT_TYPE_SECURITY_INFO;


//
// Define name of help file
//

#define HELP_FILENAME   L"pview.hlp"



//
// Define dummy access (used as filler)
//

#define DUMMY_ACCESS                                                \
    {                                                               \
        0,                                                          \
        0,                                                          \
        0,                                                          \
        NULL                                                        \
    }



//
// Define generic accesses
//

#define GENERIC_ACCESSES_5(Type)                                    \
    {                                                               \
        Type,                                                       \
        GENERIC_ALL,                                                \
        0,                                                          \
        L"All Access"                                               \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_READ,                                               \
        0,                                                          \
        L"Read"                                                     \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_WRITE,                                              \
        0,                                                          \
        L"Write"                                                    \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_EXECUTE,                                            \
        0,                                                          \
        L"Execute"                                                  \
    },                                                              \
    {                                                               \
        Type,                                                       \
        0,                                                          \
        0,                                                          \
        L"None"                                                     \
    }


//
// Define generic accesses to be shown in special access dialog
//

#define SPECIAL_GENERIC_ACCESSES_4(Type)                            \
    {                                                               \
        Type,                                                       \
        GENERIC_ALL,                                                \
        0,                                                          \
        L"Generic All"                                              \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_READ,                                               \
        0,                                                          \
        L"Generic Read"                                             \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_WRITE,                                              \
        0,                                                          \
        L"Generic Write"                                            \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_EXECUTE,                                            \
        0,                                                          \
        L"Generic Execute"                                          \
    }


//
// Define standard accesses
//

#define STANDARD_ACCESSES_5(Type)                                   \
    {                                                               \
        Type,                                                       \
        DELETE,                                                     \
        0,                                                          \
        L"Delete"                                                   \
    },                                                              \
    {                                                               \
        Type,                                                       \
        READ_CONTROL,                                               \
        0,                                                          \
        L"Read Control"                                             \
    },                                                              \
    {                                                               \
        Type,                                                       \
        WRITE_DAC,                                                  \
        0,                                                          \
        L"Write DAC"                                                \
    },                                                              \
    {                                                               \
        Type,                                                       \
        WRITE_OWNER,                                                \
        0,                                                          \
        L"Write Owner"                                              \
    },                                                              \
    {                                                               \
        Type,                                                       \
        SYNCHRONIZE,                                                \
        0,                                                          \
        L"Synchronize"                                              \
    }




//
// Define security info for 'DEFAULT' ACLs found in tokens
//

OBJECT_TYPE_SECURITY_INFO DefaultSecurityInfo = {

    //
    // Type name
    //

    L"DEFAULT",

    //
    // Help info
    //

    {
        HELP_FILENAME,
        {0, 0, 0, 0, 0, 0, 0}
    },



    //
    // Acleditor object type descriptor
    //

    {
        SED_REVISION1,          // Revision
        FALSE,                  // Is container
        FALSE,                  // AllowNewObjectPermissions
        FALSE,                  // MapSpecificPermsToGeneric
        NULL,                   // Pointer to generic mapping
        NULL,                   // Pointer to generic mapping for new objects
        L"Default",             // Object type name
        NULL,                   // Pointer to help info
        NULL,                   // ApplyToSubContainerTitle
        NULL,                   // ApplyToObjectsTitle
        NULL,                   // ApplyToSubContainerConfirmation
        L"Special...",          // SpecialObjectAccessTitle
        NULL                    // SpecialNewObjectAccessTitle
    },



    //
    // Generic mapping
    //

    {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_ALL
    },


    //
    // Application access structure
    //

    {
        14,                 // Access count (must match list below)
        NULL,               // Pointer to accesses
        L"Read",            // Default new access
    },


    //
    // Application accesses
    //

    {
        GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
        STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),
        SPECIAL_GENERIC_ACCESSES_4(SED_DESC_TYPE_RESOURCE_SPECIAL),

        DUMMY_ACCESS, // 15
        DUMMY_ACCESS, // 16
        DUMMY_ACCESS, // 17
        DUMMY_ACCESS, // 18
        DUMMY_ACCESS, // 19
        DUMMY_ACCESS, // 20
        DUMMY_ACCESS, // 21
        DUMMY_ACCESS, // 22
        DUMMY_ACCESS, // 23
        DUMMY_ACCESS, // 24
        DUMMY_ACCESS, // 25
        DUMMY_ACCESS, // 26
        DUMMY_ACCESS, // 27
        DUMMY_ACCESS, // 28
        DUMMY_ACCESS, // 29
        DUMMY_ACCESS  // 30
    }
};





//
// Define security info for each type of object
//

OBJECT_TYPE_SECURITY_INFO ObjectTypeSecurityInfo[] = {

    //
    // PROCESS
    //

    {
        //
        // Type name
        //

        L"Process",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Process",             // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            PROCESS_QUERY_INFORMATION | STANDARD_RIGHTS_READ,
            PROCESS_SET_INFORMATION | STANDARD_RIGHTS_WRITE,
            STANDARD_RIGHTS_EXECUTE,
            PROCESS_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            21,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_TERMINATE,
                0,
                L"Terminate"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_CREATE_THREAD,
                0,
                L"Create thread"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_OPERATION,
                0,
                L"VM Operation"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_READ,
                0,
                L"VM Read"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_WRITE,
                0,
                L"VM Write"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_DUP_HANDLE,
                0,
                L"Duplicate handle"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_CREATE_PROCESS,
                0,
                L"Create process",
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_QUOTA,
                0,
                L"Set quota"
            },
            { // 19
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_INFORMATION,
                0,
                L"Set information"
            },
            { // 20
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_QUERY_INFORMATION,
                0,
                L"Query information"
            },
            { // 21
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_PORT,
                0,
                L"Set port"
            },

            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    },







    //
    // THREAD
    //

    {
        //
        // Type name
        //

        L"Thread",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Thread",              // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            THREAD_QUERY_INFORMATION | STANDARD_RIGHTS_READ,
            THREAD_SET_INFORMATION | STANDARD_RIGHTS_WRITE,
            STANDARD_RIGHTS_EXECUTE,
            THREAD_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            20,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_TERMINATE,
                0,
                L"Terminate"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SUSPEND_RESUME,
                0,
                L"Suspend/Resume"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_ALERT,
                0,
                L"Alert"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_GET_CONTEXT,
                0,
                L"Get context"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_CONTEXT,
                0,
                L"Set context"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_INFORMATION,
                0,
                L"Set information"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_QUERY_INFORMATION,
                0,
                L"Query information"
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_THREAD_TOKEN,
                0,
                L"Set token"
            },
            { // 19
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_IMPERSONATE,
                0,
                L"Impersonate"
            },
            { // 20
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_DIRECT_IMPERSONATION,
                0,
                L"Direct impersonation"
            },

            DUMMY_ACCESS, // 21
            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    },





    //
    // TOKEN
    //

    {
        //
        // Type name
        //

        L"Token",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Token",               // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            TOKEN_READ,
            TOKEN_WRITE,
            TOKEN_EXECUTE,
            TOKEN_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            18,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ASSIGN_PRIMARY,
                0,
                L"Assign primary"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_DUPLICATE,
                0,
                L"Duplicate"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_IMPERSONATE,
                0,
                L"Impersonate"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_QUERY,
                0,
                L"Query"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_QUERY_SOURCE,
                0,
                L"Query source"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_PRIVILEGES,
                0,
                L"Adjust Privileges"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_GROUPS,
                0,
                L"Adjust Groups"
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_DEFAULT,
                0,
                L"Adjust Default"
            },

            DUMMY_ACCESS, // 19
            DUMMY_ACCESS, // 20
            DUMMY_ACCESS, // 21
            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    }

};


/***************************************************************************\
* InitializeACLEditor
*
* Purpose : Initializes this module.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
InitializeAclEditor(
    VOID
    )
{
    //
    // Load the acleditor module and get the proc addresses we need
    //

    hModAclEditor = LoadLibrary(TEXT("acledit.dll"));
    if (hModAclEditor == NULL) {
        return(FALSE);
    }

    lpfnDaclEditor = (LPFNDACLEDITOR)GetProcAddress(hModAclEditor,
                            TEXT("SedDiscretionaryAclEditor"));
    if (lpfnDaclEditor == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************\
* FindObjectSecurityInfo
*
* Purpose : Searches for object type in our security info table and
*           returns pointer to security info if found.
*           Any pointers in the security info are initialized by this routine.
*
* Returns pointer to security info or NULL on failure
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

POBJECT_TYPE_SECURITY_INFO
FindObjectSecurityInfo(
    HANDLE  Object
    )
{
    NTSTATUS Status;
    POBJECT_TYPE_SECURITY_INFO SecurityInfo;
    POBJECT_TYPE_INFORMATION TypeInfo;
    ULONG Length;
    BOOL Found;
    ULONG i;

    //
    // Get the object type
    //

    Status = NtQueryObject(
                            Object,
                            ObjectTypeInformation,
                            NULL,
                            0,
                            &Length
                            );
    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        DbgPrint("NtQueryObject failed, status = 0x%lx\n", Status);
        return(NULL);
    }

    TypeInfo = Alloc(Length);
    if (TypeInfo == NULL) {
        DbgPrint("Failed to allocate %ld bytes for object type\n", Length);
        return(NULL);
    }


    Status = NtQueryObject(
                            Object,
                            ObjectTypeInformation,
                            TypeInfo,
                            Length,
                            NULL
                            );
    if (!NT_SUCCESS(Status)) {
        DbgPrint("NtQueryObject failed, status = 0x%lx\n", Status);
        Free(TypeInfo);
        return(NULL);
    }


    //
    // Search for the type in our array of security info
    //

    Found = FALSE;
    for ( i=0;
          i < (sizeof(ObjectTypeSecurityInfo) / sizeof(*ObjectTypeSecurityInfo));
          i++
          ) {

        UNICODE_STRING FoundType;

        SecurityInfo = &ObjectTypeSecurityInfo[i];

        RtlInitUnicodeString(&FoundType, SecurityInfo->TypeName);

        if (RtlEqualUnicodeString(&TypeInfo->TypeName, &FoundType, TRUE)) {
            Found = TRUE;
            break;
        }
    }

    Free(TypeInfo);

    return(Found ? SecurityInfo : NULL);
}




/***************************************************************************\
* EditObjectDacl
*
* Purpose : Displays and allows the user to edit the Dacl on an object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditObjectDacl(
    HWND Owner,
    LPWSTR ObjectName,
    HANDLE Object,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    POBJECT_TYPE_SECURITY_INFO SecurityInfo,
    PSED_FUNC_APPLY_SEC_CALLBACK SetSecurityCallback,
    DWORD *EditResult
    )
{
    DWORD Result;
    HANDLE Instance;

    //
    // Initialize the pointer fields in the security info structure
    //

    SecurityInfo->AppAccesses.AccessGroup = SecurityInfo->AppAccess;
    SecurityInfo->SedObjectTypeDescriptor.GenericMapping =
                                    &SecurityInfo->GenericMapping;
    SecurityInfo->SedObjectTypeDescriptor.GenericMappingNewObjects =
                                    &SecurityInfo->GenericMapping;
    SecurityInfo->SedObjectTypeDescriptor.HelpInfo =
                                    &SecurityInfo->HelpInfo;

    //
    // Get the application instance handle
    //

    Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);
    ASSERT(Instance != 0);


    //
    // Call the ACL editor, it will call our ApplyNtObjectSecurity function
    // to store any ACL changes in the token.
    //

    Result = (*lpfnDaclEditor)(
                        Owner,
                        Instance,
                        NULL,               // server
                        &SecurityInfo->SedObjectTypeDescriptor, // object type
                        &SecurityInfo->AppAccesses, // application accesses
                        ObjectName,
                        SetSecurityCallback, // Callback
                        (ULONG_PTR)Object,    // Context
                        SecurityDescriptor,
                        (BOOLEAN)(SecurityDescriptor == NULL), // Couldn't read DACL
                        FALSE, // CantWriteDacl
                        EditResult,
                        0
                        );

    if (Result != ERROR_SUCCESS) {
        DbgPrint("DAcleditor failed, error = %d\n", Result);
        SetLastError(Result);
    }

    return (Result == ERROR_SUCCESS);

}








/***************************************************************************\
* ApplyNtObjectSecurity
*
* Purpose : Called by ACL editor to set new security on an object
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplyNtObjectSecurity(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG_PTR   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE Object = (HANDLE)CallbackContext;
    NTSTATUS Status;

    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

    //
    // Set the new DACL on the object
    //

    Status = NtSetSecurityObject(Object,
                                 DACL_SECURITY_INFORMATION,
                                 SecDesc);
    if (NT_SUCCESS(Status)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    } else {
        DbgPrint("Failed to set new ACL on object, status = 0x%lx\n", Status);
        if (Status == STATUS_ACCESS_DENIED) {
            MessageBox(hwndParent,
                       "You do not have permission to set the permissions on this object",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        } else {
            MessageBox(hwndParent,
                       "Unable to set object security",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditNtObjectDacl
*
* Purpose : Displays and allows the user to edit the Dacl on an NT object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditNtObjectDacl(
    HWND Owner,
    LPWSTR ObjectName,
    HANDLE Object,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD *EditResult
    )
{
    BOOL Result;
    POBJECT_TYPE_SECURITY_INFO SecurityInfo;


    //
    // Lookup our security info for an object of this type
    //

    SecurityInfo = FindObjectSecurityInfo(Object);
    if (SecurityInfo == NULL) {
        MessageBox(Owner, "Unable to edit the security on an object of this type",
                                NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return(FALSE);
    }


    //
    // Edit the ACL. Our callback function will be called to change the
    // new permissions
    //

    Result = EditObjectDacl(
                        Owner,
                        ObjectName,
                        Object,
                        SecurityDescriptor,
                        SecurityInfo,
                        ApplyNtObjectSecurity,
                        EditResult
                        );
    return (Result);

}


/***************************************************************************\
* EditNtObjectSecurity
*
* Purpose : Displays and allows the user to edit the protection on an NT object
*
* Parameters:
*
*   hwndOwner - Owner window for dialog
*   Object - handle to NT object. Should have been opened for MAXIMUM_ALLOWED
*   Name - Name of object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditNtObjectSecurity(
    HWND    hwndOwner,
    HANDLE  Object,
    LPWSTR  ObjectName
    )
{
    NTSTATUS Status;
    BOOL Success = FALSE;
    DWORD EditResult;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG Length;

    //
    // If we don't have an address for the DACL editor, we can't do anything
    //

    if (lpfnDaclEditor == NULL) {
        DbgPrint("EditNtObjectSecurity - no ACL editor loaded\n");
        return(FALSE);
    }

    //
    // Read the existing security from the object
    //

    Status = NtQuerySecurityObject(Object,
                                   OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &Length);
    ASSERT(!NT_SUCCESS(Status));

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        DbgPrint("Failed to query object security, status = 0x%lx\n", Status);
    } else {

        SecurityDescriptor = Alloc(Length);
        if (SecurityDescriptor == NULL) {
            DbgPrint("Failed to allocate %ld bytes for object SD\n", Length);
            goto CleanupAndExit;
        }

        Status = NtQuerySecurityObject(Object,
                                       OWNER_SECURITY_INFORMATION |
                                       GROUP_SECURITY_INFORMATION |
                                       DACL_SECURITY_INFORMATION,
                                       SecurityDescriptor,
                                       Length,
                                       &Length);
        if (!NT_SUCCESS(Status)) {
            DbgPrint("Failed to query object security, status = 0x%lx\n", Status);
            goto CleanupAndExit;
        }

        ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));
    }

    //
    // Call the ACL editor, it will call our ApplyNtObjectSecurity function
    // to store any ACL changes in the object.
    //

    Success = EditNtObjectDacl(
                        hwndOwner,
                        ObjectName,
                        Object,
                        SecurityDescriptor,
                        &EditResult
                        );
    if (!Success) {
        DbgPrint("PVIEW: Failed to edit object DACL\n");
    }

CleanupAndExit:

    if (SecurityDescriptor != NULL) {
        Free(SecurityDescriptor);
    }

    return(Success);
}





/***************************************************************************\
* ApplyTokenDefaultDacl
*
* Purpose : Called by ACL editor to set new security on an object
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplyTokenDefaultDacl(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG_PTR   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE Token = (HANDLE)CallbackContext;
    TOKEN_DEFAULT_DACL DefaultDacl;
    NTSTATUS Status;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    Status = RtlGetDaclSecurityDescriptor (
                    SecDesc,
                    &DaclPresent,
                    &DefaultDacl.DefaultDacl,
                    &DaclDefaulted
                    );
    ASSERT(NT_SUCCESS(Status));

    ASSERT(DaclPresent);


    Status = NtSetInformationToken(
                 Token,                    // Handle
                 TokenDefaultDacl,         // TokenInformationClass
                 &DefaultDacl,             // TokenInformation
                 sizeof(DefaultDacl)       // TokenInformationLength
                 );
    if (NT_SUCCESS(Status)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    } else {
        DbgPrint("SetInformationToken failed, status = 0x%lx\n", Status);
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

        if (Status == STATUS_ACCESS_DENIED) {
            MessageBox(hwndParent,
                       "You do not have permission to set the default ACL in this token",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        } else {
            MessageBox(hwndParent,
                       "Unable to set default ACL in token",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditTokenDefaultAcl
*
* Purpose : Displays and allows the user to edit the default ACL in a token
*
* Parameters:
*
*   hwndOwner - Owner window for dialog
*   Object - handle to token - opened for TOKEN_QUERY access
*   Name - Name of token
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditTokenDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Token,
    LPWSTR  ObjectName
    )
{
    NTSTATUS Status;
    BOOL Result = FALSE;
    DWORD EditResult;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   InfoLength;

    //
    // If we don't have an address for the DACL editor, we can't do anything
    //

    if (lpfnDaclEditor == NULL) {
        DbgPrint("EditNtObjectSecurity - no ACL editor loaded\n");
        return(FALSE);
    }

    //
    // Read the default DACL from the token
    //

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenDefaultDacl,         // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        DefaultDacl = Alloc(InfoLength);
        if (DefaultDacl == NULL) {
            goto CleanupAndExit;
        }

        Status = NtQueryInformationToken(
                     Token,                    // Handle
                     TokenDefaultDacl,         // TokenInformationClass
                     DefaultDacl,              // TokenInformation
                     InfoLength,               // TokenInformationLength
                     &InfoLength               // ReturnLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("NtQueryInformationToken failed, status = 0x%lx\n", Status);
            goto CleanupAndExit;
        }


        //
        // Create a security descriptor
        //

        SecurityDescriptor = Alloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (SecurityDescriptor == NULL) {
            DbgPrint("Failed to allocate security descriptor\n");
            goto CleanupAndExit;
        }

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));


        //
        // Set the DACL on the security descriptor
        //

        Status = RtlSetDaclSecurityDescriptor(
                            SecurityDescriptor,
                            TRUE,   // DACL present
                            DefaultDacl->DefaultDacl,
                            FALSE   // DACL defaulted
                            );
        ASSERT(NT_SUCCESS(Status));

        ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));
    }



    //
    // Call the ACL editor, it will call our ApplyTokenDefaultAcl function
    // to store any default ACL changes in the token.
    //

    Result = EditObjectDacl(
                        hwndOwner,
                        ObjectName,
                        Token,
                        SecurityDescriptor,
                        &DefaultSecurityInfo,
                        ApplyTokenDefaultDacl,
                        &EditResult
                        );
    if (!Result) {
        DbgPrint("Failed to edit token default ACL\n");
    }

CleanupAndExit:

    if (SecurityDescriptor != NULL) {
        Free(SecurityDescriptor);
    }
    if (DefaultDacl != NULL) {
        Free(DefaultDacl);
    }

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\lsa.h ===
BOOL    LsaInit(VOID);
BOOL    LsaTerminate(VOID);
BOOL    SID2Name(PSID, LPSTR, USHORT);
BOOL    PRIV2Name(LUID, LPSTR, UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\explode.h ===
#define PXPLODEDLG                  200
#define PXPLODE_PROCESS_ID          202
#define PXPLODE_PRIORITY_NORMAL     207
#define PXPLODE_PRIORITY_HIGH       208
#define PXPLODE_PRIORITY_IDL        206
#define PXPLODE_IMAGENAME           209
#define PXPLODE_TOTALIMAGE_COMMIT   212
#define PXPLODE_IMAGE_NOACCESS      214
#define PXPLODE_IMAGE_READONLY      216
#define PXPLODE_IMAGE_WRITECOPY     218
#define PXPLODE_IMAGE_EXECUTE       222
#define PXPLODE_IMAGE_READWRITE     225
#define PXPLODE_TOTALMAPPED_COMMIT  223
#define PXPLODE_MAPPED_NOACCESS     226
#define PXPLODE_MAPPED_READONLY     228
#define PXPLODE_MAPPED_READWRITE    230
#define PXPLODE_MAPPED_WRITECOPY    232
#define PXPLODE_MAPPED_EXECUTE      234
#define PXPLODE_TOTALPRIVATE_COMMIT 236
#define PXPLODE_PRIVATE_NOACCESS    238
#define PXPLODE_PRIVATE_READONLY    240
#define PXPLODE_PRIVATE_READWRITE   242
#define PXPLODE_PRIVATE_WRITECOPY   244
#define PXPLODE_PRIVATE_EXECUTE     246
#define PXPLODE_KERNEL_TIME         253
#define PXPLODE_USER_TIME           254
#define PXPLODE_ELAPSED_TIME        255
#define PXPLODE_READ_XFER           276
#define PXPLODE_WRITE_XFER          278
#define PXPLODE_OTHER_XFER          280
#define PXPLODE_READ_OPS            282
#define PXPLODE_WRITE_OPS           284
#define PXPLODE_OTHER_OPS           286
#define PXPLODE_PEAK_VSIZE          289
#define PXPLODE_VSIZE               291
#define PXPLODE_PFCOUNT             293
#define PXPLODE_PEAK_WS             295
#define PXPLODE_WS                  297
#define PXPLODE_PEAK_PF             299
#define PXPLODE_PF                  301
#define PXPLODE_PRIVATE_PAGE        303
#define PXPLODE_PEAK_PAGED          305
#define PXPLODE_PAGED               307
#define PXPLODE_PEAK_NONPAGED       309
#define PXPLODE_NONPAGED            311
#define PXPLODE_TERMINATE           312
#define PXPLODE_EXIT                314
#define PXPLODE_THREAD_LIST         315
#define PXPLODE_THREADELAPSED_TIME  321
#define PXPLODE_THREADKERNEL_TIME   322
#define PXPLODE_THREADUSER_TIME     323
#define PXPLODE_THREAD_HIGHEST      325
#define PXPLODE_THREAD_ABOVE        326
#define PXPLODE_THREAD_NORMAL       327
#define PXPLODE_THREAD_BELOW        328
#define PXPLODE_THREAD_LOWEST       329
#define PXPLODE_THREAD_DYNAMIC      331
#define PXPLODE_THREAD_SWITCHES     317
#define PXPLODE_PROCESS_LIST        257
#define PXPLODE_REFRESH             258
#define PXPLODE_REFRESH_TIME        260
#define PXPLODE_PROCESS_OBJECT      263
#define PXPLODE_THREAD_OBJECT       0x010A
#define PXPLODE_EVENT_OBJECT        0x010C
#define PXPLODE_SEMAPHORE_OBJECT    0x010E
#define PXPLODE_MUTEX_OBJECT        0x0110
#define PXPLODE_SECTION_OBJECT      0x0144
#define PXPLODE_HIDE                252
#define PXPLODE_IMAGE_COMMIT        211
#define PXPLODE_THREAD_COUNT        262
#define PXPLODE_SHOWHEAPS           264
#define PXPLODE_DUMPTOFILE          267
#define PXPLODE_THREAD_START        269
#define PXPLODE_POOLED_LIMITS       273
#define PXPLODE_QPGPEAK             277
#define PXPLODE_QPGCUR              281
#define PXPLODE_QPGLIM              285
#define PXPLODE_QNONPEAK            332
#define PXPLODE_QNONCUR             334
#define PXPLODE_QNONLIM             336
#define PXPLODE_QPFPEAK             338
#define PXPLODE_QPFCUR              340
#define PXPLODE_QPFLIM              342
#define PXPLODE_THREAD_PC           343
#define PXPLODE_PROCESS_ACL         347
#define PXPLODE_THREAD_ACL          348
#define PXPLODE_PROCESS_TOKEN       346
#define PXPLODE_THREAD_TOKEN        349
#define PXPLODE_PROCESS_TOKEN_ACL   350
#define PXPLODE_THREAD_TOKEN_ACL    351


#define IDD_MAIN                    1100
#define IDS_USERID                  1102
#define IDS_LOGONSESSION            1104
#define IDC_DEFAULTOWNER            1106
#define IDL_DISABLEDGROUPS          1111
#define IDB_DISABLEPRIVILEGE        1112
#define IDB_ENABLEPRIVILEGE         1113
#define IDL_ENABLEDPRIVILEGES       1117
#define IDL_DISABLEDPRIVILEGES      1118
#define IDL_ENABLEDGROUPS           1123
#define IDB_DISABLEGROUP            1124
#define IDB_ENABLEGROUP             1125
#define IDC_PRIMARYGROUP            1126
#define IDB_MORE                    1110
#define IDS_TOKENID                 1208
#define IDS_EXPIRATIONTIME          1209
#define IDS_TOKENTYPE               1210
#define IDS_IMPERSONATION           1211
#define IDS_DYNAMICCHARGED          1212
#define IDS_DYNAMICAVAILABLE        1213
#define IDS_MODIFIEDID              1214
#define IDS_RESTRICTEDSIDS          1215
#define IDD_MORE                    1101
#define IDB_DEFAULT_DACL            1108

#define PXPLODE_SECURITY_GROUP      345
#define PXPLODE_TOKEN_GROUP         467
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "pviewp.h"
#include <ntlsa.h>
#include <string.h>


// Module global that holds handle to LSA once it has been opened.
static LSA_HANDLE  LsaHandle = NULL;

LSA_HANDLE OpenLsa(VOID);
VOID    CloseLsa(LSA_HANDLE);


/****************************************************************************

   FUNCTION: LsaInit

   PURPOSE:  Does any initialization required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaInit(VOID)
{

    LsaHandle = OpenLsa();

    return (LsaHandle != NULL);

    return (TRUE);
}


/****************************************************************************

   FUNCTION: LsaTerminate

   PURPOSE:  Does any cleanup required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaTerminate(VOID)
{

    if (LsaHandle != NULL) {
        CloseLsa(LsaHandle);
    }

    LsaHandle = NULL;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenLsa

   PURPOSE:  Opens the Lsa
             Returns handle to Lsa or NULL on failure

****************************************************************************/
LSA_HANDLE OpenLsa(VOID)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ConnectHandle = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open a handle to the LSA.  Specifying NULL for the Server means that the
    // server is the same as the client.
    //

    Status = LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &ConnectHandle
                        );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Open failed 0x%lx\n", Status);
        return NULL;
    }

    return(ConnectHandle);
}


/****************************************************************************

    FUNCTION: CloseLsa

    PURPOSE:  Closes the Lsa

****************************************************************************/
VOID CloseLsa(
    LSA_HANDLE LsaHandle)
{
    NTSTATUS Status;

    Status = LsaClose(LsaHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Close failed 0x%lx\n", Status);
    }

    return;
}


/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    USHORT  MaxStringBytes)
{
    NTSTATUS    Status;
    ANSI_STRING    AnsiName;
    PLSA_REFERENCED_DOMAIN_LIST DomainList;
    PLSA_TRANSLATED_NAME NameList;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }



    Status = LsaLookupSids(LsaHandle, 1, &Sid, &DomainList, &NameList);

    if (NT_SUCCESS(Status)) {

        // Convert to ansi string
        RtlUnicodeStringToAnsiString(&AnsiName, &NameList->Name, TRUE);

        // Free up the returned data
        LsaFreeMemory((PVOID)DomainList);
        LsaFreeMemory((PVOID)NameList);

        // Copy the ansi string into our local variable
        strncpy(String, AnsiName.Buffer, MaxStringBytes);

        // Free up the ansi string
        RtlFreeAnsiString(&AnsiName);

    } else {

        UNICODE_STRING UnicodeName;

        if (NT_SUCCESS(RtlConvertSidToUnicodeString(&UnicodeName, Sid, TRUE))) {
            DbgPrint("LsaLookupSids failed for sid <%wZ>, error = 0x%lx\n", &UnicodeName, Status);

            AnsiName.Buffer = String;
            AnsiName.MaximumLength = MaxStringBytes;
            RtlUnicodeStringToAnsiString(&AnsiName, &UnicodeName, FALSE);

            RtlFreeUnicodeString(&UnicodeName);
        } else {
            DbgPrint("LsaLookupSids failed, error = 0x%lx\n", Status);
            return(FALSE);
        }

    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: PRIV2Name

   PURPOSE: Converts a PRIVILEGE into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL PRIV2Name(
    LUID    Privilege,
    LPSTR   lpstr,
    UINT    MaxStringBytes)
{
    NTSTATUS        Status;
    STRING          String;
    PUNICODE_STRING UString;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }

    Status = LsaLookupPrivilegeName(LsaHandle, &Privilege, &UString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: LsaLookupPrivilegeName failed, status = 0x%lx\n", Status);
        strcpy(lpstr, "<Unknown>");
    } else {

        //
        // Convert it to ANSI - because that's what the rest of the app is.
        //

        if (UString->Length > (USHORT)MaxStringBytes) {
            DbgPrint("SECEDIT: Truncating returned privilege name: *%S*\n", UString);
            UString->Length = (USHORT)MaxStringBytes;
            DbgPrint("                                         To: *%S*\n", UString);
        }

        String.Length = 0;
        String.MaximumLength = (USHORT)MaxStringBytes;
        String.Buffer = lpstr;
        Status = RtlUnicodeStringToAnsiString( &String, UString, FALSE );
        ASSERT(NT_SUCCESS(Status));
        LsaFreeMemory( UString );

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\mytoken.h ===
typedef struct {
    HANDLE                  Token;
    LPWSTR                  Name;

    PTOKEN_USER             UserId;
    PTOKEN_GROUPS           Groups;
    PTOKEN_OWNER            DefaultOwner;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup;
    PTOKEN_PRIVILEGES       Privileges;
    PTOKEN_STATISTICS       TokenStats;
    PTOKEN_GROUPS           RestrictedSids ;

} MYTOKEN;
typedef MYTOKEN *PMYTOKEN;

HANDLE  OpenMyToken(HANDLE, LPWSTR);
BOOL    CloseMyToken(HWND, HANDLE, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\makefile.inc ===
pviewrc.rc: explode.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\pviewp.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <explode.h>

/*--------------------------------------------------------------------------*/
/*                                                                                  */
/*  Function Templates                                                            */
/*                                                                                  */
/*--------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------*/
/*                                                                                  */
/*  Defines                                                                        */
/*                                                                                  */
/*--------------------------------------------------------------------------*/

BOOL
ComputeVaSpace(
    HWND hDlg,
    HANDLE hProcess
    );

VOID
UpdateImageCommit(
    HWND hDlg
    );

#define LBS_MYSTYLE     (LBS_NOTIFY | LBS_OWNERDRAWFIXED | WS_VSCROLL)

#define SHOVEIT(x)      (MAKELONG((x),0))

#define MAXTASKNAMELEN      40

#define PROCESSVIEWDLG      10


// Define the maximum length of a string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        ((MAX_STRING_LENGTH + 1) * sizeof(TCHAR))

#ifndef RC_INVOKED
#include "lsa.h"
#include "util.h"
#include "mytoken.h"
#include "acledit.h"
#include "tokedit.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\mytoken.c ===
/****************************************************************************

   PROGRAM: MYTOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "PVIEWP.h"

typedef PVOID   *PPVOID;


HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess);

BOOL CloseToken(
    HANDLE  Token);

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer);

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer);

BOOL FreeTokenInfo(
    PVOID   Buffer);

HANDLE  AllocMyToken(VOID);
BOOL    ReadMyToken(HANDLE);
BOOL    WriteMyToken(HWND, HANDLE);
BOOL    FreeMyToken(HANDLE);
PVOID   AllocTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS);


/****************************************************************************

   FUNCTION: OpenMyToken

   PURPOSE: Opens the token of the specified process or thread.

   RETURNS : Handle to mytoken on success, or NULL on failure.

****************************************************************************/

HANDLE OpenMyToken(
    HANDLE  Token,
    LPWSTR  Name
    )
{
    PMYTOKEN    pMyToken;
    HANDLE      hMyToken;

    //
    // Build a MYTOKEN structure.

    hMyToken = AllocMyToken();
    if (hMyToken == NULL) {
        return(NULL);
    }

    pMyToken = (PMYTOKEN)hMyToken;

    pMyToken->Token = Token;

    pMyToken->Name = Alloc((lstrlenW(Name) + 1) * sizeof(WCHAR));
    if (pMyToken->Name == NULL) {
        Free(pMyToken);
        return(NULL);
    }
    lstrcpyW(pMyToken->Name, Name);


    if (!ReadMyToken(hMyToken)) {
        DbgPrint("PVIEW : Failed to read token info\n");
        Free(pMyToken->Name);
        Free(pMyToken);
        return(NULL);
    }

    return(hMyToken);
}


/****************************************************************************

   FUNCTION: ReadMyToken

   PURPOSE: Reads the token info and stores in mytoken structure

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/

BOOL ReadMyToken(
    HANDLE  hMyToken)
{
    HANDLE      Token;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    Token = OpenToken(hMyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("PVIEW : Failed to open the token with TOKEN_QUERY access\n");
        return(FALSE);
    }

    if (!GetTokenInfo(Token, TokenStatistics, (PPVOID)&(pMyToken->TokenStats))) {
        DbgPrint("PVIEW : Failed to read token statistics from token\n");
    }

    if (!GetTokenInfo(Token, TokenGroups, (PPVOID)&(pMyToken->Groups))) {
        DbgPrint("PVIEW : Failed to read group info from token\n");
    }

    if (!GetTokenInfo(Token, TokenUser, (PPVOID)&(pMyToken->UserId))) {
        DbgPrint("PVIEW : Failed to read userid from token\n");
    }

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&(pMyToken->DefaultOwner))) {
        DbgPrint("PVIEW : Failed to read default owner from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&(pMyToken->PrimaryGroup))) {
        DbgPrint("PVIEW : Failed to read primary group from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrivileges, (PPVOID)&(pMyToken->Privileges))) {
        DbgPrint("PVIEW : Failed to read privilege info from token\n");
    }

    if ( !GetTokenInfo( Token, TokenRestrictedSids, (PPVOID) &(pMyToken->RestrictedSids) ) )
    {
        pMyToken->RestrictedSids = NULL ;
    }


    CloseToken(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: CloseMyToken

   PURPOSE: Closes the specified mytoken handle
            If fSaveChanges = TRUE, the token information is saved,
            otherwise it is discarded.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseMyToken(
    HWND    hDlg,
    HANDLE  hMyToken,
    BOOL    fSaveChanges)
{
    if (fSaveChanges) {
        WriteMyToken(hDlg, hMyToken);
    }

    return FreeMyToken(hMyToken);
}

/****************************************************************************

   FUNCTION: AllocMyToken

   PURPOSE: Allocates space for mytoken structure.

   RETURNS : HANDLE to mytoken or NULL on failure.

****************************************************************************/

HANDLE AllocMyToken(VOID)
{
    PMYTOKEN    pMyToken;

    pMyToken = (PMYTOKEN)Alloc(sizeof(MYTOKEN));

    return((HANDLE)pMyToken);
}


/****************************************************************************

   FUNCTION: FreeMyToken

   PURPOSE: Frees the memory allocated to mytoken structure.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL FreeMyToken(
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    if (pMyToken->TokenStats != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->TokenStats));
    }

    if (pMyToken->UserId != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->UserId));
    }

    if (pMyToken->PrimaryGroup != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->PrimaryGroup));
    }

    if (pMyToken->DefaultOwner != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->DefaultOwner));
    }

    if (pMyToken->Groups != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Groups));
    }

    if (pMyToken->Privileges != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Privileges));
    }

    if (pMyToken->Name != NULL) {
        Free((PVOID)pMyToken->Name);
    }

    Free((PVOID)pMyToken);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: WriteMyToken

   PURPOSE: Writes the token information out to the token

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL WriteMyToken(
    HWND    hDlg,
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    HANDLE      Token;

    //
    // Save default owner and primary group
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_DEFAULT access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change default owner or primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        // Set default owner
        //
        if ((pMyToken->DefaultOwner != NULL) &&
           (!SetTokenInfo(Token, TokenOwner, (PVOID)(pMyToken->DefaultOwner)))) {
            MessageBox(hDlg, "Failed to set default owner", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        // Set primary group
        //
        if ((pMyToken->PrimaryGroup != NULL) &&
           (!SetTokenInfo(Token, TokenPrimaryGroup, (PVOID)(pMyToken->PrimaryGroup)))) {
            MessageBox(hDlg, "Failed to set primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    //
    // Save group info
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_GROUPS);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_GROUPS access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Groups != NULL) &&
           (!SetTokenInfo(Token, TokenGroups, (PVOID)(pMyToken->Groups)))) {
            MessageBox(hDlg, "Failed to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }


    //
    // Change privileges
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_PRIVILEGES);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_PRIVILEGES access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Privileges != NULL) &&
           (!SetTokenInfo(Token, TokenPrivileges, (PVOID)(pMyToken->Privileges)))) {
            MessageBox(hDlg, "Failed to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenToken

   PURPOSE: Opens the token with the specified access

   RETURNS : Handle to token on success, or NULL on failure.

****************************************************************************/

HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    return(pMyToken->Token);
}


/****************************************************************************

   FUNCTION: CloseToken

   PURPOSE: Closes the specified token handle

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseToken(
    HANDLE  Token)
{
    return(TRUE);
}


/****************************************************************************

   FUNCTION: AllocTokenInfo

   PURPOSE: Allocates memory to hold the parameter that
            NTQueryInformationToken will return.
            Memory should be freed later using FreeTokenInfo

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID AllocTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass)
{
    NTSTATUS Status;
    ULONG   InfoLength;

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        DbgPrint("PVIEW: NtQueryInformationToken did NOT return buffer_too_small, status = 0x%lx\n", Status);
        return(NULL);
    }

    return Alloc(InfoLength);
}


/****************************************************************************

   FUNCTION: FreeTokenInfo

   PURPOSE: Frees the memory previously allocated with AllocTokenInfo

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL FreeTokenInfo(
    PVOID   Buffer)
{
    return(Free(Buffer));
}


/****************************************************************************

   FUNCTION: GetTokenInfo

   PURPOSE: Allocates a buffer and reads the specified data
            out of the token and into it.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;
    ULONG   InfoLength;
    PVOID   Buffer;

    *pBuffer = NULL;    // Prepare for failure

    Buffer = AllocTokenInfo(Token, TokenInformationClass);
    if (Buffer == NULL) {
        return(FALSE);
    }

    BufferSize = GetAllocSize(Buffer);

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 Buffer,                   // TokenInformation
                 BufferSize,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("PVIEW: NtQueryInformationToken failed, status = 0x%lx\n", Status);
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    if (InfoLength > BufferSize) {
        DbgPrint("PVIEW: NtQueryInformationToken failed, DataSize > BufferSize");
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    *pBuffer = Buffer;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: SetTokenInfo

   PURPOSE: Sets the specified information in the given token.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;

    BufferSize = GetAllocSize(Buffer);

    switch (TokenInformationClass) {

    case TokenOwner:
    case TokenPrimaryGroup:
    case TokenDefaultDacl:

        Status = NtSetInformationToken(
                     Token,                    // Handle
                     TokenInformationClass,    // TokenInformationClass
                     Buffer,                   // TokenInformation
                     BufferSize                // TokenInformationLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtSetInformationToken failed, info class = 0x%x, status = 0x%lx\n",
                                TokenInformationClass, Status);
            return(FALSE);
        }
        break;


    case TokenGroups:

        Status = NtAdjustGroupsToken(
                    Token,                      // Handle
                    FALSE,                      // Reset to default
                    (PTOKEN_GROUPS)Buffer,      // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtAdjustGroupsToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    case TokenPrivileges:

        Status = NtAdjustPrivilegesToken(
                    Token,                      // Handle
                    FALSE,                      // Disable all privileges
                    (PTOKEN_PRIVILEGES)Buffer,  // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtAdjustPrivilegesToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    default:

        // Unrecognised information type
        DbgPrint("PVIEW: SetTokenInfo passed unrecognised infoclass, class = 0x%x\n", TokenInformationClass);

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\pview.c ===
#include "pviewp.h"
#include <port1632.h>
#include <string.h>
#include <stdlib.h>

ULONG PageSize = 4096;

#ifdef DBG
#define ODS OutputDebugString
#else
#define ODS
#endif

#define BUFSIZE 64*1024

INT_PTR CALLBACK
ExplodeDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
SetProcessFields(
    PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    HWND hwnd
    );

VOID
SetThreadFields(
    PSYSTEM_THREAD_INFORMATION ThreadInfo,
    HWND hwnd
    );

VOID
InitProcessList(HWND hwnd);

int MyX = 0;
int MyY = 0;
int dxSuperTaskman;
int dySuperTaskman;
int dxScreen;
int dyScreen;
PSYSTEM_PROCESS_INFORMATION DlgProcessInfo;
BOOL Refresh = TRUE;

PUCHAR g_pLargeBuffer; // UCHAR LargeBuffer1[64*1024];
DWORD g_dwBufSize;

SYSTEM_TIMEOFDAY_INFORMATION RefreshTimeOfDayInfo;
HANDLE hEvent;
HANDLE hMutex;
HANDLE hSemaphore;
HANDLE hSection;

CHAR LastProcess[256];
CHAR LastThread[256];
CHAR LastModule[256];
CHAR Buffer[512];


INT_PTR CALLBACK
ExplodeDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int nIndex;
    HWND ThreadList;
    HWND ProcessList;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    HANDLE hProcess;

    switch (wMsg) {

    case WM_INITDIALOG:

        g_dwBufSize = BUFSIZE;

        g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

        if( g_pLargeBuffer == NULL )
        {
            EndDialog(hwnd, 0);
            return FALSE;
        }

        if (!RegisterHotKey(hwnd, 1, MOD_CONTROL | MOD_ALT, VK_ESCAPE) ) {
            EndDialog(hwnd, 0);
            return(FALSE);
        }

        ProcessInfo = NULL;
        DlgProcessInfo = ProcessInfo;
        wParam = 1;

        //
        // Tidy up the system menu
        //

        DeleteMenu(GetSystemMenu(hwnd, FALSE), SC_MAXIMIZE, MF_BYCOMMAND);
        DeleteMenu(GetSystemMenu(hwnd, FALSE), SC_SIZE, MF_BYCOMMAND);

        //
        // Hide acleditting controls if we can't handle them
        //

        if (!InitializeAclEditor()) {

            DbgPrint("PVIEW: Acl editor failed to initialize, ACL editting disabled\n");

            ShowWindow(GetDlgItem(hwnd, PXPLODE_SECURITY_GROUP), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN_ACL), SW_HIDE);

            ShowWindow(GetDlgItem(hwnd, PXPLODE_TOKEN_GROUP), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN), SW_HIDE);
        }

        //
        // fall thru
        //

    case WM_HOTKEY:

        if ( wParam == 1 ) {
            PSYSTEM_PROCESS_INFORMATION ProcessInfo;
            NTSTATUS status;
            ULONG TotalOffset = 0;

            do
            {
                // re-read systemprocess info until we get the entire buffer ( if possible )

                status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            ( PVOID )g_pLargeBuffer, // LargeBuffer1,
                            g_dwBufSize, //sizeof(LargeBuffer1),
                            NULL
                            );

                if( status != STATUS_INFO_LENGTH_MISMATCH )
                {
                    break;
                }

                ODS( "OnHotKey resizing g_pLargeBuffer\n" );

                g_dwBufSize *= 2;

                if( g_pLargeBuffer != NULL )
                {
                    free( g_pLargeBuffer );
                }

                g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

                if( g_pLargeBuffer == NULL )
                {
                    ODS( "Failed to re allocate mem in OnHotKey\n" );                    

                    EndDialog( hwnd , 0 );

                    return FALSE;
                }


            }while( 1 );
                
            if (!NT_SUCCESS(status)) {
                EndDialog(hwnd, 0);
                return(FALSE);
                }

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
            DlgProcessInfo = ProcessInfo;
            Refresh = TRUE;
            InitProcessList(hwnd);
            Refresh = FALSE;

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                        ProcessList,
                                                        CB_GETITEMDATA,
                                                        nIndex,
                                                        0
                                                        );
            if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                }
            DlgProcessInfo = ProcessInfo;
            SetProcessFields(ProcessInfo,hwnd);

            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_NORMAL);
            }
        return FALSE;

    case WM_SYSCOMMAND:
        switch (wParam & 0xfff0) {
        case SC_CLOSE:
            EndDialog(hwnd, 0);
            return(TRUE);
        }
        return(FALSE);

    case WM_COMMAND:
        switch(LOWORD(wParam)) {

        case PXPLODE_THREAD_LIST:
            switch ( HIWORD(wParam) ) {
            case LBN_DBLCLK:
            case LBN_SELCHANGE:
                ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);
                nIndex = (int)SendMessage(ThreadList, LB_GETCURSEL, 0, 0);
                ThreadInfo = (PSYSTEM_THREAD_INFORMATION)SendMessage(
                                                            ThreadList,
                                                            LB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ThreadInfo || LB_ERR == (LONG_PTR)ThreadInfo ) {
                    break;
                    }

                SetThreadFields(ThreadInfo,hwnd);
                break;
            }
            break;

        case PXPLODE_IMAGE_COMMIT:
            switch ( HIWORD(wParam) ) {
            case CBN_DBLCLK:
            case CBN_SELCHANGE:
                UpdateImageCommit(hwnd);
                break;
            }
            break;

        case PXPLODE_PROCESS_LIST:

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            switch ( HIWORD(wParam) ) {
            case CBN_DBLCLK:
            case CBN_SELCHANGE:
                nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
                SendMessage(ProcessList, CB_GETLBTEXT, nIndex, (LPARAM)LastProcess);
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                    break;
                    }

                DlgProcessInfo = ProcessInfo;
                SetProcessFields(ProcessInfo,hwnd);
                break;
            }
            break;

        case PXPLODE_EXIT:
            EndDialog(hwnd, 0);
            break;

        case PXPLODE_PRIORITY_NORMAL:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,NORMAL_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_PRIORITY_HIGH:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,HIGH_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_PRIORITY_IDL:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,IDLE_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_HIDE:
            ShowWindow(hwnd,SW_HIDE);
            break;

        case PXPLODE_SHOWHEAPS:
        case PXPLODE_DUMPTOFILE:
            MessageBox(hwnd,"This function not implemented yet","Not Implemented",MB_ICONSTOP|MB_OK);
            break;

        case PXPLODE_PROCESS_ACL:
        case PXPLODE_PROCESS_TOKEN_ACL:
        case PXPLODE_PROCESS_TOKEN:
        {
            WCHAR Name[100];
            HANDLE Process;
            HANDLE Token;

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
            if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                break;
                }

            SendMessageW(ProcessList, CB_GETLBTEXT, nIndex, (LPARAM)Name);

            switch(LOWORD(wParam)) {
            case PXPLODE_PROCESS_ACL:

                Process = OpenProcess(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
                if (Process != NULL) {
                    EditNtObjectSecurity(hwnd, Process, Name);
                    CloseHandle(Process);
                } else {
                    DbgPrint("Failed to open process for max allowed, error = %d\n", GetLastError());
                }
                break;

            default:

                Process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
                if (Process != NULL) {

                    if (OpenProcessToken(Process, MAXIMUM_ALLOWED, &Token)) {
                        if (LOWORD(wParam) == PXPLODE_PROCESS_TOKEN_ACL) {
                            EditNtObjectSecurity(hwnd, Token, Name);
                        } else {
                            HANDLE Token2;
                            if (OpenProcessToken(Process, TOKEN_QUERY, &Token2)) {
                                CloseHandle(Token2);
                                EditToken(hwnd, Token, Name);
                            } else {
                                MessageBox(hwnd,
                                   "You do not have permission to view the token on this process",
                                   "Access Denied", MB_ICONSTOP | MB_OK);
                            }
                        }
                        CloseHandle(Token);
                    } else {
                        MessageBox(hwnd,
                           "You do not have permission to access the token on this process",
                           "Access Denied", MB_ICONSTOP | MB_OK);
                    }
                    CloseHandle(Process);
                } else {
                    DbgPrint("Failed to open process for query information, error = %d\n", GetLastError());
                }
                break;
            }


            break;
        }

        case PXPLODE_THREAD_ACL:
        case PXPLODE_THREAD_TOKEN_ACL:
        case PXPLODE_THREAD_TOKEN:
        {
            WCHAR Name[100];
            HANDLE Thread;
            HANDLE Token;

            ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);
            nIndex = (int)SendMessage(ThreadList, LB_GETCURSEL, 0, 0);
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)SendMessage(
                                                        ThreadList,
                                                        LB_GETITEMDATA,
                                                        nIndex,
                                                        0
                                                        );
            if ( !ThreadInfo || LB_ERR == (LONG_PTR)ThreadInfo ) {
                break;
                }

            SendMessageW(ThreadList, LB_GETTEXT, nIndex, (LPARAM)Name);

            switch(LOWORD(wParam)) {
            case PXPLODE_THREAD_ACL:

                Thread = OpenThread(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
                if (Thread != NULL) {
                    EditNtObjectSecurity(hwnd, Thread, Name);
                    CloseHandle(Thread);
                } else {
                    DbgPrint("Failed to open thread for max allowed, error = %d\n", GetLastError());
                }
                break;

            default:

                Thread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
                if (Thread != NULL) {
                    if (OpenThreadToken(Thread, MAXIMUM_ALLOWED, TRUE, &Token)) {
                        if (LOWORD(wParam) == PXPLODE_THREAD_TOKEN_ACL) {
                            EditNtObjectSecurity(hwnd, Token, Name);
                        } else {
                            HANDLE Token2;
                            if (OpenThreadToken(Thread, TOKEN_QUERY, TRUE, &Token2)) {
                                CloseHandle(Token2);
                                EditToken(hwnd, Token, Name);
                            } else {
                                MessageBox(hwnd,
                                   "You do not have permission to view the token on this thread",
                                   "Access Denied", MB_ICONSTOP | MB_OK);
                            }
                        }
                        CloseHandle(Token);
                    } else {
                        DbgPrint("Failed to open thread token for max allowed, error = %d\n", GetLastError());
                    }
                    CloseHandle(Thread);
                } else {
                    DbgPrint("Failed to open thread for query information, error = %d\n", GetLastError());
                }
                break;
            }
            break;
        }

        case PXPLODE_TERMINATE:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            wsprintf(Buffer,"Selecting OK will terminate %s... Do you really want to do this ?",LastProcess);
            if ( MessageBox(hwnd,Buffer,"Terminate Process",MB_ICONSTOP|MB_OKCANCEL) == IDOK ) {
                TerminateProcess(hProcess,99);
                }
            CloseHandle(hProcess);

            //
            // fall thru
            //

        case PXPLODE_REFRESH:
refresh:
            {
                PSYSTEM_PROCESS_INFORMATION ProcessInfo;
                NTSTATUS status;
                ULONG TotalOffset = 0;

                ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);

                do
                {
                    status = NtQuerySystemInformation(
                                SystemProcessInformation,
                                ( PVOID )g_pLargeBuffer,
                                g_dwBufSize,
                                NULL
                                );

                    if( status != STATUS_INFO_LENGTH_MISMATCH )
                    {
                        break;
                    }                    

                    if( g_pLargeBuffer != NULL )
                    {
                        free( g_pLargeBuffer );
                    }

                    g_dwBufSize *= 2;

                    g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

                    if( g_pLargeBuffer == NULL )
                    {
                        ODS( "Failed to re allocate mem in OnPXPLODE_REFRESH\n" );

                        EndDialog( hwnd , 0 );

                        return FALSE;
                    }


                }while( 1 );

                if (!NT_SUCCESS(status)) {
                    ExitProcess(status);
                    }

                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                DlgProcessInfo = ProcessInfo;
                Refresh = TRUE;
                InitProcessList(hwnd);
                Refresh = FALSE;
                nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                    }
                DlgProcessInfo = ProcessInfo;
                SetProcessFields(ProcessInfo,hwnd);
            }
            return FALSE;
        }
    default:
        return FALSE;
    }

    return TRUE;
}

int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    hEvent = CreateEvent(NULL,TRUE,TRUE,NULL);
    hSemaphore = CreateSemaphore(NULL,1,256,NULL);
    hMutex = CreateMutex(NULL,FALSE,NULL);
    hSection = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);

    DialogBoxParam(NULL,
                   MAKEINTRESOURCE(PXPLODEDLG),
                   NULL,
                   ExplodeDlgProc,
                   (LPARAM)0
                   );


    if( g_pLargeBuffer != NULL )
    {
        ODS( "Freeing buffer\n" );
        free( g_pLargeBuffer );
    }

    return 0;

    argc;
    argv;
    envp;
}

VOID
SetProcessFields(
    PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    HWND hwnd
    )
{

    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS RunTime;
    LARGE_INTEGER Time;
    CHAR TimeString[15];
    CHAR szTempField[MAXTASKNAMELEN];
    CHAR szTemp[80];
    HANDLE hProcess;
    HWND ThreadList,ProcessList;
    int i, nIndex;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PCHAR p;
    ANSI_STRING pname;

    pname.Buffer = NULL;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(ProcessInfo->UniqueProcessId));

    //
    // Set process name and process id
    //

    if ( ProcessInfo->ImageName.Buffer ) {
        RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        p = strrchr(pname.Buffer,'\\');
        if ( p ) {
            p++;
            }
        else {
            p = pname.Buffer;
            }
        }
    else {
        p = "System Process";
        }
    SetDlgItemText(
        hwnd,
        PXPLODE_IMAGENAME,
        p
        );

    SetDlgItemInt(
        hwnd,
        PXPLODE_PROCESS_ID,
        (UINT)HandleToUlong(ProcessInfo->UniqueProcessId),
        FALSE
        );

    if ( pname.Buffer ) {
        RtlFreeAnsiString(&pname);
        }

    //
    // Set process priority
    //

    if ( ProcessInfo->BasePriority < 7 ) {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_IDL);
        }
    else if ( ProcessInfo->BasePriority < 10 ) {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_NORMAL);
        }
    else {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_HIGH);
        }

    //
    // Compute address space utilization
    //

    ComputeVaSpace(hwnd,hProcess);

    //
    // Compute runtimes
    //

    RtlTimeToTimeFields ( &ProcessInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

    RtlTimeToTimeFields ( &ProcessInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ProcessInfo->KernelTime, &KernelTime);
    Time.QuadPart = RefreshTimeOfDayInfo.CurrentTime.QuadPart - ProcessInfo->CreateTime.QuadPart;
    RtlTimeToTimeFields ( &Time, &RunTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RunTime.Hour,
                RunTime.Minute,
                RunTime.Second,
                RunTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_ELAPSED_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_USER_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_KERNEL_TIME,
        TimeString
        );

    //
    // Set I/O Counts
    //
#if 0
    SetDlgItemInt(
        hwnd,
        PXPLODE_READ_XFER,
        ProcessInfo->ReadTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_WRITE_XFER,
        ProcessInfo->WriteTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_OTHER_XFER,
        ProcessInfo->OtherTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_READ_OPS,
        ProcessInfo->ReadOperationCount,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_WRITE_OPS,
        ProcessInfo->WriteOperationCount,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_OTHER_OPS,
        ProcessInfo->OtherOperationCount,
        FALSE
        );
#endif
    //
    // Set memory management stats
    //

    wsprintf(szTemp,"%d Kb",ProcessInfo->PeakVirtualSize/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_VSIZE,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->VirtualSize/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_VSIZE,
        szTemp
        );

    SetDlgItemInt(
        hwnd,
        PXPLODE_PFCOUNT,
        ProcessInfo->PageFaultCount,
        FALSE
        );

    wsprintf(szTemp,"%d Kb",(ProcessInfo->PeakWorkingSetSize)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_WS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",(ProcessInfo->WorkingSetSize)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_WS,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PeakPagefileUsage)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PF,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PagefileUsage)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PF,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PrivatePageCount)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PRIVATE_PAGE,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakNonPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_NONPAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaNonPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_NONPAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PAGED,
        szTemp
        );

    //
    // Get the usage and limits
    //

    {
        NTSTATUS Status;
        POOLED_USAGE_AND_LIMITS PooledInfo;

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessPooledUsageAndLimits,
                        &PooledInfo,
                        sizeof(PooledInfo),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                RtlZeroMemory(&PooledInfo,sizeof(PooledInfo));
                }
            //
            // non paged
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakNonPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONPEAK,
                szTempField
                );


            wsprintf(szTempField,"%d Kb",
                PooledInfo.NonPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONCUR,
                szTempField
                );

            if (PooledInfo.NonPagedPoolLimit != (SIZE_T)-1 ) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.NonPagedPoolLimit/1024
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONLIM,
                szTempField
                );


            //
            // paged
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGPEAK,
                szTempField
                );

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGCUR,
                szTempField
                );

            if (PooledInfo.PagedPoolLimit != (SIZE_T)-1) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.PagedPoolLimit/1024
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGLIM,
                szTempField
                );

            //
            // page file
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakPagefileUsage*4
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFPEAK,
                szTempField
                );

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PagefileUsage*4
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFCUR,
                szTempField
                );

            if (PooledInfo.PagefileLimit != (SIZE_T)-1) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.PagefileLimit*4
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFLIM,
                szTempField
                );
    }
    //
    // Locate the thread list box
    // and clear it
    //

    i = 0;
    ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);

//    SendMessage(ThreadList, WM_SETREDRAW, FALSE, 0);
    SendMessage(ThreadList, LB_RESETCONTENT, 0, 0);
    SendMessage(ThreadList, LB_SETITEMDATA, 0L, 0L);

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
    while (i < (int)ProcessInfo->NumberOfThreads) {

        wsprintf(szTempField,"%d",
            ThreadInfo->ClientId.UniqueThread
            );

        nIndex = (int)SendMessage(
                        ThreadList,
                        LB_ADDSTRING,
                        0,
                        (LPARAM)(LPSTR)szTempField
                        );
        SendMessage(
            ThreadList,
            LB_SETITEMDATA,
            nIndex,
            (LPARAM)ThreadInfo
            );

        if ( i == 0 ) {
            SetThreadFields(ThreadInfo,hwnd);
            }
        ThreadInfo += 1;
        i += 1;
        }
    SendMessage(ThreadList, LB_SETCURSEL, 0, 0);

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_COUNT,
        ProcessInfo->NumberOfThreads,
        FALSE
        );

    // Redraw the list now that all items have been inserted.

//    SendMessage(ThreadList, WM_SETREDRAW, TRUE, 0);
//    InvalidateRect(ThreadList, NULL, TRUE);

    ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
    SetFocus(ProcessList);
    if ( hProcess ) {
        CloseHandle(hProcess);
        }

    //
    // If we can't get at the process (maybe it's process 0?)
    // then don't let people try and edit the security on it or it's token.
    //

    hProcess = OpenProcess(MAXIMUM_ALLOWED,FALSE,HandleToUlong(ProcessInfo->UniqueProcessId));
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_ACL), hProcess != NULL);
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN), hProcess != NULL);
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN_ACL), hProcess != NULL);
    if (hProcess) {
        CloseHandle(hProcess);
    }


}

VOID
SetThreadFields(
    PSYSTEM_THREAD_INFORMATION ThreadInfo,
    HWND hwnd
    )
{
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS RunTime;
    LARGE_INTEGER Time;
    CHAR TimeString[15];
    CHAR StartString[32];
    HANDLE hThread;
    CONTEXT ThreadContext;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    ULONG_PTR PcValue;

    //
    // Display the selected thread information
    //

    //
    // Compute runtimes
    //

    RtlTimeToTimeFields ( &ThreadInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ThreadInfo->KernelTime, &KernelTime);

    RtlTimeToTimeFields ( &ThreadInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
    Time.QuadPart = RefreshTimeOfDayInfo.CurrentTime.QuadPart - ThreadInfo->CreateTime.QuadPart;
    RtlTimeToTimeFields ( &Time, &RunTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RunTime.Hour,
                RunTime.Minute,
                RunTime.Second,
                RunTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADELAPSED_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADUSER_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADKERNEL_TIME,
        TimeString
        );

    wsprintf(StartString,"0x%p",
                ThreadInfo->StartAddress
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREAD_START,
        StartString
        );

    //
    // Do the priority Group
    //

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_DYNAMIC,
        ThreadInfo->Priority,
        FALSE
        );
    switch ( ThreadInfo->BasePriority - DlgProcessInfo->BasePriority ) {

        case 2:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_HIGHEST
                );
            break;

        case 1:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_ABOVE
                );
            break;

        case -1:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_BELOW
                );
            break;
        case -2:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_LOWEST
                );
            break;
        case 0:
        default:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_NORMAL
                );
            break;
        }
    //
    // Complete thread information
    //

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_SWITCHES,
        ThreadInfo->ContextSwitches,
        FALSE
        );

    PcValue = 0;
    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
    Status = NtOpenThread(
                &hThread,
                THREAD_GET_CONTEXT,
                &Obja,
                &ThreadInfo->ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        ThreadContext.ContextFlags = CONTEXT_CONTROL;
        Status = NtGetContextThread(hThread,&ThreadContext);
        NtClose(hThread);
        if ( NT_SUCCESS(Status) ) {
            PcValue = (ULONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(&ThreadContext);
            }
        }
    if ( PcValue ) {
        wsprintf(StartString,"0x%p",
                    PcValue
                    );
        SetDlgItemText(
            hwnd,
            PXPLODE_THREAD_PC,
            StartString
            );
        }
    else {
        SetDlgItemText(
            hwnd,
            PXPLODE_THREAD_PC,
            "Unknown"
            );
        }


    //
    // Disable the thread buttons if we can't get at the thread or it's token
    //

    {
        HANDLE Thread;
        HANDLE Token;
        BOOL ThreadOK = FALSE;
        BOOL GotToken = FALSE;

        Thread = OpenThread(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
        if (Thread != NULL) {

            ThreadOK = TRUE;

            if (OpenThreadToken(Thread, MAXIMUM_ALLOWED, TRUE, &Token)) {
                GotToken = TRUE;
                CloseHandle(Token);
            }
            CloseHandle(Thread);
        }

        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_ACL), ThreadOK);

        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN), GotToken);
        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN_ACL), GotToken);
    }
}


VOID
InitProcessList(HWND hwnd)
{
    int nIndex,i,sel;
    HWND ProcessList;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    char szTempField[MAXTASKNAMELEN];
    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];
    ULONG TotalOffset;
    TIME_FIELDS RefreshTime;
    CHAR TimeString[15];
    PCHAR p;
    ANSI_STRING pname;

    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &RefreshTimeOfDayInfo,
        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
        NULL
        );

    RtlTimeToTimeFields ( &RefreshTimeOfDayInfo.CurrentTime, &RefreshTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RefreshTime.Hour,
                RefreshTime.Minute,
                RefreshTime.Second,
                RefreshTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_REFRESH_TIME,
        TimeString
        );

    //
    // Compute ObjectCounts
    //

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    NtQueryObject( NtCurrentProcess(),
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Process Objects    %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_PROCESS_OBJECT,
        szTempField
        );

    NtQueryObject( NtCurrentThread(),
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Thread Objects     %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_THREAD_OBJECT,
        szTempField
        );

    NtQueryObject( hEvent,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Event  Objects     %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_EVENT_OBJECT,
        szTempField
        );

    NtQueryObject( hSemaphore,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Semaphore Objects  %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_SEMAPHORE_OBJECT,
        szTempField
        );

    NtQueryObject( hMutex,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Mutex Objects      %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_MUTEX_OBJECT,
        szTempField
        );

    NtQueryObject( hSection,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Section Objects    %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_SECTION_OBJECT,
        szTempField
        );

    ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);

    // Don't redraw the list as items are deleted/inserted.

//    SendMessage(ProcessList, WM_SETREDRAW, FALSE, 0);
    SendMessage(ProcessList, CB_RESETCONTENT, 0, 0);
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
    SendMessage(ProcessList, CB_SETITEMDATA, 0L, 0L);
    sel = -1;
    TotalOffset = 0;
    while (TRUE) {

        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            p = strrchr(pname.Buffer,'\\');
            if ( p ) {
                p++;
                }
            else {
                p = pname.Buffer;
                }
            }
        else {
            p = "System Process";
            }

        wsprintf(szTempField,"%d %s",
            ProcessInfo->UniqueProcessId,
            p
            );

        RtlFreeAnsiString(&pname);
        nIndex = (int)SendMessage(
                        ProcessList,
                        CB_ADDSTRING,
                        0,
                        (LPARAM)(LPSTR)szTempField
                        );
        if ( DlgProcessInfo ) {
            if ( ProcessInfo == DlgProcessInfo ) {
                sel = nIndex;
                }
            }
        else {
            sel = 0;
            }
        SendMessage(
            ProcessList,
            CB_SETITEMDATA,
            nIndex,
            (LPARAM)ProcessInfo
            );

        i = 0;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        while (i < (int)ProcessInfo->NumberOfThreads) {
            ThreadInfo += 1;
            i += 1;
            }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pLargeBuffer[TotalOffset];
        }
    if ( LastProcess[0] ) {
        nIndex = (int)SendMessage(ProcessList, CB_FINDSTRING, (WPARAM)-1, (LPARAM)LastProcess);
        if ( nIndex != CB_ERR ) {
            sel = nIndex;
            }
        }
    SendMessage(ProcessList, CB_SETCURSEL, sel, 0);
    SendMessage(ProcessList, CB_GETLBTEXT, sel, (LPARAM)LastProcess);

    DlgProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pLargeBuffer[0];
    // Redraw the list now that all items have been inserted.

//    SendMessage(ProcessList, WM_SETREDRAW, TRUE, 0);
//    InvalidateRect(ProcessList, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\util.h ===
PVOID   Alloc(ULONG);
ULONG   GetAllocSize(PVOID);
BOOL    Free(PVOID);

BOOL    LUID2String(LUID, LPSTR, UINT);
BOOL    Time2String(TIME, LPSTR, UINT);
BOOL    TokenType2String(TOKEN_TYPE, LPSTR, UINT);
BOOL    ImpersonationLevel2String(SECURITY_IMPERSONATION_LEVEL, LPSTR, UINT);
BOOL    Dynamic2String(ULONG, LPSTR, UINT);
INT     AddItem(HWND, INT, LPSTR, LPARAM, BOOL);
INT     FindSid(HWND, INT, PSID, BOOL);
BOOL    SetHooks(HWND);
BOOL    ReleaseHooks(HWND);


// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define FindLBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, FALSE))

#define FindCBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\tokedit.c ===
/****************************************************************************

   PROGRAM: TOKEDIT.C

   PURPOSE: Displays and allows the user to edit the contents of a token

****************************************************************************/


#include "PVIEWP.h"
#include "string.h"


INT_PTR CALLBACK TokenEditDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK MoreDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    TokenEditDlgInit(HWND);
BOOL    TokenEditDlgEnd(HWND, BOOL);
BOOL    EnablePrivilege(HWND, BOOL);
BOOL    EnableGroup(HWND, BOOL);
BOOL    SetDefaultOwner(HWND);
BOOL    SetPrimaryGroup(HWND);
BOOL    MoreDlgInit(HWND hDlg, LPARAM lParam);
BOOL    DisplayMyToken(HWND);


/****************************************************************************

    FUNCTION: EditToken

    PURPOSE:  Displays and allows the user to edit a token

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/

BOOL EditToken(
    HWND hwndParent,
    HANDLE Token,
    LPWSTR Name
    )
{
    //DLGPROC lpProc;
    int     Result;
    HANDLE  hMyToken;
    HANDLE  Instance;

    hMyToken = OpenMyToken(Token, Name);
    if (hMyToken == NULL) {
        return(FALSE);
    }
    //
    // Get the application instance handle
    //

    Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);
    ASSERT(Instance != 0);

    //lpProc = (DLGPROC)MakeProcInstance(TokenEditDlgProc, Instance);
    //Result = (int)DialogBoxParam(Instance,(LPSTR)IDD_MAIN, hwndParent, lpProc, (LPARAM)hMyToken);
    //FreeProcInstance(lpProc);
    Result = (int)DialogBoxParam(Instance,(LPSTR)IDD_MAIN, hwndParent, TokenEditDlgProc, (LPARAM)hMyToken);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: TokenEditDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    WM_COMMAND     - application menu (About dialog box)
    WM_DESTROY     - destroy window

    COMMENTS:

****************************************************************************/

INT_PTR CALLBACK TokenEditDlgProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    DLGPROC lpProc;
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {

    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        if (!TokenEditDlgInit(hDlg)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            // we're done, drop through to quit dialog....

        case IDCANCEL:

            TokenEditDlgEnd(hDlg, LOWORD(wParam) == IDOK);

            EndDialog(hDlg, TRUE);
            return TRUE;

        case IDB_DISABLEPRIVILEGE:
        case IDB_ENABLEPRIVILEGE:
            EnablePrivilege(hDlg, LOWORD(wParam) == IDB_ENABLEPRIVILEGE);
            return(TRUE);

        case IDB_DISABLEGROUP:
        case IDB_ENABLEGROUP:
            EnableGroup(hDlg, LOWORD(wParam) == IDB_ENABLEGROUP);
            return(TRUE);

        case IDC_DEFAULTOWNER:
            SetDefaultOwner(hDlg);
            return(TRUE);

        case IDC_PRIMARYGROUP:
            SetPrimaryGroup(hDlg);
            return(TRUE);

        case IDB_MORE:
        {
            HANDLE  Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);

            //lpProc = (DLGPROC)MakeProcInstance(MoreDlgProc, Instance);
            //DialogBoxParam(Instance,(LPSTR)IDD_MORE, hDlg, lpProc, (LPARAM)hMyToken);
            //FreeProcInstance(lpProc);
            DialogBoxParam(Instance,(LPSTR)IDD_MORE, hDlg, MoreDlgProc, (LPARAM)hMyToken);
            return(TRUE);
        }

        case IDB_DEFAULT_DACL:
        {
            HANDLE Token = ((PMYTOKEN)hMyToken)->Token;
            LPWSTR Name = ((PMYTOKEN)hMyToken)->Name;

            EditTokenDefaultDacl(hDlg, Token, Name);
            return(TRUE);
        }


        default:
            // We didn't process this message
            return FALSE;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;
}


/****************************************************************************

    FUNCTION: TokenEditDlgInit(HWND)

    PURPOSE:  Initialises the controls in the main dialog window.

    RETURNS:   TRUE on success, FALSE if dialog should be terminated.

****************************************************************************/
BOOL TokenEditDlgInit(
    HWND    hDlg
    )
{
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    WCHAR string[MAX_STRING_LENGTH];
    HCURSOR OldCursor;

    if (!LsaInit()) {
        DbgPrint("PVIEW - LsaInit failed\n");
        return(FALSE);
    }

    OldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DisplayMyToken(hDlg);
    SetCursor(OldCursor);

    //
    // Set the dialog caption appropriately
    //

    GetWindowTextW(hDlg, string, sizeof(string)/sizeof(*string));
    lstrcatW(string, L" for <");
    lstrcatW(string, ((PMYTOKEN)hMyToken)->Name);
    lstrcatW(string, L">");
    SetWindowTextW(hDlg, string);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: TokenEditDlgEnd(HWND)

    PURPOSE:  Do whatever we have to do to clean up when dialog ends

    RETURNS:  TRUE on success, FALSE on failure.

****************************************************************************/
BOOL TokenEditDlgEnd(
    HWND    hDlg,
    BOOL    fSaveChanges)
{
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    BOOL Success;

    Success = CloseMyToken(hDlg, hMyToken, fSaveChanges);

    LsaTerminate();

    return(Success);
}


/****************************************************************************

    FUNCTION: DisplayMyToken

    PURPOSE:  Reads data out of mytoken and puts in dialog controls.

    RETURNS:   TRUE on success, FALSE on failure

****************************************************************************/
BOOL DisplayMyToken(
    HWND    hDlg
    )
{
    HANDLE      hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    CHAR        string[MAX_STRING_BYTES];
    UINT        GroupIndex;
    UINT        PrivIndex;

    //
    // Groups
    //
    if (pMyToken->Groups != NULL) {

        for (GroupIndex=0; GroupIndex < pMyToken->Groups->GroupCount; GroupIndex++ ) {

            PSID Sid = pMyToken->Groups->Groups[GroupIndex].Sid;
            ULONG Attributes = pMyToken->Groups->Groups[GroupIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_GROUP_ENABLED) {
                ControlID = IDL_ENABLEDGROUPS;
            } else {
                ControlID = IDL_DISABLEDGROUPS;
            }

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, ControlID, string, GroupIndex);

                // Add this group to default owner combo box if it's valid
                if (Attributes & SE_GROUP_OWNER) {
                    AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LPARAM)Sid);
                }

                // Add this group to primary group combo box
                AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);

            } else {
                DbgPrint("PVIEW: Failed to convert Group sid to string\n");
            }
        }
    } else {
        DbgPrint("PVIEW : No group info in mytoken\n");
    }


    //
    // User ID
    //
    if (pMyToken->UserId != NULL) {

        PSID    Sid = pMyToken->UserId->User.Sid;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            // Set user-name static text
            SetDlgItemText(hDlg, IDS_USERID, string);

            // Add to default owner combo box
            AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LPARAM)Sid);

            // Add to primary group combo box
            AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);

        } else {
            DbgPrint("PVIEW: Failed to convert User ID SID to string\n");
        }

    } else {
        DbgPrint("PVIEW: No user id in mytoken\n");
    }


    //
    // Default Owner
    //
    if (pMyToken->DefaultOwner != NULL) {

        PSID    Sid = pMyToken->DefaultOwner->Owner;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_DEFAULTOWNER, Sid);

            if (iItem >= 0) {
                SendMessage(GetDlgItem(hDlg, IDC_DEFAULTOWNER), CB_SETCURSEL, iItem, 0);
            } else {
                DbgPrint("PVIEW: Default Owner is not userID or one of our groups\n");
            }

        } else {
            DbgPrint("PVIEW: Failed to convert Default Owner SID to string\n");
        }
    } else {
        DbgPrint("PVIEW: No default owner in mytoken\n");
    }


    //
    // Primary group
    //

    if (pMyToken->PrimaryGroup != NULL) {

        PSID    Sid = pMyToken->PrimaryGroup->PrimaryGroup;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {
            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_PRIMARYGROUP, Sid);

            if (iItem < 0) {
                // Group is not already in combo-box, add it
                iItem = AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);
            }

            // Select the primary group
            SendMessage(GetDlgItem(hDlg, IDC_PRIMARYGROUP), CB_SETCURSEL, iItem, 0);

        } else {
            DbgPrint("PVIEW: Failed to convert primary group SID to string\n");
        }
    } else {
        DbgPrint("PVIEW: No primary group in mytoken\n");
    }


    //
    // Privileges
    //

    if (pMyToken->Privileges != NULL) {

        for (PrivIndex=0; PrivIndex < pMyToken->Privileges->PrivilegeCount; PrivIndex++ ) {

            LUID Privilege = pMyToken->Privileges->Privileges[PrivIndex].Luid;
            ULONG Attributes = pMyToken->Privileges->Privileges[PrivIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_PRIVILEGE_ENABLED) {
                ControlID = IDL_ENABLEDPRIVILEGES;
            } else {
                ControlID = IDL_DISABLEDPRIVILEGES;
            }

            if (PRIV2Name(Privilege, string, MAX_STRING_BYTES)) {

                // Add this privelege to the appropriate list-box
                AddLBItem(hDlg, ControlID, string, PrivIndex);

            } else {
                DbgPrint("PVIEW: Failed to convert privilege to string\n");
            }
        }
    } else {
        DbgPrint("PVIEW: No privilege info in mytoken\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnablePrivilege(HWND, fEnable)

    PURPOSE:  Enables or disables one or more privileges.
              If fEnable = TRUE, the selected privileges in the disabled
              privilege control are enabled.
              Vice versa for fEnable = FALSE

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL EnablePrivilege(
    HWND    hDlg,
    BOOL    fEnable)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PTOKEN_PRIVILEGES Privileges;


    Privileges = pMyToken->Privileges;
    if (Privileges == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDPRIVILEGES;
        idTo   = IDL_ENABLEDPRIVILEGES;
    } else {
        idFrom = IDL_ENABLEDPRIVILEGES;
        idTo   = IDL_DISABLEDPRIVILEGES;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);


    // Find how many items are selected
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    PrivIndex;
        UCHAR   PrivilegeName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        PrivIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)PrivilegeName);


        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add privilege to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)PrivilegeName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LPARAM)PrivIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Privileges->Privileges[PrivIndex].Attributes |= SE_PRIVILEGE_ENABLED;
        } else {
            Privileges->Privileges[PrivIndex].Attributes &= ~SE_PRIVILEGE_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnableGroup(HWND, fEnable)

    PURPOSE:  Enables or disables one or more selected groups.
              If fEnable = TRUE, the selected groups in the disabled
              group control are enabled.
              If fEnable = FALSE the selected groups in the enabled
              group control are disabled.

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL EnableGroup(
    HWND    hDlg,
    BOOL    fEnable)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PTOKEN_GROUPS Groups;


    Groups = pMyToken->Groups;
    if (Groups == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDGROUPS;
        idTo   = IDL_ENABLEDGROUPS;
    } else {
        idFrom = IDL_ENABLEDGROUPS;
        idTo   = IDL_DISABLEDGROUPS;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);

    // Find how many items are selected
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    GroupIndex;
        UCHAR   GroupName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        GroupIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)GroupName);

        // Check it's not a mandatory group (Can-not be disabled)
        //
        if (Groups->Groups[GroupIndex].Attributes & SE_GROUP_MANDATORY) {
            CHAR    buf[256];
            strcpy(buf, "'");
            strcat(buf, GroupName);
            strcat(buf, "' is a mandatory group and cannot be disabled");
            MessageBox(hDlg, buf, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            continue;   // skip to next group
        }

        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add item to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)GroupName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)GroupIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Groups->Groups[GroupIndex].Attributes |= SE_GROUP_ENABLED;
        } else {
            Groups->Groups[GroupIndex].Attributes &= ~SE_GROUP_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetDefaultOwner()

    PURPOSE:  Sets the default owner to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL SetDefaultOwner(
    HWND    hDlg)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwnd;
    INT     iItem;
    PTOKEN_OWNER DefaultOwner;


    DefaultOwner = pMyToken->DefaultOwner;
    if (DefaultOwner == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_DEFAULTOWNER);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    DefaultOwner->Owner = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetPrimaryGroup()

    PURPOSE:  Sets the primary group to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL SetPrimaryGroup(
    HWND    hDlg)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwnd;
    INT     iItem;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;


    PrimaryGroup = pMyToken->PrimaryGroup;
    if (PrimaryGroup == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_PRIMARYGROUP);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    PrimaryGroup->PrimaryGroup = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MoreDlgProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR CALLBACK MoreDlgProc(hDlg, message, wParam, lParam)
    HWND hDlg;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {

    case WM_INITDIALOG:

        if (!MoreDlgInit(hDlg, lParam)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:

            // we're done, drop through to quit dialog....

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;
}


/****************************************************************************

    FUNCTION: MoreDlgInit(HWND)

    PURPOSE:  Initialises the controls in the more dialog window.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL MoreDlgInit(
    HWND    hDlg,
    LPARAM  lParam
    )
{
    TCHAR string[MAX_STRING_LENGTH];
    HANDLE  hMyToken = (HANDLE)lParam;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_STATISTICS Statistics;
    PTOKEN_GROUPS Restrictions ;
    UINT        GroupIndex;


    Statistics = pMyToken->TokenStats;
    if (Statistics == NULL) {
        DbgPrint("PVIEW: No token statistics in mytoken\n");
        return(FALSE);
    }

    wsprintf(string, "0x%lx-%lx",
             pMyToken->TokenStats->AuthenticationId.HighPart,
             pMyToken->TokenStats->AuthenticationId.LowPart);
    SetDlgItemText(hDlg, IDS_LOGONSESSION, string);

    if (LUID2String(Statistics->TokenId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENID, string);
    } else {
        DbgPrint("PVIEW: Failed to convert tokenid luid to string\n");
    }

    if (Time2String(Statistics->ExpirationTime, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_EXPIRATIONTIME, string);
    } else {
        DbgPrint("PVIEW: Failed to convert expiration time to string\n");
    }

    if (TokenType2String(Statistics->TokenType, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENTYPE, string);
    } else {
        DbgPrint("PVIEW: Failed to convert token type to string\n");
    }

    if (Statistics->TokenType == TokenPrimary) {
        SetDlgItemText(hDlg, IDS_IMPERSONATION, "N/A");
    } else {
        if (ImpersonationLevel2String(Statistics->ImpersonationLevel, string, MAX_STRING_BYTES)) {
            SetDlgItemText(hDlg, IDS_IMPERSONATION, string);
        } else {
            DbgPrint("PVIEW: Failed to convert impersonation level to string\n");
        }
    }

    if (Dynamic2String(Statistics->DynamicCharged, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICCHARGED, string);
    } else {
        DbgPrint("PVIEW: Failed to convert dynamic charged to string\n");
    }

    if (Dynamic2String(Statistics->DynamicAvailable, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICAVAILABLE, string);
    } else {
        DbgPrint("PVIEW: Failed to convert dynamic available to string\n");
    }

    if (LUID2String(Statistics->ModifiedId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_MODIFIEDID, string);
    } else {
        DbgPrint("PVIEW: Failed to convert modifiedid luid to string\n");
    }

    Restrictions = pMyToken->RestrictedSids ;

    if ( Restrictions && (Restrictions->GroupCount) )
    {
        for (GroupIndex=0; GroupIndex < Restrictions->GroupCount; GroupIndex++ ) {

            PSID Sid = Restrictions->Groups[GroupIndex].Sid;
            ULONG Attributes = Restrictions->Groups[GroupIndex].Attributes;

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, IDS_RESTRICTEDSIDS, string, GroupIndex);

            } else {
                DbgPrint("PVIEW: Failed to convert Group sid to string\n");
            }

        }
    }
    else
    {
        AddLBItem( hDlg, IDS_RESTRICTEDSIDS, TEXT("None"), 0 );
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "PVIEWP.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID Alloc(
    ULONG   Bytes)
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

ULONG GetAllocSize(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return (ULONG)(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL Free(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

   FUNCTION: LUID2String

   PURPOSE: Converts a LUID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL LUID2String(
    LUID    Luid,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    if (Luid.HighPart == 0) {
        wsprintf(String, "0x%lx", Luid.LowPart);
    } else {
        wsprintf(String, "0x%lx%08lx", Luid.HighPart, Luid.LowPart);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Time2String

   PURPOSE: Converts a time into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL Time2String(
    TIME    Time,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields(&Time, &TimeFields);

    if (TimeFields.Year > 2900) {
        strcpy(String, "Never");
    } else {
        wsprintf(String, "%d/%d/%d  %02d:%02d:%02d",
                    TimeFields.Year, TimeFields.Month, TimeFields.Day,
                    TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: TokenType2String

   PURPOSE: Converts a tokentype into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL TokenType2String(
    TOKEN_TYPE TokenType,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    switch (TokenType) {

    case TokenPrimary:
        strcpy(String, "Primary");
        break;

    case TokenImpersonation:
        strcpy(String, "Impersonation");
        break;

    default:
        DbgPrint("SECEDIT: TokenType2String fed unrecognised token type : 0x%x\n", TokenType);
        return(FALSE);
        break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ImpersonationLevel2String

   PURPOSE: Converts an impersonation level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL ImpersonationLevel2String(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    switch (ImpersonationLevel) {

    case SecurityAnonymous:
        strcpy(String, "Anonymous");
        break;

    case SecurityIdentification:
        strcpy(String, "Identification");
        break;

    case SecurityImpersonation:
        strcpy(String, "Impersonation");
        break;

    case SecurityDelegation:
        strcpy(String, "Delegation");
        break;

    default:
        DbgPrint("SECEDIT: ImpersonationLevel2String fed unrecognised impersonation level : 0x%x\n", ImpersonationLevel);
        return(FALSE);
        break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Dynamic2String

   PURPOSE: Converts an dynamic quota level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL Dynamic2String(
    ULONG   Dynamic,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    wsprintf(String, "%ld", Dynamic);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT AddItem(
    HWND    hDlg,
    INT     ControlID,
    LPSTR   String,
    LPARAM  Data,
    BOOL    fCBox)
{
    HWND    hwnd;
    LRESULT iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = SendMessage(hwnd, AddStringMsg, 0, (LPARAM)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return((INT)iItem);
}


/****************************************************************************

    FUNCTION: FindSid

    PURPOSE:  Searches for the specified Sid in a control.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
INT FindSid(
    HWND    hDlg,
    INT     ControlID,
    PSID    Sid,
    BOOL    fCBox)
{
    HWND    hwnd;
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT     iItem;
        PSID    ItemSid;

        for (iItem =0; iItem < cItems; iItem ++) {

            ItemSid = (PSID)SendMessage(hwnd, GetDataMsg, (WPARAM)iItem, 0);
            if (RtlEqualSid(ItemSid, Sid)) {
                return(iItem);
            }
        }
    }

    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\vastat.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pviewp.h>
#include <explode.h>

#define DEFAULT_INCR (64*1024)

LIST_ENTRY VaList;

typedef struct _VAINFO {
    LIST_ENTRY Links;
    LIST_ENTRY AllocationBaseHead;
    MEMORY_BASIC_INFORMATION BasicInfo;
} VAINFO, *PVAINFO;

PVAINFO LastAllocationBase;

SIZE_T CommitedBytes;
SIZE_T ReservedBytes;
SIZE_T FreeBytes;
SIZE_T ImageCommitedBytes;
SIZE_T ImageReservedBytes;
SIZE_T ImageFreeBytes;

#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

ULONG_PTR MappedCommit[MAXPROTECT];
ULONG_PTR PrivateCommit[MAXPROTECT];

typedef struct _MODINFO {
    PVOID BaseAddress;
    SIZE_T VirtualSize;
    ANSI_STRING Name;
    ANSI_STRING FullName;
    ULONG_PTR CommitVector[MAXPROTECT];
} MODINFO, *PMODINFO;
#define MODINFO_SIZE 64
ULONG ModInfoNext;
MODINFO ModInfo[MODINFO_SIZE];
MODINFO TotalModInfo;

PMODINFO
LocateModInfo(
    PVOID Address
    )
{
    int i;
    for (i=0;i<(int)ModInfoNext;i++){
        if ( Address >= ModInfo[i].BaseAddress &&
             Address <= (PVOID)((ULONG_PTR)ModInfo[i].BaseAddress+ModInfo[i].VirtualSize) ) {
            return &ModInfo[i];
            }
        }
    return NULL;
}

VOID
ComputeModInfo(
    HWND hDlg,
    HANDLE Process
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInfo;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead,LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING us;
    int i,nIndex;
    HWND ComboList;
    HANDLE hFile;
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS FileHeader;
    LPSTR p;
    PVOID MappedAddress;

    for (i=0;i<(int)ModInfoNext;i++){
        if ( ModInfo[i].BaseAddress &&
             ModInfo[i].BaseAddress != (PVOID) (-1) &&
             ModInfo[i].Name.Buffer
             ) {
            RtlFreeAnsiString(&ModInfo[i].Name);
            }
        }
    ModInfoNext = 0;
    RtlZeroMemory(ModInfo,sizeof(ModInfo));
    RtlInitAnsiString(&TotalModInfo.Name," TotalImageCommit");

    ComboList = GetDlgItem(hDlg, PXPLODE_IMAGE_COMMIT);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);
    nIndex = (int)SendMessage(
                    ComboList,
                    CB_ADDSTRING,
                    0,
                    (LPARAM)TotalModInfo.Name.Buffer
                    );
    SendMessage(
        ComboList,
        CB_SETITEMDATA,
        nIndex,
        (LPARAM)&TotalModInfo
        );

    Status = NtQueryInformationProcess(
                Process,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {
            Status = NtQueryInformationProcess(
                        Process,
                        ProcessBasicInformation,
                        &BasicInfo,
                        sizeof(BasicInfo)-4,
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                return;
                }
            }
        else {
            return;
            }
        }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory(
                Process,
                &Peb->Ldr,
                &Ldr,
                sizeof(Ldr),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory(
                Process,
                &LdrHead->Flink,
                &LdrNext,
                sizeof(LdrNext),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    while ( LdrNext != LdrHead ) {
        LdrEntry = CONTAINING_RECORD(LdrNext,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks);
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntry,
                    &LdrEntryData,
                    sizeof(LdrEntryData),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        ModInfo[ModInfoNext].BaseAddress = LdrEntryData.DllBase;

        us.Length = LdrEntryData.BaseDllName.Length;
        us.MaximumLength = LdrEntryData.BaseDllName.MaximumLength;
        us.Buffer = LocalAlloc(LMEM_ZEROINIT,us.MaximumLength);
        if ( !us.Buffer ) {
            return;
            }
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntryData.BaseDllName.Buffer,
                    us.Buffer,
                    us.MaximumLength,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        RtlUnicodeStringToAnsiString(
            &ModInfo[ModInfoNext].Name,
            &us,
            TRUE
            );
        LocalFree(us.Buffer);

        us.Length = LdrEntryData.FullDllName.Length;
        us.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        us.Buffer = LocalAlloc(LMEM_ZEROINIT,us.MaximumLength);
        if ( !us.Buffer ) {
            return;
            }
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntryData.FullDllName.Buffer,
                    us.Buffer,
                    us.MaximumLength,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        RtlUnicodeStringToAnsiString(
            &ModInfo[ModInfoNext].FullName,
            &us,
            TRUE
            );
        LocalFree(us.Buffer);

        if ( p = strchr(ModInfo[ModInfoNext].FullName.Buffer,':') ) {
            ModInfo[ModInfoNext].FullName.Buffer = p - 1;
            }

        hFile = CreateFile(
                    ModInfo[ModInfoNext].FullName.Buffer,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            return;
            }
        hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
        CloseHandle(hFile);
        if ( !hMappedFile ) {
            return;
            }
        MappedAddress = MapViewOfFile(
                            hMappedFile,
                            FILE_MAP_READ,
                            0,
                            0,
                            0
                            );

        CloseHandle(hMappedFile);

        if ( !MappedAddress ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }

        DosHeader = (PIMAGE_DOS_HEADER)MappedAddress;

        if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }

        FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

        if ( FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }
        ModInfo[ModInfoNext].VirtualSize = FileHeader->OptionalHeader.SizeOfImage;
        UnmapViewOfFile(MappedAddress);

        nIndex = (int)SendMessage(
                        ComboList,
                        CB_ADDSTRING,
                        0,
                        (LPARAM)ModInfo[ModInfoNext].Name.Buffer
                        );
        SendMessage(
            ComboList,
            CB_SETITEMDATA,
            nIndex,
            (LPARAM)&ModInfo[ModInfoNext]
            );

        ModInfoNext++;
        ModInfo[ModInfoNext].BaseAddress = (PVOID) (-1);

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }
    SendMessage(ComboList, CB_SETCURSEL, 0, 0);
}

ProtectionToIndex(
    ULONG Protection
    )
{
    Protection &= ~PAGE_GUARD;

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
            printf("Unknown Protection 0x%lx\n",Protection);
            return 0;
        }
}

VOID
DumpImageCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALIMAGE_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_EXECUTE,
        szTemp
        );
}

VOID
DumpMappedCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALMAPPED_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_EXECUTE,
        szTemp
        );
}

VOID
DumpPrivateCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALPRIVATE_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_EXECUTE,
        szTemp
        );
}

VOID
CaptureVaSpace(
    IN HANDLE Process
    )
{

    NTSTATUS Status;
    PVOID BaseAddress;
    PVAINFO VaInfo;
    PMODINFO Mod;
    ULONG_PTR SystemRangeStart;

    Status = NtQuerySystemInformation(SystemRangeStartInformation,
                                      &SystemRangeStart,
                                      sizeof(SystemRangeStart),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    BaseAddress = NULL;
    LastAllocationBase = NULL;
    InitializeListHead(&VaList);

    VaInfo = LocalAlloc(LMEM_ZEROINIT,sizeof(*VaInfo));
    while ( (ULONG_PTR)BaseAddress < SystemRangeStart ) {
        Status = NtQueryVirtualMemory(
                    Process,
                    BaseAddress,
                    MemoryBasicInformation,
                    &VaInfo->BasicInfo,
                    sizeof(VaInfo->BasicInfo),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            LocalFree(VaInfo);
            return;
            }
        else {
            switch (VaInfo->BasicInfo.State ) {

                case MEM_COMMIT :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        TotalModInfo.CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                        Mod = LocateModInfo(BaseAddress);
                        if ( Mod ) {
                            Mod->CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        }
                    else {
                        if ( VaInfo->BasicInfo.Type == MEM_MAPPED ) {
                            MappedCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        else {
                            PrivateCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        }
                    break;
                case MEM_RESERVE :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        ImageReservedBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    else {
                        ReservedBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    break;
                case MEM_FREE :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        ImageFreeBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    else {
                        FreeBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    break;
                }

            BaseAddress = (PVOID)((ULONG_PTR)BaseAddress + VaInfo->BasicInfo.RegionSize);
        }
    }
}

BOOL
ComputeVaSpace(
    HWND hDlg,
    HANDLE hProcess
    )
{
    memset(TotalModInfo.CommitVector,0,sizeof(TotalModInfo.CommitVector));
    memset(MappedCommit,0,sizeof(MappedCommit));
    memset(PrivateCommit,0,sizeof(PrivateCommit));
    ComputeModInfo(hDlg,hProcess);
    if ( hProcess) {
        CaptureVaSpace(hProcess);
        }
    DumpImageCommit(hDlg,&TotalModInfo.CommitVector[0]);
    DumpMappedCommit(hDlg,MappedCommit);
    DumpPrivateCommit(hDlg,PrivateCommit);
    return TRUE;
}


VOID
UpdateImageCommit(
    HWND hDlg
    )
{
    HWND ComboList;
    int nIndex;
    PMODINFO ModInfo;

    ComboList = GetDlgItem(hDlg, PXPLODE_IMAGE_COMMIT);
    nIndex = (int)SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    ModInfo = (PMODINFO)SendMessage(
                            ComboList,
                            CB_GETITEMDATA,
                            nIndex,
                            0
                            );
    if ( ModInfo ) {
        DumpImageCommit(hDlg,&ModInfo->CommitVector[0]);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pview\tokedit.h ===
//
// Function prototypes
//

BOOL EditToken(
    HWND hwndParent,
    HANDLE Token,
    LPWSTR Name
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\cntrdata.c ===
/******************************************************************************

                            C O U N T E R   D A T A

    Name:       cntrdata.c

    Description:
        This module contains functions that access counters of an instance
        of object in performance data.

    Functions:
        FirstCounter
        NextCounter
        FindCounter
        CounterData

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstCounter
//
//      Find the first counter in pObject.
//
//      Returns a pointer to the first counter.  If pObject is NULL
//      then NULL is returned.
//
PPERF_COUNTER FirstCounter (PPERF_OBJECT pObject)
{
    if (pObject)
        return (PPERF_COUNTER)((PCHAR) pObject + pObject->HeaderLength);
    else
        return NULL;
}




//*********************************************************************
//
//  NextCounter
//
//      Find the next counter of pCounter.
//
//      If pCounter is the last counter of an object type, bogus data
//      maybe returned.  The caller should do the checking.
//
//      Returns a pointer to a counter.  If pCounter is NULL then
//      NULL is returned.
//
PPERF_COUNTER NextCounter (PPERF_COUNTER pCounter)
{
    if (pCounter)
        return (PPERF_COUNTER)((PCHAR) pCounter + pCounter->ByteLength);
    else
        return NULL;
}




//*********************************************************************
//
//  FindCounter
//
//      Find a counter specified by TitleIndex.
//
//      Returns a pointer to the counter.  If counter is not found
//      then NULL is returned.
//
PPERF_COUNTER FindCounter (PPERF_OBJECT pObject, DWORD TitleIndex)
{
PPERF_COUNTER pCounter;
DWORD         i = 0;

    if (pCounter = FirstCounter (pObject))
        while (i < pObject->NumCounters)
            {
            if (pCounter->CounterNameTitleIndex == TitleIndex)
                return pCounter;

            pCounter = NextCounter (pCounter);
            i++;
            }

    return NULL;

}




//*********************************************************************
//
//  CounterData
//
//      Returns counter data for an object instance.  If pInst or pCount
//      is NULL then NULL is returne.
//
PVOID CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount)
{
PPERF_COUNTER_BLOCK pCounterBlock;

    if (pCount && pInst)
        {
        pCounterBlock = (PPERF_COUNTER_BLOCK)((PCHAR)pInst + pInst->ByteLength);
        return (PVOID)((PCHAR)pCounterBlock + pCount->CounterOffset);
        }
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\perfdata.h ===
/******************************************************************************

                    P E R F O R M A N C E   D A T A

    Name:       perfdata.h

    Description:
        This module contains function prototypes and defines used in
        objdata.c, instdata.c, and cntrdata.c.

******************************************************************************/






typedef PERF_DATA_BLOCK             PERF_DATA,      *PPERF_DATA;
typedef PERF_OBJECT_TYPE            PERF_OBJECT,    *PPERF_OBJECT;
typedef PERF_INSTANCE_DEFINITION    PERF_INSTANCE,  *PPERF_INSTANCE;
typedef PERF_COUNTER_DEFINITION     PERF_COUNTER,   *PPERF_COUNTER;














DWORD   GetPerfData (HKEY       hPerfKey,
                     LPTSTR     szObjectIndex,
                     PPERF_DATA *ppData,
                     DWORD      *pDataSize);

DWORD   GetPerfTitleSz
                    (HKEY       hKeyMachine,
                     HKEY       hKeyPerf,
                     LPTSTR     *TitleBuffer,
                     LPTSTR     *TitleSz[],
                     DWORD      *TitleLastIdx);


PPERF_OBJECT    FirstObject (PPERF_DATA pData);
PPERF_OBJECT    NextObject (PPERF_OBJECT pObject);
PPERF_OBJECT    FindObject (PPERF_DATA pData, DWORD TitleIndex);
PPERF_OBJECT    FindObjectN (PPERF_DATA pData, DWORD N);

PPERF_INSTANCE  FirstInstance (PPERF_OBJECT pObject);
PPERF_INSTANCE  NextInstance (PPERF_INSTANCE pInst);
PPERF_INSTANCE  FindInstanceN (PPERF_OBJECT pObject, DWORD N);
PPERF_INSTANCE  FindInstanceParent (PPERF_INSTANCE pInst, PPERF_DATA pData);
LPTSTR          InstanceName (PPERF_INSTANCE pInst);

PPERF_COUNTER   FirstCounter (PPERF_OBJECT pObject);
PPERF_COUNTER   NextCounter (PPERF_COUNTER pCounter);
PPERF_COUNTER   FindCounter (PPERF_OBJECT pObject, DWORD TitleIndex);
PVOID           CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\instdata.c ===
/******************************************************************************

                            I N S T A N C E   D A T A

    Name:       instdata.c

    Description:
        This module contains functions that access instances of an object
        type in performance data.

    Functions:
        FirstInstance
        NextInstance
        FindInstanceN
        FindInstanceParent
        InstanceName


******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstInstance
//
//      Returns pointer to the first instance of pObject type.
//      If pObject is NULL then NULL is returned.
//
PPERF_INSTANCE   FirstInstance (PPERF_OBJECT pObject)
{
    if (pObject)
        return (PPERF_INSTANCE)((PCHAR) pObject + pObject->DefinitionLength);
    else
        return NULL;
}




//*********************************************************************
//
//  NextInstance
//
//      Returns pointer to the next instance following pInst.
//
//      If pInst is the last instance, bogus data maybe returned.
//      The caller should do the checking.
//
//      If pInst is NULL, then NULL is returned.
//
PPERF_INSTANCE   NextInstance (PPERF_INSTANCE pInst)
{
PERF_COUNTER_BLOCK *pCounterBlock;

    if (pInst)
        {
        pCounterBlock = (PERF_COUNTER_BLOCK *)((PCHAR) pInst + pInst->ByteLength);
        return (PPERF_INSTANCE)((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
        }
    else
        return NULL;
}




//*********************************************************************
//
//  FindInstanceN
//
//      Returns the Nth instance of pObject type.  If not found, NULL is
//      returned.  0 <= N <= NumInstances.
//

PPERF_INSTANCE FindInstanceN (PPERF_OBJECT pObject, DWORD N)
{
PPERF_INSTANCE pInst;
DWORD          i = 0;

    if (!pObject)
        return NULL;
    else if (N >= (DWORD)(pObject->NumInstances))
        return NULL;
    else
        {
        pInst = FirstInstance (pObject);

        while (i != N)
            {
            pInst = NextInstance (pInst);
            i++;
            }

        return pInst;
        }
}




//*********************************************************************
//
//  FindInstanceParent
//
//      Returns the pointer to an instance that is the parent of pInst.
//
//      If pInst is NULL or the parent object is not found then NULL is
//      returned.
//
PPERF_INSTANCE FindInstanceParent (PPERF_INSTANCE pInst, PPERF_DATA pData)
{
PPERF_OBJECT    pObject;

    if (!pInst)
        return NULL;
    else if (!(pObject = FindObject (pData, pInst->ParentObjectTitleIndex)))
        return NULL;
    else
        return FindInstanceN (pObject, pInst->ParentObjectInstance);
}




//*********************************************************************
//
//  InstanceName
//
//      Returns the name of the pInst.
//
//      If pInst is NULL then NULL is returned.
//
LPTSTR  InstanceName (PPERF_INSTANCE pInst)
{
    if (pInst)
        return (LPTSTR) ((PCHAR) pInst + pInst->NameOffset);
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\perfdata.c ===
/******************************************************************************

                        P E R F O R M A N C E   D A T A

    Name:       perfdata.c

    Description:
        This module together with objdata.c, instdata.c, and cntrdata.c
        access the performance data.

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"
#include <stdlib.h>




LPTSTR      *gPerfTitleSz;
LPTSTR      TitleData;




//*********************************************************************
//
//  GetPerfData
//
//      Get a new set of performance data.
//
//      *ppData should be NULL initially.
//      This function will allocate a buffer big enough to hold the
//      data requested by szObjectIndex.
//
//      *pDataSize specifies the initial buffer size.  If the size is
//      too small, the function will increase it until it is big enough
//      then return the size through *pDataSize.  Caller should
//      deallocate *ppData if it is no longer being used.
//
//      Returns ERROR_SUCCESS if no error occurs.
//
//      Note: the trial and error loop is quite different from the normal
//            registry operation.  Normally if the buffer is too small,
//            RegQueryValueEx returns the required size.  In this case,
//            the perflib, since the data is dynamic, a buffer big enough
//            for the moment may not be enough for the next. Therefor,
//            the required size is not returned.
//
//            One should start with a resonable size to avoid the overhead
//            of reallocation of memory.
//
DWORD   GetPerfData    (HKEY        hPerfKey,
                        LPTSTR      szObjectIndex,
                        PPERF_DATA  *ppData,
                        DWORD       *pDataSize)
{
DWORD   DataSize;
DWORD   dwR;
DWORD   Type;


    if (!*ppData)
        *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize);


    do  {
        DataSize = *pDataSize;
        dwR = RegQueryValueEx (hPerfKey,
                               szObjectIndex,
                               NULL,
                               &Type,
                               (BYTE *)*ppData,
                               &DataSize);

        if (dwR == ERROR_MORE_DATA)
            {
            LocalFree (*ppData);
            *pDataSize += 1024;
            *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize);
            }

        if (!*ppData)
            {
            LocalFree (*ppData);
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        } while (dwR == ERROR_MORE_DATA);

    return dwR;
}




#ifdef UNICODE

#define atoi    atoiW


//*********************************************************************
//
//  atoiW
//
//      Unicode version of atoi.
//
INT atoiW (LPTSTR s)
{
INT i = 0;

    while (iswdigit (*s))
        {
        i = i*10 + (BYTE)*s - L'0';
        s++;
        }

    return i;
}

#endif




//*********************************************************************
//
//  GetPerfTitleSz
//
//      Retrieves the performance data title strings.
//
//      This call retrieves english version of the title strings.
//
//      For NT 1.0, the counter names are stored in the "Counters" value
//      in the ...\perflib\009 key.  For 1.0a and later, the 009 key is no
//      longer used.  The counter names should be retrieved from "Counter 009"
//      value of HKEY_PERFORMANCE_KEY.
//
//      Caller should provide two pointers, one for buffering the title
//      strings the other for indexing the title strings.  This function will
//      allocate memory for the TitleBuffer and TitleSz.  To get the title
//      string for a particular title index one would just index the TitleSz.
//      *TitleLastIdx returns the highest index can be used.  If TitleSz[N] is
//      NULL then there is no Title for index N.
//
//      Example:  TitleSz[20] points to titile string for title index 20.
//
//      When done with the TitleSz, caller should LocalFree(*TitleBuffer).
//
//      This function returns ERROR_SUCCESS if no error.
//
DWORD   GetPerfTitleSz (HKEY    hKeyMachine,
                        HKEY    hKeyPerf,
                        LPTSTR  *TitleBuffer,
                        LPTSTR  *TitleSz[],
                        DWORD   *TitleLastIdx)
{
HKEY    hKey1;
HKEY    hKey2;
DWORD   Type;
DWORD   DataSize;
DWORD   dwR;
DWORD   Len;
DWORD   Index;
DWORD   dwTemp;
BOOL    bNT10;
LPTSTR  szCounterValueName;
LPTSTR  szTitle;




    // Initialize
    //
    hKey1        = NULL;
    hKey2        = NULL;
    *TitleBuffer = NULL;
    *TitleSz     = NULL;




    // Open the perflib key to find out the last counter's index and system version.
    //
    dwR = RegOpenKeyEx (hKeyMachine,
                        TEXT("software\\microsoft\\windows nt\\currentversion\\perflib"),
                        0,
                        KEY_READ,
                        &hKey1);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Get the last counter's index so we know how much memory to allocate for TitleSz
    //
    DataSize = sizeof (DWORD);
    dwR = RegQueryValueEx (hKey1, TEXT("Last Counter"), 0, &Type, (LPBYTE)TitleLastIdx, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Find system version, for system earlier than 1.0a, there's no version value.
    //
    dwR = RegQueryValueEx (hKey1, TEXT("Version"), 0, &Type, (LPBYTE)&dwTemp, &DataSize);

    if (dwR != ERROR_SUCCESS)
        // unable to read the value, assume NT 1.0
        bNT10 = TRUE;
    else
        // found the value, so, NT 1.0a or later
        bNT10 = FALSE;









    // Now, get ready for the counter names and indexes.
    //
    if (bNT10)
        {
        // NT 1.0, so make hKey2 point to ...\perflib\009 and get
        //  the counters from value "Counters"
        //
        szCounterValueName = TEXT("Counters");
        dwR = RegOpenKeyEx (hKeyMachine,
                            TEXT("software\\microsoft\\windows nt\\currentversion\\perflib\\009"),
                            0,
                            KEY_READ,
                            &hKey2);
        if (dwR != ERROR_SUCCESS)
            goto done;
        }
    else
        {
        // NT 1.0a or later.  Get the counters in key HKEY_PERFORMANCE_KEY
        //  and from value "Counter 009"
        //
        szCounterValueName = TEXT("Counter 009");
        hKey2 = hKeyPerf;
        }





    // Find out the size of the data.
    //
    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &Type, 0, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Allocate memory
    //
    *TitleBuffer = (LPTSTR)LocalAlloc (LMEM_FIXED, DataSize);
    if (!*TitleBuffer)
        {
        dwR = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
        }

    *TitleSz = (LPTSTR *)LocalAlloc (LPTR, (*TitleLastIdx+1) * sizeof (LPTSTR));
    if (!*TitleSz)
        {
        dwR = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
        }





    // Query the data
    //
    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &Type, (BYTE *)*TitleBuffer, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;




    // Setup the TitleSz array of pointers to point to beginning of each title string.
    // TitleBuffer is type REG_MULTI_SZ.
    //
    szTitle = *TitleBuffer;

    while (Len = lstrlen (szTitle))
        {
        Index = atoi (szTitle);

        szTitle = szTitle + Len +1;

        if (Index <= *TitleLastIdx)
            (*TitleSz)[Index] = szTitle;

        szTitle = szTitle + lstrlen (szTitle) +1;
        }



done:

    // Done. Now cleanup!
    //
    if (dwR != ERROR_SUCCESS)
        {
        // There was an error, free the allocated memory
        //
        if (*TitleBuffer) LocalFree (*TitleBuffer);
        if (*TitleSz)     LocalFree (*TitleSz);
        }

    // Close the hKeys.
    //
    if (hKey1) RegCloseKey (hKey1);
    if (hKey2 && hKey2 != hKeyPerf) RegCloseKey (hKey2);



    return dwR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\pviewdat.c ===
/******************************************************************************

                            P V I E W   D A T A

    Name:       pviewdat.c

    Description:
        This module collects the data to be displayed in pview.

******************************************************************************/

#include    <windows.h>
#include    <winperf.h>
#include    "perfdata.h"
#include    "pviewdat.h"
#include    "pviewdlg.h"
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <tchar.h>


#define NODATA  TEXT("--------")





void    FormatTimeFields
(double      fTime,
 PTIME_FIELD pTimeFld);

DWORD   PutCounterDWKB
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

DWORD   PutCounterHEX
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

DWORD   PutCounterDW
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

void    PaintAddressSpace
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           TotalID,
 DWORD           NoAccessID,
 DWORD           NoAccessIndex,
 DWORD           ReadOnlyID,
 DWORD           ReadOnlyIndex,
 DWORD           ReadWriteID,
 DWORD           ReadWriteIndex,
 DWORD           WriteCopyID,
 DWORD           WriteCopyIndex,
 DWORD           ExecuteID,
 DWORD           ExecuteIndex1,
 DWORD           ExecuteIndex2,
 DWORD           ExecuteIndex3,
 DWORD           ExecuteIndex4);

void    PaintMemDlgAddrData
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    PaintMemDlgVMData
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    PaintPviewDlgMemoryData
(HWND            hPviewDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    RefreshMemoryDlgImageList
(HWND            hImageList,
 DWORD           ParentIndex,
 PPERF_OBJECT    pImageObj);

WORD    ProcessPriority
(PPERF_OBJECT    pObject,
 PPERF_INSTANCE  pInstance);

void    SetProcessListText
(PPERF_INSTANCE pInst,
 PPERF_COUNTER  pCPU,
 PPERF_COUNTER  pPRIV,
 PPERF_COUNTER  pProcID,
 double         fTime,
 LPTSTR         str);

void    SetThreadListText
(PPERF_INSTANCE  pInst,
 PPERF_COUNTER   pCPU,
 PPERF_COUNTER   pPRIV,
 double          fTime,
 LPTSTR          str);




//*********************************************************************
//
//      FormatTimeFields
//
//  Formats a double value to time fields.
//
void FormatTimeFields   (double      fTime,
                         PTIME_FIELD pTimeFld)
{
    INT     i;
    double   f;

    f = fTime/3600;

    pTimeFld->Hours = i = (int)f;

    f = f - i;
    pTimeFld->Mins = i = (int)(f = f * 60);

    f = f - i;
    pTimeFld->Secs = i = (int)(f = f * 60);

    f = f - i;
    pTimeFld->mSecs = (int)(f * 1000);
}




//*********************************************************************
//
//      PutCounterDWKB
//
//  Display a DWORD counter's data in KB units.
//
DWORD   PutCounterDWKB (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            wsprintf (szTemp, TEXT("%ld KB"), *pdwData/1024);
            SetDlgItemText (hWnd, dwItemID, szTemp);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }
}




//*********************************************************************
//
//      PutCounterHEX
//
//  Display a DWORD counter's data in hex.
//
DWORD   PutCounterHEX  (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            wsprintf (szTemp, TEXT("0x%08x"), *pdwData);
            SetDlgItemText (hWnd, dwItemID, szTemp);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }

}




//*********************************************************************
//
//      PutCounterDWKB
//
//  Display a DWORD counter's data.
//
DWORD   PutCounterDW   (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            SetDlgItemInt (hWnd, dwItemID, *pdwData, FALSE);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }

}




//*********************************************************************
//
//      PaintAddressSpace
//
//
void    PaintAddressSpace  (HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj,
                            DWORD           TotalID,
                            DWORD           NoAccessID,
                            DWORD           NoAccessIndex,
                            DWORD           ReadOnlyID,
                            DWORD           ReadOnlyIndex,
                            DWORD           ReadWriteID,
                            DWORD           ReadWriteIndex,
                            DWORD           WriteCopyID,
                            DWORD           WriteCopyIndex,
                            DWORD           ExecuteID,
                            DWORD           ExecuteIndex1,
                            DWORD           ExecuteIndex2,
                            DWORD           ExecuteIndex3,
                            DWORD           ExecuteIndex4)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    DWORD           dwTotal = 0;
    DWORD           dwExecute = 0;
    BOOL            bCounter = FALSE;


    dwTotal += PutCounterDWKB (hMemDlg, NoAccessID,  pInst, pObj, NoAccessIndex);
    dwTotal += PutCounterDWKB (hMemDlg, ReadOnlyID,  pInst, pObj, ReadOnlyIndex);
    dwTotal += PutCounterDWKB (hMemDlg, ReadWriteID, pInst, pObj, ReadWriteIndex);
    dwTotal += PutCounterDWKB (hMemDlg, WriteCopyID, pInst, pObj, WriteCopyIndex);


    // execute is the sum of the following
    //
    if (pCounter = FindCounter (pObj, ExecuteIndex1)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex2)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex3)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex4)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (bCounter) {
        wsprintf (szTemp, TEXT("%ld KB"), dwExecute/1024);
        SetDlgItemText (hMemDlg, ExecuteID, szTemp);
    } else
        SetDlgItemText (hMemDlg, ExecuteID, NODATA);

    wsprintf (szTemp, TEXT("%ld KB"), dwTotal/1024);
    SetDlgItemText (hMemDlg, TotalID, szTemp);

}




//*********************************************************************
//
//      PaintMemDlgAddrData
//
//  Paint the memory dialog address space data.
//
void    PaintMemDlgAddrData(HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj)
{
    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALPRIVATE_COMMIT,
                       MEMORY_PRIVATE_NOACCESS,  PX_PROCESS_PRIVATE_NOACCESS,
                       MEMORY_PRIVATE_READONLY,  PX_PROCESS_PRIVATE_READONLY,
                       MEMORY_PRIVATE_READWRITE, PX_PROCESS_PRIVATE_READWRITE,
                       MEMORY_PRIVATE_WRITECOPY, PX_PROCESS_PRIVATE_WRITECOPY,
                       MEMORY_PRIVATE_EXECUTE,   PX_PROCESS_PRIVATE_EXECUTABLE,
                       PX_PROCESS_PRIVATE_EXE_READONLY,
                       PX_PROCESS_PRIVATE_EXE_READWRITE,
                       PX_PROCESS_PRIVATE_EXE_WRITECOPY);

    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALMAPPED_COMMIT,
                       MEMORY_MAPPED_NOACCESS,  PX_PROCESS_MAPPED_NOACCESS,
                       MEMORY_MAPPED_READONLY,  PX_PROCESS_MAPPED_READONLY,
                       MEMORY_MAPPED_READWRITE, PX_PROCESS_MAPPED_READWRITE,
                       MEMORY_MAPPED_WRITECOPY, PX_PROCESS_MAPPED_WRITECOPY,
                       MEMORY_MAPPED_EXECUTE,   PX_PROCESS_MAPPED_EXECUTABLE,
                       PX_PROCESS_MAPPED_EXE_READONLY,
                       PX_PROCESS_MAPPED_EXE_READWRITE,
                       PX_PROCESS_MAPPED_EXE_WRITECOPY);

    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALIMAGE_COMMIT,
                       MEMORY_IMAGE_NOACCESS,   PX_PROCESS_IMAGE_NOACCESS,
                       MEMORY_IMAGE_READONLY,   PX_PROCESS_IMAGE_READONLY,
                       MEMORY_IMAGE_READWRITE,  PX_PROCESS_IMAGE_READWRITE,
                       MEMORY_IMAGE_WRITECOPY,  PX_PROCESS_IMAGE_WRITECOPY,
                       MEMORY_IMAGE_EXECUTE,    PX_PROCESS_IMAGE_EXECUTABLE,
                       PX_PROCESS_IMAGE_EXE_READONLY,
                       PX_PROCESS_IMAGE_EXE_READWRITE,
                       PX_PROCESS_IMAGE_EXE_WRITECOPY);
}




//*********************************************************************
//
//      PaintMemDlgVMData
//
//  Paint the memory dialog Virtual Memory data.
//
void    PaintMemDlgVMData  (HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj)
{

    PutCounterDWKB (hMemDlg, MEMORY_WS,           pInst, pObj, PX_PROCESS_WORKING_SET);
    PutCounterDWKB (hMemDlg, MEMORY_PEAK_WS,      pInst, pObj, PX_PROCESS_PEAK_WS);
    PutCounterDWKB (hMemDlg, MEMORY_PRIVATE_PAGE, pInst, pObj, PX_PROCESS_PRIVATE_PAGE);
    PutCounterDWKB (hMemDlg, MEMORY_VSIZE,        pInst, pObj, PX_PROCESS_VIRTUAL_SIZE);
    PutCounterDWKB (hMemDlg, MEMORY_PEAK_VSIZE,   pInst, pObj, PX_PROCESS_PEAK_VS);
    PutCounterDWKB (hMemDlg, MEMORY_PFCOUNT,      pInst, pObj, PX_PROCESS_FAULT_COUNT);

}




//*********************************************************************
//
//      PaintPviewDlgMemoryData
//
//  Paint the memory data for pview dialog.
//
void    PaintPviewDlgMemoryData    (HWND            hPviewDlg,
                                    PPERF_INSTANCE  pInst,
                                    PPERF_OBJECT    pObj)
{
    PPERF_COUNTER   pCounter;
    TCHAR           str[20];
    DWORD           *pdwData;
    DWORD           dwData = 0;
    BOOL            bCounter = FALSE;


    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_NOACCESS)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READONLY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READWRITE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_WRITECOPY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXECUTABLE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READONLY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READWRITE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_WRITECOPY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (bCounter) {
        wsprintf (str, TEXT("%ld KB"), dwData/1024);
        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, str);
    } else
        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, NODATA);

}




//*********************************************************************
//
//      RefreshMemoryDlg
//
//  Refresh the memory detail dialog.
//
BOOL    RefreshMemoryDlg   (HWND            hMemDlg,
                            PPERF_INSTANCE  pProcessInstance,
                            PPERF_OBJECT    pProcessObject,
                            PPERF_OBJECT    pAddressObject,
                            PPERF_OBJECT    pImageObject)
{
    DWORD           *pProcessID1;
    DWORD           *pProcessID2;
    PPERF_COUNTER   pCounter1;
    PPERF_COUNTER   pCounter2;
    PPERF_INSTANCE  pAddressInstance;
    HWND            hImageList;
    TCHAR           szTemp[40];
    BOOL            bStat = FALSE;
    INT             InstIndex = 0;


    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &&
        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) {
        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1);
        if (pProcessID1) {
            wsprintf (szTemp, TEXT("%s (%#x)"), InstanceName (pProcessInstance), *pProcessID1);
            SetDlgItemText (hMemDlg, MEMORY_PROCESS_ID, szTemp);

            pAddressInstance = FirstInstance (pAddressObject);

            while (pAddressInstance && InstIndex < pAddressObject->NumInstances) {
                pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2);
                if (pProcessID2) {
                    if (*pProcessID1 == *pProcessID2) {
                        PaintMemDlgAddrData (hMemDlg, pAddressInstance, pAddressObject);
                        PaintMemDlgVMData (hMemDlg, pProcessInstance, pProcessObject);
    
                        hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE);
                        RefreshMemoryDlgImageList (hImageList, InstIndex, pImageObject);
    
                        bStat = TRUE;
                        break;
                    }
                }

                pAddressInstance = NextInstance (pAddressInstance);
                InstIndex++;
            }
        }
    }

    return bStat;

}




//*********************************************************************
//
//      RefreshMemoryDlgImageList
//
//  Refresh the image list for memory dialog.
//
void    RefreshMemoryDlgImageList  (HWND            hImageList,
                                    DWORD           ParentIndex,
                                    PPERF_OBJECT    pImageObj)
{
    PPERF_INSTANCE  pImageInst;
    INT_PTR         ListIndex;
    INT_PTR             InstIndex = 0;


    ListIndex = SendMessage (hImageList, CB_ADDSTRING, 0, (DWORD_PTR)TEXT(" Total Commit"));
    SendMessage (hImageList, CB_SETITEMDATA, ListIndex, 0xFFFFFFFF);

    if (pImageObj) {
        pImageInst = FirstInstance (pImageObj);

        while (pImageInst && InstIndex < pImageObj->NumInstances) {
            if (ParentIndex == pImageInst->ParentObjectInstance) {
                ListIndex = SendMessage (hImageList,
                                         CB_ADDSTRING,
                                         0,
                                         (LPARAM)InstanceName(pImageInst));
                SendMessage (hImageList, CB_SETITEMDATA, ListIndex, InstIndex);
            }

            pImageInst = NextInstance (pImageInst);
            InstIndex++;
        }
    }
}




//*********************************************************************
//
//      RefreshMemoryDlgImage
//
//
void RefreshMemoryDlgImage (HWND            hMemDlg,
                            DWORD           dwIndex,
                            PPERF_OBJECT    pImageObject)
{
    PPERF_INSTANCE  pInst;

    if (pInst = FindInstanceN (pImageObject, dwIndex))
        PaintAddressSpace (hMemDlg, pInst, pImageObject,
                           MEMORY_TOTALIMAGE_COMMIT,
                           MEMORY_IMAGE_NOACCESS,   PX_IMAGE_NOACCESS,
                           MEMORY_IMAGE_READONLY,   PX_IMAGE_READONLY,
                           MEMORY_IMAGE_READWRITE,  PX_IMAGE_READWRITE,
                           MEMORY_IMAGE_WRITECOPY,  PX_IMAGE_WRITECOPY,
                           MEMORY_IMAGE_EXECUTE,    PX_IMAGE_EXECUTABLE,
                           PX_IMAGE_EXE_READONLY,
                           PX_IMAGE_EXE_READWRITE,
                           PX_IMAGE_EXE_WRITECOPY);
}


//*********************************************************************
//
//      RefreshPviewDlgMemoryData
//
//  Update the memory data for pview dialog.  This should be done
//  after the ghCostlyData is collected and is not refreshing.
//
void RefreshPviewDlgMemoryData (HWND            hPviewDlg,
                                PPERF_INSTANCE  pProcessInstance,
                                PPERF_OBJECT    pProcessObject,
                                PPERF_OBJECT    pAddressObject)
{
    DWORD           *pProcessID1;
    DWORD           *pProcessID2;
    PPERF_COUNTER   pCounter1;
    PPERF_COUNTER   pCounter2;
    PPERF_INSTANCE  pAddressInstance;
    INT             i = 0;


    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &&
        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) {
        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1);
        if (pProcessID1) {
            pAddressInstance = FirstInstance (pAddressObject);
    
            while (pAddressInstance && i < pAddressObject->NumInstances) {
                pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2);
                if (pProcessID2){
                    if (*pProcessID1 == *pProcessID2) {
                        PaintPviewDlgMemoryData (hPviewDlg, pAddressInstance, pAddressObject);
                        break;
                    }
        
                    pAddressInstance = NextInstance (pAddressInstance);
                    i++;
                }
            }
        }
    }
}




//*********************************************************************
//
//      RefreshPviewDlgThreadPC
//
//  Update the thread PC value.  This should be done after the ghCostlyData
//  is collected and is no refreshing.
//
void RefreshPviewDlgThreadPC   (HWND            hPviewDlg,
                                LPTSTR          szProcessName,
                                LPTSTR          szThreadName,
                                PPERF_OBJECT    pThreadDetailsObject,
                                PPERF_DATA      pCostlyData)
{
    PPERF_COUNTER   pCounter;
    PPERF_INSTANCE  pInstance;
    PPERF_INSTANCE  pParent;
    LPTSTR          szInstanceName;
    LPTSTR          szParentName;
    TCHAR           str[20];
    DWORD           *pdwData;
    INT             i = 0;


    if (pCounter = FindCounter (pThreadDetailsObject, PX_THREAD_PC)) {
        pInstance = FirstInstance (pThreadDetailsObject);

        while (pInstance && i < pThreadDetailsObject->NumInstances) {
            if (!(szInstanceName = InstanceName (pInstance)))
                // can't find name
                ;
            else if (lstrcmp (szThreadName, szInstanceName))
                // the thread name is different
                ;
            else if (!(pParent = FindInstanceParent (pInstance, pCostlyData)))
                // can't find parent
                ;
            else if (!(szParentName = InstanceName (pParent)))
                // can't find parent's name
                ;
            else if (!lstrcmp (szProcessName, szParentName)) {
                // Parent's name matches, this is the right one.
                //

                pdwData = CounterData (pInstance, pCounter);
                if (pdwData) {
                    wsprintf (str, TEXT("0x%08x"), *pdwData);
                    SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, str);
                }

                return;
            }

            pInstance = NextInstance (pInstance);
            i++;
        }
    }


    // We are here only because we can't find the data to display.
    //

    SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, NODATA);

}




//*********************************************************************
//
//      ProcessPriority
//
//  Returns the process priority dialog item id.
//
WORD    ProcessPriority    (PPERF_OBJECT    pObject,
                            PPERF_INSTANCE  pInstance)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;


    if (pCounter = FindCounter (pObject, PX_PROCESS_PRIO)) {
        pdwData = (DWORD *) CounterData (pInstance, pCounter);
        if (pdwData) {

            if (*pdwData < 7)
                return PVIEW_PRIORITY_IDL;
            else if (*pdwData < 10)
                return PVIEW_PRIORITY_NORMAL;
            else
                return PVIEW_PRIORITY_HIGH;
        } else {
            return PVIEW_PRIORITY_NORMAL;
        }
    } else
        return PVIEW_PRIORITY_NORMAL;
}




//*********************************************************************
//
//      RefreshPerfData
//
//  Get a new set of performance data.  pData should be NULL initially.
//
PPERF_DATA RefreshPerfData (HKEY        hPerfKey,
                            LPTSTR      szObjectIndex,
                            PPERF_DATA  pData,
                            DWORD       *pDataSize)
{
    if (GetPerfData (hPerfKey, szObjectIndex, &pData, pDataSize) == ERROR_SUCCESS)
        return pData;
    else
        return NULL;
}




//*********************************************************************
//
//      SetProcessListText
//
//  Format the process list text.
//
void SetProcessListText (PPERF_INSTANCE pInst,
                         PPERF_COUNTER  pCPU,
                         PPERF_COUNTER  pPRIV,
                         PPERF_COUNTER  pProcID,
                         double         fTime,
                         LPTSTR         str)
{
    DWORD           *pdwProcID;
    LARGE_INTEGER   *liCPU;
    LARGE_INTEGER   *liPRIV;
    double          fCPU = 0;
    double          fPRIV = 0;
    INT             PcntPRIV = 0;
    INT             PcntUSER = 0;
    TIME_FIELD      TimeFld;
    TCHAR           szTemp[100];


    if (pCPU) {
        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU);
        if (liCPU) {
            fCPU  = Li2Double (*liCPU);
        }
    }

    if (pPRIV) {
        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV);
        if (liPRIV) 
            fPRIV  = Li2Double (*liPRIV);
    }

    if (fCPU > 0) {
        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5);
        PcntUSER = 100 - PcntPRIV;
    }



    if (pProcID) {
        pdwProcID = (DWORD *) CounterData (pInst, pProcID);
        if (pdwProcID) 
            wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), *pdwProcID);
        else
            wcscpy (szTemp, InstanceName(pInst));
    } else
        wcscpy (szTemp, InstanceName(pInst));



    FormatTimeFields (fCPU/1.0e7, &TimeFld);

    wsprintf (str,
              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld%%"),
              szTemp,
              TimeFld.Hours,
              TimeFld.Mins,
              TimeFld.Secs,
              TimeFld.mSecs,
              PcntPRIV,
              PcntUSER);
}




//*********************************************************************
//
//      RefreshProcessList
//
//  Find all process and update the process list.
//
void RefreshProcessList (HWND           hProcessList,
                         PPERF_OBJECT   pObject)
{
    PPERF_INSTANCE  pInstance;
    TCHAR           szListText[256];
    INT_PTR         ListIndex;

    PPERF_COUNTER   pCounterCPU;
    PPERF_COUNTER   pCounterPRIV;
    PPERF_COUNTER   pCounterProcID;
    double          fObjectFreq;
    double          fObjectTime;
    double          fTime;

    INT             InstanceIndex = 0;

    if (pObject) {
        if ((pCounterCPU    = FindCounter (pObject, PX_PROCESS_CPU))  &&
            (pCounterPRIV   = FindCounter (pObject, PX_PROCESS_PRIV)) &&
            (pCounterProcID = FindCounter (pObject, PX_PROCESS_ID))) {

            fObjectFreq = Li2Double (pObject->PerfFreq);
            fObjectTime = Li2Double (pObject->PerfTime);
            fTime = fObjectTime / fObjectFreq;

            pInstance = FirstInstance (pObject);

            while (pInstance && InstanceIndex < pObject->NumInstances) {
                SetProcessListText (pInstance,
                                    pCounterCPU,
                                    pCounterPRIV,
                                    pCounterProcID,
                                    fTime,
                                    szListText);

                ListIndex = SendMessage (hProcessList, LB_ADDSTRING, 0, (LPARAM)szListText);
                SendMessage (hProcessList, LB_SETITEMDATA, ListIndex, InstanceIndex);

                pInstance = NextInstance (pInstance);
                InstanceIndex++;
            }
        }
    }
}




//*********************************************************************
//
//      RefreshProcessData
//
//  Find data for a given process and update.
//
void RefreshProcessData    (HWND            hWnd,
                            PPERF_OBJECT    pObject,
                            DWORD           ProcessIndex)
{
    PPERF_INSTANCE  pInstance;


    if (pInstance = FindInstanceN (pObject, ProcessIndex)) {
        PutCounterDWKB (hWnd, PVIEW_WS, pInstance, pObject, PX_PROCESS_WORKING_SET);


        SetDlgItemText (hWnd, PVIEW_TOTALPRIVATE_COMMIT, NODATA);

        // set priority
        //
        CheckRadioButton (hWnd,
                          PVIEW_PRIORITY_HIGH,
                          PVIEW_PRIORITY_IDL,
                          ProcessPriority (pObject, pInstance));
    }
}




//*********************************************************************
//
//      SetThreadListText
//
//  Format the thread list text.
//
void SetThreadListText (PPERF_INSTANCE  pInst,
                        PPERF_COUNTER   pCPU,
                        PPERF_COUNTER   pPRIV,
                        double          fTime,
                        LPTSTR          str)
{
    LARGE_INTEGER   *liCPU;
    LARGE_INTEGER   *liPRIV;
    double          fCPU = 0;
    double          fPRIV = 0;
    INT             PcntPRIV = 0;
    INT             PcntUSER = 0;
    TIME_FIELD      TimeFld;
    TCHAR           szTemp[100];


    if (pCPU) {
        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU);
        if (liCPU)
            fCPU  = Li2Double (*liCPU);
    }

    if (pPRIV) {
        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV);
        if (liPRIV)
            fPRIV  = Li2Double (*liPRIV);
    }

    if (fCPU > 0) {
        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5);
        PcntUSER = 100 - PcntPRIV;
    }



    if (pInst->UniqueID != PERF_NO_UNIQUE_ID)
        wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), pInst->UniqueID);
    else
        wcscpy (szTemp, InstanceName(pInst));




    FormatTimeFields (fCPU/1.0e7, &TimeFld);

    wsprintf (str,
              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld %%"),
              szTemp,
              TimeFld.Hours,
              TimeFld.Mins,
              TimeFld.Secs,
              TimeFld.mSecs,
              PcntPRIV,
              PcntUSER);

}




//*********************************************************************
//
//      RefreshThreadList
//
//  Find all threads for a given process and update the thread list.
//
void RefreshThreadList (HWND            hThreadList,
                        PPERF_OBJECT    pObject,
                        DWORD           ParentIndex)
{
    PPERF_INSTANCE  pInstance;
    TCHAR           szListText[256];
    INT_PTR         ListIndex;

    PPERF_COUNTER   pCounterCPU;
    PPERF_COUNTER   pCounterPRIV;
    double          fObjectFreq;
    double          fObjectTime;
    double          fTime;

    INT             InstanceIndex = 0;

    if (pObject) {
        if ((pCounterCPU  = FindCounter (pObject, PX_THREAD_CPU)) &&
            (pCounterPRIV = FindCounter (pObject, PX_THREAD_PRIV))) {

            fObjectFreq = Li2Double (pObject->PerfFreq);
            fObjectTime = Li2Double (pObject->PerfTime);
            fTime = fObjectTime / fObjectFreq;


            pInstance = FirstInstance (pObject);

            while (pInstance && InstanceIndex < pObject->NumInstances) {
                if (ParentIndex == pInstance->ParentObjectInstance) {
                    SetThreadListText (pInstance,
                                       pCounterCPU,
                                       pCounterPRIV,
                                       fTime,
                                       szListText);

                    ListIndex = SendMessage (hThreadList,
                                             LB_INSERTSTRING,
                                             (WPARAM)-1,
                                             (LPARAM)szListText);
                    SendMessage (hThreadList, LB_SETITEMDATA, ListIndex, InstanceIndex);
                }

                pInstance = NextInstance (pInstance);
                InstanceIndex++;
            }
        }
    }

}




//*********************************************************************
//
//      RefreshThreadData
//
//  Find data for a given thread and update.
//
void RefreshThreadData (HWND              hWnd,
                        PPERF_OBJECT      pThreadObj,
                        DWORD             ThreadIndex,
                        PPERF_OBJECT      pProcessObj,
                        PPERF_INSTANCE    pProcessInst)
{
    PPERF_INSTANCE  pInstance;
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    DWORD           *pdwProcPrio;
    BOOL            bPrioCounter = TRUE;



    if (pInstance = FindInstanceN (pThreadObj, ThreadIndex)) {
        SetDlgItemText (hWnd, PVIEW_THREAD_PC, NODATA);

        PutCounterHEX (hWnd, PVIEW_THREAD_START,    pInstance, pThreadObj, PX_THREAD_START);
        PutCounterDW  (hWnd, PVIEW_THREAD_SWITCHES, pInstance, pThreadObj, PX_THREAD_SWITCHES);
        PutCounterDW  (hWnd, PVIEW_THREAD_DYNAMIC,  pInstance, pThreadObj, PX_THREAD_PRIO);
    }




    if (pInstance) {
        // get thread base priority
        //

        if (pCounter = FindCounter (pThreadObj, PX_THREAD_BASE_PRIO)) {
            pdwData = CounterData (pInstance, pCounter);
            if (!pdwData) {
                bPrioCounter = FALSE;
            }
        } else
            bPrioCounter = FALSE;


        // get process priority
        //

        if (pCounter = FindCounter (pProcessObj, PX_PROCESS_PRIO)) {
            pdwProcPrio = CounterData (pProcessInst, pCounter);
            if (!pdwProcPrio) {
                bPrioCounter = FALSE;
            }
        } else
            bPrioCounter = FALSE;
    } else
        bPrioCounter = FALSE;





    // set thread base priority
    //

    if (!bPrioCounter)
        CheckRadioButton (hWnd,
                          PVIEW_THREAD_HIGHEST,
                          PVIEW_THREAD_LOWEST,
                          PVIEW_THREAD_NORMAL);
    else {
        switch (*pdwData - *pdwProcPrio) {
            case 2:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_HIGHEST);
                break;

            case 1:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_ABOVE);
                break;

            case -1:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_BELOW);
                break;

            case -2:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_LOWEST);
                break;

            case 0:
                default:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_NORMAL);
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\objdata.c ===
/******************************************************************************

                                O B J E C T   D A T A

    Name:       objdata.c

    Description:
        This module contains functions that access objects in performance
        data.

    Functions:
        FirstObject
        NextObject
        FindObject
        FindObjectN

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstObject
//
//      Returns pointer to the first object in pData.
//      If pData is NULL then NULL is returned.
//
PPERF_OBJECT FirstObject (PPERF_DATA pData)
{
    if (pData)
        return ((PPERF_OBJECT) ((PBYTE) pData + pData->HeaderLength));
    else
        return NULL;
}




//*********************************************************************
//
//  NextObject
//
//      Returns pointer to the next object following pObject.
//
//      If pObject is the last object, bogus data maybe returned.
//      The caller should do the checking.
//
//      If pObject is NULL, then NULL is returned.
//
PPERF_OBJECT NextObject (PPERF_OBJECT pObject)
{
    if (pObject)
        return ((PPERF_OBJECT) ((PBYTE) pObject + pObject->TotalByteLength));
    else
        return NULL;
}




//*********************************************************************
//
//  FindObject
//
//      Returns pointer to object with TitleIndex.  If not found, NULL
//      is returned.
//
PPERF_OBJECT FindObject (PPERF_DATA pData, DWORD TitleIndex)
{
PPERF_OBJECT pObject;
DWORD        i = 0;

    if (pObject = FirstObject (pData))
        while (i < pData->NumObjectTypes)
            {
            if (pObject->ObjectNameTitleIndex == TitleIndex)
                return pObject;

            pObject = NextObject (pObject);
            i++;
            }

    return NULL;
}




//*********************************************************************
//
//  FindObjectN
//
//      Find the Nth object in pData.  If not found, NULL is returned.
//      0 <= N < NumObjectTypes.
//
PPERF_OBJECT FindObjectN (PPERF_DATA pData, DWORD N)
{
PPERF_OBJECT pObject;
DWORD        i = 0;

    if (!pData)
        return NULL;
    else if (N >= pData->NumObjectTypes)
        return NULL;
    else
        {
        pObject = FirstObject (pData);

        while (i != N)
            {
            pObject = NextObject (pObject);
            i++;
            }

        return pObject;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\pviewdlg.h ===
#define PVIEW_DLG                   100
#define PVIEW_EXIT                  101
#define PVIEW_MEMORY_DETAIL         102
#define PVIEW_TERMINATE             103
#define PVIEW_REFRESH               104
#define PVIEW_COMPUTER              105
#define PVIEW_CONNECT               106
#define PVIEW_PROCESS_LIST          107
#define PVIEW_WS                    108
#define PVIEW_TOTALPRIVATE_COMMIT   109
#define PVIEW_PRIORITY_HIGH         110
#define PVIEW_PRIORITY_NORMAL       111
#define PVIEW_PRIORITY_IDL          112
#define PVIEW_THREAD_HIGHEST        113
#define PVIEW_THREAD_ABOVE          114
#define PVIEW_THREAD_NORMAL         115
#define PVIEW_THREAD_BELOW          116
#define PVIEW_THREAD_LOWEST         117
#define PVIEW_THREAD_LIST           118
#define PVIEW_THREAD_PC             119
#define PVIEW_THREAD_START          120
#define PVIEW_THREAD_SWITCHES       121
#define PVIEW_THREAD_DYNAMIC        122
#define MEMORY_DLG                  1000
#define MEMORY_PROCESS_ID           1001
#define MEMORY_IMAGE_EXECUTE        1002
#define MEMORY_IMAGE_WRITECOPY      1003
#define MEMORY_IMAGE_READWRITE      1004
#define MEMORY_TOTALIMAGE_COMMIT    1005
#define MEMORY_IMAGE_NOACCESS       1006
#define MEMORY_IMAGE_READONLY       1007
#define MEMORY_TOTALMAPPED_COMMIT   1008
#define MEMORY_MAPPED_NOACCESS      1009
#define MEMORY_MAPPED_READONLY      1010
#define MEMORY_MAPPED_READWRITE     1011
#define MEMORY_MAPPED_WRITECOPY     1012
#define MEMORY_MAPPED_EXECUTE       1013
#define MEMORY_TOTALPRIVATE_COMMIT  1014
#define MEMORY_PRIVATE_NOACCESS     1015
#define MEMORY_PRIVATE_READONLY     1016
#define MEMORY_PRIVATE_READWRITE    1017
#define MEMORY_PRIVATE_WRITECOPY    1018
#define MEMORY_PRIVATE_EXECUTE      1019
#define MEMORY_WS                   1020
#define MEMORY_PEAK_WS              1021
#define MEMORY_PRIVATE_PAGE         1022
#define MEMORY_VSIZE                1023
#define MEMORY_PEAK_VSIZE           1024
#define MEMORY_PFCOUNT              1025
#define MEMORY_PAGED                1026
#define MEMORY_PEAK_PAGED           1027
#define MEMORY_NONPAGED             1028
#define MEMORY_QPGPEAK              1029
#define MEMORY_QNONPEAK             1030
#define MEMORY_QPGCUR               1031
#define MEMORY_QNONCUR              1032
#define MEMORY_QPGLIM               1033
#define MEMORY_QNONLIM              1034
#define PVIEW_PROCESS_PRIORITY      124
#define PVIEW_THREAD_PRIORITY       123
#define MEMORY_IMAGE                1035
#define MEMORY_REFRESH              2000
#define MEMORY_REFRESH_ALL          2002
#define PVIEW_REFRESH_COSTLY_DATA   2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rc\output.cpp ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include "output.h"

bool fStdOutConsole;

bool FIsConsole(FILE *fd)
{
   int fh = _fileno(fd);

   HANDLE hFile = (HANDLE) _get_osfhandle(fh);

   DWORD dwType = GetFileType(hFile);

   if (dwType != FILE_TYPE_CHAR) {
        return false;
   }

   switch (fh) {
       case 0 :
           hFile = GetStdHandle(STD_INPUT_HANDLE);
           break;

       case 1 :
           hFile = GetStdHandle(STD_OUTPUT_HANDLE);
           break;

       case 2 :
           hFile = GetStdHandle(STD_ERROR_HANDLE);
           break;
    }

    DWORD dwMode;

    if (!GetConsoleMode(hFile, &dwMode)) {
        return false;
    }

    return true;
}


int ConsoleVprintf(const wchar_t *szFormat, va_list valist)
{
    // UNDONE: This exists only because the CRT lacks a va_list cwprintf variant

    int cch = _vscwprintf(szFormat, valist);

    wchar_t *sz = (wchar_t *) malloc((cch + 1) * sizeof(wchar_t));
    if (sz) {
        vswprintf(sz, szFormat, valist);
    
        _cputws(sz);
        free(sz);
    }

    return cch;
}


void OutputInit()
{
    if (FIsConsole(stdout)) {
        fStdOutConsole = true;
    }
}


int StdOutFlush()
{
    if (fStdOutConsole) {
        return 0;
    }

    return fflush(stdout);
}


int __cdecl StdOutPrintf(const wchar_t *szFormat, ...)
{
    va_list valist;

    va_start(valist, szFormat);

    int ret = StdOutVprintf(szFormat, valist);

    va_end(valist);

    return ret;
}


int StdOutPutc(wchar_t ch)
{
    if (fStdOutConsole) {
        return _putwch(ch);
    }

    return fputwc(ch, stdout);
}


int StdOutPuts(const wchar_t *sz)
{
    if (fStdOutConsole) {
        return _cputws(sz);
    }

    return fputws(sz, stdout);
}


int StdOutVprintf(const wchar_t *szFormat, va_list valist)
{
    if (fStdOutConsole) {
        return ConsoleVprintf(szFormat, valist);
    }

    return vfwprintf(stdout, szFormat, valist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\pviewer.c ===
/******************************************************************************

                        P R O C E S S   V I E W E R

    Name:       pviewer.c

    Description:
        This program demonstrates the usage of special registry APIs
        for collecting performance data.

        C files used in this app:
            pviewer.c       - this file
            pviewdat.c      - updates the dialog
            perfdata.c      - gets performance data structures
            objdata.c       - access performance data objects
            instdata.c      - access performance data instances
            cntrdata.c      - access performance data counters

******************************************************************************/




#include <windows.h>
#include <winperf.h>
#include "perfdata.h"
#include "pviewdat.h"
#include "pviewdlg.h"
#include <string.h>
#include <stdio.h>



#define INDEX_STR_LEN       10
#define MACHINE_NAME_LEN    MAX_COMPUTERNAME_LENGTH+2
#define MACHINE_NAME_SIZE   MACHINE_NAME_LEN+1


/****
Globals
****/

TCHAR           INDEX_PROCTHRD_OBJ[2*INDEX_STR_LEN];
TCHAR           INDEX_COSTLY_OBJ[3*INDEX_STR_LEN];

TCHAR           gszMachineName[MACHINE_NAME_SIZE];
TCHAR           gszCurrentMachine[MACHINE_NAME_SIZE];

DWORD           gPerfDataSize = 50*1024;            // start with 50K
PPERF_DATA      gpPerfData;

DWORD           gCostlyDataSize = 100*1024;         // start wiih 100K
PPERF_DATA      gpCostlyData;


PPERF_OBJECT    gpProcessObject;                    // pointer to process objects
PPERF_OBJECT    gpThreadObject;                     // pointer to thread objects
PPERF_OBJECT    gpThreadDetailsObject;              // pointer to thread detail objects
PPERF_OBJECT    gpAddressSpaceObject;               // pointer to address space objects
PPERF_OBJECT    gpImageObject;                      // pointer to image objects


HKEY            ghPerfKey = HKEY_PERFORMANCE_DATA;  // get perf data from this key
HKEY            ghMachineKey = HKEY_LOCAL_MACHINE;  // get title index from this key


HCURSOR         ghCursor[2];                        // 0 = arrow, 1 = hourglass

HANDLE          ghMemUpdateEvent;                   // to signal a refresh of mem stats
HANDLE          ghMemUpdateMutex;                   // to restrict overlapping refreshes

HINSTANCE       ghInstance;                         // handle for pviewer app



/****
Prototypes
****/

INT_PTR CALLBACK   PviewDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void    PviewDlgRefresh (HWND hWnd);
void    PviewDlgRefreshCostlyData (HWND hPviewDlg);
void    PviewDlgRefreshProcess (HWND hWnd);
void    PviewDlgRefreshThread (HWND hWnd);
void    PviewDlgRefreshCurSelProcess (HWND hWnd);
void    PviewDlgRefreshCurSelThread (HWND hWnd);
WORD    PviewDlgGetCurSelPriority (HWND hWnd);
BOOL    PviewDlgChangePriority (HWND hWnd, WPARAM wParam, WORD wItem);
BOOL    PviewDlgTerminateProcess (HWND hPviewDlg);

INT_PTR CALLBACK   MemDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void    MemDlgUpdateThread (HWND hWnd);
void    MemDlgRefresh (HWND hWnd, HWND hPviewDlg);
void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg);

INT     GetCurSelText (HWND hList, LPTSTR str);
DWORD   GetCurSelData (HWND hWnd, DWORD dwList);
INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str);
void    SetPerfIndexes (HWND hWnd);
DWORD   GetTitleIdx (HWND hWnd, LPTSTR TitleSz[], DWORD LastIndex, LPTSTR Name);
void    SetListBoxTabStops (HWND hWnd);
void    SetLocalMachine (void);
BOOL    ConnectComputer (HWND hWnd);
void    DisableControls (HWND hPviewDlg);
void    EnableControls (HWND hPviewDlg);




//********************************************************
//
//  WinMain --
//
//      Build Up: create the program's dialog box,
//          load the desired icons, enter the message
//          loop.
//
//      Tear Down: free up the memory allocated by the
//          dialog box proc, and exit.
//
int WINAPI WinMain (HINSTANCE   hInstance,
                    HINSTANCE   hPrevInstance,
                    LPSTR       lpCmdLine,
                    int         nCmdShow)
{
    HANDLE  hWndDialog;
    MSG     msg;


    ghInstance = hInstance;


    // load our default cursors
    //
    ghCursor[0] = LoadCursor (0, IDC_ARROW);
    ghCursor[1] = LoadCursor (0, IDC_WAIT);

    // open our dialog box
    //
    hWndDialog = CreateDialogParam (hInstance,
                                    MAKEINTRESOURCE (PVIEW_DLG),
                                    NULL,
                                    PviewDlgProc,
                                    0);

    // the almighty Windows message loop:
    //
    while (GetMessage (&msg, NULL, 0, 0))
        if (!IsDialogMessage (hWndDialog, &msg)) {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }

        // close up shop
        //
    DestroyWindow (hWndDialog);
    LocalFree (gpPerfData);

    return 0;
}




/*****************
PviewDlg functions
*****************/

//********************************************************
//
//  PviewDlgProc --
//
//      Pview dialog procedure
//
INT_PTR CALLBACK   PviewDlgProc   (HWND    hWnd,
                                   UINT    wMsg,
                                   WPARAM  wParam,
                                   LPARAM  lParam)
{
    WORD    wItem;
    MSG     Msg;


    switch (wMsg) {

        case WM_INITDIALOG:
            SetClassLongPtr (hWnd, GCLP_HICON, (LONG_PTR)LoadIcon(ghInstance, TEXT("VIEWPICON")) );
            SetListBoxTabStops (hWnd);
            SendDlgItemMessage (hWnd, PVIEW_COMPUTER, EM_LIMITTEXT, MACHINE_NAME_LEN, 0);
            PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH, 0);
            break;

        case WM_CLOSE:
            PostQuitMessage (0);
            break;

        case WM_COMMAND:
            //
            // handle our app-specific controls:
            //
            switch (LOWORD (wParam)) {
                // works just like "close"
                //
                case PVIEW_EXIT:
                    PostQuitMessage (0);
                    break;

                    // if somebody moved the highlight in the thread list,
                    //  update the view
                    //
                case PVIEW_THREAD_LIST:
                    if (HIWORD(wParam) == LBN_DBLCLK || HIWORD(wParam) == LBN_SELCHANGE) {
                        PviewDlgRefreshCurSelThread (hWnd);
                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);
                    }
                    break;

                    // if somebody clicked on a new process, update all of the
                    //  affected information.
                    //
                case PVIEW_PROCESS_LIST:
                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) {
                        PviewDlgRefreshCurSelProcess (hWnd);
                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);
                        if (HIWORD(wParam) == CBN_DBLCLK)
                            PostMessage (hWnd, WM_COMMAND, PVIEW_MEMORY_DETAIL, 0);
                    }
                    break;

                    // the user wishes to view the memory stats in detail:
                    //
                case PVIEW_MEMORY_DETAIL:
                    //
                    // check to see if we can get exclusive access
                    //  to the memory statistics
                    //
                    if (WaitForSingleObject (ghMemUpdateMutex, 0))

                        // we can't, so just return.
                        //
                        return FALSE;

                    else {
                        // we have exclusive access, so start up the
                        //  memory statistics dialog.
                        //
                        // release the mutex first so the dialog can use it.
                        //
                        ReleaseMutex (ghMemUpdateMutex);
                        DialogBoxParam (NULL,
                                        MAKEINTRESOURCE (MEMORY_DLG),
                                        hWnd,
                                        MemDlgProc,
                                        (LPARAM)hWnd);
                    }
                    break;

                    // somebody clicked one of the priority radio
                    //  buttons.  Find out which one was selected...
                    //
                case PVIEW_PRIORITY_HIGH:
                case PVIEW_PRIORITY_NORMAL:
                case PVIEW_PRIORITY_IDL:

                    if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_HIGH, BM_GETCHECK, 0, 0))
                        wItem = PVIEW_PRIORITY_HIGH;
                    else if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_NORMAL, BM_GETCHECK, 0, 0))
                        wItem = PVIEW_PRIORITY_NORMAL;
                    else
                        wItem = PVIEW_PRIORITY_IDL;

                    // if the user actually clicked on a NEW state,
                    //  do the change.
                    //
                    if (LOWORD(wParam) != wItem) {
                        // of course, if it's a remote machine, disallow
                        //  the modification.
                        //
                        if (lstrcmp (gszCurrentMachine, gszMachineName)) {
                            SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
                            SetFocus (GetDlgItem (hWnd, wItem));
                            MessageBox (hWnd,
                                        TEXT("Cannot change process priority on remote machine"),
                                        TEXT("Set priority"),
                                        MB_ICONEXCLAMATION|MB_OK);
                        }

                        // at this point, we know we are affecting the local
                        //  machine, and a change has to be made.
                        //  Just Do It(TM).
                        //
                        else if (PviewDlgChangePriority (hWnd, wParam, wItem))
                            PviewDlgRefresh (hWnd);

                    }
                    break;

                case PVIEW_THREAD_HIGHEST:
                case PVIEW_THREAD_ABOVE:
                case PVIEW_THREAD_NORMAL:
                case PVIEW_THREAD_BELOW:
                case PVIEW_THREAD_LOWEST:
                    //
                    // this selection hasn't been fleshed out yet.
                    //
                    PviewDlgRefreshCurSelThread (hWnd);
                    break;

                    // terminate the selected process
                    //
                case PVIEW_TERMINATE:
                    if (PviewDlgTerminateProcess (hWnd))
                        PviewDlgRefresh (hWnd);
                    break;

                    // if the text has changed, we want to connect and
                    //  view another system's processes...
                    //
                case PVIEW_COMPUTER:
                    if (HIWORD(wParam) == EN_CHANGE)
                        EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), TRUE);
                    else
                        return FALSE;
                    break;

                    // we were told to connect, go ahead and try...
                    //
                case PVIEW_CONNECT:
                    if (ConnectComputer (hWnd)) {
                        SetPerfIndexes (hWnd);
                        PviewDlgRefresh (hWnd);
                    }
                    break;

                    // refresh the current information displayed
                    //
                case PVIEW_REFRESH:
                    if (ConnectComputer (hWnd))
                        SetPerfIndexes (hWnd);
                    PviewDlgRefresh (hWnd);
                    break;

                    // refresh the currently updated costly
                    //  statistics
                    //
                case PVIEW_REFRESH_COSTLY_DATA:
                    if (WaitForSingleObject (ghMemUpdateMutex, 0))
                        return FALSE;

                    PviewDlgRefreshCostlyData (hWnd);
                    ReleaseMutex (ghMemUpdateMutex);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}




//********************************************************
//
//  PviewDlgRefresh --
//
//      Refresh the pview dialog.
//
void    PviewDlgRefresh (HWND hWnd)
{
    static  HANDLE  hMemUpdateThread = NULL;
    static  DWORD   MemUpdateThreadID;
    MSG     Msg;


    SetCursor (ghCursor[1]);


    if (hMemUpdateThread)       // get memory data
        SetEvent (ghMemUpdateEvent);
    else
        hMemUpdateThread = CreateThread (NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE)MemDlgUpdateThread,
                                         (LPVOID)hWnd,
                                         0,
                                         &MemUpdateThreadID);


    // get performance data
    //
    gpPerfData = RefreshPerfData (ghPerfKey, INDEX_PROCTHRD_OBJ, gpPerfData, &gPerfDataSize);

    gpProcessObject = FindObject (gpPerfData, PX_PROCESS);
    gpThreadObject  = FindObject (gpPerfData, PX_THREAD);


    // refresh
    //
    PviewDlgRefreshProcess (hWnd);
    PviewDlgRefreshThread (hWnd);



    // Remove all mouse and key messages. They are not accepted
    //  while the cursor is a hourglass.
    //
    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE));

    SetCursor (ghCursor[0]);

}




//********************************************************
//
//  PviewDlgRefreshCostlyData --
//
//      Refresh the costly data.
//
void    PviewDlgRefreshCostlyData (HWND hPviewDlg)
{
    LPTSTR          szProcessName;
    LPTSTR          szThreadName;
    PPERF_INSTANCE  pInstance;
    DWORD           dwIndex;


    dwIndex       = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInstance     = FindInstanceN (gpProcessObject, dwIndex);
    szProcessName = InstanceName (pInstance);

    RefreshPviewDlgMemoryData (hPviewDlg,
                               pInstance,
                               gpProcessObject,
                               gpAddressSpaceObject);


    dwIndex      = GetCurSelData (hPviewDlg, PVIEW_THREAD_LIST);
    pInstance    = FindInstanceN (gpThreadObject, dwIndex);
    szThreadName = InstanceName (pInstance);

    RefreshPviewDlgThreadPC (hPviewDlg,
                             szProcessName,
                             szThreadName ? szThreadName : TEXT("UNKNOWN"),
                             gpThreadDetailsObject,
                             gpCostlyData);

}




//********************************************************
//
//  PviewDlgRefreshProcess --
//
//      Refresh the process list and data in pview dialog.
//
void    PviewDlgRefreshProcess (HWND hWnd)
{
    TCHAR   szProcessString[256];
    INT     nProcess;
    INT     nIndex;
    HWND    hProcessList;
    DWORD   dwProcessIndex;


    // refresh process list
    //
    hProcessList = GetDlgItem (hWnd, PVIEW_PROCESS_LIST);
    nProcess     = GetCurSelText (hProcessList, szProcessString);

    SendMessage (hProcessList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hProcessList, LB_RESETCONTENT, 0, 0);
    SendMessage (hProcessList, LB_SETITEMDATA, 0, 0);


    RefreshProcessList (hProcessList, gpProcessObject);

    // refresh process data
    //
    if (nProcess != LB_ERR)
        nIndex = ReSelectText (hProcessList, nProcess, szProcessString);
    else
        nIndex = 0;


    dwProcessIndex = (DWORD)SendMessage (hProcessList, LB_GETITEMDATA, nIndex, 0);

    RefreshProcessData (hWnd, gpProcessObject, dwProcessIndex);

    SendMessage (hProcessList, WM_SETREDRAW, TRUE, 0);

}




//********************************************************
//
//  PviewDlgRefreshThread --
//
//      Refresh the thread list and data in pview dialog.
//
void    PviewDlgRefreshThread (HWND hWnd)
{
    TCHAR           szThreadString[256];
    INT             nThread;
    INT             nIndex;
    HWND            hThreadList;
    DWORD           dwThreadIndex;

    PPERF_INSTANCE  pProcessInstance;
    DWORD           dwProcessIndex;


    // get process info
    //
    dwProcessIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pProcessInstance = FindInstanceN (gpProcessObject, dwProcessIndex);


    // refresh thread list
    //
    hThreadList  = GetDlgItem (hWnd, PVIEW_THREAD_LIST);
    nThread      = GetCurSelText (hThreadList, szThreadString);

    SendMessage (hThreadList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hThreadList, LB_RESETCONTENT, 0, 0);
    SendMessage (hThreadList, LB_SETITEMDATA, 0, 0);

    RefreshThreadList (hThreadList, gpThreadObject, dwProcessIndex);


    // refresh thread data
    //
    if (nThread != LB_ERR)
        nIndex = ReSelectText (hThreadList, nThread, szThreadString);
    else
        nIndex = 0;

    dwThreadIndex    = (DWORD)SendMessage (hThreadList, LB_GETITEMDATA, nIndex, 0);

    RefreshThreadData (hWnd,
                       gpThreadObject,
                       dwThreadIndex,
                       gpProcessObject,
                       pProcessInstance);

    SendMessage (hThreadList, WM_SETREDRAW, TRUE, 0);

}




//********************************************************
//
//  PviewDlgGetCurSelPriority --
//
//      Get the process priority of currently selected process.
//
WORD    PviewDlgGetCurSelPriority (HWND hWnd)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);
    return ProcessPriority (gpProcessObject, pInst);
}




//********************************************************
//
//  PviewDlgRefreshCurSelProcess --
//
//      Refresh the data of currently selected process.
//
void    PviewDlgRefreshCurSelProcess (HWND hWnd)
{
    DWORD   dwIndex;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    RefreshProcessData (hWnd, gpProcessObject, dwIndex);

    PviewDlgRefreshThread (hWnd);
}




//********************************************************
//
//  PviewDlgRefreshCurSelThread --
//
//      Refresh the data of currently selected thread.
//
void    PviewDlgRefreshCurSelThread (HWND hWnd)
{
    PPERF_INSTANCE  pProcessInstance;
    DWORD           dwIndex;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pProcessInstance = FindInstanceN (gpProcessObject, dwIndex);

    dwIndex = GetCurSelData (hWnd, PVIEW_THREAD_LIST);

    RefreshThreadData (hWnd,
                       gpThreadObject,
                       dwIndex,
                       gpProcessObject,
                       pProcessInstance);
}




//********************************************************
//
//  PviewDlgChangePriority --
//
//      Change process priority.
//
BOOL PviewDlgChangePriority (HWND hWnd, WPARAM wParam, WORD wItem)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;
    PPERF_COUNTER   pCountID;
    DWORD           *pProcessID;
    DWORD           ProcessID = 0;
    HANDLE          hProcess;
    BOOL            bStat = TRUE;



    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);


    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) {
        pProcessID = (DWORD *) CounterData (pInst, pCountID);
        if (pProcessID) {
            ProcessID = *pProcessID;
        }
    } else {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Cannot find ID for this process"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    hProcess = OpenProcess (PROCESS_SET_INFORMATION, FALSE, ProcessID);
    if (!hProcess) {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Unable to open the process; Priority not changed"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }



    switch (wParam) {
        case PVIEW_PRIORITY_HIGH:
            bStat = SetPriorityClass (hProcess, HIGH_PRIORITY_CLASS);
            break;

        case PVIEW_PRIORITY_NORMAL:
            bStat = SetPriorityClass (hProcess, NORMAL_PRIORITY_CLASS);
            break;

        case PVIEW_PRIORITY_IDL:
            bStat = SetPriorityClass (hProcess, IDLE_PRIORITY_CLASS);
            break;

        default:
            break;
    }


    CloseHandle (hProcess);

    if (!bStat) {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Unable to change priority"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    return TRUE;

}




//********************************************************
//
//  PviewDlgTerminateProcess --
//
//      Terminate the current selected process.
//
BOOL    PviewDlgTerminateProcess (HWND hPviewDlg)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;
    PPERF_COUNTER   pCountID;
    DWORD           *pProcessID;
    DWORD           ProcessID;
    HANDLE          hProcess;
    TCHAR           szTemp[50];


    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);


    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) {
        pProcessID = (DWORD *) CounterData (pInst, pCountID);
        if (pProcessID) {
            ProcessID = *pProcessID;
        }
    } else {
        MessageBox (hPviewDlg,
                    TEXT("Cannot find ID for this process"),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    wsprintf (szTemp, TEXT("Terminate process %s (ID %#x)?"),
              InstanceName (pInst), ProcessID);

    if (MessageBox (hPviewDlg, szTemp, TEXT("Terminate Process"), MB_ICONSTOP|MB_OKCANCEL) != IDOK)
        return FALSE;


    hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, ProcessID);
    if (!hProcess) {
        MessageBox (hPviewDlg,
                    TEXT("Unable to open the process; Process not terminated"),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    if (!TerminateProcess (hProcess, 99)) {
        MessageBox (hPviewDlg,
                    TEXT("Unable to terminate the process."),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);

        CloseHandle (hProcess);
        return FALSE;
    }


    CloseHandle (hProcess);

    return TRUE;

}




/***************
MemDlg functions
***************/

//********************************************************
//
//  MemDlgProc --
//
//      MemoryDlg procedure
//
INT_PTR CALLBACK   MemDlgProc (HWND    hWnd,
                               UINT    wMsg,
                               WPARAM  wParam,
                               LPARAM  lParam)
{
    static HWND hPviewDlg;


    switch (wMsg) {
        case WM_INITDIALOG:
            hPviewDlg = (HWND)lParam;
            PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0);
            break;

        case WM_QUIT:
        case WM_CLOSE:
            EndDialog (hWnd, TRUE);
            break;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                // get the memory statistics for the currently selected
                //  process/thread
                //
                case MEMORY_IMAGE:
                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) {
                        if (WaitForSingleObject (ghMemUpdateMutex, 0))
                            return FALSE;

                        MemDlgRefreshCurSelImage (hWnd, hPviewDlg);
                        ReleaseMutex (ghMemUpdateMutex);
                    } else
                        return FALSE;
                    break;

                    // refresh the current memory statistics,
                    //  retry if we can't get the mutex
                    //
                case MEMORY_REFRESH:
                    if (WaitForSingleObject (ghMemUpdateMutex, 1000)) {
                        // can't get the mutex, retry...
                        //
                        PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0);
                        return FALSE;
                    }

                    MemDlgRefresh (hWnd, hPviewDlg);
                    ReleaseMutex (ghMemUpdateMutex);
                    break;

                case IDCANCEL:
                case IDOK:
                    EndDialog (hWnd, TRUE);
                    break;

                default:
                    return FALSE;
            }
        default:
            return FALSE;
    }


    return TRUE;

}




//********************************************************
//
//  MemDlgUpdateThread --
//
//      This function runs in a separate thread to collect memory data.
//
void MemDlgUpdateThread (HWND hPviewDlg)
{

    ghMemUpdateMutex = CreateMutex (NULL, TRUE, NULL);
    ghMemUpdateEvent = CreateEvent (NULL, FALSE, FALSE, NULL);


    while (TRUE) {
        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), FALSE);


        gpCostlyData = RefreshPerfData (ghPerfKey,
                                        INDEX_COSTLY_OBJ,
                                        gpCostlyData,
                                        &gCostlyDataSize);


        gpAddressSpaceObject  = FindObject (gpCostlyData, PX_PROCESS_ADDRESS_SPACE);
        gpThreadDetailsObject = FindObject (gpCostlyData, PX_THREAD_DETAILS);
        gpImageObject         = FindObject (gpCostlyData, PX_IMAGE);


        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), TRUE);

        ReleaseMutex (ghMemUpdateMutex);

        PostMessage (hPviewDlg, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);


        WaitForSingleObject (ghMemUpdateEvent, INFINITE);
        WaitForSingleObject (ghMemUpdateMutex, INFINITE);
    }

}




//********************************************************
//
//  MemDlgRefresh --
//
//      Refresh the memory dialog.
//
void MemDlgRefresh (HWND hMemDlg, HWND hPviewDlg)
{
    HWND            hImageList;
    DWORD           dwIndex;
    BOOL            bStat;
    PPERF_INSTANCE  pInstance;


    hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE);

    SendMessage (hImageList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hImageList, CB_RESETCONTENT, 0, 0);
    SendMessage (hImageList, CB_SETITEMDATA, 0, 0);

    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInstance = FindInstanceN (gpProcessObject, dwIndex);

    bStat = RefreshMemoryDlg (hMemDlg,
                              pInstance,
                              gpProcessObject,
                              gpAddressSpaceObject,
                              gpImageObject);

    SendMessage (hImageList, WM_SETREDRAW, TRUE, 0);
    SendMessage (hImageList, CB_SETCURSEL, 0, 0);

    if (!bStat) {
        MessageBox (hMemDlg,
                    TEXT("Unable to retrieve memory detail"),
                    TEXT("Memory detail"),
                    MB_ICONSTOP|MB_OK);
        PostMessage (hMemDlg, WM_CLOSE, 0, 0);
    }

}




//********************************************************
//
//  MemDlgRefreshCurSelImage --
//
//      Refresh the current selected image for memory dialog.
//
void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg)
{
    HWND    hList;
    INT     nIndex;
    DWORD   dwIndex;


    hList = GetDlgItem (hMemDlg, MEMORY_IMAGE);
    nIndex = (INT)SendMessage (hList, CB_GETCURSEL, 0, 0);

    if (nIndex == CB_ERR)
        nIndex = 0;

    dwIndex = (DWORD)SendMessage (hList, CB_GETITEMDATA, nIndex, 0);

    if (dwIndex == 0xFFFFFFFF)
        MemDlgRefresh (hMemDlg, hPviewDlg);
    else
        RefreshMemoryDlgImage (hMemDlg, dwIndex, gpImageObject);

}




/****************
utility functions
****************/

//********************************************************
//
//  GetCurSelText --
//
//      Get the text of current selection.  Used for later ReSelectText().
//
INT     GetCurSelText (HWND hList, LPTSTR str)
{
    INT     Index;
    INT     Length;

    Index = (INT)SendMessage (hList, LB_GETCURSEL, 0, 0);
    SendMessage (hList, LB_GETTEXT, Index, (LPARAM)str);

    return Index;
}




//********************************************************
//
//  GetCurSelData --
//
//      Get the data associated with the current selection.
//
DWORD   GetCurSelData (HWND hWnd, DWORD dwList)
{
    HWND    hList;
    INT     nIndex;
    DWORD   dwIndex;


    hList  = GetDlgItem (hWnd, dwList);
    nIndex = (INT)SendMessage (hList, LB_GETCURSEL, 0, 0);

    if (nIndex == LB_ERR)
        nIndex = 0;

    dwIndex = (DWORD)SendMessage (hList, LB_GETITEMDATA, nIndex, 0);

    return dwIndex;
}




//********************************************************
//
//  ReSelectText --
//
//      Reselect the line specified by str.  Returns the new index.  If cannot
//      find the line or any error, then 0 is returned.
//
INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str)
{
    INT_PTR Index;
    INT     Length;
    TCHAR   SaveChar = TEXT('\0');


    Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (LPARAM)str);

    if (Index == LB_ERR) {
        Length = lstrlen (str);

        while (Index == LB_ERR && Length) {
            SaveChar = str[Length-1];
            str[Length-1] = TEXT('\0');

            Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (LPARAM)str);

            str[Length-1] = SaveChar;
            Length--;
        }
    }

    if (Index == LB_ERR)
        return 0;
    else {
        SendMessage (hList, LB_SETCURSEL, Index, 0);
        return (INT)Index;
    }

}




//********************************************************
//
//  SetPerfIndexes
//
//      Setup the perf data indexes.
//
void    SetPerfIndexes (HWND hWnd)
{
    LPTSTR  TitleBuffer;
    LPTSTR  *Title;
    DWORD   Last;
    TCHAR   szTemp[50];
    DWORD   dwR;


    dwR = GetPerfTitleSz (ghMachineKey, ghPerfKey, &TitleBuffer, &Title, &Last);

    if (dwR != ERROR_SUCCESS) {
        wsprintf (szTemp, TEXT("Unable to retrieve counter indexes, ERROR -> %#x"), dwR);
        MessageBox (hWnd, szTemp, TEXT("Pviewer"), MB_OK|MB_ICONEXCLAMATION);
        return;
    }


    PX_PROCESS                       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS);
    PX_PROCESS_CPU                   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_CPU);
    PX_PROCESS_PRIV                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIV);
    PX_PROCESS_USER                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_USER);
    PX_PROCESS_WORKING_SET           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_WORKING_SET);
    PX_PROCESS_PEAK_WS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_WS);
    PX_PROCESS_PRIO                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIO);
    PX_PROCESS_ELAPSE                = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ELAPSE);
    PX_PROCESS_ID                    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ID);
    PX_PROCESS_PRIVATE_PAGE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_PAGE);
    PX_PROCESS_VIRTUAL_SIZE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_VIRTUAL_SIZE);
    PX_PROCESS_PEAK_VS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_VS);
    PX_PROCESS_FAULT_COUNT           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_FAULT_COUNT);

    PX_THREAD                        = GetTitleIdx (hWnd, Title, Last, PN_THREAD);
    PX_THREAD_CPU                    = GetTitleIdx (hWnd, Title, Last, PN_THREAD_CPU);
    PX_THREAD_PRIV                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIV);
    PX_THREAD_USER                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_USER);
    PX_THREAD_START                  = GetTitleIdx (hWnd, Title, Last, PN_THREAD_START);
    PX_THREAD_SWITCHES               = GetTitleIdx (hWnd, Title, Last, PN_THREAD_SWITCHES);
    PX_THREAD_PRIO                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIO);
    PX_THREAD_BASE_PRIO              = GetTitleIdx (hWnd, Title, Last, PN_THREAD_BASE_PRIO);
    PX_THREAD_ELAPSE                 = GetTitleIdx (hWnd, Title, Last, PN_THREAD_ELAPSE);

    PX_THREAD_DETAILS                = GetTitleIdx (hWnd, Title, Last, PN_THREAD_DETAILS);
    PX_THREAD_PC                     = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PC);

    PX_IMAGE                         = GetTitleIdx (hWnd, Title, Last, PN_IMAGE);
    PX_IMAGE_NOACCESS                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_NOACCESS);
    PX_IMAGE_READONLY                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READONLY);
    PX_IMAGE_READWRITE               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READWRITE);
    PX_IMAGE_WRITECOPY               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_WRITECOPY);
    PX_IMAGE_EXECUTABLE              = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXECUTABLE);
    PX_IMAGE_EXE_READONLY            = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READONLY);
    PX_IMAGE_EXE_READWRITE           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READWRITE);
    PX_IMAGE_EXE_WRITECOPY           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_WRITECOPY);

    PX_PROCESS_ADDRESS_SPACE         = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ADDRESS_SPACE);
    PX_PROCESS_PRIVATE_NOACCESS      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_NOACCESS);
    PX_PROCESS_PRIVATE_READONLY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READONLY);
    PX_PROCESS_PRIVATE_READWRITE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READWRITE);
    PX_PROCESS_PRIVATE_WRITECOPY     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_WRITECOPY);
    PX_PROCESS_PRIVATE_EXECUTABLE    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXECUTABLE);
    PX_PROCESS_PRIVATE_EXE_READONLY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READONLY);
    PX_PROCESS_PRIVATE_EXE_READWRITE = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READWRITE);
    PX_PROCESS_PRIVATE_EXE_WRITECOPY = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_WRITECOPY);

    PX_PROCESS_MAPPED_NOACCESS       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_NOACCESS);
    PX_PROCESS_MAPPED_READONLY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READONLY);
    PX_PROCESS_MAPPED_READWRITE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READWRITE);
    PX_PROCESS_MAPPED_WRITECOPY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_WRITECOPY);
    PX_PROCESS_MAPPED_EXECUTABLE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXECUTABLE);
    PX_PROCESS_MAPPED_EXE_READONLY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READONLY);
    PX_PROCESS_MAPPED_EXE_READWRITE  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READWRITE);
    PX_PROCESS_MAPPED_EXE_WRITECOPY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_WRITECOPY);

    PX_PROCESS_IMAGE_NOACCESS        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_NOACCESS);
    PX_PROCESS_IMAGE_READONLY        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READONLY);
    PX_PROCESS_IMAGE_READWRITE       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READWRITE);
    PX_PROCESS_IMAGE_WRITECOPY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_WRITECOPY);
    PX_PROCESS_IMAGE_EXECUTABLE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXECUTABLE);
    PX_PROCESS_IMAGE_EXE_READONLY    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READONLY);
    PX_PROCESS_IMAGE_EXE_READWRITE   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READWRITE);
    PX_PROCESS_IMAGE_EXE_WRITECOPY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_WRITECOPY);


    wsprintf (INDEX_PROCTHRD_OBJ, TEXT("%ld %ld"), PX_PROCESS, PX_THREAD);
    wsprintf (INDEX_COSTLY_OBJ, TEXT("%ld %ld %ld"),
              PX_PROCESS_ADDRESS_SPACE, PX_IMAGE, PX_THREAD_DETAILS);


    LocalFree (TitleBuffer);
    LocalFree (Title);

}




//********************************************************
//
//  GetTitleIdx
//
//      Searches Titles[] for Name.  Returns the index found.
//
DWORD   GetTitleIdx (HWND hWnd, LPTSTR Title[], DWORD LastIndex, LPTSTR Name)
{
    DWORD   Index;

    for (Index = 0; Index <= LastIndex; Index++)
        if (Title[Index])
            if (!lstrcmpi (Title[Index], Name))
                return Index;

    MessageBox (hWnd, Name, TEXT("Pviewer cannot find index"), MB_OK);
    return 0;
}




//********************************************************
//
//  SetListBoxTabStops --
//
//      Set tab stops in the two list boxes.
//
void    SetListBoxTabStops (HWND hWnd)
{
    HWND    hListBox;
    INT     Tabs[4] = {22*4, 36*4, 44*4};

    hListBox = GetDlgItem (hWnd, PVIEW_PROCESS_LIST);
    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD_PTR)Tabs);

    hListBox = GetDlgItem (hWnd, PVIEW_THREAD_LIST);
    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD_PTR)Tabs);
}




//********************************************************
//
//  SetLocalMachine --
//
//      Set local machine as performance data focus.
//
//      Sets    ghPerfKey
//              ghMachineKey
//              gszMachineName
//              gszCurrentMachine
//
void    SetLocalMachine (void)
{
    TCHAR   szName[MACHINE_NAME_SIZE];
    DWORD   dwSize = MACHINE_NAME_SIZE;


    // close remote connections, if any
    //
    if (ghPerfKey != HKEY_PERFORMANCE_DATA)
        RegCloseKey (ghPerfKey);

    if (ghMachineKey != HKEY_LOCAL_MACHINE)
        RegCloseKey (ghMachineKey);


    // set to registry keys on local machine
    //
    ghPerfKey    = HKEY_PERFORMANCE_DATA;
    ghMachineKey = HKEY_LOCAL_MACHINE;



    // get computer name
    GetComputerName (szName, &dwSize);



    if (szName[0] != '\\' || szName[1] != '\\') {     // must have two '\\'
        wsprintf (gszMachineName, TEXT("\\\\%s"), szName);
        lstrcpy (gszCurrentMachine, gszMachineName);
    } else {
        lstrcpy (gszMachineName, szName);
        lstrcpy (gszCurrentMachine, gszMachineName);
    }

}




//********************************************************
//
//  ConnectComputer --
//
//      Connect to a computer with name entered in PVIEW_COMPUTER.
//      If a new connection is made, then return TRUE else return FALSE.
//
//      Sets    gszCurrentMachine
//              ghPerfKey
//              ghMachineKey
//
BOOL    ConnectComputer (HWND hWnd)
{
    DWORD   dwR;
    HKEY    hKey;
    TCHAR   szTemp[MACHINE_NAME_SIZE];
    TCHAR   szTemp2[MACHINE_NAME_SIZE+100];
    BOOL    bResult = TRUE;
    MSG     Msg;

    SetCursor (ghCursor[1]);

    if (!GetDlgItemText (hWnd, PVIEW_COMPUTER, szTemp, sizeof (szTemp)/sizeof(TCHAR))) {
        SetLocalMachine ();
        SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine);
    }

    else if (!lstrcmpi (szTemp, gszCurrentMachine))     // didn't change name
        bResult = FALSE;

    else if (!lstrcmpi (szTemp, gszMachineName)) {        // local machine
        SetLocalMachine ();
        EnableControls (hWnd);
    }

    else {
        // a remote machine, connect to it
        //
        dwR = RegConnectRegistry (szTemp, HKEY_PERFORMANCE_DATA, &hKey);

        if (dwR != ERROR_SUCCESS) {
            wsprintf (szTemp2, TEXT("Cannot connect to computer %s"), szTemp);
            MessageBox (hWnd, szTemp2, TEXT(""), MB_ICONEXCLAMATION|MB_OK);

            SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine);

            bResult = FALSE;
        } else {
            // connected
            //
            lstrcpy (gszCurrentMachine, szTemp);

            if (ghPerfKey != HKEY_PERFORMANCE_DATA)
                RegCloseKey (ghPerfKey);

            ghPerfKey = hKey;



            DisableControls (hWnd);



            // we also need to get the remote machine's title indexes.
            //
            dwR = RegConnectRegistry (gszCurrentMachine, HKEY_LOCAL_MACHINE, &hKey);

            if (ghMachineKey != HKEY_LOCAL_MACHINE)
                RegCloseKey (ghMachineKey);

            if (dwR == ERROR_SUCCESS)
                ghMachineKey = hKey;
            else
                // unable to connect, so we'll use our own indexes.
                //
                ghMachineKey = HKEY_LOCAL_MACHINE;
        }
    }



    // Remove all mouse and key messages. They are not accepted
    //  while the cursor is a hourglass.
    //
    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE));

    SetCursor (ghCursor[0]);


    EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), FALSE);


    return bResult;

}




//********************************************************
//
//  DisableControls --
//
//      Disable controls that don't make sense on remote machine
//
void DisableControls (HWND hPviewDlg)
{
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), FALSE);
}




//********************************************************
//
//  EnableControls --
//
//      Enable controls disabled by DisableControl().
//
void EnableControls (HWND hPviewDlg)
{
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pviewer\pviewdat.h ===
/******************************************************************************

                            P V I E W   D A T A

    Name:       pviewdat.h

    Description:
        Prototypes of functions used in pviewdat.c

******************************************************************************/





//******************************************************************************
//
//  Titles and indexes.
//
//  See GetPerfTitleSz() in perfdata.c on how to retrieve these data.
//
//  This is not complete, for complete listing
//  see under hkey_local_system
//               \software
//                   \microsoft
//                       \windows nt
//                           \currentversion
//                               \perflib
//                                   \###
//

#define PN_PROCESS                          TEXT("Process")
#define PN_PROCESS_CPU                      TEXT("% Processor Time")
#define PN_PROCESS_PRIV                     TEXT("% Privileged Time")
#define PN_PROCESS_USER                     TEXT("% User Time")
#define PN_PROCESS_WORKING_SET              TEXT("Working Set")
#define PN_PROCESS_PEAK_WS                  TEXT("Working Set Peak")
#define PN_PROCESS_PRIO                     TEXT("Priority Base")
#define PN_PROCESS_ELAPSE                   TEXT("Elapsed Time")
#define PN_PROCESS_ID                       TEXT("ID Process")
#define PN_PROCESS_PRIVATE_PAGE             TEXT("Private Bytes")
#define PN_PROCESS_VIRTUAL_SIZE             TEXT("Virtual Bytes")
#define PN_PROCESS_PEAK_VS                  TEXT("Virtual Bytes Peak")
#define PN_PROCESS_FAULT_COUNT              TEXT("Page Faults/sec")


#define PN_THREAD                           TEXT("Thread")
#define PN_THREAD_CPU                       TEXT("% Processor Time")
#define PN_THREAD_PRIV                      TEXT("% Privileged Time")
#define PN_THREAD_USER                      TEXT("% User Time")
#define PN_THREAD_START                     TEXT("Start Address")
#define PN_THREAD_SWITCHES                  TEXT("Context Switches/sec")
#define PN_THREAD_PRIO                      TEXT("Priority Current")
#define PN_THREAD_BASE_PRIO                 TEXT("Priority Base")
#define PN_THREAD_ELAPSE                    TEXT("Elapsed Time")

#define PN_THREAD_DETAILS                   TEXT("Thread Details")
#define PN_THREAD_PC                        TEXT("User PC")

#define PN_IMAGE                            TEXT("Image")
#define PN_IMAGE_NOACCESS                   TEXT("No Access")
#define PN_IMAGE_READONLY                   TEXT("Read Only")
#define PN_IMAGE_READWRITE                  TEXT("Read/Write")
#define PN_IMAGE_WRITECOPY                  TEXT("Write Copy")
#define PN_IMAGE_EXECUTABLE                 TEXT("Executable")
#define PN_IMAGE_EXE_READONLY               TEXT("Exec Read Only")
#define PN_IMAGE_EXE_READWRITE              TEXT("Exec Read/Write")
#define PN_IMAGE_EXE_WRITECOPY              TEXT("Exec Write Copy")


#define PN_PROCESS_ADDRESS_SPACE            TEXT("Process Address Space")
#define PN_PROCESS_PRIVATE_NOACCESS         TEXT("Reserved Space No Access")
#define PN_PROCESS_PRIVATE_READONLY         TEXT("Reserved Space Read Only")
#define PN_PROCESS_PRIVATE_READWRITE        TEXT("Reserved Space Read/Write")
#define PN_PROCESS_PRIVATE_WRITECOPY        TEXT("Reserved Space Write Copy")
#define PN_PROCESS_PRIVATE_EXECUTABLE       TEXT("Reserved Space Executable")
#define PN_PROCESS_PRIVATE_EXE_READONLY     TEXT("Reserved Space Exec Read Only")
#define PN_PROCESS_PRIVATE_EXE_READWRITE    TEXT("Reserved Space Exec Read/Write")
#define PN_PROCESS_PRIVATE_EXE_WRITECOPY    TEXT("Reserved Space Exec Write Copy")


#define PN_PROCESS_MAPPED_NOACCESS          TEXT("Mapped Space No Access")
#define PN_PROCESS_MAPPED_READONLY          TEXT("Mapped Space Read Only")
#define PN_PROCESS_MAPPED_READWRITE         TEXT("Mapped Space Read/Write")
#define PN_PROCESS_MAPPED_WRITECOPY         TEXT("Mapped Space Write Copy")
#define PN_PROCESS_MAPPED_EXECUTABLE        TEXT("Mapped Space Executable")
#define PN_PROCESS_MAPPED_EXE_READONLY      TEXT("Mapped Space Exec Read Only")
#define PN_PROCESS_MAPPED_EXE_READWRITE     TEXT("Mapped Space Exec Read/Write")
#define PN_PROCESS_MAPPED_EXE_WRITECOPY     TEXT("Mapped Space Exec Write Copy")


#define PN_PROCESS_IMAGE_NOACCESS           TEXT("Image Space No Access")
#define PN_PROCESS_IMAGE_READONLY           TEXT("Image Space Read Only")
#define PN_PROCESS_IMAGE_READWRITE          TEXT("Image Space Read/Write")
#define PN_PROCESS_IMAGE_WRITECOPY          TEXT("Image Space Write Copy")
#define PN_PROCESS_IMAGE_EXECUTABLE         TEXT("Image Space Executable")
#define PN_PROCESS_IMAGE_EXE_READONLY       TEXT("Image Space Exec Read Only")
#define PN_PROCESS_IMAGE_EXE_READWRITE      TEXT("Image Space Exec Read/Write")
#define PN_PROCESS_IMAGE_EXE_WRITECOPY      TEXT("Image Space Exec Write Copy")







DWORD   PX_PROCESS;
DWORD   PX_PROCESS_CPU;
DWORD   PX_PROCESS_PRIV;
DWORD   PX_PROCESS_USER;
DWORD   PX_PROCESS_WORKING_SET;
DWORD   PX_PROCESS_PEAK_WS;
DWORD   PX_PROCESS_PRIO;
DWORD   PX_PROCESS_ELAPSE;
DWORD   PX_PROCESS_ID;
DWORD   PX_PROCESS_PRIVATE_PAGE;
DWORD   PX_PROCESS_VIRTUAL_SIZE;
DWORD   PX_PROCESS_PEAK_VS;
DWORD   PX_PROCESS_FAULT_COUNT;
DWORD   PX_PROCESS_PAGED_POOL_QUOTA;
DWORD   PX_PROCESS_PEAK_PAGED_POOL_QUOTA;
DWORD   PX_PROCESS_NONPAGED_POOL_QUOTA;
DWORD   PX_PROCESS_PEAK_PAGED_POOL;
DWORD   PX_PROCESS_PEAK_NONPAGED_POOL;
DWORD   PX_PROCESS_CUR_PAGED_POOL;
DWORD   PX_PROCESS_CUR_NONPAGED_POOL;
DWORD   PX_PROCESS_PAGED_POOL_LIMIT;
DWORD   PX_PROCESS_NONPAGED_POOL_LIMIT;


DWORD   PX_THREAD;
DWORD   PX_THREAD_CPU;
DWORD   PX_THREAD_PRIV;
DWORD   PX_THREAD_USER;
DWORD   PX_THREAD_START;
DWORD   PX_THREAD_SWITCHES;
DWORD   PX_THREAD_PRIO;
DWORD   PX_THREAD_BASE_PRIO;
DWORD   PX_THREAD_ELAPSE;

DWORD   PX_THREAD_DETAILS;
DWORD   PX_THREAD_PC;

DWORD   PX_IMAGE;
DWORD   PX_IMAGE_NOACCESS;
DWORD   PX_IMAGE_READONLY;
DWORD   PX_IMAGE_READWRITE;
DWORD   PX_IMAGE_WRITECOPY;
DWORD   PX_IMAGE_EXECUTABLE;
DWORD   PX_IMAGE_EXE_READONLY;
DWORD   PX_IMAGE_EXE_READWRITE;
DWORD   PX_IMAGE_EXE_WRITECOPY;


DWORD   PX_PROCESS_ADDRESS_SPACE;
DWORD   PX_PROCESS_PRIVATE_NOACCESS;
DWORD   PX_PROCESS_PRIVATE_READONLY;
DWORD   PX_PROCESS_PRIVATE_READWRITE;
DWORD   PX_PROCESS_PRIVATE_WRITECOPY;
DWORD   PX_PROCESS_PRIVATE_EXECUTABLE;
DWORD   PX_PROCESS_PRIVATE_EXE_READONLY;
DWORD   PX_PROCESS_PRIVATE_EXE_READWRITE;
DWORD   PX_PROCESS_PRIVATE_EXE_WRITECOPY;


DWORD   PX_PROCESS_MAPPED_NOACCESS;
DWORD   PX_PROCESS_MAPPED_READONLY;
DWORD   PX_PROCESS_MAPPED_READWRITE;
DWORD   PX_PROCESS_MAPPED_WRITECOPY;
DWORD   PX_PROCESS_MAPPED_EXECUTABLE;
DWORD   PX_PROCESS_MAPPED_EXE_READONLY;
DWORD   PX_PROCESS_MAPPED_EXE_READWRITE;
DWORD   PX_PROCESS_MAPPED_EXE_WRITECOPY;


DWORD   PX_PROCESS_IMAGE_NOACCESS;
DWORD   PX_PROCESS_IMAGE_READONLY;
DWORD   PX_PROCESS_IMAGE_READWRITE;
DWORD   PX_PROCESS_IMAGE_WRITECOPY;
DWORD   PX_PROCESS_IMAGE_EXECUTABLE;
DWORD   PX_PROCESS_IMAGE_EXE_READONLY;
DWORD   PX_PROCESS_IMAGE_EXE_READWRITE;
DWORD   PX_PROCESS_IMAGE_EXE_WRITECOPY;











#define Li2Double(x) ((double)((x).HighPart) * 4.294967296E9 + (double)((x).LowPart))







typedef     struct _TIME_FIELD
    TIME_FIELD,
    *PTIME_FIELD;

struct _TIME_FIELD
    {
    INT     Hours;
    INT     Mins;
    INT     Secs;
    INT     mSecs;
    };








void RefreshPviewDlgThreadPC
           (HWND            hPviewDlg,
            LPTSTR          szProcessName,
            LPTSTR          szThreadName,
            PPERF_OBJECT    pThreadDetailsObject,
            PPERF_DATA      pCostlyData);


BOOL RefreshMemoryDlg
           (HWND            hMemDlg,
            PPERF_INSTANCE  pProcessInstance,
            PPERF_OBJECT    pProcessObject,
            PPERF_OBJECT    pAddressObject,
            PPERF_OBJECT    pImageObject);


void RefreshMemoryDlgImage
           (HWND            hMemDlg,
            DWORD           dwIndex,
            PPERF_OBJECT    pImageObject);


void RefreshPviewDlgMemoryData
           (HWND            hPviewDlg,
            PPERF_INSTANCE  pProcessInstance,
            PPERF_OBJECT    pProcessObject,
            PPERF_OBJECT    pAddressObject);


PPERF_DATA RefreshPerfData
           (HKEY            hPerfKey,
            LPTSTR          szObjectIndex,
            PPERF_DATA      pData,
            DWORD           *pDataSize);


void RefreshProcessList
           (HWND            hProcessList,
            PPERF_OBJECT    pObject);


void RefreshProcessData
           (HWND            hWnd,
            PPERF_OBJECT    pObject,
            DWORD           ProcessIndex);


void RefreshThreadList
           (HWND            hThreadList,
            PPERF_OBJECT    pObject,
            DWORD           ParentIndex);


void RefreshThreadData
           (HWND            hWnd,
            PPERF_OBJECT    pThreadObj,
            DWORD           ThreadIndex,
            PPERF_OBJECT    pProcessObj,
            PPERF_INSTANCE  pProcessInst);


WORD ProcessPriority
           (PPERF_OBJECT    pObject,
            PPERF_INSTANCE  pInstance);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ramdiskctrl\ramdiskctrl.c ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <initguid.h>
#include <mountmgr.h>
#include <ntddramd.h>

#define _NTSCSI_USER_MODE_
#include <scsi.h>

#define PAGE_SIZE 4096
#define ROUND_TO_PAGE_SIZE(_x) (((_x) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

#include <windows.h>
#include <devioctl.h>
#include <setupapi.h>
#include <cfgmgr32.h>

#include <rpc.h>

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <strsafe.h>

#include <sdistructs.h>

#define SECTOR_SIZE 0x200
#define SECTORS_PER_TRACK 0x80
#define TRACKS_PER_CYLINDER 0x10
#define CYLINDER_SIZE (SECTOR_SIZE * SECTORS_PER_TRACK * TRACKS_PER_CYLINDER)

#define arrayof(a)      (sizeof(a)/sizeof(a[0]))

typedef struct _RAMCTRL_HEADER {
    char Signature[8]; // "ramctrl"
    GUID DiskGuid;
    ULONG DiskOffset;
    ULONG DiskType;
    RAMDISK_CREATE_OPTIONS Options;
} RAMCTRL_HEADER, *PRAMCTRL_HEADER;

typedef union _RAMDISK_HEADER {

    RAMCTRL_HEADER Ramctrl;
    SDI_HEADER Sdi;

} RAMDISK_HEADER, *PRAMDISK_HEADER;

VOID
PrintError(
    ULONG ErrorCode
    )
{
    WCHAR errorBuffer[512];
    ULONG count;

    count = FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                ErrorCode,
                0,
                errorBuffer,
                arrayof(errorBuffer),
                NULL
                );

    if ( count != 0 ) {
        printf( "%ws\n", errorBuffer );
    } else {
        printf( "Format message failed. Error: %d\n", GetLastError() );
    }

    return;

} // PrintError

VOID
ListDisks (
    HANDLE ControlHandle
    )
{
    BOOL ok;
    HRESULT hr;
    WCHAR actualDeviceName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];
    WCHAR dosDeviceName[MAX_PATH];
    WCHAR driveLetterString[3] = L"A:";
    BOOL foundRamDisk;
    BOOL foundDriveLetter;
    LPCGUID interfaceGuid;
    GUID foundGuid;
    PWSTR guidPtr;
    UNICODE_STRING guidString;
    GUID diskGuid;
    HDEVINFO devinfo;
    SP_DEVICE_INTERFACE_DATA interfaceData;
    BYTE detailBuffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR))];
    PSP_DEVICE_INTERFACE_DETAIL_DATA interfaceDetailData;
    SP_DEVINFO_DATA devinfoData;
    DWORD i;
    RAMDISK_QUERY_INPUT queryInput;
    BYTE queryOutputBuffer[sizeof(RAMDISK_QUERY_OUTPUT) + (MAX_PATH * sizeof(WCHAR))];
    PRAMDISK_QUERY_OUTPUT queryOutput;
    DWORD returnedLength;

    interfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)detailBuffer;
    queryOutput = (PRAMDISK_QUERY_OUTPUT)queryOutputBuffer;

    interfaceGuid = &RamdiskDiskInterface;

    foundRamDisk = FALSE;

    do {

        devinfo = SetupDiGetClassDevs(
                    interfaceGuid,
                    NULL,
                    NULL,
                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
                    );
    
        if ( devinfo == NULL ) {
    
            printf( "ListDisks: SetupDiGetClassDevs failed: %d\n", GetLastError() );
            return;
        }

        ZeroMemory( &interfaceData, sizeof(interfaceData) );
        interfaceData.cbSize = sizeof(interfaceData);

        //
        // Enumerate the device interfaces of the class.
        //

        for (i = 0;
             SetupDiEnumDeviceInterfaces( devinfo, NULL, interfaceGuid, i, &interfaceData );
             i++ ) {

            interfaceDetailData->cbSize = sizeof(*interfaceDetailData);
            devinfoData.cbSize = sizeof(devinfoData);

            if ( !SetupDiGetDeviceInterfaceDetail(
                    devinfo,
                    &interfaceData,
                    interfaceDetailData,
                    sizeof(detailBuffer),
                    NULL,
                    &devinfoData
                    ) ) {

                //printf( "ListDisks: SetupDiGetDeviceInterfaceDetail failed for item %d. (%d)\n", i, GetLastError() );

                hr = StringCchCopyW(
                        interfaceDetailData->DevicePath,
                        MAX_PATH,
                        L"<couldn't retrieve name>"
                        );
                ASSERT( SUCCEEDED(hr) );
            }

            //printf( "Enumerated device %ws\n", interfaceDetailData->DevicePath );

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_BUSTYPEGUID,
                    NULL,
                    (PBYTE)&foundGuid,
                    sizeof(foundGuid),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                //printf( "ListDisks: SetupDiGetDeviceRegistryProperty (bus GUID) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            if ( memcmp( &foundGuid, &GUID_BUS_TYPE_RAMDISK, sizeof(GUID) ) != 0 ) {

                //printf( "ListDisks: skipping non-ramdisk device %ws\n", interfaceDetailData->DevicePath );
                continue;
            }

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                    NULL,
                    (PBYTE)actualDeviceName,
                    sizeof(actualDeviceName),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                printf( "ListDisks: SetupDiGetDeviceRegistryProperty (name) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            foundRamDisk = TRUE;

            printf( "\n%ws\n", interfaceDetailData->DevicePath );
            printf( "  Device name: %ws\n", actualDeviceName );

            guidPtr = wcschr( actualDeviceName, L'{' );
            hr = StringCchPrintfW( dosDeviceName, MAX_PATH, L"Ramdisk%ws", guidPtr );
            ASSERT( SUCCEEDED(hr) );

            if ( QueryDosDeviceW(dosDeviceName, foundDeviceName, arrayof(foundDeviceName)) ) {

                printf( "  DosDevice name %ws is assigned to this device\n", dosDeviceName );

            } else {

                printf( "  No DosDevice name was assigned to this device\n" );
            }

            foundDriveLetter = FALSE;

            for ( driveLetterString[0] = 'A';
                  driveLetterString[0] <= 'Z';
                  driveLetterString[0]++ ) {
    
                if ( QueryDosDeviceW(driveLetterString, foundDeviceName, arrayof(foundDeviceName)) &&
                     (_wcsicmp(actualDeviceName, foundDeviceName) == 0) ) {
    
                    printf( "  Drive letter %ws is assigned to this device\n", driveLetterString );
                    foundDriveLetter = TRUE;
                    break;
                }
            }
    
            if ( !foundDriveLetter ) {
                printf( "  No letter was assigned to this device\n" );
            }

            guidString.Buffer = guidPtr;
            guidString.Length = (USHORT)(wcslen(guidPtr) * sizeof(WCHAR));
            guidString.MaximumLength = guidString.Length;

            RtlGUIDFromString( &guidString, &diskGuid );

            queryInput.Version = sizeof(RAMDISK_QUERY_INPUT);
            queryInput.DiskGuid = diskGuid;

            ok = DeviceIoControl(
                    ControlHandle,
                    FSCTL_QUERY_RAM_DISK,
                    &queryInput,
                    sizeof(queryInput),
                    queryOutput,
                    sizeof(queryOutputBuffer),
                    &returnedLength,
                    FALSE
                    );
        
            if ( !ok ) {

               DWORD errorCode = GetLastError();
               printf( "Error querying RAM disk: %d\n", errorCode );
               PrintError( errorCode );

            } else {

                printf( "  RAM disk information:\n" );
                if ( queryOutput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {
                    printf( "    Type: boot disk\n" );
                    printf( "    Base page: 0x%x\n", queryOutput->BasePage );
                } else {
                    printf( "    Type: %s\n",
                                queryOutput->DiskType == RAMDISK_TYPE_FILE_BACKED_VOLUME ? "volume" : "disk" );
                    printf( "    File: %ws\n", queryOutput->FileName );
                }
                printf( "    Length: 0x%I64x\n", queryOutput->DiskLength );
                printf( "    Offset: 0x%x\n", queryOutput->DiskOffset );
                if ( queryOutput->DiskType != RAMDISK_TYPE_BOOT_DISK ) {
                    printf( "    View count: 0x%x\n", queryOutput->ViewCount );
                    printf( "    View length: 0x%x\n", queryOutput->ViewLength );
                }
                printf( "    Options: " );
                printf( "%s; ", queryOutput->Options.Fixed ? "fixed" : "removable" );
                printf( "%s; ", queryOutput->Options.Readonly ? "readonly" : "writeable" );
                printf( "%s; ", queryOutput->Options.NoDriveLetter ? "no drive letter" : "drive letter" );
                printf( "%s; ", queryOutput->Options.Hidden ? "hidden" : "visible" );
                printf( "%s\n", queryOutput->Options.NoDosDevice ? "no DosDevice" : "DosDevice" );
            }
        }

        SetupDiDestroyDeviceInfoList( devinfo );

        if ( interfaceGuid == &RamdiskDiskInterface ) {
            interfaceGuid = &MOUNTDEV_MOUNTED_DEVICE_GUID;
        } else {
            break;
        }

    } while ( TRUE );

    if ( !foundRamDisk ) {
        printf( "No RAM disks found\n" );
    }

    return;

} // ListDisks

VOID
FindDisk (
    ULONG DiskType,
    PUNICODE_STRING DiskGuidString,
    BOOL WaitForDeletion
    )
{
    HRESULT hr;
    WCHAR actualDeviceName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];
    WCHAR dosDeviceName[MAX_PATH];
    WCHAR driveLetterString[3] = L"A:";
    BOOL found;
    LPCGUID interfaceGuid;
    HDEVINFO devinfo;
    SP_DEVICE_INTERFACE_DATA interfaceData;
    BYTE detailBuffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR))];
    PSP_DEVICE_INTERFACE_DETAIL_DATA interfaceDetailData;
    SP_DEVINFO_DATA devinfoData;
    DWORD i;

    interfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)detailBuffer;

    hr = StringCchPrintfW( actualDeviceName, MAX_PATH, L"\\Device\\Ramdisk%wZ", DiskGuidString );
    ASSERT( SUCCEEDED(hr) );

    printf( "Waiting for device %ws to be %s...",
            actualDeviceName,
            WaitForDeletion ? "deleted" : "ready" );

    if ( DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {
        interfaceGuid = &RamdiskDiskInterface;
    } else {
        interfaceGuid = &MOUNTDEV_MOUNTED_DEVICE_GUID;
    }

    found = FALSE;

    do {

        devinfo = SetupDiGetClassDevs(
                    interfaceGuid,
                    NULL,
                    NULL,
                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
                    );
    
        if ( devinfo == NULL ) {
    
            printf( "\nFindDisk: SetupDiGetClassDevs failed: %d\n", GetLastError() );
            return;
        }

        ZeroMemory( &interfaceData, sizeof(interfaceData) );
        interfaceData.cbSize = sizeof(interfaceData);

        //
        // Enumerate the device interfaces of the class.
        //

        for (i = 0;
             SetupDiEnumDeviceInterfaces( devinfo, NULL, interfaceGuid, i, &interfaceData );
             i++ ) {

            interfaceDetailData->cbSize = sizeof(*interfaceDetailData);
            devinfoData.cbSize = sizeof(devinfoData);

            if ( !SetupDiGetDeviceInterfaceDetail(
                    devinfo,
                    &interfaceData,
                    interfaceDetailData,
                    sizeof(detailBuffer),
                    NULL,
                    &devinfoData
                    ) ) {

                //printf( "\nFindDisk: SetupDiGetDeviceInterfaceDetail failed for item %d. (%d)\n", i, GetLastError() );

                hr = StringCchCopyW(
                        interfaceDetailData->DevicePath,
                        MAX_PATH,
                        L"<couldn't retrieve name>"
                        );
                ASSERT( SUCCEEDED(hr) );
            }

            //printf( "\nEnumerated device %ws\n", interfaceDetailData->DevicePath );

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                    NULL,
                    (PBYTE)foundDeviceName,
                    sizeof(foundDeviceName),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                //printf( "\nFindDisk: SetupDiGetDeviceRegistryProperty (name) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            //printf( "\nTarget device %ws\n", foundDeviceName );

            if ( _wcsicmp( actualDeviceName, foundDeviceName ) != 0 ) {
                continue;
            }

            found = TRUE;
            break;
        }

        SetupDiDestroyDeviceInfoList( devinfo );

        if ( !found ) {

            if ( WaitForDeletion ) {

                printf( "\nRAM disk is now gone\n" );
                return;
            }

            //printf( "Enumeration failed to find target device; sleeping\n" );
            printf( "." );

            Sleep( 500 );

        } else {

            if ( !WaitForDeletion ) {

                printf( "\nRAM disk is now ready\n" );
                break;
            }

            //printf( "Enumeration found target device; sleeping\n" );
            printf( "." );

            Sleep( 500 );

            found = FALSE;
        }

    } while ( TRUE );

    if ( found ) {

        hr = StringCchPrintfW( dosDeviceName, MAX_PATH, L"Ramdisk%wZ", DiskGuidString );
        ASSERT( SUCCEEDED(hr) );

        if ( QueryDosDeviceW(dosDeviceName, foundDeviceName, arrayof(foundDeviceName)) ) {

            printf( "  DosDevice name %ws is assigned to this device\n", dosDeviceName );

        } else {

            printf( "  No DosDevice name was assigned to this device\n" );
        }

        found = FALSE;

        for ( driveLetterString[0] = 'A';
              driveLetterString[0] <= 'Z';
              driveLetterString[0]++ ) {

            if ( QueryDosDeviceW(driveLetterString, foundDeviceName, arrayof(foundDeviceName)) &&
                 (_wcsicmp(actualDeviceName, foundDeviceName) == 0) ) {

                printf( "  Drive letter %ws is assigned to this device\n", driveLetterString );
                found = TRUE;
                break;
            }
        }

        if ( !found ) {
            printf( "  No letter was assigned to this device\n" );
        }
    }

    return;

} // FindDisk
                 
VOID
FullFilePath (
    PWCHAR pwzPath
    )
{
    HRESULT hr;
    WCHAR wzDevPath[512] = L"";
    WCHAR wzDosPath[512] = L"";
    PWCHAR pwzDosName = wzDosPath;
    DWORD dw;
    WCHAR c;

    dw = GetFullPathNameW(pwzPath, arrayof(wzDosPath), wzDosPath, NULL);
    if (0 != dw) {
        if (NULL != (pwzDosName = wcschr(wzDosPath, ':'))) {
            pwzDosName++;
            c = *pwzDosName;
            *pwzDosName = '\0';

            dw = QueryDosDeviceW(wzDosPath, wzDevPath, arrayof(wzDevPath));
            if (0 != dw) {
                *pwzDosName = c;
            
                hr = StringCchPrintfW(pwzPath, 512, L"%ls%ls", wzDevPath, pwzDosName);
                ASSERT( SUCCEEDED(hr) );
            }
            else {
                printf("QueryDosDeviceW(%ls) failed: %d\n", wzDosPath, GetLastError());
                PrintError(GetLastError());
            }
        }
    }
}

BOOLEAN
IsDriveLetter (
    PWCHAR Name
        )
{
    if ((((Name[0] >= L'A') && (Name[0] <= L'Z')) ||
         ((Name[0] >= L'a') && (Name[0] <= L'z'))) &&
        (Name[1] == L':') &&
        (Name[2] == 0)) {
        return TRUE;
    }
    return FALSE;
}

VOID
DeleteRamdisk (
    IN HANDLE ControlHandle,
    IN PWSTR FileName
    )
{
    BOOL ok;
    HRESULT hr;
    ULONG errorCode = 0;
    ULONG returnedLength = 0;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE imageFileHandle;
    HANDLE volumeHandle;
    RAMDISK_HEADER ramdiskHeader;
    UNICODE_STRING guidString;
    LARGE_INTEGER offset;
    LPCGUID diskGuid;
    ULONG diskType;
    RAMDISK_QUERY_INPUT queryInput;
    RAMDISK_MARK_FOR_DELETION_INPUT markInput;
    BYTE queryOutputBuffer[sizeof(RAMDISK_QUERY_OUTPUT) + (MAX_PATH * sizeof(WCHAR))];
    PRAMDISK_QUERY_OUTPUT queryOutput;
    CONFIGRET cr;
    DEVNODE devnode;
    WCHAR devinst[MAX_PATH];
    PNP_VETO_TYPE vetoType;
    WCHAR vetoName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];

    queryOutput = (PRAMDISK_QUERY_OUTPUT)queryOutputBuffer;

    if ( FileName[0] == L'{' ) {

        guidString.Buffer = FileName;
        guidString.Length = (USHORT)(wcslen(FileName) * sizeof(WCHAR));
        guidString.MaximumLength = guidString.Length;

        queryInput.Version = sizeof(RAMDISK_QUERY_INPUT);
        RtlGUIDFromString( &guidString, &queryInput.DiskGuid );

        ok = DeviceIoControl(
                ControlHandle,
                FSCTL_QUERY_RAM_DISK,
                &queryInput,
                sizeof(queryInput),
                queryOutput,
                sizeof(queryOutputBuffer),
                &returnedLength,
                FALSE
                );
    
        if ( !ok ) {

           errorCode = GetLastError();
           printf( "Error querying RAM disk: %d\n", errorCode );
           PrintError( errorCode );
           return;

        }

        diskGuid = &queryOutput->DiskGuid;
        diskType = queryOutput->DiskType;

    } else if (IsDriveLetter ( FileName ) ) {

        //
        // Treat FileName as a drive letter.  See if this the supplied
        // drive letter corresponds to a ramdisk.
        //

        if ((QueryDosDeviceW(FileName, foundDeviceName, arrayof(foundDeviceName)) == 0) ||
            wcsncmp(foundDeviceName, L"\\Device\\Ramdisk", wcslen(L"\\Device\\Ramdisk"))) {
            errorCode = GetLastError();
            printf( "Drive letter \"%ws\" is not assigned to a RAM disk.\n",
                    FileName);
            PrintError( errorCode );
            return;
        }
        guidString.Buffer = wcschr( foundDeviceName, L'{' );
        guidString.Length = (USHORT)(wcslen(guidString.Buffer) * sizeof(WCHAR));
        guidString.MaximumLength = guidString.Length;

        queryInput.Version = sizeof(RAMDISK_QUERY_INPUT);
        RtlGUIDFromString( &guidString, &queryInput.DiskGuid );

        ok = DeviceIoControl(
                ControlHandle,
                FSCTL_QUERY_RAM_DISK,
                &queryInput,
                sizeof(queryInput),
                queryOutput,
                sizeof(queryOutputBuffer),
                &returnedLength,
                FALSE
                );
    
        if ( !ok ) {

           errorCode = GetLastError();
           printf( "Error querying RAM disk: %d\n", errorCode );
           PrintError( errorCode );
           return;

        }

        diskGuid = &queryOutput->DiskGuid;
        diskType = queryOutput->DiskType;

    } else {
    
        RtlInitUnicodeString( &ustr, FileName );
        InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );
    
        status = NtOpenFile(
                    &imageFileHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                    &obja,
                    &iosb,
                    FILE_SHARE_READ,
                    FILE_SYNCHRONOUS_IO_ALERT
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't open target file %ws: %x\n", FileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return;
        }
    
        //
        // Read and verify the header.
        //

        offset.QuadPart = 0;

        status = NtReadFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &ramdiskHeader,
                    sizeof(ramdiskHeader),
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't read header from target file %ws: %x\n", FileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return;
        }

        if ( strcmp( ramdiskHeader.Ramctrl.Signature, "ramctrl" ) == 0 ) {

            diskGuid = &ramdiskHeader.Ramctrl.DiskGuid;
            diskType = ramdiskHeader.Ramctrl.DiskType;

        } else if ( strncmp( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) == 0 ) {

            diskGuid = (LPCGUID)ramdiskHeader.Sdi.RuntimeGUID;
            diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;

        } else {

            printf( "Header in target file not recognized\n" );
            return;
        }

    
        NtClose( imageFileHandle );

        RtlStringFromGUID( diskGuid, &guidString );
    }

    printf("Attempting to delete \\Device\\Ramdisk%wZ\n", &guidString );

    hr = StringCchPrintfW( devinst, MAX_PATH, L"\\Device\\Ramdisk%ws", guidString.Buffer );
    ASSERT( SUCCEEDED(hr) );

    RtlInitUnicodeString( &ustr, devinst );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &volumeHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open target device %ws: %x\n", devinst, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    printf( "Syncing %ws ... ", devinst );

    if ( !FlushFileBuffers( volumeHandle ) ) {

        errorCode = GetLastError();
        // NOTE: [bassamt] FlushFileBuffers can fail with error code 
        // ERROR_INVALID_FUNCTION if the volume is not formatted.
        // NOTE: [brimo] FlushFileBuffers can fail with error code
        // ERROR_WRITE_PROTECT if the volume is mounted read-only
        if ((errorCode != ERROR_INVALID_FUNCTION) && (errorCode != ERROR_WRITE_PROTECT)) {
            printf( "flush failed (%u)\n", errorCode );
            PrintError( errorCode );
            return;
        }
    }

    if ( !DeviceIoControl(
            volumeHandle,
            FSCTL_LOCK_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &returnedLength,
            NULL
            ) ) {
        
        errorCode = GetLastError();
        printf( "lock volume failed (%u)\n", errorCode );
        PrintError( errorCode );
        return;
    }

    if ( !DeviceIoControl(
            volumeHandle,
            FSCTL_DISMOUNT_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &returnedLength,
            NULL
            ) ) {

        errorCode = GetLastError();
        printf( "dismount volume failed (%u)\n", errorCode );
        PrintError( errorCode );
        return;
    }

    printf( "done\n" );

    NtClose( volumeHandle );

    markInput.Version = sizeof(RAMDISK_MARK_FOR_DELETION_INPUT);
    markInput.DiskGuid = *diskGuid;

    ok = DeviceIoControl(
            ControlHandle,
            FSCTL_MARK_RAM_DISK_FOR_DELETION,
            &markInput,
            sizeof(markInput),
            NULL,
            0,
            &returnedLength,
            FALSE
            );

    if ( !ok ) {

       errorCode = GetLastError();
       printf( "Error marking RAM disk: %d\n", errorCode );
       PrintError( errorCode );
       return;
    }

    if ( diskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {
        hr = StringCchPrintfW( devinst, MAX_PATH, L"Ramdisk\\Ramdisk\\%ws", guidString.Buffer );
    } else {
        hr = StringCchPrintfW( devinst, MAX_PATH, L"Ramdisk\\Ramvolume\\%ws", guidString.Buffer );
    }
    ASSERT( SUCCEEDED(hr) );
    
    cr = CM_Locate_DevNode( &devnode, devinst, 0 );
    if ( cr != CR_SUCCESS ) {
        printf( "Unable to locate devnode: %d\n", cr );
        return;
    }
    cr = CM_Query_And_Remove_SubTree_Ex( devnode, &vetoType, vetoName, MAX_PATH, 0, NULL );
    if ( cr != CR_SUCCESS ) {
        printf( "Unable to remove devnode: %d\n", cr );
        if ( cr == CR_REMOVE_VETOED ) {
            printf( "  veto type = 0x%x\n", vetoType );
            printf( "  veto name = %ws\n", vetoName );
        }
        return;
    }

    FindDisk( diskType, &guidString, TRUE );

    printf( "RAM disk %wZ deleted\n", &guidString );

    return;

} // DeleteRamdisk

void
AddBootFilesToSdi(
    PWCHAR SdiFile,
    PWCHAR StartromFile,
    PWCHAR OsloaderFile
    )
{
    NTSTATUS status;
    HRESULT hr;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE imageFileHandle;
    HANDLE startromHandle;
    HANDLE osloaderHandle;
    FILE_STANDARD_INFORMATION fileInfo;
    FILE_ALLOCATION_INFORMATION allocInfo;
    SDI_HEADER sdiHeader;
    LARGE_INTEGER offset;
    ULONGLONG diskOffset;
    ULONGLONG diskLength;
    ULONGLONG startromOffset;
    ULONGLONG startromLength;
    ULONGLONG startromLengthAligned;
    ULONGLONG osloaderOffset;
    ULONGLONG osloaderLength;
    ULONGLONG osloaderLengthAligned;
    ULONGLONG finalFileLength;
    ULONG errorCode = 0;
    PUCHAR buffer;

#define STRING_SIZE 512
    WCHAR dataFileName[STRING_SIZE];

    printf( "Adding boot files to SDI file %ws\n", SdiFile );

    RtlInitUnicodeString( &ustr, SdiFile );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &imageFileHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open target file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    //
    // Read and verify the header.
    //

    offset.QuadPart = 0;

    status = NtReadFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                &sdiHeader,
                sizeof(sdiHeader),
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read header from target file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    if ( strncmp( sdiHeader.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) != 0 ) {

        printf( "Header in target file not recognized\n" );
        return;
    }

    diskOffset = sdiHeader.ToC[0].llOffset.LowPart;
    diskLength = sdiHeader.ToC[0].llSize.QuadPart;

    startromOffset = ROUND_TO_PAGE_SIZE( diskOffset + diskLength );

    //
    // Get the length of startrom.com.
    //

    hr = StringCchCopyW( dataFileName, STRING_SIZE, StartromFile );
    ASSERT( SUCCEEDED(hr) );

    FullFilePath( dataFileName );

    RtlInitUnicodeString( &ustr, dataFileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &startromHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open startrom file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    status = NtQueryInformationFile(
                startromHandle,
                &iosb,
                &fileInfo,
                sizeof(fileInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(status) ) {

        printf( "Can't query info for startrom file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    startromLength = fileInfo.EndOfFile.QuadPart;
    startromLengthAligned = ROUND_TO_PAGE_SIZE( startromLength );

    osloaderOffset = startromOffset + startromLengthAligned;

    //
    // Get the length of osloader.exe.
    //

    hr = StringCchCopyW( dataFileName, STRING_SIZE, OsloaderFile );
    ASSERT( SUCCEEDED(hr) );
    FullFilePath( dataFileName );

    RtlInitUnicodeString( &ustr, dataFileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &osloaderHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open osloader file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    status = NtQueryInformationFile(
                osloaderHandle,
                &iosb,
                &fileInfo,
                sizeof(fileInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(status) ) {

        printf( "Can't query info for osloader file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    osloaderLength = fileInfo.EndOfFile.QuadPart;
    osloaderLengthAligned = ROUND_TO_PAGE_SIZE( startromLength );

    finalFileLength = osloaderOffset + osloaderLengthAligned;

    //
    // Truncate the file at the end of the disk image, then extend it back.
    //

    printf( "  truncating SDI file at end of ramdisk image %I64d [0x%I64x]\n",
            startromOffset, startromOffset );

    allocInfo.AllocationSize.QuadPart = startromOffset;

    status = NtSetInformationFile(
                imageFileHandle,
                &iosb,
                &allocInfo,
                sizeof(allocInfo),
                FileAllocationInformation
                );
    if ( !NT_SUCCESS(status) ) {

        printf( "Can't set allocation size for image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    allocInfo.AllocationSize.QuadPart = finalFileLength;

    status = NtSetInformationFile(
                imageFileHandle,
                &iosb,
                &allocInfo,
                sizeof(allocInfo),
                FileAllocationInformation
                );
    if ( !NT_SUCCESS(status) ) {

        printf( "Can't set allocation size for image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    //
    // Copy startrom into the image file.
    //

    printf( "  adding boot file %ws, length %I64d [0x%I64x]\n",
            StartromFile, startromLength, startromLength );

    buffer = malloc( (ULONG)startromLength );

    offset.QuadPart = 0;

    status = NtReadFile(
                startromHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)startromLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read from startrom file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    offset.QuadPart = startromOffset;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)startromLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write startrom to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    free( buffer );

    //
    // Copy osloader into the image file.
    //

    printf( "  adding load file %ws, length %I64d [0x%I64x]\n",
            OsloaderFile, osloaderLength, osloaderLength );

    buffer = malloc( (ULONG)osloaderLength );

    offset.QuadPart = 0;

    status = NtReadFile(
                osloaderHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)osloaderLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read from osloader file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    offset.QuadPart = osloaderOffset;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)osloaderLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write osloader to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    free( buffer );

    //
    // Update the header.
    //

    printf( "  updating header\n" );

    sdiHeader.liBootCodeOffset.QuadPart = startromOffset;
    sdiHeader.liBootCodeSize.QuadPart = startromLength;

    sdiHeader.ToC[1].dwType = SDI_BLOBTYPE_BOOT;
    sdiHeader.ToC[1].llOffset.QuadPart = startromOffset;
    sdiHeader.ToC[1].llSize.QuadPart = startromLength;

    sdiHeader.ToC[2].dwType = SDI_BLOBTYPE_LOAD;
    sdiHeader.ToC[2].llOffset.QuadPart = osloaderOffset;
    sdiHeader.ToC[2].llSize.QuadPart = osloaderLength;

    offset.QuadPart = 0;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                &sdiHeader,
                sizeof(sdiHeader),
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write header to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    printf( "  done\n" );

    NtClose( osloaderHandle );
    NtClose( startromHandle );
    NtClose( imageFileHandle );

    return;
}

int
__cdecl
wmain (
    ULONG argc,
    WCHAR *argv[])
{
    BOOL ok;
    HRESULT hr;
    HANDLE controlHandle = NULL;
    PUCHAR dataBuffer = NULL;
    UCHAR buffer[2048];
    WCHAR string[25];
    ULONG length = 0;
    ULONG errorCode = 0;
    ULONG returned = 0;
    ULONG sizeInMb;
    ULONG diskType;
    WCHAR fileName[MAX_PATH];
    ULONG desiredSize;
    ULONG actualSize;
    ULONG controlSize;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    PRAMDISK_CREATE_INPUT createInput;
    ULONG arg;
    BOOL fNeedHelp = FALSE;
    HANDLE imageFileHandle;
    LARGE_INTEGER allocation;
    BOOL fixed;
    BOOL readonly;
    BOOL delete = FALSE;
    ULONG diskNumber;
    BOOL noDriveLetter;
    BOOL hidden;
    BOOL noDosDevice;
    BOOL ignoreHeader;
    BOOL bootDisk;
    BOOL useSdi;
    ULONG diskOffset;
    RAMDISK_HEADER ramdiskHeader;
    UNICODE_STRING guidString;
    LARGE_INTEGER offset;
    PWCHAR startromFile = NULL;
    PWCHAR osloaderFile = NULL;

    sizeInMb = 64;
    diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
    fileName[0] = 0;
    fixed = TRUE;
    readonly = FALSE;
    noDriveLetter = FALSE;
    hidden = FALSE;
    noDosDevice = FALSE;
    ignoreHeader = FALSE;
    bootDisk = FALSE;
    diskOffset = PAGE_SIZE;
    useSdi = FALSE;

    for ( arg = 1; arg < argc; arg++ ) {

        // process options
        if ( (argv[arg][0] == '-') || (argv[arg][0] == '/') ) {

            PWCHAR argn = argv[arg]+1;                   // Argument name
            PWCHAR argp = argn;							// Argument parameter

            while ( *argp && (*argp != ':') ) {
                argp++;
            }
            if ( *argp == ':' ) {
                *argp++ = '\0';
            }

            switch ( argn[0] ) {
            
            case 's':                                 // Size in MB
            case 'S':

                if ( _wcsicmp( argn, L"sdi" ) == 0 ) {
                    useSdi = TRUE;
                } else {
                    sizeInMb = _wtoi(argp);
                }
                break;

            case 'a':
                if ( _wcsicmp( argn, L"addboot" ) == 0 ) {
                    if ( arg+2 < argc ) {
                        startromFile = argv[++arg];
                        osloaderFile = argv[++arg];
                    } else {
                        printf( "Missing startrom/osloader file name\n" );
                        fNeedHelp = TRUE;
                        arg = argc - 1;
                    }
                } else {
                    printf( "Unknown argument: %ws\n", argv[arg] );
                    fNeedHelp = TRUE;
                    arg = argc - 1;
                }

            case 'i':                                 // ignore header
            case 'I':
                ignoreHeader = TRUE;
                break;

            case 'b':                                 // use boot disk GUID
            case 'B':
                bootDisk = TRUE;
                break;

            case 'd':                                 // disk offset
            case 'D':
                diskOffset = _wtol(argp);             
                break;

            case 'o':
            case 'O':                                 // Readonly, or options
                if ( *argp ) {

                    BOOL sense = TRUE;

                    do {

                        if ( *argp == '-' ) {
                            sense = FALSE;
                            argp++;
                        } else if ( *argp == '+' ) {
                            sense = TRUE;
                            argp++;
                        }

                        switch ( *argp ) {
                        
                        case 'v':
                        case 'V':
                            diskType = sense ? RAMDISK_TYPE_FILE_BACKED_VOLUME :
                                               RAMDISK_TYPE_FILE_BACKED_DISK;
                            break;

                        case 'r':
                        case 'R':
                            readonly = sense;
                            break;

                        case 'f':
                        case 'F':
                            fixed = sense;
                            break;

                        case 'l':
                        case 'L':
                            noDriveLetter = !sense;
                            break;

                        case 'h':
                        case 'H':
                            hidden = sense;
                            break;

                        case 'd':
                        case 'D':
                            noDosDevice = !sense;
                            break;

                        }

                        sense = TRUE;

                        argp++;

                    } while ( *argp );

                } else {

                    readonly = TRUE;

                }

                break;

            case 'x':                                 // Delete device, not create
            case 'X':
                delete = TRUE;
                break;

            case 'h':									// Help
            case 'H':
            case '?':
                fNeedHelp = TRUE;
                arg = argc - 1;
                break;
                
            default:
                printf( "Unknown argument: %ws\n", argv[arg] );
                fNeedHelp = TRUE;
                arg = argc - 1;
                break;
            }

        } else {
            hr = StringCchCopyW( fileName, MAX_PATH, argv[arg] );
            ASSERT( SUCCEEDED(hr) );
        }
    }

    if ( fNeedHelp ) {

        printf(
            "Usage (to create):\n"
            "    ramdiskctrl [options] win32_disk_file_name\n"
            "or (to delete)\n"
            "    ramdiskctrl -x win32_disk_file_name | {guid} | drive_letter:\n"
            "\n"
            "Options:\n"
            "    -s:N         Set size of disk image in MB (default: 64)\n"
            "    -i           Ignore ramctrl header in existing ramdisk file.\n"
            "    -d:N         Ramdisk offset from start of file. (default: 4096).\n"
            "    -o:options   Options: (use - or + to set sense)\n"
            "        v          Volume (vs. disk) (default: volume)\n"
            "        r          Readonly (default: writeable)\n"
            "        f          Fixed (default: fixed)\n"
            "        l          Assign drive letter (default: assign)\n"
            "        h          Hidden (default: visible)\n"
            "        d          Assign DosDevice name (default: assign)\n"
            "    -h or -?  Display this help text.\n"
            );
        return 1;
    }

    if ( !delete ||
        ((fileName[0] != L'{') &&
        !IsDriveLetter(fileName))) {
        FullFilePath( fileName );
    }

    if ( startromFile != NULL ) {

        AddBootFilesToSdi( fileName, startromFile, osloaderFile );

        return 0;
    }

    hr = StringCchCopyW( string, 25, L"\\device\\ramdisk" );
    ASSERT( SUCCEEDED(hr) );
    RtlInitUnicodeString( &ustr, string );

    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );
    //printf( "Opening %ws\n", string );

    status = NtOpenFile(
                &controlHandle,
                GENERIC_READ | GENERIC_WRITE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN
                );

    if ( !NT_SUCCESS(status) ) {
        printf( "Error opening control device %ws. Error: %x\n", string, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return 1;
    }

    if ( delete ) {

        //
        // Delete the disk.
        //

        DeleteRamdisk( controlHandle, fileName );

        return 0;
    }

    if ( fileName[0] == 0 ) {

        //
        // Just list the disks.
        //
    
        ListDisks( controlHandle );
        return 0;
    }

    //
    // If SDI, force the disk type to emulated volume, etc.
    //

    if ( useSdi ) {
        diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
        bootDisk = FALSE;
        fixed = TRUE;
        readonly = FALSE;
        noDriveLetter = FALSE;
        hidden = FALSE;
        noDosDevice = FALSE;
    }

    //
    // Create the disk.
    //

    desiredSize = sizeInMb * 1024 * 1024;
    actualSize = ((desiredSize + CYLINDER_SIZE - 1) / CYLINDER_SIZE) * CYLINDER_SIZE;
    if ( actualSize != desiredSize ) {
        printf( "Using rounded-up disk size of %d instead of %d\n", actualSize, desiredSize );
    }

    controlSize = sizeof(RAMDISK_CREATE_INPUT) + (wcslen(fileName) * sizeof(WCHAR));

    createInput = malloc( controlSize );
    if ( createInput == NULL ) {
        printf( "Can't allocate %d bytes for RAMDISK_CREATE_INPUT struct\n", controlSize );
        return 1;
    }

    RtlZeroMemory( createInput, controlSize );
              
    createInput->Version = sizeof(RAMDISK_CREATE_INPUT);
    hr = StringCchCopyW( createInput->FileName, wcslen(fileName) + 1, fileName );
    ASSERT( SUCCEEDED(hr) );

    allocation.QuadPart = actualSize + diskOffset;

    RtlInitUnicodeString( &ustr, fileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtCreateFile(
                &imageFileHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                &allocation,
                0,
                0,
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_ALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't create target file %ws: %x\n", fileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return 1;
    }

    if ( iosb.Information == FILE_CREATED || ignoreHeader ) {

        if ( !bootDisk ) {
            RPC_STATUS rpcStatus;
            rpcStatus = UuidCreate( &createInput->DiskGuid );
            ASSERT( rpcStatus == RPC_S_OK );
        } else {
            createInput->DiskGuid = RamdiskBootDiskGuid;
        }

        createInput->DiskOffset = diskOffset;
        createInput->DiskLength = actualSize;
        createInput->DiskType = diskType;
        createInput->Options.Fixed = (BOOLEAN)fixed;
        createInput->Options.Readonly = (BOOLEAN)readonly;
        createInput->Options.NoDriveLetter = (BOOLEAN)noDriveLetter;
        createInput->Options.Hidden = (BOOLEAN)hidden;
        createInput->Options.NoDosDevice = (BOOLEAN)noDosDevice;

    }

    if ( iosb.Information == FILE_CREATED ) {

        UCHAR byte = 0;

        printf( "Created target file %ws\n", fileName );

        //
        // Extend the file to the desired length.
        //

        offset.QuadPart = actualSize + diskOffset - 1;

        status = NtWriteFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &byte,
                    1,
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't write to target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

        //
        // Write the header.
        //

        RtlZeroMemory( &ramdiskHeader, sizeof(ramdiskHeader) );

        if ( !useSdi ) {
        
            hr = StringCchCopyA( ramdiskHeader.Ramctrl.Signature, 8, "ramctrl" );
            ASSERT( SUCCEEDED(hr) );
            ramdiskHeader.Ramctrl.DiskGuid = createInput->DiskGuid;
            ramdiskHeader.Ramctrl.DiskOffset = diskOffset;
            ramdiskHeader.Ramctrl.DiskType = diskType;
            ramdiskHeader.Ramctrl.Options = createInput->Options;

        } else {

            memcpy( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) );
            ramdiskHeader.Sdi.dwMDBType = SDI_MDBTYPE_VOLATILE;
            memcpy( ramdiskHeader.Sdi.RuntimeGUID, &createInput->DiskGuid, sizeof(GUID) );
            ramdiskHeader.Sdi.dwPageAlignmentFactor = SDI_DEFAULTPAGEALIGNMENT;
            ramdiskHeader.Sdi.ToC[0].dwType = SDI_BLOBTYPE_PART;
            ramdiskHeader.Sdi.ToC[0].llOffset.QuadPart = diskOffset;
            ramdiskHeader.Sdi.ToC[0].llSize.QuadPart = createInput->DiskLength;
        }

        offset.QuadPart = 0;

        status = NtWriteFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &ramdiskHeader,
                    sizeof(ramdiskHeader),
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't write to target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

    } else {

        FILE_STANDARD_INFORMATION fileInfo;

        printf( "Using existing target file %ws\n", fileName );

        //
        // Get the length of the existing file.
        //

        status = NtQueryInformationFile(
                    imageFileHandle,
                    &iosb,
                    &fileInfo,
                    sizeof(fileInfo),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            printf( "Can't query info for target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

        //
        // Read and verify the header.
        //
        if ( !ignoreHeader ) {

            offset.QuadPart = 0;

            status = NtReadFile(
                        imageFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &iosb,
                        &ramdiskHeader,
                        sizeof(ramdiskHeader),
                        &offset,
                        NULL
                        );
            if ( !NT_SUCCESS(status) ) {
                printf( "Can't read header from target file %ws: %x\n", fileName, status );
                errorCode = RtlNtStatusToDosError( status );
                PrintError( errorCode );
                return 0;
            }

            if ( strcmp( ramdiskHeader.Ramctrl.Signature, "ramctrl" ) == 0 ) {

                createInput->DiskGuid = ramdiskHeader.Ramctrl.DiskGuid;
                createInput->DiskOffset = ramdiskHeader.Ramctrl.DiskOffset;
                createInput->DiskLength = fileInfo.EndOfFile.QuadPart - createInput->DiskOffset;
                diskType = createInput->DiskType = ramdiskHeader.Ramctrl.DiskType;
                createInput->Options = ramdiskHeader.Ramctrl.Options;

            } else if ( strncmp( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) == 0 ) {

                memcpy( &createInput->DiskGuid, ramdiskHeader.Sdi.RuntimeGUID, sizeof(GUID) );
                createInput->DiskOffset = ramdiskHeader.Sdi.ToC[0].llOffset.LowPart;
                createInput->DiskLength = ramdiskHeader.Sdi.ToC[0].llSize.QuadPart;
                diskType = createInput->DiskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
                bootDisk = FALSE;
                fixed = TRUE;
                readonly = FALSE;
                noDriveLetter = FALSE;
                hidden = FALSE;
                noDosDevice = FALSE;
                createInput->Options.Fixed = (BOOLEAN)fixed;
                createInput->Options.Readonly = (BOOLEAN)readonly;
                createInput->Options.NoDriveLetter = (BOOLEAN)noDriveLetter;
                createInput->Options.Hidden = (BOOLEAN)hidden;
                createInput->Options.NoDosDevice = (BOOLEAN)noDosDevice;

            } else {
            
                printf( "Header in target file not recognized\n" );
                return 0;
            }
        } else {

            //
            // Ignored header, set length to the actual file length.
            //

            createInput->DiskLength = fileInfo.EndOfFile.QuadPart - createInput->DiskOffset;
        }

    }

    NtClose( imageFileHandle );

    RtlStringFromGUID( &createInput->DiskGuid, &guidString );

    printf( "Creating RAM disk:\n" );
    printf( "     File: %ws\n", createInput->FileName );
    printf( "     Type: %s\n",
                    createInput->DiskType == RAMDISK_TYPE_FILE_BACKED_VOLUME ? "volume" : "disk" );
    printf( "   Length: 0x%I64x\n", createInput->DiskLength );
    printf( "   Offset: 0x%x\n", createInput->DiskOffset );
    printf( "     GUID: %wZ\n", &guidString );
    printf( "  Options:" );
    printf( "%s; ", createInput->Options.Fixed ? "fixed" : "removable" );
    printf( "%s; ", createInput->Options.Readonly ? "readonly" : "writeable" );
    printf( "%s; ", createInput->Options.NoDriveLetter ? "no drive letter" : "drive letter" );
    printf( "%s; ", createInput->Options.Hidden ? "hidden" : "visible" );
    printf( "%s\n", createInput->Options.NoDosDevice ? "no DosDevice" : "DosDevice" );

    ok = DeviceIoControl(
            controlHandle,
            FSCTL_CREATE_RAM_DISK,
            createInput,
            controlSize,
            NULL,
            0,
            &returned,
            FALSE
            );

    if ( !ok ) {
       errorCode = GetLastError();
       printf( "Error creating RAM disk: %d\n", errorCode );
       PrintError( errorCode );
       return 1;
    }
   
    printf( "RAM disk created\n" );

    FindDisk( createInput->DiskType, &guidString, FALSE );

    return 0;

} // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rc\output.h ===
/***********************************************************************
* Microsoft (R) Debugging Information Dumper
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

void OutputInit();

int StdOutFlush();
int __cdecl StdOutPrintf(const wchar_t *, ...);
int StdOutPutc(wchar_t);
int StdOutPuts(const wchar_t *);
int StdOutVprintf(const wchar_t *, va_list);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rc\rc.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include "output.h"


extern "C"
{
int WINAPI RCW(HWND, int, RC_MESSAGE_CALLBACKW, RC_PARSE_CALLBACKW, int, wchar_t *[]);
BOOL WINAPI Handler(DWORD);
}


int CALLBACK UpdateRCStatus(ULONG ul1, ULONG ul2, LPCWSTR wsz)
{
    StdOutPuts(wsz);

    return(0);
}


int __cdecl wmain(int argc, wchar_t *argv[])
{
    int rc;

    OutputInit();

    SetConsoleCtrlHandler(Handler, TRUE);

    rc = RCW(NULL, 0, UpdateRCStatus, NULL, argc, argv);

    SetConsoleCtrlHandler(Handler, FALSE);

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\charmap.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* CHARMAP.C - Character mapping arrays                                 */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"
//#include "rcpptype.h"
//#include "charmap.h"

#define CHARMAP_SIZE    256

WCHAR Charmap[CHARMAP_SIZE] = {
    LX_EOS,                 /* 0x0, <end of string marker> */
    LX_ILL,                 /* 0x1 */
    LX_ILL,                 /* 0x2 */
    LX_ILL,                 /* 0x3 */
    LX_ILL,                 /* 0x4 */
    LX_ILL,                 /* 0x5 */
    LX_ILL,                 /* 0x6 */
    LX_ILL,                 /* 0x7 */
    LX_ILL,                 /* 0x8 */
    LX_WHITE,               /* <horizontal tab> */
    LX_NL,                  /* <newline> */
    LX_WHITE,               /* <vertical tab> */
    LX_WHITE,               /* <form feed> */
    LX_CR,                  /* <really a carriage return> */
    LX_ILL,                 /* 0xe */
    LX_ILL,                 /* 0xf */
    LX_ILL,                 /* 0x10 */
    LX_ILL,                 /* 0x11 */
    LX_ILL,                 /* 0x12 */
    LX_ILL,                 /* 0x13 */
    LX_ILL,                 /* 0x14 */
    LX_ILL,                 /* 0x15 */
    LX_ILL,                 /* 0x16 */
    LX_ILL,                 /* 0x17 */
    LX_ILL,                 /* 0x18 */
    LX_ILL,                 /* 0x19 */
    LX_EOS,                 /* 0x1a, ^Z */
    LX_ILL,                 /* 0x1b */
    LX_ILL,                 /* 0x1c */
    LX_ILL,                 /* 0x1d */
    LX_ILL,                 /* 0x1e */
    LX_ILL,                 /* 0x1f */
    LX_WHITE,               /* 0x20 */
    LX_BANG,                /* ! */
    LX_DQUOTE,              /* " */
    LX_POUND,               /* # */
    LX_ASCII,               /* $ */
    LX_PERCENT,             /* % */
    LX_AND,                 /* & */
    LX_SQUOTE,              /* ' */
    LX_OPAREN,              /* ( */
    LX_CPAREN,              /* ) */
    LX_STAR,                /* * */
    LX_PLUS,                /* + */
    LX_COMMA,               /* , */
    LX_MINUS,               /* - */
    LX_DOT,                 /* . */
    LX_SLASH,               /* / */
    LX_NUMBER,              /* 0 */
    LX_NUMBER,              /* 1 */
    LX_NUMBER,              /* 2 */
    LX_NUMBER,              /* 3 */
    LX_NUMBER,              /* 4 */
    LX_NUMBER,              /* 5 */
    LX_NUMBER,              /* 6 */
    LX_NUMBER,              /* 7 */
    LX_NUMBER,              /* 8 */
    LX_NUMBER,              /* 9 */
    LX_COLON,               /* : */
    LX_SEMI,                /* ; */
    LX_LT,                  /* < */
    LX_EQ,                  /* = */
    LX_GT,                  /* > */
    LX_QUEST,               /* ? */
    LX_EACH,                /* @ */
    LX_ID,                  /* A */
    LX_ID,                  /* B */
    LX_ID,                  /* C */
    LX_ID,                  /* D */
    LX_ID,                  /* E */
    LX_ID,                  /* F */
    LX_ID,                  /* G */
    LX_ID,                  /* H */
    LX_ID,                  /* I */
    LX_ID,                  /* J */
    LX_ID,                  /* K */
    LX_ID,                  /* L */
    LX_ID,                  /* M */
    LX_ID,                  /* N */
    LX_ID,                  /* O */
    LX_ID,                  /* P */
    LX_ID,                  /* Q */
    LX_ID,                  /* R */
    LX_ID,                  /* S */
    LX_ID,                  /* T */
    LX_ID,                  /* U */
    LX_ID,                  /* V */
    LX_ID,                  /* W */
    LX_ID,                  /* X */
    LX_ID,                  /* Y */
    LX_ID,                  /* Z */
    LX_OBRACK,              /* [ */
    LX_EOS,                 /* \ */
    LX_CBRACK,              /* ] */
    LX_HAT,                 /* ^ */
    LX_ID,                  /* _ */
    LX_ASCII,               /* ` */
    LX_ID,                  /* a */
    LX_ID,                  /* b */
    LX_ID,                  /* c */
    LX_ID,                  /* d */
    LX_ID,                  /* e */
    LX_ID,                  /* f */
    LX_ID,                  /* g */
    LX_ID,                  /* h */
    LX_ID,                  /* i */
    LX_ID,                  /* j */
    LX_ID,                  /* k */
    LX_ID,                  /* l */
    LX_ID,                  /* m */
    LX_ID,                  /* n */
    LX_ID,                  /* o */
    LX_ID,                  /* p */
    LX_ID,                  /* q */
    LX_ID,                  /* r */
    LX_ID,                  /* s */
    LX_ID,                  /* t */
    LX_ID,                  /* u */
    LX_ID,                  /* v */
    LX_ID,                  /* w */
    LX_ID,                  /* x */
    LX_ID,                  /* y */
    LX_ID,                  /* z */
    LX_OBRACE,              /* { */
    LX_OR,                  /* | */
    LX_CBRACE,              /* } */
    LX_TILDE,               /* ~ */
    LX_ILL,                 /* 0x7f */
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
};

WCHAR Contmap[CHARMAP_SIZE] = {
    LXC_SPECIAL,                                                /* 0x0, <end of string marker> */
    0,                                                          /* 0x1 */
    0,                                                          /* 0x2 */
    0,                                                          /* 0x3 */
    0,                                                          /* 0x4 */
    0,                                                          /* 0x5 */
    0,                                                          /* <end of buffer marker> */
    0,                                                          /* 0x7 */
    0,                                                          /* 0x8 */
    LXC_WHITE,                                                  /* <horizontal tab> */
    LXC_SPECIAL,                                                /* <newline>, this is NOT considered whitespace */
    LXC_WHITE,                                                  /* <vertical tab> */
    LXC_WHITE,                                                  /* <form feed> */
    0,                                                          /* <really a carriage return> */
    0,                                                          /* 0xe */
    0,                                                          /* 0xf */
    0,                                                          /* 0x10 */
    0,                                                          /* 0x11 */
    0,                                                          /* 0x12 */
    0,                                                          /* 0x13 */
    0,                                                          /* 0x14 */
    0,                                                          /* 0x15 */
    0,                                                          /* 0x16 */
    0,                                                          /* 0x17 */
    0,                                                          /* 0x18 */
    0,                                                          /* 0x19 */
    LXC_SPECIAL,                                                /* 0x1a */
    0,                                                          /* 0x1b */
    0,                                                          /* 0x1c */
    0,                                                          /* 0x1d */
    0,                                                          /* 0x1e */
    0,                                                          /* 0x1f */
    LXC_WHITE,                                                  /* 0x20 */
    0,                                                          /* ! */
    0,                                                          /* " */
    0,                                                          /* # */
    0,                                                          /* $ */
    0,                                                          /* % */
    0,                                                          /* & */
    0,                                                          /* ' */
    0,                                                          /* ( */
    0,                                                          /* ) */
    LXC_SPECIAL,                                                /* * */
    0,                                                          /* + */
    0,                                                          /* , */
    0,                                                          /* - */
    0,                                                          /* . */
    0,                                                          /* / */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,  /* 0 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,  /* 1 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 2 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 3 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 4 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 5 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 6 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 7 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT,                            /* 8 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT,                            /* 9 */
    0,                                                          /* : */
    0,                                                          /* ; */
    0,                                                          /* < */
    0,                                                          /* = */
    0,                                                          /* > */
    0,                                                          /* ? */
    0,                                                          /* @ */
    LXC_ID | LXC_XDIGIT,                                        /* A */
    LXC_ID | LXC_XDIGIT     | LXC_RADIX,                        /* B */
    LXC_ID | LXC_XDIGIT,                                        /* C */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* D */
    LXC_ID | LXC_XDIGIT,                                        /* E */
    LXC_ID | LXC_XDIGIT,                                        /* F */
    LXC_ID,                                                     /* G */
    LXC_ID | LXC_RADIX,                                         /* H */
    LXC_ID,                                                     /* I */
    LXC_ID,                                                     /* J */
    LXC_ID,                                                     /* K */
    LXC_ID,                                                     /* L */
    LXC_ID,                                                     /* M */
    LXC_ID,                                                     /* N */
    LXC_ID | LXC_RADIX,                                         /* O */
    LXC_ID,                                                     /* P */
    LXC_ID | LXC_RADIX,                                         /* Q */
    LXC_ID,                                                     /* R */
    LXC_ID,                                                     /* S */
    LXC_ID,                                                     /* T */
    LXC_ID,                                                     /* U */
    LXC_ID,                                                     /* V */
    LXC_ID,                                                     /* W */
    LXC_ID,                                                     /* X */
    LXC_ID,                                                     /* Y */
    LXC_ID,                                                     /* Z */
    0,                                                          /* [ */
    0,                                                          /* \ */
    0,                                                          /* ] */
    0,                                                          /* ^ */
    LXC_ID,                                                     /* _ */
    0,                                                          /* ` */
    LXC_ID | LXC_XDIGIT,                                        /* a */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* b */
    LXC_ID | LXC_XDIGIT,                                        /* c */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* d */
    LXC_ID | LXC_XDIGIT,                                        /* e */
    LXC_ID | LXC_XDIGIT,                                        /* f */
    LXC_ID,                                                     /* g */
    LXC_ID | LXC_RADIX,                                         /* h */
    LXC_ID,                                                     /* i */
    LXC_ID,                                                     /* j */
    LXC_ID,                                                     /* k */
    LXC_ID,                                                     /* l */
    LXC_ID,                                                     /* m */
    LXC_ID,                                                     /* n */
    LXC_ID | LXC_RADIX,                                         /* o */
    LXC_ID,                                                     /* p */
    LXC_ID | LXC_RADIX,                                         /* q */
    LXC_ID,                                                     /* r */
    LXC_ID,                                                     /* s */
    LXC_ID,                                                     /* t */
    LXC_ID,                                                     /* u */
    LXC_ID,                                                     /* v */
    LXC_ID,                                                     /* w */
    LXC_ID,                                                     /* x */
    LXC_ID,                                                     /* y */
    LXC_ID,                                                     /* z */
    0,                                                          /* { */
    0,                                                          /* | */
    0,                                                          /* } */
    0,                                                          /* ~ */
    0,                                                          /* 0x7f */
};


WCHAR
GetCharMap (
    WCHAR c
    )
{
    if (c == 0xFEFF)           // Byte Order Mark
        return (LX_BOM);
    else if (c > CHARMAP_SIZE)
        return (LX_ID);        // character beyond the ANSI set

    return (Charmap[c]);
}


void
SetCharMap (
    WCHAR c,
    WCHAR val
    )
{
    if (c > CHARMAP_SIZE)
       return;

    Charmap[((UCHAR)(c))] = val;
}


WCHAR
GetContMap (
    WCHAR c
    )
{
    if (c > CHARMAP_SIZE)
        return (LXC_ID);       // character beyong the ANSI set

    return (Contmap[c]);
}


void
SetContMap (
    WCHAR c,
    WCHAR val
    )
{
    if (c > CHARMAP_SIZE)
       return;

    Contmap[c] = val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\charmap.h ===
/*
**  charmap.h : P0 specific, also included by charmap.c
**  it defines the mapping used to go from simple chars to these predefined
**  values. this enables the compiler to use a compact switch stmt.
**  they have been grouped in what is believed to be the most beneficial
**  way, in that most switches will be checking those values which have
**  been grouped together.
*/
#define EOS_CHAR                L'\0'    /* end of string/buffer marker char */

#define LX_WHITE                0
#define LX_CR                   1
#define LX_SLASH                2              /* /, /=, comment start  */
#define LX_EOS                  3
#define LX_STAR                 4              /* *, *=, comment stop  */
#define LX_NL                   5
#define LX_BACKSLASH            6
#define LX_SQUOTE               7
#define LX_DQUOTE               8

#define LX_DOT                  9              /* . ... */
#define LX_BANG                 10             /* ! !=  */
#define LX_POUND                11             /* # ##  */
#define LX_PERCENT              12             /* % %=  */
#define LX_EQ                   13             /* = ==  */
#define LX_HAT                  14             /* ^ ^=  */
#define LX_OR                   15             /* | |= || */
#define LX_AND                  16             /* & && &= */
#define LX_PLUS                 17             /* + ++ += */
#define LX_MINUS                18             /* - -- -= ->  */
#define LX_LT                   19             /* < << <<= <= */
#define LX_GT                   20             /* > >= >> >>= */
#define LX_LSHIFT               21             /* << */
#define LX_RSHIFT               22             /* >> */

#define LX_ILL                  23
#define LX_CBRACE               24
#define LX_CBRACK               25
#define LX_COLON                26
#define LX_COMMA                27
#define LX_CPAREN               28
#define LX_NUMBER               29
#define LX_OBRACE               30
#define LX_OBRACK               31
#define LX_OPAREN               32
#define LX_QUEST                33
#define LX_SEMI                 34
#define LX_TILDE                35
#define LX_MACFORMAL            36
#define LX_STRFORMAL            37
#define LX_CHARFORMAL           38
#define LX_NOEXPAND             39
#define LX_ID                   40
#define LX_EACH                 41

#define LX_LEADBYTE             42
#define LX_ASCII                43             /* to use for 'non-illegal' illegals */
#define LX_BOM                  44             /* Byte Order Mark */

#define LX_FORMALMARK           0x01
#define LX_FORMALSTR            0x02
#define LX_FORMALCHAR           0x03
#define LX_NOEXPANDMARK         0x04
#define CONTROL_Z               0x1a
/*
**  Charmap is indexed with a character value plus the above offset
*/
#define CHARMAP(c)              GetCharMap(c)
#define SETCHARMAP(c,val)       SetCharMap(c, val)

#define LX_IS_IDENT(c)  (CHARMAP(c) == LX_ID)
#define LX_IS_WHITE(c)  (CHARMAP(c) == LX_WHITE)
#define LX_IS_NUMBER(c) (CHARMAP(c) == LX_NUMBER)

#define LXC_BDIGIT      0x01            /* 0 - 1 */
#define LXC_ODIGIT      0x02            /* 0 - 7 */
#define LXC_DIGIT       0x04            /* 0 - 9 */
#define LXC_XDIGIT      0x08            /* a-f A-F 0-9 */
#define LXC_ID          0x10            /* continuation is part of an identifier */
#define LXC_RADIX       0x20            /* BbDdHhOoQq */
#define LXC_WHITE       0x40            /* whitespace */
#define LXC_SPECIAL     0x80            /* the char may have a special meaning */

#define CONTMAP(c)           GetContMap(c)
#define SETCONTMAP(c, val)   SetContMap(c, val)
/*
**      LXC_IS_ID(c) : is c part of an identifier
*/
#define LXC_IS_BDIGIT(c)        (CONTMAP(c) & LXC_BDIGIT)
#define LXC_IS_ODIGIT(c)        (CONTMAP(c) & LXC_ODIGIT)
#define LXC_IS_DIGIT(c)         (CONTMAP(c) & LXC_DIGIT)
#define LXC_IS_XDIGIT(c)        (CONTMAP(c) & LXC_XDIGIT)
#define LXC_IS_IDENT(c)         (CONTMAP(c) & LXC_ID)
#define LXC_IS_RADIX(c)         (CONTMAP(c) & LXC_RADIX)
#define LXC_IS_WHITE(c)         (CONTMAP(c) & LXC_WHITE)
#define IS_SPECIAL(c)           (CONTMAP(c) & LXC_SPECIAL)


// Function prototypes

WCHAR GetCharMap (WCHAR);
void  SetCharMap (WCHAR, WCHAR);
WCHAR GetContMap (WCHAR);
void  SetContMap (WCHAR, WCHAR);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\common.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    common.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define IN
#define OUT
#define INOUT

//
// An ID_WORD indicates the following WORD is an ordinal rather 
// than a string
// 

#define ID_WORD 0xffff

typedef struct _STRING {
        DWORD discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct _STRING *pnext;
                  DWORD  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  sz[1];
		} ss;
		WORD     Ordinal;
	} uu;
} STRING, *PSTRING, **PPSTRING;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz
#define pn             uu.ss.pnext

typedef struct _RESNAME {
    struct _RESNAME *pnext;    // The first three fields should be the
    PSTRING Name;              // same in both res structures
    DWORD   OffsetToData;      //

    PSTRING Type;
    struct _RESNAME *pnextRes;
    RESADDITIONAL	*pAdditional;
    DWORD   OffsetToDataEntry;
    USHORT  ResourceNumber;
    USHORT  NumberOfLanguages;
    POBJLST pObjLst;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
    struct _RESTYPE *pnext;    // The first three fields should be the
    PSTRING Type;              // same in both res structures
    DWORD   OffsetToData;      //

    struct _RESNAME *NameHeadID;
    struct _RESNAME *NameHeadName;
    DWORD  NumberOfNamesID;
    DWORD  NumberOfNamesName;
    POBJLST pObjLst;
} RESTYPE, *PRESTYPE, **PPRESTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\error.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include "rcmsgs.h"


#define MAX_ERRORS 100


/* defines for message types */
#define W_MSG   4000
#define E_MSG   2000
#define F_MSG   1000


void message(int msgtype, int msgnum, va_list arg_list)
{
    SET_MSGV(msgnum, arg_list);

    static wchar_t mbuff[512];
    wchar_t *p = mbuff;
    wchar_t *pT;
    const wchar_t *msgname;
    wchar_t msgnumstr[32];

    if (Linenumber > 0 && Filename) {
        swprintf(p, L"%s(%u) : ", Filename, Linenumber);
        p += wcslen(p);
#if 0
    } else {
        wcscpy(p, L"RC : ");
        p += wcslen(p);
#endif
    }

    if (msgtype) {
        switch (msgtype) {
            case W_MSG:
                msgname = L"warning";
                break;

            case E_MSG:
                msgname = L"error";
                break;

            case F_MSG:
                msgname = L"fatal error";
                break;
        }

        wcscpy(p, msgname);
        p += wcslen(msgname);

        swprintf(msgnumstr, L" RC%04u: ", msgnum);
        wcscpy(p, msgnumstr);
        p += wcslen(msgnumstr);

        wcscpy(p, Msg_Text);
        p += wcslen(p);
    }

    DoMessageCallback(TRUE, mbuff);
}


void fatal(int msgnum, ...)
{
    va_list arg_list;

    va_start(arg_list, msgnum);

    message(F_MSG, msgnum, arg_list);

    va_end(arg_list);

    quit(NULL);
}


void error(int msgnum, ...)
{
    va_list arg_list;

    va_start(arg_list, msgnum);

    message(E_MSG, msgnum, arg_list);

    va_end(arg_list);

    if (++Nerrors > MAX_ERRORS) {
        fatal(1003, MAX_ERRORS);            /* die - too many errors */
    }
}


void warning(int msgnum, ...)
{
    va_list arg_list;

    va_start(arg_list, msgnum);

    message(W_MSG, msgnum, arg_list);

    va_end(arg_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\grammar.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* GRAMMAR.H - Grammar definitions for terminals                        */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#define L_NOTOKEN       1L
#define L_IDENT         2L
#define L_STRING        3L
#define L_CFLOAT        4L
#define L_CDOUBLE       5L
#define L_CLDOUBLE      6L
#define L_CINTEGER      7L
#define L_LONGINT       8L
#define L_CUNSIGNED     9L
#define L_LONGUNSIGNED  10L
#define L_AUTO          11L
#define L_STATIC        12L
#define L_EXTERN        13L
#define L_REGISTER      14L
#define L_TYPEDEF       15L
#define L_FORTRAN       16L
#define L_PASCAL        17L
#define L_C             18L
#define L_INTERRUPT     19L
#define L_SAVEREGS      20L
#define L_LOADDS        21L
#define L_EXPORT        22L
#define L_ASM           23L
#define L_NEAR          24L
#define L_FAR           25L
#define L_HUGE          26L
#define L_CONST         27L
#define L_VOLATILE      28L
#define L_CHAR          29L
#define L_INT           30L
#define L_FLOAT         31L
#define L_DOUBLE        32L
#define L_SHORT         33L
#define L_LONG          34L
#define L_VOID          35L
#define L_SIGNED        36L
#define L_UNSIGNED      37L
#define L_ENUM          38L
#define L_ENUM_TAG      39L
#define L_STRUCT        40L
#define L_STRUCT_TAG    41L
#define L_UNION         42L
#define L_UNION_TAG     43L
#define L_AND           44L
#define L_ANDAND        45L
#define L_ANDEQ         46L
#define L_ASSIGN        47L
#define L_BIT           48L
#define L_COLON         49L
#define L_COMMA         50L
#define L_DECR          51L
#define L_DIV           52L
#define L_DIVEQ         53L
#define L_EQUALS        54L
#define L_EXCLAIM       55L
#define L_EXTRACT       56L
#define L_GT            57L
#define L_GTEQ          58L
#define L_INCR          59L
#define L_LBRACK        60L
#define L_LSHFTEQ       61L
#define L_LSHIFT        62L
#define L_LT            63L
#define L_LTEQ          64L
#define L_MINUS         65L
#define L_MINUSEQ       66L
#define L_MOD           67L
#define L_MODEQ         68L
#define L_MULT          69L
#define L_MULTEQ        70L
#define L_NOTEQ         71L
#define L_OR            72L
#define L_OREQ          73L
#define L_OROR          74L
#define L_PERIOD        75L
#define L_PLUS          76L
#define L_PLUSEQ        77L
#define L_POINTSTO      78L
#define L_PREDECR       79L
#define L_PREINCR       80L
#define L_QUEST         81L
#define L_RSHFTEQ       82L
#define L_RSHIFT        83L
#define L_TILDE         84L
#define L_UMINUS        85L
#define L_XOR           86L
#define L_XOREQ         87L
#define L_ARG           88L
#define L_ASOP          89L
#define L_BREAK         90L
#define L_CASE          91L
#define L_CAST          92L
#define L_CLASS         93L
#define L_CONSTANT      94L
#define L_CONTINUE      95L
#define L_DEFAULT       96L
#define L_DIVOP         97L
#define L_DO            98L
#define L_ELLIPSIS      99L
#define L_ELSE          100L
#define L_ENTRY         101L
#define L_EOF           102L
#define L_EQUOP         103L
#define L_FILE          104L
#define L_FOR           105L
#define L_FUNCTION      106L
#define L_GOTO          107L
#define L_IF            108L
#define L_INCOP         109L
#define L_INIT          110L
#define L_LCURLY        111L
#define L_LINE          112L
#define L_LPAREN        113L
#define L_INTRINSIC     114L
#define L_MODIFIER      115L
#define L_MODULE        116L
#define L_RBRACK        117L
#define L_RCURLY        118L
#define L_RELOP         119L
#define L_RETURN        120L
#define L_RPAREN        121L
#define L_SELF          122L
#define L_SEMI          123L
#define L_SHIFTOP       124L
#define L_SIZEOF        125L
#define L_STUNOP        126L
#define L_SW            127L
#define L_SWEXP         128L
#define L_TYPE          129L
#define L_TYPENAME      130L
#define L_UPLUS         131L
#define L_WHILE         132L

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\getmsg.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


void __cdecl SET_MSGV(int msgnumber, va_list arg_list)
{
    DWORD cb = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE,
                              hInstance,
                              msgnumber,
                              0,
                              Msg_Text,
                              sizeof(Msg_Text) / sizeof(wchar_t),
                              &arg_list);

    if (cb == 0) {
#if DBG
        printf("Internal error : message not found: %d\n", msgnumber);
#endif

        Msg_Text[0] = L'\0';
    }
}


void __cdecl SET_MSG(int msgnumber, ...)
{
    va_list arg_list;

    va_start(arg_list, msgnumber);

    SET_MSGV(msgnumber, arg_list);

    va_end(arg_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\getflags.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/************************************************************************/
/* Define function specific macros and global vars                      */
/************************************************************************/
static WCHAR     *ErrString;   /* Store string pointer in case of error */


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
int getnumber   (const wchar_t *);
int isita       (const wchar_t *, const wchar_t);
void substr     (struct cmdtab *, wchar_t *, int);
int tailmatch   (const wchar_t *, const wchar_t *);



/************************************************************************
 *      crack_cmd(table, string, func, dup)
 *              set flags determined by the string based on table.
 *              func will get the next word.
 *              if dup is set, any strings stored away will get pstrduped
 * see getflags.h for specific matching and setting operators
 *
 *  for flags which take parameters, a 'char' following the flag where 'char' is
 *  '#' : says the parameter string may be separated from the option.
 *              ie, "-M#" accepts "-Mabc" and "-M abc"
 *  '*' : says the parameter must be concatenated with the flag
 *              ie, "-A*" accepts only "-Axyz" not "-A xyz"
 *  if neither is specified a space is required between parameter and flag
 *              ie, "-o" accepts only "-o file" and not "-ofile"
 *
 * Modified by:         Dave Weil                       D001
 *                              recognize '-' and '/' as equivalent on MSDOS
 *
 ************************************************************************/

int
crack_cmd(
    struct cmdtab *tab,
    WCHAR *string,
    WCHAR *(*next)(void),
    int _dup
    )
{
    const wchar_t *format;
    wchar_t *str;

    if (!string) {
        return(0);
    }

    ErrString = string;
    for (; tab->type; tab++)            /* for each format */ {
        format = tab->format;
        str = string;
        for (; ; )                              /* scan the string */
            switch (*format) {
                /*  optional space between flag and parameter  */
                case L'#':
                    if ( !*str ) {
                        substr(tab, (*next)(), _dup);
                    } else {
                        substr(tab, str, _dup);
                    }
                    return(tab->retval);
                    break;

                /*  no space allowed between flag and parameter  */
                case L'*':
                    if (*str && tailmatch(format, str))
                        substr(tab, str, _dup);
                    else
                        goto notmatch;
                    return(tab->retval);
                    break;

                /*  space required between flag and parameter  */
                case 0:
                    if (*str) {                         /*  str left, no good  */
                        goto notmatch;
                    } else if (tab->type & TAKESARG) {  /*  if it takes an arg  */
                        substr(tab, (*next)(), _dup);
                    } else {                            /*  doesn't want an arg  */
                        substr(tab, (WCHAR *)0, _dup);
                    }
                    return(tab->retval);
                    break;
                case L'-':
                    if (L'-' == *str) {
                        str++;
                        format++;
                        continue;
                    } else {
                        goto notmatch;
                    }

                default:
                    if (*format++ == *str++)
                        continue;
                    goto notmatch;
            }
notmatch:
        ;
    }
    return(0);
}


/************************************************************************/
/* set the appropriate flag(s).  called only when we know we have a match */
/************************************************************************/
void
substr(
    struct cmdtab *tab,
    wchar_t *str,
    int _dup
    )
{
    const struct subtab *q;
    LIST * list;
    const wchar_t *string = str;

    switch (tab->type) {
        case FLAG:
            *(int *)(tab->flag) = 1;
            return;

        case UNFLAG:
            *(int *)(tab->flag) = 0;
            return;

        case NOVSTR:
            if (*(WCHAR **)(tab->flag)) {
                /* before we print it out in the error message get rid of the
                 * arg specifier (e.g. #) at the end of the format.
                 */
//                string = _wcsdup(tab->format);
//                string[wcslen(string)-1] = L'\0';
//
// message 1046 doesn't exist and don't know what it should be
//            SET_MSG(1046, string, *(WCHAR **)(tab->flag), str);
                fatal(1000);
                return;
            }

            /* fall through */

        case STRING:
            *(WCHAR **)(tab->flag) = (_dup ? _wcsdup(str) : str);
            return;

        case NUMBER:
            *(int *)(tab->flag) = getnumber(str);
            return;

        case PSHSTR:
            list = (LIST * )(tab->flag);
            if (list->li_top > 0)
                list->li_defns[--list->li_top] = (_dup ? _wcsdup(str) : str);
            else {
                fatal(1047, tab->format, str);
            }
            return;

        case SUBSTR:
            for ( ; *str; ++str) {  /*  walk the substring  */
                for (q = (struct subtab *)tab->flag; q->letter; q++) {
                    /*
                                    **  for every member in the table
                                    */
                    if (*str == (WCHAR)q->letter)
                        switch (q->type) {
                        case FLAG:
                            *(q->flag) = 1;
                            goto got_letter;
                        case UNFLAG:
                            *(q->flag) = 0;
                            goto got_letter;
                        default:
                            goto got_letter;
                        }
                }
got_letter:
                if (!q->letter) {
                    fatal(1048, *str, ErrString);
                }
            }
            return;

        default:
            return;
    }
}


/************************************************************************/
/* Parse the string and return a number 0 <= x < 0xffff (64K)           */
/************************************************************************/
int
getnumber (
    const wchar_t *str
    )
{
    long i = 0;
    const wchar_t *ptr = str;

    for (; iswspace(*ptr); ptr++)
        ;
    if (!iswdigit(*ptr) || (((i = wcstol(ptr, NULL, 10)) >= 65535) ||  i < 0)) {
        fatal(1049, str);            /* invalid numerical argument, 'str' */
    }
    return((int) i);
}


/************************************************************************/
/*  is the letter in the string?                                        */
/************************************************************************/
int
isita (
    const wchar_t *str,
    const wchar_t let
    )
{
    if (str)
        while (*str)
            if (*str++ == let)
                return(1);

    return(0);
}


/************************************************************************/
/* compare a tail format (as in *.c) with a string.  if there is no     */
/* tail, anything matches.  (null strings are detected elsewhere)       */
/* the current implementation only allows one wild card                 */
/************************************************************************/
int
tailmatch (
    const wchar_t *format,
    const wchar_t *str
    )
{
    const wchar_t *f = format;
    const wchar_t *s = str;

    if (f[1] == 0)      /*  wild card is the last thing in the format, it matches */
        return(1);

    while (f[1])                /*  find char in front of null in format  */
        f++;

    while (s[1])                /*  find char in front of null in string to check  */
        s++;

    while (*s == *f) {  /*  check chars walking towards front */
        s--;
        f--;
    }
    /*
**  if we're back at the beginning of the format
**  and
**  the string is either at the beginning or somewhere inside
**  then we have a match.
**
**  ex format == "*.c", str == "file.c"
**      at this point *f = '*' and *s == 'e', since we've kicked out of the above
**  loop. since f==format and s>=str this is a match.
**  but if format == "*.c" and str == "file.asm" then
**  *f == 'c' and *s = 'm', f != format and no match.
*/
    return((f == format) && (s >= str));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\getflags.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

/*
 * the format strings may be:
 *              .*                      must match exactly
 *              .*\*.*          head and tail must match, with wild card in middle
 *              .*#                     head must match. tail can either be adjacent or next word
 *      at the moment '-' is not treated specialy
 *  note that 'middle' may be at either end since '.*' matches null.
 */

#define TAKESARG  0x20           /* tag to indicate argument or not */
#define FLAG      1              /* set the flag */
#define STRING    2 | TAKESARG   /* set the string, either from here, or next word */
#define SUBSTR    3 | TAKESARG   /* set single letter flags from substring */
#define NUMBER    4 | TAKESARG   /* set read in the number */
#define UNFLAG    5              /* turn the flag off */
#define PSHSTR    6 | TAKESARG   /* like string, but puts it on a LIST structure */
#define NOVSTR    7 | TAKESARG   /* like string, but complains about overwriting */

#define NUM_ARGS                50   /* Limit of flags passed from driver to pass */
#define MSC_ENVFLAGS            "MSC_CMD_FLAGS"
            /* Environment variable flags passed in, used for getenv() */
#define PUT_MSC_ENVFLAGS        "MSC_CMD_FLAGS="
            /* Environment variable flags passed in, used for putenv() */

/* return values from getflags */
#define R_SWITCH        1
#define R_CFILE         2
#define R_ASMFILE       3
#define R_OBJFILE       4
#define R_ERROR         5
#define R_FILE          6
#define R_EXIT          7
#define R_FFILE         8
#define R_PFILE         9
#define R_AFILE         10
#define R_OFILE         11
/* r. nevin, 1/11/85 */
#define R_HELP          12
/* b. nguyen, 4/7/86 */
#define R_HELPC         13
#define R_HELPF         14

struct cmdtab
        {
        const wchar_t *format;   /* format matching string */
        char  *flag;             /* pointer to what to fill in */
/*  this is really a
 *      union
 *              {
 *              WCHAR **str;
 *              int  *flag;
 *              struct subtab *sub;
 *              struct LIST *list;
 *              } cm;
 *      but you cant initialize unions so we have to fake it.
 */
        char retval;            /* crack_cmd will return whatever is here */
        UCHAR type;             /* control mask */
        };

struct subtab
        {
        int letter;
        int type;
        int *flag;
        };


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\makefile.inc ===
msg00001.bin rcmsgs.h rcmsgs.rc: rcmsgs.mc
	mc -v rcmsgs.mc

$(NTTARGETFILE0): msg00001.bin rcdll.rc rcmsgs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\ltoa.c ===
#include "rcpptype.h"

/* Long to ASCII conversion routine - used by print, and those programs
 * which want to do low level formatted output without hauling in a great
 * deal of extraneous code.  This will convert a long value to an ascii
 * string in any radix from 2 - 16.
 * RETURNS - the number of characters in the converted buffer.
 */

static WCHAR digits[] = {
    L'0', L'1', L'2', L'3', L'4',
    L'5', L'6', L'7', L'8', L'9',
    L'a', L'b', L'c', L'd', L'e', L'f'
};

#define BITS_IN_LONG  (8*sizeof(long))

int
zltoa(
    long aval,
    register WCHAR *buf,
    int base
    )
{
    // if unsigned long wont work on your host, you will probably have
    // to use signed long and accept this as not working for negative
    // numbers.

    register unsigned long val;
    register WCHAR *p;
    WCHAR tbuf[BITS_IN_LONG];
    int size = 0;

    p = tbuf;
    *p++ = L'\0';

    if (aval < 0 && base == 10) {
        *buf++ = L'-';
        val = -aval;
        size++;
    } else {
        val = aval;
    }

    do {
        *p++ = digits[val % base];
    } while (val /= base);

    while ((*buf++ = *--p) != 0) {
        ++size;
    }

    return(size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\globals.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/* shared strings */
const WCHAR   Union_str[] = L"union";
const WCHAR   Struct_str[] = L"struct";
const WCHAR   Cdecl_str[] = L"cdecl";
const WCHAR   Cdecl1_str[] = L"cdecl L";
const WCHAR   Fortran_str[] = L"fortran";
const WCHAR   Fortran1_str[] = L"fortran L";
const WCHAR   Pascal_str[] = L"pascal";
const WCHAR   Pascal1_str[] = L"pascal L";
const WCHAR   PPelse_str[] = L"#else";
const WCHAR   PPendif_str[] = L"#endif";
const WCHAR   PPifel_str[] = L"#if/#elif";
const WCHAR   Syntax_str[] = L"syntax error";


PFILE   OUTPUTFILE;                     /* File for output of program */

WCHAR   *A_string;                      /* model encoding */
WCHAR   *Debug;                         /* debugging switches */
WCHAR   *Input_file;                    /* the input .rc file */
WCHAR   *Output_file;                   /* the output .res file */
WCHAR   *Q_string;                      /* hardware characteristics */
WCHAR   *Version;
UINT    uiDefaultCodePage;
UINT    uiCodePage;

int     In_alloc_text;
int     Bad_pragma;
int     Cross_compile;                  /* is this a cross compile ? */
int     Ehxtension;                     /* near/far keywords, but no huge */
int     HugeModel;                      /* Huge Model program ?? */
int     Inteltypes;                     /* using strict Intel types or not */
int     Nerrors;
int     NoPasFor;                       /* no fortran/pascal keywords ? */
int     Out_funcdef;                    /* output function definitions */
int     Plm;                            /* non-C calling sequence */
int     Prep;                           /* preprocess */
int     Srclist;                        /* put msgs to il file if source listing */

int     Cmd_intrinsic;                  /* implicit intrinsics */
int     Cmd_loop_opt;
int     Cmd_pointer_check;

int     Symbolic_debug;                 /* Whether to put out dbil info or not */
int     Cflag;                          /* leave in comments */
int     Eflag;                          /* insert #line */
int     Jflag;                          /* no Kanji */
int     Pflag;                          /* no #line */
int     Rflag;                          /* mkhives - no exponent missing error */
int     ZcFlag;                         /* case insensitive compare */
int     In_define;
int     InInclude;
int     InIf;
int     Macro_depth;
int     Linenumber;

CHAR    chBuf[MED_BUFFER+1];
WCHAR   Reuse_W[BIG_BUFFER];
WCHAR   Filebuff[MED_BUFFER+1];
WCHAR   Macro_buffer[BIG_BUFFER * 4];

WCHAR   Reuse_Include[MED_BUFFER+1];

token_t Basic_token = L_NOTOKEN;
LIST    Defs = {MAXLIST};               /* -D list */
LIST    UnDefs = {MAXLIST};             /* -U list */
LIST    Includes = {MAXLIST, {0}};      /* for include file names */
WCHAR   *Path_chars = L"/";             /* path delimiter chars */
WCHAR   *Basename = L"";                /* base IL file name */
WCHAR   *Filename = Filebuff;

int     Char_align = 1;                 /* alignment of chars in structs */
int     Cmd_stack_check = TRUE;
int     Stack_check = TRUE;
int     Prep_ifstack = -1;
int     Switch_check = TRUE;
int     Load_ds_with;
int     Plmn;
int     Plmf;
int     On_pound_line;
int     Listing_value;
hash_t  Reuse_W_hash;
UINT    Reuse_W_length;
token_t Currtok = L_NOTOKEN;

int     Extension = TRUE;               /* near/far keywords? */
int     Cmd_pack_size = 2;
int     Pack_size = 2;

lextype_t yylval;

/*** I/O Variable for PreProcessor ***/
ptext_t Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
wchar_t  Msg_Text[MSG_BUFF_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\mktable.c ===
/*****************************************************************************
 * mktable - table-building program to ease table maintenance problems
 *
 * DESCRIPTION
 *  Several parts of the FORTRAN compiler need large tables.
 *  For example, the lexer contains tables of keywords and multicharacter
 *  tokens; the intrinsic-function handler contains a table of all the
 *  FORTRAN intrinsic functions.
 *  Maintaining these tables can be aggravating, since they are typically
 *  large and involve lots of drudge work (like changing many sequentially-
 *  numbered macro definitions) to modify.
 *
 *  `mktable' can be used to build tables automatically as part of the
 *  usual compiler building process.  Its usages and semantics are as
 *  follows.
 *
 *  `mktable' takes a "table" file on its standard input.  Each line of
 *  the table file has one of the following forms:
 *
 *      # commentary information
 *      "key-string" [index-macro-name [arbitrary-stuff]]
 *      <blank line>
 *
 *  The key string and arbitrary-stuff form the contents of a single
 *  table record.  The index-macro-name is #define'd to be the index
 *  of the given record in the table.  If the index-macro-name is absent or
 *  is an empty string ("") then no macro definition is produced for the
 *  record.
 *
 *  `mktable' produces its output on four files:
 *      mktable.keys: the key string
 *      mktable.defs: #define <index_macro_name> <index to mktable.keys>
 *      mktable.indx: contains the initialization part of a definition
 *          for an index array for key-letter indexed tables,
 *          or the initialization part of a collision-resolution
 *          table for linear-list hashed tables.
 *          (not generated for sorted or _open-addressed tables.)
 *      mktable.info: contains arbitrary-stuff
 *
 *  For example, if the table to be defined were named "symtab" and the
 *  table being constructed was of the "sorted" type (suitable for binary
 *  search),
 *
 *      # contents of symtab:
 *      "alpha" ST_ALPHA    2, 4, MONADIC
 *      "gamma" ST_GAMMA    2, 3, MONADIC
 *      "delta" ST_DELTA    2, 1, DYADIC
 *      "epsilon"
 *
 *  then `mktable' produces the following in mktable.keys:
 *
 *      "alpha","delta","epsilon","gamma"
 *
 *  and the following in mktable.defs:
 *
 *      #define ST_ALPHA 0
 *      #define ST_DELTA 1
 *      #define ST_GAMMA 2
 *
 *  and in mktable.info :
 *
 *      {2, 4, MONADIC}, {2, 1, DYADIC}, {0}, {2, 3, MONADIC}
 *
 *  The files might be included in a C source program in the
 *  following way:
 *
 *      #include "mktable.defs"
 *      ...
 *      char    *symname[] = {
 *      #   include "mktable.keys"
 *          };
 *      struct syminfo
 *          {
 *          int size;
 *          int cycles;
 *          int arity;
 *          };
 *      struct syminfo symtab[] = {
 *      #   include "mktable.info"
 *          };
 *
 *  The `mktable' command itself is used in one of the following ways:
 *
 *  mktable "open" size <tablefile
 *      This form creates an _open-addressed hash table, keyed on
 *      the string fields at the beginning of each record in the
 *      table file.  The hash function used is the absolute value
 *      of the sum of all the characters in a key, modulo the table
 *      size.  The collision resolution function is simply one plus
 *      the last hash, modulo the table size.
 *      Since some of the entries in the hash table may be empty,
 *      and `mktable' has no way of knowing how to fill them,
 *      one of the records supplied by the user will be replicated
 *      in the empty entries with its key value set to NULL.
 *      "table.c" will be created with the hash table itself, and
 *      "table.h" will be created with index-macro definitions that
 *      may be used to index directly into the table in "table.c".
 *
 *  mktable "hashed" size <tablefile
 *      This form creates a hash table keyed on the string fields
 *      at the beginning of each table file record.  The hash function
 *      is the absolute value of the sum of all the characters in a
 *      key, modulo the table size.  Collision resolution is handled
 *      with linear chaining, as follows:  If two keys hash to the
 *      same table location, the first one will be placed in the table,
 *      and the corresponding entry of the collision resolution vector
 *      will contain the (integer) index of the next table slot to be
 *      checked for the hash synonym.  When the collision resolution
 *      vector entry is -1, the end of the chain has been reached.
 *      Note that since all entries are stored in the main table, the
 *      `size' must be at least as large as the number of entries.
 *      As with _open addressing, some slots in the table may be
 *      padded with a replicated entry (key value set to NULL).
 *      "table.c" receives the hash table.  "table.h" receives the
 *      index-macro definitions that will index into the table in
 *      "table.c".  "tabindex.c" receives the conflict resolution
 *      vector.
 *
 *  mktable "sorted" <tablefile
 *      This form creates a table sorted in ascending order, keyed
 *      on the string fields at the beginning of each record in the
 *      table file.  Comparisons are ordered according to the ASCII
 *      values of the characters being compared.
 *      "table.c" will be created with the sorted table itself, and
 *      "table.h" will be created with index-macro definitions that
 *      may be used to index directly into the table in "table.c".
 *
 *  mktable "key-letter" <tablefile
 *      This form creates a key-letter-indexed table.
 *      The string fields serve as the
 *      key letter.  An auxiliary table indexed from 'A' to 'Z'+1
 *      gives the starting index of all the entries whose keys begin
 *      with each letter (the last entry duplicates the entry for 'Z').
 *      "table.c" will contain the sorted table.  "tabindex.c" will
 *      contain the auxiliary index table information.  "table.h" will
 *      contain the index-macro definitions that may be used to index
 *      directly into the "table.c" table.
 *      Note that key-letter tables are sorted in a peculiar way;
 *      in ascending order by first letter of the key, but descending
 *      order by the remainder of the key.  This is required by
 *      FORTRAN, to insure that longer keywords are matched before
 *      shorter keywords that are initial substrings of the longer
 *      keywords.
 *      Also note that the key strings themselves are missing the first
 *      char, since by indexing into the table, we are always assured
 *      of having matched the first char.
 *
 * AUTHOR
 *      February, 1984      Allen Akin
 *
 * MODIFICATIONS
 *  March 8, 1984       Allen Akin
 *      Added linear-list resolved hashing.
 *****************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define MAXRECORDS  300     /* maximum-size table we can handle */
#define MAXLINE     82      /* maximum line length (incl "\n\0") */

#define HASHED      0       /* flag used by table loader */
#define LINEAR      1       /* ditto */
#define OPENADDR    2       /* ditto */

#define KEYFILE         "mktable.key"   /* name of table output file */
#define DEFFILE         "mktable.def"   /* name of index defs output file */
#define INDEXFILE       "mktable.ind"   /* name of table index output file */
#define INFOFILE        "mktable.inf"   /* gots the infos in it */

typedef struct rec {
    char *key;      /* key-string field */
    char *id;       /* index macro identifier */
    char *other;    /* other stuff in the record - output untouched */
    struct rec *link;   /* pointer to next record in hash synonyms list */
} Rec_t;

int Upper = 0;

FILE *Fkeys, *Findex, *Fdefs, *Finfo;

/************************************************************************/
/* Function Prototypes                          */
/************************************************************************/
void main (int argc, char **argv);
void usage (void);
void error(char * message);
void open_addr(int size);
void hash_linear(int size);
void sorted(void);
void key_letter(void);
int load(Rec_t *record, int method, int size);
void startoutput(void);
void endoutput(void);
void outrec(Rec_t *rec);
void outdef(char *name, int value);
void outinx(int value);
void sortrec(Rec_t **rptr, int size);
int hash(register char *name);


/************************************************************************/
/* Program code                             */
/************************************************************************/
void  __cdecl
main (
    int argc,
    char **argv
    )
{
    if (argc <= 1)
        usage();

    if(strcmp(argv[1], "-U") == 0) {
        Upper = 1;
        argv++;
        argc--;
    }

    if (strcmp(argv[1], "open") == 0) {
        if (argc != 3)
            usage();
        open_addr(atoi(argv[2]));
    } else if (strcmp(argv[1], "hashed") == 0) {
        if (argc != 3)
            usage();
        hash_linear(atoi(argv[2]));
    } else if (strcmp(argv[1], "sorted") == 0) {
        if (argc != 2)
            usage();
        sorted();
    } else if (strcmp(argv[1], "key-letter") == 0) {
        if (argc != 2)
            usage();
        key_letter();
    } else
        usage();
    exit(0);
}

void
usage (
    void
    )
{
    error("usage: mktable (open SIZE | hashed SIZE | sorted | key-letter) <table-master");
}

void
error(
    char * message
    )
{
    fprintf(stderr, "%s\n", message);
    exit(1);
}

void
open_addr(
    int size
    )
{
    register Rec_t *record;     /* points to array storing all records */
    Rec_t defrec;               /* "default" record for empty array slot */
    register int i;

    if (size <= 0)
        error("hash table size specified is less than zero");

    if ((record = (Rec_t *)calloc(size, sizeof(Rec_t))) == NULL)
        error("insufficient memory for hash table");

    for (i = 0; i < size; ++i)
        record[i].key = NULL;

    if (load(record, OPENADDR, size) == 0)
        error("couldn't find any input records");

    defrec.key = NULL;
    defrec.id = NULL;
    for (i = 0; i < size; ++i)
    if (record[i].key != NULL)
        break;
    defrec.other = record[i].other;

    startoutput();

    for (i = 0; i < size; ++i) {
        if (record[i].key == NULL) {
            outrec(&defrec);
        } else {
            outrec(&record[i]);
            outdef(record[i].id, i);
        }
    }

    endoutput();
    _unlink(INDEXFILE);
}

void
hash_linear(
    int size
    )
{
    register Rec_t *record,     /* stores some records, all buckets */
                    *rp;
    Rec_t defrec;               /* default record for empty hash table slots */
    register int i,
                 nextslot,      /* next empty slot in main hash table */
                 prev;

    if (size <= 0)
        error("hash table size specified is less than zero");

    if ((record = (Rec_t *)calloc(size, sizeof(Rec_t))) == NULL)
        error("insufficient memory for hash table");

    for (i = 0; i < size; ++i) {
        record[i].key = NULL;
        record[i].link = NULL;
    }

    if ((i = load(record, HASHED, size)) == 0)
        error("couldn't find any input records");

    if (i > size)
        error("too many records to hold in table");

    defrec.key = NULL;
    defrec.id = NULL;
    for (i = 0; i < size; ++i) {
        if (record[i].key != NULL)
            break;
    }
    defrec.other = record[i].other;
    defrec.link = NULL;
    /*
     * The `load' routine has built a hash table `record'.
     * Each entry in `record' is either empty (key == NULL) or contains a record.
     * Each record may have a NULL link field, or a link field that points to
     * a hash synonym.
     * With this section of code, we rearrange the linked lists of hash synonyms
     * so that all the entries are stored in `record'.
     */
    nextslot = 0;
    for (i = 0; i < size; ++i) {
        if ((record[i].key != NULL) &&
            (record[i].link != NULL) &&
            ((record[i].link < record) || (record[i].link >= (record + size))))
        {
            for (prev = i, rp = record[i].link; rp != NULL; rp = rp->link) {
                while (record[nextslot].key != NULL)
                    ++nextslot;
                record[prev].link = &record[nextslot];
                record[nextslot] = *rp;
                prev = nextslot;
            }
        }
    }

    startoutput();

    for (i = 0; i < size; ++i) {
        if (record[i].key == NULL) {
            outrec(&defrec);
            outinx(-1);
        } else {
            outrec(&record[i]);
            if (record[i].link == NULL)
                outinx(-1);
            else
                outinx(record[i].link - record);    /* cvt. to inx in table */
            outdef(record[i].id, i);
        }
    }

    endoutput();
}

void
sorted(
    void
    )
{
    Rec_t  record[MAXRECORDS],
          *rptr[MAXRECORDS];
    register int i, size;

    size = load(record, LINEAR, MAXRECORDS);

    for (i = 0; i < size; ++i)
        rptr[i] = &record[i];

    sortrec(rptr, size);

    startoutput();

    for (i = 0; i < size; ++i) {
        outrec(rptr[i]);
        outdef(rptr[i]->id, i);
    }

    endoutput();
    _unlink(INDEXFILE);
}

void
key_letter(
    void
    )
{
    Rec_t  record[MAXRECORDS],
          *rptr[MAXRECORDS],
          *temp;
    register int i, size, j, k, l;

    register char lastletter;

    size = load(record, LINEAR, MAXRECORDS);

    for (i = 0; i < size; ++i)
        rptr[i] = &record[i];

    sortrec(rptr, size);

    for (i = 0; i < size; i = j) {
        for (j = i; j < size; ++j) {
            if (rptr[i]->key[0] != rptr[j]->key[0])
                break;
        }

        l = j - 1;

        for (k = i; k < l; ++k, --l) {
            temp = rptr[k];
            rptr[k] = rptr[l];
            rptr[l] = temp;
        }
    }

    startoutput();

    lastletter = (char)((Upper ? 'A' : '_') - 1);
    for (i = 0; i < size; ++i)
    {
        while (rptr[i]->key[0] > lastletter) {
            outinx(i);
            ++lastletter;
        }
        outrec(rptr[i]);
        outdef(rptr[i]->id, i);
    }


    for (; lastletter < (char)((Upper ? 'Z' : 'z') + 1); ++lastletter)
        outinx(size);

    endoutput();
}

int
load(
    Rec_t *record,
    int method,
    int size
    )
{
    char *line;
    register char *p;
    int rec, h, chainlen, maxchainlen = 0, collisions = 0;
    Rec_t r;

    for (rec = 0; ; ++rec)
    {
        if ((line = malloc(MAXLINE)) == NULL)
            error("insufficient memory to load records");

        if (fgets(line, MAXLINE, stdin) == NULL)
            break;

        if (rec >= size)
            error("too many records to handle");

        r.key = r.id = r.other = NULL;
        r.link = NULL;

        for (p = line; *p && isspace(*p); ++p)
            ;
        if (*p != '"') {
            free(line);
            --rec;
            continue;
        }
        r.key = ++p;
        for (; *p != '"'; ++p) {
            if(Upper && (islower(*p)))
                *p = (char)toupper(*p);
        }

        *p++ = '\0';

        for (; *p && isspace(*p); ++p)          /* skip space key and id */
            ;
        if (*p == '"' && *(p + 1) == '"') {     /* no id */
            r.id = NULL;
            p += 2;
        } else if (*p) {
            r.id = p++;                         /* id start */
            for (; *p && ( ! isspace(*p)); ++p) /* til first space */
                ;
            if(*p) {
                *p++ = '\0';                    /* terminate id */
            }
        }

        for (; *p && isspace(*p); ++p)      /* skip space til other info */
            ;
        if(*p) {
            r.other = p++;
            for (; *p != '\n' && *p != '\0'; ++p)
                ;
            *p = '\0';
        }

        if (method == LINEAR) {
            record[rec] = r;
        } else if (method == OPENADDR) {
            chainlen = 0;
            for(h = hash(r.key) % size; record[h].key; h = (h+1) % size) {
                ++chainlen;
                ++collisions;
            }
            maxchainlen = (chainlen < maxchainlen)? maxchainlen: chainlen;
            record[h] = r;
        } else { /* method == HASHED */
            Rec_t  *rp;

            h = hash(r.key) % size;
            if (record[h].key == NULL) {
                record[h] = r;
            } else {
                if ((rp = (Rec_t *)malloc(sizeof(Rec_t))) == NULL)
                    error("insufficient memory to store all records");
                *rp = record[h];
                r.link = rp;
                record[h] = r;
                ++collisions;
                chainlen = 1;
                for (rp = &record[h]; rp->link != NULL; rp = rp->link)
                    ++chainlen;
                maxchainlen = (chainlen < maxchainlen)? maxchainlen: chainlen;
            }
        }
    }

    if (method == HASHED || method == OPENADDR)
        fprintf(stderr, "%d collisions, max chain length %d\n", collisions, maxchainlen);

    return rec;
}

void
startoutput(
    void
    )
{
    if ((Fkeys = fopen(KEYFILE, "w")) == NULL)
        error("can't open keys output file");

    if ((Findex = fopen(INDEXFILE, "w")) == NULL)
        error("can't open index output file");

    if ((Fdefs = fopen(DEFFILE, "w")) == NULL)
        error("can't open definitions output file");

    if ((Finfo = fopen(INFOFILE, "w")) == NULL)
        error("can't open info output file");
}

void
endoutput(
    void
    )
{
    fclose(Fkeys);
    fclose(Findex);
    fclose(Fdefs);
    fclose(Finfo);
}

void outrec(Rec_t *rec)
{
    if (rec->key == NULL)
        fprintf(Fkeys, "NULL,\n");
    else
        fprintf(Fkeys, "\"%s\",\n", ((rec->key) + 1));

    if (rec->other == NULL)
        fprintf(Finfo, "{0},\n");
    else
        fprintf(Finfo, "{%s},\n", rec->other);
}

void
outdef(
    char *name,
    int value
    )
{
    if (name != NULL)
        fprintf(Fdefs, "#define %s %d\n", name, value);
}

void
outinx(
    int value
    )
{
    fprintf(Findex, "%d,\n", value);
}
/*
 * Following code defines the hash function used in `mktable' and in
 * the compiler.  Since we must guarantee they are the same function,
 * we use a single source file.
 *
 * `mktable' does not use the standard include file that the compiler
 * uses, so we define the allowable register declarations here.
 */
#define REG1 register
#define REG2 register
#define REG3 register

void
sortrec(
    Rec_t **rptr,
    int size
    )
{
    register int j, i, gap;
    Rec_t  *temp;

    for (gap = size / 2; gap > 0; gap /= 2) {
        for (i = gap; i < size; ++i) {
            for (j = i - gap; j >= 0; j -= gap) {
                if (strcmp(rptr[j]->key, rptr[j + gap]->key) <= 0)
                    break;
                temp = rptr[j];
                rptr[j] = rptr[j + gap];
                rptr[j + gap] = temp;
            }
        }
    }
}

int
hash(
    register char *name
    )
{
    register    int i;

    i = 0;
    while(*name) {
        i += *name++ ;
    }
    return(i) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\newexe.h ===
/*static WCHAR *SCCSID = L"@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 *      88/03/28        Craig Critchley Version 3.00 stuff
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    USHORT      e_magic;        /* Magic number */
    USHORT      e_cblp;         /* Bytes on last page of file */
    USHORT      e_cp;           /* Pages in file */
    USHORT      e_crlc;         /* Relocations */
    USHORT      e_cparhdr;      /* Size of header in paragraphs */
    USHORT      e_minalloc;     /* Minimum extra paragraphs needed */
    USHORT      e_maxalloc;     /* Maximum extra paragraphs needed */
    USHORT      e_ss;           /* Initial (relative) SS value */
    USHORT      e_sp;           /* Initial SP value */
    USHORT      e_csum;         /* Checksum */
    USHORT      e_ip;           /* Initial IP value */
    USHORT      e_cs;           /* Initial (relative) CS value */
    USHORT      e_lfarlc;       /* File address of relocation table */
    USHORT      e_ovno;         /* Overlay number */
    USHORT      e_res[ERESWDS]; /* Reserved words */
    LONG        e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    USHORT      ne_magic;       /* Magic number NE_MAGIC */
    BYTE        ne_ver;         /* Version number */
    BYTE        ne_rev;         /* Revision number */
    USHORT      ne_enttab;      /* Offset of Entry Table */
    USHORT      ne_cbenttab;    /* Number of bytes in Entry Table */
    LONG        ne_crc;         /* Checksum of whole file */
    USHORT      ne_flags;       /* Flag word */
    USHORT      ne_autodata;    /* Automatic data segment number */
    USHORT      ne_heap;        /* Initial heap allocation */
    USHORT      ne_stack;       /* Initial stack allocation */
    LONG        ne_csip;        /* Initial CS:IP setting */
    LONG        ne_sssp;        /* Initial SS:SP setting */
    USHORT      ne_cseg;        /* Count of file segments */
    USHORT      ne_cmod;        /* Entries in Module Reference Table */
    USHORT      ne_cbnrestab;   /* Size of non-resident name table */
    USHORT      ne_segtab;      /* Offset of Segment Table */
    USHORT      ne_rsrctab;     /* Offset of Resource Table */
    USHORT      ne_restab;      /* Offset of resident name table */
    USHORT      ne_modtab;      /* Offset of Module Reference Table */
    USHORT      ne_imptab;      /* Offset of Imported Names Table */
    LONG        ne_nrestab;     /* Offset of Non-resident Names Table */
    USHORT      ne_cmovent;     /* Count of movable entries */
    USHORT      ne_align;       /* Segment alignment shift count */
    USHORT      ne_cres;        /* Count of resource segments */
    BYTE        ne_exetyp;      /* Target operating system */
    BYTE        ne_flagsother;  /* Additional exe flags */
    USHORT      ne_gangstart;   /* offset to gangload area */
    USHORT      ne_ganglength;  /* length of gangload area */
    USHORT      ne_swaparea;    /* Minimum code swap area size */
    USHORT      ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   l                                  Private Library
 *    e                                 Errors in image
 *     xxxx                             Unused
 *         ww                           Uses PM API
 *           G                          Library GlobalAlloc above the line
 *            M                         Multiple Instance
 *             L                        Uses LIM 3.2
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEPRIVLIB       0x4000          /* Private Library */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEWINAPI        0x0300          /* Uses PM API. For binary compat */
#define NEEMSLIB        0x0040          /* Library GA above EMS line */
#define NEMULTINST      0x0020          /* multiple instance flag */
#define NELIM32         0x0010          /* LIM 32 expanded memory */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

/*
 *  Format of additional flags:
 *
 *  xxxx
 *      p                               Preload area defined after seg table
 *       P                              2.X supports protected mode
 *        F                             2.X supports proportional font
 *         L                            Long file name support
 */

#define NEPRELOAD       0x08            /* preload segments */
#define NEINPROT        0x04            /* protect mode */
#define NEINFONT        0x02            /* prop. system font */
#define NELONGNAMES     0x01            /* long file names */

struct new_seg                          /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
    USHORT      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            USHORT      ns_niter;       /* number of iterations */
            USHORT      ns_nbytes;      /* number of bytes */
            BYTE        ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            BYTE        ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    USHORT      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    BYTE        nr_stype;       /* Source type */
    BYTE        nr_flags;       /* Flag byte */
    USHORT      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            BYTE        nr_segno;       /* Target segment number */
            BYTE        nr_res;         /* Reserved */
            USHORT nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            USHORT nr_mod;      /* Index into Module Reference Table */
            USHORT nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */


/* Resource type or name string */
struct rsrc_string
    {
    USHORT rs_len;            /* number of bytes in string */
    WCHAR  rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    USHORT rt_id;
    USHORT rt_nres;
    LONG   rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    USHORT rn_offset;   /* file offset to resource data */
    USHORT rn_length;   /* length of resource data */
    USHORT rn_flags;    /* resource flags */
    USHORT rn_id;       /* resource name id */
    USHORT rn_handle;   /* If loaded, then global handle */
    USHORT rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    USHORT rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0expr.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
long and(void);
long andif(void);
long constant(void);
long constexpr(void);
long eqset(void);
long mult(void);
long or(void);
long orelse(void);
long plus(void);
long prim(void);
long relation(void);
long shift(void);
long xor(void);


/************************************************************************/
/* File Global Variables                                                */
/************************************************************************/
long    Currval = 0;
static  int             Parencnt = 0;


/************************************************************************/
/* do_constexpr()                                                       */
/************************************************************************/
long
do_constexpr(
    void
    )
{
    REG long    val;

    Parencnt = 0;
    Currtok = L_NOTOKEN;
    val = constexpr();
    if( Currtok == L_RPAREN ) {
        if( Parencnt-- == 0 ) {
            fatal(1012, L"(");                /* missing left paren */
        }
    } else if( Currtok != L_NOTOKEN ) {
        warning(4067, PPifel_str);
    }

    if( Parencnt > 0 ) {
        fatal(4012, L")");    /* missing right paren */
    }
    return(val);
}

/************************************************************************/
/* constexpr ::= orelse [ '?' orelse ':' orelse ];                      */
/************************************************************************/
long
constexpr(
    void
    )
{
    REG long            val;
    REG long            val1;
    long                val2;

    val = orelse();
    if( nextis(L_QUEST) ) {
        val1 = orelse();
        if( nextis(L_COLON) )
            val2 = orelse();
        return(val ? val1 : val2);
    }
    return(val);
}


/************************************************************************/
/* orelse ::= andif [ '||' andif ]* ;                                   */
/************************************************************************/
long
orelse(
    void
    )
{
    REG long val;

    val = andif();
    while(nextis(L_OROR))
        val = andif() || val;
    return(val);
}


/************************************************************************/
/* andif ::= or [ '&&' or ]* ;                                          */
/************************************************************************/
long
andif(
    void
    )
{
    REG long val;

    val = or();
    while(nextis(L_ANDAND))
        val = or() && val;
    return(val);
}


/************************************************************************/
/* or ::= xor [ '|' xor]* ;                                             */
/************************************************************************/
long
or(
    void
    )
{
    REG long val;

    val = xor();
    while( nextis(L_OR) )
        val |= xor();
    return(val);
}


/************************************************************************/
/* xor ::= and [ '^' and]* ;                                            */
/************************************************************************/
long
xor(
    void
    )
{
    REG long val;

    val = and();
    while( nextis(L_XOR) )
        val ^= and();
    return(val);
}


/************************************************************************/
/*  and ::= eqset [ '&' eqset]* ;                                       */
/************************************************************************/
long
and(
    void
    )
{
    REG long val;

    val = eqset();
    while( nextis(L_AND) )
        val &= eqset();
    return(val);
}


/************************************************************************/
/* eqset ::= relation [ ('==' | '!=') eqset] ;                          */
/************************************************************************/
long
eqset(
    void
    )
{
    REG long val;

    val = relation();
    if( nextis(L_EQUALS) )
        return(val == relation());
    if( nextis(L_NOTEQ) )
        return(val != relation());
    return(val);
}

/************************************************************************/
/* relation ::= shift [ ('<' | '>' | '<=' | '>=' ) shift] ;             */
/************************************************************************/
long
relation(
    void
    )
{
    REG long val;

    val = shift();
    if( nextis(L_LT) )
        return(val < shift());
    if( nextis(L_GT) )
        return(val > shift());
    if( nextis(L_LTEQ) )
        return(val <= shift());
    if( nextis(L_GTEQ) )
        return(val >= shift());
    return(val);
}


/************************************************************************/
/* shift ::= plus [ ('<< | '>>') plus] ;                                */
/************************************************************************/
long
shift(
    void
    )
{
    REG long val;

    val = plus();
    if( nextis(L_RSHIFT) )
        return(val >> plus());
    if( nextis(L_LSHIFT) )
        return(val << plus());
    return(val);
}


/************************************************************************/
/* plus ::= mult [ ('+' | '-') mult ]* ;                                */
/************************************************************************/
long
plus(
    void
    )
{
    REG long val;

    val = mult();
    for(;;) {
        if( nextis(L_PLUS) )
            val += mult();
        else if( nextis(L_MINUS) )
            val -= mult();
        else
            break;
    }
    return(val);
}


/************************************************************************/
/* mult ::= prim [ ('*' | '/' | '%' ) prim ]* ;                         */
/************************************************************************/
long
mult(
    void
    )
{
    REG long val;
    long PrimVal;

    val = prim();
    for(;;) {
        if( nextis(L_MULT) )
            val *= prim();
        else if( nextis(L_DIV) ) {
            PrimVal = prim();
            if (PrimVal)
                val /= PrimVal;
            else
                val = PrimVal;
        }
        else if( nextis(L_MOD) ) {
            PrimVal = prim();
            if (PrimVal)
                val %= PrimVal;
            else
                val = 0;
        }
        else
            break;
    }
    return(val);
}


/************************************************************************/
/* prim ::= constant | ( '!' | '~' | '-' ) constant                     */
/************************************************************************/
long
prim(
    void
    )
{
    if( nextis(L_EXCLAIM) )
        return( ! constant());
    else if( nextis(L_TILDE) )
        return( ~ constant() );
    else if( nextis(L_MINUS) )
        return(-constant());
    else
        return(constant());
}


/************************************************************************/
/* constant - at last, a terminal symbol  | '(' constexpr ')'           */
/************************************************************************/
long
constant(
    void
    )
{
    REG long val;

    if( nextis(L_LPAREN) ) {
        Parencnt++;
        val = constexpr();
        if( nextis(L_RPAREN) ) {
            Parencnt--;
            return(val);
        } else {
            fatal(1012, L")");
        }
    } else if( ! nextis(L_CINTEGER) ) {
        fatal(1017);    /* invalid integer constant expression */
    }

    return(Currval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0defs.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0DEFS.H - Defintions for PreProcessor parsing code                  */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

struct  s_defn  {
    pdefn_t     defn_next;              /*  pointer to next ident  */
    PWCHAR      defn_ident;             /*  pointer to name */
    PWCHAR      defn_text;              /*  definition substitution string  */
    char        defn_nformals;          /*number of formal arguments - can be <0*/
    char        defn_expanding;         /* are we already expanding this one? */
};

#define DEFN_IDENT(P)           ((P)->defn_ident)
#define DEFN_NAME(P)            (DEFN_IDENT(P))
#define DEFN_NEXT(P)            ((P)->defn_next)
#define DEFN_TEXT(P)            ((P)->defn_text)
#define DEFN_NFORMALS(P)        ((P)->defn_nformals)
#define DEFN_EXPANDING(P)       ((P)->defn_expanding)

#define FILE_EOS                0x01L
#define ACTUAL_EOS              0x02L
#define DEFINITION_EOS          0x04L
#define RESCAN_EOS              0x08L
#define BACKSLASH_EOS           0x10L
#define ANY_EOS                 ( FILE_EOS | ACTUAL_EOS | DEFINITION_EOS \
                                                                         | RESCAN_EOS | BACKSLASH_EOS )

/*
**      arbitrarily chosen characters that get special treatment when found
**      after EOS in handle_eos()
*/
#define EOS_ACTUAL              L'A'
#define EOS_DEFINITION          L'D'
#define EOS_RESCAN              L'R'
#define EOS_PAD                 L'P'

#define FROM_COMMAND            -2
#define PRE_DEFINED(P)          (DEFN_NFORMALS(P) < FROM_COMMAND)

typedef struct s_expstr {
    ptext_t     exp_string;     /* ptr to next character in stream aft macro */
    WCHAR       *exp_actuals;   /* ptr to start of actuals linked list */
    ptext_t     exp_text;       /* ptr to expanded text for this macro */
    pdefn_t     exp_macro;      /* ptr to macro defn */
    UCHAR       exp_nactuals;   /* number of actuals */
    UCHAR       exp_nactsexpanded;/* number of expanded actuals for handle_eos*/
} expansion_t;

/*
**      note that CURRENT_STRING usually points into an area in the macro
**      expansion buffer, but the first item used (Macro_depth equals 1) points
**      to text read from a file.  In some versions, the heap is reshuffled
**      and this pointer must be updated for the first item.
*/
#define CURRENT_STRING          Macro_expansion[Macro_depth].exp_string
#define CURRENT_ACTUALS         Macro_expansion[Macro_depth].exp_actuals
#define CURRENT_TEXT            Macro_expansion[Macro_depth].exp_text
#define CURRENT_MACRO           Macro_expansion[Macro_depth].exp_macro
#define CURRENT_NACTUALS        Macro_expansion[Macro_depth].exp_nactuals
#define CURRENT_NACTSEXPANDED Macro_expansion[Macro_depth].exp_nactsexpanded

/*
**      finds address after last element in an array. Used to check for
**      buffer overflows.
*/
#define LIMIT(a)        &(a)[sizeof(a) / sizeof(*a)]

#define IS_CHAR(c,uc)   (towupper(c) == (uc))
#define IS_B(c)         IS_CHAR(c, L'B')
#define IS_D(c)         IS_CHAR(c, L'D')
#define IS_E(c)         IS_CHAR(c, L'E')
#define IS_F(c)         IS_CHAR(c, L'F')
#define IS_H(c)         IS_CHAR(c, L'H')
#define IS_EL(c)        IS_CHAR(c, L'L')
#define IS_O(c)         IS_CHAR(c, L'O')
#define IS_Q(c)         IS_CHAR(c, L'Q')
#define IS_U(c)         IS_CHAR(c, L'U')
#define IS_X(c)         IS_CHAR(c, L'X')
#define IS_DOT(c)       (c == L'.')
#define IS_SIGN(c)      ((c == L'+') || (c ==L'-'))

#define P0_IF           0
#define P0_ELIF         1
#define P0_ELSE         2
#define P0_ENDIF        3
#define P0_IFDEF        4
#define P0_IFNDEF       5
#define P0_DEFINE       6
#define P0_INCLUDE      7
#define P0_PRAGMA       8
#define P0_UNDEF        9
#define P0_LINE         10
#define P0_NOTOKEN      11
#define P0_ERROR        12
#define P0_IDENT        13


#define HLN_NAME(s)     ((s).hln_name)
#define HLN_HASH(s)     ((s).hln_hash)
#define HLN_LENGTH(s)   ((s).hln_length)
#define HLN_IDENT_HASH(p)       (HLN_HASH(*(p)))
#define HLN_IDENT_LENGTH(p)     (HLN_LENGTH(*(p)))
#define HLN_IDENTP_NAME(p)      (HLN_NAME(*(p)))
#define HLN_TO_NAME(S)          ((PWCHAR)pstrndup(HLN_IDENTP_NAME(S),HLN_IDENT_LENGTH(S)))

#define HASH_MASK               0x5f

#define LIMIT_ID_LENGTH         31
#define LIMIT_NESTED_INCLUDES   1024
#define LIMIT_MACRO_DEPTH       64
#define LIMIT_STRING_LENGTH     2043
#define LEVEL_0                 0xffL

#define MUST_OPEN       1
#define MAY_OPEN        0

/*** The following are defined to use on the Token Table ***/

#define TS_STR(idx)     (Tokstrings[idx-L_NOTOKEN].k_text)
#define TS_VALUE(idx)   (Tokstrings[idx-L_NOTOKEN].k_token)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0io.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.H - Preprocessor I/O macros					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#define	MUST_OPEN	1
#define	MAY_OPEN	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0keys.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0KEYS.C - Keycode stuff                                             */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

/************************************************************************/
/*  table for preprocessor id's                                         */
/************************************************************************/
WCHAR   * Pkeyw_Table[] = {
#include "pkeyw.key"
};
char    Pkeyw_Index[] = {
#include        "pkeyw.ind"
};
struct  s_pkinfo        {
    token_t     s_info;
} Pkeyw_Info[] = {
#include        "pkeyw.inf"
};


/************************************************************************/
/*  is_pkeyword : finds the token for the id if it's a preprocessor keyword.*/
/*  P0_NOTOKEN if not found.                                            */
/************************************************************************/
token_t
is_pkeyword(
    WCHAR *id
    )
{
    REG WCHAR   **start;
    REG WCHAR   **stop;
    PUCHAR      pi;

    if( (*id) < L'_') {
        return(P0_NOTOKEN);
    }
    /*
    **  the indx table tells us the start of
    **  the words which begin with the first char if the id.
    **  the 'stop' is the index of the word which does not have the
    **  give char as it's first.
    **  we can start checking after the first char since, we *know* that
    **  they match (hence the additions 'id++' and (*start) + 1
    */
    pi = (PUCHAR) &Pkeyw_Index[((*id) - L'_')];
    for(start = &Pkeyw_Table[*pi++], stop = &Pkeyw_Table[*pi], id++;
        start != stop;
        start++
        ) {
        if(wcscmp(*start, id) == 0) {
            return(Pkeyw_Info[(start - &Pkeyw_Table[0])].s_info);
        }
    }
    return(P0_NOTOKEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0gettok.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/************************************************************************
**      MAP_TOKEN : a token has two representations and additional information.
**      (ex : const, has basic token of L_CONST,
**                              mapped token of [L_TYPE | L_MODIFIER]
**                              and info based on what the map token is)
**      MAP_AND_FILL : has two representations, but none of the extra info.
**      (ex : '<', has basic of L_LT, and map of L_RELOP)
**  NOMAP_TOKEN : has 1 representation and additional info.
**      (ex: a string, basic and 'map' type L_STRING and ptrs to the actual str)
**      NOMAP_AND_FILL : has 1 representation and no additional info.
**      (ex : 'while', has basic and 'map' of L_WHILE)
**  the FILL versions fill the token with the basic token type.
************************************************************************/
#define MAP_TOKEN(otok)\
        (Basic_token = (otok), TS_VALUE(Basic_token))
#define MAP_AND_FILL(otok)\
        (yylval.yy_token = Basic_token = (otok), TS_VALUE(Basic_token))
#define NOMAP_TOKEN(otok)\
        (Basic_token = (otok))
#define NOMAP_AND_FILL(otok)\
        (yylval.yy_token = Basic_token = (otok))



/************************************************************************/
/* yylex - main tokenization routine                                    */
/************************************************************************/

token_t
yylex(
    void
    )
{
    REG WCHAR           last_mapped;
    WCHAR               mapped_c;
    WCHAR               buf[5];
    REG token_t         lex_token;

    for(;;) {
        last_mapped = mapped_c = CHARMAP(GETCH());
first_switch:
        switch(mapped_c) {
            case LX_EACH:
            case LX_ASCII:
                if (fAFXSymbols && PREVCH() == SYMUSESTART || PREVCH() == SYMDEFSTART
                    || PREVCH() == SYMDELIMIT) {
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                    continue;
                }
                error(2018, PREVCH());
                continue;

            case LX_OBRACE:
                return(NOMAP_AND_FILL(L_LCURLY));

            case LX_CBRACE:
                return(NOMAP_AND_FILL(L_RCURLY));

            case LX_OBRACK:
                return(NOMAP_AND_FILL(L_LBRACK));

            case LX_CBRACK:
                return(NOMAP_AND_FILL(L_RBRACK));

            case LX_OPAREN:
                return(NOMAP_AND_FILL(L_LPAREN));

            case LX_CPAREN:
                return(NOMAP_AND_FILL(L_RPAREN));

            case LX_COMMA:
                return(NOMAP_AND_FILL(L_COMMA));

            case LX_QUEST:
                return(NOMAP_AND_FILL(L_QUEST));

            case LX_SEMI:
                return(NOMAP_AND_FILL(L_SEMI));

            case LX_TILDE:
                return(NOMAP_AND_FILL(L_TILDE));

            case LX_NUMBER:
                return(MAP_TOKEN(getnum(PREVCH())));

            case LX_MINUS:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_MINUSEQ));

                    case LX_GT:
                        return(MAP_AND_FILL(L_POINTSTO));

                    case LX_MINUS:
                        return(MAP_AND_FILL(L_DECR));

                    default:
                        lex_token = L_MINUS;
                        break;
                }
                break;

            case LX_PLUS:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_PLUSEQ));

                    case LX_PLUS:
                        return(MAP_AND_FILL(L_INCR));

                    default:
                        lex_token = L_PLUS;
                        break;
                }
                break;

            case LX_AND:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_ANDEQ));

                    case LX_AND:
                        return(MAP_AND_FILL(L_ANDAND));

                    default:
                        lex_token = L_AND;
                        break;
                }
                break;

            case LX_OR:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_OREQ));

                    case LX_OR:
                        return(MAP_AND_FILL(L_OROR));

                    default:
                        lex_token = L_OR;
                        break;
                }
                break;

            case LX_COLON:
                return(NOMAP_AND_FILL(L_COLON));

            case LX_HAT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_XOREQ));
                }
                lex_token = L_XOR;
                break;

            case LX_PERCENT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_MODEQ));
                }
                lex_token = L_MOD;
                break;

            case LX_EQ:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_EQUALS));
                }
                lex_token = L_ASSIGN;
                break;

            case LX_BANG:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_NOTEQ));
                }
                lex_token = L_EXCLAIM;
                break;

            case LX_SLASH:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_STAR:
                        dump_comment();
                        continue;

                    case LX_SLASH:
                        DumpSlashComment();
                        continue;

                    case LX_EQ:
                        return(MAP_AND_FILL(L_DIVEQ));

                    default:
                        lex_token = L_DIV;
                        break;
                }
                break;

            case LX_STAR:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_SLASH:
                        if( ! Prep ) {
                            error(2138); /* (nested comments) */
                        } else {
                            myfwrite(L"*/", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                        }
                        continue;

                    case LX_EQ:
                        return(MAP_AND_FILL(L_MULTEQ));

                    default:
                        lex_token = L_MULT;
                        break;
                }
                break;

            case LX_LT:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_LT:
                        if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                            return(MAP_AND_FILL(L_LSHFTEQ));
                        }
                        mapped_c = LX_LSHIFT;
                        lex_token = L_LSHIFT;
                        break;

                    case LX_EQ:
                        return(MAP_AND_FILL(L_LTEQ));

                    default:
                        lex_token = L_LT;
                        break;
                }
                break;

            case LX_LSHIFT:
                /*
                **  if the next char is not an =, then we unget and return,
                **  since the only way in here is if we broke on the char
                **  following '<<'. since we'll have already worked the handle_eos()
                **  code prior to getting here, we'll not see another eos,
                **  UNLESS i/o buffering is char by char. ???
                **  see also, LX_RSHIFT
                */
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_LSHFTEQ));
                }
                UNGETCH();
                return(MAP_AND_FILL(L_LSHIFT));

            case LX_GT:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_GTEQ));

                    case LX_GT:
                        if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                            return(MAP_AND_FILL(L_RSHFTEQ));
                        }
                        mapped_c = LX_RSHIFT;
                        lex_token = L_RSHIFT;
                        break;

                    default:
                        lex_token = L_GT;
                        break;
                }
                break;

            case LX_RSHIFT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_RSHFTEQ));
                }
                UNGETCH();
                return(MAP_AND_FILL(L_RSHIFT));

            case LX_POUND:
                if( ! Prep ) {
                    error(2014);/* # sign must be first non-whitespace */
                    UNGETCH();              /* replace it */
                    Linenumber--;   /* do_newline counts a newline */
                    do_newline();   /* may be a 'real' prepro line */
                } else {
                    myfwrite(L"#", sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;

            case LX_EOS:
                if(PREVCH() == L'\\') {
                    if( ! Prep ) {
                        if( ! checknl()) {  /* ignore the new line */
                            error(2017);/* illegal escape sequence */
                        }
                    } else {
                        myfwrite(L"\\", sizeof(WCHAR), 1, OUTPUTFILE);
                        *buf = get_non_eof();
                        myfwrite(buf, sizeof(WCHAR), 1, OUTPUTFILE);
                    }
                    continue;
                }

                if(Macro_depth == 0) {
                    if( ! io_eob()) {       /* not the end of the buffer */
                        continue;
                    }
                    if(fpop()) {            /* have more files to read */
                        continue;
                    }
                    return(MAP_AND_FILL(L_EOF));    /* all gone . . . */
                }
                handle_eos();                       /* found end of macro */
                continue;

            case LX_DQUOTE:
                if( ! Prep ) {
                    str_const();
                    return(NOMAP_TOKEN(L_STRING));
                }
                prep_string(L'\"');
                continue;

            case LX_SQUOTE:
                if( ! Prep ) {
                    return(MAP_TOKEN(char_const()));
                }
                prep_string(L'\'');
                continue;

            case LX_CR:             /*  ??? check for nl next  */
                continue;

            case LX_NL:
                if(On_pound_line) {
                    UNGETCH();
                    return(NOMAP_TOKEN(L_NOTOKEN));
                }
                if(Prep) {
                    // must manually write '\r' with '\n' when writing 16-bit strings
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                do_newline();
                continue;

            case LX_WHITE:          /* skip all white space */
                if( ! Prep ) {      /* check only once */
                    do {
                        ;
                    } while(LXC_IS_WHITE(GETCH()));
                }
                else {
                    WCHAR   c;

                    c = PREVCH();
                    do {
                        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
                    } while(LXC_IS_WHITE(c = GETCH()));
                }
                UNGETCH();
                continue;

            case LX_ILL:
                if( ! Prep ) {
                    error(2018, PREVCH());/* unknown character */
                } else {
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;

            case LX_BACKSLASH:
                if( ! Prep ) {
                    if( ! checknl()) {      /* ignore the new line */
                        error(2017);/* illegal escape sequence */
                    }
                }
                else {
                    myfwrite(L"\\", sizeof(WCHAR), 1, OUTPUTFILE);
                    *buf = get_non_eof();
                    myfwrite(buf, sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;

            case LX_DOT:
dot_switch:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_BACKSLASH:
                        if(checknl()) {
                            goto dot_switch;
                        }
                        UNGETCH();
                        break;

                    case LX_EOS:
                        if(handle_eos() == BACKSLASH_EOS) {
                            break;
                        }
                        goto dot_switch;

                    case LX_DOT:
                        if( ! checkop(L'.') ) {
                            error(2142);/* ellipsis requires three '.'s */
                        }
                        return(NOMAP_AND_FILL(L_ELLIPSIS));

                    case LX_NUMBER:
                        /*
                        **      don't worry about getting correct hash value.
                        **      The text equivalent of a real number is never
                        **      hashed
                        */
                        Reuse_W[0] = L'.';
                        Reuse_W[1] = PREVCH();
                        return(MAP_TOKEN(get_real(&Reuse_W[2])));
                }
                UNGETCH();
                return(MAP_AND_FILL(L_PERIOD));

            case LX_NOEXPAND:
                SKIPCH();                   /* just skip length */
                continue;

            case LX_ID:
                {
                    pdefn_t pdef;

                    if(Macro_depth > 0) {
                        if( ! lex_getid(PREVCH())) {
                            goto avoid_expand;
                        }
                    }
                    else {
                        getid(PREVCH());
                    }

                    if( ((pdef = get_defined()) != 0)
                        &&
                        ( ! DEFN_EXPANDING(pdef))
                        &&
                        ( can_expand(pdef))
                        ) {
                        continue;
                    }

avoid_expand:
                    if( ! Prep ) {
                        /* M00BUG get near copy of identifier???? */
                        HLN_NAME(yylval.yy_ident) = Reuse_W;
                        HLN_HASH(yylval.yy_ident) = Reuse_W_hash;
                        HLN_LENGTH(yylval.yy_ident) = (UINT)Reuse_W_length;
                        return(L_IDENT);
                    } else {
                        myfwrite(Reuse_W, (Reuse_W_length - 1) * sizeof(WCHAR), 1, OUTPUTFILE);
                        return(NOMAP_TOKEN(L_NOTOKEN));
                    }
                }
                continue;
        }
        /*
        **  all the multichar ( -> -- -= etc ) operands
        **  must come through here. we've gotten the next char,
        **  and not matched one of the possiblities, but we have to check
        **  for the end of the buffer character and act accordingly
        **  if it is the eob, then we handle it and go back for another try.
        **  otherwise, we unget the char we got, and return the base token.
        */
        if(last_mapped == LX_EOS) {
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
        }
        UNGETCH();      /* cause we got an extra one to check */
        return(MAP_AND_FILL(lex_token));
    }
}


/************************************************************************
**
**      lex_getid: reads an identifier for the main lexer.  The
**              identifier is read into Reuse_W. This function should not handle
**              an end of string if it is rescanning a macro expansion, because
**              this could switch the context with regards to whether the macro
**            is expandable or not.  Similarly, the noexpand marker must only be
**           allowed if a macro is being rescanned, otherwise let this character
**              be caught as an illegal character in text
************************************************************************/
int
lex_getid(
    WCHAR c
    )
{
    REG WCHAR   *p;
    int         length = 0;

    p = Reuse_W;
    *p++ = c;
    c &= HASH_MASK;
    for(;;) {
        while(LXC_IS_IDENT(*p = GETCH())) { /* collect character */
            c += (*p & HASH_MASK);                      /* hash it */
            p++;
        }

        if(CHARMAP(*p) == LX_NOEXPAND ) {
            length = (int)GETCH();
            continue;
        }

        UNGETCH();
        break;                          /* out of for loop  -  only way out */
    }

    if(p >= LIMIT(Reuse_W)) {   /* is this error # correct? */
        fatal(1067);
    }

    if(((p - Reuse_W) > LIMIT_ID_LENGTH) && ( ! Prep )) {
        p = Reuse_W + LIMIT_ID_LENGTH;
        *p = L'\0';
        c = local_c_hash(Reuse_W);
        warning(4011, Reuse_W);  /* id truncated */
    } else {
        *p = L'\0';              /* terminates identifier for expandable check */
    }

    Reuse_W_hash = (hash_t)c;
    Reuse_W_length = (UINT)((p - Reuse_W) + 1);

    return(length != (p - Reuse_W));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0macros.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/************************************************************************
**
**      WARNING:        gather_chars() depends ELIMIT being the boundary of
**              Macro_buffer.
************************************************************************/
#define ACT_BUFFER              &Macro_buffer[0]
#define EXP_BUFFER              &Macro_buffer[BIG_BUFFER * 2]
#define EXP_PAD                 5
#define ALIMIT                  &Macro_buffer[BIG_BUFFER * 2]
#define ELIMIT                  (&Macro_buffer[BIG_BUFFER * 4] - EXP_PAD)


/************************************************************************
**  actual argument lists are length preceeded strings which are copied
**  into ACT_BUFFER. the first argument is pt'd to by exp_actuals in the
**  expansion_t construct. the next actual is obtained by adding the length
**  of the current actual to the start of the current actual.
************************************************************************/
#define ACTUAL_SIZE(P)  (*(short *)(P))
#define ACTUAL_TEXT(P)  ((ptext_t)(((char *)(P)) + sizeof(short)))
#define ACTUAL_NEXT(P)  ((ptext_t)(((char *)(P)) + ACTUAL_SIZE(P)))


expansion_t     Macro_expansion[LIMIT_MACRO_DEPTH];

ptext_t P_defn_start;
int             N_formals;
pdefn_t Defn_level_0[LEVEL_0 + 1];


/************************************************************************
**      These are needed by p0scanner (Exp_ptr,Tiny_lexer_nesting)
************************************************************************/
ptext_t Exp_ptr = EXP_BUFFER;           /* ptr to free exp space */
int             Tiny_lexer_nesting;     /* stay in tiny lexer or back to main */

static  ptext_t Act_ptr = ACT_BUFFER;           /* ptr to free actuals space */
static  ptext_t Save_Exp_ptr = EXP_BUFFER;      /* for buffering unbal parens */

static  ptext_t P_actuals;              /* actuals for this (level) macro */
static  int             N_actuals;      /* number of actuals in invocation */
static  int             Macro_line;     /*  where we started the macro  */


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
void    chkbuf(ptext_t);
ptext_t do_strformal(void);
ptext_t do_macformal(int *);
void    expand_actual(UCHAR);
void    expand_definition(void);
void    expand_macro(void);
void    fatal_in_macro(int);
ptext_t gather_chars(ptext_t, WCHAR);
void    get_actuals(pdefn_t, int);
int     get_definition(void);
void    get_formals(void);
int     is_macro_arg(ptext_t);
void    move_to_actual(ptext_t, ptext_t);
void    move_to_exp(ptext_t);
void    move_to_exp_esc(int, ptext_t);
int     post_paste(void);
void    push_macro(pdefn_t);
int     redefn (ptext_t, ptext_t, int);
int     rescan_expansion(void);


/************************************************************************
** UNDEFINE - remove a symbol from the symbol table
**      No noise is made if the programmer attempts to undefine a predefined
**              macro, but it is not done.
************************************************************************/
void
undefine(
    void
    )
{
    pdefn_t     pdef;
    pdefn_t     prev;

    prev = NULL;
    pdef = Defn_level_0[Reuse_W_hash & LEVEL_0];
    while(pdef) {
        if(memcmp (Reuse_W, DEFN_IDENT(pdef), Reuse_W_length * sizeof(WCHAR)) == 0) {
            if(PRE_DEFINED(pdef)) {
                warning(4117, Reuse_W, L"#undef");
                break;
            }
            if(prev == NULL)    /*  match at head of list  */
                Defn_level_0[Reuse_W_hash & LEVEL_0] = DEFN_NEXT(pdef);
            else
                DEFN_NEXT(prev) = DEFN_NEXT(pdef);

            if (wcscmp(DEFN_NAME(pdef), afxSzHiddenSymbols) == 0)
                afxHiddenSymbols = FALSE;
            if (wcscmp(DEFN_NAME(pdef), afxSzReadOnlySymbols) == 0)
                afxReadOnlySymbols = FALSE;

            break;
        }
        prev = pdef;
        pdef = DEFN_NEXT(pdef);
    }
}


/************************************************************************
**  BEGIN DEFINE A MACRO {
************************************************************************/
void
define(
    void
    )
{
    WCHAR       c;

    if (! (LX_IS_IDENT(c = skip_cwhite())) ) {
        error(2007); /* #define syntax */
        skip_cnew();
        return;
    }
    getid(c);
    N_formals = 0;
    P_defn_start = Macro_buffer;
/*
**  the next character must be white space or an open paren
*/
first_switch:
    switch(CHARMAP(c = GETCH())) {
        case LX_OPAREN:                 /*  we have formal parameters  */
            get_formals();              /*  changes N_formals and fills Macro_buffer */
            if(N_formals == 0) {        /*  empty formal list  */
                /*
                **  we must special case this since the expand() reads in the
                **  actual arguments iff there are formal parameters. thus if we
                **      #define foo()   bar()
                **              . . .
                **              foo()
                **  will expand as
                **              bar()()
                **  we put the right paren in to fool the expander into looking
                **  for actuals.
                */
                N_formals = -1;
            }
            break;
        case LX_WHITE:
            break;
        case LX_CR:
            goto first_switch;
        case LX_SLASH:
            if( ! skip_comment()) {
                error(2008, L'/');
            }
            break;
        case LX_NL:                 /* no definition */
            UNGETCH();
            definstall((ptext_t)0, 0, 0);
            return;
            break;
        case LX_EOS:
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
            /* got BACKSLASH_EOS */
            /*
            **  FALLTHROUGH
            */
        default:
            error(2008, c); /* unexpected character in macro definition */
    }
    definstall(P_defn_start, get_definition(), N_formals);
}


/************************************************************************
**  get_formals : collect comma separated idents until the first closing paren
**  (the openning paren has already been read)
**  since we can't be in a macro when we're asked for this, we can be assured
**  that we can use a single buffer to collect all the formal names.
************************************************************************/
void
get_formals(
    void
    )
{
    WCHAR       c;
    ptext_t     p_stop;
    ptext_t     p_id;

    p_id = p_stop = ACTUAL_TEXT(P_defn_start);
    for(;;) {
        switch(CHARMAP(c = skip_cwhite())) {
            case LX_ID:
                if( p_id != p_stop ) {
                    error(2010, c);
                }
                *p_stop++ = c;
                for(;;) {
                    while(LXC_IS_IDENT(c = GETCH())) {      /* while an id char */
                        *p_stop++ = c;                      /* collect it */
                    } if(c == EOS_CHAR) {
                            /*
                            **  found end of buffer marker, make sure it is,
                            **  then handle it.
                            */
                        if(io_eob()) {      /* end of buffer in here is bad */
                            fatal(1004);
                        }
                        continue;
                    }
                    if((c == L'\\') && (checknl())) {
                        continue;
                    }
                    UNGETCH();
                    break;
                }
                *p_stop++ = L'\0';
                break;
            case LX_COMMA:
            case LX_CPAREN:
                if( p_stop > p_id ) {
                    /* make sure an identifier was read */
                    if((p_stop - p_id) >= TINY_BUFFER) {
                        p_id[TINY_BUFFER - 1] = L'\0';
                        warning(4011);              /* id truncated */
                        p_stop = p_id + TINY_BUFFER;
                    }
                    if(is_macro_arg(p_id) >= 1) {
                        error(2009, p_id);                /* reuse of formal */
                    } else {
                        ACTUAL_SIZE(P_defn_start) = (short)(p_stop - P_defn_start) * sizeof(WCHAR);
                        P_defn_start = p_stop;
                        N_formals++;
                    }
                } else {
                    if( (CHARMAP(c) == LX_COMMA) || (N_formals > 0) ) {
                        error(2010, c);
                    }
                }
                if( CHARMAP(c) == LX_CPAREN ) {
                    return;
                }
                p_id = p_stop = ACTUAL_TEXT(P_defn_start);
                break;
            default:
                error(2010, c); /*  unexpected char in formal list */
                break;
        }
    }
}


/************************************************************************
** definstall - Install a new definition. id is in Reuse_W.
**      p_text : ptr to the definition
**      n : number of bytes in the definition (may contain embedded nulls)
**      number : number of formals
************************************************************************/
void
definstall(
    WCHAR * p_text,
    int n,
    int number
    )
{
    pdefn_t     p;

    if(n == 0) {
        p_text = NULL;
    }
    if( wcscmp (Reuse_W, L"defined") == 0) {
        warning(4117, Reuse_W, L"#define");/* name reserved */
        return;
    }
    if((p = get_defined()) != 0) {
        if(PRE_DEFINED(p)) {
            warning(4117, Reuse_W, L"#define");/* name reserved */
            return;
        } else {
            if(redefn(p_text, DEFN_TEXT(p), n)) {
                warning(4005, Reuse_W);/* redefinition */
            } else {
                return;
            }
        }
    } else {
        hln_t   ident;

        HLN_NAME(ident) = Reuse_W;
        HLN_HASH(ident) = Reuse_W_hash;
        HLN_LENGTH(ident) = (UINT)Reuse_W_length;
        p = (pdefn_t) MyAlloc(sizeof(defn_t));
        if (p == NULL) {
            error(1002);
            return;
        }
        DEFN_IDENT(p) = HLN_TO_NAME(&ident);
        DEFN_NEXT(p) = Defn_level_0[Reuse_W_hash & LEVEL_0];
        DEFN_TEXT(p) = (WCHAR*)NULL;
        DEFN_EXPANDING(p) = 0;
        Defn_level_0[Reuse_W_hash & LEVEL_0] = p;
    }
    if(n != 0) {
        DEFN_TEXT(p) = pstrndup(p_text, n);
        if(number == FROM_COMMAND) {    /* special case from cmd line */
            *(DEFN_TEXT(p) + n - 1) = EOS_DEFINITION;   /* for handle_eos */
        }
    }
    DEFN_NFORMALS(p) = (char)((number != FROM_COMMAND) ? number : 0);

    if (fAFXSymbols && !PRE_DEFINED(p) && DEFN_NFORMALS(p) == 0)
        AfxOutputMacroDefn(p);
}


/************************************************************************
**  get_defined : is the given id in the macro symbol table?
**  return a ptr to it if so, NULL if not.
************************************************************************/
pdefn_t
get_defined(
    void
    )
{
    pdefn_t     pdef;

    for( pdef = Defn_level_0[Reuse_W_hash & LEVEL_0]; pdef;
        pdef = DEFN_NEXT(pdef))         {
        if(memcmp (Reuse_W, DEFN_IDENT(pdef), Reuse_W_length * sizeof(WCHAR)) == 0) {
            return(pdef);
        }
    }
    return(NULL);
}


/************************************************************************
**  redefn : are the two definitions the same?
************************************************************************/
int
redefn(
    REG  PWCHAR p_new,
    PWCHAR p_old,
    int n
    )
{
    if(p_old && p_new) {
        if(wcsncmp(p_new, p_old, n) == 0) {     /* strings are exact */
            return(FALSE);
        }
        return(TRUE);
    }
    return((p_old != NULL) || (p_new != NULL));
}


/************************************************************************
**  get_definition : accumulate the macro definition, stops when it finds
**  a newline (it uses it). returns a ptr to the end of the string it builds.
**  builds the string in Macro_buffer. (given the start in P_defn_start)
************************************************************************/
int
get_definition(
    void
    )
{
    REG ptext_t p;
    WCHAR       c;
    int         stringize = FALSE;
    int         charize = FALSE;

    p = P_defn_start;
    c = skip_cwhite();
    for(;;) {
        chkbuf(p);
        switch(CHARMAP(c)) {
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    /* got backslash EOS */
                    /* \<anything else> goes out as is.  The <anything else>
                     * character must be emitted now, so that
                     *               #define FOO(name)       \name
                     *               . . .
                     *               FOO(bar)
                     *
                     * does NOT see occurence of name in the definition as an
                     * occurence of the formal param and emit \bar when it is
                     * expanded later,but if the definition is \nname it will
                     * find name as a formal paramater and emit \nbar
                     */
                    *p++ = c;       /* put in backslash, break'll add new char */
                    c = get_non_eof();
                } else {
                    c = GETCH();
                    continue;
                }
                break;
            case LX_NL:             /*  only way out  */
                UNGETCH();
                if(p == P_defn_start) {
                    return(0);
                }
                chkbuf(p);
                *p++ = EOS_CHAR;
                *p++ = EOS_DEFINITION;      /* tells handle_eos defn finished */
                return((int)(p - P_defn_start));/* p's last incr counts the 0*/
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                p = gather_chars(p, c);
                c = GETCH();
                continue;
                break;
            case LX_POUND:
split_op:
                switch(CHARMAP(GETCH())) {
                    case LX_POUND:
                        /*
                        **  handle ## processing. cant be the first or the last.
                        */
                        if(p == P_defn_start) {
                            error(2160);        /* ## not allowed as first entry */
                            continue;
                        }
                        if(*(p - 1) == L' ') {   /* hose the last blank */
                            p--;
                        }
                        if(CHARMAP(c = skip_cwhite()) == LX_NL) {
                            UNGETCH();
                            error(2161);
                            continue;
                        }
                        /* this case does *not* fall through to LX_ID */
                        continue;
                        break;
                    case LX_EACH:
                        charize = TRUE;
                        break;
                    case LX_EOS:
                        if( handle_eos() != BACKSLASH_EOS ) {
                            goto split_op;
                        }
                        /*
                        **      FALLTHROUGH
                        */
                    default:
                        UNGETCH();
                        stringize = TRUE;
                        break;
                }
                if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                    error(2162);    /* must have id following */
                    continue;
                }
                /*
                **  FALLTHROUGH
                */
            case LX_ID:
                {
                    /* we have the start of an identifier - check it to see if
                     * its an occurence of a formal parameter name.
                     * we gather the id ourselves (instead of getid()) since this
                     * wil save us from having to copy it to our string if it's
                     * not a formal parameter.
                     */
                    int                     n;
                    ptext_t p_macformal;

                    p_macformal = p;
                    do {
                        chkbuf(p);
                        *p++ = c;
get_more_id:
                        c = GETCH();
                    } while(LXC_IS_IDENT(c));
                    if(CHARMAP(c) == LX_EOS) {
                        if(handle_eos() != BACKSLASH_EOS) {
                            goto get_more_id;
                        }
                    }
                    *p = L'\0'; /* term. string, but do not advance ptr */
                    if((n = is_macro_arg(p_macformal)) >= 1) {
                        /*
                        **  this is an occurance of formal 'n', replace the id with
                        **  the special MAC character.
                        */
                        p = p_macformal;
                        if(stringize) {
                            *p++ = LX_FORMALSTR;
                        } else {
                            if(charize) {
                                *p++ = LX_FORMALCHAR;
                            } else {
                                *p++ = LX_FORMALMARK;
                            }
                        }
                        *p++ = (WCHAR) n;
                    } else if(charize || stringize) {
                        error(2162);
                    }
                    stringize = FALSE;
                    charize = FALSE;
                    continue;       /* we broke out of the loop with a new char */
                }
            case LX_SLASH:
                if( ! skip_comment() ) {    /* really is a slash */
                    break;
                }
                /*
                **  FALLTHROUGH
                */
            case LX_CR:
            case LX_WHITE:
                /*
                **  this is white space, all contiguous whitespace is transformed
                **  to 1 blank. (hence the skip_cwhite() and the continue).
                */
                if(CHARMAP(c = skip_cwhite()) != LX_NL) {
                    *p++ = L' ';
                }
                continue;                           /* restart loop */
            case LX_ILL:
                error(2018, c);
                c = GETCH();
                continue;
        }
        *p++ = c;
        c = GETCH();
    }
}


/************************************************************************/
/* is_macro_arg ()                                                      */
/************************************************************************/
int
is_macro_arg(
    ptext_t name
    )
{
    REG int     i;
    REG ptext_t p;

    p = Macro_buffer;
    for(i = 1; i <= N_formals; i++) {
        if( wcscmp(name, ACTUAL_TEXT(p)) == 0) {
            return(i);
        }
        p = ACTUAL_NEXT(p);
    }
    return(-1);
}



/************************************************************************/
/* chkbuf ()                                                            */
/************************************************************************/
void
chkbuf(
    ptext_t p
    )
{
    if( p >= ELIMIT ) {
        fatal(1011, Reuse_W);
    }
}


/************************************************************************
**  gather_chars : collect chars until a matching one is found.
**  skip backslashed chars. moves the chars into the buffer,
**  returns a ptr past the last char copied.
************************************************************************/
ptext_t
gather_chars(
    REG ptext_t p,
    WCHAR match_c
    )
{
    WCHAR       c;

    *p++ = match_c;
    for(;;) {
        if(p > ELIMIT) {
            return(ELIMIT);
        }
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                error(2001);
                UNGETCH();
                c = match_c;
                /*
                **  FALLTHROUGH
                */
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == match_c) {
                    *p++ = c;
                    return(p);              /* only way out */
                }
                break;
            case LX_EOS:
                if(handle_eos() != BACKSLASH_EOS) {
                    continue;
                } else {
                    /* got backslash */
                    *p++ = L'\\';
                    c = get_non_eof();
                    if((c == '\\') && (checknl())) {
                        continue;
                    }
                }
                break;
        }
        *p++ = c;
    }
}
/************************************************************************
**  END DEFINING MACROS }
************************************************************************/

/************************************************************************
**  BEGIN EXPANDING MACROS {
************************************************************************/
/************************************************************************
**      can_expand:             tries to expand the macro passed to it - returns
**              true if it succeeded in expanding it.  It will only return FALSE
**              if a macro name was found, a paren was expected, and a paren was
**              not the next non white character.
************************************************************************/
int
can_expand(
    pdefn_t pdef
    )
{
    WCHAR   c;
    int     n_formals;
    int     return_value = FALSE;

    Tiny_lexer_nesting = 0;
    Save_Exp_ptr = Exp_ptr;             /* not necessarily EXP_BUFFER */
    Macro_line = Linenumber;
expand_name:

    P_actuals = Act_ptr;
    N_actuals = 0;

    n_formals = DEFN_NFORMALS(pdef);
    if( PRE_DEFINED(pdef) ) {
        push_macro(pdef);
        DEFN_EXPANDING(CURRENT_MACRO)++;
        if(rescan_expansion()) {
            return(TRUE);                       /* could expand macro */
        }
    }
    else if( n_formals == 0 ) {
        return_value = TRUE;
        if(DEFN_TEXT(pdef)) {
            push_macro(pdef);
            expand_definition();
        } else {
            /*
            **      Macro expands to nothing (no definition).  Since it
            **      didn't have any actuals, Act_ptr is already correct.
            **      Exp_ptr must be changed however to delete the
            **      identifier from the expanded text.
            */
            Exp_ptr = Save_Exp_ptr;
        }
    } else {
        if( n_formals == -1 ) {
            n_formals = 0;
        }
name_comment_paren:
        if( can_get_non_white()) {
            if(CHARMAP(CHECKCH()) == LX_SLASH) {
                SKIPCH();
                if(skip_comment()) {
                    goto name_comment_paren;
                } else {
                    UNGETCH();
                }
            }
            if(CHARMAP(CHECKCH())==LX_OPAREN) {
                SKIPCH();
                return_value = TRUE;
                get_actuals(pdef, n_formals);
            } else {
                /*
                **      #define xx(a) a
                **  xx bar();
                **  don't lose white space between "xx" and "bar"
                */
                ptext_t p = Exp_ptr;

                push_macro(pdef);
                DEFN_EXPANDING(CURRENT_MACRO)++;
                Exp_ptr = p;
                if( rescan_expansion() ) {
                    return(FALSE);
                }
            }
        } else {
        }
    }
    /*
    **      makes sure a macro is being worked on. At this point, there will
    **      be a macro to expand, unless the macro expand_the_named_macro was
    **      passed had no definition text.  If it had no defintion text,
    **      Tiny_lexer_nesting was not incremented.
    */
    while(Tiny_lexer_nesting != 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        switch(CHARMAP(c = GETCH())) {
            case LX_ID:
            case LX_MACFORMAL:
                Save_Exp_ptr = Exp_ptr;
                if(tl_getid(c) && ((pdef = get_defined())!= 0)) {
                    if(DEFN_EXPANDING(pdef)) {
                        /*
                        **      the macro is already being expanded, so just
                        **      write the do not expand marker and the
                        **      identifier to the expand area.  The do not
                        **      expand marker is necessary so this macro
                        **      doesn't get expanded on the rescan
                        */
                        int         len = Reuse_W_length - 1;

                        *Exp_ptr++ = LX_NOEXPANDMARK;
                        *Exp_ptr++ = ((WCHAR)len);
                    } else {
                        /*
                        ** a legal identifier was read, it is defined, and
                        ** it is not currently being expanded.  This means
                        ** there is reason to believe it can be expanded.
                        */
                        goto expand_name;
                    }
                }
                if(InIf &&(memcmp(Reuse_W, L"defined", 8 * sizeof(WCHAR)) ==0)) {
                    do_defined(Reuse_W);
                }
                continue;
                break;
            case LX_NUMBER:
                /* getnum with Prep on to keep leading 0x on number */
                {
                    int     Save_prep = Prep;
                    Prep = TRUE;
                    getnum(c);
                    Prep = Save_prep;
                }
                continue;
                break;
            case LX_DOT:
                *Exp_ptr++ = L'.';
dot_switch:
                switch(CHARMAP(c = GETCH())) {
                    case LX_EOS:
                        if(handle_eos() != BACKSLASH_EOS) {
                            if(Tiny_lexer_nesting > 0) {
                                goto dot_switch;
                            }
                            continue;
                        }
                        break;
                    case LX_DOT:
                        *Exp_ptr++ = L'.';
                        if( ! checkop(L'.')) {
                            break;      /* error will be caught on rescan */
                        }
                        *Exp_ptr++ = L'.';
                        continue;
                        break;
                    case LX_NUMBER:
                        *Exp_ptr++ = c;
                        get_real(Exp_ptr);
                        continue;
                }
                UNGETCH();
                continue;
            case LX_CHARFORMAL:
                move_to_exp_esc(L'\'', do_strformal());
                continue;
                break;
            case LX_STRFORMAL:
                move_to_exp_esc(L'"', do_strformal());
                continue;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                /*
                **  gather_chars is called even though the error reported
                **  on overflow may need to be changed.
                */
                Exp_ptr = gather_chars(Exp_ptr, c);
                continue;
                break;
            case LX_WHITE:
                while(LXC_IS_WHITE(GETCH())) {
                    ;
                }
                UNGETCH();
                c = L' ';
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    *Exp_ptr++ = c;
                    c = GETCH();
                    break;
                }
                continue;
                break;
        }
        *Exp_ptr++ = c;
    }
    return(return_value);
}


/************************************************************************
**  get_actuals :  Paren must already be found.  If all the actuals can
**              be read, the macro is pushed and expansion begins. Otherwise,
**              this function is quickly exited and lets the tiny lexer take
**              care of rescanning.
************************************************************************/
void
get_actuals(
    pdefn_t pdef,
    int n_formals
    )
{
    /*
    **  The only concern with this is that a rescan could finish while
    **  this is trying to collect actuals.  When a rescan finishes, it
    **  may reset Act_ptr and Exp_ptr.  Unless these are saved before the
    **  end of rescan is handled, the part of the actual collected so far
    **  would be lost.
    */
    REG ptext_t start;
    WCHAR       c;
    ptext_t     actuals_start;
    int         paste;
    int         level;

    *Exp_ptr++ = PREVCH();                      /* must be oparen */
    level = 0;
    actuals_start = Act_ptr;

    while( level >= 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
more_white:
        if( ! can_get_non_white()) {
            return;
        }
        if(CHARMAP(CHECKCH()) == LX_SLASH) {
            SKIPCH();
            if(skip_comment()) {
                goto more_white;
            } else {
                start = Exp_ptr;
                *Exp_ptr++ = L'/';
            }
        } else {
            start = Exp_ptr;
        }
        paste = FALSE;

        for(;;) {
            switch(CHARMAP(c = GETCH())) {
                case LX_CPAREN:
                    if(--level < 0) {
                        goto leave_loop;
                    }
                    break;
                case LX_COMMA:
                    /*
                    **      if the comma is not at level == 0, it is part of
                    **      a parenthesized list and not a delimiter
                    */
                    if(level == 0) {
                        goto leave_loop;
                    }
                    break;
                case LX_SLASH:
                    if( ! skip_comment()) {
                        break;
                    }
                    if(*(Exp_ptr - 1) == L' ') {
                        continue;
                    }
                    c = L' ';
                    break;
                case LX_CR:
                case LX_NL:
                case LX_WHITE:
                    UNGETCH();              /* This char is valid white space */
                    if( ! can_get_non_white()) {
                        return;
                    }
                    continue;
                    break;
                case LX_OPAREN:
                    ++level;
                    break;
                case LX_DQUOTE:
                case LX_SQUOTE:
                    Exp_ptr = gather_chars(Exp_ptr, c);
                    continue;
                    break;
                case LX_ID:
                    *Exp_ptr++ = c;
                    while(LXC_IS_IDENT(c = GETCH())) {
                        if(Exp_ptr >= ELIMIT) {
                            fatal_in_macro(10056);
                        }
                        *Exp_ptr++ = c;
                    }
                    if(CHARMAP(c) != LX_MACFORMAL) {
                        UNGETCH();
                        continue;
                    }
                    paste = TRUE;
                    /*
                    **      FALLTHROUGH
                    */
                case LX_MACFORMAL:
                    move_to_exp(do_macformal(&paste));
                    continue;
                    break;
                case LX_STRFORMAL:
                    move_to_exp_esc(L'"', do_strformal());
                    continue;
                    break;
                case LX_CHARFORMAL:
                    move_to_exp_esc(L'\'', do_strformal());
                    continue;
                    break;
                case LX_EOS:
                    /*
                    **      Will saving this pointers create dead space in the
                    **      buffers?  Yes, but only temporarily.
                    **
                    **      handle_eos() may reset Act_ptr and Exp_ptr to the
                    **      beginning of the buffers if a rescan is finishing
                    **      and Macro_depth is going to be 0.  ANSI allows
                    **      actuals to start within a macro defintion and be
                    **      completed (further actuals and closing paren) later
                    **      in the text.
                    **
                    **      These buffer pointers will eventually be reset to
                    **      the beginnings of their respective buffers when the
                    **      macro for the actuals being collected right now
                    **      finish rescan
                    **
                    **      This is special handling for folks who use
                    **      unbalanced parens in macro definitions
                    */
                    {
                        ptext_t     Exp_save;
                        ptext_t     Act_save;
                        int eos_res;

                        Exp_save = Exp_ptr;
                        Act_save = Act_ptr;
                        if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
                            return;
                        }
                        Act_ptr = Act_save;
                        Exp_ptr = Exp_save;
                        if(eos_res == BACKSLASH_EOS) {      /* ??? DFP QUESTION  */
                            *Exp_ptr++ = c;         /*  save the \  */
                            c = get_non_eof();      /*  get char following \  */
                            break;
                        }
                    }
                    continue;
                    break;
            }
            *Exp_ptr++ = c;
        }
leave_loop:
        /*
                **      if the last character was whitespace, hose it
                */
        if(CHARMAP(*(Exp_ptr - 1)) == LX_WHITE) {
            Exp_ptr--;
        }
        /*
        **      if Exp_ptr <= start, foo() was read, don't incr N_actuals
        */
        if(Exp_ptr > start) {
            N_actuals++;
            move_to_actual(start, Exp_ptr);
        }
        *Exp_ptr++ = c;
    }

    P_actuals = actuals_start;
    if(n_formals < N_actuals) {
        warning(4002, Reuse_W);
    }
    else if(n_formals > N_actuals) {
        warning(4003, Reuse_W);
    }

    if(DEFN_TEXT(pdef)) {
        push_macro(pdef);
        expand_macro();
    } else {
        /*
        **      the macro expands to nothing (no definition)
        **      This essentially means delete the macro and its actuals
        **      from the expanded text
        */
        Act_ptr = P_actuals;    /* reset pointer to get rid of actuals */
        Exp_ptr = Save_Exp_ptr; /* delete macro & actuals from exp text */
    }
}

/************************************************************************
**      rescan_expansion:       pops a level off of tiny lexer.  If this is the
**              original macro called, the rescan is set up, otherwise the MACRO
**              (not only the tiny lexer level) is popped.
************************************************************************/
int
rescan_expansion(
    void
    )
{
    if(--Tiny_lexer_nesting == 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        if (fAFXSymbols && !InIf && (DEFN_NFORMALS(CURRENT_MACRO)==0))
            AfxOutputMacroUse(CURRENT_MACRO);

        *Exp_ptr++ = EOS_CHAR;
        *Exp_ptr++ = EOS_RESCAN;
        Current_char = CURRENT_TEXT;
        return(TRUE);                   /* rescan the expanded text */
    } else {
        /* reset Current_char, pop the macro */

        Current_char = CURRENT_STRING;
        Act_ptr = CURRENT_ACTUALS;      /* don't need its actuals */
        DEFN_EXPANDING(CURRENT_MACRO)--;
        --Macro_depth;
        return(FALSE);                  /* do not rescan expanded text */
    }
}


/************************************************************************
** move_to_actual:      moves the string located between start and finish
**              inclusive to the current location in ACT_BUFFER as a new actual.
************************************************************************/
void
move_to_actual(
    ptext_t start,
    ptext_t finish
    )
{
    REG ptext_t p;
    REG int     len;

    len = (int)(finish - start);
    if(Act_ptr + len >= ALIMIT - 2) {
        fatal_in_macro(10056);
    }
    wcsncpy(ACTUAL_TEXT(Act_ptr), start, len);
    p = ACTUAL_TEXT(Act_ptr);
    p += len;
    if ((((ULONG_PTR)p) & 1) == 0) {
        *p++ = EOS_CHAR;
        *p++ = EOS_ACTUAL;
    } else {
        *p++ = EOS_CHAR;
        *p++ = EOS_PAD;
        *p++ = EOS_ACTUAL;
    }
    ACTUAL_SIZE(Act_ptr) = (short)(p - Act_ptr) * sizeof(WCHAR);
    Act_ptr = p;
}


/************************************************************************
** move_to_exp_esc:     moves zero terminated string starting at source to
**      the current position in EXP_BUFFER, with quotes placed around the
**      string and interior backslashes and dquotes are escaped with a
**      backslash.  The terminating null should not be copied.  The null
**      does not come from the property of a string, but rather is the
**      marker used to indicate there is no more actual.
************************************************************************/
void
move_to_exp_esc(
    int quote_char,
    REG ptext_t source
    )
{
    int     mapped_c;
    int     mapped_quote;
    int     in_quoted = FALSE;

    if( ! source ) {
        return;
    }

    *Exp_ptr++ = (WCHAR)quote_char;
    for(;;) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        switch(mapped_c = CHARMAP(*source)) {
            case LX_EOS:
                if(*source == EOS_CHAR) {
                    goto leave_move_stringize;
                }
                /* got BACKSLASH */
                /* but it can't be backslash-newline combination because
                                    ** we are reprocessing text already read in
                                    */
                if(in_quoted) {
                    *Exp_ptr++ = L'\\';
                }
                break;

            case LX_DQUOTE:
                if(CHARMAP((WCHAR)quote_char) == LX_DQUOTE) {
                    *Exp_ptr++ = L'\\';
                }
                /*
                **      FALLTHROUGH
                */
            case LX_SQUOTE:
                if(CHARMAP((WCHAR)quote_char) == LX_SQUOTE) {
                    break;
                }
                if(in_quoted ) {
                    if(mapped_c == mapped_quote) {
                        in_quoted = FALSE;
                    }
                } else {
                    in_quoted = TRUE;
                    mapped_quote = mapped_c;
                }
                break;
        }
        *Exp_ptr++ = *source++;
    }

leave_move_stringize:
    *Exp_ptr++ = (WCHAR)quote_char;
}


/************************************************************************
**      move_to_exp:    moves zero terminated string starting at source to
**              the current position in EXP_BUFFER.  The terminating null should
**              not be copied.
************************************************************************/
void
move_to_exp(
    REG ptext_t source
    )
{
    if( ! source ) {
        return;
    }

    while( *source ) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        *Exp_ptr++ = *source++;
    }
}


/************************************************************************
** push_macro:                  pushes macro information onto the macro stack.
**      Information such as the current location in the Exp and Act buffers
**      will be used by whatever macros this one may call.
************************************************************************/
void
push_macro(
    pdefn_t pdef
    )
{
    /*
    **      note that increment leaves element 0 of the macro stack unused.
    **      this element can be reserved for links to dynamically allocated
    **      macro expansion stacks, if they become desirable
    */
    if(++Macro_depth >= LIMIT_MACRO_DEPTH) {
        fatal(1009, Reuse_W);
    }
    Tiny_lexer_nesting++;
    CURRENT_MACRO = pdef;
    CURRENT_ACTUALS = P_actuals;
    CURRENT_NACTUALS = (UCHAR)N_actuals;
    CURRENT_NACTSEXPANDED = 0;
    CURRENT_STRING = Current_char;
    CURRENT_TEXT = Exp_ptr = Save_Exp_ptr;
}


/************************************************************************
**expand_definition:            sets the input stream to start reading from
**              the macro definition.  Also marks the macro as in the process of
**              expanding so if it eventually invokes itself, it will not expand
**              the new occurence.
************************************************************************/
void
expand_definition(
    void
    )
{
    Current_char = DEFN_TEXT(CURRENT_MACRO);
    DEFN_EXPANDING(CURRENT_MACRO)++;
}


/************************************************************************
**expand_actual:        sets the input stream to start reading from
**              the actual specified in actual.
************************************************************************/
void
expand_actual(
    UCHAR actual
    )
{
    ptext_t     p;
    p = CURRENT_ACTUALS;
    while(--actual) {
        p = ACTUAL_NEXT(p);
    }
    Current_char = ACTUAL_TEXT(p);
}

/************************************************************************
**      expand_macro:           if there are still actuals for this macro to be
**              expanded, the next one is set up, otherwise this sets up to
**              expand the macro definition
************************************************************************/
void
expand_macro(
    void
    )
{
    if(CURRENT_NACTUALS > CURRENT_NACTSEXPANDED) {
        expand_actual(++CURRENT_NACTSEXPANDED);
    } else {
        expand_definition();
    }
}


/************************************************************************
**post_paste:           looks ahead one character to find out if a paste has
**      been requested immediately after this identifier.  If the next
**      character can continue an identifier, or is the macformal marker,
**      a paste should be done.  This is called after a macformal is found
**      to find out if the expanded or unexpanded actual should be used.
************************************************************************/
int
post_paste(
    void
    )
{
    WCHAR       c;

    if((CHARMAP(c = GETCH()) == LX_MACFORMAL) || (LXC_IS_IDENT(c))) {
        UNGETCH();
        return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}

/************************************************************************
**do_macformal:         This function is called after a macformal marker is
**      found.  It reads the next character to find out which macformal is
**      wanted.  Then it checks to see if a paste is wanted, to find out
**      if the expanded or unexpanded actual should be used.  The return
**      value is a pointer to the text of the actual wanted, or NULL if the
**      actual asked for was not provided.
************************************************************************/
ptext_t
do_macformal(
    int *pre_paste
    )
{
    WCHAR       n;
    ptext_t     p;
    int temp_paste;

    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
        return(NULL);           /* already output warning */
    }
    temp_paste = post_paste();
    if(( ! (*pre_paste)) && ( ! temp_paste) ) {
        /*
        **      if the programmer provided x actuals, actuals x+1 to 2x are
        **      those actuals expanded
        */
        n += CURRENT_NACTUALS;
    }
    *pre_paste = temp_paste;
    if (n != 0)
        while(--n) {
            p = ACTUAL_NEXT(p);
        }

    return(ACTUAL_TEXT(p));
}


/************************************************************************
**tl_getid:             This function reads an identifier for the tiny lexer
**      into EXP_BUFFER.  if macformal is found, the text of that actual
**      (expanded or not) is appended to the identifier.  It is possible
**      that this text will contain characters that are not legal
**      identifiers so return value is whether checking to see if the
**      "identifier" is defined is worth the bother.
************************************************************************/
int
tl_getid(
    WCHAR c
    )
{
    WCHAR  *p;
    int     paste;
    int     legal_identifier;
    int     length = 0;

    p = Exp_ptr;
    paste = FALSE;
    legal_identifier = TRUE;

do_handle_macformal:
    if(CHARMAP(c) == LX_MACFORMAL) {
        ptext_t p_buf;

        if((p_buf = do_macformal(&paste)) != 0) {
            while( *p_buf ) {
                if( ! LXC_IS_IDENT(*p_buf)) {
                    legal_identifier = FALSE;
                }
                if(Exp_ptr >= ELIMIT) {
                    fatal_in_macro(10056);
                }
                *Exp_ptr++ = *p_buf++;
            }
        }
    } else {
        *Exp_ptr++ = c;
    }

do_handle_eos:
    while(LXC_IS_IDENT(c = GETCH())) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        *Exp_ptr++ = c;
    }

    if(CHARMAP(c) == LX_NOEXPAND) {
        length = (int)GETCH();                  /* just skip length */
        goto do_handle_eos;
    }

    if(CHARMAP(c) == LX_MACFORMAL) {
        paste = TRUE;
        goto do_handle_macformal;
    }

    UNGETCH();
    if(legal_identifier && (length == (Exp_ptr - p))) {
        legal_identifier = FALSE;
    }

    if(legal_identifier) {
        if(((Exp_ptr - p) > LIMIT_ID_LENGTH) && ( ! Prep)) {
            Exp_ptr = &p[LIMIT_ID_LENGTH];
            *Exp_ptr = L'\0';    /* terminates identifier for warning */
            warning(4011, p);              /* id truncated */
        } else {
            *Exp_ptr = L'\0';    /* terminates identifier for expandable check */
        }
        /*
        **      Whether or not we are doing Prep output, we still have to make
        **      sure the identifier will fit in Reuse_W
        */
        if((Exp_ptr - p) > (sizeof(Reuse_W) / sizeof(WCHAR))) {
            Exp_ptr = &p[LIMIT_ID_LENGTH];
            *Exp_ptr = L'\0';
            warning(4011, p);
        }
        /*
        **      copy into Reuse_W for warnings about mismatched number of
        **      formals/actuals, and in case it's not expandable
        */
        memcpy(Reuse_W, p, (int)((Exp_ptr - p) + 1) * sizeof(WCHAR));
        Reuse_W_hash = local_c_hash(Reuse_W);
        /*
        **      the characters from Exp_ptr to p inclusive do not include the
        **      the hash character, the length character, and the terminating
        **      null.
        */
        Reuse_W_length = (UINT)((Exp_ptr - p) + 1);
    }

    return(legal_identifier);
}


/************************************************************************
**  do_strformal:   returns pointer to the actual requested without
**          checking for paste (a legal token is not possible, so if a paste
**          is being done on a strformal, the behavior is undefined
************************************************************************/
ptext_t
do_strformal(
    void
    )
{
    WCHAR   n;
    ptext_t p;

    /* use unexpanded actual */
    p = CURRENT_ACTUALS;
    n = GETCH();

    if(n > CURRENT_NACTUALS) {
        return(NULL);           /* already output warning */
    }

    if (n != 0)
        while(--n) {
            p = ACTUAL_NEXT(p);
        }

    return(ACTUAL_TEXT(p));
}


/************************************************************************
**  can_get_non_white:      tries to get the next non white character
**          using P1 rules for white space (NL included).  If the end of
**          an actual, or a rescan is found, this returns FALSE, so control
**          can drop into one of the lexers.
************************************************************************/
int
can_get_non_white(
    void
    )
{
    int return_value = FALSE;
    int white_found = FALSE;

    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                if(On_pound_line) {
                    UNGETCH();
                    goto leave_cgnw;
                }
                Linenumber++;
                /*
                **      FALLTHROUGH
                */
            case LX_WHITE:
            case LX_CR:
                white_found = TRUE;
                break;
            case LX_EOS:
                {
                    int     eos_res;
                    if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
                        goto leave_cgnw;
                    }
                    if(eos_res != BACKSLASH_EOS) {
                        break;
                    }
                }
                /*
                **      FALLTHROUGH
                */
            default:
                UNGETCH();
                return_value = TRUE;
                goto leave_cgnw;
                break;
        }
    }
leave_cgnw:
    if(white_found) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        if(*(Exp_ptr - 1) != L' ') {
            *Exp_ptr++ = L' ';
        }
    }
    return(return_value);               /* could you get next non white? */
}


/************************************************************************/
/* fatal_in_macro ()                                                    */
/************************************************************************/
void
fatal_in_macro(
    int e
    )
{
    Linenumber = Macro_line;

    fatal(e);
}


/************************************************************************
**  handle_eos : handle the end of a string.
************************************************************************/
int
handle_eos(
    void
    )
{
    if(PREVCH() == L'\\') {
        if(checknl()) {
            return(FILE_EOS);
        } else {
            return(BACKSLASH_EOS);
        }
    }

    if(Macro_depth == 0) {      /* found end of file buffer or backslash */
        if(io_eob()) {          /* end of buffer in here is bad */
            fatal(1004);
        }

        return(FILE_EOS);
    }

again:
    switch(GETCH()) {
        case EOS_PAD:
            goto again;

        case EOS_ACTUAL:
            /*
            ** Just finished expanding actual.  Check to see if there are
            ** any more actuals to be expanded.  If there are, set up to
            ** expand them and return.  Otherwise, set up to expand defn
            */

            /* move expanded text of this actual to act_buffer */
            move_to_actual(CURRENT_TEXT, Exp_ptr);

            /* reset Exp_ptr for more expansions at this macro depth */
            Exp_ptr = CURRENT_TEXT;

            /* expand next actual if there, otherwise expand definition */
            expand_macro();

            return(ACTUAL_EOS);

        case EOS_DEFINITION:
            if(rescan_expansion()) {
                return(RESCAN_EOS);
            } else {
                return(DEFINITION_EOS);
            }

        case EOS_RESCAN:
            /*
            ** Reset Current_char, Exp_ptr and Act_ptr, pop the macro
            */

            /*      get input from the previous stream */
            Current_char = CURRENT_STRING;

            /* mark this macro as not expanding */
            DEFN_EXPANDING(CURRENT_MACRO)--;


            /*
            **      if looking for the actuals of a macro, these pointers
            **      should really not be reset, however, it is cleaner to
            **      save them before calling handle_eos, and restore them
            **      upon returning, than check a static variable here.
            */
            if(Macro_depth == 1) {
                Act_ptr = ACT_BUFFER;
                Exp_ptr = EXP_BUFFER;
            }
            --Macro_depth;
            return(DEFINITION_EOS);

            /* the following conditional compile is so brackets match */

        default:
            return(FILE_EOS);
    }
}
/************************************************************************
**      END EXPANDING MACRO }
************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0io.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
PWCHAR esc_sequence(PWCHAR, PWCHAR);


#define TEXT_TYPE ptext_t

/***  ASSUME : the trailing marker byte is only 1 character. ***/

#define PUSHBACK_BYTES  1

#define TRAILING_BYTES  1

#define EXTRA_BYTES             (PUSHBACK_BYTES + TRAILING_BYTES)
/*
**  here are some defines for the new handling of io buffers.
**  the buffer itself is 6k plus some extra bytes.
**  the main source file uses all 6k.
**  the first level of include files will use 4k starting 2k from the beginning.
**  the 2nd level - n level will use 2k starting 4k from the beginning.
**  this implies that some special handling may be necessary when we get
**  overlapping buffers. (unless the source file itself is < 2k
**  all the include files are < 2k and they do not nest more than 2 deep.)
**  first, the source file is read into the buffer (6k at a time).
**  at the first include file, (if the source from the parent file
**  is more than 2k chars) . . .
**              if the Current_char ptr is not pointing above the 2k boundary
**              (which is the beginning of the buffer for the include file)
**              then we pretend we've read in only 2k into the buffer and
**              place the terminator at the end of the parents 2k buffer.
**              else we pretend we've used up all chars in the parents buffer
**              so the next read for the parent will be the terminator, and
**              the buffer will get filled in the usual manner.
**  (if we're in a macro, the picture is slightly different in that we have
**  to update the 'real' source file pointer in the macro structure.)
**
**  the first nested include file is handled in a similar manner. (except
**  it starts up 4k away from the start.)
**
**  any further nesting will keep overlaying the upper 2k part.
*/
#define IO_BLOCK        (4 * 1024 + EXTRA_BYTES)

int vfCurrFileType = DFT_FILE_IS_UNKNOWN;   //- Added for 16-bit file support.

extern expansion_t Macro_expansion[];

typedef struct  s_filelist      filelist_t;
static struct s_filelist        {       /* list of input files (nested) */
    int         fl_bufsiz;      /* characters to read into the buffer */
    FILE *      fl_file;        /* FILE id */
    long        fl_lineno;      /* line number when file was pushed */
    PWCHAR      fl_name;        /* previous file text name */
    ptext_t     fl_currc;       /* ptr into our buffer for current c */
    TEXT_TYPE   fl_buffer;      /* type of buffer */
    int         fl_numread;     /* # of characters read from the file */
    int         fl_fFileType;   //- Added for 16-bit file support.
                                //- return from DetermineFileType.
    long        fl_seek;        //- Added for restart - contains seek
                                //  address of last read.
} Fstack[LIMIT_NESTED_INCLUDES];

static  FILE *Fp = NULL;
int           Findex = -1;


/************************************************************************
 * NEWINPUT - A new input file is to be opened, saving the old.
 *
 * ARGUMENTS
 *      WCHAR *newname - the name of the file
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *      - causes input stream to be switched
 *      - Linenumber is reset to 1
 *      - storage is allocated for the newname
 *      - Filename is set to the new name
 *
 * DESCRIPTION
 *      The file is opened, and if successful, the current input stream is saved
 *      and the stream is switched to the new file. If the newname is NULL,
 *      then stdin is taken as the new input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
newinput (
    const wchar_t *newname,
    int m_open
    )
{
    filelist_t *pF;
    wchar_t *p;

    if( newname == NULL ) {
        Fp = stdin;
        newname = L"stdin";
    }
    else {
        if((Fp = _wfopen(newname, L"rb")) == NULL) {
           if(m_open == MUST_OPEN) {
               fatal(1005, newname);
           }

           return(FALSE);
        }
    }

    /* now push it onto the file stack */
    ++Findex;
    if(Findex >= LIMIT_NESTED_INCLUDES) {
        fatal(1014, LIMIT_NESTED_INCLUDES);
    }

    pF = &Fstack[Findex];
    p = (WCHAR *) MyAlloc((IO_BLOCK + PUSHBACK_BYTES) * sizeof(WCHAR));
    if (!p) {
        fatal(1002);                  /* no memory */
        return 0;
    }
    pF->fl_bufsiz = IO_BLOCK;

    pF->fl_currc = Current_char;     /*  previous file's current char */
    pF->fl_lineno = Linenumber;      /*  previous file's line number  */
    pF->fl_file = Fp;                /*  the new file descriptor      */
    pF->fl_buffer = p;
    pF->fl_numread = 0;
    pF->fl_seek = 0;

    pF->fl_fFileType = DetermineFileType (Fp);

    if (pF->fl_fFileType == DFT_FILE_IS_UNKNOWN) {
        warning(4413, newname);
        pF->fl_fFileType = DFT_FILE_IS_8_BIT;
    }

    vfCurrFileType = pF->fl_fFileType;

    Current_char = p;
    io_eob();                                   /*  fill the buffer  */
    /*
        * Note that include filenames will live the entire compiland. This
        * puts the burden on the user with MANY include files.  Any other
        * scheme takes space out of static data.
        * Notice also, that we save the previous filename in the new file's
        * fl_name.
        */
    pF->fl_name = pstrdup(Filename);
    wcsncpy(Filebuff, newname, sizeof(Filebuff) / sizeof(WCHAR));
    Linenumber = 0;     /*  do_newline() will increment to the first line */
    if(Eflag) {
        emit_line();
        // must manually write '\r' with '\n' when writing 16-bit strings
        myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);  /* this line is inserted */
    }

    {
        defn_t d;
        int old_line = Linenumber;
        Linenumber = Findex;

        DEFN_IDENT(&d) = L"!";
        DEFN_TEXT(&d) = Reuse_Include;
        DEFN_NEXT(&d) = NULL;
        DEFN_NFORMALS(&d) = 0;
        DEFN_EXPANDING(&d) = FALSE;
        AfxOutputMacroDefn(&d);

        if (Findex > 0) {
            DEFN_IDENT(&d) = L"$";
            DEFN_TEXT(&d) = Filename;
            DEFN_NEXT(&d) = NULL;
            DEFN_NFORMALS(&d) = 0;
            DEFN_EXPANDING(&d) = FALSE;
            AfxOutputMacroDefn(&d);
        }

        Linenumber = old_line;
    }

    do_newline();       /*  a new file may have preproc cmd as first line  */
    return(TRUE);
}


/************************************************************************
 * FPOP - pop to a previous level of input stream
 *
 * ARGUMENTS - none
 *
 * RETURNS
 *      TRUE if successful, FALSE if the stack is empty
 *
 * SIDE EFFECTS
 *      - Linenumber is restored to the old files line number
 *      - Filename is reset to the old filename
 *  - frees storage allocated for filename
 *
 * DESCRIPTION
 *      Pop the top of the file stack, restoring the previous input stream.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
WCHAR
fpop(
    void
    )
{
    int     OldLine;
    defn_t  DefType;

    if(Findex == -1) {          /* no files left */
        return(FALSE);
    }

    if (Fp)
        fclose(Fp);

    OldLine = Linenumber;

    --Findex;
    Linenumber = Findex;

    DEFN_IDENT(&DefType) = L"!";
    DEFN_TEXT(&DefType) = L"";
    DEFN_NEXT(&DefType) = NULL;
    DEFN_NFORMALS(&DefType) = 0;
    DEFN_EXPANDING(&DefType) = FALSE;
    AfxOutputMacroDefn(&DefType);
    Findex++;
    Linenumber = OldLine;

    strappend(Filebuff, Fstack[Findex].fl_name);
    OldLine = Linenumber;
    Linenumber = (int)Fstack[Findex].fl_lineno;
    Current_char = Fstack[Findex].fl_currc;
    MyFree(Fstack[Findex].fl_buffer);
    if(--Findex < 0) {                  /* popped the last file */
        Linenumber = OldLine;
        return(FALSE);
    }
    Fp = Fstack[Findex].fl_file;
    vfCurrFileType = Fstack[Findex].fl_fFileType;
    if(Eflag) {
        // If the last file didn't end in a \r\n, the #line from emit_line could
        // end up in whatever data structure it ended in... Emit a dummy newline
        // just in case.
        myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);  /* this line is inserted */
        emit_line();
    }
    return(TRUE);
}


/************************************************************************
**  nested_include : searches the parentage list of the currently
**              open files on the stack when a new include file is found.
**              Input : ptr to include file name.
**              Output : TRUE if the file was found, FALSE if not.
*************************************************************************/
int
nested_include(
    void
    )
{
    PWCHAR      p_tmp1;
    PWCHAR      p_file;
    PWCHAR      p_slash;
    int         tos;

    tos = Findex;
    p_file = Filename;          /* always start with the current file */
    for(;;) {
        p_tmp1 = p_file;
        p_slash = NULL;
        while(*p_tmp1) {        /* pt to end of filename, find trailing slash */
            if(wcschr(Path_chars, *p_tmp1)) {
                p_slash = p_tmp1;
            }
            p_tmp1++;
        }
        if(p_slash) {
            p_tmp1 = Reuse_W;
            while(p_file <= p_slash) {  /*  we want the trailing '/'  */
                *p_tmp1++ = *p_file++;  /*  copy the parent directory  */
            }
            p_file = yylval.yy_string.str_ptr;
            while((*p_tmp1++ = *p_file++)!=0) {  /*append include file name  */
                ;       /*  NULL  */
            }
        } else {
            wcscpy(Reuse_W, yylval.yy_string.str_ptr);
        }
        if(newinput(Reuse_W,MAY_OPEN)) {
            return(TRUE);
        }
        if(tos <= 0) {
            break;
        }
        p_file = Fstack[tos--].fl_name;
    }
    return(FALSE);
}


/************************************************************************/
/* esc_sequence()                                                       */
/************************************************************************/
PWCHAR
esc_sequence(
    PWCHAR dest,
    PWCHAR name
    )
{
    *dest = L'"';
    while((*++dest = *name) != 0) {
        if (CHARMAP(*name) == LX_EOS) {
            *++dest = L'\\';
        }
        name++;
    }
    *dest++ = L'"';              /* overwrite null */
    return( dest );
}


/************************************************************************/
/* emit_line()                                                          */
/************************************************************************/
void
emit_line(
    void
    )
{
    PWCHAR   p;

    swprintf(Reuse_W, L"#line %d ", Linenumber+1);
    myfwrite(Reuse_W, wcslen(Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);

    p = esc_sequence(Reuse_W, Filename);
    myfwrite(Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
}

/************************************************************************
**  io_eob : handle getting the next block from a file.
**  return TRUE if this is the real end of the buffer, FALSE if we have
**  more to do.
************************************************************************/
int
io_eob(
    void
    )
{
    int         n;
    TEXT_TYPE   p;

    static int   dc;

    p = Fstack[Findex].fl_buffer;
    if((Current_char - (ptext_t)p) < Fstack[Findex].fl_numread) {
        /*
        **  haven't used all the chars from the buffer yet.
        **  (some clown has a null/cntl z embedded in his source file.)
        */
        if(PREVCH() == CONTROL_Z) {     /* imbedded control z, real eof */
            UNGETCH();
            return(TRUE);
        }
        return(FALSE);
    }
    Current_char = p;

    //-
    //- The following section was added to support 16-bit resource files.
    //- It will just convert them to 8-bit files that the Resource Compiler
    //- can read.  Here is the basic strategy used.  An 8-bit file is
    //- read into the normal buffer and should be processed the old way.
    //- A 16-bit file is read into a wide character buffer identical to the
    //- normal 8-bit one.  The entire contents are then copied to the 8-bit
    //- buffer and processed normally.  The one exception to this is when
    //- a string literal is encountered.  We then return to the 16-bit buffer
    //- to read the characters.  These characters are written as backslashed
    //- escape characters inside an 8-bit string.  (ex. "\x004c\x523f").
    //- I'll be the first person to admit that this is an ugly solution, but
    //- hey, we're Microsoft :-).  8-2-91 David Marsyla.
    //-
    if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {
        REG int     i;
        REG PUCHAR  lpb;
        PUCHAR      Buf;

        Buf = (PUCHAR) MyAlloc(Fstack[Findex].fl_bufsiz + 1);
        if (Buf == NULL) {
            fatal(1002);                  /* no memory */
        }
        Fstack[Findex].fl_seek = fseek(Fp, 0, SEEK_CUR);
        n = fread (Buf, sizeof(char), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- Determine if the last byte is a DBCS lead byte
        //-     if YES (i will be greater than n), backup one byte
        //-
        for (i = 0, lpb = Buf; i < n; i++, lpb++) {
            if (IsDBCSLeadByteEx(uiCodePage, *lpb)) {
                i++;
                lpb++;
            }
        }
        if (i > n) {
            if (fseek (Fp, -1, SEEK_CUR) == -1)
                fatal(1002);
            n--;
            *(Buf + n) = 0;
        }

        //-
        //- Convert the 8-bit buffer to the 16-bit buffer.
        //-
        Fstack[Findex].fl_numread = MultiByteToWideChar (uiCodePage, MB_PRECOMPOSED,
                                          (LPCSTR) Buf, n, p, Fstack[Findex].fl_bufsiz);
        MyFree (Buf);
    } else {

        Fstack[Findex].fl_numread = n =
            fread (p, sizeof(WCHAR), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- If the file is in reversed format, swap the bytes.
        //-
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_16_BIT_REV && n > 0) {
            WCHAR  *pT = p;
            BYTE  jLowNibble;
            BYTE  jHighNibble;
            INT   cNumWords = n;

            while (cNumWords--) {
                jLowNibble = (BYTE)(*pT & 0xFF);
                jHighNibble = (BYTE)((*pT >> 8) & 0xFF);

                *pT++ = (WCHAR)(jHighNibble | (jLowNibble << 8));
            }
        }
    }

    /*
    **  the total read counts the total read *and* used.
    */

    if (n != 0) {                               /* we read something */
        *(p + Fstack[Findex].fl_numread) = EOS_CHAR;    /* sentinal at the end */
        return(FALSE);                          /* more to do */
    }
    *p = EOS_CHAR;                              /* read no chars */
    return(TRUE);                               /* real end of buffer */
}


/************************************************************************
** io_restart : restarts the current file with a new codepage
**  Method: figure out where the current character came from
**      using WideCharToMultiByte(...cch up to current char...)
**      Note that this assumes that roundtrip conversion to/from
**      Unicode results in the same # of characters out as in.
**      fseek to the right place, then read a new buffer
**
**      Note that uiCodePage controls the seek, so it must
**      remain set to the value used to do the translation
**      from multi-byte to Unicode until after io_restart returns.
**
************************************************************************/
int
io_restart(
    unsigned long cp
    )
{
    int         n;
    TEXT_TYPE   p;

    // If it's a Unicode file, nothing to do, so just return.
    if (Fstack[Findex].fl_fFileType != DFT_FILE_IS_8_BIT)
        return TRUE;

    p = Fstack[Findex].fl_buffer;
    n = Fstack[Findex].fl_numread - (int)(Current_char - p);

    if (n != 0) {
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {
            n = WideCharToMultiByte(uiCodePage, 0, Current_char, n, NULL, 0, NULL, NULL);
            if (n == 0)
                return TRUE;
        } else
            n *= sizeof(WCHAR);

        if (fseek(Fp, -n, SEEK_CUR) == -1)
            fatal(1002);
    }
    Fstack[Findex].fl_numread = 0;
    // io_eob will return true if we're at the end of the file.
    // this is an error for restart (it means there's nothing more
    // to do here (ie: #pragma codepage is the last line in the file).
    return !io_eob();
}


/************************************************************************
**  p0_init : inits for prepocessing.
**              Input : ptr to file name to use as input.
**                      ptr to LIST containing predefined values.
**                                       ( -D's from cmd line )
**
**  Note : if "newinput" cannot open the file,
**                it gives a fatal msg and exits.
**
************************************************************************/
void
p0_init(
    WCHAR *p_fname,
    WCHAR *p_outname,
    LIST *p_defns,
    LIST *p_undefns
    )
{
    REG WCHAR  *p_dstr;
    REG WCHAR  *p_eq;
    int         ntop;

    SETCHARMAP(LX_FORMALMARK, LX_MACFORMAL);
    SETCHARMAP(LX_FORMALSTR, LX_STRFORMAL);
    SETCHARMAP(LX_FORMALCHAR, LX_CHARFORMAL);
    SETCHARMAP(LX_NOEXPANDMARK, LX_NOEXPAND);
    if(EXTENSION) {
        /*
        **      '$' is an identifier character under extensions.
        */
        SETCHARMAP(L'$', LX_ID);
        SETCONTMAP(L'$', LXC_ID);
    }

    for(ntop = p_defns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_defns->li_defns[ntop];
        p_eq = Reuse_W;
        while ((*p_eq = *p_dstr++) != 0)  {  /* copy the name to Reuse_W */
            if(*p_eq == L'=') {     /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if(*p_eq == L'=') {
            WCHAR      *p_tmp;
            WCHAR      *last_space = NULL;

            *p_eq = L'\0';               /* null the = */
            for(p_tmp = p_dstr; *p_tmp; p_tmp++) {      /* find the end of it */
                if(iswspace(*p_tmp)) {
                    if(last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if(last_space != NULL) {
                *last_space = L'\0';
            }
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            if( *p_dstr ) {     /* non-empty string */
                definstall(p_dstr, (wcslen(p_dstr) + 2), FROM_COMMAND);
            } else {
                definstall((WCHAR *)0, 0, 0);
            }
        } else {
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            definstall(L"1\000", 3, FROM_COMMAND);   /* value of string is 1 */
        }
    }

    /* undefine */
    for(ntop = p_undefns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_undefns->li_defns[ntop];
        p_eq = Reuse_W;
        while ((*p_eq = *p_dstr++) != 0)  {  /* copy the name to Reuse_W */
            if(*p_eq == L'=') {     /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if(*p_eq == L'=') {
            WCHAR      *p_tmp;
            WCHAR      *last_space = NULL;

            *p_eq = L'\0';               /* null the = */
            for(p_tmp = p_dstr; *p_tmp; p_tmp++) {      /* find the end of it */
                if(iswspace(*p_tmp)) {
                    if(last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if(last_space != NULL) {
                *last_space = L'\0';
            }
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            if( *p_dstr ) {     /* non-empty string */
                undefine();
            } else {
                undefine();
            }
        } else {
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            undefine();   /* value of string is 1 */
        }
    }

    if ((OUTPUTFILE = _wfopen(p_outname, L"w+b")) == NULL) {
        fatal(1023, p_outname);
    }

    newinput(p_fname,MUST_OPEN);
}

/************************************************************************
**  p0_terminate : terminates prepocessing.
**
**
************************************************************************/
void
p0_terminate(
    void
    )
{
    for ( ;fpop(); )
        ;
    if (OUTPUTFILE)
        fclose(OUTPUTFILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p0prepro.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include <ddeml.h>

/************************************************************************/
/* Internal constants                                                   */
/************************************************************************/
#define GOT_IF                  1       /* last nesting command was an if.. */
#define GOT_ELIF                2       /* last nesting command was an if.. */
#define GOT_ELSE                3       /* last nesting command was an else */
#define GOT_ENDIF               4       /* found endif */
#define ELSE_OR_ENDIF           5       /* skip to either #else or #endif */
#define ENDIF_ONLY              6       /* skip to #endif -- #else is an error*/

int     ifstack[IFSTACK_SIZE];


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
void chk_newline(const wchar_t *);
void in_standard(void);
int incr_ifstack(void);
token_t next_control(void);
unsigned long int pragma(void);
int skipto(int);
void skip_quoted(int);
PWCHAR sysinclude(void);


/************************************************************************/
/* incr_ifstack - Increment the IF nesting stack                        */
/************************************************************************/

int
incr_ifstack(
    void
    )
{
    if(++Prep_ifstack >= IFSTACK_SIZE) {
        fatal(1052);
    }
    return(Prep_ifstack);
}


/************************************************************************
 * SYSINCLUDE - process a system include : #include <foo>
 *
 * ARGUMENTS - none
 *
 * RETURNS - none
 *
 * SIDE EFFECTS - none
 *
 * DESCRIPTION
 *      Get the system include file name.  Since the name is not a "string",
 *      the name must be built much the same as the -E option rebuilds the text
 *      by using the Tokstring expansion for tokens with no expansion already
 *
 *  NOTE : IS THIS ANSI? note we're just reading chars, and not expanding
 * any macros. NO, it's not. it must expand the macros.
 * TODO : have it call yylex() unless and until it finds a '>' or a newline.
 * (probably have to set On_pound_line to have yylex return the newline.)
 *
 * AUTHOR
 *                      Ralph Ryan      Sep. 1982
 *
 * MODIFICATIONS - none
 *
 *
 ************************************************************************/
PWCHAR
sysinclude(
    void
    )
{
    REG int     c;
    REG WCHAR  *p_fname;

    p_fname = Reuse_W;
    c = skip_cwhite();
    if( c == L'\n' ) {
        UNGETCH();
        error(2012);    /* missing name after '<' */
        return(NULL);
    }
    while( c != L'>' && c != L'\n' ) {
        *p_fname++ = (WCHAR)c;          /* check for buffer overflow ??? */
        c = get_non_eof();
    }
    if( c == L'\n' ) {
        UNGETCH();
        error(2013);    /* missing '>' */
        return(NULL);
    }
    if(p_fname != Reuse_W) {
        p_fname--;
        while((p_fname >= Reuse_W) && iswspace(*p_fname)) {
            p_fname--;
        }
        p_fname++;
    }
    *p_fname = L'\0';
    return(Reuse_W);
}


/************************************************************************
**  preprocess : the scanner found a # which was the first non-white char
**  on a line.
************************************************************************/
void
preprocess(
    void
    )
{
    REG WCHAR   c;
    long        eval;
    int         condition;
    token_t     deftok;
    hln_t       identifier;
    unsigned long int   cp;

    if(Macro_depth != 0) {      /* # only when not in a macro */
        return;
    }
    switch(CHARMAP(c = skip_cwhite())) {
        case LX_ID:
            getid(c);
            HLN_NAME(identifier) = Reuse_W;
            HLN_LENGTH(identifier) = (UINT)Reuse_W_length;
            HLN_HASH(identifier) = Reuse_W_hash;
            break;

        case LX_NL:
            UNGETCH();
            return;

        default:
            error(2019, c);    /* unknown preprocessor command */
            skip_cnew();    /* finds a newline */
            return;
    }

    On_pound_line = TRUE;
start:
    switch(deftok = is_pkeyword(HLN_IDENTP_NAME(&identifier))) {
        int                     old_prep;

        case P0_DEFINE :
            define();
            break;
        case P0_LINE :
            old_prep = Prep;
            Prep = FALSE;
            yylex();
            if(Basic_token != L_CINTEGER) {         /* #line needs line number */
                error(2005, TS_STR(Basic_token));        /* unknown preprocessor command */
                Prep = old_prep;
                skip_cnew();
                On_pound_line = FALSE;
                return;
            }
            /*
            **  -1 because there's a newline at the end of this line
            **  which will be counted later when we find it.
            **  the #line says the next line is the number we've given
            */
            Linenumber = TR_LVALUE(yylval.yy_tree) - 1;
            yylex();
            Prep = old_prep;
            switch(Basic_token) {
                case L_STRING:
                    if( wcscmp(Filename, yylval.yy_string.str_ptr) != 0) {
                        wcsncpy(Filename,
                            yylval.yy_string.str_ptr,
                            sizeof(Filebuff) / sizeof(WCHAR)
                            );
                    }

                case L_NOTOKEN:
                    break;

                default:
                    error(2130, TS_STR(Basic_token));         /* #line needs a string */
                    skip_cnew();
                    On_pound_line = FALSE;
                    return;
            }
            emit_line();
            chk_newline(L"#line");
            break;
        case P0_INCLUDE :
            old_prep = Prep;
            Prep = FALSE;
            InInclude = TRUE;
            yylex();
            InInclude = FALSE;
            Prep = old_prep;
            switch(Basic_token) {
                case L_LT:
                    if((sysinclude()) == NULL) {
                        skip_cnew();
                        On_pound_line = FALSE;
                        return;
                    }
                    yylval.yy_string.str_ptr = Reuse_W;
                    break;

                case L_STRING:
                    break;

                default:
                    error(2006, TS_STR(Basic_token));        /* needs file name */
                    skip_cnew();
                    On_pound_line = FALSE;
                    return;
                    break;
            }
            wcscpy(Reuse_Include, yylval.yy_string.str_ptr);
            chk_newline(L"#include");
            if( wcschr(Path_chars, *yylval.yy_string.str_ptr) ||
                (wcschr(Path_chars, L':') && (yylval.yy_string.str_ptr[1] == L':'))) {
                /*
                **  we have a string which either has a 1st char which is a path
                **  delimiter or, if ':' is a path delimiter (DOS), which has
                **  "<drive letter>:" as the first two characters.  Such names
                **  specify a fully qualified pathnames. Do not append the search
                **  list, just look it up.
                */
                if( ! newinput(yylval.yy_string.str_ptr, MAY_OPEN)) {
                    fatal(1015, Reuse_W); /* can't find include file */
                }
            }
            else if( (Basic_token != L_STRING) || (! nested_include())) {
                in_standard();
            }
            break;

        case P0_IFDEF :
        case P0_IFNDEF :
            if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                fatal(1016);
            }
            getid(c);
            eval = (get_defined()) ? TRUE : FALSE;
            chk_newline((deftok == P0_IFDEF) ? L"#ifdef" : L"#ifndef");
            if(deftok == P0_IFNDEF) {
                eval = ( ! eval );
            }
            if( eval || ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE) ) {
                /*
                **  expression is TRUE or when we skipped the false part
                **  we found a #else that will be expanded.
                */
                ifstack[incr_ifstack()] = GOT_IF;
            } else if(condition == GOT_ELIF) {
                /* hash is wrong, but it won't be used */
                HLN_NAME(identifier) = L"if";                /* sleazy HACK */
                goto start;
            }
            break;

        case P0_IF :
            old_prep = Prep;
            Prep = FALSE;
            InIf = TRUE;
            eval = do_constexpr();
            InIf = FALSE;
            Prep = old_prep;
            chk_newline(PPifel_str /* "#if/#elif" */);
            if((eval) || ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE) ) {
                /*
                **  expression is TRUE or when we skipped the false part
                **  we found a #else that will be expanded.
                */
                ifstack[incr_ifstack()] = GOT_IF;
                if(Eflag && !eval)
                    emit_line();
            } else {
                /*
                **  here the #if's expression was false, so we skipped until we found
                **  an #elif. we'll restart and fake that we're processing a #if
                */
                if(Eflag)
                    emit_line();
                if(condition == GOT_ELIF) {
                    /* hash is wrong, but it won't be needed */
                    HLN_NAME(identifier) = L"if";            /* sleazy HACK */
                    goto start;
                }
            }
            break;
        case P0_ELIF :
            /*
            **  here, we have found a #elif. first check to make sure that
            **  this is not an occurrance of a #elif with no preceding #if.
            **  (if Prep_ifstack < 0) then there is no preceding #if.
            */
            if(Prep_ifstack-- < 0) {
                fatal(1018);
            }
            /*
            **  now, the preceding #if/#elif was true, and we've
            **  just found the next #elif. we want to skip all #else's
            **  and #elif's from here until we find the enclosing #endif
            */
            while(skipto(ELSE_OR_ENDIF) != GOT_ENDIF) {
                ;
            }
            if(Eflag)
                emit_line();
            break;

        case P0_ELSE :      /*  the preceding #if/#elif was true  */
            if((Prep_ifstack < 0) || (ifstack[Prep_ifstack--] != GOT_IF)) {
                fatal(1019); /*  make sure there was one  */
            }
            chk_newline(PPelse_str /* "#else" */);
            skipto(ENDIF_ONLY);
            if(Eflag)
                emit_line();
            break;

        case P0_ENDIF :     /*  only way here is a lonely #endif  */
            if(Prep_ifstack-- < 0) {
                fatal(1020);
            }
            if(Eflag)
                emit_line();
            chk_newline(PPendif_str /* "#endif" */);
            break;

        case P0_PRAGMA :
            cp = pragma();
            if (cp != 0) {
                if (cp == CP_WINUNICODE) {
                    if (fWarnInvalidCodePage) {
                        warning(4213);
                    } else {
                        fatal(4213);
                    }
                    break;
                }
                if (!IsValidCodePage(cp)) {
                    if (fWarnInvalidCodePage) {
                        warning(4214);
                    } else {
                        fatal(4214);
                    }
                    break;
                }
                if (cp != uiCodePage) {
                    if (!io_restart(cp)) {
                        fatal(1121);
                    }
                    uiCodePage = cp;    // can't be set until now!
                }
            }
            break;

        case P0_UNDEF :
            if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                warning(4006);      /* missing identifier on #undef */
            } else {
                getid(c);
                undefine();
            }
            chk_newline(L"#undef");
            break;

        case P0_ERROR:
            {
                PWCHAR      p;

                p = Reuse_W;
                while((c = get_non_eof()) != LX_EOS) {
                    if(c == L'\n') {
                        UNGETCH();
                        break;
                    }
                    *p++ = c;
                }
                *p = L'\0';
            }
            error(2188, Reuse_W);
            chk_newline(L"#error");
            break;

        case P0_IDENT:
            old_prep = Prep ;
            Prep = FALSE;
            yylex();
            Prep = old_prep;
            if(Basic_token != L_STRING) {
                warning(4079, TS_STR(Basic_token));
            }
            chk_newline(L"#error");
            break;

        case P0_NOTOKEN:
            fatal(1021, HLN_IDENTP_NAME(&identifier));
            break;
    }
    On_pound_line = FALSE;
}


/************************************************************************
 * SKIPTO - skip code until the end of an undefined block is reached.
 *
 * ARGUMENTS
 *      short key - skip to an ELSE or ENDIF or just an ENDIF
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *      - throws away input
 *
 * DESCRIPTION
 *      The preprocessor is skipping code between failed ifdef, etc. and
 *      the corresponding ELSE or ENDIF (when key == ELSE_OR_ENDIF).
 *      Or it is skipping code between a failed ELSE and the ENDIF (when
 *      key == ENDIF_ONLY).
 *
 * AUTHOR - Ralph Ryan, Sept. 16, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
skipto(
    int key
    )
{
    REG int             level;
    REG token_t tok;

    level = 0;
    tok = P0_NOTOKEN;
    for(;;) {
        /* make sure that IF [ELSE] ENDIF s are balanced */
        switch(next_control()) {
            case P0_IFDEF:
            case P0_IFNDEF:
            case P0_IF:
                level++;
                break;
            case P0_ELSE:
                tok = P0_ELSE;
                /*
                            **  FALLTHROUGH
                            */
            case P0_ELIF:
                /*
                **  we found a #else or a #elif. these have their only chance
                **  at being valid if they're at level 0.
                **  if we're at any other level,
                **  then this else/elif belongs to some other #if and we skip them.
                **  if we were looking for an endif, the we have an error.
                */
                if(level != 0) {
                    tok = P0_NOTOKEN;
                    break;
                }
                if(key == ENDIF_ONLY) {
                    fatal(1022);   /* expected #endif */
                } else if(tok == P0_ELSE) {
                    chk_newline(PPelse_str /* "#else" */);
                    return(GOT_ELSE);
                } else {
                    return(GOT_ELIF);
                }
                break;
            case P0_ENDIF:
                if(level == 0) {
                    chk_newline(PPendif_str /* "#endif" */);
                    return(GOT_ENDIF);
                } else {
                    level--;
                }
                break;
        }
    }
}


/*************************************************************************
**  in_standard : search for the given file name in the directory list.
**              Input : ptr to include file name.
**              Output : fatal error if not found.
*************************************************************************/
void
in_standard(
    void
    )
{
    int     i;
    int     stop;
    WCHAR   *p_dir;
    WCHAR   *p_file;
    WCHAR   *p_tmp;

    stop = Includes.li_top;

    for(i = MAXLIST-1; i >= stop; i--) {
        p_file = yylval.yy_string.str_ptr;
        if( ((p_dir = Includes.li_defns[i])!=0) &&(wcscmp(p_dir, L"./") != 0) ) {
            /*
            **  there is a directory to prepend and it's not './'
            */
            p_tmp = Exp_ptr;
            while((*p_tmp++ = *p_dir++) != 0)
                ;
            /*
            **  above loop increments p_tmp past null.
            **  this replaces that null with a '/' if needed.  Not needed if the
            **  last character of the directory spec is a path delimiter.
            **  we then point to the char after the '/'
            */
            if(wcschr(Path_chars, p_dir[-2]) == 0) {
                p_tmp[-1] = L'/';
            } else {
                --p_tmp;
            }
            while((*p_tmp++ = *p_file++) != 0)
                ;
            p_file = Exp_ptr;
        }
        if(newinput(p_file,MAY_OPEN)) { /* this is the non-error way out */
            return;
        }
    }

    fatal(1015, yylval.yy_string.str_ptr);       /* can't find include file */
}


/*************************************************************************
**  chk_newline : check for whitespace only before a newline.
**  eat the newline.
*************************************************************************/
void chk_newline(const wchar_t *cmd)
{
    if(skip_cwhite() != L'\n') {
        warning(4067, cmd);          /* cmd expected newline */
        skip_cnew();
    } else {
        UNGETCH();
    }
}

/*************************************************************************
**  skip_quoted : skips chars until it finds a char which matches its arg.
*************************************************************************/
void
skip_quoted(
    int sc
    )
{
    REG WCHAR   c;

    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                warning(4093);
                UNGETCH();
                return;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == (WCHAR)sc)
                    return;
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    SKIPCH();       /* might be /" !! */
                }
                break;
            case LX_LEADBYTE:
                get_non_eof();
                break;
        }
    }
}


/*************************************************************************
**  next_control : find a newline. find a pound sign as the first non-white.
**  find an id start char, build an id look it up and return the token.
**  this knows about strings/char const and such.
*************************************************************************/
token_t
next_control(
    void
    )
{
    REG WCHAR   c;

    for(;;) {
        c = skip_cwhite();
first_switch:
        switch(CHARMAP(c)) {
            case LX_NL:
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if(Prep) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                if((c = skip_cwhite()) == L'#') {
                    if(LX_IS_IDENT(c = skip_cwhite())) {
                        /*
                        **  this is the only way to return to the caller.
                        */
                        getid(c);
                        return(is_pkeyword(Reuse_W));       /* if its predefined  */
                    }
                }
                goto first_switch;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                skip_quoted(c);
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    SKIPCH();       /* might be \" !! */
                }
                break;
        }
    }
}


/*************************************************************************
**  do_defined : does the work for the defined(id)
**              should parens be counted, or just be used as delimiters (ie the
**              first open paren matches the first close paren)? If this is ever
**              an issue, it really means that there is not a legal identifier
**              between the parens, causing an error anyway, but consider:
**              #if (defined(2*(x-1))) || 1
**              #endif
**              It is friendlier to allow compilation to continue
*************************************************************************/
int
do_defined(
    PWCHAR p_tmp
    )
{
    REG UINT    c;
    REG int     value=0;
    int         paren_level = 0;

    /*
    ** we want to allow:
    **      #define FOO             defined
    **      #define BAR(a,b)        a FOO | b
    **      #define SNAFOO          0
    **      #if FOO BAR
    **      print("BAR is defined");
    **      #endif
    **      #if BAR(defined, SNAFOO)
    **      print("FOO is defined");
    **      #endif
    */
    if(wcscmp(p_tmp,L"defined") != 0) {
        return(0);
    }
    if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
        /* NL encountered */
        return(value);
    }
    if((c = CHECKCH())== L'(') { /* assumes no other CHARMAP form of OPAREN */
        *Exp_ptr++ = (WCHAR)c;
        SKIPCH();
        paren_level++;
        if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
            /* NL encountered */
            return(value);
        }
    }
    if(Tiny_lexer_nesting>0) {
        if((CHARMAP((WCHAR)(c=CHECKCH()))==LX_MACFORMAL) || (CHARMAP((WCHAR)c)==LX_ID)) {
            SKIPCH();
            tl_getid((UCHAR)c);
        }
    } else {
        if(LX_IS_IDENT(((WCHAR)(c = CHECKCH())))) {
            SKIPCH();
            if(Macro_depth >0) {
                lex_getid((WCHAR)c);
            } else {
                getid((WCHAR)c);
            }
            value = (get_defined()) ? TRUE : FALSE;
        } else {
            if(paren_level==0) {
                error(2003);
            } else {
                error(2004);
            }
        }
    }
    if((CHARMAP(((WCHAR)(c = CHECKCH()))) == LX_WHITE) || (CHARMAP((WCHAR)c) == LX_EOS)) {
        if( ! can_get_non_white()) {
            return(value);
        }
    }
    if(paren_level) {
        if((CHARMAP(((WCHAR)(c = CHECKCH()))) == LX_CPAREN)) {
            SKIPCH();
            paren_level--;
            *Exp_ptr++ = (WCHAR)c;
        }
    }

    if((paren_level > 0) && (Tiny_lexer_nesting == 0)) {
        warning(4004);
    }

    return(value);
}


/*************************************************************************
 * NEXTIS - The lexical interface for #if expression parsing.
 * If the next token does not match what is wanted, return FALSE.
 * otherwise Set Currtok to L_NOTOKEN to force scanning on the next call.
 * Return TRUE.
 * will leave a newline as next char if it finds one.
 *************************************************************************/
int
nextis(
    register token_t tok
    )
{
    if(Currtok != L_NOTOKEN) {
        if(tok == Currtok) {
            Currtok = L_NOTOKEN;                        /*  use up the token  */
            return(TRUE);
        } else {
            return(FALSE);
        }
    }
    switch(yylex()) {                           /*  acquire a new token  */
        case 0:
            break;
        case L_CONSTANT:
            if( ! IS_INTEGRAL(TR_BTYPE(yylval.yy_tree))) {
                    fatal(1017);
            } else {
                Currval = TR_LVALUE(yylval.yy_tree);
            }

            if(tok == L_CINTEGER) {
                return(TRUE);
            }

            Currtok = L_CINTEGER;
            break;

        case L_IDENT:
            Currval = do_defined(HLN_IDENTP_NAME(&yylval.yy_ident));
            if(tok == L_CINTEGER) {
                return(TRUE);
            }
            Currtok = L_CINTEGER;
            break;

        default:
            if(tok == Basic_token) {
                return(TRUE);
            }
            Currtok = Basic_token;
            break;
    }

    return(FALSE);
}


/************************************************************************
**  skip_cnew : reads up to and including the next newline.
************************************************************************/
void
skip_cnew(
    void
    )
{
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                UNGETCH();
                return;
            case LX_SLASH:
                skip_comment();
                break;
            case LX_EOS:
                handle_eos();
                break;
        }
    }
}


/************************************************************************
**  skip_NLonly : reads up to the next newline, disallowing comments
************************************************************************/
void
skip_NLonly(
    void
    )
{
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                UNGETCH();
                return;
            case LX_EOS:
                handle_eos();
                break;
        }
    }
}


/************************************************************************
**  pragma : handle processing the pragma directive
**  called by preprocess() after we have seen the #pragma
**  and are ready to handle the keyword which follows.
************************************************************************/
unsigned long
pragma(
    void
    )
{
    WCHAR   c;
    unsigned long int cp=0;

    c = skip_cwhite();
    if (c != L'\n') {
        getid(c);
        _wcsupr(Reuse_W);
        if (wcscmp(L"CODE_PAGE", Reuse_W) == 0) {
            if ((c = skip_cwhite()) == L'(') {
                c = skip_cwhite();  // peek token
                if (iswdigit(c)) {
                    token_t tok;
                    int old_prep = Prep;

                    Prep = FALSE;
                    tok = getnum(c);
                    Prep = old_prep;

                    switch(tok) {
                        default:
                        case L_CFLOAT:
                        case L_CDOUBLE:
                        case L_CLDOUBLE:
                        case L_FLOAT:
                        case L_DOUBLE:
                            break;
                        case L_CINTEGER:
                        case L_LONGINT:
                        case L_CUNSIGNED:
                        case L_LONGUNSIGNED:
                        case L_SHORT:
                        case L_LONG:
                        case L_SIGNED:
                        case L_UNSIGNED:
                            cp = TR_LVALUE(yylval.yy_tree);
                            break;
                    }
                }
                if (cp == 0) {
                    getid(c);
                    _wcsupr(Reuse_W);
                    if (wcscmp(L"DEFAULT", Reuse_W) == 0) {
                        cp = uiDefaultCodePage;
                    } else {
                        error(4212, Reuse_W);
                    }
                }
                if ((c = skip_cwhite()) != L')') {
                    UNGETCH();
                    error(4211);
                }
            } else {
                UNGETCH();
                error(4210);
            }

            swprintf(Reuse_W, L"#pragma code_page %d\r\n", cp);
            myfwrite(Reuse_W, wcslen(Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        }
    }
    // Skip #pragma statements
    while((c = get_non_eof()) != L'\n');
    UNGETCH();
    return cp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p1types.h ===
/*
**  symbols basic types
**  if the values are changed check : init'd arrays in globals.c
*/
#define BTundef         0
#define BTchar          1
#define BTshort         2
#define BTint           3
#define BTlong          4
#define BTenumuse       5
#define BTfloat         6
#define BTdouble        7
#define BTldouble       8
#define BTseg           9
#define BTBASIC         9   /* used elsewhere to indicate the last basic type */
#define BTvoid          10
#define BTenum          11
#define BTstruct        12
#define BTunion         13
#define BTstuse         14
#define BTunuse         15

#define BT_MASK         0x0f    /* basic type mask */

/*
**  the following are also used in indirection strings as modifiers
**  to the basic indirections.
**  NOTE THIS DOESN'T really work for C600, but for just one case.
**  if a typedef has 'near' on it, 'consolidate_types' will consider
**  it to be a 'signed' bit, and remove it, thus, near never gets
**  added to whatever the typedef is used on.
*/
#define BT_UNSIGNED             0x0010  /* unsigned keyword used */
#define BT_SIGNED               0x0020  /* signed keyword used */
#define SU_MASK                 0x0030  /* signed/unsigned mask */

#define BT_NEAR                 0x0040  /* near keyword used */
#define BT_FAR                  0x0080  /* far keyword used */
#define BT_HUGE                 0x00c0  /* huge keyword used */
#define NFH_MASK                0x00c0  /* near/far/huge mask */

#define BT_INTERRUPT            0x0100  /* interrupt seen */
#define BT_SAVEREGS             0x0200  /* dynalink seen */
#define BT_EXPORT               0x0400  /* export seen */
#define BT_LOADDS               0x0800  /* loadds seen */
#define CODEMOD_MASK            0x0f00  /* code modifiers */

#define BT_CONST                0x1000  /* constant keyword used */
#define BT_VOLATILE             0x2000  /* volatile keyword used */
#define CV_MASK                 0x3000  /* const/volatile mask */

#define BT_CDECL                0x4000  /* cdecl keyword used */
#define BT_FORTRAN              0x8000  /* fortran keyword used */
#define BT_PASCAL               0xc000  /* pascal keyword used */
#define LANGUAGE_MASK           0xc000  /* cdecl/fortran/pascal mask */

#define MODIFIER_MASK   (NFH_MASK | LANGUAGE_MASK | CODEMOD_MASK | CV_MASK)
#define ALL_MODIFIERS   (MODIFIER_MASK | SU_MASK)
/*
**      macros for getting/setting basic type information
**  Q_* to query the flag.
**      S_* to set the flag.
**  the Q_near/far/huge things are defined later, and are called IS_*.
*/
#define IS_BTBASIC(P)           ((P) <= BTBASIC)
#define IS_BTINTEGRAL(P)        ((P) <= BTenumuse)
#define IS_BTFLOAT(P)           ((BTfloat <= (P)) && ((P) <= BTldouble))
#define IS_BTVOID(P)            ((P) == BTvoid)

#define IS_BASIC(P)             (IS_BTBASIC(Q_BTYPE(P)))
#define IS_INTEGRAL(P)          (IS_BTINTEGRAL(Q_BTYPE(P)))
#define IS_FLOAT(P)             (IS_BTFLOAT(Q_BTYPE(P)))
#define IS_VOID(P)              (IS_BTVOID(Q_BTYPE(P)))

#define IS_MULTIBYTE(P) ((BTstruct <= (P)) && ((P) <= BTunuse))
#define IS_UNSIGNED(P)  ((P) & BT_UNSIGNED)
#define IS_SIGNED(P)    ((P) & BT_SIGNED)
#define CLR_SIGNED(P)   ((P) &= ~BT_SIGNED)

#define S_UNSIGNED(P)   ((P) |= BT_UNSIGNED)
#define S_SIGNED(P)     ((P) |= BT_SIGNED)
#define S_CONST(P)      ((P) |= BT_CONST)
#define S_VOLATILE(P)   ((P) |= BT_VOLATILE)
#define S_NEAR(P)       ((P) |= BT_NEAR)
#define S_FAR(P)        ((P) |= BT_FAR)
#define S_HUGE(P)       ((P) |= BT_HUGE)
#define S_CDECL(P)      ((P) |= BT_CDECL)
#define S_FORTRAN(P)    ((P) |= BT_FORTRAN)
#define S_PASCAL(P)     ((P) |= BT_PASCAL)
#define S_INTERRUPT(P)  ((P) |= BT_INTERRUPT)
#define S_SAVEREGS(P)   ((P) |= BT_SAVEREGS)

#define Q_BTYPE(P)      ((P) & ( BT_MASK ))
#define S_BTYPE(P,V)    ((P) = (((P) & ( ~ BT_MASK )) | V))

struct  s_flist         {                       /* formal parameter list of types */
        ptype_t         fl_type;                /* type of formal */
        pflist_t        fl_next;                /* next one */
        };

#define FL_NEXT(P)              ((P)->fl_next)
#define FL_TYPE(P)              ((P)->fl_type)

union   u_ivalue        {
        abnd_t          ind_subscr;             /*  array subscript size  */
        psym_t          ind_formals;    /*  formal symbol list  */
        pflist_t        ind_flist;              /*  formal type list  */
        psym_t          ind_basesym;    /*  segment we're based on  */
        ptype_t         ind_basetype;   /*  type we're based on  */
        phln_t          ind_baseid;             /*  id we're based on  */
        };

#define PIVALUE_ISUB(P)                 ((P)->ind_subscr)
#define PIVALUE_IFORMALS(P)             ((P)->ind_formals)
#define PIVALUE_IFLIST(P)               ((P)->ind_flist)
#define PIVALUE_BASEDSYM(P)             ((P)->ind_basesym)
#define PIVALUE_BASEDTYPE(P)            ((P)->ind_basetype)
#define PIVALUE_BASEDID(P)              ((P)->ind_baseid)

#define IVALUE_ISUB(P)                  (PIVALUE_ISUB(&(P)))
#define IVALUE_IFORMALS(P)              (PIVALUE_IFORMALS(&(P)))
#define IVALUE_IFLIST(P)                (PIVALUE_IFLIST(&(P)))
#define IVALUE_BASEDSYM(P)              (PIVALUE_BASEDSYM(&(P)))
#define IVALUE_BASEDTYPE(P)             (PIVALUE_BASEDTYPE(&(P)))
#define IVALUE_BASEDID(P)               (PIVALUE_BASEDID(&(P)))

struct  s_indir {
        btype_t         ind_type;               /*  what kind ?  */
        pindir_t        ind_next;               /*  next one  */
        ivalue_t        ind_info;               /*  subscript/function's params  */
        };

#define INDIR_INEXT(P)          ((P)->ind_next)
#define INDIR_ITYPE(P)          ((P)->ind_type)
#define INDIR_INFO(P)           ((P)->ind_info)
#define INDIR_ISUB(P)           (IVALUE_ISUB(INDIR_INFO(P)))
#define INDIR_IFORMALS(P)       (IVALUE_IFORMALS(INDIR_INFO(P)))
#define INDIR_IFLIST(P)         (IVALUE_IFLIST(INDIR_INFO(P)))
#define INDIR_BASEDSYM(P)       (IVALUE_BASEDSYM(INDIR_INFO(P)))
#define INDIR_BASEDTYPE(P)      (IVALUE_BASEDTYPE(INDIR_INFO(P)))
#define INDIR_BASEDID(P)        (IVALUE_BASEDID(INDIR_INFO(P)))
/*
**  optimal choices for these things.
**  however, everyone uses macros to test them, so if i'm wrong,
**  it should be easy to change the values, but think well !!!
*/
#define IN_FUNC                         0x00
#define IN_PFUNC                        0x01
#define IN_ARRAY                        0x02
#define IN_PDATA                        0x03
#define IN_VOIDLIST                     0x04
#define IN_VARARGS                      0x08
#define IN_MASK                         (IN_ARRAY | IN_PDATA | IN_PFUNC | IN_FUNC)
#define IN_ADDRESS                      (IN_ARRAY | IN_PDATA | IN_PFUNC)
#define IN_DATA_ADDRESS                 (IN_ARRAY & IN_PDATA)   /* yes, i meant '&' */
#define IN_POINTER                      (IN_PFUNC & IN_PDATA)   /* yes, i meant '&' */
#if IN_DATA_ADDRESS == 0
#error IN_DATA_ADDRESS is ZERO
#endif
#if IN_POINTER == 0
#error IN_POINTER is ZERO
#endif
#define IS_ARRAY(I)                     (((I) & IN_MASK) == IN_ARRAY)
#define IS_PDATA(I)                     (((I) & IN_MASK) == IN_PDATA)
#define IS_PFUNC(I)                     (((I) & IN_MASK) == IN_PFUNC)
#define IS_FUNC(I)                      (((I) & IN_MASK) == IN_FUNC)
#define IS_EXTRACT(I)                   ((I) & IN_POINTER)
#define IS_DATA_ADDRESS(I)              ((I) & IN_DATA_ADDRESS)
#define IS_ADDRESS(I)                   ((I) & IN_ADDRESS)
#define IS_INDIR(I)                     ((I) & IN_MASK)
#define MASK_INDIR(I)                   ((I) & IN_MASK)
#define IS_VOIDLIST(I)                  ((I) & IN_VOIDLIST)
#define IS_VARARGS(I)                   ((I) & IN_VARARGS)

#define IS_NFH(I)                       ((I) & NFH_MASK)
#define IS_NEARNFH(I)                   ((I) == BT_NEAR)
#define IS_FARNFH(I)                    ((I) == BT_FAR)
#define IS_HUGENFH(I)                   ((I) == BT_HUGE)
#define IS_BASEDNFH(I)                  ((I) >= BT_BASED)
#define IS_BASEDSELFNFH(I)              ((I) == BT_BASEDSELF)
#define IS_BASEDIDNFH(I)                ((I) == BT_BASEDID)
#define IS_BASEDSYMNFH(I)               ((I) == BT_BASEDSYM)
#define IS_BASEDTYPENFH(I)              ((I) == BT_BASEDTYPE)

#define IS_NEAR(I)                      (IS_NEARNFH(IS_NFH(I)))
#define IS_FAR(I)                       (IS_FARNFH(IS_NFH(I)))
#define IS_HUGE(I)                      (IS_HUGENFH(IS_NFH(I)))
#define IS_BASED(I)                     (IS_BASEDNFH(IS_NFH(I)))
#define IS_BASEDSELF(I)                 (IS_BASEDSELFNFH(IS_NFH(I)))
#define IS_BASEDID(I)                   (IS_BASEDIDNFH(IS_NFH(I)))
#define IS_BASEDSYM(I)                  (IS_BASEDSYMNFH(IS_NFH(I)))
#define IS_BASEDTYPE(I)                 (IS_BASEDTYPENFH(IS_NFH(I)))

#define IS_INTERRUPT(I)         ((I) & BT_INTERRUPT)
#define IS_SAVEREGS(I)          ((I) & BT_SAVEREGS)
#define IS_EXPORT(I)            ((I) & BT_EXPORT)
#define IS_LOADDS(I)            ((I) & BT_LOADDS)
#define IS_CODEMOD(I)           ((I) & CODEMOD_MASK)

#define IS_CONST(I)             ((I) & BT_CONST)
#define IS_VOLATILE(I)          ((I) & BT_VOLATILE)

#define IS_MODIFIED(I)          ((I) & (MODIFIER_MASK))
#define ANY_MODIFIER(I)         ((I) & (ALL_MODIFIERS))

#define INTERF(I)               (MASK_INDIR(I) + (((I) & NFH_MASK) > 4))

#define S_ITYPE(I,V)            ((I) = ((I) & ( ~ IN_MASK )) | (V))
#define S_INFH(I,V)             ((I) = ((I) & ( ~ NFH_MASK )) | (V))
/*
**  type info for symbols
*/
struct  s_type  {
        btype_t         ty_bt;          /*  base type specifiers  */
        pindir_t        ty_indir;       /*  indirection string  */
        p1key_t         ty_dtype;       /*  derived type */
        psym_t          ty_esu;         /*  enum/structure/union/static defining type  */
        USHORT          ty_index;       /*      unique index of type for debugger */
        };
/*
**  help getting type info. P is pointer to TYPE (struct s_type).
**      TYPE contains the basic type, adjectives and an optional pointer
**      to a symbol which is an enumeration, structure, union which is the type
**      of this TYPE.
*/
#define TY_BTYPE(P)             ((P)->ty_bt)    /*  basic type  */
#define TY_DTYPE(P)             ((P)->ty_dtype) /*  derived type  */
#define TY_ESU(P)               ((P)->ty_esu)   /*  ptr to parent enum/struct/union  */
#define TY_INDIR(P)             ((P)->ty_indir) /*  indirection string  */
#define TY_TINDEX(P)            ((P)->ty_index) /*  type index */
#define TY_INEXT(P)             (INDIR_INEXT(TY_INDIR(P)))
#define TY_ITYPE(P)             (INDIR_ITYPE(TY_INDIR(P)))
#define TY_ISUB(P)              (INDIR_ISUB(TY_INDIR(P)))
#define TY_IFORMALS(P)          (INDIR_IFORMALS(TY_INDIR(P)))
#define TY_IFLIST(P)            (INDIR_IFLIST(TY_INDIR(P)))

typedef struct  s_indir_entry   indir_entry_t;
typedef struct  s_type_entry    type_entry_t;

struct  s_indir_entry   {
        indir_entry_t   *ind_next;
        indir_t          ind_type;
        };

struct  s_type_entry    {
        type_entry_t    *te_next;
        type_t           te_type;
        };

#define TYPE_TABLE_SIZE         0x100
#define INDIR_TABLE_SIZE        0x040
/*
**  HASH_MASK : is a value which consists of the bits in common
**  between upper and lower case. we mask each char we read with this
**  to sum them for a hash value. we do this so that all names consisting
**  of the same chars (case insensitive), will hash to the same location.
*/
#define HASH_MASK                       0x5f

#define DATASEGMENT                     0
#define TEXTSEGMENT                     1

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\prerc.c ===
#include "rc.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rc.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

#include <setjmp.h>
#include <ddeml.h>


#define READ_MAX        (MAXSTR+80)
#define MAX_CMD         256
#define cDefineMax      100

wchar_t  resname[_MAX_PATH];

wchar_t  *szRCPP[MAX_CMD];
BOOL     fRcppAlloc[MAX_CMD];

/************************************************************************/
/* Define Global Variables                                              */
/************************************************************************/


int __cdecl rcpp_main(int, wchar_t *[]);

SHORT   ResCount;   /* number of resources */
PTYPEINFO pTypInfo;

SHORT   nFontsRead;
FONTDIR *pFontList;
FONTDIR *pFontLast;
TOKEN   token;
int     errorCount;
WCHAR   tokenbuf[ MAXSTR + 1 ];
wchar_t exename[ _MAX_PATH ];
wchar_t fullname[ _MAX_PATH ];
wchar_t curFile[ _MAX_PATH ];
HANDLE  hHeap = NULL;

PDLGHDR pLocDlg;
UINT    mnEndFlagLoc;       /* patch location for end of a menu. */
/* we set the high order bit there    */

/* BOOL fLeaveFontDir; */
BOOL fVerbose;          /* verbose mode (-v) */

BOOL fAFXSymbols;
BOOL fMacRsrcs;
BOOL fAppendNull;
BOOL fWarnInvalidCodePage;
BOOL fSkipDuplicateCtlIdWarning;
long lOffIndex;
WORD idBase;
BOOL fPreprocessOnly;
wchar_t szBuf[_MAX_PATH * 2];
wchar_t szPreProcessName[_MAX_PATH];


/* File global variables */
wchar_t inname[_MAX_PATH];
wchar_t *szTempFileName;
wchar_t *szTempFileName2;
PFILE   fhBin;
PFILE   fhInput;

/* array for include path stuff, initially empty */
wchar_t *pchInclude;

/* Substitute font name */
int     nBogusFontNames;
WCHAR  *pszBogusFontNames[16];
WCHAR   szSubstituteFontName[MAXTOKSTR];

static  jmp_buf jb;
extern ULONG lCPPTotalLinenumber;

/* Function prototypes for local functions */
HANDLE  RCInit(void);
void    RC_PreProcess(const wchar_t *);
void    CleanUpFiles(void);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rc_main() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int __cdecl
rc_main(
    int argc,
    wchar_t *argv[],
    char *argvA[]
    )
{
    wchar_t     *r;
    wchar_t     *x;
    wchar_t     *s1;
    wchar_t     *s2;
    wchar_t     *s3;
    int         n;
    wchar_t     *pchIncludeT;
    ULONG       cchIncludeMax;
    int         fInclude = TRUE;        /* by default, search INCLUDE */
    int         fIncludeCurrentFirst = TRUE; /* by default, add current dir to start of includes */
    int         cDefine = 0;
    int         cUnDefine = 0;
    wchar_t     *pszDefine[cDefineMax];
    wchar_t     *pszUnDefine[cDefineMax];
    wchar_t     szDrive[_MAX_DRIVE];
    wchar_t     szDir[_MAX_DIR];
    wchar_t     szFName[_MAX_FNAME];
    wchar_t     szExt[_MAX_EXT];
    wchar_t     szFullPath[_MAX_PATH];
    wchar_t     szIncPath[_MAX_PATH];
    wchar_t     buf[10];
    wchar_t     *szRC;
    wchar_t     **ppargv;
    BOOL        *pfRcppAlloc;
    int         rcpp_argc;

    /* Set up for this run of RC */
    if (_setjmp(jb)) {
        return Nerrors;
    }

    hHeap = RCInit();

    if (hHeap == NULL) {
        fatal(1120, 0x01000000);
    }

    if (argvA != NULL) {
        argv = UnicodeCommandLine(argc, argvA);
    }


    pchInclude = pchIncludeT = (wchar_t *) MyAlloc(_MAX_PATH * 2 * sizeof(wchar_t));
    cchIncludeMax = _MAX_PATH*2;

    szRC = argv[0];

    /* process the command line switches */
    while ((argc > 1) && (IsSwitchChar(*argv[1]))) {
        switch (towupper(argv[1][1])) {
            case L'?':
            case L'H':
                // Print out help, and quit

                SendWarning(L"\n");
                SET_MSG(10001, LVER_PRODUCTVERSION_STR);
                SendWarning(Msg_Text);
                SET_MSG(10002);
                SendWarning(Msg_Text);
                SET_MSG(20001);
                SendWarning(Msg_Text);

                return 0;   /* can just return - nothing to cleanup, yet. */

            case L'B':
                if (towupper(argv[1][2]) == L'R') {   /* base resource id */
                    unsigned long id;
                    if (isdigit(argv[1][3]))
                        argv[1] += 3;
                    else if (argv[1][3] == L':')
                        argv[1] += 4;
                    else {
                        argc--;
                        argv++;
                        if (argc <= 1)
                            goto BadId;
                    }
                    if (*(argv[1]) == 0)
                        goto BadId;
                    id = _wtoi(argv[1]);
                    if (id < 1 || id > 32767)
                        fatal(1210);
                    idBase = (WORD)id;
                    break;

BadId:
                    fatal(1209);
                }
                break;

            case L'C':
                /* Check for the existence of CodePage Number */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* Now argv point to first digit of CodePage */

                if (!argv[1])
                    fatal(1204);

                uiCodePage = _wtoi(argv[1]);

                if (uiCodePage == 0)
                    fatal(1205);

                /* Check if uiCodePage exist in registry. */
                if (!IsValidCodePage (uiCodePage))
                    fatal(1206);
                break;

            case L'D':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* remember pointer to string */
                pszDefine[cDefine++] = argv[1];
                if (cDefine > cDefineMax) {
                    fatal(1105, argv[1]);
                }
                break;

            case L'F':
                switch (towupper(argv[1][2])) {
                    case L'O':
                        if (argv[1][3])
                            argv[1] += 3;
                        else {
                            argc--;
                            argv++;
                        }
                        if (argc > 1)
                            wcscpy(resname, argv[1]);
                        else
                            fatal(1101);

                        break;

                    default:
                        fatal(1103, argv[1]);
                }
                break;

            case L'I':
                /* add string to directories to search */
                /* note: format is <path>\0<path>\0\0 */

                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    fatal(1201);

                if ((wcslen(argv[1]) + 1 + wcslen(pchInclude)) >= cchIncludeMax) {
                    cchIncludeMax = wcslen(pchInclude) + wcslen(argv[1]) + _MAX_PATH*2;
                    pchIncludeT = (wchar_t *) MyAlloc(cchIncludeMax * sizeof(wchar_t));
                    wcscpy(pchIncludeT, pchInclude);
                    MyFree(pchInclude);
                    pchInclude = pchIncludeT;
                    pchIncludeT = pchInclude + wcslen(pchIncludeT) + 1;
                }

                /* if not first switch, write over terminator with semicolon */
                if (pchInclude != pchIncludeT)
                    pchIncludeT[-1] = L';';

                /* copy the path */
                while ((*pchIncludeT++ = *argv[1]++) != 0)
                    ;
                break;

            case L'L':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    fatal(1202);

                if (swscanf(argv[1], L"%x", &language) != 1)
                    fatal(1203);

                while (*argv[1]++ != 0)
                    ;

                break;

            case L'M':
                fMacRsrcs = TRUE;
                goto MaybeMore;

            case L'N':
                fAppendNull = TRUE;
                goto MaybeMore;

            case L'P':
                fPreprocessOnly = TRUE;
                break;

            case L'R':
                goto MaybeMore;

            case L'S':
                // find out from BRAD what -S does
                fAFXSymbols = TRUE;
                break;

            case L'U':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* remember pointer to string */
                pszUnDefine[cUnDefine++] = argv[1];
                if (cUnDefine > cDefineMax) {
                    fatal(1104, argv[1]);
                }
                break;

            case L'V':
                fVerbose = TRUE; // AFX doesn't set this
                goto MaybeMore;

            case L'W':
                fWarnInvalidCodePage = TRUE; // Invalid Codepage is a warning, not an error.
                goto MaybeMore;

            case L'Y':
                fSkipDuplicateCtlIdWarning = TRUE;
                goto MaybeMore;

            case L'X':
                /* remember not to add INCLUDE path */
                fInclude = FALSE;

                // VC seems to feel the current dir s/b added first no matter what...
                // If -X! is specified, don't do that.
                if (argv[1][2] == L'!') {
                    fIncludeCurrentFirst = FALSE;
                    argv[1]++;
                }

MaybeMore:      /* check to see if multiple switches, like -xrv */
                if (argv[1][2]) {
                    argv[1][1] = L'-';
                    argv[1]++;
                    continue;
                }
                break;

            case L'Z':

                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    fatal(1211);

                s3 = wcschr(argv[1], L'/');
                if (s3 == NULL)
                    fatal(1212);

                *s3 = L'\0';
                wcscpy(szSubstituteFontName, s3+1);

                s1 = argv[1];
                do {
                    s2 = wcschr(s1, L',');
                    if (s2 != NULL)
                        *s2 = L'\0';

                    if (wcslen(s1)) {
                        if (nBogusFontNames >= 16)
                            fatal(1213);

                        pszBogusFontNames[nBogusFontNames] = (WCHAR *) MyAlloc((wcslen(s1)+1) * sizeof(WCHAR));
                        wcscpy(pszBogusFontNames[nBogusFontNames], s1);
                        nBogusFontNames += 1;
                    }

                    if (s2 != NULL)
                        *s2++ = L',';
                    }
                while (s1 = s2);

                *s3 =  L'/';

                while (*argv[1]++ != 0)
                    ;
                break;

            default:
                fatal(1106, argv[1]);
        }

        /* get next argument or switch */
        argc--;
        argv++;
    }

    /* make sure we have at least one file name to work with */
    if (argc != 2 || *argv[1] == L'\0')
        fatal(1107);

    if (fVerbose) {
        SET_MSG(10001, LVER_PRODUCTVERSION_STR);
        SendWarning(Msg_Text);
        SET_MSG(10002);
        SendWarning(Msg_Text);
        SendWarning(L"\n");
    }

    // Support Multi Code Page

    //  If user did NOT indicate code in command line, we have to set Default
    //     for NLS Conversion

    if (uiCodePage == 0) {
        CHAR *pchCodePageString;

        /* At first, search ENVIRONMENT VALUE */

        if ((pchCodePageString = getenv("RCCODEPAGE")) != NULL) {
            uiCodePage = atoi(pchCodePageString);

            if (uiCodePage == 0 || !IsValidCodePage(uiCodePage)) {
                fatal(1207);
            }
        } else {
            // We use System ANSI Code page (ACP)

            uiCodePage = GetACP();
        }
    }
    uiDefaultCodePage = uiCodePage;
    if (fVerbose) {
        wprintf(L"Using codepage %d as default\n", uiDefaultCodePage);
    }

    /* If we have no extension, assumer .rc                             */
    /* If .res extension, make sure we have -fo set, or error           */
    /* Otherwise, just assume file is .rc and output .res (or resname)  */

    _wsplitpath(argv[1], szDrive, szDir, szFName, szExt);

    if (!(*szDir || *szDrive)) {
        wcscpy(szIncPath, L".;");
    } else {
        wcscpy(szIncPath, szDrive);
        wcscat(szIncPath, szDir);
        wcscat(szIncPath, L";.;");
    }

    if ((wcslen(szIncPath) + 1 + wcslen(pchInclude)) >= cchIncludeMax) {
        cchIncludeMax = wcslen(pchInclude) + wcslen(szIncPath) + _MAX_PATH*2;
        pchIncludeT = (wchar_t *) MyAlloc(cchIncludeMax * sizeof(wchar_t));
        wcscpy(pchIncludeT, pchInclude);
        MyFree(pchInclude);
        pchInclude = pchIncludeT;
        pchIncludeT = pchInclude + wcslen(pchIncludeT) + 1;
    }

    pchIncludeT = (wchar_t *) MyAlloc(cchIncludeMax * sizeof(wchar_t));

    if (fIncludeCurrentFirst) {
        wcscpy(pchIncludeT, szIncPath);
        wcscat(pchIncludeT, pchInclude);
    } else {
        wcscpy(pchIncludeT, pchInclude);
        wcscat(pchIncludeT, L";");
        wcscat(pchIncludeT, szIncPath);
    }

    MyFree(pchInclude);
    pchInclude = pchIncludeT;
    pchIncludeT = pchInclude + wcslen(pchIncludeT) + 1;

    if (!szExt[0]) {
        wcscpy(szExt, L".RC");
    } else if (wcscmp(szExt, L".RES") == 0) {
        fatal(1208);
    }

    _wmakepath(inname, szDrive, szDir, szFName, szExt);
    if (fPreprocessOnly) {
        _wmakepath(szPreProcessName, NULL, NULL, szFName, L".rcpp");
    }

    /* Create the name of the .RES file */
    if (resname[0] == 0) {
        // if building a Mac resource file, we use .rsc to match mrc's output
        _wmakepath(resname, szDrive, szDir, szFName, fMacRsrcs ? L".RSC" : L".RES");
    }

    /* create the temporary file names */
    szTempFileName = (wchar_t *) MyAlloc(_MAX_PATH * sizeof(wchar_t));

    _wfullpath(szFullPath, resname, _MAX_PATH);
    _wsplitpath(szFullPath, szDrive, szDir, NULL, NULL);

    _wmakepath(szTempFileName, szDrive, szDir, L"RCXXXXXX", NULL);
    _wmktemp (szTempFileName);
    szTempFileName2 = (wchar_t *) MyAlloc(_MAX_PATH * sizeof(wchar_t));
    _wmakepath(szTempFileName2, szDrive, szDir, L"RDXXXXXX", NULL);
    _wmktemp(szTempFileName2);

    ppargv = szRCPP;
    pfRcppAlloc = fRcppAlloc;
    *ppargv++ = L"RCPP";
    *pfRcppAlloc++ = FALSE;
    rcpp_argc = 1;

    /* Open the .RES file (deleting any old versions which exist). */
    if ((fhBin = _wfopen(resname, L"w+b")) == NULL) {
        fatal(1109, resname);
    }

    if (fMacRsrcs)
        MySeek(fhBin, MACDATAOFFSET, 0);

    if (fVerbose) {
        SET_MSG(10102, resname);
        SendWarning(Msg_Text);
    }

    /* Set up for RCPP. This constructs the command line for it. */
    *ppargv++ = _wcsdup(L"-CP");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    _itow(uiCodePage, buf, 10);
    *ppargv++ = buf;
    *pfRcppAlloc++ = FALSE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(L"-f");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(szTempFileName);
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(L"-g");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;
    if (fPreprocessOnly) {
        *ppargv++ = _wcsdup(szPreProcessName);
    } else {
        *ppargv++ = _wcsdup(szTempFileName2);
    }
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(L"-DRC_INVOKED");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    if (fAFXSymbols) {
        *ppargv++ = _wcsdup(L"-DAPSTUDIO_INVOKED");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;
    }

    if (fMacRsrcs) {
        *ppargv++ = _wcsdup(L"-D_MAC");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;
    }

    *ppargv++ = _wcsdup(L"-D_WIN32"); /* to be compatible with C9/VC++ */
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(L"-pc\\:/");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    *ppargv++ = _wcsdup(L"-E");
    *pfRcppAlloc++ = TRUE;
    rcpp_argc++;

    /* Parse the INCLUDE environment variable */

    if (fInclude) {

        *ppargv++ = _wcsdup(L"-I.");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        /* add seperator if any -I switches */
        if (pchInclude != pchIncludeT)
            pchIncludeT[-1] = L';';

        /* read 'em */
        x = _wgetenv(L"INCLUDE");
        if (x == NULL) {
            *pchIncludeT = L'\0';
        } else {
            if (wcslen(pchInclude) + wcslen(x) + 1 >= cchIncludeMax) {
                cchIncludeMax = wcslen(pchInclude) + wcslen(x) + _MAX_PATH*2;
                pchIncludeT = (wchar_t *) MyAlloc(cchIncludeMax * sizeof(wchar_t));
                wcscpy(pchIncludeT, pchInclude);
                MyFree(pchInclude);
                pchInclude = pchIncludeT;
            }

            wcscat(pchInclude, x);
            pchIncludeT = pchInclude + wcslen(pchInclude);
        }
    }

    /* now put includes on the RCPP command line */
    for (x = pchInclude ; *x ; ) {

        r = x;
        while (*x && *x != L';')
            x = CharNextW(x);

        /* mark if semicolon */
        if (*x)
            *x-- = 0;

        if (*r != L'\0' &&       /* empty include path? */
            *r != L'%'           /* check for un-expanded stuff */
            // && wcschr(r, L' ') == NULL  /* check for whitespace */
            ) {
            /* add switch */
            *ppargv++ = _wcsdup(L"-I");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;

            *ppargv++ = _wcsdup(r);
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;
        }

        /* was semicolon, need to fix for searchenv() */
        if (*x) {
            *++x = L';';
            x++;
        }
    }

    /* include defines */
    for (n = 0; n < cDefine; n++) {
        *ppargv++ = _wcsdup(L"-D");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = pszDefine[n];
        *pfRcppAlloc++ = FALSE;
        rcpp_argc++;
    }

    /* include undefine */
    for (n = 0; n < cUnDefine; n++) {
        *ppargv++ = _wcsdup(L"-U");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = pszUnDefine[n];
        *pfRcppAlloc++ = FALSE;
        rcpp_argc++;
    }

    if (rcpp_argc > MAX_CMD) {
        fatal(1102);
    }

    if (fVerbose) {
        /* echo the preprocessor command */
        wprintf(L"RC:");
        for (n = 0 ; n < rcpp_argc ; n++) {
            wprintf(L" %s", szRCPP[n]);
        }
        wprintf(L"\n");
    }

    /* Add .rc with rcincludes into szTempFileName */
    RC_PreProcess(inname);

    /* Run the Preprocessor. */
    if (rcpp_main(rcpp_argc, szRCPP) != 0)
        fatal(1116);

    // All done.  Now free up the argv array.
    for (n = 0 ; n < rcpp_argc ; n++) {
        if (fRcppAlloc[n] == TRUE) {
            free(szRCPP[n]);
        }
    }


    if (fPreprocessOnly) {
        swprintf(szBuf, L"Preprocessed file created in: %s\n", szPreProcessName);
        quit(szBuf);
    }

    if (fVerbose)
        wprintf(L"\n%s", inname);

    if ((fhInput = _wfopen(szTempFileName2, L"rb")) == NULL_FILE)
        fatal(2180);

    if (!InitSymbolInfo())
        fatal(22103);

    LexInit (fhInput);
    uiCodePage = uiDefaultCodePage;
    ReadRF();               /* create .RES from .RC */
    if (!TermSymbolInfo(fhBin))
        fatal(22204);

    if (!fMacRsrcs)
        MyAlign(fhBin); // Pad end of file so that we can concatenate files

    CleanUpFiles();

    HeapDestroy(hHeap);

    return Nerrors;   // return success, not quitting.
}


/*  RCInit
 *      Initializes this run of RC.
 */

HANDLE
RCInit(
    void
    )
{
    Nerrors    = 0;
    uiCodePage = 0;
    nFontsRead = 0;

    szTempFileName = NULL;
    szTempFileName2 = NULL;

    lOffIndex = 0;
    idBase = 128;
    pTypInfo = NULL;

    fVerbose = FALSE;
    fMacRsrcs = FALSE;

    // Clear the filenames
    exename[0] = L'\0';
    resname[0] = L'\0';

    /* create growable local heap of 16MB minimum size */
    return HeapCreate(HEAP_NO_SERIALIZE, 0, 0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  skipblanks() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

wchar_t *
skipblanks(
    wchar_t *pstr,
    int fTerminate
    )
{
    /* search forward for first non-white character and save its address */
    while (*pstr && iswspace(*pstr))
        pstr++;

    if (fTerminate) {
        wchar_t *retval = pstr;

        /* search forward for first white character and zero to extract word */
        while (*pstr && !iswspace(*pstr))
            pstr++;
        *pstr = 0;
        return retval;
    } else {
        return pstr;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  RC_PreProcess() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
RC_PreProcess(
    const wchar_t *szname
    )
{
    PFILE fhout;        /* fhout: is temp file with rcincluded stuff */
    PFILE fhin;
    wchar_t *wch_buf;
    wchar_t *pwch;
    wchar_t *pfilename;
    wchar_t *szT;
    UINT iLine = 0;
    int fBlanks = TRUE;
    INT fFileType;

    wch_buf = (wchar_t *)MyAlloc(sizeof(wchar_t) * READ_MAX);
    szT = (wchar_t *)MyAlloc(sizeof(wchar_t) * MAXSTR);

    /* Open the .RC source file. */
    wcscpy(Filename, szname);
    fhin = _wfopen(szname, L"rb");
    if (!fhin) {
        fatal(1110, szname);
    }

    /* Open the temporary output file. */
    fhout = _wfopen(szTempFileName, L"w+b");
    if (!fhout) {
        fatal(2180);
    }

    /* output the current filename for RCPP messages */
    for (pwch=wch_buf ; *szname ; szname++) {
        *pwch++ = *szname;
        /* Hack to fix bug #8786: makes '\' to "\\" */
        if (*szname == L'\\')
            *pwch++ = L'\\';
    }
    *pwch++ = L'\0';

    /* Output the current filename for RCPP messages */

    MyWrite(fhout, L"#line 1\"", 8 * sizeof(wchar_t));
    MyWrite(fhout, wch_buf, wcslen(wch_buf) * sizeof(wchar_t));
    MyWrite(fhout, L"\"\r\n", 3 * sizeof(wchar_t));

    /* Determine if the input file is Unicode */
    fFileType = DetermineFileType (fhin);

    /* Process each line of the input file. */
    while (fgetl(wch_buf, READ_MAX, fFileType == DFT_FILE_IS_16_BIT, fhin)) {

        /* keep track of the number of lines read */
        Linenumber = iLine++;

        if ((iLine & RC_PREPROCESS_UPDATE) == 0)
            UpdateStatus(1, iLine);

        /* Skip the Byte Order Mark and the leading bytes. */
        pwch = wch_buf;
        while (*pwch && (iswspace(*pwch) || *pwch == 0xFEFF))
            pwch++;

        /* if the line is a rcinclude line... */
        if (strpre(L"rcinclude", pwch)) {
            /* Get the name of the rcincluded file. */
            pfilename = skipblanks(pwch + 9, TRUE);

            MyWrite(fhout, L"#include \"", 10 * sizeof(WCHAR));
            MyWrite(fhout, pfilename, wcslen(pfilename) * sizeof(WCHAR));
            MyWrite(fhout, L"\"\r\n", 3 * sizeof(WCHAR));

        } else if (strpre(L"#pragma", pwch)) {
            WCHAR cSave;

            pfilename = skipblanks(pwch + 7, FALSE);
            if (strpre(L"code_page", pfilename)) {
                pfilename = skipblanks(pfilename + 9, FALSE);
                if (*pfilename == L'(') {
                    ULONG cp = 0;

                    pfilename = skipblanks(pfilename + 1, FALSE);
                    // really should allow hex/octal, but ...
                    if (iswdigit(*pfilename)) {
                        while (iswdigit(*pfilename)) {
                            cp = cp * 10 + (*pfilename++ - L'0');
                        }
                        pfilename = skipblanks(pfilename, FALSE);
                    } else if (strpre(L"default", pfilename)) {
                        cp = uiDefaultCodePage;
                        pfilename = skipblanks(pfilename + 7, FALSE);
                    }

                    if (cp == 0) {
                        error(4212, pfilename);
                    } else if (*pfilename != L')') {
                        error(4211);
                    } else if (cp == CP_WINUNICODE) {
                        if (fWarnInvalidCodePage) {
                            warning(4213);
                        } else {
                            fatal(4213);
                        }
                    } else if (!IsValidCodePage(cp)) {
                        if (fWarnInvalidCodePage) {
                            warning(4214);
                        } else {
                            fatal(4214);
                        }
                    } else {
                        uiCodePage = cp;
                        /* Copy the #pragma line to the temp file. */
                        MyWrite(fhout, pwch, wcslen(pwch) * sizeof(WCHAR));
                        MyWrite(fhout, L"\r\n", 2 * sizeof(WCHAR));
                    }
                } else {
                    error(4210);
                }
            }
        } else if (!*pwch) {
            fBlanks = TRUE;
        } else {
            if (fBlanks) {
                swprintf(szT, L"#line %d\r\n", iLine);
                MyWrite(fhout, szT, wcslen(szT) * sizeof(WCHAR));
                fBlanks = FALSE;
            }
            /* Copy the .RC line to the temp file. */
            MyWrite(fhout, pwch, wcslen(pwch) * sizeof(WCHAR));
            MyWrite(fhout, L"\r\n", 2 * sizeof(WCHAR));
        }
    }

    lCPPTotalLinenumber = iLine;
    Linenumber = 0;

    uiCodePage = uiDefaultCodePage;

    MyFree(wch_buf);
    MyFree(szT);

    fclose(fhout);
    fclose(fhin);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  quit()                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void quit(const wchar_t *wsz)
{
    /* print out the error message */

    if (wsz != NULL) {
        SendWarning(L"\n");
        SendError(wsz);
        SendWarning(L"\n");
    }

    CleanUpFiles();

    /* delete output file */
    if (resname) {
        _wremove(resname);
    }

    if (hHeap) {
        HeapDestroy(hHeap);
    }

    Nerrors++;

    longjmp(jb, Nerrors);
}


extern "C"
BOOL WINAPI Handler(DWORD fdwCtrlType)
{
    if (fdwCtrlType == CTRL_C_EVENT) {
        SendWarning(L"\n");
        SET_MSG(20101);
        SendWarning(Msg_Text);

        CleanUpFiles();

        HeapDestroy(hHeap);

        /* Delete output file */

        if (resname) {
            _wremove(resname);
        }

        return(FALSE);
    }

    return(FALSE);
}


VOID
CleanUpFiles(
    void
    )
{
    TermSymbolInfo(NULL_FILE);

    // Close ALL files.

    if (fhBin != NULL) {
        fclose(fhBin);
    }

    if (fhInput != NULL) {
        fclose(fhInput);
    }

    if (fhCode != NULL) {
        fclose(fhCode);
    }

    p0_terminate();

    // Clean up after font directory temp file

    if (nFontsRead) {
        _wremove(L"rc$x.fdr");
    }

    // Delete the temporary files

    if (szTempFileName) {
        _wremove(szTempFileName);
    }

    if (szTempFileName2) {
        _wremove(szTempFileName2);
    }

    if (Nerrors > 0) {
        _wremove(resname);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\p1sup.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/* trees */
#define LEFT                    1
#define RIGHT                   2

#define MORE_CHECKING   2

int TypeCount;
int TreeCount;

type_entry_t    *Type_table[TYPE_TABLE_SIZE];


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
ptype_t  hash_type(ptype_t);
int     types_equal(ptype_t, ptype_t);


/************************************************************************
**  hash_type : returns a pointer to an already built type, if it
**  exists, or builds one.
************************************************************************/
ptype_t
hash_type(
    type_t *p_type
    )
{
    REG type_entry_t    *p_tmp;
    type_entry_t        **p_start;

    /* Try to get a unique hash value for every type...keep
         * type_equal in mind if changing this
         */
    p_start = &Type_table[(TY_BTYPE(p_type) + TY_DTYPE(p_type) + (INT_PTR) TY_INDIR(p_type)) & (TYPE_TABLE_SIZE - 1)];

    for(p_tmp = *p_start; p_tmp; p_tmp = p_tmp->te_next ) {
        if(types_equal(p_type,&(p_tmp->te_type))) {
            return(&(p_tmp->te_type));
        }
    }
    p_tmp = (type_entry_t *) MyAlloc(sizeof(type_entry_t));
    if (p_tmp == NULL) {
        error(1002);
        return NULL;
    }
    p_tmp->te_next = *p_start;
    *p_start = p_tmp;
    p_tmp->te_type = *p_type;
    TY_TINDEX(&(p_tmp->te_type)) = 0;
    return(&(p_tmp->te_type));
}


/************************************************************************
**  types_equal : are two types equal?
************************************************************************/
int
types_equal(
    REG ptype_t p1,
    REG ptype_t p2
    )
{
    return((TY_BTYPE(p1) == TY_BTYPE(p2))
        &&
        (TY_DTYPE(p1) == TY_DTYPE(p2))
        &&
        TY_INDIR(p1) == TY_INDIR(p2)
        );
}

/************************************************************************
**      build_const - builds and returns a pointer to a constant tree.
**              Input   : constant type.
**                      : ptr to a union containing the value of the constant
**              Output  : Pointer to constant tree.
************************************************************************/
ptree_t
build_const(
    REG token_t type,
    value_t *value
    )
{
    REG ptree_t res;
    ptype_t     p_type;
    btype_t     btype;

    res = (ptree_t) MyAlloc(sizeof(tree_t));

    TR_SHAPE(res) = TTconstant;
    TR_TOKEN(res) = type;
    switch( type ) {
        case L_CINTEGER:
        case L_LONGINT:
        case L_CUNSIGNED:
        case L_LONGUNSIGNED:
            if( type == L_CUNSIGNED || type == L_LONGUNSIGNED ) {
                btype = (btype_t)(BT_UNSIGNED |
                     (btype_t)((type == L_CUNSIGNED) ? BTint : BTlong));
            } else {
                btype = (btype_t)((type == L_CINTEGER) ? BTint : BTlong);
            }

            if((TR_LVALUE(res) = PV_LONG(value)) == 0) {
                TR_SHAPE(res) |= TTzero;
            }
            break;

        case L_CFLOAT:
            btype = BTfloat;
            TR_RCON(res) = PV_RCON(value);
            break;

        case L_CDOUBLE:
            btype = BTdouble;
            TR_RCON(res) = PV_RCON(value);
            break;

        case L_CLDOUBLE:
            btype = BTldouble;
            TR_RCON(res) = PV_RCON(value);
            break;

        default:
            break;
    }

    p_type = (ptype_t) MyAlloc(sizeof(type_t));

    TY_BTYPE(p_type) = (btype_t)(btype | BT_CONST);
    TR_P1TYPE(res) = hash_type(p_type);

    return(res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rc.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include <windows.h>
#include <ntverp.h>
#include <stdio.h>
#include <windef.h>
#include <wchar.h>

typedef FILE    *PFILE;
typedef WCHAR   *PWCHAR;
typedef USHORT  *PUSHORT;
typedef SHORT   *PSHORT;
typedef UINT    *PUINT;
typedef UCHAR   *PUCHAR;

#include <ctype.h>
#include <errno.h>
#include <io.h>
#include <limits.h>
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <mmsystem.h>

#include "charmap.h"
#include "fcntl.h"
#include "getflags.h"
#include "grammar.h"

#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"

#include "newexe.h"
#include "p1types.h"
#include "rcdefs.h"
#include "rcnewres.h"
#include "rcppx.h"
#include "rcunicod.h"
#include "resfile.h"
#include "strings.h"
#include "trees.h"


#define NULL_FILE ((PFILE) NULL)

/* ----- General symbols ----- */
#define VERSION_DUAL            0x202
#define BUFSIZE                 16384
#define EOF                     (-1)

#define TRUE    1
#define FALSE   0

/* The ResType field of NewHeader identifies the cursor/icon type */
#define  ICONTYPE      1
#define  CURSORTYPE    2

/* Identifies the menu item template version number */
#define OLDMENUITEMTEMPLATEVERSIONNUMBER    0
#define OLDMENUITEMTEMPLATEBYTESINHEADER    0

#define MENUITEMTEMPLATEVERSIONNUMBER       1
#define MENUITEMTEMPLATEBYTESINHEADER       sizeof(DWORD)   //dwHelpID in hdr

#define DIFFERENCE      11

/* Predefined resource types */
#define RT_NEWRESOURCE  0x2000
#define RT_ERROR        0x7fff
#define RT_NEWBITMAP    MAKEINTRESOURCE((DWORD)RT_BITMAP+DIFFERENCE)

// These are 'hidden' resources that users never see/use directly.
#define RT_MENUEX       MAKEINTRESOURCE(15)
#define RT_DIALOGEX     MAKEINTRESOURCE(18)

// These are here only temporary here they should in winuser.w
#define RT_ANICURSOR    MAKEINTRESOURCE(21)
#define RT_ANIICON      MAKEINTRESOURCE(22)

#define RT_LAST         MAKEINTRESOURCE(22)

// AFX resource types (Should these be in winuser.h?)
#define RT_DLGINIT      MAKEINTRESOURCE(240)
#define RT_TOOLBAR      MAKEINTRESOURCE(241)

#define GFE_ZEROINIT    0x0001
#define GFE_SHORT       0x0002

#ifdef MFR_POPUP
#if (MFR_POPUP != 0x01) && (MFR_END != 0x80)
#error MFR_POPUP or MFR_END definition(s) invalid
#endif
#else
#define MFR_POPUP       0x01
#define MFR_END         0x80
#endif

/* Single-byte control class IDs */
#define BUTTONCODE      0x80
#define EDITCODE        0x81
#define STATICCODE      0x82
#define LISTBOXCODE     0x83
#define SCROLLBARCODE   0x84
#define COMBOBOXCODE    0x85

/* Translator flag bits */
#define fVIRTKEY                1
#define fNOINVERT               2
#define fSHIFT                  4
#define fCONTROL                8
#define fALT                    16

/* Menu flag bits */
#define OPGRAYED                  0x0001
#define OPINACTIVE                0x0002    // INACTIVE | GRAYED
#define OPBITMAP                  0x0004
#define OPOWNERDRAW               0x0100
#define OPUSECHECKBITMAPS 0x0200
#define OPCHECKED                 0x0008
#define OPPOPUP                   0x0010
#define OPBREAKWBAR               0x0020
#define OPBREAK                   0x0040
#define OPENDMENU                 0x0080
#define OPHELP                    0x4000
#define OPSEPARATOR               0x0800
/*#define OPPOPHELP         0x0004*/


#define wcsdigit(w) (w >= 0x0030 && w <= 0x0039)

/*
** dialog & menu template tokens (these start at 40)
*/

/* buttons */
#define TKRADIOBUTTON       40
#define TKCHECKBOX          41
#define TKPUSHBUTTON        42
#define TKDEFPUSHBUTTON     43
#define TKAUTOCHECK         44
#define TK3STATE            45
#define TKAUTO3             46
#define TKUSERBUTTON        47
#define TKAUTORADIO         48
#define TKOWNERDRAW         50
#define TKGROUPBOX          51
#define TKPUSHBOX           52

/* static/edit */
#define TKBEDIT         57
#define TKHEDIT         58
#define TKIEDIT         59
#define TKEDITTEXT      60
#define TKLTEXT         61
#define TKRTEXT         62
#define TKCTEXT         63
#define TKEDIT          64
#define TKSTATIC        65
#define TKICON          66
#define TKBITMAP        67

/* menu stuff */
#define TKMENU          70
#define TKMENUITEM      71
#define TKSEPARATOR     72
#define TKCHECKED       73
#define TKGRAYED        74
#define TKINACTIVE      75
#define TKBREAKWBAR     76
#define TKBREAK         77
#define TKPOPUP         78
#define TKHELP          79

/* other controls */
#define TKLISTBOX       90
#define TKCOMBOBOX      91
#define TKRCDATA        92
#define TKSCROLLBAR     93
#define TKFONT          94
#define TKBUTTON        95
#define TKMESSAGETABLE  96

/* math expression tokens */
#define TKCLASS         100
#define TKPLUS          101
#define TKMINUS         102
#define TKNOINVERT      103
#define TKNOT           104
#define TKKANJI         105
#define TKSHIFT         106

/* Accel table */
#define TKALT           110
#define TKASCII         111
#define TKVIRTKEY       112
#define TKVALUE         113
#define TKBLOCK         114

/* verison */
#define TKFILEVERSION   120
#define TKPRODUCTVERSION        121
#define TKFILEFLAGSMASK 122
#define TKFILEFLAGS     123
#define TKFILEOS        124
#define TKFILETYPE      125
#define TKFILESUBTYPE   126

/* misc */
#define TKCHARACTERISTICS   130
#define TKLANGUAGE          131
#define TKVERSION           132
#define TKSTYLE             133
#define TKCONTROL           134
#define TKCAPTION           135
#define TKDLGINCLUDE        136
#define TKLSTR              137
#define TKDLGINIT           138
#define TKEXSTYLE           0xf7  /* so as not to conflict with x-coordinate */

/* memory and load flags */
#define TKFIXED         0xfff0
#define TKMOVEABLE      0xfff1
#define TKDISCARD       0xfff2
#define TKLOADONCALL    0xfff3
#define TKPRELOAD       0xfff4
#define TKPURE          0xfff5
#define TKIMPURE        0xfff6



/* special tokens */
#define CHCARRIAGE      L'\r'
#define CHSPACE         L' '
#define CHNEWLINE       L'\n'
//??#define CHTAB            9
#define CHTAB           L'\t'
#define CHDIRECTIVE     L'#'
#define CHQUOTE         L'"'
#define CHEXTENSION     L'.'
#define CHCSOURCE       L'c'
#define CHCHEADER       L'h'
#define CHCOMMENT       L';'

#define DEBUGLEX    1
#define DEBUGPAR    2
#define DEBUGGEN    4

/* End of file character/token */
#define EOFMARK         127

/* Single character keywords that we ignore */
#define LPAREN          1      /* ( */
#define RPAREN          2      /* ) */

/* multiple character keywords */
#define FIRSTKWD        11             /* for adding to table indices */

#define OR          FIRSTKWD+1
#define BEGIN       FIRSTKWD+2
#define END         FIRSTKWD+3
#define COMMA       FIRSTKWD+4
#define TILDE       FIRSTKWD+5
#define AND         FIRSTKWD+6
#define EQUAL       FIRSTKWD+7  // AFX
#define LASTKWD     FIRSTKWD+8  // 19

/* Token types */
#define NUMLIT      LASTKWD+1   // 20
#define STRLIT      LASTKWD+2
#define CHARLIT     LASTKWD+3
#define LSTRLIT     LASTKWD+4   // AFX

/* The following switches, when defined enable various options
**  #define DEBUG enables debugging output.  Use one or more of the
**  values defined above to enable debugging output for different modules */

/* Version number.  VERSION and REVISION are used to set the API number
** in an RCed file.  SIGNON_* are used just to print the signon banner.
** Changing VERSION and REVISION means that applications RCed with this
** version will not run with earlier versions of Windows.  */

//#define VERSION     2
#define REVISION    03
#define SIGNON_VER  4
#define SIGNON_REV  00

/* GetToken() flags */
#define TOKEN_NOEXPRESSION 0x8000

/* Current token structure */
#define MAXSTR (4096+1)     // AFX defines this as 255
#define MAXTOKSTR (256+1)

// New Menu Template Parsing structures/definitions

// New menu template format
//
//      MenuName MENUEX
//      BEGIN
//          [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
//          [POPUP    "text" [, [id] [, [type] [, [state] [, [help id]]]]]
//          BEGIN
//              [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
//              ...
//          END]
//          ...
//      END

typedef struct tagMENU
{
    DWORD   dwID;
    DWORD   dwType;
    DWORD   dwState;
    DWORD   dwHelpID;
    WORD    wResInfo;
    WCHAR   szText[MAXTOKSTR];
} MENU, *PMENU;


typedef enum
{
    PT_WORD = 0,
    PT_DWORD,
    PT_TEXT
}   PARSETYPE;

typedef enum
{
    PTO_WORD = 0x80,
    PTO_DWORD,
    PTO_TEXT
}   OPARSETYPE;

typedef enum
{
    PAR_POPUP = 0,
    PAR_MENUITEM,
    PAR_MENU
}   PARCELTYPE;

#define PT_OPTIONAL 0x80

typedef struct tagPARCEL
{
    WORD    *pwEnd;
    BYTE    *pwParms;
}   PARCEL;

typedef struct tagKEY
{
    PWCHAR  kwd;
    WORD    kwdval;
} KEY, *PKEY;

typedef struct tagSKEY
{
    WCHAR   skwd;
    UINT    skwdval; /* changed from a char */
} SKEY, *PSKEY;

#pragma pack(2)
typedef struct tagSYMINFO
{
    WCHAR   name[MAX_SYMBOL + 1];/* symbol for the resource if available */
    WCHAR   file[_MAX_PATH];
    WORD    line;
    WORD    nID;
} SYMINFO, *PSYMINFO;

typedef struct tagTOKEN
{
    LONG        longval;
    int         row;                    /* line number of current token */
    int         col;                    /* column number of current token */
    BOOL        flongval;               /* is parsed number a long? */
    USHORT      val;
    UCHAR       type;
    UCHAR       realtype;
    SYMINFO     sym;
} TOKEN, *PTOKEN;

typedef struct tagFONTDIR
{
    USHORT              ordinal;
    USHORT              nbyFont;
    struct tagFONTDIR   *next;
} FONTDIR, *PFONTDIR;

typedef struct tagOBJLST
{
    struct tagOBJLST    *next;
    DWORD               nObj;         /* objecty number */
    DWORD               cb;           /* number of bytes used */
    DWORD               cpg;          /* number of pages used */
    DWORD               flags;        /* object memory flags */
} OBJLST, *POBJLST;

typedef struct tagCTRL
{
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    WCHAR   fOrdinalText;
    WCHAR   text[MAXTOKSTR];
    DWORD   id;
    WCHAR   Class[MAXTOKSTR];
    DWORD   dwStyle;
    DWORD   dwExStyle;
    DWORD   dwHelpID;
} CTRL, *PCTRL;

typedef struct tagDLGHDR
{
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    UCHAR   fOrdinalMenu;
    UCHAR   fClassOrdinal;
    DWORD   dwStyle;
    DWORD   dwExStyle;
    WORD    bNumberOfItems;
    WCHAR   Title[MAXTOKSTR];
    WCHAR   MenuName[MAXTOKSTR];
    WCHAR   Class[MAXTOKSTR];
    WCHAR   Font[MAXTOKSTR];
    WORD    pointsize;
    WORD    wWeight;
    BYTE    bItalic;
    BYTE    bCharSet;
    DWORD   dwHelpID;
} DLGHDR, *PDLGHDR;

typedef struct tagMENUHDR
{
    USHORT   menuTemplateVersionNumber;
    USHORT   menuTemplateBytesInHeader;
} MENUHDR, *PMENUHDR;

typedef struct tagMENUITEM
{
    SHORT       id;
    WCHAR       szText[ MAXTOKSTR ];
    WORD        OptFlags;
    WORD        PopFlag;
} MENUITEM, *PMENUITEM;

#define BLOCKSIZE 16
typedef struct tagRCSTRING
{
    struct tagRCSTRING *next;
    DWORD       version;
    DWORD       characteristics;
    USHORT      hibits;
    SHORT       flags;
    WORD        language;
    PWCHAR      rgsz[ BLOCKSIZE ];
    PSYMINFO    rgsym[ BLOCKSIZE ];
} RCSTRING, *PRCSTRING;

typedef struct tagRCACCEL
{
    WORD        flags;
    WCHAR       ascii;
    USHORT      id;
    USHORT      unused;
} RCACCEL, *PRCACCEL;

typedef struct tagRESINFO
{
    DWORD       version;
    DWORD       characteristics;
    LONG        exstyleT;
    LONG        BinOffset;
    LONG        size;
    struct tagRESINFO *next;
    WORD        *poffset;
    PWCHAR      name;
    POBJLST     pObjLst;
    WORD        language;
    SHORT       flags;
    USHORT      nameord;
    USHORT      cLang;
    SYMINFO     sym;
} RESINFO, *PRESINFO;

typedef struct tagTYPEINFO
{
    struct tagTYPEINFO *next;
    PRESINFO    pres;
    PWCHAR      type;
    USHORT      typeord;
    USHORT      cTypeStr;
    USHORT      cNameStr;
    SHORT       nres;
} TYPEINFO, *PTYPEINFO;

#pragma pack()


/* ----- Global variables ----- */
extern  SHORT       ResCount;
extern  PTYPEINFO   pTypInfo;
extern  UINT        uiDefaultCodePage;
extern  UINT        uiCodePage;
extern  SHORT       nFontsRead;
extern  PFONTDIR    pFontList;
extern  PFONTDIR    pFontLast;
extern  TOKEN       token;
extern  int         errorCount;
extern  WCHAR       tokenbuf[MAXSTR + 1]; // +1 is to allow double sz termination
extern  wchar_t     exename[_MAX_PATH];
extern  wchar_t     fullname[_MAX_PATH];
extern  wchar_t     curFile[_MAX_PATH];
extern  WORD        language;
extern  LONG        version;
extern  LONG        characteristics;

extern  PDLGHDR     pLocDlg;
extern  UINT        mnEndFlagLoc;   /* patch location for end of a menu. */
                                    /* we set the high order bit there    */
extern  BOOL        fVerbose;       /* verbose mode (-v) */
extern  BOOL        fAFXSymbols;
extern  BOOL        fMacRsrcs;
extern  BOOL        fAppendNull;
extern  BOOL        fWarnInvalidCodePage;
extern  BOOL        fSkipDuplicateCtlIdWarning;
extern  long        lOffIndex;
extern  WORD        idBase;
extern  wchar_t     *szTempFileName;
extern  wchar_t     *szTempFileName2;
extern  wchar_t     inname[_MAX_PATH];
extern  PFILE       fhBin;
extern  PFILE       fhInput;
extern  PFILE       fhCode;
extern  wchar_t     *pchInclude;
extern  SHORT       k1,k2,k3,k4;
extern  PRESINFO    pResString;

extern  HINSTANCE   hInstance;
extern  HANDLE      hHeap;

extern  int         nBogusFontNames;
extern  WCHAR      *pszBogusFontNames[16];
extern  WCHAR       szSubstituteFontName[MAXTOKSTR];

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcl.c                                                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/

USHORT  FindKwd(PWCHAR);
WCHAR   GetCharFTB();
PWSTR   GetWord(PWSTR);
LONG    GetDNum();
LONG    GetExpression();
PWCHAR  GetGenText();
int     GetKwd(int);
int     GetNameOrd();
VOID    GetNum();
VOID    GetNumFTB();
VOID    GetNumNoExpression();
LONG    GetONum();
LONG    GetOperand();
int     GetOperator(PWCHAR pOperator);
VOID    GetStr();
int     GetToken(int);
LONG    GetXNum();
void    LexError1(int iMsg);
void    LexError2(int iMsg, const wchar_t *str);
int     LexInit(PFILE);
WCHAR   LitChar();
WCHAR   OurGetChar();
VOID    SkipWhitespace();

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcp.c                                                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID        AddBinEntry(PTYPEINFO, PRESINFO, PCHAR , int, LONG);
VOID        AddDefaultTypes();
VOID        AddFontDir();
VOID        AddResToResFile (PTYPEINFO, PRESINFO, PCHAR, int, LONG);
PTYPEINFO   AddResType (PWCHAR, LPWSTR);
VOID        AddStringToBin(USHORT, PWCHAR);
int         DGetMemFlags(PRESINFO);
LONG        GetFileName (VOID);
VOID        ParseError1(int);
VOID        ParseError2(int, PWCHAR); // AFX has 1&2 -- NT just has ParseError
VOID        ParseError3(int);
int         ReadRF(VOID);
WORD        GetLanguage(VOID);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcstring.c                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID        WriteTable (PRESINFO);
int         GetAccelerators (PRESINFO);
PRESINFO    GetTable (PRESINFO);
void *      MyFAlloc(size_t, const void *);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rctg.c                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

DWORD   GetNewBitmap(void);
BOOL    AddFontRes(PRESINFO);
VOID    AppendString(PWCHAR, BOOL);
VOID    CtlAlloc();
PFILE   CtlFile(PFILE);
VOID    CtlFree();
VOID    CtlInit();
VOID    FixMenuPatch();
VOID    GenWarning2(int iMsg, const wchar_t *arg);
VOID    GenWarning4(int iMsg, const wchar_t *arg1, const wchar_t *arg2, const wchar_t *arg3);
VOID    GenError1(int iMsg);
VOID    GenError2(int iMsg, const wchar_t *arg);
WORD    GetBufferLen();
void    SetItemCount(int Index, USHORT wCount);
USHORT  GetItemCount(int Index);
DWORD   GetIcon(LONG);
DWORD   GetAniIconsAniCursors(LONG nbyFile);
DWORD   FileIsAnimated(LONG nbyFile);
VOID    GetNewIconsCursors(PTYPEINFO, PRESINFO, LPWSTR);
WORD    GetRCData(PRESINFO);
void *  GetSpace(WORD cb);
VOID    IncItemCount();
VOID    SwapItemCount(VOID);
void    FixMenuPatch    (WORD);
void    FixOldMenuPatch (WORD);
VOID    MarkAccelFlagsByte();
VOID    MarkMenuPatch();
VOID    PatchAccelEnd();
LONG    ResourceSize();
VOID    SaveResFile(PTYPEINFO, PRESINFO);
void    SetItemExtraCount(WORD, BOOL);
void    SetUpDlg        (PDLGHDR, BOOL);
void    SetUpItem       (PCTRL,   BOOL);
WORD    SetUpMenu       (PMENU);
WORD    SetUpOldMenu    (PMENUITEM);
VOID    WriteAlign();
void    WriteBuffer(const void *, size_t);
int     WriteControl(PFILE, PCHAR, int, LONG);
VOID    WriteString(PWCHAR, BOOL);
VOID    WriteMacString(PWCHAR sz, BOOL fMacCP, BOOL fPascal);
int     ExpandString(BYTE* pb, int cb, BYTE* pbExpand);
WORD    SwapWord(WORD w);
DWORD   SwapLong(DWORD dw);

#define SwappedWord(w)  (fMacRsrcs ? SwapWord(w) : (w))
#define SwappedLong(dw) (fMacRsrcs ? SwapLong(dw) : (dw))

#define WriteByte(b)    (*(BYTE *)  GetSpace(sizeof(BYTE)) = b)
#define WriteLong(dw)   (*(DWORD UNALIGNED *) GetSpace(sizeof(DWORD)) = SwappedLong(dw))
#define WriteWord(w)    (*(WORD UNALIGNED *)  GetSpace(sizeof(WORD)) = SwappedWord(w))


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rctp.c                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

#define GFE_ZEROINIT    0x0001
#define GFE_SHORT       0x0002

void    DGetClassName   (PDLGHDR);
void    DGetFont        (PDLGHDR, BOOL);
void    DGetMenuName    (PDLGHDR);
void    DGetTitle       (PDLGHDR);
BOOL    DLexOptionalArgs(PRESINFO, PDLGHDR, BOOL);
void    DlgIncludeParse (PRESINFO); // new for NT
WORD    DoMenuItem      (int);
void    GetCoords       (PSHORT, PSHORT, PSHORT, PSHORT);
VOID    GetCtlCoords    (PCTRL);
VOID    GetCtlID        (PCTRL, BOOL);
VOID    GetCtlText      (PCTRL);
int     GetDlg          (PRESINFO, PDLGHDR, BOOL);
int     GetDlgItems     (BOOL);
BOOL    GetFullExpression(void *pval, WORD wFlags);
USHORT  GetTokenNoComma (USHORT wFlags);
USHORT  ICGetTok        ();
int     IsmnOption      (UINT, PMENUITEM);
VOID    ParseCtl        (PCTRL, BOOL);
int     ParseMenu       (int, PRESINFO);
int     ParseOldMenu    (int, PRESINFO);
int     VersionBlockStruct(PWCHAR pstrKey, PCHAR pstrValue, USHORT LenValue);
int     VersionBlockVariable(PWCHAR pstrKey);
VOID    VersionGet4Words(PDWORD pdw);
VOID    VersionGetDWord(PDWORD pdw);
int     VersionParse();
USHORT  VersionParseBlock();
int     VersionParseFixed();
USHORT  VersionParseValue(int IndexType); // void arg list in AFX
int     GetToolbar (PRESINFO);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcutil.c                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID    ExtractFileName(const wchar_t *, wchar_t *);
int     iswhite(WCHAR);
BOOL    IsSwitchChar(wchar_t);
UINT    MyAlign(PFILE);
PVOID   MyAlloc(size_t);
size_t  MyCopy(PFILE, PFILE, size_t);
int     MyCopyAll(PFILE, PFILE);
void    MyFree(PVOID);
PWCHAR  MyMakeStr(const wchar_t *);
size_t  MyRead(PFILE, void *, size_t);
LONG    MySeek(PFILE, LONG, int);
size_t  MyWrite(PFILE, const void *, size_t);
VOID    PreBeginParse(PRESINFO, int);
VOID    quit(const wchar_t *);
int     strpre (const wchar_t *, const wchar_t *);
DWORD   wcsatoi(const wchar_t *);
PWCHAR  wcsitow(LONG v, PWCHAR s, DWORD r);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcfutil.c                                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int     fgetl (PWCHAR, int, BOOL, PFILE);


/* ----- AFX Functionality ----- */
#include "rcppx.h"

LONG    MakeFontDir();              // AFX only

void DoMessageCallback(BOOL, const wchar_t *);
void SendWarning(const wchar_t *);
void SendError(const wchar_t *);

extern RC_MESSAGE_CALLBACK lpfnMessageCallbackA;
extern RC_MESSAGE_CALLBACKW lpfnMessageCallbackW;
extern RC_PARSE_CALLBACK lpfnParseCallbackA;
extern RC_PARSE_CALLBACKW lpfnParseCallbackW;
extern BOOL fWindowUnicode;
extern HWND hWndCaller;

void GetSymbolDef(int fReportError, WCHAR curChar);
void GetSymbol(int fReportError, WCHAR curChar);
BOOL InitSymbolInfo();
BOOL TermSymbolInfo(PFILE fhresFile);
void WriteSymbolUse(PSYMINFO sym);
void WriteSymbolDef(PWCHAR name, PWCHAR value, PWCHAR file, WORD line, char flags);
void WriteFileInfo(PRESINFO pRes, PTYPEINFO pType, PWCHAR szFileName);
void WriteResInfo(PRESINFO pRes, PTYPEINFO pType, BOOL bWriteMapEntry);
void WriteResIndex(PRESINFO pRes, PTYPEINFO pType);
void UpdateStatus(unsigned nCode, unsigned long dwStatus);

// offset in a macintosh resource file of the start of the resource data
#define MACDATAOFFSET 256

void GetMacIcon(TYPEINFO *pType, RESINFO *pRes);
void GetMacCursor(TYPEINFO *pType, RESINFO *pRes);

void WriteMacMap(void);
BOOL IsIcon(TYPEINFO* ptype);

#define res_type(ch1,ch2,ch3,ch4) (((unsigned long)(unsigned char)(ch1)<<24)| \
                                ((unsigned long)(unsigned char)(ch2)<<16)| \
                                ((unsigned long)(unsigned char)(ch3)<<8)| \
                                ((unsigned long)(unsigned char)(ch4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcl.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


#define EOLCHAR L';'
#define STRCHAR L'"'
#define CHRCHAR L'\''
#define SGNCHAR L'-'
#define iswhite( c ) ((c != SYMUSESTART) && (c != SYMDEFSTART) &&\
        ((WCHAR)c <= L' ') ? TRUE : FALSE)

static WCHAR  curChar;
static WCHAR  curCharFTB;   /* Cur char From Token Buf */
static PWCHAR CurPtrTB;
static PFILE  inpfh;
static int    curLin, curCol;

extern BOOL bExternParse;


/* Must be sorted */
KEY keyList[] =
{
    { L"ALT",              TKALT },
    { L"ASCII",            TKASCII },
    { L"AUTO3STATE",       TKAUTO3 },
    { L"AUTOCHECKBOX",     TKAUTOCHECK },
    { L"AUTORADIOBUTTON",  TKAUTORADIO },
    { L"BEGIN",            BEGIN },
    { L"BEDIT",            TKBEDIT },
    { L"BITMAP",           TKBITMAP },
    { L"BLOCK",            TKBLOCK },
    { L"BUTTON",           TKBUTTON },
    { L"CAPTION",          TKCAPTION },
    { L"CHARACTERISTICS",  TKCHARACTERISTICS },
    { L"CHECKBOX",         TKCHECKBOX },
    { L"CHECKED",          TKCHECKED },
    { L"CLASS",            TKCLASS },
    { L"COMBOBOX",         TKCOMBOBOX },
    { L"CONTROL",          TKCONTROL },
    { L"CTEXT",            TKCTEXT },
    { L"DEFPUSHBUTTON",    TKDEFPUSHBUTTON },
    { L"DISCARDABLE",      TKDISCARD },
    { L"DLGINCLUDE",       TKDLGINCLUDE },
    { L"DLGINIT",          TKDLGINIT },
    { L"EDIT",             TKEDIT },
    { L"EDITTEXT",         TKEDITTEXT },
    { L"END",              END },
    { L"EXSTYLE",          TKEXSTYLE },
    { L"FILEFLAGS",        TKFILEFLAGS },
    { L"FILEFLAGSMASK",    TKFILEFLAGSMASK },
    { L"FILEOS",           TKFILEOS },
    { L"FILESUBTYPE",      TKFILESUBTYPE },
    { L"FILETYPE",         TKFILETYPE },
    { L"FILEVERSION",      TKFILEVERSION },
    { L"FIXED",            TKFIXED },
    { L"FONT",             TKFONT },
    { L"GRAYED",           TKGRAYED },
    { L"GROUPBOX",         TKGROUPBOX },
    { L"HEDIT",            TKHEDIT },
    { L"HELP",             TKHELP },
    { L"ICON",             TKICON },
    { L"IEDIT",            TKIEDIT },
    { L"IMPURE",           TKIMPURE },
    { L"INACTIVE",         TKINACTIVE },
    { L"LANGUAGE",         TKLANGUAGE },
    { L"LISTBOX",          TKLISTBOX },
    { L"LOADONCALL",       TKLOADONCALL },
    { L"LTEXT",            TKLTEXT },
    { L"MENU",             TKMENU },
    { L"MENUBARBREAK",     TKBREAKWBAR },
    { L"MENUBREAK",        TKBREAK },
    { L"MENUITEM",         TKMENUITEM },
    { L"MESAGETABLE",      TKMESSAGETABLE },
    { L"MOVEABLE",         TKMOVEABLE },
    { L"NOINVERT",         TKNOINVERT },
    { L"NONSHARED",        TKIMPURE },
    { L"NOT",              TKNOT },
    { L"OWNERDRAW",        TKOWNERDRAW },
    { L"POPUP",            TKPOPUP },
    { L"PRELOAD",          TKPRELOAD },
    { L"PRODUCTVERSION",   TKPRODUCTVERSION },
    { L"PURE",             TKPURE },
    { L"PUSHBOX",          TKPUSHBOX },
    { L"PUSHBUTTON",       TKPUSHBUTTON },
    { L"RADIOBUTTON",      TKRADIOBUTTON },
    { L"RCDATA",           TKRCDATA },
    { L"RTEXT",            TKRTEXT },
    { L"SCROLLBAR",        TKSCROLLBAR },
    { L"SEPARATOR",        TKSEPARATOR },
    { L"SHARED",           TKPURE },
    { L"SHIFT",            TKSHIFT },
    { L"STATE3",           TK3STATE },
    { L"STATIC",           TKSTATIC },
    { L"STYLE",            TKSTYLE },
    { L"USERBUTTON",       TKUSERBUTTON },
    { L"VALUE",            TKVALUE },
    { L"VERSION",          TKVERSION },
    { L"VIRTKEY",          TKVIRTKEY },
    { NULL,                0 }
};


SKEY skeyList[] =
{
    { L',', COMMA },
    { L'|', OR },
    { L'(', LPAREN },
    { L')', RPAREN },
    { L'{', BEGIN },
    { L'}', END },
    { L'~', TILDE },
    { L'+', TKPLUS },
    { L'-', TKMINUS },
    { L'&', AND },
    { L'=', EQUAL },
    { EOFMARK, EOFMARK },
    { L'\000', 0 }
};


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexInit() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
LexInit(
    PFILE fh
    )
{
    /* zero errors so far */
    errorCount = 0;
    curLin = 1;
    curCol = 0;
    inpfh = fh;

    /* Read initial character */
    OurGetChar();

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCharFTB() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
WCHAR
GetCharFTB(
    void
    )
{
    return(curCharFTB = *CurPtrTB++);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  OurGetChar() -                                                           */
/*                                                                           */
/*  Read a character, treating semicolon as an end of line comment char      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WCHAR
OurGetChar(
    void
    )
{
    if ((LitChar() != EOFMARK) && (curChar == CHCOMMENT))
        // if comment, HARD LOOP until EOLN
        while ((LitChar() != EOFMARK) && (curChar != CHNEWLINE));

    return(curChar);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FileChar() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WCHAR
FileChar(
    void
    )
{
    static WCHAR rgchLine[MAXSTR];
    static int   ibNext = MAXSTR;
    size_t       cch;
    WCHAR        ch;

    if (ibNext >= MAXSTR) {
        ibNext = 0;

        cch = MyRead(inpfh, rgchLine, MAXSTR * sizeof(WCHAR));

        if (cch < (MAXSTR * sizeof(WCHAR))) {
            fclose(inpfh);

            // NULL terminate the input buffer

            *(rgchLine + (cch / sizeof(WCHAR))) = L'\0';
        }
    }

    ch = rgchLine[ibNext];

    if (ch != L'\0') {
        ibNext++;
    }

    return(ch);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CopyToken() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
CopyToken(
    PTOKEN ptgt_token,
    PTOKEN psrc_token
    )
{
    ptgt_token->longval  = psrc_token->longval;
    ptgt_token->row      = psrc_token->row;
    ptgt_token->col      = psrc_token->col;
    ptgt_token->flongval = psrc_token->flongval;
    ptgt_token->val      = psrc_token->val;
    ptgt_token->type     = psrc_token->type;
    ptgt_token->realtype = psrc_token->realtype;

    wcscpy(ptgt_token->sym.name, psrc_token->sym.name);
    wcscpy(ptgt_token->sym.file, psrc_token->sym.file);
    ptgt_token->sym.line = psrc_token->sym.line;
    ptgt_token->sym.nID  = psrc_token->sym.nID;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LitChar() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* Read a literal character, without interpreting EOL comments */

WCHAR
LitChar(
    void
    )
{
    static int  fNewLine = TRUE;
    int fIgnore = FALSE;
    int fBackSlash = FALSE;
    int fDot;
    PWCHAR      pch;
    WCHAR buf[_MAX_PATH];
    TOKEN token_save;

    for (; ; ) {
        switch (curChar = FileChar()) {
            case 0:
                curChar = EOFMARK;
                goto char_return;

            case 0xFEFF:     // skip Byte Order Mark
                continue;

            case SYMDEFSTART:
            {
                int fNewLineSave = fNewLine;
                GetSymbolDef(TRUE, curChar);
                fNewLine = fNewLineSave;
                break;
            }

            case CHCARRIAGE:
                curChar = CHSPACE;
                if (!fIgnore)
                    goto char_return;
                break;

            case CHNEWLINE:
                fNewLine = TRUE;
                curLin++;
                {
                    static long lTotalLin = 0;
                    if ((lTotalLin++ & RC_COMPILE_UPDATE) == 0)
                        UpdateStatus(2, lTotalLin);
                }

                if (!fIgnore)
                    goto char_return;
                break;

                /* skip whitespace before #line - don't clear fNewLine */
            case CHSPACE:
            case CHTAB:
                if (!fIgnore)
                    goto char_return;
                break;

            case CHDIRECTIVE:
                if (fNewLine) {
                    WCHAR tch;

                    fDot = FALSE;

                    /* also, leave fNewLine set, since we read thru \n */

                    /* read the 'line' part */
                    if ((tch = FileChar()) != L'l') {
                        if (tch == L'p') {
                            if (FileChar() != L'r')
                                goto DirectiveError;
                            if (FileChar() != L'a')
                                goto DirectiveError;
                            if (FileChar() != L'g')
                                goto DirectiveError;
                            if (FileChar() != L'm')
                                goto DirectiveError;
                            if (FileChar() != L'a')
                                goto DirectiveError;

                            /*
                            ** This is very specific, as any #pragma will
                            ** be a code_page pragma written by p0prepro.c.
                            */
                            CopyToken( &token_save, &token );

                            GetToken(FALSE);        /* get #pragma and ignore */
                            GetToken(FALSE);        /* get code_page and ignore */
                            GetToken(TOKEN_NOEXPRESSION);   /* get codepage value only*/
                                            /* don't check return value */
                            uiCodePage = token.val;     /* assume ok */
                            /* read through end of line */
                            while (curChar != CHNEWLINE) {
                                curChar = FileChar();
                            }
                            CopyToken( &token, &token_save );
                            continue;
                        } else {
                            goto DirectiveError;
                        }
                    }
                    if (FileChar() != L'i')
                        goto DirectiveError;
                    if (FileChar() != L'n')
                        goto DirectiveError;
                    if (FileChar() != L'e')
                        goto DirectiveError;

                    /* up to filename, grabbing line number as we go */
                    /* note that curChar first contains '#', because */
                    /* we don't read a new character into curChar */
                    curLin = 0;
                    do {
                        if (curChar >= L'0' && curChar <= L'9') {
                            curLin *= 10;
                            curLin += curChar - L'0';
                        }

                        curChar = FileChar();
                    } while (curChar != CHQUOTE && curChar != CHNEWLINE);

                    /* don't change curFile or fIgnore if this is just a
                     * #line <lineno>
                     */
                    if (curChar == CHNEWLINE)
                        break;

                    /* read the filename.  detect the presence of .c or .h */
                    pch = buf;
                    do {
                        curChar = FileChar();

                        switch (towlower(curChar)) {

                            /* treat backslash like normal char, set flag. */
                            case L'\\':
                                if (fBackSlash) {
                                    fBackSlash = FALSE;
                                } else {
                                    fBackSlash = TRUE;
                                    fIgnore = FALSE;
                                    fDot = FALSE;
                                    *pch++ = curChar;
                                }
                                break;

                                /* line format sanity check: no embedded newlines */
                            case CHNEWLINE:
                            case 0:
DirectiveError:
                                LexError1(2101);

                                /* stop reading filename when we hit a quote */
                            case CHQUOTE:
                                break;

                                /* if we see a ., prepare to find extension */
                            case CHEXTENSION:
                                fBackSlash = FALSE;
                                fDot = TRUE;
                                *pch++ = curChar;
                                break;

                                /* if there's a C or H after a '.', its not RCINCLUDE'd */
                            case CHCSOURCE:
                            case CHCHEADER:
                                fBackSlash = FALSE;
                                fIgnore = fDot;
                                fDot = FALSE;
                                *pch++ = curChar;
                                break;

                                /* any other character in a file means the next character
                                won't be after a dot, and the last char up to now
                                wasn't C or H.
                                */

                            default:
                                fIgnore = FALSE;
                                fDot = FALSE;
                                *pch++ = curChar;
                                break;
                        }
                    } while (curChar != CHQUOTE);
                    *pch = 0;

                    wcsncpy(curFile, buf, _MAX_PATH);

                    /* read through end of line */
                    do {
                        curChar = FileChar();
                    } while (curChar != CHNEWLINE);

                    break;
                }
                /* else, fall through, treat like normal char */

            default:
                fNewLine = FALSE;
                if (!fIgnore)
                    goto char_return;
        }
    }

char_return:
    if (bExternParse)
        *((WCHAR*) GetSpace(sizeof(WCHAR))) = curChar;

    return curChar;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetStr() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GetStr(
    void
    )
{
    PWCHAR  s;
    WCHAR   ch;
    WCHAR   temptok[MAXSTR];
    SHORT   i = 0;
    int     inc;
    UCHAR   Octal_Num;
    UCHAR   HexNum;

    /* token type is string literal */
    token.realtype = STRLIT;

    /*
    **  NB:  FloydR
    **  The use of token.realtype is a hack for RCDATA.
    **
    **  When we converted RC to be Unicode-based, all the
    **  separate "case STRLIT:" code was removed, and the LSTRLIT
    **  cases took over for them.  Alternatively, we could have
    **  left the STRLIT case, but removed the code it accessed
    **  and move the STRLIT case prior/after the LSTRLIT case,
    **  since they were now identical.  They were removed in favor
    **  of smaller/faster code.
    **
    **  However, RCDATA still had a need to discern the difference,
    **  so I added token.realtype, set it to STRLIT in GetStr(),
    **  set it to LSTRLIT in GetLStr() (below), and check it in
    **  GetRCData() in rctg.c.
    **
    */

    token.type = LSTRLIT;
    token.val = 0;
    s = tokenbuf;

    // Read string until " or EOF

    while (LitChar() != EOFMARK)  {
        if (curChar == STRCHAR) {
            if (OurGetChar() != STRCHAR) {
                goto gotstr;
            }
        }

        if (token.val++ == MAXSTR) {
            LexError1(2102);           // "string literal too long"
        }

        *s++ = curChar;
    }

    if (curChar == EOFMARK) {
        LexError1(2103);               // "unexpected end of file in string literal"
    }

gotstr:
    *s++ = 0;
    s = tokenbuf;

    /* process escape characters in the string */

    while (*s != 0)  {
        if (*s == L'\\')  {
            s++;
            if (*s == L'\\')
                temptok[i++] = L'\\';
            else if (*s == L'T' || *s == L't')
                temptok[i++] = L'\011';            /* Tab */
            else if (*s == 0x0a)                   /* continuation slash */
                ; /* ignore and let it go trough the s++ at the end so we skip the 0x0a char*/
            else if (*s == L'A' || *s == L'a')
                temptok[i++] = L'\010';            /* Right Align */
            else if (*s == L'n')
                temptok[i++] = fMacRsrcs ? 13 : 10;   /* linefeed */
            else if (*s == L'r')
                temptok[i++] = fMacRsrcs ? 10 : 13;   /* carriage return */
            else if (*s == L'"')
                temptok[i++] = L'"';               /* quote character */
            else if (*s == L'X' || *s == L'x')  {  /* Hexidecimal digit */
                USHORT wCount;

                HexNum = 0;
                ++s;
                for (wCount = 2 ;
                    wCount && iswxdigit((ch=(WCHAR)towupper(*s)));
                    --wCount)  {
                    if (ch >= L'A')
                        inc = ch - L'A' + 10;
                    else
                        inc = ch - L'0';
                    HexNum = HexNum * 16 + inc;
                    s++;
                }
                MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, (LPCSTR) &HexNum, 1, &temptok[i], 1);
                i++;
                s--;
            } else if (*s >= L'0' && *s <= L'7') {    /* octal character */
                USHORT wCount;

                Octal_Num = 0;
                for (wCount = 3; wCount && *s >= L'0' && *s <= L'7'; --wCount)  {
                    Octal_Num = (Octal_Num * 8 + (*s - L'0'));
                    s++;
                }
                MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, (LPCSTR) &Octal_Num, 1, &temptok[i], 1);
                i++;
                s--;
            }
            else {
                temptok[i++] = L'\\';
                s--;
            }
        } else
            temptok[i++] = *s;

        s++;
    }

    // Zero terminate

    temptok[i] = L'\0';

    memcpy(tokenbuf, temptok, sizeof(WCHAR) * (i + 1));
    token.val = (USHORT) i;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetLStr() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GetLStr(
    void
    )
{
    PWCHAR  s;
    WCHAR   ch;
    WCHAR   temptok[MAXSTR];
    SHORT   i = 0;
    int     inc;
    int     Octal_Num;
    int     HexNum;

    // Token type is string literal

    token.realtype = token.type = LSTRLIT;
    token.val = 0;
    s = tokenbuf;

    // Read string until " or EOF

    while (LitChar() != EOFMARK)  {
        if (curChar == STRCHAR) {
            if (OurGetChar() != STRCHAR) {
                goto gotstr;
            }
        }

        if (token.val++ == MAXSTR) {
            LexError1(2102);           // "string literal too long"
        }

        *s++ = curChar;
    }

    if (curChar == EOFMARK) {
        LexError1(2103);               // "unexpected end of file in string literal"
    }

    if (token.val >= 256) {
        SendError(L"\n");
        SET_MSG(4205, curFile, token.row);
        SendError(Msg_Text);
    }

gotstr:
    *s++ = 0;
    s = tokenbuf;

    /* process escape characters in the string */

    while (*s != 0)  {
        if (*s == L'\\')  {
            s++;
            if (*s == L'\\')
                temptok[i++] = L'\\';
            else if (*s == L'T' || *s == L't')
                temptok[i++] = L'\011';            /* Tab */
            else if (*s == L'A' || *s == L'a')
                temptok[i++] = L'\010';            /* Right Align */
            else if (*s == L'n')
                temptok[i++] = fMacRsrcs ? 13 : 10;   /* linefeed */
            else if (*s == L'r')
                temptok[i++] = fMacRsrcs ? 10 : 13;   /* carriage return */
            else if (*s == L'"')
                temptok[i++] = L'"';               /* quote character */
            else if (*s == L'X' || *s == L'x')  {  /* Hexidecimal digit */
                USHORT wCount;

                HexNum = 0;
                ++s;
                for (wCount = 4 ;
                    wCount && iswxdigit((ch=(WCHAR)towupper(*s)));
                    --wCount)  {
                    if (ch >= L'A')
                        inc = ch - L'A' + 10;
                    else
                        inc = ch - L'0';
                    HexNum = HexNum * 16 + inc;
                    s++;
                }
                temptok[i++] = (WCHAR)HexNum;
                s--;
            }
            else if (*s >= L'0' && *s <= L'7') {    /* octal character */
                USHORT wCount;

                Octal_Num = 0;
                for (wCount = 7; wCount && *s >= L'0' && *s <= L'7'; --wCount)  {
                    Octal_Num = (Octal_Num * 8 + (*s - L'0'));
                    s++;
                }
                temptok[i++] = (WCHAR)Octal_Num;
                s--;
            }

        }
        else
            temptok[i++] = *s;

        s++;
    }

    // Zero terminate

    temptok[i] = L'\0';

    memcpy(tokenbuf, temptok, sizeof(WCHAR) * (i + 1));
    token.val = (USHORT) i;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetToken() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetToken(
    int fReportError
    )
{
    for (; ; )  {
        /* skip whitespace */
        while (iswhite( curChar))
            OurGetChar();

        /* take care of 'random' symbols use */
        if (curChar == SYMUSESTART)
            GetSymbol(fReportError, curChar);
        token.sym.name[0] = L'\0';

        /* remember location of token */
        token.row = curLin;
        token.col = curCol;

        /* determine if token is EOF, number, string, or keyword */
        token.type = EOFMARK;
        switch (curChar) {
            case EOFMARK:
                break;

            case SGNCHAR:
            case L'~':
                if (fReportError & TOKEN_NOEXPRESSION)
                    GetNumNoExpression();
                else
                    GetNum();
                break;

            case STRCHAR:
                GetStr();
                break;

            default:
                if (curChar == L'(' && !(fReportError & TOKEN_NOEXPRESSION))
                    GetNum();
                else if (iswdigit( curChar)) {
                    if (fReportError & TOKEN_NOEXPRESSION)
                        GetNumNoExpression();
                    else
                        GetNum();

                    if (curChar == SYMUSESTART)
                        GetSymbol(fReportError, curChar);
                } else {
                    if (!GetKwd( fReportError))
                        continue;
                    if (token.type == TKLSTR) {
                        GetLStr();
                        break;
                    }
                }
        }

        break;
    }

    return token.type;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetXNum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get hexadecimal number */

LONG
GetXNum(
    void
    )
{
    LONG n = 0;

    while (iswxdigit (GetCharFTB()))
        n = n * 16 + ( ((curCharFTB = (WCHAR)towupper(curCharFTB)) >= L'A') ?
            (WCHAR)(curCharFTB - L'A' + 10) :
            (WCHAR)(curCharFTB - L'0'));
    return (n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetONum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get octal number */

LONG
GetONum(
    void
    )
{
    LONG n = 0;

    while (GetCharFTB() >= L'0' && curCharFTB <= L'7')
        n = n * 8 + (curCharFTB - L'0');
    return (n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetDNum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get decimal number */

LONG
GetDNum(
    void
    )
{
    LONG n = 0;

    while (iswdigit(curCharFTB)) {
        n = n * 10 + (curCharFTB - L'0');
        GetCharFTB();
    }
    return (n);
}


PWSTR
GetWord(
    PWSTR pStr
    )
{
    WCHAR   ch;
    PSKEY   pskey;

    *pStr++ = curCharFTB = curChar;
    while (TRUE) {
        ch = OurGetChar();

        if (ch <= L' ')
            goto FoundBreak;

        switch (ch) {
            case EOFMARK:
            case EOLCHAR:
            case STRCHAR:
            case CHRCHAR:
                goto FoundBreak;

            default:
                for (pskey = skeyList; pskey->skwd; pskey++)
                    if (pskey->skwd == ch)
                        goto FoundBreak;
        }

        *pStr++ = ch;
    }

FoundBreak:
    *pStr = 0;

    return(pStr);
}


/*  GetNumFTB
 *      This function was previously added as a hack to handle converting
 *      radices.  I'm treating this as a (ugly) black box to read a number.
 */

VOID
GetNumFTB(
    void
    )
{
    int signFlag;
    USHORT wNotFlag;
    LONG n;

    /* Small hack to support NOT:  If we have a tilde, skip whitespace
     *  before the number.
     */
    if (curChar == L'~')
        while (iswhite(curChar))
            OurGetChar();

    /* Get the entire number in tokenbuf before computing radix */
    GetWord(tokenbuf);

    /* Skip the first char.  It is already in curCharFTB */
    CurPtrTB = tokenbuf + 1;

    /* mark token type as numeric literal */
    token.type = NUMLIT;

    /* find sign of number */
    if (curCharFTB == SGNCHAR)  {
        signFlag = TRUE;
        GetCharFTB();
    } else {
        signFlag = FALSE;
    }

    /* Check for a NOT (~) */
    if (curCharFTB == L'~') {
        wNotFlag = TRUE;
        GetCharFTB();
    } else {
        wNotFlag = FALSE;
    }

    /* determine radix of number */
    if (curCharFTB == L'0')  {
        GetCharFTB();
        if (curCharFTB == L'x')
            n = GetXNum();
        else if (curCharFTB == L'o')
            n = GetONum();
        else
            n = GetDNum();
    } else {
        n = GetDNum();
    }

    /* find size of number */
    if ((curCharFTB == L'L') || (curCharFTB == L'l'))  {
        token.flongval = TRUE;
        GetCharFTB();
    } else {
        token.flongval = FALSE;
    }

    /* account for sign */
    if (signFlag)
        n = -n;

    /* Account for the NOT */
    if (wNotFlag)
        n = ~n;

    /* Set longval regardless of flongval because Dialog Styles
     *  always have to be be long
     */
    token.longval = n;
    token.val = (USHORT)n;
}


/* ----- Static information needed for parsing ----- */
static int      wLongFlag;
static int      nParenCount;

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetNum() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetNum(
    void
    )
{
    LONG lValue;

    /* Initialize */
    wLongFlag = 0;
    nParenCount = 0;

    /* Return the number */
    lValue = GetExpression();

    /* Make sure we had matched parens */
    if (nParenCount)
        ParseError1(1013); //"Mismatched parentheses"

    /* Return as the proper token */
    if (wLongFlag)
        token.flongval = TRUE;
    token.type = NUMLIT;
    token.longval = lValue;
    token.val = (USHORT)lValue;
}


/*  GetNumNoExpression
 *      Gets a number without doing expression parsing on it.
 */

VOID
GetNumNoExpression(
    VOID
    )
{
    /* Call the single number parser */
    GetNumFTB();
}


/*  GetExpression
 *      Gets an expression, which is defined as any number of
 *      operators and operands inside one set of parens.
 */

LONG
GetExpression(
    VOID
    )
{
    LONG op1;
    LONG op2;
    WCHAR byOperator;
    UINT wFlags;

    /* Get the first operand */
    op1 = GetOperand();

    /* take care of symbol use */
    if (curChar == SYMUSESTART) {
        GetSymbol(TRUE, curChar);
        token.sym.nID = token.val;
    }

    /* Loop until end of expression */
    for (; ; ) {
        /* Get the operator */
        wFlags = GetOperator(&byOperator);

        /* If this is a right paren, dec the count */
        if (byOperator == L')') {
            /* Bring the paren count back down */
            --nParenCount;

            /* Skip the paren and any trailing whitespace */
            OurGetChar();
            SkipWhitespace();
        }

        /* If this isn't an operator, we're done with the expression */
        if (!wFlags) {
            token.sym.nID = (unsigned)op1;
            return op1;
        }
        token.sym.name[0] = L'\0';

        /* Get the second operand */
        op2 = GetOperand();

        /* Compute the value of the expression */
        switch (byOperator) {
            case L'+':
                op1 += op2;
                break;

            case L'-':
                op1 -= op2;
                break;

            case L'&':
                op1 &= op2;
                break;

            case L'|':
                op1 |= op2;
                break;
        }
    }
}


/*  GetOperand
 *      Gets an operand, which may either be a single number or may
 *      be an entire expression.
 */

LONG
GetOperand(
    VOID
    )
{

    /* Check to see if we need to descend a level */
    if (curChar == L'(') {
        /* Bump paren count so we can match them up */
        ++nParenCount;

        /* Skip past the paren char */
        OurGetChar();
        SkipWhitespace();

        /* Return the value of the computed expression for the operand */
        return GetExpression();
    }

    /* If this isn't a number, return an error */
    if (curChar != L'-' && curChar != L'~' && !iswdigit(curChar)) {
        GetKwd(FALSE);
        ParseError2(2237, tokenbuf);
        return 0;
    }

    /* Get the number in the token structure */
    GetNumFTB();

    /* See if we need to force the result long */
    if (token.flongval)
        wLongFlag = TRUE;

    /* Skip trailing whitespace */
    SkipWhitespace();

    /* Return the value */
    return token.longval;
}


/*  GetOperator
 *      Gets the next character and decides if it should be an operator.
 *      If it should, it returns TRUE, which causes the expression
 *      parser to continue.  Otherwise, it returns FALSE which causes
 *      the expression parser to pop up a level.
 */

int
GetOperator(
    PWCHAR pOperator
    )
{
    static WCHAR byOps[] = L"+-|&";
    PWCHAR pOp;

    /* take care of symbol use */
    if (curChar == SYMUSESTART)
        GetSymbol(TRUE, curChar);

    /* See if this character is an operator */
    pOp = wcschr(byOps, curChar);
    *pOperator = curChar;

    /* If we didn't find it, get out */
    if (!pOp)
        return FALSE;

    /* Otherwise, read trailing whitespace */
    OurGetChar();
    SkipWhitespace();

    /* Return the operator */
    return TRUE;
}


/*  SkipWhitespace
 *      Skips past whitespace in the current stream.
 */

VOID
SkipWhitespace(
    VOID
    )
{
    while (iswhite(curChar))
        OurGetChar();
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetKwd() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetKwd(
    int fReportError
    )
{
    PSKEY sk;

    /* see if a special character */

    for (sk = &skeyList[ 0 ]; sk->skwd; sk++) {
        if (curChar == sk->skwd)  {
            token.type = (UCHAR)sk->skwdval;
            token.val = 0;
            OurGetChar();
            return (token.type >= FIRSTKWD);
        }
    }

    /* else read characters up to the next seperator */
    GetWord(tokenbuf);

    // Check for TKLSTR -- new for NT
    if (!tokenbuf[1] && (towupper(tokenbuf[0]) == L'L') && (curChar == STRCHAR)) {
        token.type = TKLSTR;
        return TRUE;
    }

    /* look up keyword in table */
    if ((token.val = FindKwd( tokenbuf)) != (USHORT)-1) {
        token.type = (UCHAR)token.val;
    } else if (fReportError)  {
        LexError2(2104, tokenbuf); //"undefined keyword or key name: %ws"
    }
    else
        token.type = 0;

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FindKwd() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

USHORT
FindKwd(
    PWCHAR str
    )
{
    PKEY   k;
    int    t;

    /* linear search the keyword table for the key */
    for (k = &keyList[0]; k->kwd; k++)
        if (!(t = _wcsicmp( str, k->kwd)))
            return k->kwdval;
        else if (t < 0)
            break;

    /* if not found, return -1 as keyword id */
    return (USHORT)-1;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexError1() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void LexError1(int iMsg)
{
    SET_MSG(iMsg, curFile, curLin);
    SendError(Msg_Text);
    quit(NULL);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexError2() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void LexError2(int iMsg, const wchar_t *str)
{
    SET_MSG(iMsg, curFile, curLin, str);
    SendError(Msg_Text);
    quit(NULL);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetNameOrd() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* For reading in resource names and types.  */
int
GetNameOrd(
    void
    )
{
    PWCHAR pch;
    int fString;

    /* get space delimited string */
    if (!GetGenText())
        return FALSE;

    /* convert to upper case */
    _wcsupr(tokenbuf);

    /* is it a string or number */
    for (pch=tokenbuf,fString=0 ; *pch ; pch++ )
    if (!iswdigit(*pch))
        fString = 1;

    /* determine if ordinal */
    if (tokenbuf[0] == L'0' && tokenbuf[1] == L'X') {
        int         HexNum;
        int         inc;
        USHORT      wCount;
        PWCHAR      s;

        HexNum = 0;
        s = &tokenbuf[2];
        for (wCount = 4 ; wCount && iswxdigit(*s) ; --wCount)  {
            if (*s >= L'A')
                inc = *s - L'A' + 10;
            else
                inc = *s - L'0';
            HexNum = HexNum * 16 + inc;
            s++;
        }
        token.val = (USHORT)HexNum;
    } else if (fString) {
        token.val = 0;
    } else {
       token.val = (USHORT)wcsatoi(tokenbuf);
    }

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetGenText() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* returns a pointer to a string of generic text */

PWCHAR
GetGenText(
    void
    )
{
    PWCHAR  s;

    s = tokenbuf;

    /* skip white space */
    while (iswhite(curChar))
        OurGetChar();

    if (curChar == EOFMARK)  {
        token.type = EOFMARK;
        return NULL;
    }

    /* random symbol */
    if (curChar == SYMUSESTART)
        GetSymbol(TRUE, curChar);
    token.sym.name[0] = L'\0';

    /* read space delimited string */
    *s++ = curChar;
    while (( LitChar() != EOFMARK) && ( !iswhite(curChar)))
        *s++ = curChar;
    *s++ = 0;     /* put a \0 on the end of the string */

    OurGetChar();    /* read in the next character        */
    if (curChar == EOFMARK)
        token.type = EOFMARK;

    if (curChar == SYMUSESTART) {
        GetSymbol(TRUE, curChar);
        token.sym.nID = token.val;
    }

    return (tokenbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcdefs.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#ifndef _RCDEFS_H
#define _RCDEFS_H

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define RC_OK			1
#define RC_FAILED		0
#define RC_CANCELED		-1

#define WM_RC_ERROR	(0x0400+0x0019)
#define WM_RC_STATUS	(0x0400+0x0020)


// How often do I update status information (lineo & RC_xxx == 0)
#define RC_PREPROCESS_UPDATE	63
#define RC_COMPILE_UPDATE	31

extern void UpdateStatus(unsigned nCode, unsigned long dwStatus);

#define MAX_SYMBOL 247 /* from ApStudio */

typedef int (CALLBACK *RC_MESSAGE_CALLBACK)(ULONG, ULONG, LPCSTR);
typedef int (CALLBACK *RC_MESSAGE_CALLBACKW)(ULONG, ULONG, LPCWSTR);

typedef struct tagRESINFO_PARSE
{
	LONG size;
	PWCHAR type;
	USHORT typeord;
	PWCHAR name;
	USHORT nameord;
	WORD flags;
	WORD language;
	DWORD version;
	DWORD characteristics;
} RESINFO_PARSE, *PRESINFO_PARSE;

typedef struct tagCONTEXTINFO_PARSE
{
	HANDLE hHeap;
	HWND hWndCaller;
	RC_MESSAGE_CALLBACK lpfnMsg;
	unsigned line;
	LPCSTR format;
} CONTEXTINFO_PARSE, *PCONTEXTINFO_PARSE;

typedef struct tagCONTEXTINFO_PARSEW
{
	HANDLE hHeap;
	HWND hWndCaller;
	RC_MESSAGE_CALLBACKW lpfnMsg;
	unsigned line;
	LPCWSTR format;
} CONTEXTINFO_PARSEW, *PCONTEXTINFO_PARSEW;

typedef int (CALLBACK *RC_PARSE_CALLBACK)(PRESINFO_PARSE, void **, PCONTEXTINFO_PARSE);
typedef int (CALLBACK *RC_PARSE_CALLBACKW)(PRESINFO_PARSE, void **, PCONTEXTINFO_PARSEW);

typedef int (WINAPI *RCPROC)(HWND, int, RC_MESSAGE_CALLBACK, RC_PARSE_CALLBACK, int, char *[]);
typedef int (WINAPI *RCPROCW)(HWND, int, RC_MESSAGE_CALLBACKW, RC_PARSE_CALLBACK, int, wchar_t *[]);

int WINAPI RC(HWND, int, RC_MESSAGE_CALLBACK, RC_PARSE_CALLBACK, int, char *[]);
int WINAPI RCW(HWND, int, RC_MESSAGE_CALLBACKW, RC_PARSE_CALLBACKW, int, wchar_t *[]);

#define RC_ORDINAL MAKEINTRESOURCE(2)

#ifdef __cplusplus
}
#endif

#endif // _RCDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcfutil.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/* IsTextUnicode has to be here so this will run on Chicago and NT 1.0. */

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028

#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

#define ARGUMENT_PRESENT(a)     (a != NULL)

BOOL
WINAPI
LocalIsTextUnicode(
    CONST LPVOID Buffer,
    int Size,
    LPINT Result
    )

/*++

Routine Description:

    IsTextUnicode performs a series of inexpensive heuristic checks
    on a buffer in order to verify that it contains Unicode data.


    [[ need to fix this section, see at the end ]]

    Found            Return Result

    BOM              TRUE   BOM
    RBOM             FALSE  RBOM
    FFFF             FALSE  Binary
    NULL             FALSE  Binary
    null             TRUE   null bytes
    ASCII_CRLF       FALSE  CRLF
    UNICODE_TAB etc. TRUE   Zero Ext Controls
    UNICODE_TAB_R    FALSE  Reversed Controls
    UNICODE_ZW  etc. TRUE   Unicode specials

    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl
    3/1 or worse   "                                  FALSE  AntiCorrel

Arguments:

    Buffer - pointer to buffer containing text to examine.

    Size - size of buffer in bytes.  At most 256 characters in this will
           be examined.  If the size is less than the size of a unicode
           character, then this function returns FALSE.

    Result - optional pointer to a flag word that contains additional information
             about the reason for the return value.  If specified, this value on
             input is a mask that is used to limit the factors this routine uses
             to make it decision.  On output, this flag word is set to contain
             those flags that were used to make its decision.

Return Value:

    Boolean value that is TRUE if Buffer contains unicode characters.

--*/
{
    CPINFO      cpinfo;
    UNALIGNED WCHAR *lpBuff = (UNALIGNED WCHAR *) Buffer;
    PCHAR lpb = (PCHAR) Buffer;
    ULONG iBOM = 0;
    ULONG iCR = 0;
    ULONG iLF = 0;
    ULONG iTAB = 0;
    ULONG iSPACE = 0;
    ULONG iCJK_SPACE = 0;
    ULONG iFFFF = 0;
    ULONG iPS = 0;
    ULONG iLS = 0;

    ULONG iRBOM = 0;
    ULONG iR_CR = 0;
    ULONG iR_LF = 0;
    ULONG iR_TAB = 0;
    ULONG iR_SPACE = 0;

    ULONG iNull = 0;
    ULONG iUNULL = 0;
    ULONG iCRLF = 0;
    ULONG iTmp;
    ULONG LastLo = 0;
    ULONG LastHi = 0;
    ULONG iHi, iLo;
    ULONG HiDiff = 0;
    ULONG LoDiff = 0;
    ULONG cLeadByte = 0;
    ULONG cWeird = 0;

    ULONG iResult = 0;

    ULONG iMaxTmp = __min(256, Size / sizeof(WCHAR));

    if (Size < 2 ) {
        if (ARGUMENT_PRESENT( Result )) {
            *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
            }

        return FALSE;
        }


    // Check at most 256 wide character, collect various statistics
    for (iTmp = 0; iTmp < iMaxTmp; iTmp++) {
        switch (lpBuff[iTmp]) {
            case BYTE_ORDER_MARK:
                iBOM++;
                break;
            case PARAGRAPH_SEPARATOR:
                iPS++;
                break;
            case LINE_SEPARATOR:
                iLS++;
                break;
            case UNICODE_LF:
                iLF++;
                break;
            case UNICODE_TAB:
                iTAB++;
                break;
            case UNICODE_SPACE:
                iSPACE++;
                break;
            case UNICODE_CJK_SPACE:
                iCJK_SPACE++;
                break;
            case UNICODE_CR:
                iCR++;
                break;

            // The following codes are expected to show up in
            // byte reversed files
            case REVERSE_BYTE_ORDER_MARK:
                iRBOM++;
                break;
            case UNICODE_R_LF:
                iR_LF++;
                break;
            case UNICODE_R_TAB:
                iR_TAB++;
                break;
            case UNICODE_R_CR:
                iR_CR++;
                break;
            case UNICODE_R_SPACE:
                iR_SPACE++;
                break;

            // The following codes are illegal and should never occur
            case UNICODE_FFFF:
                iFFFF++;
                break;
            case UNICODE_NULL:
                iUNULL++;
                break;

            // The following is not currently a Unicode character
            // but is expected to show up accidentally when reading
            // in ASCII files which use CRLF on a little endian machine
            case ASCII_CRLF:
                iCRLF++;
                break;       /* little endian */
        }

        // Collect statistics on the fluctuations of high bytes
        // versus low bytes

        iHi = HIBYTE (lpBuff[iTmp]);
        iLo = LOBYTE (lpBuff[iTmp]);

        // Count cr/lf and lf/cr that cross two words
        if ((iLo == '\r' && LastHi == '\n') ||
            (iLo == '\n' && LastHi == '\r')) {
            cWeird++;
        }

        iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   /* count Null bytes */

        HiDiff += __max( iHi, LastHi ) - __min( LastHi, iHi );
        LoDiff += __max( iLo, LastLo ) - __min( LastLo, iLo );

        LastLo = iLo;
        LastHi = iHi;
    }

    // Count cr/lf and lf/cr that cross two words
    if ((iLo == '\r' && LastHi == '\n') ||
        (iLo == '\n' && LastHi == '\r')) {
        cWeird++;
    }

    if (iHi == '\0')     /* don't count the last null */
        iNull--;
    if (iHi == 26)       /* count ^Z at end as weird */
        cWeird++;

    iMaxTmp = (ULONG)__min(256 * sizeof(WCHAR), Size);
    GetCPInfo(CP_ACP, &cpinfo);
    if (cpinfo.MaxCharSize != 1) {
        for (iTmp = 0; iTmp < iMaxTmp; iTmp++) {
            if (IsDBCSLeadByteEx(uiCodePage, lpb[iTmp])) {
                cLeadByte++;
                iTmp++;         /* should check for trailing-byte range */
            }
        }
    }

    // sift the statistical evidence
    if (LoDiff < 127 && HiDiff == 0) {
        iResult |= IS_TEXT_UNICODE_ASCII16;         /* likely 16-bit ASCII */
    }

    if (HiDiff && LoDiff == 0) {
        iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; /* reverse 16-bit ASCII */
    }

    // Use leadbyte info to weight statistics.
    if (!cpinfo.MaxCharSize != 1 || cLeadByte == 0 ||
        !ARGUMENT_PRESENT(Result) || !(*Result & IS_TEXT_UNICODE_DBCS_LEADBYTE)) {
        iHi = 3;
    } else {
        // A ratio of cLeadByte:cb of 1:2 ==> dbcs
        // Very crude - should have a nice eq.
        iHi = __min(256, Size/sizeof(WCHAR)) / 2;
        if (cLeadByte < (iHi-1) / 3) {
            iHi = 3;
        } else if (cLeadByte < (2 * (iHi-1)) / 3) {
            iHi = 2;
        } else {
            iHi = 1;
        }
        iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
    }

    if (iHi * HiDiff < LoDiff) {
        iResult |= IS_TEXT_UNICODE_STATISTICS;
    }

    if (iHi * LoDiff < HiDiff) {
        iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
    }

    //
    // Any control codes widened to 16 bits? Any Unicode character
    // which contain one byte in the control code range?
    //

    if (iCR + iLF + iTAB + iSPACE + iCJK_SPACE /*+iPS+iLS*/) {
        iResult |= IS_TEXT_UNICODE_CONTROLS;
    }

    if (iR_LF + iR_CR + iR_TAB + iR_SPACE) {
        iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
    }

    //
    // Any characters that are illegal for Unicode?
    //

    if (((iRBOM + iFFFF + iUNULL + iCRLF) != 0) || ((cWeird != 0) && (cWeird >= iMaxTmp/40))) {
        iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
    }

    //
    // Odd buffer length cannot be Unicode
    //

    if (Size & 1) {
        iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
    }

    //
    // Any NULL bytes? (Illegal in ANSI)
    //
    if (iNull) {
        iResult |= IS_TEXT_UNICODE_NULL_BYTES;
    }

    //
    // POSITIVE evidence, BOM or RBOM used as signature
    //

    if (*lpBuff == BYTE_ORDER_MARK) {
        iResult |= IS_TEXT_UNICODE_SIGNATURE;
    } else if (*lpBuff == REVERSE_BYTE_ORDER_MARK) {
        iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
    }

    //
    // limit to desired categories if requested.
    //

    if (ARGUMENT_PRESENT( Result )) {
        iResult &= *Result;
        *Result = iResult;
    }

    //
    // There are four separate conclusions:
    //
    // 1: The file APPEARS to be Unicode     AU
    // 2: The file CANNOT be Unicode         CU
    // 3: The file CANNOT be ANSI            CA
    //
    //
    // This gives the following possible results
    //
    //      CU
    //      +        -
    //
    //      AU       AU
    //      +   -    +   -
    //      --------  --------
    //      CA +| 0   0    2   3
    //      |
    //      -| 1   1    4   5
    //
    //
    // Note that there are only 6 really different cases, not 8.
    //
    // 0 - This must be a binary file
    // 1 - ANSI file
    // 2 - Unicode file (High probability)
    // 3 - Unicode file (more than 50% chance)
    // 5 - No evidence for Unicode (ANSI is default)
    //
    // The whole thing is more complicated if we allow the assumption
    // of reverse polarity input. At this point we have a simplistic
    // model: some of the reverse Unicode evidence is very strong,
    // we ignore most weak evidence except statistics. If this kind of
    // strong evidence is found together with Unicode evidence, it means
    // its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK
    // is found, it precludes normal Unicode. If both byte order marks are
    // found it's not Unicode.
    //

    //
    // Unicode signature : uncontested signature outweighs reverse evidence
    //

    if ((iResult & IS_TEXT_UNICODE_SIGNATURE) &&
        !(iResult & (IS_TEXT_UNICODE_NOT_UNICODE_MASK&(~IS_TEXT_UNICODE_DBCS_LEADBYTE)))
       ) {
        return TRUE;
    }

    //
    // If we have conflicting evidence, it's not Unicode
    //

    if (iResult & IS_TEXT_UNICODE_REVERSE_MASK) {
        return FALSE;
    }

    //
    // Statistical and other results (cases 2 and 3)
    //

    if (!(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK) &&
         ((iResult & IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
          (iResult & IS_TEXT_UNICODE_UNICODE_MASK)
         )
       ) {
        return TRUE;
    }

    return FALSE;
}


/*------------------------------------------------------------------*/
/*                                                                  */
/* fgetl() -                                                        */
/*                                                                  */
/*------------------------------------------------------------------*/

/* fgetl expands tabs and return lines w/o separators */
/* returns line from file (no CRLFs); returns NULL if EOF */

int
fgetl (
    PWCHAR wbuf,
    int len,
    BOOL bUnicode,
    PFILE fh
    )
{
    int c = 0;
    int second;

    *wbuf = 0;

    if (bUnicode) {
        PWCHAR p;

        /* remember NUL at end */
        len--;
        p = wbuf;


        /* fill buffer from the file until EOF or EOLN or no space in buffer */
        while (len) {
            c = fgetc (fh);
            if (c == EOF)
                break;
            second = fgetc (fh);
            c = MAKEWORD (c, second);
            if (c == L'\n')
                break;

            if (c != L'\r') {
                if (c != L'\t') {
                    *p++ = (WCHAR)c;
                    len--;
                } else {

                    /* tabs: expand to spaces */
                    c = (int)(min (8 - ((p - wbuf) & 0x0007), len));
                    len -= c;
                    while (c) {
                        *p++ = L' ';
                        c--;
                    }
                }
            }
        }

        /* null terminate string */
        *p = 0;
    } else {
        PCHAR p;
        PCHAR lpbuf;

        p = lpbuf = (PCHAR) LocalAlloc (LPTR, len);

        if (p) {
            /* remember NUL at end */
            len--;
    
            /* fill buffer from the file until EOF or EOLN or no space in buffer */
            while (len) {
                c = fgetc (fh);
                if (c == EOF || c == '\n')
                    break;
    
                if (c != '\r') {
                    if (c != '\t') {
                        *p++ = (CHAR)c;
                        len--;
                    } else {
    
                        /* tabs: expand to spaces */
                        c = (int)(min (8 - ((p - lpbuf) & 0x0007), len));
                        len -= c;
                        while (c) {
                            *p++ = ' ';
                            c--;
                        }
                    }
                }
            }
    
            /* null terminate string and translate to Unicode */
            *p = 0;
            MultiByteToWideChar (uiCodePage, MB_PRECOMPOSED, lpbuf, -1, wbuf, (int)(p - lpbuf + 1));
    
            LocalFree (lpbuf);
        }
    }

    /* return false if EOF with no chars read */
    return !(c == EOF && !*wbuf);
}

/*----------------------------------------------------------*/
/*                                                          */
/* myfwrite() -                                             */
/*                                                          */
/*  Wrapper for fwrite to ensure data gets to the disk.     */
/*      returns if ok, calls quit if write fails            */
/*----------------------------------------------------------*/

void
myfwrite(
    const void *pv,
    size_t s,
    size_t n,
    PFILE fp
    )
{
    if (fwrite(pv, s, n, fp) == n)
        return;

    fatal(1122);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcdll.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include <setjmp.h>


/* Module handle */
extern "C" const BYTE __ImageBase[];
HINSTANCE hInstance = (HINSTANCE) __ImageBase;

RC_MESSAGE_CALLBACK lpfnMessageCallbackA;
RC_MESSAGE_CALLBACKW lpfnMessageCallbackW;
RC_PARSE_CALLBACK lpfnParseCallbackA;
RC_PARSE_CALLBACKW lpfnParseCallbackW;
BOOL fWindowUnicode;
HWND hWndCaller;


/* Function prototypes */
int __cdecl rc_main(int, wchar_t *[], char *[]);


void DoMessageCallback(BOOL f, const wchar_t *wsz)
{
    static CPINFO cpinfo;

    size_t cwch;
    size_t cchMax;
    char *sz;

    if (lpfnMessageCallbackW != 0) {
        (*lpfnMessageCallbackW)(0, 0, wsz);
    }

    if ((hWndCaller != NULL) && fWindowUnicode) {
        if (SendMessageW(hWndCaller, WM_RC_ERROR, f, (LPARAM) wsz) != 0) {
            quit(NULL);
        }
    }

    if ((lpfnMessageCallbackA == 0) && ((hWndCaller == NULL) || fWindowUnicode)) {
        return;
    }

    if (cpinfo.MaxCharSize == 0) {
        if (!GetCPInfo(CP_ACP, &cpinfo)) {
            return;
        }
    }

    cwch = wcslen(wsz) + 1;
    cchMax = (cwch - 1) * cpinfo.MaxCharSize + 1;
    sz = (char *) MyAlloc(cchMax);

    if (WideCharToMultiByte(CP_ACP, 0, wsz, (int) cwch, sz, (int) cchMax, NULL, NULL) == 0) {
        // Conversion failed

        return;
    }

    if (lpfnMessageCallbackA != 0) {
        (*lpfnMessageCallbackA)(0, 0, sz);
    }

    if ((hWndCaller != NULL) && !fWindowUnicode) {
        if (SendMessageA(hWndCaller, WM_RC_ERROR, f, (LPARAM) sz) != 0) {
            quit(NULL);
        }
    }

    MyFree(sz);
}


extern "C"
int CALLBACK
RC(
    HWND hWnd,
    int fStatus,
    RC_MESSAGE_CALLBACK lpfnMsg,
    RC_PARSE_CALLBACK lpfnParse,
    int argc,
    char *argv[]
    )
{
    fWindowUnicode = FALSE;
    hWndCaller = hWnd;

    lpfnMessageCallbackA = lpfnMsg;
    lpfnParseCallbackA = lpfnParse;

    return(rc_main(argc, NULL, argv));
}


extern "C"
int CALLBACK
RCW(
    HWND hWnd,
    int fStatus,
    RC_MESSAGE_CALLBACKW lpfnMsg,
    RC_PARSE_CALLBACKW lpfnParse,
    int argc,
    wchar_t *argv[]
    )
{
    fWindowUnicode = TRUE;
    hWndCaller = hWnd;

    lpfnMessageCallbackW = lpfnMsg;
    lpfnParseCallbackW = lpfnParse;

    return(rc_main(argc, argv, NULL));
}


void SendWarning(const wchar_t *wsz)
{
    DoMessageCallback(FALSE, wsz);
}


void SendError(const wchar_t *wsz)
{
    static int cErrThisLine = 0;
    static int LastRow = 0;

    DoMessageCallback(FALSE, wsz);

    if (token.row == LastRow) {
        if ((++cErrThisLine > 4) && wcscmp(wsz, L"\n")) {
            quit(NULL);
        }
    } else {
        LastRow = token.row;
        cErrThisLine = 0;
    }
}


void UpdateStatus(unsigned nCode, unsigned long dwStatus)
{
    if (hWndCaller) {
        if (SendMessageA(hWndCaller, WM_RC_STATUS, nCode, dwStatus) != 0) {
            quit(NULL);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcmenu.c ===
/****************************************************************************/
/*                                                                          */
/*  RCTP.C -                                                                */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Resource Parser                       */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"

extern KEY  keyList[];
extern SKEY skeyList[];
extern BOOL CheckStr(PWCHAR pStr);

WORD    wEndPOPUP[]     = { 1, BEGIN };
WORD    wEndMENUITEM[]  = { 3, TKPOPUP, TKMENUITEM, END };
WORD    wEndMENU[]      = { 0 };

BYTE    bParmsPOPUP[]   = { 5, PT_TEXT, PTO_DWORD, PTO_DWORD, PTO_DWORD, PTO_DWORD };
BYTE    bParmsMENUITEM[]= { 4, PT_TEXT, PTO_DWORD, PTO_DWORD, PTO_DWORD };
BYTE    bParmsMENU[]    = { 1, PTO_DWORD };

PARCEL  parcels[]= {
    { wEndPOPUP,       bParmsPOPUP    },    // PAR_POPUP
    { wEndMENUITEM,    bParmsMENUITEM },    // PAR_MENUITEM
    { wEndMENU,        bParmsMENU     }     // PAR_MENU
};

typedef enum {
    ERR_MOREARGS = 2235,
    ERR_NEEDARG,
    ERR_NEEDNUM,
    ERR_NEEDSTR,
    ERR_NEEDBEGIN,
    ERR_NEEDEND,
    ERR_NEEDPAREN,
    ERR_BADEXP,
    ERR_BADSTREXP,
    ERR_NOSEP,
    ERR_BADSUBMENU,
    ERR_NOEMPTYMENU
} ERRCODE;


BOOL
EndParcel(
    WORD *pwEnd
    )
{
    WORD i;

    if (!*pwEnd)
        return(TRUE);

    for (i = *pwEnd; i > 0; i--)
        if (token.type == pwEnd[i])
            return(TRUE);

    return(FALSE);
}

#define PARM_SET    0x0001
#define PARM_LAST   0x0002

BOOL MyGetExpression(DWORD *pdwExp, BOOL fRecursed);

BOOL
GetOp(
    DWORD *pdwExp,
    WORD opcode
    )
{
    DWORD dwOp2 = 0;
    BOOL    fNest = FALSE;

    switch (token.type) {
        case LPAREN:
            GetToken(TOKEN_NOEXPRESSION);
            if (!MyGetExpression(&dwOp2, TRUE))
                return(FALSE);
            fNest = TRUE;
            break;

        case TKMINUS:                   // -flag (unary minus)
            GetToken(TOKEN_NOEXPRESSION);
            dwOp2 = -token.longval;
            break;

        case TKPLUS:
            GetToken(TOKEN_NOEXPRESSION);
        case NUMLIT:
            dwOp2 = token.longval;
            break;

        case TKNOT:                     // (x | NOT flag) == (x & ~flag)
            opcode = AND;
        case TILDE:                     // ~flag
            GetToken(TOKEN_NOEXPRESSION);
            dwOp2 = ~token.longval;
            break;

        default:
            return(FALSE);
    }

    if (!fNest) {
        if (token.type != NUMLIT)
            ParseError2(ERR_NEEDNUM, tokenbuf);

        GetToken(TOKEN_NOEXPRESSION);
    }

    switch (opcode) {
        case TKPLUS:
            *pdwExp += dwOp2;
            break;

        case TKMINUS:
            *pdwExp -= dwOp2;
            break;

        case OR:
            *pdwExp |= dwOp2;
            break;

        case AND:
            *pdwExp &= dwOp2;
            break;
    }

    return(TRUE);
}

BOOL
GetFullExpression(
    void *pval,
    WORD wFlags
    )
{
    BOOL fRes;
    DWORD   dwExp = 0;

    if (!(wFlags & GFE_ZEROINIT))
        dwExp = (wFlags & GFE_SHORT) ? (DWORD) *((WORD *) pval) : *((DWORD UNALIGNED *) pval);

    fRes = MyGetExpression(&dwExp, FALSE);

    if (wFlags & GFE_SHORT)
        *((WORD *) pval) = (WORD) dwExp;
    else
        *((DWORD UNALIGNED *) pval) = dwExp;

    return(fRes);
}

BOOL
MyGetExpression(
    DWORD *pdwExp,
    BOOL fRecursed
    )
{
    WORD    opcode;

    if (!GetOp(pdwExp, OR))
        return(FALSE);

    while (TRUE) {    // break out as appropriate
        if (token.type == NUMLIT) {
            if (token.longval < 0) {
                *pdwExp += token.longval;
                GetToken(TOKEN_NOEXPRESSION);
                continue;
            }
            //
            // This is a hack to fix the problem of a space after a minus sign.
            //    - for example 10 - 5
            //    - if this is a problem, please speak to Jeff Bogden
            //
            if (token.longval == 0 && tokenbuf[0] == L'-' && tokenbuf[1] == L'\0')
                token.type = TKMINUS;
        }

        switch (token.type) {
            case TKPLUS:
            case TKMINUS:
            case OR:
            case AND:
            case TKNOT:
                opcode = token.type;
                GetToken(TOKEN_NOEXPRESSION);

                if (!GetOp(pdwExp, opcode))
                    ParseError2(ERR_NEEDNUM, tokenbuf);
                break;

            case RPAREN:
                if (fRecursed) {
                    GetToken(TOKEN_NOEXPRESSION);
                    return(TRUE);
                } else {
                    goto parenMismatch;
                }

            default:
                if (fRecursed)
parenMismatch:
                ParseError2(ERR_NEEDPAREN, tokenbuf);
                return(TRUE);
        }
    }
}

WORD
MyGetNum(
    WORD *pwEnd,
    BOOL fDouble,
    DWORD *pdwExp
    )
{
    WORD    wRes;
    DWORD   dwExp = 0;

    wRes = MyGetExpression(&dwExp, FALSE) ? PARM_SET : 0;

    if (EndParcel(pwEnd))
        wRes |= PARM_LAST;
    else if (!(token.type == COMMA))
        ParseError2(ERR_BADEXP, tokenbuf);

    if (fDouble)
        *pdwExp = dwExp;
    else
        *((WORD *) pdwExp) = (WORD) dwExp;

    return(wRes);
}

WORD
GetText(
    PWORD pwEnd,
    PWCHAR szDst
    )
{
    BOOL    fEnd;
    BOOL    fPlus = FALSE;
    WORD    wRes = 0;

    while (!(fEnd = EndParcel(pwEnd)) && (token.type != COMMA)) {
        if (CheckStr(szDst)) {
            szDst += wcslen(szDst);

            if (fPlus)
                fPlus = FALSE;
            else if (wRes)
                goto ErrBadStr;

            wRes = PARM_SET;
        } else if ((token.type == TKPLUS) && !fPlus && wRes) {
            fPlus = TRUE;
        } else {
ErrBadStr:
            ParseError2(ERR_BADSTREXP, tokenbuf);
        }

        GetToken(TOKEN_NOEXPRESSION);
    }

    if (fPlus)
        ParseError2(ERR_NEEDSTR, tokenbuf);

    if (fEnd)
        wRes |= PARM_LAST;

    return(wRes);
}

void __cdecl
GetParcel(
    PARCELTYPE parType,
    ...
    )
{
    PARCEL  par = parcels[parType];
    WORD    wParm;
    WORD    wRes;
    va_list ap;
    void    *pParm;
    BOOL    fOptional;
    BOOL    fWriteSymbol = FALSE;

    va_start(ap, parType);

    for (wParm = 1; wParm <= *par.pwParms; wParm++) {
        pParm = va_arg(ap, void *);
        fOptional = par.pwParms[wParm] & PT_OPTIONAL;
        switch (par.pwParms[wParm] & ~PT_OPTIONAL) {
            case PT_TEXT:
                wRes = GetText(par.pwEnd, (PWCHAR) pParm);
                fWriteSymbol = TRUE;
                break;

            case PT_WORD:
                wRes = MyGetNum(par.pwEnd, FALSE, (DWORD *) pParm);
                break;

            case PT_DWORD:
                wRes = MyGetNum(par.pwEnd, TRUE, (DWORD *) pParm);
                break;
        }

        if (!(wRes & PARM_SET) && !fOptional)
            goto ErrMissingParm;

        if (wRes & PARM_LAST) {
            while (wParm < *par.pwParms) {
                if (!(par.pwParms[++wParm] & PT_OPTIONAL))
ErrMissingParm:
                    ParseError2(ERR_NEEDARG, tokenbuf);
            }
            goto Exit;
        }

        GetToken(TRUE);

        WriteSymbolUse(&token.sym);
    }

    if (!EndParcel(par.pwEnd))
        ParseError2(ERR_MOREARGS, tokenbuf);

Exit:
    va_end(ap);
}

/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      DoMenuItem() -                                                                                                                   */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

WORD
DoMenuItem(
    int fPopup
    )
{
    MENU    mn;

    mn.wResInfo = fPopup ? MFR_POPUP : 0;
    mn.dwType = 0;
    mn.dwState = 0;
    mn.dwID = 0;
    mn.dwHelpID = 0;
    mn.szText[0] = 0;

    GetToken(TOKEN_NOEXPRESSION); //TRUE);

    if ((token.type == NUMLIT) && (token.val == MFT_SEPARATOR)) {
        if (fPopup)
            ParseError2(ERR_NOSEP, tokenbuf);

        mn.dwType = MFT_SEPARATOR;
        mn.dwState = 0;
        mn.dwID = 0;
        GetToken(TOKEN_NOEXPRESSION); //TRUE);
        if (!EndParcel(parcels[PAR_MENUITEM].pwEnd))
            ParseError2(ERR_MOREARGS, tokenbuf);
    } else if (fPopup) {
        GetParcel(PAR_POPUP, mn.szText, &mn.dwID, &mn.dwType, &mn.dwState, &mn.dwHelpID);
    } else {
        GetParcel(PAR_MENUITEM, mn.szText, &mn.dwID, &mn.dwType, &mn.dwState);
    }

    // set it up in the buffer (?)
    return(SetUpMenu(&mn));
}

/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      ParseMenu() -                                                                                                                    */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

int
ParseMenu(
    int fRecursing,
    PRESINFO pRes           /* TRUE iff popup */
    )
{
    int     bItemRead = FALSE;
    WORD    wEndFlagLoc = 0;
    DWORD   dwHelpID = 0;

    if (!fRecursing) {
        // Write Help ID to header
        GetParcel(PAR_MENU, &dwHelpID);
        WriteLong(dwHelpID);
        PreBeginParse(pRes, 2121);
    } else {
        /* make sure its really a menu */
        if (token.type != BEGIN)
            ParseError1(2121); //"BEGIN expected in menu"
        GetToken(TRUE); // vs. TOKEN_NOEXPRESSION ??
    }

    /* get the individual menu items */
    while (token.type != END) {
        switch (token.type) {
            case TKMENUITEM:
                bItemRead = TRUE;
                wEndFlagLoc = DoMenuItem(FALSE);
                break;

            case TKPOPUP:
                bItemRead = TRUE;
                wEndFlagLoc = DoMenuItem(TRUE);
                ParseMenu(TRUE, pRes);
                break;

            default:
                ParseError2(ERR_BADSUBMENU, tokenbuf);
                break;
        }
    }

    /* did we die on an END? */
    if (token.type != END)
        ParseError2(ERR_NEEDEND, tokenbuf);

    /* make sure we have a menu item */
    if (!bItemRead)
        ParseError2(ERR_NOEMPTYMENU, tokenbuf);

    /* Get next token if this was NOT the last END*/
    if (fRecursing)
        GetToken(TOKEN_NOEXPRESSION);

    /* mark the last item in the menu */
    FixMenuPatch(wEndFlagLoc);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcnewres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */

#define  NAMELEN    14

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *PNEWHEADER;

typedef struct tagDESCRIPTOR
{
    BYTE    Width;      // 16, 32, 64
    BYTE    Height;     // 16, 32, 64
    BYTE    ColorCount; //  2,  8, 16
    BYTE    reserved;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   BytesInRes;
    DWORD   OffsetToBits;
} DESCRIPTOR;

typedef struct tagICONRESDIR
{
    BYTE    Width;      // 16, 32, 64
    BYTE    Height;     // 16, 32, 64
    BYTE    ColorCount; //  2,  8, 16
    BYTE    reserved;
} ICONRESDIR;

typedef struct tagCURSORDIR
{
    WORD    Width;
    WORD    Height;
} CURSORDIR;

typedef struct tagRESDIR
{
    union
    {
        ICONRESDIR   Icon;
        CURSORDIR    Cursor;
    } ResInfo;
    WORD    Planes;
    WORD    BitCount;
    DWORD   BytesInRes;
} RESDIR;

typedef struct tagLOCALHEADER
{
    WORD    xHotSpot;
    WORD    yHotSpot;
} LOCALHEADER;

typedef struct tagBITMAPHEADER
{
    DWORD   biSize;
    DWORD   biWidth;
    DWORD   biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biStyle;
    DWORD   biSizeImage;
    DWORD   biXPelsPerMeter;
    DWORD   biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
}  BITMAPHEADER;


#define BFOFFBITS(pbfh) MAKELONG(*(LPWORD)((LPWORD)pbfh+5), \
                                 *(LPWORD)((LPWORD)pbfh+6))

#define TOCORE(bi) (*(BITMAPCOREHEADER *)&(bi))

/****************************************************\
*                                                    *
*      Imported from asdf.h in windows\inc           *
*                                                    *
\****************************************************/

// RIFF chunk header.

typedef struct _RTAG {
    FOURCC ckID;
    DWORD ckSize;
} RTAG, *PRTAG;


// Valid TAG types.

// 'ANI ' - simple ANImation file

#define FOURCC_ACON  mmioFOURCC('A', 'C', 'O', 'N')


// 'anih' - ANImation Header
// Contains an ANIHEADER structure.

#define FOURCC_anih mmioFOURCC('a', 'n', 'i', 'h')


// 'rate' - RATE table (array of jiffies)
// Contains an array of JIFs.  Each JIF specifies how long the corresponding
// animation frame is to be displayed before advancing to the next frame.
// If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
// otherwise the count == anih.cFrames.

#define FOURCC_rate mmioFOURCC('r', 'a', 't', 'e')


// 'seq ' - SEQuence table (array of frame index values)
// Countains an array of DWORD frame indices.  anih.cSteps specifies how
// many.

#define FOURCC_seq  mmioFOURCC('s', 'e', 'q', ' ')


// 'fram' - list type for the icon list that follows

#define FOURCC_fram mmioFOURCC('f', 'r', 'a', 'm')

// 'icon' - Windows ICON format image (replaces MPTR)

#define FOURCC_icon mmioFOURCC('i', 'c', 'o', 'n')


// Standard tags (but for some reason not defined in MMSYSTEM.H)

#define FOURCC_INFO mmioFOURCC('I', 'N', 'F', 'O')      // INFO list
#define FOURCC_IART mmioFOURCC('I', 'A', 'R', 'T')      // Artist
#define FOURCC_INAM mmioFOURCC('I', 'N', 'A', 'M')      // Name/Title

#if 0 //in winuser.w
typedef DWORD JIF;  // in winuser.w

typedef struct _ANIHEADER {     // anih
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

// If the AF_ICON flag is specified the fields cx, cy, cBitCount, and
// cPlanes are all unused.  Each frame will be of type ICON and will
// contain its own dimensional information.

#define AF_ICON     0x0001L     // Windows format icon/cursor animation

#define AF_SEQUENCE 0x0002L     // Animation is sequenced
#endif

/**************************\
*                          *
*  End Import from asdf.h  *
*                          *
\**************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcpp.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/************************************************************************/
/* Global Varialbes                                                     */
/************************************************************************/
WCHAR   *Unknown = NULL;                /* holder for bad flags */
int     Argc;
WCHAR   **Argv;

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
WCHAR   *nextword(void);
void    to_human(void);


const struct subtab Ztab[] = {
    L'a',        UNFLAG, &Extension,
    L'e',        FLAG,   &Extension,
    L'E',        FLAG,   &Ehxtension,
    L'i',        FLAG,   &Symbolic_debug,
    L'g',        FLAG,   &Out_funcdef,
    L'p',        FLAG,   &Cmd_pack_size,
    L'I',        FLAG,   &Inteltypes,
    L'c',        FLAG,   &ZcFlag,
    0,           0,              0,
};

struct cmdtab cmdtab[] = {
    L"-pc#",             (char *)&Path_chars,            1,      STRING,
    L"-pf",              (char *)&NoPasFor,              1,      FLAG,
    L"-C",               (char *)&Cflag,                 1,      FLAG,
    L"-CP#",             (char *)&uiCodePage,            1,      NUMBER,
    L"-D#",              (char *)&Defs,                  1,      PSHSTR,
    L"-U#",              (char *)&UnDefs,                1,      PSHSTR,
    L"-E",               (char *)&Eflag,                 1,      FLAG,
    L"-I#",              (char *)&Includes,              1,      PSHSTR,
    L"-P",               (char *)&Pflag,                 1,      FLAG,
    L"-f",               (char *)&Input_file,            1,      STRING,
    L"-g",               (char *)&Output_file,           1,      STRING,
    L"-J",               (char *)&Jflag,                 1,      FLAG,
    L"-Zp",              (char *)&Cmd_pack_size,         1,      FLAG,
    L"-Zp#",             (char *)&Cmd_pack_size,         1,      NUMBER,
    L"-Z*",              (char *)Ztab,                   1,      SUBSTR,
    L"-Oi",              (char *)&Cmd_intrinsic,         1,      FLAG,
    L"-Ol",              (char *)&Cmd_loop_opt,          1,      FLAG,
    L"-db#",             (char *)&Debug,                 1,      STRING,
    L"-il#",             (char *)&Basename,              1,      STRING,
    L"-xc",              (char *)&Cross_compile,         1,      FLAG,
    L"-H",               (char *)&HugeModel,             1,      FLAG,
    L"-V#",              (char *)&Version,               1,      STRING,
    L"-Gs",              (char *)&Cmd_stack_check,       1,      UNFLAG,
    L"-Gc",              (char *)&Plm,                   1,      FLAG,
    L"-char#",           (char *)&Char_align,            1,      NUMBER,
    L"-A#",              (char *)&A_string,              1,      STRING,
    L"-Q#",              (char *)&Q_string,              1,      STRING,
    L"-Fs",              (char *)&Srclist,               1,      FLAG,
    L"-R",               (char *)&Rflag,                 1,      FLAG,
    L"*",                (char *)&Unknown,               0,      STRING,
    0,                   0,                              0,      0,
};

/************************************************************************/
/* nextword -                                                           */
/************************************************************************/
WCHAR   *nextword(void)
{
    return((--Argc > 0) ? (*++Argv) : 0);
}

/************************************************************************/
/* main -                                                               */
/************************************************************************/
int __cdecl
rcpp_main(
    int argc,
    wchar_t *argv[]
    )
{
    Argc = argc;
    Argv = argv;

    if(Argv == NULL) {
        fatal(1002);    /* no memory */
    }

    while(crack_cmd(cmdtab, nextword(), nextword, 0)) ;

    if(Unknown) {
        fatal(1007, Unknown, L"c1");    /* unknown flag */
    }

    if( ! Input_file) {
        fatal(1008);            /* no input file specified */
    }

    if( ! Output_file) {
        fatal(1010);            /* no output file specified */
    }

    Prep = TRUE;
    if( !Eflag && !Pflag ) {
        Eflag = TRUE;
    }

    wcsncpy(Filename,Input_file,128);

    p0_init(Input_file, Output_file, &Defs, &UnDefs);
    to_human();

    if( Prep_ifstack >= 0 ) {
        fatal(1022);            /* expected #endif */
    }

    p0_terminate();
    return Nerrors;
}


/************************************************************************/
/* to_human : outputs preprocessed text in human readable form.         */
/************************************************************************/
void
to_human(
    void
    )
{
    const wchar_t *value;

    for(;;) {
        switch(yylex()) {
            case 0:
                return;

            case L_NOTOKEN:
                break;

            default:
                if (Basic_token == 0) {
                    fatal(1011);
                }

                value = Tokstrings[Basic_token - L_NOTOKEN].k_text;
                myfwrite(value, wcslen(value) * sizeof(WCHAR), 1, OUTPUTFILE);
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcppdecl.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

void error(int, ...);
void fatal(int, ...);
void warning(int, ...);

/************************************************************************/
/* GETMSG.C                                                             */
/************************************************************************/
void __cdecl SET_MSG(int, ...);
void __cdecl SET_MSGV(int, va_list);

/************************************************************************/
/* GETFLAGS.C                                                           */
/************************************************************************/
struct cmdtab;
int crack_cmd(struct cmdtab *, WCHAR *, WCHAR *(*)(void), int);

/************************************************************************/
/* LTOA.C                                                               */
/************************************************************************/
int zltoa       (long, WCHAR *, int);

/************************************************************************/
/* P0EXPR.C                                                             */
/************************************************************************/
long do_constexpr       (void);

/************************************************************************/
/* P0GETTOK.C                                                           */
/************************************************************************/
token_t         yylex(void);
int             lex_getid (WCHAR);

/************************************************************************/
/* P0IO.C                                                               */
/************************************************************************/
void            emit_line (void);
WCHAR           fpop (void);
int             io_eob (void);
int             io_restart (unsigned long int);
int             newinput(const wchar_t *, int);
int             nested_include (void);
void            p0_init (PWCHAR, PWCHAR, LIST *, LIST *);
void            p0_terminate (void);

/************************************************************************/
/* P0KEYS.C                                                             */
/************************************************************************/
token_t         is_pkeyword (WCHAR *);

/************************************************************************/
/* P0MACROS.C                                                           */
/************************************************************************/
int             can_get_non_white (void);
int             can_expand (pdefn_t);
void            define (void);
void            definstall (WCHAR *, int, int);
pdefn_t         get_defined (void);
int             handle_eos (void);
int             tl_getid (WCHAR);
void            undefine (void);

/************************************************************************/
/* P0PREPRO.C                                                           */
/************************************************************************/
int             do_defined (PWCHAR);
int             nextis (token_t);
void            preprocess (void);
void            skip_cnew (void);
void            skip_NLonly (void);

/************************************************************************/
/* P1SUP.C                                                              */
/************************************************************************/
ptree_t         build_const (token_t, value_t *);

/************************************************************************/
/* RCPPUTIL.C                                                           */
/************************************************************************/
WCHAR *         pstrdup (WCHAR *);
WCHAR *         pstrndup (WCHAR *, int);
WCHAR *         strappend (WCHAR *, WCHAR *);

/************************************************************************/
/* SCANNER.C                                                            */
/************************************************************************/
token_t         char_const (void);
int             checknl (void);
int             checkop (int);
void            do_newline (void);
void            dump_comment (void);
void            DumpSlashComment (void);
void            getid (UINT);
WCHAR           get_non_eof (void);
token_t         getnum (WCHAR);
token_t         get_real (PWCHAR);
hash_t          local_c_hash (WCHAR *);
void            prep_string (WCHAR);
WCHAR           skip_cwhite (void);
int             skip_comment (void);
void            str_const (void);

/************************************************************************/
/* P0 I/O MACROS                                                        */
/************************************************************************/

//
// These macros could be a problem when working with non-spacing marks.
//
#define GETCH()         (*Current_char++)
#define CHECKCH()       (*Current_char)
#define UNGETCH()       (Current_char--)
#define PREVCH()        (*(Current_char - 1))
#define SKIPCH()        (Current_char++)


/************************************************************************/
/* RCPPX extensions needed for symbols                                  */
/************************************************************************/
void AfxOutputMacroDefn(pdefn_t p);
void AfxOutputMacroUse(pdefn_t p);
void move_to_exp(ptext_t);

/************************************************************************/
/* RCFUTIL utility routine						*/
/************************************************************************/
void myfwrite(const void *pv, size_t s, size_t n, FILE *fp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcpputil.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/************************************************************************
 * PSTRDUP - Create a duplicate of string s and return a pointer to it.
 ************************************************************************/
WCHAR *
pstrdup(
    WCHAR *s
    )
{
    return(wcscpy((WCHAR *)MyAlloc((wcslen(s) + 1) * sizeof(WCHAR)), s));
}


/************************************************************************
**  pstrndup : copies n bytes from the string to a newly allocated
**  near memory location.
************************************************************************/
WCHAR *
pstrndup(
    WCHAR *s,
    int n
    )
{
    WCHAR   *r;
    WCHAR   *res;

    r = res = (WCHAR *) MyAlloc((n+1) * sizeof(WCHAR));
    if (res == NULL) {
        error(1002);
        return NULL;
    }

    __try {
        for (; n--; r++, s++) {
            *r = *s;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        n++;
        while (n--) {
            *r++ = L'\0';
        }
    }
    *r = L'\0';
    return(res);
}


/************************************************************************
**      strappend : appends src to the dst,
**  returns a ptr in dst to the null terminator.
************************************************************************/
WCHAR *
strappend(
    register WCHAR *dst,
    register WCHAR *src
    )
{
    while ((*dst++ = *src++) != 0);
    return(--dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcp.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


static BOOL fFontDirRead = FALSE;

BOOL    bExternParse = FALSE;

WORD    language = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
LONG    version = 0;
LONG    characteristics = 0;

static int rowError = 0;
static int colError = 0;
static int idError = 0;


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError3() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError3(
    int id
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit(NULL);

    SendError(L"\n");
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit(NULL);

    rowError = token.row;
    colError = token.col;
    idError = id;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError2() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError2(
    int id,
    PWCHAR arg
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit(NULL);

    SendError(L"\n");
    SET_MSG(id, curFile, token.row, arg);
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit(NULL);

    rowError = token.row;
    colError = token.col;
    idError = id;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError1() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError1(
    int id
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit(NULL);

    SendError(L"\n");
    SET_MSG(id, curFile, token.row);
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit(NULL);

    rowError = token.row;
    colError = token.col;
    idError = id;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetFileName() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Read in a filename from the RC file. */

VOID
SearchInclude(wchar_t *szFile, wchar_t *szActual)
{
    size_t cchFile;
    const wchar_t *pchVar;

    // We don't do absolute paths

    if ((szFile[0] == L'\\') || (szFile[0] == L'/') || (szFile[1] == L':')) {
        if (wcslen(szFile) >= _MAX_PATH) {
            szActual[0] = L'\0';
        } else {
            wcscpy(szActual, szFile);
        }

        return;
    }

    cchFile = wcslen(szFile) + 1;

    pchVar = pchInclude;

    while (*pchVar != L'\0') {
        size_t ich;

        // Copy the next include path component

        for (ich = 0; *pchVar != L'\0'; pchVar++) {
            if (*pchVar == L';') {
                pchVar++;
                break;
            }

            if (ich < _MAX_PATH) {
               szActual[ich++] = *pchVar;
            }
        }

        if ((ich == 0) || (ich == _MAX_PATH)) {
             // Skip empty paths (e.g. ";;")
             // Skip too long paths too

             continue;
        }

        // Find end of path string

        // Check first!  this is what _searchenv() messed up!

        if ((szActual[ich - 1] != L'\\') && (szActual[ich - 1] != L'/')) {
            if (ich < _MAX_PATH) {
               szActual[ich++] = L'\\';
            }
        }

        // We already know szFile does not start with a drive or abs. dir

        if ((ich + cchFile) >= _MAX_PATH) {
            continue;
        }

        wcscpy(szActual + ich, szFile);

        // Is the file here? szActual already contains name

        if (!_waccess(szActual, 0)) {
            return;
        }
    }

    szActual[0] = L'\0';
}


LONG
GetFileName(
    VOID
    )
{
    PFILE fh;
    LONG size;
    wchar_t szFilename[_MAX_PATH];

    SearchInclude(tokenbuf, szFilename);

    if (szFilename[0] && ((fh = _wfopen(szFilename, L"rb")) != NULL)) {
        size = MySeek(fh, 0, SEEK_END);                /* find size of file */
        MySeek(fh, 0, SEEK_SET);                       /* return to start of file */
        CtlFile(fh);
        return(size);
    }

    ParseError2(2135, tokenbuf);
    return 0;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddStringToBin() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* adds ordinal if non-zero, otherwise adds string.  In either case, puts */
/* it in a field of NCHARS [16] */

VOID
AddStringToBin(
    USHORT ord,
    WCHAR *sz
    )
{
    USHORT      n1 = 0xFFFF;

    /* Is this an ordinal type? */
    if (ord) {
        MyWrite(fhBin, &n1, sizeof(USHORT));     /* 0xFFFF */
        MyWrite(fhBin, &ord, sizeof(USHORT));
    } else {
        MyWrite(fhBin, sz, (wcslen(sz)+1) * sizeof(WCHAR));
    }
}


PWCHAR   pTypeName[] =
{
    NULL,                //  0
    L"CURSOR",           //  1 RT_CURSOR
    L"BITMAP",           //  2 RT_BITMAP
    L"ICON",             //  3 RT_ICON
    L"MENU",             //  4 RT_MENU
    L"DIALOG",           //  5 RT_DIALOG
    L"STRING",           //  6 RT_STRING
    L"FONTDIR",          //  7 RT_FONTDIR
    L"FONT",             //  8 RT_FONT
    L"ACCELERATOR",      //  9 RT_ACCELERATOR
    L"RCDATA",           // 10 RT_RCDATA
    L"MESSAGETABLE",     // 11 RT_MESSAGETABLE
    L"GROUP_CURSOR",     // 12 RT_GROUP_CURSOR
    NULL,                // 13 RT_NEWBITMAP -- according to NT
    L"GROUP_ICON",       // 14 RT_GROUP_ICON
    NULL,                // 15 RT_NAMETABLE
    L"VERSION",          // 16 RT_VERSION
    L"DIALOGEX",         // 17 RT_DIALOGEX     ;internal
    L"DLGINCLUDE",       // 18 RT_DLGINCLUDE
    L"PLUGPLAY",         // 19 RT_PLUGPLAY
    L"VXD",              // 20 RT_VXD
    L"ANICURSOR",        // 21 RT_ANICURSOR    ;internal
    L"ANIICON",          // 22 RT_ANIICON      ;internal
    L"HTML"              // 23 RT_HTML
};

// Note: Don't forget to update the same table in rcdump.c

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddBinEntry() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* FORMAT: type, name, flags, length, bytes */

VOID
AddBinEntry(
    PTYPEINFO pType,
    PRESINFO pRes,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{
    ULONG       hdrSize = sizeof(RESADDITIONAL);
    ULONG       t0 = 0;
    ULONG       cbPad=0;

    if (!pRes->size)
        pRes->size = ResourceSize();

    if (pType->typeord == 0) {
        hdrSize += (wcslen(pType->type) + 1) * sizeof(WCHAR);
        cbPad += (wcslen(pType->type) + 1) * sizeof(WCHAR);
    } else {
        hdrSize += 2 * sizeof(WORD);
    }

    if (pRes->nameord == 0) {
        hdrSize += (wcslen(pRes->name) + 1) * sizeof(WCHAR);
        cbPad += (wcslen(pRes->name) + 1) * sizeof(WCHAR);
    } else {
        hdrSize += 2 * sizeof(WORD);
    }

    if (cbPad % 4)
        hdrSize += sizeof(WORD);        // could only be off by 2

    if (fVerbose) {
        if (pType->typeord == 0) {
            if (pRes->nameord == 0)
                swprintf(Msg_Text, L"\nWriting %s:%s,\tlang:0x%x,\tsize %d",
                        pType->type, pRes->name, pRes->language, pRes->size);
            else
                swprintf(Msg_Text, L"\nWriting %s:%d,\tlang:0x%x,\tsize %d",
                        pType->type, pRes->nameord, pRes->language, pRes->size);
        } else {
            if (pRes->nameord == 0) {
                if (pType->typeord <= (USHORT)(UINT_PTR)RT_LAST)
                    swprintf(Msg_Text, L"\nWriting %s:%s,\tlang:0x%x,\tsize %d",
                              pTypeName[pType->typeord],
                              pRes->name, pRes->language, pRes->size);
                else
                    swprintf(Msg_Text, L"\nWriting %d:%s,\tlang:0x%x,\tsize %d",
                              pType->typeord,
                              pRes->name, pRes->language, pRes->size);
            } else {
                if (pType->typeord <= (USHORT)(UINT_PTR)RT_LAST)
                    swprintf(Msg_Text, L"\nWriting %s:%d,\tlang:0x%x,\tsize %d",
                              pTypeName[pType->typeord],
                              pRes->nameord, pRes->language, pRes->size);
                else
                    swprintf(Msg_Text, L"\nWriting %d:%d,\tlang:0x%x,\tsize %d",
                              pType->typeord,
                              pRes->nameord, pRes->language, pRes->size);
            }
        }
        fputws(Msg_Text, stdout);
    }

    if (fMacRsrcs) {
        /* record file location for the resource map and dump out
        resource's size */
        DWORD dwT;
        pRes->BinOffset = (long)MySeek(fhBin,0L,1) - MACDATAOFFSET;
        dwT = SwapLong(pRes->size);
        MyWrite(fhBin, &dwT, 4);
    } else {
        /* add type, name, flags, and resource length */
        MyWrite(fhBin, &pRes->size, sizeof(ULONG));
        MyWrite(fhBin, &hdrSize, sizeof(ULONG));

        AddStringToBin(pType->typeord, pType->type);
        AddStringToBin(pRes->nameord , pRes->name);
        MyAlign(fhBin);

        MyWrite(fhBin, &t0, sizeof(ULONG));  /* data version */
        MyWrite(fhBin, &pRes->flags, sizeof(WORD));
        MyWrite(fhBin, &pRes->language, sizeof(WORD));
        MyWrite(fhBin, &pRes->version, sizeof(ULONG));
        MyWrite(fhBin, &pRes->characteristics, sizeof(ULONG));

        /* record file location for the .EXE construction */
        pRes->BinOffset = (LONG)MySeek(fhBin, 0L, SEEK_CUR);
    }

    /* write array plus contents of resource source file */
    WriteControl(fhBin, Array, ArrayCount, FileCount);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddResToResFile(pType, pRes, Array, ArrayCount, FileCount)              */
/*                                                                          */
/*  Parameters:                                                             */
/*      pType  : Pointer to Res Type                                        */
/*      pRes   : Pointer to resource                                        */
/*      Array  : Pointer to array from which some data is to be copied into */
/*               the .RES file.                                             */
/*               This is ignored if ArrayCount is zero.                     */
/*      ArrayCount : This is the number of bytes to be copied from "Array"  */
/*                   into the .RES file. This is zero if no copy is required*/
/*      FileCount  : This specifies the number of bytes to be copied from   */
/*                   fhCode into fhOut. If this is -1, the complete input   */
/*                   file is to be copied into fhOut.                       */
/*                                                                          */
/*------------------------------------------------------------------------*/

VOID
AddResToResFile(
    PTYPEINFO pType,
    PRESINFO pRes,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{
    PRESINFO p;

    p = pType->pres;

    /* add resource to end of resource list for this type */
    if (p) {
        while (p->next)
            p = p->next;

        p->next = pRes;
    } else {
        pType->pres = pRes;
    }


    /* add the resource to the .RES File */
    AddBinEntry(pType, pRes, Array, ArrayCount, FileCount);

    /* keep track of number of resources and types */
    pType->nres++;
    ResCount++;
    WriteResInfo(pRes, pType, TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddResType() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PTYPEINFO
AddResType(
    PWCHAR s,
    LPWSTR l
    )
{
    PTYPEINFO  pType;

    if ((pType = pTypInfo) != 0) {
        for (; ; ) {
            /* search for resource type, return if already exists */
            if ((s && pType->type && !wcscmp(s, pType->type)) ||
                (!s && l && pType->typeord == (USHORT)l))
                return(pType);
            else if (!pType->next)
                break;
            else
                pType = pType->next;
        }

        /* if not in list, add space for it */
        pType->next = (PTYPEINFO)MyAlloc(sizeof(TYPEINFO));
        pType = pType->next;
    } else {
        /* allocate space for resource list */
        pTypInfo = (PTYPEINFO)MyAlloc(sizeof(TYPEINFO));
        pType = pTypInfo;
    }

    /* fill allocated space with name and ordinal, and clear the resources
         of this type */
    pType->type = MyMakeStr(s);
    pType->typeord = (USHORT)l;
    pType->nres = 0;
    pType->pres = NULL;

    return(pType);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DGetMemFlags() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int
DGetMemFlags (
    PRESINFO pRes
    )
{
    if (token.type == NUMLIT)
        // this is a numeric value, not a mem flag -- this means we're done
        // processing memory flags
        return(FALSE);

    /* adjust memory flags of resource */
    switch (token.val) {
        case TKMOVEABLE:
            pRes->flags |= NSMOVE;
            break;

        case TKFIXED:
            pRes->flags &= ~(NSMOVE | NSDISCARD);
            break;

        case TKPURE :
            pRes->flags |= NSPURE;
            break;

        case TKIMPURE :
            pRes->flags &= ~(NSPURE | NSDISCARD);
            break;

        case TKPRELOAD:
            pRes->flags |= NSPRELOAD;
            break;

        case TKLOADONCALL:
            pRes->flags &= ~NSPRELOAD;
            break;

        case TKDISCARD:
            pRes->flags |= NSMOVE | NSPURE | NSDISCARD;
            break;

        case TKEXSTYLE:
            GetToken(FALSE);        /* ignore '=' */
            if (token.type != EQUAL)
                ParseError1(2136);
            GetTokenNoComma(TOKEN_NOEXPRESSION);
            GetFullExpression(&pRes->exstyleT, GFE_ZEROINIT);
            break;

            /* if current token not memory flag, return FALSE to indicate not
             to continue parsing flags */
        default:
            return(FALSE);
    }

    GetToken(FALSE);

    /* TRUE ==> found memory flag */
    return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddDefaultTypes() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
AddDefaultTypes(
    VOID
    )
{
    AddResType(L"CURSOR", RT_GROUP_CURSOR);
    AddResType(L"ICON", RT_GROUP_ICON);
    AddResType(L"BITMAP", RT_BITMAP);
    AddResType(L"MENU", RT_MENU);
    AddResType(L"DIALOG", RT_DIALOG);
    AddResType(L"STRINGTABLE", RT_STRING);
    AddResType(L"FONTDIR", RT_FONTDIR);
    AddResType(L"FONT", RT_FONT);
    AddResType(L"ACCELERATORS", RT_ACCELERATOR);
    AddResType(L"RCDATA", RT_RCDATA);
    AddResType(L"MESSAGETABLE", RT_MESSAGETABLE);
    AddResType(L"VERSIONINFO", RT_VERSION);
    AddResType(L"DLGINCLUDE", RT_DLGINCLUDE);
    AddResType(L"MENUEX", RT_MENUEX);
    AddResType(L"DIALOGEX", RT_DIALOGEX);
    AddResType(L"PLUGPLAY", RT_PLUGPLAY);
    AddResType(L"VXD", RT_VXD);

    // AFX resource types.
    AddResType(L"DLGINIT", RT_DLGINIT);
    AddResType(L"TOOLBAR", RT_TOOLBAR);

    AddResType(L"ANIICON",   RT_ANIICON);
    AddResType(L"ANICURSOR", RT_ANICURSOR);

    AddResType(L"HTML", RT_HTML);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddFontDir() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
AddFontDir(
    VOID
    )
{
    PRESINFO   pRes;
    PTYPEINFO  pType;
    PFONTDIR   pFont;

    /* make new resource */
    pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
    pRes->language = language;
    pRes->version = version;
    pRes->characteristics = characteristics;
    pRes->name = MyMakeStr(L"FONTDIR");

    /* find or create the type list */
    pType = AddResType(NULL, RT_FONTDIR);

    CtlInit();

    WriteWord(nFontsRead);

    pFont = pFontList;

    while (pFont) {
        WriteWord(pFont->ordinal);
        WriteBuffer(pFont + 1, pFont->nbyFont);
        pFont = pFont->next;
    }

    pRes->flags = NSMOVE | NSPRELOAD;

    /* write to the .RES file */
    SaveResFile(pType, pRes);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadRF() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* top level parsing function: recognizes an RC script */

int
ReadRF(
    VOID
    )
{
    PRESINFO    pRes;
    PTYPEINFO   pType;
    ULONG       zero=0;
    WORD        ffff=0xffff;
    ULONG       hdrSize = sizeof(RESADDITIONAL) + 2 * (sizeof(WORD) * 2);

    ResCount = 0;
    nFontsRead = 0;

    /* Initialize data structures. */
    AddDefaultTypes();

    if (!fMacRsrcs) {
        /* write 32-bit header for empty resource/signature */
        MyWrite(fhBin, &zero, sizeof(ULONG));
        MyWrite(fhBin, &hdrSize, sizeof(ULONG));
        MyWrite(fhBin, &ffff, sizeof(WORD));
        MyWrite(fhBin, &zero, sizeof(WORD));
        MyWrite(fhBin, &ffff, sizeof(WORD));
        MyWrite(fhBin, &zero, sizeof(WORD));
        MyWrite(fhBin, &zero, sizeof(ULONG));
        MyWrite(fhBin, &zero, sizeof(WORD));
        MyWrite(fhBin, &zero, sizeof(WORD));
        MyWrite(fhBin, &zero, sizeof(ULONG));
        MyWrite(fhBin, &zero, sizeof(ULONG));
    }

    CtlAlloc();

    if (fAFXSymbols) {
        int n;
        char szMultiByte[_MAX_PATH];
        char *pch = szMultiByte;
        // write out first HWB resource

        CtlInit();
        pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;

        pRes->size = sizeof(DWORD);
        pRes->flags = 0;
        pRes->name = 0;
        pRes->nameord = 1;
        WriteLong(0);           /* space for file pointer */

        n = wcslen(inname) + 1;
        n = WideCharToMultiByte(CP_ACP,
                                0,
                                inname,
                                n,
                                szMultiByte,
                                MAX_PATH,
                                NULL,
                                NULL);

        while (*pch) {
            WriteByte(*pch++);
            pRes->size++;
        }
        WriteByte(0);
        pRes->size++;

        pType = AddResType(L"HWB", 0);
        SaveResFile(pType, pRes);
        lOffIndex = pRes->BinOffset;
    }

    /* Process the RC file. */
    do {
        token.sym.name[0] = L'\0';
        token.sym.nID = 0;

        /* Find the beginning of the next resource. */
        if (!GetNameOrd())
            break;

        if (!wcscmp(tokenbuf, L"LANGUAGE")) {
            language = GetLanguage();
            continue;
        } else if (!wcscmp(tokenbuf, L"VERSION")) {
            GetToken(FALSE);
            if (token.type != NUMLIT)
                ParseError1(2139);
            version = token.longval;
            continue;
        } else if (!wcscmp(tokenbuf, L"CHARACTERISTICS")) {
            GetToken(FALSE);
            if (token.type != NUMLIT)
                ParseError1(2140);
            characteristics = token.longval;
            continue;
        }

        /* Print a dot for each resource processed. */
        if (fVerbose) {
            wprintf(L".");
        }

        /* Allocate space for the new resources Info structure. */
        pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;

        if (token.sym.name[0]) {
            /* token has a real symbol associated with it */
            memcpy(&pRes->sym, &token.sym, sizeof(SYMINFO));
        } else {
            pRes->sym.name[0] = L'\0';
        }

        if (!token.val) {
            if (wcslen(tokenbuf) > MAXTOKSTR-1) {
                SET_MSG(4206, curFile, token.row);
                SendError(Msg_Text);
                tokenbuf[MAXTOKSTR-1] = L'\0';
                token.val = MAXTOKSTR-2;
            }
            pRes->name = MyMakeStr(tokenbuf);
        } else {
            pRes->nameord = token.val;
        }

      /* If not a string table, find out what kind of resource follows.
       * The StringTable is a special case since the Name field is the
       * string's ID number mod 16.
       */
        if ((pRes->name == NULL) || wcscmp(pRes->name, L"STRINGTABLE")) {
            if (!GetNameOrd())
                break;

            if (!token.val) {
                if (wcslen(tokenbuf) > MAXTOKSTR-1) {
                    SET_MSG(4207, curFile, token.row);
                    SendError(Msg_Text);
                    tokenbuf[MAXTOKSTR-1] = L'\0';
                    token.val = MAXTOKSTR-2;
                }
                if (!wcscmp(tokenbuf, L"STRINGTABLE")) {
                    // User attempted to create a named string table... Bail
                    ParseError1(2255);
                    pRes->name = MyMakeStr(tokenbuf);
                    goto ItsAStringTable;
                }

                pType = AddResType(tokenbuf, MAKEINTRESOURCE(0));
            }
            else
                pType = AddResType(NULL, MAKEINTRESOURCE(token.val));

            if (!pType)
                return(errorCount == 0);

            /* Parse any user specified memory flags. */
            GetToken(FALSE);

            switch ((INT_PTR)pType->typeord) {
                    /* Calculated resources default to discardable. */
                case (INT_PTR)RT_ICON:
                case (INT_PTR)RT_CURSOR:
                case (INT_PTR)RT_FONT:
                case (INT_PTR)RT_DIALOG:
                case (INT_PTR)RT_MENU:
                case (INT_PTR)RT_DLGINCLUDE:
                case (INT_PTR)RT_DIALOGEX:
                case (INT_PTR)RT_MENUEX:
                    pRes->flags = NSMOVE | NSPURE | NSDISCARD;
                    break;

                case (INT_PTR)RT_GROUP_ICON:
                case (INT_PTR)RT_GROUP_CURSOR:
                    pRes->flags = NSMOVE | NSDISCARD;
                    break;

                    /* All other resources default to moveable. */
                default:
                    pRes->flags = NSMOVE | NSPURE;
                    break;
            }

            /* adjust according to the user's specifications
           */
            while (DGetMemFlags(pRes))
                ;

            // write out start of new resource
            WriteResInfo(pRes, pType, FALSE);
        } else {

ItsAStringTable:

            /* Parse any user specified memory flags. */
            GetToken(FALSE);

            /* String and Error resources default to discardable. */
            pRes->flags = NSMOVE | NSPURE | NSDISCARD;
            while (DGetMemFlags(pRes))
                ;

            pType = NULL;
        }

        if (!pType) {
            /* parse the string table, if that's what it is */
            if ((pRes->name != NULL) && (!wcscmp(pRes->name, L"STRINGTABLE"))) {
                if (GetTable(pRes) == NULL)
                    break;
            } else {
                ParseError1(2141);
            }
        } else {
            CtlInit();
            pRes->size = 0L;

            /* call parsing and generating functions specific to the various
             resource types */
            switch ((INT_PTR)pType->typeord) {
                case (INT_PTR)RT_DIALOGEX:
                    /* allocate dialog memory */
                    pLocDlg = (PDLGHDR) MyAlloc(sizeof(DLGHDR));

                    /* parse dialog box */
                    GetDlg(pRes, pLocDlg, TRUE);

                    /* write dialog box */
                    SaveResFile(AddResType(L"DIALOG", 0), pRes);

                    /* free dialog memory */
                    MyFree(pLocDlg);
                    break;

                case (INT_PTR)RT_DIALOG:
                    /* allocate dialog memory */
                    pLocDlg = (PDLGHDR) MyAlloc(sizeof(DLGHDR));

                    /* parse dialog box */
                    GetDlg(pRes, pLocDlg, FALSE);

                    /* write dialog box */
                    SaveResFile(pType, pRes);

                    /* free dialog memory */
                    MyFree(pLocDlg);
                    break;

                case (INT_PTR)RT_ACCELERATOR:
                    GetAccelerators(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_MENUEX:
                    WriteWord(MENUITEMTEMPLATEVERSIONNUMBER);
                    WriteWord(MENUITEMTEMPLATEBYTESINHEADER);
                    ParseMenu(FALSE, pRes);
                    SaveResFile(AddResType(L"MENU", 0), pRes);
                    break;

                case (INT_PTR)RT_MENU:
                    WriteWord(OLDMENUITEMTEMPLATEVERSIONNUMBER);
                    WriteWord(OLDMENUITEMTEMPLATEBYTESINHEADER);
                    ParseOldMenu(FALSE, pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_ICON:
                case (INT_PTR)RT_CURSOR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            pRes->size = GetIcon(pRes->size);
                            SaveResFile(pType, pRes);
                        }
                    }
                    break;

                case (INT_PTR) RT_ANIICON:
                case (INT_PTR) RT_ANICURSOR:
ani:
                    {
                        USHORT iLastTypeOrd = pType->typeord;

                        // Strictly speaking, ANIICON and ANICURSOR are not allowed.  However,
                        // we'll keep them around for the time being.  BryanT 8/14/96.
                        if ((pType->typeord == (USHORT)(INT_PTR)RT_ICON) ||
                            (pType->typeord == (USHORT)(INT_PTR)RT_GROUP_ICON))
                        {
                            pType->typeord = (USHORT)(INT_PTR)RT_ANIICON;
                        } else
                        if ((pType->typeord == (USHORT)(INT_PTR) RT_CURSOR) ||
                            (pType->typeord == (USHORT)(INT_PTR) RT_GROUP_CURSOR))
                        {
                            pType->typeord = (USHORT)(INT_PTR)RT_ANICURSOR;
                        }
                        WriteFileInfo(pRes, pType, tokenbuf);
                        pRes->size = GetFileName();
                        if (pRes->size) {
                            pRes->size = GetAniIconsAniCursors(pRes->size);
                            SaveResFile(pType, pRes);
                        }

                        pType->typeord = iLastTypeOrd;
                    }
                    break;

                case (INT_PTR)RT_BITMAP:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        /* Bitmap in DIB format */
                        pRes ->size = GetNewBitmap();
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_GROUP_ICON:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            if (fMacRsrcs)
                                GetMacIcon(pType, pRes);
                            else
                                GetNewIconsCursors(pType, pRes, RT_ICON);
                        }
                    }
                    break;

                case (INT_PTR)RT_GROUP_CURSOR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            if (fMacRsrcs)
                                GetMacCursor(pType, pRes);
                            else
                                GetNewIconsCursors(pType, pRes, RT_CURSOR);
                        }
                    }
                    break;

                case (INT_PTR)RT_FONT:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->name)
                        ParseError1(2143);
                    if (AddFontRes(pRes)) {
                        nFontsRead++;
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_FONTDIR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    fFontDirRead = TRUE;
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_MESSAGETABLE:
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_VERSION:
                    VersionParse();
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_DLGINCLUDE:
                    DlgIncludeParse(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_TOOLBAR:
                    GetToolbar(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_RCDATA:
                case (INT_PTR)RT_DLGINIT:
                default:
                    if (token.type != BEGIN) {
                        pRes->size = GetFileName();
                        if (pRes->size) {
                            WriteFileInfo(pRes, pType, tokenbuf);
                        }
                    } else {
                        RESINFO_PARSE rip;

                        bExternParse = FALSE;

                        // Check to see if caller wants to parse this.
                        if ((lpfnParseCallbackA != 0) || (lpfnParseCallbackW != 0)) {
                            rip.size = 0L;
                            rip.type = pType->type;
                            rip.typeord = pType->typeord;
                            rip.name = pRes->name;
                            rip.nameord = pRes->nameord;
                            rip.flags = pRes->flags;
                            rip.language = pRes->language;
                            rip.version = pRes->version;
                            rip.characteristics = pRes->characteristics;

                            if (lpfnParseCallbackW != 0) {
                                bExternParse = (*lpfnParseCallbackW)(&rip, NULL, NULL);
                            } else {
                                bExternParse = (*lpfnParseCallbackA)(&rip, NULL, NULL);
                            }
                        }

                        if (!bExternParse) {
                            GetRCData(pRes);
                        } else {
                            union {
                                CONTEXTINFO_PARSE cipA;
                                CONTEXTINFO_PARSEW cipW;
                            } cip;

                            extern PCHAR CodeArray;
                            extern int CodeSize;
                            extern int CCount;

                            int nBegins = 1;
                            int nCountSave; // CCount before END token reached

                            cip.cipW.hHeap = hHeap;
                            cip.cipW.hWndCaller = hWndCaller;
                            cip.cipW.line = token.row;

                            // Collect data for caller to parse.
                            while(nBegins > 0) {
                                nCountSave = CCount;
                                GetToken(FALSE);

                                if (token.type == BEGIN) {
                                    nBegins++;
                                } else if (token.type == END) {
                                    nBegins--;
                                }
                            }

                            bExternParse = FALSE;

                            if ((rip.size = nCountSave) > 0) {
                                BOOL b;

                                if (lpfnParseCallbackW != 0) {
                                    wchar_t mbuff[512];    // REVIEW: Long filenames??  See error.c also.

                                    cip.cipW.lpfnMsg = lpfnMessageCallbackW;

                                    swprintf(mbuff, L"%s(%%d) : %%s", curFile);
                                    cip.cipW.format = mbuff;

                                    b = (*lpfnParseCallbackW)(&rip, (void **) &CodeArray, &cip.cipW);
                                } else {
                                    char mbuff[512];    // REVIEW: Long filenames??  See error.c also.

                                    cip.cipA.lpfnMsg = lpfnMessageCallbackA;

                                    sprintf(mbuff, "%S(%%d) : %%s", curFile);
                                    cip.cipA.format = mbuff;

                                    b = (*lpfnParseCallbackA)(&rip, (void **) &CodeArray, &cip.cipA);
                                }

                                if (!b) {
                                    // Assume caller gave error message, and quit.

                                    quit(NULL);
                                }
                            }

                        pRes->size = CCount = CodeSize = rip.size;
                        }
                    }

                    SaveResFile(pType, pRes);
                    break;
            }
            // write out end of new resource
            WriteResInfo(NULL, NULL, FALSE);
        }
    } while (token.type != EOFMARK);

    /* if we added fonts without a font directory, add one */
    if (!fFontDirRead && nFontsRead)
        AddFontDir();

    /* write string table */
    if (pResString != NULL)
        WriteTable(pResString);

    /* write Mac resource map */
    if (fMacRsrcs)
        WriteMacMap();

    CtlFree();

    if (fVerbose) {
        wprintf(L"\n");
    }
    return(errorCount == 0);
}


WORD
GetLanguage()
{
    WORD    L_language;

    GetToken(FALSE);
    if (token.type != NUMLIT) {
        ParseError1(2144);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    if (token.flongval) {
        ParseError1(2145);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    L_language = token.val;
    GetToken(FALSE);
    if (token.type != COMMA) {
        ParseError1(2146);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    GetToken(FALSE);
    if (token.type != NUMLIT) {
        ParseError1(2147);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    if (token.flongval) {
        ParseError1(2148);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }

    return MAKELANGID(L_language, token.val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcppx.h ===
/* special characters for handling symbol information */
/* note that we use characters in the private use area, as */
/* these will never be emitted (hopefully) by MultiByteToWideChar */
#define SYMDEFSTART 0xe000
#define SYMUSESTART 0xe001
#define SYMDELIMIT  0xe002
#define USR_RESOURCE 0
#define SYS_RESOURCE 1
#define IGN_RESOURCE 2
#define WIN_RESOURCE 3

extern int afxReadOnlySymbols;
extern int afxHiddenSymbols;
extern WCHAR* afxSzReadOnlySymbols;
extern WCHAR* afxSzHiddenSymbols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcpptype.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

/************************************************************************/
/* Define types for greater visibility and easier portability           */
/************************************************************************/

#ifndef _WINDOWS_
typedef char            CHAR;
typedef unsigned char   BYTE;
typedef CHAR *          PCHAR;
typedef unsigned short  WCHAR;
typedef unsigned char   UCHAR;
typedef UCHAR *         PUCHAR;
typedef WCHAR *         PWCHAR;

typedef short           SHORT;
typedef SHORT *         PSHORT;
typedef unsigned short  USHORT;
typedef USHORT *        PUSHORT;

typedef int             INT;
typedef INT             BOOL;
typedef INT *           PINT;
typedef unsigned int    UINT;
typedef UINT *          PUINT;

typedef long            LONG;
typedef LONG *          PLONG;
typedef unsigned long   ULONG;
typedef ULONG *         PULONG;

typedef void            VOID;
typedef VOID *          PVOID;
#endif

typedef double          DOUBLE;
typedef DOUBLE *        PDOUBLE;


/************************************************************************/
/*                                                                      */
/* Define internal types                                                */
/*                                                                      */
/************************************************************************/

#define TRUE    1
#define FALSE   0

#define EXTERN  extern
#define REG     register
#define STATIC  static


#define BIG_BUFFER      512
#define MED_BUFFER      256
#define SMALL_BUFFER    128
#define TINY_BUFFER     32
#define MSG_BUFF_SIZE   2048
#define IFSTACK_SIZE    TINY_BUFFER


/*
**      some commonly used typdefs for scalar items
*/
typedef UINT    p1key_t;
typedef UCHAR   hash_t;
typedef UCHAR   token_t;
typedef UCHAR   shape_t;

typedef UCHAR   blknum_t;       /*  lexical level  */
typedef UCHAR   class_t;

typedef USHORT  btype_t;        /*  basic type specifier  */
typedef USHORT  refcnt_t;       /*  symbol's reference count  */
typedef USHORT  hey_t;          /*  unique keys  */
typedef USHORT  offset_t;       /*  members offset within a struct  */

typedef ULONG   abnd_t;         /*  array bound type  */
typedef ULONG   len_t;          /*  number of bytes/bits of member/field  */

typedef struct  s_adj           symadj_t;
typedef struct  s_defn          defn_t;
typedef struct  s_flist         flist_t;
typedef struct  s_indir         indir_t;
typedef struct  s_stack         stack_t;
typedef struct  s_sym           sym_t;
typedef struct  s_table         table_t;
typedef struct  s_toklist       toklist_t;
typedef struct  s_tree          tree_t;
typedef struct  s_type          type_t;
typedef struct  s_case          case_t;

typedef union   u_ivalue        ivalue_t;

/*
**      abstract char pointer types
*/
typedef PWCHAR          ptext_t;        /* wherever input text comes from */

/*
**      other abstract pointer types
*/
typedef type_t *        ptype_t;        /* ptr to types */
typedef indir_t *       pindir_t;       /* ptr to indirections */
typedef flist_t *       pflist_t;       /* ptr to formal list type */
typedef sym_t *         psym_t;         /* symbol ptrs */
typedef defn_t *        pdefn_t;        /* #define names */

typedef tree_t *        ptree_t;


typedef struct s_realt {
    LONG        S_sizet;
    DOUBLE      S_realt;
} Srealt_t;


/* declspec type */
struct s_declspec {
    class_t ds_calss;
    ptype_t ds_type;
};
typedef struct s_declspec       declspec_t;
typedef declspec_t *            pdeclspec_t;


/* string type */
struct s_string {
    WCHAR *     str_ptr;
    USHORT      str_len;
};
typedef struct s_string         string_t;
typedef string_t *              pstring_t;


/* rcon type */
struct rcon {
    Srealt_t    rcon_real;
};
typedef struct rcon             rcon_t;
typedef struct rcon *           prcon_t;


/* hln type */
struct s_hln {
    PWCHAR hln_name;
    UCHAR hln_hash;
    UCHAR hln_length;
};
typedef struct  s_hln           hln_t;
typedef hln_t *                 phln_t;


/*
**      union used to return values from the lexer
*/
typedef union   s_lextype       {
        btype_t         yy_btype;
        PWCHAR          yy_cstr;
        int             yy_int;
        int             yy_class;
        long            yy_long;
        hln_t           yy_ident;
        declspec_t      yy_declspec;
        string_t        yy_string;
        psym_t          yy_symbol;
        token_t         yy_token;
        ptree_t         yy_tree;
        ptype_t         yy_type;
        } lextype_t;

/* value_t definition */
union u_value {
    prcon_t     v_rcon;
    long        v_long;
    string_t    v_string;
    psym_t      v_symbol;
};
typedef union   u_value         value_t;

/* keytab_t definition */
typedef struct {
    const WCHAR *k_text;
    UCHAR       k_token;
} keytab_t;


/************************************************************************/
/* LIST definition for \D values                                        */
/************************************************************************/
#define MAXLIST 100

typedef struct LIST {
        INT      li_top;
        WCHAR *  li_defns[MAXLIST];
} LIST;

#define UNREFERENCED_PARAMETER(x) (x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcppext.h ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

extern  const WCHAR   Union_str[];
extern  const WCHAR   Struct_str[];
extern  const WCHAR   Cdecl_str[];
extern  const WCHAR   Cdecl1_str[];
extern  const WCHAR   Fortran_str[];
extern  const WCHAR   Fortran1_str[];
extern  const WCHAR   Pascal_str[];
extern  const WCHAR   Pascal1_str[];
extern  const WCHAR   PPelse_str[];
extern  const WCHAR   PPendif_str[];
extern  const WCHAR   PPifel_str[];
extern  const WCHAR   Syntax_str[];

extern  FILE    * OUTPUTFILE;

extern  WCHAR   * A_string;
extern  WCHAR   * Debug;
extern  WCHAR   * Input_file;
extern  WCHAR   * Output_file;
extern  WCHAR   * Q_string;
extern  WCHAR   * Version;
extern  int     In_alloc_text;
extern  int     Bad_pragma;
extern  int     Cross_compile;
extern  int     Ehxtension;
extern  int     HugeModel;
extern  LIST    Defs;
extern  LIST    UnDefs;
extern  LIST    Includes;
extern  lextype_t yylval;
extern  token_t Basic_token;
extern  WCHAR   * Basename;
extern  WCHAR   * Path_chars;
extern  int     Char_align;
extern  int     Dump_tables;
extern  int     StunOpSeen;
extern  int     Inteltypes;
extern  int     List_type;
extern  int     Need_enddata;
extern  int     Nerrors;
extern  int     NoPasFor;

extern  int     Cmd_intrinsic;
extern  int     Cmd_pointer_check;
extern  int     Pointer_check;
extern  int     Cmd_stack_check;
extern  int     Stack_check;
extern  int     Cmd_loop_opt;
extern  int     Loop_opt;
extern  int     Cmd_pack_size;
extern  int     Pack_size;

extern  int     N_types;
extern  int     Got_type;
extern  int     Out_funcdef;
extern  int     Plm;
extern  int     Prep;
extern  int     Prep_ifstack;
extern  int     Ret_seen;
extern  int     Srclist;
extern  int     Stack_depth;
extern  int     Symbolic_debug;
extern  int     Table_index;
extern  int     Switch_check;
extern  int     Load_ds_with;
extern  int     Plmn;
extern  int     Plmf;
extern  int     Cflag;
extern  int     Eflag;
extern  int     Jflag;
extern  int     Pflag;
extern  int     Rflag;
extern  int     ZcFlag;
extern  int     StunDepth;

extern  long    Enum_val;
extern  long    Max_ival[];
extern  table_t *Table_stack[];

extern  int     Extension;

extern  WCHAR   *Filename;
extern  int     Linenumber;
extern  WCHAR   Filebuff[MED_BUFFER + 1];
extern  CHAR    chBuf[MED_BUFFER+1];
extern  WCHAR   Reuse_W[BIG_BUFFER];
extern  hash_t  Reuse_W_hash;
extern  UINT    Reuse_W_length;
extern  WCHAR   Reuse_Include[MED_BUFFER+1];
extern  WCHAR   Macro_buffer[BIG_BUFFER * 4];
extern  int     In_define;
extern  int     InIf;
extern  int     InInclude;
extern  int     Macro_depth;
extern  int     On_pound_line;
extern  int     Listing_value;
extern  token_t Currtok;

extern  long    Currval;
extern  int     Comment_type;
extern  WCHAR   *Comment_string;
extern  int     Tiny_lexer_nesting;
extern  WCHAR   *Exp_ptr;
extern  int     ifstack[IFSTACK_SIZE];

extern WCHAR    Contmap[], Charmap[];

extern const keytab_t Tokstrings[];

#define EXTENSION    (Extension || Ehxtension)

/*** I/O Variable for PreProcessor ***/
extern  ptext_t Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
extern wchar_t  Msg_Text[MSG_BUFF_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcppx.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0MACROS.C - Preprocessor Macros definitions                         */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

int afxReadOnlySymbols = FALSE;
int afxHiddenSymbols = FALSE;
WCHAR* afxSzReadOnlySymbols = L"APSTUDIO_READONLY_SYMBOLS";
WCHAR* afxSzHiddenSymbols = L"APSTUDIO_HIDDEN_SYMBOLS";

static WCHAR lineBuffer[2048];


void
AfxOutputMacroUse(
    pdefn_t p
    )
{
    if (!fAFXSymbols)
        return;

    if (afxHiddenSymbols)
        return;

    swprintf(lineBuffer,
        L" %c\"%s%c%s%c%d\"",
         SYMUSESTART,
         DEFN_NAME(p),
         SYMDELIMIT,
         Filename,
         SYMDELIMIT,
         Linenumber);

    move_to_exp(lineBuffer);
}

void
AfxOutputMacroDefn(
    pdefn_t p
    )
{
    char flags;
    int nLen;

    if (!fAFXSymbols || OUTPUTFILE == NULL)
            return;

    if (wcscmp(DEFN_NAME(p), afxSzReadOnlySymbols) == 0) {
        afxReadOnlySymbols = TRUE;
        return;
    }

    if (wcscmp(DEFN_NAME(p), afxSzHiddenSymbols) == 0) {
        afxHiddenSymbols = TRUE;
        return;
    }

    if (afxHiddenSymbols || DEFN_TEXT(p) == NULL)
        return;

    if (afxReadOnlySymbols)
        flags = SYS_RESOURCE;
    else
        flags = 0;

    nLen = swprintf(lineBuffer,
            L"%c%s%c%s%c%d%c%c%c",
             SYMDEFSTART,
             DEFN_NAME(p),
             SYMDELIMIT,
             DEFN_TEXT(p),
             SYMDELIMIT,
#if 0
             Filename,
             SYMDELIMIT,
    // don't forget to add %s%c
#endif
             Linenumber,
             SYMDELIMIT,
             (char)flags | '\200',   // (char)0x80,
             SYMDELIMIT);

    myfwrite(lineBuffer, nLen * sizeof(WCHAR), 1, OUTPUTFILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcstring.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

PRESINFO pResString = NULL;      /* Used to add a stringtable     */
/* at the end of processing if a stringtable */
/* was found.                                */

static PRCSTRING pSTHeader;
/* Ptr to the start of the parsed STRINGTABLE. */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyFAlloc() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void *MyFAlloc(size_t cb, const void *pv)
{
    void *pvT= MyAlloc(cb);

    if (pv != NULL) {
        memmove(pvT, pv, cb);
    } else {
        memset(pvT, 0, cb);
    }

    return(pvT);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTable() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PRESINFO
GetTable(
    PRESINFO pResTemp
    )
{
    PRCSTRING  pCurrent;
    PRCSTRING  pTrailer;
    CHAR       bDone = FALSE;
    USHORT     nStringID;
    PWCHAR     p;
    PSYMINFO   pCurrentSymbol;

    DWORD  TmpSize;
    wchar_t *TmpBuf;
    int    TmpRow;

    PreBeginParse(pResTemp, 2105);

    /* Does a string table already exist? */
    if (pResString == NULL) {
        /* No, start at the beginning - otherwise append. */
        pTrailer = (PRCSTRING)NULL;
        pSTHeader = (PRCSTRING)NULL;
    }

    do {
        pCurrent = pSTHeader;
        bDone = FALSE;
        if (token.type != NUMLIT)
            ParseError1(2149); //"Expected numeric constant in string table "

        nStringID = token.val;

        pCurrentSymbol = (SYMINFO*) MyFAlloc(sizeof(token.sym), (char*)&token.sym);

        if (!GetFullExpression(&nStringID, GFE_ZEROINIT | GFE_SHORT))
            ParseError1(2110); //"Expected numeric constant in v table "

        if (token.type == COMMA)
            GetToken(TOKEN_NOEXPRESSION);

        if (token.type != LSTRLIT)
            ParseError1(2150);

        tokenbuf[token.val + 1] = 0;

        TmpSize = sizeof(WCHAR) * (token.val + 2);
        TmpBuf = (wchar_t *) MyFAlloc(TmpSize, tokenbuf);
        TmpRow = token.row;
        GetToken(TRUE);

//        wprintf(L"TmpSize: %d\tTmpBuf: %s\tTmpRow: %d\n", TmpSize, TmpBuf, TmpRow);

        while ((token.row == TmpRow) && (token.type == LSTRLIT)) {
            size_t NewSize = TmpSize + (sizeof(WCHAR) * (token.val));
            wchar_t *NewBuf = (wchar_t *) MyAlloc(NewSize);

            memmove(NewBuf, TmpBuf, TmpSize);
            memmove((BYTE *) NewBuf + TmpSize-4, tokenbuf, (token.val * sizeof(WCHAR)));

//            wprintf(L"NewSize: %d\tNewBuf: %ws\ttoken.row: %d\ttokenbuf: %ws\n", NewSize, NewBuf, token.row, tokenbuf);

            MyFree(TmpBuf);
            TmpSize = NewSize;
            TmpBuf = NewBuf;
            GetToken(TRUE);
        }

        while (!bDone && pCurrent) {
            if (pCurrent->language == pResTemp->language) {
                if (pCurrent->hibits == (USHORT)(nStringID / BLOCKSIZE)) {
                    bDone = TRUE;
                    if (!(pCurrent->rgsz[nStringID % BLOCKSIZE])) {
                        pCurrent->rgsz[nStringID % BLOCKSIZE] = TmpBuf;
                        pCurrent->rgsym[nStringID % BLOCKSIZE] = pCurrentSymbol;
                    }
                    else {
                        SET_MSG(2151,
                                curFile,
                                TmpRow,
                                nStringID,
                                pCurrent->rgsz[nStringID % BLOCKSIZE],
                                TmpBuf
                                );

                        ParseError3(2151);
                        MyFree(TmpBuf);
                    }

                    TmpBuf = NULL; TmpSize = 0;
                }
            }
            pTrailer = pCurrent;
            pCurrent = pCurrent->next;
        }

        if (!bDone) {       /* and thus pCurrent == NULL */
            pCurrent = (PRCSTRING) MyFAlloc(sizeof(RCSTRING), NULL);
            pCurrent->hibits = (short)(nStringID / BLOCKSIZE);
            pCurrent->flags  = pResTemp->flags;
            pCurrent->language = pResTemp->language;
            pCurrent->version = pResTemp->version;
            pCurrent->characteristics = pResTemp->characteristics;

            p = pCurrent->rgsz[nStringID%BLOCKSIZE] = TmpBuf;
            TmpBuf = NULL; TmpSize = 0;

            pCurrent->rgsym[nStringID%BLOCKSIZE] = pCurrentSymbol;

            if (pTrailer)
                pTrailer->next = pCurrent;

            if (!pSTHeader)
                pSTHeader = pCurrent;           /* First time only */
        }

//        GetToken(TRUE);
    } while (token.type != END);

    pResString = pResTemp;

    return pResString;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WriteTable() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
WriteTable(
    PRESINFO pResOld
    )
{
    PRCSTRING   p;
    int         i;
    PRESINFO    pRes;
    PTYPEINFO   pType;
    int         n;
    PWCHAR      s;
    UINT        nBytesWritten;
    SYMINFO     symInfo;

    /* Start at the start of the proper table. */
    p = pSTHeader;

    while (p) {
        nBytesWritten = 0;

        CtlInit();

        // 'STR#' resource starts with a count of strings
        if (fMacRsrcs)
            WriteWord(BLOCKSIZE);

        /* Write out the next block. */
        for (i = 0; i < BLOCKSIZE; i++) {
            n = 0;
            s = p->rgsz[i];

            if (fMacRsrcs) {
                WriteMacString(s, TRUE, TRUE);
                continue;
            }

            if (s) {
                while (s[n] || s[n + 1])
                    n++; // szsz terminated

                if (fAppendNull)
                    n++;
            }

            nBytesWritten += sizeof(WCHAR) * (n + 1);

            WriteWord((WORD)n);
            while (n--)
                WriteWord(*s++);
        }

        pRes = (RESINFO * )MyAlloc(sizeof(RESINFO));
        pRes->language = p->language;
        pRes->version = p->version;
        pRes->characteristics = p->characteristics;

        pType = AddResType(NULL, RT_STRING);

        pRes->size = nBytesWritten;

        /* Mark the resource as Moveable and Discardable. */
        pRes->flags = p->flags;

        /*We're in an origin 1 world here*/
        pRes->nameord = (short)(p->hibits + 1);
        SaveResFile(pType, pRes);

        memset(&symInfo, 0, sizeof(symInfo));
        WriteResInfo(pRes, pType, FALSE);
        for (i=0; i < BLOCKSIZE; i++) {
            WriteSymbolUse(p->rgsym[i] != NULL  && p->rgsz[i][0] != '\0' ? p->rgsym[i] : &symInfo);
        }
        WriteResInfo(NULL, NULL, FALSE);

        /* Move on to the next block. */
        p = p->next;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetAccelerators() _                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int
GetAccelerators(
    PRESINFO pRes
    )
{
    int count = 0;
    int ntype;
    WCHAR                 c;
    int bTypeSpecified;
    RCACCEL Accel;

    PreBeginParse(pRes, 2106);

    do {
        if (token.type == END)
            continue;
        bTypeSpecified = FALSE;
        ntype = token.type;
        if (token.type == END) {
            MarkAccelFlagsByte();
            WriteWord(0);
            WriteWord(0);
            WriteWord(0);
            WriteWord(0);
            count++;
            continue;
        }
        else if (token.type == NUMLIT)
            Accel.ascii = token.val;
        else if (token.type == LSTRLIT) {
            if (tokenbuf[0] == L'^') {
                if (wcslen(tokenbuf) != 2)
                    ParseError1(2152);
                /* GetAccelerators() and support "^^" to put ^ */
                if (tokenbuf[1] == L'^')
                    Accel.ascii = L'^';
                else {
                    if (!iswalpha(c=towupper(tokenbuf[1])))
                        ParseError1(2154);

                    Accel.ascii = c - L'A' + 1;
                }
            }
            else if (wcslen(tokenbuf) == 2)
                Accel.ascii = (WCHAR)((tokenbuf[0] << 8) + tokenbuf[1]);
            else if (wcslen(tokenbuf) == 1)
                Accel.ascii = tokenbuf[0];
            else
                ParseError1(2155);
        }
        else
            ParseError1(2156);

        /* Get the trailing comma. */
        GetToken(TRUE);
        if (token.type != COMMA)
            ParseError1(2157);

        /* Get the next number. */
        GetToken(TRUE);
        if (token.type != NUMLIT)
            ParseError1(2107);

        Accel.id = token.val;

        WriteSymbolUse(&token.sym);

        if (!GetFullExpression(&Accel.id, GFE_ZEROINIT | GFE_SHORT))
            ParseError1(2107); //"Expected numeric command value"

        Accel.flags = 0;

        if (token.type == COMMA)
            do {
                GetToken(TRUE);
                switch (token.type) {
                    case TKVIRTKEY:
                        Accel.flags |= fVIRTKEY;
                        bTypeSpecified = TRUE;
                        break;
                    case TKASCII:
                        bTypeSpecified = TRUE;
                        break;  /* don't set the flag */
                    case TKNOINVERT:
                        Accel.flags |= fNOINVERT;
                        break;
                    case TKSHIFT:
                        Accel.flags |= fSHIFT;
                        break;
                    case TKCONTROL:
                        Accel.flags |= fCONTROL;
                        break;
                    case TKALT:
                        Accel.flags |= fALT;
                        break;
                    default:
                        ParseError1(2159);
                }
                GetToken(TRUE);
            } while (token.type == COMMA);

        if (ntype == NUMLIT && !bTypeSpecified)
            ParseError1(2163);

        if (!(Accel.flags & fVIRTKEY) && (Accel.flags & (fSHIFT | fCONTROL))) {
            SET_MSG(4203, curFile, token.row);
            SendError(Msg_Text);
        }

        if (Accel.flags & fVIRTKEY && ntype == LSTRLIT) {
            if (!iswalnum(Accel.ascii = (WCHAR)towupper(Accel.ascii))) {
                SET_MSG(4204, curFile, token.row);
                SendError(Msg_Text);
            }
        }

        MarkAccelFlagsByte();
        WriteWord(Accel.flags);
        WriteWord(Accel.ascii);
        if (fMacRsrcs) {
            WriteLong(Accel.id);
        } else {
            WriteWord(Accel.id);
            WriteWord(0);
        }

        count++;

    } while (token.type != END);

    PatchAccelEnd();

    return(5 * count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rctg.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"
#include "assert.h"


#define MAXCODE    128000 //AFX uses > 65000
#define DIBBITMAPFORMAT   0x4D42   /* 'BM' as in PM format */

#undef  min
#define min(a,b) ((a<b)?(a):(b))

PCHAR       CodeArray;      /* pointer to code buffer */
int         CodeSize;       /* size of code buffer */
int         CCount;         /* current code array address */
PFILE       fhCode;         /* file handle for remaining data */
static int  ItemCountLoc;   /* a patch location; this one for */
static int  ItemExtraLoc;   /* a patch location; this one for */

typedef struct {
    SHORT   csHotX;
    SHORT   csHotY;
    SHORT   csWidth;
    SHORT   csHeight;
    SHORT   csWidthBytes;
    SHORT   csColor;
} IconHeader;


typedef struct {
    UINT        dfVersion;              /* not in FONTINFO */
    DWORD       dfSize;                 /* not in FONTINFO */
    CHAR        dfCopyright[60];        /* not in FONTINFO */
    UINT        dfType;
    UINT        dfPoints;
    UINT        dfVertRes;
    UINT        dfHorizRes;
    UINT        dfAscent;
    UINT        dfInternalLeading;
    UINT        dfExternalLeading;
    BYTE        dfItalic;
    BYTE        dfUnderline;
    BYTE        dfStrikeOut;
    UINT        dfWeight;
    BYTE        dfCharSet;
    UINT        dfPixWidth;
    UINT        dfPixHeight;
    BYTE        dfPitchAndFamily;
    UINT        dfAvgWidth;
    UINT        dfMaxWidth;
    BYTE        dfFirstChar;
    BYTE        dfLastChar;
    BYTE        dfDefaultCHar;
    BYTE        dfBreakChar;
    UINT        dfWidthBytes;
    DWORD       dfDevice;           /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD       dfFace;             /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD       dfReserved;         /* See Adaptation Guide 6.3.10 and 6.4 */
} ffh;

#define FONT_FIXED sizeof(ffh)
#define FONT_ALL sizeof(ffh) + 64

struct MacCursor {
    char data[16];
    char mask[16];
    short hotSpotV;
    short hotSpotH;
};

typedef struct {
    unsigned short red;
    unsigned short green;
    unsigned short blue;
} RGBColor;

typedef struct {
    unsigned short value;
    RGBColor rgb;
} ColorSpec;


#define ccs2 2
const ColorSpec rgcs2[ccs2] = {
    {0, {0xffff,0xffff,0xffff}},
    {1, {0x0000,0x0000,0x0000}}
};


#define ccs16 16
const ColorSpec rgcs16[ccs16] = {
    {0x00, {0xffff,0xffff,0xffff}},
    {0x01, {0xfc00,0xf37d,0x052f}},
    {0x02, {0xffff,0x648a,0x028c}},
    {0x03, {0xdd6b,0x08c2,0x06a2}},
    {0x04, {0xf2d7,0x0856,0x84ec}},
    {0x05, {0x46e3,0x0000,0xa53e}},
    {0x06, {0x0000,0x0000,0xd400}},
    {0x07, {0x0241,0xab54,0xeaff}},
    {0x08, {0x1f21,0xb793,0x1431}},
    {0x09, {0x0000,0x64af,0x11b0}},
    {0x0a, {0x5600,0x2c9d,0x0524}},
    {0x0b, {0x90d7,0x7160,0x3a34}},
    {0x0c, {0xc000,0xc000,0xc000}},
    {0x0d, {0x8000,0x8000,0x8000}},
    {0x0e, {0x4000,0x4000,0x4000}},
    {0x0f, {0x0000,0x0000,0x0000}}
};


/*
 *  the 34 legal icon colors
 */
#define ccs256 34
const ColorSpec rgcs256[ccs256] = {
    {0x01, {0xFFFF, 0xFFFF, 0xCCCC}},
    {0x08, {0xFFFF, 0xCCCC, 0x9999}},
    {0x33, {0xCCCC, 0x9999, 0x6666}},
    {0x16, {0xFFFF, 0x6666, 0x3333}},
    {0x92, {0x3333, 0xFFFF, 0x9999}},
    {0xE3, {0x0000, 0xBBBB, 0x0000}},
    {0x9F, {0x3333, 0x9999, 0x6666}},
    {0xA5, {0x3333, 0x6666, 0x6666}},
    {0x48, {0x9999, 0xFFFF, 0xFFFF}},
    {0xC0, {0x0000, 0x9999, 0xFFFF}},
    {0xEC, {0x0000, 0x0000, 0xDDDD}},
    {0xB0, {0x3333, 0x0000, 0x9999}},
    {0x2A, {0xCCCC, 0xCCCC, 0xFFFF}},
    {0x54, {0x9999, 0x9999, 0xFFFF}},
    {0x7F, {0x6666, 0x6666, 0xCCCC}},
    {0xAB, {0x3333, 0x3333, 0x6666}},
    {0x13, {0xFFFF, 0x6666, 0xCCCC}},
    {0x69, {0x9999, 0x0000, 0x6666}},
    {0x5C, {0x9999, 0x6666, 0x9999}},
    {0x00, {0xFFFF, 0xFFFF, 0xFFFF}},
    {0xF5, {0xEEEE, 0xEEEE, 0xEEEE}},
    {0xF6, {0xDDDD, 0xDDDD, 0xDDDD}},
    {0x2B, {0xCCCC, 0xCCCC, 0xCCCC}},
    {0xF7, {0xBBBB, 0xBBBB, 0xBBBB}},
    {0xF8, {0xAAAA, 0xAAAA, 0xAAAA}},
    {0xF9, {0x8888, 0x8888, 0x8888}},
    {0xFA, {0x7777, 0x7777, 0x7777}},
    {0xFB, {0x5555, 0x5555, 0x5555}},
    {0xFC, {0x4444, 0x4444, 0x4444}},
    {0xFD, {0x2222, 0x2222, 0x2222}},
    {0xFE, {0x1111, 0x1111, 0x1111}},
    {0xFF, {0x0000, 0x0000, 0x0000}},
    {0x05, {0xFFFF, 0xFFFF, 0x0000}},
    {0xD8, {0xDDDD, 0x0000, 0x0000}}
};

void ProcessMacIcons(RESINFO* pRes, int itBase, int ib1, int ib4, int ib8);
void ReadDIB(int ibDesc, struct tagDESCRIPTOR *pds, BITMAPINFOHEADER* pbmh, int* pcbWidth, void** ppBits, RGBQUAD** prgrgq, BOOL fIcon);
void CompactAndFlipIcon(BYTE* pBits, int cbRowCur, int cbRowMask, int cbRowNew, int cbRowMaskNew, int Height);
void WriteMacRsrc(void* pBits, int cbBits, RESINFO* pResBase, DWORD res);
void LookupIconColor(const ColorSpec* rgcs, int ccs, RGBQUAD* pq);
long MungeResType(WCHAR *szType, short wOrd);
int IdUnique(TYPEINFO *ptype, RESINFO* pres);
RESINFO* LookupIconRes(TYPEINFO* ptypeIcon, RESINFO* pres);
void TranslateString(char* sz);
void TranslateBuffer(char* rgch, int cch);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenWarning2() -                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
GenWarning2(
    int iMsg,
    const wchar_t *arg
    )
{
    SET_MSG(iMsg, curFile, token.row, arg);
    SendWarning(Msg_Text);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenWarning4() -                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
GenWarning4(
    int iMsg,
    const wchar_t *arg1,
    const wchar_t *arg2,
    const wchar_t *arg3
    )
{
    SET_MSG(iMsg,
            curFile,
            token.row,
            arg1,
            arg2,
            arg3);

    SendWarning(Msg_Text);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenError2() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
GenError2(
    int iMsg,
    const wchar_t *arg
    )
{
    if (fhCode > 0)
        fclose(fhCode);

    SET_MSG(iMsg, curFile, token.row, arg);
    SendError(Msg_Text);
    quit(NULL);
}


/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      GenError1() -                                                                                                                    */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

void
GenError1(
    int iMsg
    )
{
    if (fhCode > 0)
        fclose(fhCode);

    SET_MSG(iMsg, curFile, token.row);
    SendError(Msg_Text);
    quit(NULL);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlAlloc() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlAlloc(
    VOID
    )
{
    CodeSize = MAXCODE;
    CodeArray = (PCHAR) MyAlloc(MAXCODE);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlInit() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlInit(
    VOID
    )
{
    CCount = 0;         /* absolute location in CodeArray */
    fhCode = NULL_FILE; /* don't copy file unless we need to */
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlFile() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
PFILE
CtlFile(
    PFILE fh
    )
{
    if (fh != NULL_FILE)
        fhCode = fh;    /* set file handle to read remaining resource from */

    return(fhCode);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlFree() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlFree(
    VOID
    )
{
    CodeSize = 0;
    MyFree(CodeArray);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetSpace() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void *GetSpace(WORD cb)
{
    PCHAR pch;

    if (CCount > (int) (CodeSize - cb)) {
        PVOID pv = HeapReAlloc(hHeap, HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY, ((PCHAR) CodeArray) - 8, CodeSize + 0x00010000 + 8);

        if (pv == NULL) {
            GenError1(2168); //"Resource too large"
            /* GenError1 calls quit(NULL) and doesn't return! */
        }

        CodeArray = ((PCHAR) pv)+8;
        CodeSize += 0x00010000;
    }

    pch = CodeArray + CCount;
    CCount += cb;

    return(pch);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteString() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteString(
    PWCHAR sz,
    BOOL fMacCP
    )
{
    /* add a string to the resource buffer */
    if (fMacRsrcs) {
        WriteMacString(sz, fMacCP, FALSE);
    } else {
        do {
            WriteWord(*sz);
        } while (*sz++ != 0);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteMacString() -                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteMacString(
    PWCHAR sz,
    BOOL fMacCP,
    BOOL fPascal
    )
{
    BYTE rgb[256];
    BYTE rgbExpand[256];
    BYTE* pb = rgb;
    BYTE* pbExpand = rgbExpand;
    int cch = 0;
    int cb = 0;

    if (sz != NULL)
    {
        UINT iCP;
        UINT nCP = uiCodePage;
        BOOL fAttemptTranslate = FALSE;
        static const UINT rgnCP[] = {10029, 10007, 10000, 10006, 10081};    // Mac codepages
        static BOOL rgfCP[5];

        // If the codepage for the current resource text is one of the Windows
        // Latin 1, Greek, Cyrillic, Turkish, or Eastern European codepages, then
        // there exists a corresponding Macintosh codepage in Win32 and it is valid
        // to use WCToMB to map the Windows text to the Macintosh character set. If
        // the Windows text is in a different code page, we don't try to do any
        // mapping.
        iCP = uiCodePage - 1250;
        if (fMacCP && uiCodePage >= 1250 && uiCodePage <= 1254) {
            nCP = rgnCP[iCP];

            // unfortunately the Mac code pages are not supported under Windows 95.
            // To handle this, we check to see if the Mac code page we came up
            // with is actually available, and if it isn't, revert back to uiCodePage.

            if ((rgfCP[iCP] & 0x01) == 0) {  // is this fCP still uninitialized?
                rgfCP[iCP] |= 0x01;     // bit 0 set: has been initialized
                if (IsValidCodePage(nCP))
                    rgfCP[iCP] |= 0x02;     // bit 1 set: this CP is available
            }

            if ((rgfCP[iCP] & 0x02) == 0) {
                nCP = uiCodePage;
                fAttemptTranslate = TRUE;
            }
        }

        cch = wcslen(sz);

        cb = WideCharToMultiByte(nCP, 0, sz, cch, NULL, 0, NULL, NULL);
        if (cb > sizeof(rgb))
            pb = (BYTE *) MyAlloc(cb);
        WideCharToMultiByte(nCP, 0, sz, cch, (LPSTR) pb, cb, NULL, NULL);

        // if the Mac code page we wanted isn't available, try using our hard-coded tables
        if (fAttemptTranslate)
            TranslateBuffer((LPSTR) pb, cb);
    }

    if (fPascal) {
        WriteByte((char)cb);
        WriteBuffer(rgb, (size_t) cb);
    } else {
        // at worst, we'll need one wide char for every single-byte char, plus a null terminator
        if (((cb + 1) * sizeof(WCHAR)) > sizeof(rgbExpand))
            pbExpand = (BYTE *) MyAlloc((cb + 1) * sizeof(WCHAR));

        cb = ExpandString(pb, cb, pbExpand);
        WriteBuffer(pbExpand, (size_t) cb);

        if (pbExpand != rgbExpand)
            MyFree(pbExpand);
    }

    if (pb != rgb)
        MyFree(pb);
}


const unsigned char *mpchchCodePage;

const unsigned char mpchchLatin1ToMac[128] = {
    0x3f, /* 0x80 */
    0x3f, /* 0x81 */
    0xe2, /* 0x82 */
    0xc4, /* 0x83 */
    0xe3, /* 0x84 */
    0xc9, /* 0x85 */
    0xa0, /* 0x86 */
    0xe0, /* 0x87 */
    0xf6, /* 0x88 */
    0xe4, /* 0x89 */
    0x3f, /* 0x8a */
    0xdc, /* 0x8b */
    0xce, /* 0x8c */
    0x3f, /* 0x8d */
    0x3f, /* 0x8e */
    0x3f, /* 0x8f */
    0x3f, /* 0x90 */
    0xd4, /* 0x91 */
    0xd5, /* 0x92 */
    0xd2, /* 0x93 */
    0xd3, /* 0x94 */
    0xa5, /* 0x95 */
    0xd0, /* 0x96 */
    0xd1, /* 0x97 */
    0xf7, /* 0x98 */
    0x84, /* 0x99 */
    0x3f, /* 0x9a */
    0xdd, /* 0x9b */
    0xcf, /* 0x9c */
    0x3f, /* 0x9d */
    0x3f, /* 0x9e */
    0xd9, /* 0x9f */
    0xca, /* 0xa0 */
    0xc1, /* 0xa1 */
    0xa2, /* 0xa2 */
    0xa3, /* 0xa3 */
    0xdb, /* 0xa4 */
    0xb4, /* 0xa5 */
    0x3f, /* 0xa6 */
    0xa4, /* 0xa7 */
    0xac, /* 0xa8 */
    0xa9, /* 0xa9 */
    0xbb, /* 0xaa */
    0xc7, /* 0xab */
    0xc2, /* 0xac */
    0x3f, /* 0xad */
    0xa8, /* 0xae */
    0x3f, /* 0xaf */
    0xa1, /* 0xb0 */
    0xb1, /* 0xb1 */
    0x3f, /* 0xb2 */
    0x3f, /* 0xb3 */
    0xab, /* 0xb4 */
    0xb5, /* 0xb5 */
    0xa6, /* 0xb6 */
    0xe1, /* 0xb7 */
    0xfc, /* 0xb8 */
    0x3f, /* 0xb9 */
    0xbc, /* 0xba */
    0xc8, /* 0xbb */
    0x3f, /* 0xbc */
    0x3f, /* 0xbd */
    0x3f, /* 0xbe */
    0xc0, /* 0xbf */
    0xcb, /* 0xc0 */
    0xe7, /* 0xc1 */
    0xe5, /* 0xc2 */
    0xcc, /* 0xc3 */
    0x80, /* 0xc4 */
    0x81, /* 0xc5 */
    0xae, /* 0xc6 */
    0x82, /* 0xc7 */
    0xe9, /* 0xc8 */
    0x83, /* 0xc9 */
    0xe6, /* 0x3f */
    0xe8, /* 0xcb */
    0xed, /* 0xcc */
    0xea, /* 0xcd */
    0xeb, /* 0xce */
    0xec, /* 0xcf */
    0x3f, /* 0xd0 */
    0x84, /* 0xd1 */
    0xf1, /* 0xd2 */
    0xee, /* 0xd3 */
    0xef, /* 0xd4 */
    0xcd, /* 0xd5 */
    0x85, /* 0xd6 */
    0x3f, /* 0xd7 */
    0xaf, /* 0xd8 */
    0x84, /* 0xd9 */
    0xf2, /* 0xda */
    0xf3, /* 0xdb */
    0x86, /* 0xdc */
    0x3f, /* 0xdd */
    0x3f, /* 0xde */
    0xa7, /* 0xdf */
    0x88, /* 0xe0 */
    0x87, /* 0xe1 */
    0x89, /* 0xe2 */
    0x8b, /* 0xe3 */
    0x8a, /* 0xe4 */
    0x8c, /* 0xe5 */
    0xbe, /* 0xe6 */
    0x8d, /* 0xe7 */
    0x8f, /* 0xe8 */
    0x8e, /* 0xe9 */
    0x90, /* 0xea */
    0x91, /* 0xeb */
    0x93, /* 0xec */
    0x92, /* 0xed */
    0x94, /* 0xee */
    0x95, /* 0xef */
    0x3f, /* 0xf0 */
    0x96, /* 0xf1 */
    0x98, /* 0xf2 */
    0x97, /* 0xf3 */
    0x99, /* 0xf4 */
    0x9b, /* 0xf5 */
    0x9a, /* 0xf6 */
    0xd6, /* 0xf7 */
    0xbf, /* 0xf8 */
    0x9d, /* 0xf9 */
    0x9c, /* 0xfa */
    0x9e, /* 0xfb */
    0x9f, /* 0xfc */
    0x3f, /* 0xfd */
    0x3f, /* 0xfe */
    0xd8, /* 0xff */
};

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  BuildCodePage() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
BuildCodePage(
    int cp
    )
{
    mpchchCodePage = cp == 1252 ? mpchchLatin1ToMac : NULL;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  TranslateString() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
TranslateString(
    char* sz
    )
{
    TranslateBuffer(sz, strlen(sz)+1);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  TranslateBuffer() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
TranslateBuffer(
    char* rgch,
    int cch
    )
{
    if (mpchchCodePage == NULL)
        BuildCodePage(uiCodePage);

    if (mpchchCodePage == NULL)
        return;

    for (NULL; cch > 0; rgch++, cch--)
        if (*rgch & 0x80)
            *rgch = (char) mpchchCodePage[(unsigned char)(*rgch-0x80)];
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ExpandString() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
int
ExpandString(
    BYTE* pb,
    int cb,
    BYTE* pbExpand
    )
{
    int cbWide = 2; // for null terminator

    while (cb > 0) {
        if (IsDBCSLeadByteEx(uiCodePage, *pb)) {
            *pbExpand++ = *pb++;
            cb--;
        } else {
            *pbExpand++ = 0;
        }

        *pbExpand++ = *pb++;
        cbWide += 2;
        cb--;
    }

    *(WORD*) pbExpand++ = L'\0';
    return cbWide;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  AppendString() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
AppendString(
    PWCHAR sz,
    BOOL fMacCP
    )
{
    PWCHAR psz;

    /* add a string to the resource buffer */
    psz = (PWCHAR) (&CodeArray[CCount]);
    if (*(psz-1) == L'\0')
        CCount -= sizeof(WCHAR);
    WriteString(sz, fMacCP);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteAlign() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteAlign(
    VOID
    )
{
    WORD    i = CCount % 4;

    while (i--)
        WriteByte(0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteBuffer() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void WriteBuffer(const void *pv, size_t cb)
{
    const BYTE *pb = (BYTE *) pv;

    while (cb--) {
        WriteByte(*pb++);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/* WriteControl() -                                                         */
/*                                                                          */
/*  Parameters:                                                             */
/*      outfh  : The handle of the RES file.                                */
/*      Array  : Pointer to array from which some data is to be copied into */
/*               the .RES file.                                             */
/*               This is ignored if ArrayCount is zero.                     */
/*      ArrayCount : This is the number of bytes to be copied from "Array"  */
/*                   into the .RES file. This is zero if no copy is required*/
/*      FileCount  : This specifies the number of bytes to be copied from   */
/*                   fhCode into fhOut. If this is -1, the complete input   */
/*                   file is to be copied into fhOut.                       */
/**/
/**/

int
WriteControl(
    PFILE outfh,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{

    /* Check if the Array is to be written to .RES file */
    if (ArrayCount > 0)
        /* write the array (resource) to .RES file */
        MyWrite(outfh, Array, ArrayCount);

    /* copy the extra input file - opened by generator functions */
    if (fhCode != NULL_FILE) {
        /* Check if the complete input file is to be copied or not */
        if (FileCount == -1) {
            MyCopyAll(fhCode, outfh);
            fclose(fhCode);
        } else {
            /* Only a part of the input file is to be copied */
            MyCopy(fhCode, outfh, FileCount);

            /* Note that the fhCode is NOT closed in this case */
        }
    }

    return(ArrayCount);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ResourceSize() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

LONG
ResourceSize (
    VOID
    )
{
    if (fhCode == NULL_FILE)
        return (LONG)CCount;            /* return size of array */
    else {
        /* note: currently all resources that use the fhCode file
         * compute their own resource sizes, and this shouldn't get
         * executed, but it is here in case of future modifications
         * which require it.
         */
        LONG lFPos = MySeek(fhCode, 0L, SEEK_CUR);
        LONG lcb = (LONG)CCount + MySeek(fhCode, 0L, SEEK_END) - lFPos;
        MySeek(fhCode, lFPos, SEEK_SET);
        return lcb;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetIcon() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

DWORD
GetIcon(
    LONG nbyFile
    )
{
    PFILE      infh = CtlFile(NULL_FILE);

    IconHeader header;
    LONG    nbyIconSize, nSeekLoc;
    LONG    nbyTransferred = 0;
    SHORT   IconID;
    int bHeaderWritten = FALSE;

    if (infh == NULL)
        return FALSE;
    /* read the header and find its size */
    if (!MyRead( infh, &IconID, sizeof(SHORT))) {
        GenError2(2169, tokenbuf); //"Resource file %ws is not in 2.03 format."
        return FALSE;
    }

    /* Check if the input file is in correct format */
    if (((CHAR)IconID != 1) && ((CHAR)IconID != 3))
        GenError2(2169, tokenbuf); //"Resource file %ws is not in 2.03 format."

    if (!MyRead( infh, &header, sizeof(IconHeader))) {
        GenError2(2169, tokenbuf); //"Resource file %ws is not in 2.03 format."
        return FALSE;
    }
    nbyIconSize = (header.csWidthBytes * 2) * header.csHeight;

    /* if pre-shrunk version exists at eof */
    if ((nSeekLoc = ( sizeof (SHORT) + nbyIconSize + sizeof(IconHeader))) < nbyFile) {
        /* mark as device dependant */
        *(((PCHAR)&IconID) + 1) = 0;
        MySeek(infh, (LONG)nSeekLoc, SEEK_SET);
        WriteWord(IconID);
    } else {   /* only canonical version exists */

        *(((PCHAR)&IconID) + 1) = 1;   /* mark as device independent */
        WriteWord(IconID);
        WriteBuffer(&header, sizeof(IconHeader));
        bHeaderWritten = TRUE;
    }

    nbyTransferred = nbyFile - MySeek(infh, 0L, SEEK_CUR);

    /* return number of bytes in the temporary file */
    return (nbyTransferred + (bHeaderWritten ? sizeof(IconHeader) : 0)
         + sizeof(SHORT));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNewBitmap() -                                                        */
/*                                                                          */
/*   This loads the new bitmaps in DIB format (PM format)                   */
/*--------------------------------------------------------------------------*/

DWORD
GetNewBitmap(
    VOID
    )
{
    PFILE infh = CtlFile(NULL_FILE);
    BITMAPFILEHEADER bf;
    BITMAPCOREHEADER bc;
    BITMAPINFOHEADER *pBitMapInfo;
    int cbColorTable;
    PCHAR pColorTable;
    LONG        cbImage;
    int nbits;
    DWORD BitmapSize;

    if (infh == NULL)
        return FALSE;

    MyRead(infh, &bf, sizeof(bf));

    /* Check if it is in correct format */
    if (bf.bfType != DIBBITMAPFORMAT)
        GenError2(2170, tokenbuf); //"Bitmap file %ws is not in 3.00 format."

    /* get the header -- assume old format */
    MyRead(infh, &bc, sizeof(bc));

    BitmapSize = bc.bcSize;

    if (BitmapSize >= sizeof(BITMAPINFOHEADER)) {
        /* V3 or better format */
        pBitMapInfo = (BITMAPINFOHEADER *) MyAlloc(BitmapSize);

        memcpy(pBitMapInfo, &bc, sizeof(bc));

        MyRead(infh, ((PCHAR)pBitMapInfo) + sizeof(bc), BitmapSize - sizeof(bc));

        nbits = pBitMapInfo->biPlanes * pBitMapInfo->biBitCount;

        if ( pBitMapInfo->biCompression == BI_BITFIELDS ) {
            if( (pBitMapInfo->biBitCount <= 8) ||
                (pBitMapInfo->biBitCount == 24) )
            {
                GenError2(2170, tokenbuf); //"Bitmap file %ws is not in 3.00 format."
            }

            cbColorTable = 3 * sizeof(DWORD);
        } else {
            // Only pBitMapInfo->biBitCount 1,4,8,24. biBitCount 16 and 32 MUST have BI_BITFIELD specified
            cbColorTable = (int)pBitMapInfo->biClrUsed * sizeof(RGBQUAD);
            if ((cbColorTable  == 0) && (pBitMapInfo->biBitCount<=8))
                cbColorTable = (1 << nbits) * sizeof(RGBQUAD);
        }

        if (fMacRsrcs) {
            pBitMapInfo->biSize = SwapLong(pBitMapInfo->biSize);
            pBitMapInfo->biWidth = SwapLong(pBitMapInfo->biWidth);
            pBitMapInfo->biHeight = SwapLong(pBitMapInfo->biHeight);
            pBitMapInfo->biPlanes = SwapWord(pBitMapInfo->biPlanes);
            pBitMapInfo->biBitCount = SwapWord(pBitMapInfo->biBitCount);
            pBitMapInfo->biCompression = SwapLong(pBitMapInfo->biCompression);
            pBitMapInfo->biSizeImage = SwapLong(pBitMapInfo->biSizeImage);
            pBitMapInfo->biXPelsPerMeter = SwapLong(pBitMapInfo->biXPelsPerMeter);
            pBitMapInfo->biYPelsPerMeter = SwapLong(pBitMapInfo->biYPelsPerMeter);
            pBitMapInfo->biClrUsed = SwapLong(pBitMapInfo->biClrUsed);
            pBitMapInfo->biClrImportant = SwapLong(pBitMapInfo->biClrImportant);
        }
        WriteBuffer(pBitMapInfo, BitmapSize);
        MyFree(pBitMapInfo);
    } else if (BitmapSize == sizeof(BITMAPCOREHEADER)) {
        nbits = bc.bcPlanes * bc.bcBitCount;

        /* old format */
        if (nbits == 24)
            cbColorTable = 0;
        else
            cbColorTable = (1 << nbits) * sizeof(RGBTRIPLE);

        if (fMacRsrcs) {
            bc.bcSize = SwapLong(bc.bcSize);
            bc.bcWidth = SwapWord(bc.bcWidth);
            bc.bcHeight = SwapWord(bc.bcHeight);
            bc.bcPlanes = SwapWord(bc.bcPlanes);
            bc.bcBitCount = SwapWord(bc.bcBitCount);
        }
        WriteBuffer(&bc, BitmapSize);
    } else {
        GenError1(2171); //"Unknown DIB header format"
    }

    if (cbColorTable) {
        pColorTable = (PCHAR) MyAlloc(cbColorTable);
        MyRead(infh, pColorTable, cbColorTable);
        WriteBuffer(pColorTable, cbColorTable);
        MyFree(pColorTable);
    }

    /* get the length of the bits */
    cbImage = MySeek(infh, 0L, SEEK_END) - BFOFFBITS(&bf) + BitmapSize + cbColorTable;

    /* seek to the beginning of the bits... */
    MySeek(infh, BFOFFBITS(&bf), SEEK_SET);

    return cbImage;
}

VOID
WriteOrdCode(
    void
    )
{
    WriteWord(0xFFFF);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SetUpDlg() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
SetUpDlg(
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    if (fDlgEx) {
        // Hack -- this is how we version switch the dialog
        WriteWord(0x0001);          // store wDlgVer
        WriteWord(0xFFFF);          // store wSignature
        WriteLong(pDlg->dwHelpID);
        WriteLong(pDlg->dwExStyle); // store exstyle
    }

    /* write the style bits to the resource buffer */
    WriteLong(pDlg->dwStyle);   /* store style */

    if (!fDlgEx)
        WriteLong(pDlg->dwExStyle);   /* store exstyle */

    ItemCountLoc = CCount;        /* global marker for location of item cnt. */

    /* skip place for num of items */
    WriteWord(0);

    /* output the dialog position and size */
    WriteWord(pDlg->x);
    WriteWord(pDlg->y);
    WriteWord(pDlg->cx);
    WriteWord(pDlg->cy);

    /* output the menu identifier */
    if (pDlg->fOrdinalMenu) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(pDlg->MenuName));
    } else {
        WriteString(pDlg->MenuName, FALSE);
    }

    /* output the class identifier */
    if (pDlg->fClassOrdinal) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(pDlg->Class));
    } else {
        WriteString(pDlg->Class, FALSE);
    }

    /* output the title */
    WriteString(pDlg->Title, TRUE);

    /* add the font information */
    if (pDlg->pointsize) {
        WriteWord(pDlg->pointsize);
        if (fDlgEx) {
            WriteWord(pDlg->wWeight);
            WriteByte(pDlg->bItalic);
            WriteByte(pDlg->bCharSet);
        }
        WriteString(pDlg->Font, FALSE);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SetUpItem() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
SetUpItem(
    PCTRL LocCtl,
    BOOL fDlgEx
    )
{
    PWCHAR  tempptr;

    /* control dimensions, id, and style bits */
    WriteAlign();

    // control dimensions, id, and style bits
    if (fDlgEx) {
        WriteLong(LocCtl->dwHelpID);
        WriteLong(LocCtl->dwExStyle);
        WriteLong(LocCtl->dwStyle);
    } else {
        WriteLong(LocCtl->dwStyle);
        WriteLong(LocCtl->dwExStyle);
    }

    WriteWord(LocCtl->x);
    WriteWord(LocCtl->y);
    WriteWord(LocCtl->cx);
    WriteWord(LocCtl->cy);

    if (fDlgEx)
        WriteLong(LocCtl->id);
    else
        WriteWord(LOWORD(LocCtl->id));

    /* control class */
    tempptr = LocCtl->Class;
    if (*tempptr == 0xFFFF) {
        /* special class code follows */
        WriteWord(*tempptr++);
        WriteWord(*tempptr++);
    } else {
        WriteString(tempptr, FALSE);
    }

    /* text */
    if (LocCtl->fOrdinalText) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(LocCtl->text));
    } else {
        WriteString(LocCtl->text, TRUE);
    }

    if (fDlgEx)
        ItemExtraLoc = CCount;

    WriteWord(0);   /* zero CreateParams count */

    IncItemCount();

}


void
SetItemExtraCount(
    WORD wCount,
    BOOL fDlgEx
    )
{
    if (fDlgEx)
        *((WORD *) (CodeArray + ItemExtraLoc)) = wCount;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IncItemCount() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* seemingly obscure way to increment # of items in a dialog */
/* ItemCountLoc indexes where we put the item count in the resource buffer, */
/* so we increment that counter when we add a control */

VOID
IncItemCount(
    VOID
    )
{
    PUSHORT     pus;

    pus = (PUSHORT)&CodeArray[ItemCountLoc];
    (*pus)++;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SwapItemCount() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* when writing a Mac resource fork, we need to swap this count before writing */
VOID
SwapItemCount(
    VOID
    )
{
    PUSHORT     pus;

    pus = (PUSHORT)&CodeArray[ItemCountLoc];
    *pus = SwapWord(*pus);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FixMenuPatch() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
FixMenuPatch(
    WORD wEndFlagLoc
    )
{
    if (fMacRsrcs)
        CodeArray[wEndFlagLoc + 1] |= MFR_END;
    else
        *((PWORD) (CodeArray + wEndFlagLoc)) |= MFR_END;
    // mark last menu item
//    CodeArray[wEndFlagLoc] |= MFR_END;
}


VOID
FixOldMenuPatch(
    WORD wEndFlagLoc
    )
{
    // mark last menu item
    if (fMacRsrcs)
        CodeArray[wEndFlagLoc + 1] |= OPENDMENU;
    else
        CodeArray[wEndFlagLoc] |= OPENDMENU;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MarkAccelFlagsByte() -                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* set the place where the accel end bit is going to be set */

VOID
MarkAccelFlagsByte (
    VOID
    )
{
    /* set the location to the current position in the resource buffer */
    mnEndFlagLoc = CCount;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  PatchAccelEnd() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
PatchAccelEnd (
    VOID
    )
{
    if (fMacRsrcs)
        CodeArray[mnEndFlagLoc + 1] |= 0x80;
    else
        CodeArray[mnEndFlagLoc] |= 0x80;
}


// ----------------------------------------------------------------------------
//
//  SetUpMenu() -
//
// ----------------------------------------------------------------------------

WORD
SetUpMenu(
    PMENU pmn
    )
{
    WORD    wRes;

    WriteLong(pmn->dwType);
    WriteLong(pmn->dwState);
    WriteLong(pmn->dwID);

    // mark the last item added to the menu
    wRes = (WORD)CCount;

    WriteWord(pmn->wResInfo);
    WriteString(pmn->szText, TRUE);
    if (32)
        WriteAlign();
    if (pmn->wResInfo & MFR_POPUP)
        WriteLong(pmn->dwHelpID);

    return(wRes);
}


// ----------------------------------------------------------------------------
//
//  SetUpOldMenu() -
//
// ----------------------------------------------------------------------------

WORD
SetUpOldMenu(
    PMENUITEM mnTemp
    )
{
    WORD    wRes;

    /* mark the last item added to the menu */
    wRes = (WORD)CCount;

    /* write the menu flags */
    WriteWord(mnTemp->OptFlags);

    /* popup menus don't have id values */
    /* write ids of menuitems */
    if (!((mnTemp->OptFlags) & OPPOPUP))
        WriteWord(mnTemp->id);

    /* write text of selection */
    WriteString(mnTemp->szText, TRUE);

    return(wRes);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetRCData() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WORD
GetRCData (
    PRESINFO pRes
    )
{
    PCHAR       pch, pchT;
    PWCHAR      pwch;
    WORD        nBytes = 0;
    ULONG       cb = 0;

    /* look for BEGIN (after id RCDATA memflags) */
    // 2134 -- "BEGIN expected in RCData"
    PreBeginParse(pRes, 2134);

    /* add the users data to the resource buffer until we see an END */
    while (token.type != END) {
    /* see explanation in rcl.c in GetStr() */
        if (token.type == LSTRLIT)
            token.type = token.realtype;

        switch (token.type) {
            case LSTRLIT:
                pwch = tokenbuf;
                while (token.val--) {
                    WriteWord(*pwch++);
                    nBytes += sizeof(WCHAR);
                }
                break;

            case STRLIT:
                cb = WideCharToMultiByte(uiCodePage, 0, tokenbuf,
                                            token.val, NULL, 0, NULL, NULL);
                pchT = pch = (PCHAR) MyAlloc(cb);
                WideCharToMultiByte(uiCodePage, 0, tokenbuf,
                                            token.val, pch, cb, NULL, NULL);
                while (cb--) {
                    WriteByte(*pch++);
                    nBytes += sizeof(CHAR);
                }
                MyFree(pchT);
                break;

            case NUMLIT:
                if (token.flongval) {
                    WriteLong(token.longval);
                    nBytes += sizeof(LONG);
                } else {
                    WriteWord(token.val);
                    nBytes += sizeof(WORD);
                }
                break;

            default:
                ParseError1(2164);
                return 0;
        }
        ICGetTok();
    }

    return(nBytes);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  AddFontRes() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL
AddFontRes(
    PRESINFO pRes
    )
{
    PFILE    fpFont;
    BYTE     font[FONT_ALL];
    PCHAR    pEnd, pDev, pFace;
    DWORD    offset;
    SHORT    nbyFont;
    PFONTDIR pFont;
    PFONTDIR pFontSearch;

    /* get handle to font file */
    fpFont = CtlFile(NULL_FILE);
    if (fpFont == NULL)
        return FALSE;
    MySeek(fpFont, 0L, SEEK_SET);

    /* copy font information to the font directory */
    /*    name strings are ANSI (8-bit) */
    MyRead(fpFont, &font[0], sizeof(ffh));
    pEnd = (PCHAR) (&font[0] + sizeof(ffh));    /* pointer to end of font buffer */
    offset = ((ffh * )(&font[0]))->dfDevice;
    if (offset != (LONG)0)  {
        MySeek(fpFont, (LONG)offset, SEEK_SET);        /* seek to device name */
        pDev = pEnd;
        do {
            MyRead(fpFont, pEnd, 1);              /* copy device name */
        } while (*pEnd++);
    } else {
        (*pEnd++ = '\0');
    }
    offset = ((ffh * )(&font[0]))->dfFace;
    MySeek(fpFont, (LONG)offset, SEEK_SET);         /* seek to face name */
    pFace = pEnd;
    do {                                /* copy face name */
        MyRead(fpFont, pEnd, 1);
    } while (*pEnd++);

    nbyFont = (SHORT)(pEnd - (PCHAR) &font[0]);

    pFont = (FONTDIR * )MyAlloc(sizeof(FONTDIR) + nbyFont);
    pFont->nbyFont = nbyFont;
    pFont->ordinal = pRes->nameord;
    pFont->next = NULL;
    memcpy((PCHAR)(pFont + 1), (PCHAR)font, nbyFont);

    if (!nFontsRead) {
        pFontList = pFontLast = pFont;
    } else {
        for (pFontSearch=pFontList ; pFontSearch!=NULL ; pFontSearch=pFontSearch->next) {
            if (pFont->ordinal == pFontSearch->ordinal) {
                SET_MSG(2181, curFile, token.row, pFont->ordinal);
                SendError(Msg_Text);
                MyFree(pFont);
                return FALSE;
            }
        }
        pFontLast = pFontLast->next = pFont;
    }

    /* rewind font file for SaveResFile() */
    MySeek(fpFont, 0L, SEEK_SET);
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveResFile() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/


VOID
SaveResFile(
    PTYPEINFO pType,
    PRESINFO pRes
    )
{
    if (!fMacRsrcs)
        MyAlign(fhBin);

    AddResToResFile(pType, pRes, CodeArray, CCount, -1L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNewIconsCursors(ResType)                                     */
/*                                                                          */
/*      This reads all the different forms of icons/cursors in 3.00 format  */
/*      in the input file                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetNewIconsCursors(
    PTYPEINFO pGroupType,
    PRESINFO pGroupRes,
    LPWSTR ResType
    )
{
    static SHORT  idIconUnique = 1;
    UINT          i;
    LONG          DescOffset;
    PTYPEINFO     pType;
    PRESINFO      pRes;
    NEWHEADER     NewHeader;
    DESCRIPTOR    Descriptor;
    BITMAPHEADER  BitMapHeader;
    RESDIR        ResDir;
    int           ArrayCount = 0;
    LOCALHEADER   LocHeader;

    /* Read the header of the bitmap file */
    MyRead(fhCode, &NewHeader, sizeof(NEWHEADER));

    /* Check if the file is in correct format */
    if ((NewHeader.Reserved != 0) || ((NewHeader.ResType != 1) && (NewHeader.ResType != 2)))
        GenError2(2175, tokenbuf); //"Resource file %ws is not in 3.00 format."
    /* Write the header into the Code array */
    WriteBuffer(&NewHeader, sizeof(NEWHEADER));

    /* Process all the forms one by one */
    for (i = 0; i < NewHeader.ResCount; i++) {
        /* Readin the Descriptor */
        MyRead(fhCode, &Descriptor, sizeof(DESCRIPTOR));

        /* Save the current offset */
        DescOffset = MySeek(fhCode, 0L, SEEK_CUR);

        /* Seek to the Data */
        MySeek(fhCode, Descriptor.OffsetToBits, SEEK_SET);

        /* Get the bitcount and Planes data */
        MyRead(fhCode, &BitMapHeader, sizeof(BITMAPHEADER));
        if (BitMapHeader.biSize != sizeof(BITMAPHEADER))
            GenError2(2176, tokenbuf); //"Old DIB in %ws.  Pass it through SDKPAINT."

        ResDir.BitCount = BitMapHeader.biBitCount;
        ResDir.Planes = BitMapHeader.biPlanes;

        /* Seek to the Data */
        MySeek(fhCode, Descriptor.OffsetToBits, SEEK_SET);

        ArrayCount = 0;

        /* fill the fields of ResDir and LocHeader */
        switch (NewHeader.ResType) {
            case CURSORTYPE:

                LocHeader.xHotSpot = Descriptor.xHotSpot;
                LocHeader.yHotSpot = Descriptor.yHotSpot;
                ArrayCount = sizeof(LOCALHEADER);

                ResDir.ResInfo.Cursor.Width = (USHORT)BitMapHeader.biWidth;
                ResDir.ResInfo.Cursor.Height = (USHORT)BitMapHeader.biHeight;

                break;

            case ICONTYPE:

                ResDir.ResInfo.Icon.Width = Descriptor.Width;
                ResDir.ResInfo.Icon.Height = Descriptor.Height;
                ResDir.ResInfo.Icon.ColorCount = Descriptor.ColorCount;
                /* The following line is added to initialise the unused
                 * field "reserved".
                 * Fix for Bug #10382 --SANKAR-- 03-14-90
                 */
                ResDir.ResInfo.Icon.reserved = Descriptor.reserved;
                break;

        }

        ResDir.BytesInRes = Descriptor.BytesInRes + ArrayCount;


        /* Create a pRes with New name */
        pRes = (PRESINFO) MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;
        pRes ->name = NULL;
        pRes ->nameord = idIconUnique++;

        /* The individual resources must have the same memory flags as the
            ** group.
            */
        pRes ->flags = pGroupRes ->flags;
        pRes ->size = Descriptor.BytesInRes + ArrayCount;

        /* Create a new pType, or find existing one */
        pType = AddResType(NULL, ResType);


        /* Put Resource Directory entry in CodeArray */
        WriteBuffer(&ResDir, sizeof(RESDIR));

        /*
         * Write the resource name ordinal.
         */
        WriteWord(pRes->nameord);

        MyAlign(fhBin);

        AddResToResFile(pType, pRes, (PCHAR)&LocHeader, ArrayCount,
            Descriptor.BytesInRes);

        /* Seek to the Next Descriptor */
        MySeek(fhCode, DescOffset, SEEK_SET);
    }

    pGroupRes ->size = sizeof(NEWHEADER) + NewHeader.ResCount * (sizeof(RESDIR) + sizeof(SHORT));

    /* If the group resource is marked as PRELOAD, then we should use
        ** the same flags. Otherwise, mark it as DISCARDABLE
        */
    if (!(pGroupRes ->flags & NSPRELOAD))
        pGroupRes ->flags = NSMOVE | NSPURE | NSDISCARD;

    /* Close the input file, nothing more to read */
    fclose(fhCode);
    fhCode = NULL_FILE;

    /* Copy the code array into RES file for Group items */
    SaveResFile(pGroupType, pGroupRes);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FileIsAnimated(LONG nbyFile)                                            */
/*                                                                          */
/*  This function checks to see if the file we have is 3.0 icon/cursor file */
/*  or an animated icon/cursor.                                             */
/*                                                                          */
/*  Returns RT_* of filetype.                                               */
/*--------------------------------------------------------------------------*/

DWORD
FileIsAnimated(
    LONG nbyFile
    )
{
    RTAG tag;
    LONG lRead;

    lRead = MyRead(fhCode, &tag, sizeof(RTAG));
    MySeek(fhCode, 0L, SEEK_SET);             /* return to start of file */
    if (lRead != sizeof(RTAG))
        return FALSE;

    return tag.ckID == FOURCC_RIFF;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetAniIconsAniCursors(ResType)                                          */
/*                                                                          */
/*  This function check if the file we have is a valid animated icon.       */
/*  All the work performed here is purelly optional and is done to make     */
/*  sure that the image we write in the res file is in the proper format.   */
/*  Just returning the nbyFile would be enough to copy the file in the res  */
/*  file.                                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD
GetAniIconsAniCursors(
    LONG nbyFile
    )
{
    RTAG tag;
    LONG lRead = nbyFile;

    /* Check if we have a RIFF file */
    lRead -= MyRead(fhCode, &tag, sizeof(RTAG));

    if( tag.ckID!=FOURCC_RIFF )
        GenError2(2173, tokenbuf);

    /* Read the next chunk */
    lRead -= MyRead(fhCode, &tag.ckID, sizeof(tag.ckID));
    if( tag.ckID!=FOURCC_ACON )
        GenError2(2173, tokenbuf);

    /* so we have an animated icon file, make sure all the blocks are there */
    while( MyRead(fhCode, &tag, sizeof(RTAG)) ) {
        lRead -= sizeof(RTAG)+tag.ckSize;
        MySeek(fhCode, tag.ckSize, SEEK_CUR);
    }

    if( lRead!=0 )
        GenError2(2173, tokenbuf);

    /*
     * Now that we are sure this is a valid file, move the
     * file pointer back at the begining of the file.
     */
    MySeek(fhCode, 0L, SEEK_SET);

    return nbyFile;
}

/*  GetBufferLen
 *      Returns the current length of the buffer
 */

WORD
GetBufferLen(
    VOID
    )
{
    return (WORD)CCount;
}


USHORT
GetItemCount(
    int Index
    )
{
    return *((USHORT UNALIGNED*)(CodeArray + Index));
}

void
SetItemCount(
    int Index,
    USHORT wCount
    )
{
    *((USHORT UNALIGNED*)(CodeArray + Index)) = wCount;
}

DWORD
SwapLong(
    DWORD dw
    )
{
    return ((dw << 24) & 0xff000000L) |
    ((dw << 8) & 0x00ff0000L) |
    ((dw >> 8) & 0x0000ff00L) |
    ((dw >> 24) & 0x000000ffL);
}

WORD
SwapWord(
    WORD w
    )
{
    return ((w << 8) & 0xff00) |
        ((w >> 8) & 0x00ff);
}

enum {
    itNone = -1,

    itIcn_ = 0,
    itIcl4 = 1,
    itIcl8 = 2,

    itIcs_ = 3,
    itIcs4 = 4,
    itIcs8 = 5,

    itIcm_ = 6,
    itIcm4 = 7,
    itIcm8 = 8,

    itMax = 9
};

static DWORD mpitres[itMax] = {
    'ICN#',
    'icl4',
    'icl8',
    'ics#',
    'ics4',
    'ics8',
    'icm#',
    'icm4',
    'icm8'
};

enum {
    fitIcn_ = 1 << itIcn_,
    fitIcl4 = 1 << itIcl4,
    fitIcl8 = 1 << itIcl8,

    fitIcs_ = 1 << itIcs_,
    fitIcs4 = 1 << itIcs4,
    fitIcs8 = 1 << itIcs8,

    fitIcm_ = 1 << itIcm_,
    fitIcm4 = 1 << itIcm4,
    fitIcm8 = 1 << itIcm8
};

void
GetMacIcon(
    TYPEINFO *pType,
    RESINFO *pRes
    )
{
    struct tagNEWHEADER gh;
    struct tagDESCRIPTOR ds;
    BITMAPINFOHEADER bmh;
    int ibDescNext;
    int mpitib[itMax];
    int it;
    int ires;
    int fitFound;

    /* The input file has already been opened; read in the bitmap file header */

    MyRead(fhCode, &gh, sizeof(struct tagNEWHEADER));
    if (gh.Reserved != 0 || gh.ResType != 1)
        GenError2(2175, tokenbuf);

    /* run through all the icons, keeping track of the useful ones */

    memset(mpitib, 0, sizeof(mpitib));
    ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);
    fitFound = 0;
    for (ires = 0; ires < gh.ResCount; ires++) {
        /* Read in the descriptor */

        MySeek(fhCode, ibDescNext, SEEK_SET);
        MyRead(fhCode, &ds, sizeof(struct tagDESCRIPTOR));
        ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);

        /* get bitmap header */

        MySeek(fhCode, ds.OffsetToBits, SEEK_SET);
        MyRead(fhCode, &bmh, sizeof(BITMAPINFOHEADER));
        if (bmh.biSize != sizeof(BITMAPINFOHEADER))
            GenError2(2176, tokenbuf);

        /* find valid color cases */

        if (bmh.biPlanes != 1)
            continue;
        if (bmh.biBitCount == 1)
            it = itIcn_;
        else if (bmh.biBitCount == 4)
            it = itIcl4;
        else if (bmh.biBitCount == 8)
            it = itIcl8;
        else
            continue;

        /* find valid sizes */

        if (bmh.biWidth == 16 && bmh.biHeight == 24)
            it += itIcm_ - itIcn_;
        else if (bmh.biWidth == 16 && bmh.biHeight == 32)
            it += itIcs_ - itIcn_;
        else if (bmh.biWidth == 32 && bmh.biHeight == 64)
            it += itIcn_ - itIcn_;
        else
            continue;

        /* mark sizes we found */

        fitFound |= 1 << it;
        mpitib[it] = ibDescNext - sizeof(struct tagDESCRIPTOR);
    }

    /* if no usable icon found, bail out */

    if (fitFound == 0) {
        GenWarning2(4508, tokenbuf);
    } else {
        if (fitFound & (fitIcn_|fitIcl4|fitIcl8))
            ProcessMacIcons(pRes, itIcn_, mpitib[itIcn_], mpitib[itIcl4], mpitib[itIcl8]);
        if (fitFound & (fitIcs_|fitIcs4|fitIcs8))
            ProcessMacIcons(pRes, itIcs_, mpitib[itIcs_], mpitib[itIcs4], mpitib[itIcs8]);
        if (fitFound & (fitIcm_|fitIcm4|fitIcm8))
            ProcessMacIcons(pRes, itIcm_, mpitib[itIcs_], mpitib[itIcs4], mpitib[itIcs8]);
    }

    fclose(fhCode);
    fhCode = NULL_FILE;
}


int
Luminance(
    const RGBColor* prgb
    )
{
    return prgb->red/256*30 + prgb->green/256*59 + prgb->blue/256*11;
}

/* threshold = middle gray */

#define rThreshold 128
#define gThreshold 128
#define bThreshold 128
int lumThreshold = rThreshold*30 + gThreshold*59 + bThreshold*11;


void
ProcessMacIcons(
    RESINFO* pResBase,
    int itBase,
    int ib1,
    int ib4,
    int ib8
    )
{
    BITMAPINFOHEADER bmh;
    RGBQUAD* rgq;
    struct tagDESCRIPTOR ds;
    BYTE* pBits;
    int cbWidth, cbMask;
    int cbBits;
    int ib, iq;
    int y;
    BYTE *pbIn;
    BYTE* pbOut;
    BYTE bIn = 0, bOut;

    /* create monochrome icon out of the best-looking icon */

    if (ib1 != 0) {
        /* read the DIB */

        ReadDIB(ib1, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* invert bits, if color table is backwards */

        if (rgq[0].rgbReserved != 0)
            for (ib = cbWidth*bmh.biHeight/2; --ib >= 0; )
                pBits[ib] ^= 0xff;
    } else if (ib4 != 0) {
        /* read the DIB and create color-to-mono color mapping */

        ReadDIB(ib4, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);
        for (iq = 0; iq < (int)bmh.biClrUsed; iq++)
            rgq[iq].rgbReserved =
                    Luminance(&rgcs16[rgq[iq].rgbReserved].rgb) < lumThreshold;

        /* map colors to black and white and convert to 1-bit/pixel */

        for (y = 0; y < (int)(bmh.biHeight/2); y++) {
            pbIn = pBits + y*cbWidth;
            pbOut = pbIn;
            assert(cbWidth % 4 == 0);   // we know it's 8 or 16 bytes wide
            for (ib = 0; ib < cbWidth; ) {
                bIn = *pbIn++;
                bOut = (bOut<<1) | rgq[bIn>>4].rgbReserved;
                bOut = (bOut<<1) | rgq[bIn&0xf].rgbReserved;
                ib++;
                if (ib % 4 == 0)
                    *pbOut++ = bOut;
            }
        }
    } else {
        /* read the DIB and create color-to-mono color mapping */

        ReadDIB(ib8, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);
        for (iq = 0; iq < (int)bmh.biClrUsed; iq++)
            rgq[iq].rgbReserved =
                    Luminance(&rgcs256[rgq[iq].rgbReserved].rgb) < lumThreshold;

        /* map colors to black and white and convert to 1-bit/pixel */

        for (y = 0; y < (int)(bmh.biHeight/2); y++) {
            pbIn = pBits + y*cbWidth;
            pbOut = pbIn;
            assert(cbWidth % 8 == 0);   // we know it's 16 or 32 bytes wide
            for (ib = 0; ib < cbWidth; ) {
                bIn = *pbIn++;
                bOut = (bOut<<1) | rgq[bIn].rgbReserved;
                ib++;
                if (ib % 8 == 0)
                    *pbOut++ = bOut;
            }
        }
    }

    cbMask = (bmh.biWidth+31)/32*4;
    CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth/8, bmh.biWidth/8, bmh.biHeight/2);
    cbBits = bmh.biHeight * (bmh.biWidth/8);

    /* "xor" the mask back into image */
    pbOut = pBits; pbIn = pBits + cbBits/2;
    for (ib = cbBits/2; ib > 0; ib--)
        *pbOut++ ^= ~*pbIn++;

    /* and write out base icon */

    WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase]);
    MyFree(pBits);
    MyFree(rgq);

    /* move over 16-color icon */

    if (ib4 != 0) {
        ReadDIB(ib4, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* convert color table to mac standard palette */

        for (pbIn = pBits, ib = cbWidth*bmh.biHeight/2; ib > 0; pbIn++, ib--) {
            bIn = *pbIn;
            *pbIn = (rgq[bIn>>4].rgbReserved << 4) |
                    rgq[bIn&0x0f].rgbReserved;
        }

        /* compact and flip the image */

        cbMask = (bmh.biWidth+31)/32*4;
        CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth/2, bmh.biWidth/8, bmh.biHeight/2);
        cbBits = (bmh.biHeight/2) * (bmh.biWidth/2);

        /* "xor" the mask back into the image */

        pbOut = pBits; pbIn = pBits + cbBits;
        for (ib = 0; ib < cbBits; ib++, pbOut++) {
            if (ib % 4 == 0)
                bIn = *pbIn++;
            if ((bIn & 0x80) == 0)
                *pbOut ^= 0xf0;
            if ((bIn & 0x40) == 0)
                *pbOut ^= 0x0f;
            bIn <<= 2;
        }

        /* and write out the resource */

        WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase+itIcs4-itIcs_]);
        MyFree(pBits);
        MyFree(rgq);
    }

    /* move over 256-color icon */

    if (ib8 != 0) {
        ReadDIB(ib8, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* convert color table to mac standard palette */

        for (pbIn = pBits, ib = cbWidth*bmh.biHeight/2; ib > 0; pbIn++, ib--)
            *pbIn = rgq[*pbIn].rgbReserved;

        /* compact and flip the image */

        cbMask = (bmh.biWidth+31)/32*4;
        CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth, bmh.biWidth/8, bmh.biHeight/2);
        cbBits = (bmh.biHeight/2) * (bmh.biWidth);

        /* "xor" the mask back into the image */

        pbOut = pBits; pbIn = pBits + cbBits;
        for (ib = 0; ib < cbBits; ib++, pbOut++) {
            if (ib % 8 == 0)
                bIn = *pbIn++;
            if ((bIn & 0x80) == 0)
                *pbOut ^= 0xff;
            bIn <<= 1;
        }

        /* and write out the resource */

        WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase+itIcs8-itIcs_]);

        MyFree(pBits);
        MyFree(rgq);
    }
}

void
WriteMacRsrc(
    void* pBits,
    int cbBits,
    RESINFO* pResBase,
    DWORD res
    )
{
    WCHAR sz[8];
    TYPEINFO* pType;
    RESINFO* pRes;

    sz[0] = (char)(res >> 24);
    sz[1] = (char)(res >> 16);
    sz[2] = (char)(res >> 8);
    sz[3] = (char)res;
    sz[4] = 0;
    pType = AddResType(sz, 0);

    pRes = (RESINFO *)MyAlloc(sizeof(RESINFO));
    *pRes = *pResBase;
    pRes->size = cbBits;

    AddResToResFile(pType, pRes, (PCHAR) pBits, (WORD)cbBits, 0);
}


void
CompactAndFlipIcon(
    BYTE* pBits,
    int cbRowCur,
    int cbRowMaskCur,
    int cbRowNew,
    int cbRowMaskNew,
    int Height
    )
{
    BYTE* pBitsNew;
    int y;
    BYTE* pbFrom, *pbTo;
    int cb;

    assert(cbRowCur >= cbRowNew);
    pBitsNew = (BYTE *) MyAlloc((WORD)(Height*(cbRowNew+cbRowMaskCur)));

    /* copy the bits over into the scratch space, compacting and
       flipping as we go */

    for (y = 0; y < Height; y++)
        memcpy(pBitsNew+y*cbRowNew, pBits+(Height-y-1)*cbRowCur, cbRowNew);

    /* copy over the mask, flipping and inverting as we go */

    for (y = 0; y < Height; y++) {
        pbTo = pBitsNew + cbRowNew*Height + y*cbRowMaskNew;
        pbFrom = pBits + cbRowCur*Height + (Height-y-1)*cbRowMaskCur;
        for (cb = cbRowMaskNew; cb > 0; cb--)
            *pbTo++ = ~*pbFrom++;
    }

    /* and move the result back to pBits */

    memcpy(pBits, pBitsNew, (cbRowNew+cbRowMaskCur)*Height);
    MyFree(pBitsNew);
}

void CrunchY(unsigned char* pbSrc, unsigned char* pbDst, int WidthBytes, int dySrc, int scale);
void CrunchX2(unsigned char* pbSrc, unsigned char* pbDst, int cbWidth, int dy);

void
GetMacCursor(
    TYPEINFO *pType,
    RESINFO *pRes
    )
{
    struct tagNEWHEADER gh;
    struct tagDESCRIPTOR ds;
    BITMAPINFOHEADER bmh;
    RGBQUAD *rgbq;
    short rgwMask[16];
    short rgwData[16];
    int xyBest;
    int xScale, yScale;
    char* pbBits;
    int ibDescNext, ibDescBest;
    int ires;
    int y, dy;
    int cbWidth;

    /* The input file has already been opened; read in the bitmap file header */

    MyRead(fhCode, &gh, sizeof(struct tagNEWHEADER));
    if (gh.Reserved != 0 || gh.ResType != 2)
        GenError2(2175, tokenbuf);

    /* find the best-looking cursor */

    xyBest = 32767;
    ibDescBest = -1;
    ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);
    for (ires = 0; ires < gh.ResCount; ires++) {
        /* Read in the descriptor */

        MySeek(fhCode, ibDescNext, SEEK_SET);
        MyRead(fhCode, &ds, sizeof(struct tagDESCRIPTOR));
        ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);

        /* get bitmap header */

        MySeek(fhCode, ds.OffsetToBits, SEEK_SET);
        MyRead(fhCode, &bmh, sizeof(BITMAPINFOHEADER));
        if (bmh.biSize != sizeof(BITMAPINFOHEADER))
            GenError2(2176, tokenbuf);
        /* !!! could we be smarter here about smaller cursors? */
        if (bmh.biBitCount != 1 || bmh.biPlanes != 1 ||
                bmh.biWidth % 16 != 0 || bmh.biHeight % 32 != 0)
            continue;
        xScale = bmh.biWidth / 16;
        yScale = bmh.biHeight / 32;
        if (xScale > 2)
            continue;
        if (xScale * yScale < xyBest) {
            xyBest = xScale * yScale;
            ibDescBest = ibDescNext - sizeof(struct tagDESCRIPTOR);
        }
    }

    /* if no usable cursor found, bail out */

    if (ibDescBest == -1) {
        GenWarning2(4507, tokenbuf);
        return;
    }

    /* go back and get the best descriptor and bitmap header */

    ReadDIB(ibDescBest, &ds, &bmh, &cbWidth, (void **) &pbBits, &rgbq, FALSE);

    /* if our color table is backwards, invert the bits */

    if ((rgbq[0].rgbRed == 0xff) &&
        (rgbq[0].rgbGreen == 0xff) &&
        (rgbq[0].rgbBlue == 0xff))
    {
        int cb;
        for (cb = cbWidth * bmh.biHeight; cb > 0; cb--)
            pbBits[cb] = ~pbBits[cb];
    }

    /* if necessary, scale the bits down to 16x16 */

    if (xyBest != 1) {
        GenWarning2(4506, tokenbuf);

        if (bmh.biWidth > 16) {
            assert(bmh.biWidth == 32);
            ds.xHotSpot /= (int)(bmh.biWidth / 16);
            CrunchX2((unsigned char *) pbBits, (unsigned char *) pbBits, cbWidth, bmh.biHeight);
            cbWidth = 2;
        }

        if (bmh.biHeight > 32) {
            ds.yHotSpot /= (int)(bmh.biHeight / 32);
            CrunchY((unsigned char *) pbBits, (unsigned char *) pbBits, cbWidth, bmh.biHeight, bmh.biHeight/32);
            bmh.biHeight = 32;
        }
    }

    /* now build the CURS resource mask and data */

    dy = bmh.biHeight/2;
    if (cbWidth == 1) {
        for (y = dy; y > 0; y--) {
            rgwMask[dy-y] = pbBits[y-1];
            rgwData[dy-y] = pbBits[dy+y-1] ^ ~rgwMask[dy-y];
        }
    } else {
        for (y = dy; y > 0; y--) {
            rgwMask[dy-y] = ~*(short*)&pbBits[(dy+y-1)*cbWidth];
            rgwData[dy-y] = *(short*)&pbBits[(y-1)*cbWidth] ^ rgwMask[dy-y];
        }
    }
    for (y = dy; y < 16; y++) {
        rgwMask[y] = 0;
        rgwData[y] = 0;
    }

    /* and write out the CURS resource data */

    WriteBuffer(rgwData, 32);
    WriteBuffer(rgwMask, 32);
    WriteWord(ds.yHotSpot);
    WriteWord(ds.xHotSpot);

    pRes->size = 32 + 32 + 2 + 2;

    /* and we're done - cleanup and return */

    MyFree(pbBits);
    MyFree(rgbq);
    fclose(fhCode);
    fhCode = NULL_FILE;
    AddResToResFile(pType, pRes, CodeArray, CCount, 0);
}


void
ReadDIB(
    int ibDesc,
    struct tagDESCRIPTOR* pds,
    BITMAPINFOHEADER* pbmh,
    int* pcbWidth,
    void** ppBits,
    RGBQUAD** prgq,
    BOOL fIcon
    )
{
    int cbBits;
    int iq;

    MySeek(fhCode, ibDesc, SEEK_SET);
    MyRead(fhCode, pds, sizeof(struct tagDESCRIPTOR));
    MySeek(fhCode, pds->OffsetToBits, SEEK_SET);
    MyRead(fhCode, pbmh, sizeof(BITMAPINFOHEADER));

    /* get the color table and map to macintosh color palette while we're
       looking at it */

    if (pbmh->biClrUsed == 0)
        pbmh->biClrUsed = 1 << pbmh->biBitCount;
    *prgq = (RGBQUAD *) MyAlloc(pbmh->biClrUsed * sizeof(RGBQUAD));
    MyRead(fhCode, *prgq, pbmh->biClrUsed * sizeof(RGBQUAD));
    switch (pbmh->biBitCount) {
        case 1:
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs2, ccs2, &(*prgq)[iq]);
            break;
        case 4:
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs16, ccs16, &(*prgq)[iq]);
            break;
        case 8:
            // !!! should use 256-color palette
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs256, ccs256, &(*prgq)[iq]);
            break;
        default:
            break;
    }

    /* allocate space for the bits, and load them in */

    *pcbWidth = (pbmh->biBitCount*pbmh->biWidth+31)/32*4;
    if (fIcon)
        cbBits = (*pcbWidth * pbmh->biHeight/2) + ((pbmh->biWidth+31)/32*4) * (pbmh->biHeight/2);
    else
        cbBits = *pcbWidth * pbmh->biHeight;
    *ppBits = MyAlloc(cbBits);
    MyRead(fhCode, *ppBits, cbBits);
}


void
LookupIconColor(
    const ColorSpec* rgcs,
    int ccs,
    RGBQUAD* pq
    )
{
    int ics, icsBest;
    int dred, dgreen, dblue;
    int drgb, drgbBest;

    drgbBest = 32767;
    icsBest = -1;
    for (ics = 0; ics < ccs; ics++) {
        dred = pq->rgbRed - (rgcs[ics].rgb.red>>8);
        dgreen = pq->rgbGreen - (rgcs[ics].rgb.green>>8);
        dblue = pq->rgbBlue - (rgcs[ics].rgb.blue>>8);
        drgb = abs(dred) + abs(dgreen) + abs(dblue);
        if (drgb < drgbBest) {
            drgbBest = drgb;
            icsBest = ics;
            if (drgbBest == 0)
                break;
        }
    }
    pq->rgbReserved = (BYTE)rgcs[icsBest].value;
}


BOOL
IsIcon(
    TYPEINFO* ptype
    )
{
    unsigned long rt;
    short it;

    if (ptype->type == 0)
        return FALSE;
    rt = res_type(ptype->type[0], ptype->type[1], ptype->type[2], ptype->type[3]);
    for (it = 0; it < itMax; it++)
        if (rt == mpitres[it])
            return TRUE;
    return FALSE;
}


void
CrunchX2(
    unsigned char* pbSrc,
    unsigned char* pbDst,
    int cbWidth,
    int dy
    )
{
    unsigned short cw, cwWidth;
    unsigned short w;
    unsigned char b = 0;
    short bit;

    assert(dy > 0);
    assert(cbWidth > 1);

    cwWidth = cbWidth / 2;
    do {
        cw = cwWidth;
        do {
            w = (*pbSrc << 8)|(*(pbSrc+1));
            pbSrc += 2;
            bit = 8;
            do {
                b >>= 1;
                if ((w & 3) == 3)   /* if both are white, keep white */
                    b += 0x80;
                w >>= 2;
            } while (--bit != 0);
            *pbDst++ = b;
        } while (--cw > 0);
        pbDst += cwWidth & 1;
    } while (--dy > 0);
}


void
CrunchY(
    unsigned char* pbSrc,
    unsigned char* pbDst,
    int WidthBytes,
    int dySrc,
    int scale
    )
{
    int cbGroup;
    int cwRow;
    int dyDst, dy;
    unsigned short w;
    unsigned char *pb;

    if (scale <= 1) {
        memcpy(pbDst, pbSrc, dySrc * WidthBytes);
        return;
    }
    dyDst = dySrc / scale;
    cbGroup = WidthBytes * (scale - 1);

    do {
        cwRow = WidthBytes / sizeof(unsigned short);
        do {
            pb = pbSrc;
            w = *(unsigned short*)pb;
            dy = scale - 1;
            do {
                pb += WidthBytes;
                w &= *(unsigned short*)pb;
            } while (--dy > 0);
            *((unsigned short*)pbDst) = w;
            pbDst += sizeof(unsigned short);
            pbSrc += sizeof(unsigned short);
        } while (--cwRow > 0);
        pbSrc += cbGroup;
    } while (--dyDst > 0);
}

/*  WriteMacMap
 *
 *  Writes out a macintosh resource map from the type and resource
 *  data stashed away in the type and resource lists
 *
 *  See Inside Mac, Volume I, for a fine description of the
 *  format of a macintosh resource file
 */
void
WriteMacMap(
    void
    )
{
    TYPEINFO *ptype;
    RESINFO *pres;
    int i;
    size_t cch;
    int cbNameTbl, ctype, cref, ibName;
    long cbData;
    int offRef;
    WCHAR *pch;
#define cbMacType 8
#define cbMacRef 12

    /* alright, we're done reading all this stuff in, run through all
       our type lists and see what we've accumulated */

    cbData = MySeek(fhBin, 0L, 1) - MACDATAOFFSET;
    ctype = 0;
    cref = 0;
    cbNameTbl = 0;

    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;
        ctype++;
        cref += ptype->nres;
        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            /* make sure each reference has a unique resource id */
            if (pres->nameord == 0)
                pres->nameord = (USHORT)IdUnique(ptype, pres);
            if (pres->name != 0)
                cbNameTbl += wcslen(pres->name)+1;
        }
    }

    /* write out the resource header at offset 0 in the file */

    MySeek(fhBin, 0L, 0);
    CtlInit();
    WriteLong((long)MACDATAOFFSET);
    WriteLong((long)MACDATAOFFSET + cbData);
    WriteLong(cbData);
    WriteLong((long)(16+4+2+2+2+2+2 + ctype*cbMacType + cref*cbMacRef + cbNameTbl));
    for (i = (MACDATAOFFSET - 16)/4; i-- > 0; )
        WriteLong(0);
    MyWrite(fhBin, CodeArray, CCount);

    /* we've already written out all the data, now write out the
       beginning of the map part of the resource file */

    MySeek(fhBin, (long)MACDATAOFFSET + cbData, 0);
    CtlInit();
    /* 24 bytes of 0s */
    for (i = 6; i-- > 0; )
        WriteLong(0);
    /* offset to start of type list */
    WriteWord(28);
    /* offset to start of name list */
    WriteWord((USHORT)(28 + 2 + ctype * cbMacType + cref * cbMacRef));

    /* dump out type table of the resource map */

    WriteWord((USHORT)(ctype - 1));
    offRef = 2 + ctype * cbMacType;
    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        long rt;
        TYPEINFO *ptypeX;

        if (ptype->nres == 0)
            continue;

        /* 32-bit resource name - verify name truncation didn't
           cause conflicts */

        rt = MungeResType(ptype->type, ptype->typeord);

        for (ptypeX = ptype->next; ptypeX != 0; ptypeX = ptypeX->next) {
            if (rt == MungeResType(ptypeX->type, ptypeX->typeord)) {
                wchar_t szMac[8];
                wchar_t szType1[128];
                wchar_t szType2[128];

                szMac[0] = (BYTE) (rt >> 24);
                szMac[1] = (BYTE) (rt >> 16);
                szMac[2] = (BYTE) (rt >> 8);
                szMac[3] = (BYTE) (rt);
                szMac[4] = 0;

                if (ptype->typeord)
                    swprintf(szType1, L"%d", ptype->typeord);
                else
                    wcscpy(szType1, ptype->type);

                if (ptypeX->typeord)
                    swprintf(szType2, L"%d", ptypeX->typeord);
                else
                    wcscpy(szType2, ptypeX->type);

                GenWarning4(4509, szType1, szType2, szMac);
            }
        }
        WriteLong(rt);
        /* number of references of this type */
        WriteWord((USHORT)(ptype->nres-1));
        /*  offset to the reference list for this type */
        WriteWord((USHORT)offRef);
        offRef += ptype->nres * cbMacRef;
    }

    /* dump out reference table of the resource map */

    ibName = 0;
    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;

        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            /* resource id */
            WriteWord(pres->nameord);
            /* offset to name in namelist */
            if (pres->name == 0) {
                WriteWord(0xffff);  /* unnamed, use -1 */
            } else {
                WriteWord((USHORT)ibName);
                ibName += wcslen(pres->name)+1;
            }
            /* attributes and resource data offset */
            WriteLong(pres->BinOffset);
            /* must be 0 */
            WriteLong(0L);
        }
    }

    /* and finally, dump out name table */

    /* note that we've implemented the Unicode=>ASCII conversion here by
       simply dumping out the low byte of each Unicode character. Effectively,
       we're assuming that resource names will be ASCII. Changing this would
       require changing the output code here and also changing a few places
       where we use wcslen to calculate the number of bytes that the ASCII
       resource name will require. If the resource name can contain 2-byte
       characters we would need to convert the Unicode to multi-byte and
       then count characters instead of just calling wcslen. */

    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;

        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            if (pres->name == 0)
                continue;

            WriteByte(cch = wcslen(pres->name));
            for (pch = pres->name; cch--; )
                WriteByte((BYTE)*pch++);
        }
    }
    MyWrite(fhBin, CodeArray, CCount);
}


long
MungeResType(
    WCHAR *szType,
    short wOrd
    )
{
    long rt;
    int ich;

    switch (wOrd) {
        case 0:
            assert(szType != NULL && *szType != 0);
            rt = 0;
            for (ich = 0; ich < 4; ich++) {
                rt <<= 8;
                if (*szType)
                    rt |= (BYTE) (*szType++);
                else
                    rt |= ' ';
            }
            break;
        case RT_CURSOR:
            rt = 'CURS';
            break;
        case RT_BITMAP:
            rt = 'WBMP';
            break;
        case RT_ICON:
            rt = 'WICO';
            break;
        case RT_MENU:
            rt = 'WMNU';
            break;
        case RT_DIALOG:
            rt = 'WDLG';
            break;
        case RT_STRING:
            rt = 'STR#';
            break;
        case RT_ACCELERATOR:
            rt = 'WACC';
            break;
        case RT_RCDATA:
        case RT_DLGINIT:
            rt = 'HEXA';
            break;
        case RT_TOOLBAR:
            rt = 'TLBR';
            break;
        case RT_GROUP_CURSOR:
            rt = 'CURS';
            break;
        case RT_GROUP_ICON:
            rt = 'WGIC';
            break;
        case RT_VERSION:
            rt = 'WVER';
            break;
        case RT_FONTDIR:
        case RT_FONT:
        //case RT_ERRTABLE:
        //case RT_NAMETABLE:
        default: {
            static const char rgchHex[] = "0123456789ABCDEF";
            char ch4 = rgchHex[wOrd & 0x0f];
            char ch3 = rgchHex[(wOrd >> 4) & 0x0f];
            char ch2 = rgchHex[(wOrd >> 8) & 0x0f];
            char ch1 = 'M' + ((wOrd >> 12) & 0x0f);
            rt = res_type(ch1,ch2,ch3,ch4);
            break;
        }
    }

    return rt;
}


/*  IdUnique
 *
 *  Searches through the items of the given type looking for
 *  an unused resource id.  Returns the smallest resource id
 *  that is not currently used.
 *
 *  This routine handles icon families in a particular annoying
 *  way, using a particularly inefficient algorithm.  But it
 *  does keep icon ids synchronized if they have the same name.
 *
 *  Entry:
 *      ptype - type to search
 *      pres - resource type needing the unique id
 *
 *  Exit:
 *      retunrs - a unique resource id
 */
int
IdUnique(
    TYPEINFO *ptype,
    RESINFO *pres
    )
{
    int id;
    RESINFO *presScan;
    TYPEINFO* ptypeIcon;

    assert(ptype->pres != 0);

    if (IsIcon(ptype)) {
        /* see if we've already found an id for an icon with the same name */

        assert(pres->name != NULL);
        for (ptypeIcon = pTypInfo; ptypeIcon != NULL; ptypeIcon = ptypeIcon->next) {
            if (!IsIcon(ptypeIcon))
                continue;
            for (presScan = ptypeIcon->pres; presScan != NULL; presScan = presScan->next) {
                if (presScan->name == NULL || presScan->nameord == 0)
                    continue;
                if (wcscmp(presScan->name, pres->name) == 0)
                    return presScan->nameord;
            }
        }

        /* rats, didn't find it, gotta find one that's unique in *all* the
           icon types */

        for (id = idBase; ; ) {
            for (ptypeIcon = pTypInfo; ptypeIcon != NULL; ptypeIcon = ptypeIcon->next) {
                if (!IsIcon(ptypeIcon))
                    continue;
                for (presScan = ptypeIcon->pres; presScan != NULL; presScan = presScan->next) {
                    if (presScan->nameord == id)
                        goto NextId;
                }
            }
            return id;
NextId:
            id = (id+1) & 0xffff;
            if (id == 0)
                id = 1;
        }
    } else {
        for (id = idBase; ; ) {
            for (presScan = ptype->pres; presScan->nameord != id; ) {
                presScan = presScan->next;
                if (presScan == 0)
                    return id;
            }
            id = (id+1) & 0xffff;
            if (id == 0)
                id = 1;
        }
    }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GetToolbar -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

SHORT
GetToolbarValue(
    void
    )
{
    SHORT sVal;

    if (!GetFullExpression(&sVal, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2250); //"expected numerical toolbar constant"

    return(sVal);
}

void
GetButtonSize(
    PSHORT cx,
    PSHORT cy
    )
{
    *cx= GetToolbarValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cy= GetToolbarValue();
}

int
GetToolbar(
    PRESINFO pRes
    )
{
    SHORT cx, cy;
    BOOL    bItemRead = FALSE;

    WriteWord(0x0001);  // Version 1 of this resource.

    GetButtonSize(&cx, &cy);

    WriteWord(cx);
    WriteWord(cy);

    ItemCountLoc = CCount;        /* global marker for location of item cnt. */

    /* skip place for num of items */
    WriteWord(0);

    PreBeginParse(pRes, 2251);

    while (token.type != END) {
        switch (token.type) {
            case TKSEPARATOR:
                bItemRead = TRUE;
                GetToken(TOKEN_NOEXPRESSION);
                WriteWord(0);
                break;

            case TKBUTTON:
                bItemRead = TRUE;
                GetToken(TRUE);
                if (token.type != NUMLIT)
                    ParseError1(2250); //"expected numerical toolbar constant"

                WriteSymbolUse(&token.sym);

                WriteWord(GetToolbarValue());
                break;

            case EOFMARK:
                ParseError1(2252); //"END expected in toolbar"
                quit(NULL);
                break;

            default:
                ParseError1(2253); //"unknown toolbar item type"
                GetToken(TOKEN_NOEXPRESSION);   // try to continue
                continue;
        }

        IncItemCount();
    }

    /* make sure we have a toolbar item */
    if (!bItemRead)
        ParseError1(2254); //"empty toolbars not allowed"

    if (fMacRsrcs)
        SwapItemCount();

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rctp.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


static BOOL fComma;

/* Dialog template format :

        dialogName DIALOGEX x, y, cx, cy [, helpID]
        [style ...]
        [exStyle ...]
        [FONT height, name [, [weight] [, [italic [, [charset]]]]]]
        [caption ...]
        [menu ...]
        [memFlags [pure] [discard n] [preload]]
        BEGIN
            [CONTROL "text", id, BUTTON | STATIC | EDIT | LISTBOX | SCROLLBAR | COMBOBOX | "class", style, x, y, cx, cy]
            [FONT height, name [, [weight] [, [italic]]]]
            [BEGIN
                data-element-1 [,
                data-element-2 [,
                ... ]]
            END]

            [LTEXT     "text", id, x, y, cx, cy]
            [RTEXT     "text", id, x, y, cx, cy]
            [CTEXT     "text", id, x, y, cx, cy]

            [AUTO3STATE         "text", id, x, y, cx, cy]
            [AUTOCHECKBOX       "text", id, x, y, cx, cy]
            [AUTORADIOBUTTON    "text", id, x, y, cx, cy]
            [CHECKBOX           "text", id, x, y, cx, cy]
            [PUSHBOX            "text", id, x, y, cx, cy]
            [PUSHBUTTON         "text", id, x, y, cx, cy]
            [RADIOBUTTON        "text", id, x, y, cx, cy]
            [STATE3             "text", id, x, y, cx, cy]
            [USERBUTTON         "text", id, x, y, cx, cy]

            [EDITTEXT   id, x, y, cx, cy]
            [BEDIT      id, x, y, cx, cy]
            [HEDIT      id, x, y, cx, cy]
            [IEDIT      id, x, y, cx, cy]
            ...
        END

        MenuName MENUEX
        BEGIN
            [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
            [POPUP    "text" [, [id] [, [type] [, [state] [, [help id]]]]]
            BEGIN
                [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
                ...
            END]
            ...
        END

    Menu template format

                MenuName MENU
                BEGIN
                        [MENUITEM "text", id [option, ...]]
                        [POPUP    "text" [, option, ...]
                                BEGIN
                                   [MENUITEM "text", id [option, ...]]
                                   ...
                                END ]
                                ...
                END
*/

/* Dialog template format :

          dialogname DIALOG  x, y, cx, cy
          [language ...]
          [style ...]
          [caption ...  ]
          [menu ... ]
          [memflags [pure] [discard n] [preload]]
          begin
                [CONTROL "text", id, BUTTON | STATIC | EDIT | LISTBOX | SCROLLBAR | COMBOBOX | "class", style, x, y, cx, cy]

                [LTEXT     "text", id, x, y, cx, cy]
                [RTEXT     "text", id, x, y, cx, cy]
                [CTEXT     "text", id, x, y, cx, cy]

                [CHECKBOX     "text", id, x, y, cx, cy]
                [PUSHBUTTON   "text", id, x, y, cx, cy]
                [RADIOBUTTON  "text", id, x, y, cx, cy]

                [EDITTEXT  id, x, y, cx, cy]
                ...
          end

   Menu template format

        MenuName MENU
        BEGIN
            [MENUITEM "text", id [option, ...]]
            [POPUP    "text" [, option, ...]
                BEGIN
                   [MENUITEM "text", id [option, ...]]
                   ...
                END ]
                ...
        END
*/


#define CTLSTYLE(s) (WS_CHILD | WS_VISIBLE | (s))

/* list of control id's to check for duplicates */
PDWORD  pid;
int     cidMac;
int     cidMax;

BOOL
CheckStr(
    PWCHAR pStr
    )
{
    if (token.type == STRLIT || token.type == LSTRLIT) {
        if (token.val > MAXTOKSTR-1) {
            SET_MSG(4208, curFile, token.row);
            SendError(Msg_Text);
            tokenbuf[MAXTOKSTR-1] = TEXT('\0');
            token.val = MAXTOKSTR-2;
        }
        memcpy(pStr, tokenbuf, (token.val+1)*sizeof(WCHAR));

        return(TRUE);
    }
    return(FALSE);
}


// ----------------------------------------------------------------------------
//
//  GetDlgValue
//
// ----------------------------------------------------------------------------

SHORT
GetDlgValue(
    void
    )
{
    SHORT sVal;

    if (!GetFullExpression(&sVal, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2109); //"Expected Numerical Dialog constant"

    return(sVal);
}

void
GetCoords(
    PSHORT x,
    PSHORT y,
    PSHORT cx,
    PSHORT cy
    )
{
    *x = GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *y = GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cx= GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cy= GetDlgValue();
}

typedef struct tagCTRLTYPE {
    WORD    type;
    DWORD   dwStyle;
    BYTE    bCode;
    BYTE    fHasText;
}   CTRLTYPE;

CTRLTYPE ctrlTypes[] = {
    { TKGROUPBOX,       BS_GROUPBOX,                    BUTTONCODE,     TRUE  },
    { TKPUSHBUTTON,     BS_PUSHBUTTON | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKDEFPUSHBUTTON,  BS_DEFPUSHBUTTON | WS_TABSTOP,  BUTTONCODE,     TRUE  },
    { TKCHECKBOX,       BS_CHECKBOX | WS_TABSTOP,       BUTTONCODE,     TRUE  },
    { TKRADIOBUTTON,    BS_RADIOBUTTON,                 BUTTONCODE,     TRUE  },
    { TKAUTO3,          BS_AUTO3STATE | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKAUTOCHECK,      BS_AUTOCHECKBOX | WS_TABSTOP,   BUTTONCODE,     TRUE  },
    { TKAUTORADIO,      BS_AUTORADIOBUTTON,             BUTTONCODE,     TRUE  },
    { TKPUSHBOX,        BS_PUSHBOX | WS_TABSTOP,        BUTTONCODE,     TRUE  },
    { TK3STATE,         BS_3STATE | WS_TABSTOP,         BUTTONCODE,     TRUE  },
    { TKUSERBUTTON,     BS_USERBUTTON | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKLTEXT,          ES_LEFT | WS_GROUP,             STATICCODE,     TRUE  },
    { TKRTEXT,          ES_RIGHT | WS_GROUP,            STATICCODE,     TRUE  },
    { TKCTEXT,          ES_CENTER | WS_GROUP,           STATICCODE,     TRUE  },
    { TKICON,           SS_ICON,                        STATICCODE,     TRUE  },
    { TKBEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKHEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKIEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKEDITTEXT,       ES_LEFT | WS_BORDER | WS_TABSTOP, EDITCODE,     FALSE },
    { TKLISTBOX,        WS_BORDER | LBS_NOTIFY,         LISTBOXCODE,    FALSE },
    { TKCOMBOBOX,       0,                              COMBOBOXCODE,   FALSE },
    { TKSCROLLBAR,      0,                              SCROLLBARCODE,  FALSE }
};

#define C_CTRLTYPES (sizeof(ctrlTypes) / sizeof(CTRLTYPE))

// ----------------------------------------------------------------------------
//
//  GetDlgItems(fDlgEx) -
//
// ----------------------------------------------------------------------------

int
GetDlgItems(
    BOOL fDlgEx
    )
{
    CTRL ctrl;
    int i;

    cidMac = 0;
    cidMax = 100;
    pid = (PDWORD) MyAlloc(sizeof(DWORD)*cidMax);
    if (!pid)
        return FALSE;

    GetToken(TRUE);

    /* read all the controls in the dialog */

    ctrl.id = 0L;  // initialize the control's id to 0

    while (token.type != END) {
        ctrl.dwHelpID = 0L;
        ctrl.dwExStyle = 0L;
        ctrl.dwStyle = WS_CHILD | WS_VISIBLE;
        ctrl.text[0] = 0;
        ctrl.fOrdinalText = FALSE;

        if (token.type == TKCONTROL) {
            ParseCtl(&ctrl, fDlgEx);
        } else {
            for (i = 0; i < C_CTRLTYPES; i++)
                if (token.type == ctrlTypes[i].type)
                    break;

            if (i == C_CTRLTYPES) {
                ParseError1(2111); //"Invalid Control type : ", tokenbuf
                return(FALSE);
            }

            ctrl.dwStyle |= ctrlTypes[i].dwStyle;
            if (fMacRsrcs &&
                (token.type == TKPUSHBUTTON ||
                token.type == TKDEFPUSHBUTTON ||
                token.type == TKCHECKBOX ||
                token.type == TKAUTO3 ||
                token.type == TKAUTOCHECK ||
                token.type == TKPUSHBOX ||
                token.type == TK3STATE ||
                token.type == TKUSERBUTTON))
            {
                ctrl.dwStyle &= ~WS_TABSTOP;
            }
            if (ctrlTypes[i].bCode) {
                ctrl.Class[0] = 0xFFFF;
                ctrl.Class[1] = ctrlTypes[i].bCode;
            } else {
                CheckStr(ctrl.Class);
            }

            if (ctrlTypes[i].fHasText)
                GetCtlText(&ctrl);

            // find the ID and the coordinates
            GetCtlID(&ctrl, fDlgEx);
            GetCoords(&ctrl.x, &ctrl.y, &ctrl.cx, &ctrl.cy);

            // get optional style, exstyle, and helpid
            if (token.type == COMMA) {
                GetToken(TOKEN_NOEXPRESSION);
                GetFullExpression(&ctrl.dwStyle, 0);
            }
        }

        if (token.type == COMMA) {
            GetToken(TOKEN_NOEXPRESSION);
            GetFullExpression(&ctrl.dwExStyle, 0);

            if (fDlgEx && (token.type == COMMA)) {
                GetToken(TOKEN_NOEXPRESSION);
                GetFullExpression(&ctrl.dwHelpID, GFE_ZEROINIT);
            }
        }

        SetUpItem(&ctrl, fDlgEx); /* gen the code for it  */

        if (fDlgEx && (token.type == BEGIN)) {
            /* align any CreateParams are there */
            //WriteAlign(); not yet!!!

            // we're ok passing NULL in for pRes here because PreBeginParse
            // won't have to use pRes
            // Note that passing fDlgEx is actually redundant since it
            // will always be TRUE here, but we'll do it in case someone
            // else ever calls SetItemExtraCount
            SetItemExtraCount(GetRCData(NULL), fDlgEx);
            GetToken(TOKEN_NOEXPRESSION);
        }
    }
    MyFree(pid);
    return TRUE;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetDlg() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetDlg(
    PRESINFO pRes,
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    /* initialize and defaults */
    pDlg->dwExStyle = pRes->exstyleT;
    pDlg->dwStyle = WS_POPUPWINDOW | WS_SYSMENU;
    pDlg->MenuName[0] = 0;
    pDlg->Title[0] = 0;
    pDlg->Class[0] = 0;
    pDlg->fOrdinalMenu = FALSE;
    pDlg->fClassOrdinal = FALSE;
    pDlg->pointsize = 0;

    // get x, y, cx, cy
    GetCoords(&pDlg->x, &pDlg->y, &pDlg->cx, &pDlg->cy);

    /* get optional parameters */
    if (!DLexOptionalArgs(pRes, pDlg, fDlgEx))
        return FALSE;

    if (pDlg->pointsize)
        pDlg->dwStyle |= DS_SETFONT;
    else
        pDlg->dwStyle &= ~DS_SETFONT;

    /* output header to the resource buffer */
    SetUpDlg(pDlg, fDlgEx);

    /* make sure we have a BEGIN */
    if (token.type != BEGIN)
        ParseError1(2112); //"BEGIN expected in Dialog"

    /* get the dialog items */
    GetDlgItems(fDlgEx);

    if (fMacRsrcs)
        SwapItemCount();

    /* make sure this ended on an END */
    if (token.type != END)
        ParseError1(2113); //"END expected in Dialog"

    return (TRUE);
}



typedef struct tagCTRLNAME {
    BYTE    bCode;
    WORD    wType;
    PWCHAR  pszName;
} CTRLNAME;

CTRLNAME    ctrlNames[] = {
    { BUTTONCODE,    TKBUTTON,    L"button"    },
    { EDITCODE,      TKEDIT,      L"edit"      },
    { STATICCODE,    TKSTATIC,    L"static"    },
    { LISTBOXCODE,   TKLISTBOX,   L"listbox"   },
    { SCROLLBARCODE, TKSCROLLBAR, L"scrollbar" },
    { COMBOBOXCODE,  TKCOMBOBOX,  L"combobox"  }
};

#define C_CTRLNAMES (sizeof(ctrlNames) / sizeof(CTRLNAME))

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      ParseCtl() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// for a control of the form CTL

void
ParseCtl(
    PCTRL LocCtl,
    BOOL fDlgEx
    )
{   /* by now we've read the CTL */
    int i;

    /* get the control text and identifier */
    GetCtlText(LocCtl);
    GetCtlID(LocCtl, fDlgEx);

    if (token.type == NUMLIT) {
        LocCtl->Class[0] = (char) token.val;
        LocCtl->Class[1] = 0;
    } else if (token.type == LSTRLIT) {
        // We will now convert class name strings to short form magic
        // numbers. These magic numbers are order dependent as defined in
        // USER. This provides some space savings in resource files.
        for (i = C_CTRLNAMES; i; ) {
            if (!_wcsicmp(tokenbuf, ctrlNames[--i].pszName))
                goto Found1;
        }
        CheckStr(LocCtl->Class);
    } else {
        for (i = C_CTRLNAMES; i; ) {
            if (token.type == ctrlNames[--i].wType)
                goto Found1;
        }
        ParseError1(2114); //"Expected control class name"

Found1:
        LocCtl->Class[0] = 0xFFFF;
        LocCtl->Class[1] = ctrlNames[i].bCode;
    }

    /* get the style bits */
    GetTokenNoComma(TOKEN_NOEXPRESSION);
    GetFullExpression(&LocCtl->dwStyle, 0);

    /* get the coordinates of the control */
    ICGetTok();
    GetCoords(&LocCtl->x, &LocCtl->y, &LocCtl->cx, &LocCtl->cy);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCtlText() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetCtlText(
    PCTRL pLocCtl
    )
{
    GetTokenNoComma(TOKEN_NOEXPRESSION);
    if (CheckStr(pLocCtl->text)) {
        pLocCtl->fOrdinalText = FALSE;
        token.sym.name[0] = L'\0';
        token.sym.nID = 0;
    } else if (token.type == NUMLIT) {
        wcsitow(token.val, pLocCtl->text, 10);
        pLocCtl->fOrdinalText = TRUE;
        WriteSymbolUse(&token.sym);
    } else {
        ParseError1(2115); //"Text string or ordinal expected in Control"
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCtlID() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetCtlID(
    PCTRL pLocCtl,
    BOOL fDlgEx
    )
{
    WORD    wGFE = GFE_ZEROINIT;
    int i;

    ICGetTok();

    WriteSymbolUse(&token.sym);

    if (!fDlgEx)
        wGFE |= GFE_SHORT;

    if (GetFullExpression(&pLocCtl->id, wGFE)) {
        if (!fDlgEx && pLocCtl->id != (DWORD)(WORD)-1 ||
             fDlgEx && pLocCtl->id != (DWORD)-1) {
            for (i=0 ; i<cidMac ; i++) {
                if (pLocCtl->id == *(pid+i) && !fSkipDuplicateCtlIdWarning) {
                    i = (int)pLocCtl->id;
                    SET_MSG(2182, curFile, token.row, i);
                    SendError(Msg_Text);
                    break;
                }
            }
            if (cidMac == cidMax) {
                PDWORD pidNew;

                cidMax += 100;
                pidNew = (PDWORD) MyAlloc(cidMax*sizeof(DWORD));
                memcpy(pidNew, pid, cidMac*sizeof(DWORD));
                MyFree(pid);
                pid = pidNew;
            }
            *(pid+cidMac++) = pLocCtl->id;
        }
    } else {
        ParseError1(2116); //"Expecting number for ID"
    }

    if (token.type == COMMA)
        ICGetTok();
}


// ----------------------------------------------------------------------------
//
//  DLexOptionArgs(pRes, fDlgEx) -
//
// ----------------------------------------------------------------------------
BOOL
DLexOptionalArgs(
    PRESINFO pRes,
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    /* read all the optional dialog items */

    if (fDlgEx && (token.type == COMMA)) {
        GetToken(TOKEN_NOEXPRESSION);
        GetFullExpression(&pDlg->dwHelpID, GFE_ZEROINIT);
    }

    while (token.type != BEGIN) {
        switch (token.type) {
            case TKLANGUAGE:
                pRes->language = GetLanguage();
                GetToken(FALSE);
                break;

            case TKVERSION:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2139);
                pRes->version = token.longval;
                GetToken(FALSE);
                break;

            case TKCHARACTERISTICS:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2140);
                pRes->characteristics = token.longval;
                GetToken(FALSE);
                break;

            case TKSTYLE:
                // If CAPTION statement preceded STYLE statement, then we
                // already must have WS_CAPTION bits set in the "style"
                // field and we must not lose it;

                if ((pDlg->dwStyle & WS_CAPTION) == WS_CAPTION)
                    pDlg->dwStyle = WS_CAPTION;
                else
                    pDlg->dwStyle = 0;

                GetTokenNoComma(TOKEN_NOEXPRESSION);
                GetFullExpression(&pDlg->dwStyle, 0);
                break;

            case TKEXSTYLE:
                GetTokenNoComma(TOKEN_NOEXPRESSION);
                GetFullExpression(&pDlg->dwExStyle, 0);
                break;

            case TKCAPTION:
                DGetTitle(pDlg);
                break;

            case TKMENU:
                DGetMenuName(pDlg);
                break;

            case TKCLASS:
                DGetClassName(pDlg);
                break;

            case TKFONT:
                DGetFont(pDlg, fDlgEx);
                break;

            default:
                ParseError1(2112); //"BEGIN expected in dialog");
                return FALSE;
        }
    }
    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetFont() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
DGetFont(
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    WORD w;
    int i;

    GetToken(TRUE);
    if (!GetFullExpression(&pDlg->pointsize, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2117); //"Expected numeric point size"

    if (token.type == COMMA)
        ICGetTok();

    if (!CheckStr(pDlg->Font))
        ParseError1(2118); //"Expected font face name"

    if (_wcsicmp(pDlg->Font, L"System") &&
        szSubstituteFontName[0] != UNICODE_NULL) {
        for (i=0; i<nBogusFontNames; i++) {
            if (!_wcsicmp(pszBogusFontNames[i], pDlg->Font)) {
                GenWarning4(4510, pDlg->Font, szSubstituteFontName, 0); // Warning for hard coded fonts
                wcscpy(pDlg->Font, szSubstituteFontName);
            }
        }
    }

    GetToken(TRUE);

    pDlg->bCharSet = DEFAULT_CHARSET;

    if (fDlgEx && (token.type == COMMA)) {
        GetToken(TOKEN_NOEXPRESSION);
        if (GetFullExpression(&w, GFE_ZEROINIT | GFE_SHORT))
            pDlg->wWeight = w;

        if (token.type == COMMA) {
            GetToken(TOKEN_NOEXPRESSION);
            if (token.type == NUMLIT) {
                pDlg->bItalic = (token.val) ? TRUE : FALSE;
                GetToken(TOKEN_NOEXPRESSION);

                if (token.type == COMMA) {
                    GetToken(TOKEN_NOEXPRESSION);
                    if (GetFullExpression(&w, GFE_ZEROINIT | GFE_SHORT))
                        pDlg->bCharSet = (UCHAR) w;
                }
            }
        }
    }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetMenuName() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*  gets the unquoted string of the name of the optional menu associated */
/*  with the dialog.  */

VOID
DGetMenuName(
    PDLGHDR pDlg
    )
{
    if (GetGenText()) {
        /* copy the menu name */
        token.type = LSTRLIT;
        CheckStr(pDlg->MenuName);

        /* check if menu name is an ordinal */
        if (wcsdigit(pDlg->MenuName[0]))
            pDlg->fOrdinalMenu = TRUE;
        GetToken(TRUE);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetTitle() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
DGetTitle(
 PDLGHDR pDlg
 )
{
    GetToken(TRUE);

    if (CheckStr(pDlg->Title))
        pDlg->dwStyle |= WS_CAPTION;
    else
        ParseError1(2119); //"Expecting quoted string in dialog title"

    GetToken(TRUE);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetClassName() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
DGetClassName(
 PDLGHDR pDlg
 )
{
    GetToken(TRUE);
    if (!CheckStr(pDlg->Class)) {
        if (token.type == NUMLIT) {
            wcsitow(token.val, pDlg->Class, 10);
            pDlg->fClassOrdinal = TRUE;
        } else {
            ParseError1(2120); //"Expecting quoted string in dialog class"
        }
    }
    GetToken(TRUE);
}


/*---------------------------------------------------------------------------*/
/*      Gets a token, ignoring commas.  Returns the token type.              */
/*                                                                           */
/*  ICGetTok() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*  Get token, but ignore commas  */

USHORT
ICGetTok(
    VOID
    )
{
    fComma = FALSE; // NT added the use of this fComma flag
    GetToken(TRUE);
    while (token.type == COMMA) {
        GetToken(TRUE);
        fComma = TRUE; // and they set it here
    }
    return (USHORT)token.type;
}


/*  GetTokenNoComma
 *      This function replaces ICGetTok() but has a flag to support
 *      the turning off of expression parsing.
 */

USHORT
GetTokenNoComma(
    USHORT wFlags
    )
{
    /* Get a token */
    GetToken(TRUE | wFlags);

    /* Ignore any commas */
    while (token.type == COMMA)
        GetToken(TRUE | wFlags);

    return (USHORT)token.type;
}


/*************  Menu Parsing Routines *********************/


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IsmnOption() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
IsmnOption(
    UINT arg,
    PMENUITEM pmn
    )
{
    /* if we have a valid flag, or it into the menu flags */
    switch (arg) {
        case TKOWNERDRAW:
            pmn->OptFlags |= OPOWNERDRAW;
            break;

        case TKCHECKED:
            pmn->OptFlags |= OPCHECKED;
            break;

        case TKGRAYED:
            pmn->OptFlags |= OPGRAYED;
            break;

        case TKINACTIVE:
            pmn->OptFlags |= OPINACTIVE;
            break;

        case TKBREAKWBAR:
            pmn->OptFlags |= OPBREAKWBAR;
            break;

        case TKBREAK:
            pmn->OptFlags |= OPBREAK;
            break;

        case TKHELP:
            pmn->OptFlags |= OPHELP;
            break;

        case TKBITMAP:
            pmn->OptFlags |= OPBITMAP;
            break;

        default:
            return(FALSE);
    }
    return(TRUE);

#if 0
    if ((arg == OPBREAKWBAR)       || (arg == OPHELP   ) || (arg == OPGRAYED) ||
        (arg == OPUSECHECKBITMAPS) || (arg == OPCHECKED) || (arg == OPBITMAP) ||
        (arg == OPOWNERDRAW)       || (arg == OPBREAK  ) || (arg == OPINACTIVE))
    {
        pmn->OptFlags |= arg;
        return TRUE;
    }
#if 0
    if (arg == OPHELP) {
        pmn->OptFlags |= OPPOPHELP;
        return TRUE;
    }
#endif
    return FALSE;
#endif
}



// ----------------------------------------------------------------------------
//
//  DoOldMenuItem() -
//
// ----------------------------------------------------------------------------

WORD
DoOldMenuItem(
    int fPopup
    )
{
    MENUITEM mnTemp;

    mnTemp.PopFlag  = (UCHAR)fPopup;
    GetToken(TRUE);

    /* menu choice string */
    if (CheckStr(mnTemp.szText)) {
        mnTemp.OptFlags = OPPOPUP;
        ICGetTok();
        if (!fPopup) {
            /* change the flag and get the ID if not a popup */
            mnTemp.OptFlags = 0;

            WriteSymbolUse(&token.sym);
            if (!GetFullExpression(&mnTemp.id, GFE_ZEROINIT | GFE_SHORT))
                ParseError1(2125); //"Expected ID value for Menuitem"

            if (token.type == COMMA)
                GetToken(TOKEN_NOEXPRESSION);
        }

        /* read the menu option flags */
        while (IsmnOption(token.type, &mnTemp))
            ICGetTok();
    } else if (token.type == TKSEPARATOR) {
        mnTemp.szText[0] = 0;       // MENUITEM SEPARATOR
        mnTemp.id = 0;
        mnTemp.OptFlags = 0;
        ICGetTok();
    } else {
        ParseError1(2126); //"Expected Menu String"
    }

    /* set it up in the buffer (?) */
    return(SetUpOldMenu(&mnTemp));
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ParseOldMenu() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
ParseOldMenu(
    int fRecursing,
    PRESINFO pRes           // 8 char proc name limitation!
    )
{
    BOOL    bItemRead = FALSE;
    WORD    wEndFlagLoc = 0;

    if (!fRecursing) {
        PreBeginParse(pRes, 2121);
    } else {
        /* make sure its really a menu */
        if (token.type != BEGIN)
            ParseError1(2121); //"BEGIN expected in menu"
        GetToken(TRUE);
    }

    /* get the individual menu items */
    while (token.type != END) {
        switch (token.type) {
            case TKMENUITEM:
                bItemRead = TRUE;
                wEndFlagLoc = DoOldMenuItem(FALSE);
                break;

            case TKPOPUP:
                bItemRead = TRUE;
                wEndFlagLoc = DoOldMenuItem(TRUE);
                ParseOldMenu(TRUE, pRes);
                break;

            default:
                ParseError1(2122); //"Unknown Menu SubType :"
                break;
        }
    }

    /* did we die on an END? */
    if (token.type != END)
        ParseError1(2123); //"END expected in menu"

    /* make sure we have a menu item */
    if (!bItemRead)
        ParseError1(2124); //"Empty menus not allowed"

    /* Get next token if this was NOT the last END*/
    if (fRecursing)
        GetToken(TRUE);

    /* mark the last item in the menu */
    FixOldMenuPatch(wEndFlagLoc);

    return (TRUE);
}


/* ----- Version resource stuff ----- */

/*  VersionParse
 *      Parses the VERSION resource and places it in the global buffer
 *      so it can be written out by SaveResFile().
 */

int
VersionParse(
    VOID
    )
{
    int Index;

    /* Get the fixed structure entries */
    /* Note that VersionParseFixed doesn't actually fail! */
    /* This is because VersionBlockStruct doesn't fail. */
    Index = VersionParseFixed();

    /* Put the following blocks in as sub-blocks.  Fix up the length when
     *  we're done.
     */
    SetItemCount(Index, (USHORT)(GetItemCount(Index) + VersionParseBlock()));

    /* The return data buffer is global */
    return TRUE;
}


/*  VersionParseFixed
 *      Parses the fixed portion of the version resource.  Returns a pointer
 *      to the length word of the block.  This word has the length of
 *      the fixed portion precomputed and remains to have the variable
 *      portion added in.
 */

int
VersionParseFixed(
    VOID
    )
{
    VS_FIXEDFILEINFO FixedInfo;

    /* Initialize the structure fields */
    memset((PCHAR)&FixedInfo, 0, sizeof(FixedInfo));
    FixedInfo.dwSignature = 0xfeef04bdL;
    FixedInfo.dwStrucVersion = 0x00010000L;
    FixedInfo.dwFileDateMS = 0L;
    FixedInfo.dwFileDateLS = 0L;

    /* Loop through tokens until we get the "BEGIN" token which
     *  must be present to terminate the fixed portion of the VERSIONINFO
     *  resource.
     */
    while (token.type != BEGIN) {
        switch (token.type) {
            /* The following have four WORDS scrambled into two DWORDS */
            case TKFILEVERSION:
                VersionGet4Words(&FixedInfo.dwFileVersionMS);
                break;

            case TKPRODUCTVERSION:
                VersionGet4Words(&FixedInfo.dwProductVersionMS);
                break;

                /* The following have just one DWORD */
            case TKFILEFLAGSMASK:
                VersionGetDWord(&FixedInfo.dwFileFlagsMask);
                break;

            case TKFILEFLAGS:
                VersionGetDWord(&FixedInfo.dwFileFlags);
                break;

            case TKFILEOS:
                VersionGetDWord(&FixedInfo.dwFileOS);
                break;

            case TKFILETYPE:
                VersionGetDWord(&FixedInfo.dwFileType);
                break;

            case TKFILESUBTYPE:
                VersionGetDWord(&FixedInfo.dwFileSubtype);
                break;

                /* Other tokens are unknown */
            default:
                ParseError1(2167); //"Unrecognized VERSIONINFO field;"
        }
    }

    /* Write the block out and return the pointer to the length */
    return VersionBlockStruct(L"VS_VERSION_INFO", (PCHAR)&FixedInfo,
        sizeof(FixedInfo));
}


/*  VersionGet4Words
 *      Reads a version number from the source file and scrambles them
 *      to fit in two DWORDs.  We force them to put commas in here so
 *      that if they don't put in enough values we can fill in zeros.
 */

VOID
VersionGet4Words(
    ULONG *pdw
    )
{
    //    static CHAR szParseError[] = "Version WORDs separated by commas expected";

    /* Get the first number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *pdw = ((LONG)token.val) << 16;

    /* Get the comma.  If none, we're done, so fill the rest with zeros */
    GetToken(TRUE);
    if (token.type != COMMA) {
        *++pdw = 0L;
        return;
    }

    /* Get the second number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *(PUSHORT)pdw = token.val;

    /* Get the comma.  If none, we're done, so fill the rest with zeros */
    GetToken(TRUE);
    if (token.type != COMMA) {
        *++pdw = 0L;
        return;
    }

    /* Get the third number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *++pdw = ((LONG)token.val) << 16;

    /* Get the comma.  If none, we're done */
    GetToken(TRUE);
    if (token.type != COMMA)
        return;

    /* Get the fourth number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *(PUSHORT)pdw = token.val;

    /* Get the next token for the loop */
    GetToken(TRUE);
}


/*  VersionGetDWord
 *      Reads a single DWORD from the source file into the given variable.
 */

VOID
VersionGetDWord(
    ULONG *pdw
    )
{
    /* Get the token */
    GetToken(TRUE);
    if (token.type != NUMLIT)
        ParseError1(2128); //"DWORD expected"
    *pdw = token.longval;

    /* Get the next token for the loop */
    GetToken(TRUE);
}


/*  VersionParseBlock
 *      Parses a block of version information.  Note that this block may
 *      contain one or more additional blocks, causing this function to
 *      be called recursively.  Returns the length of the block which can
 *      be added to the length of the current block.  Returns 0xffff on error.
 */

USHORT
VersionParseBlock(
    VOID
    )
{
    USHORT      wLen;
    int         IndexLen;
    USHORT      wType;

    /* Get the current position in the buffer */
    wLen = GetBufferLen();

    /* The token has already been read.  This should be a BEGIN */
    if (token.type != BEGIN)
        ParseError1(2129); //"BEGIN expected in VERSIONINFO resource"

    /* Get the first token.  From here on, the VersionBlockVariable()
     *  routine gets the tokens as it searches for the end of the value
     *  field.
     */
    GetToken(TRUE);

    /* Loop until we get to the END for this BEGIN */
    for (; ; ) {
        /* Get and decode the next line type */
        switch (token.type) {
            case TKVALUE:
            case TKBLOCK:
                /* Save the type of this token */
                wType = token.type;

                /* Get the key string */
                GetToken(TRUE);
                if (token.type != LSTRLIT)
                    ParseError1(2131); //"Expecting quoted string for key"

                /* Now feed in the key string and value items */
                IndexLen = VersionBlockVariable(tokenbuf);

                /* A "BLOCK" item causes recursion.  Current token should be
                 *  "BEGIN"
                 */
                if (wType == TKBLOCK) {
                    SetItemCount(IndexLen, (USHORT)(GetItemCount(IndexLen) + VersionParseBlock()));
                    GetToken(TRUE);
                }
                break;

            case END:
                /* We're done with this block.  Get the next token
                 *  (read past the "END") and return the length of the block.
                 */
                return GetBufferLen() - wLen;

            default:
                ParseError1(2132); //"Expected VALUE, BLOCK, or, END keyword."
        }
    }
}


#define DWORDALIGN(w) \
    (((w) + (sizeof(ULONG) - 1)) & ~(USHORT)(sizeof(ULONG) - 1))

/*  VersionBlockStruct
 *      Writes a version block without sub-blocks.  Sub-blocks are to
 *      be written directly after this header.  To facilitate this,
 *      a pointer to the block length is returned so that it can be modified.
 *      This call uses a pre-parsed value item.  Use VersionBlockVariable()
 *      to parse the value items instead.
 *      Note that this actually can't fail!
 */

int
VersionBlockStruct(
    PWCHAR pstrKey,
    PCHAR pstrValue,
    USHORT wLenValue
    )
{
    USHORT wLen;
    int Index;
    ULONG dwPadding = 0L;
    USHORT wAlign;

    /* Pad the block data to DWORD align */
    wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
    if (wAlign)
        WriteBuffer((PCHAR)&dwPadding, wAlign);

    /* Save the current length so we can compute the new block length later */
    wLen = GetBufferLen();

    /* Write a zero for the length for now */
    Index = GetBufferLen();
    WriteWord(0);

    /* Write the length of the value field */
    WriteWord(wLenValue);

    /* data is binary */
    WriteWord(0);

    /* Write the key string now */
    WriteString(pstrKey, TRUE);

    /* Write the value data if there is any */
    if (wLenValue) {
        /* Now we have to DWORD align the value data */
        wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
        if (wAlign)
            WriteBuffer((PSTR)&dwPadding, wAlign);

        /* Write it to the buffer */
        WriteBuffer((PSTR)pstrValue, wLenValue);
    }

    /* Now fix up the block length and return a pointer to it */
    SetItemCount(Index, (USHORT)(GetBufferLen() - wLen));

    return Index;
}



/*  VersionBlockVariable
 *      Writes a version block without sub-blocks.  Sub-blocks are to
 *      bre written directly after this header.  To facilitate this,
 *      a pointer to the block length is returned so that it can be modified.
 *      VersionBlockVariable() gets the value items by parsing the
 *      RC script as RCDATA.
 */

int
VersionBlockVariable(
    PWCHAR pstrKey
    )
{
    USHORT wLen;
    int IndexLen;
    int IndexType;
    int IndexValueLen;
    ULONG dwPadding = 0L;
    USHORT wAlign;

    /* Pad the block data to DWORD align */
    wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
    if (wAlign)
        WriteBuffer((PCHAR)&dwPadding, wAlign);

    /* Save the current length so we can compute the new block length later */
    wLen = GetBufferLen();

    /* Write a zero for the length for now */
    IndexLen = GetBufferLen();
    WriteWord(0);

    /* Write the length of the value field.  We fill this in later */
    IndexValueLen = GetBufferLen();
    WriteWord(0);

    /* Assume string data */
    IndexType = GetBufferLen();
    WriteWord(1);

    /* Write the key string now */
    WriteString(pstrKey, TRUE);

    /* Parse and write the value data if there is any */
    SetItemCount(IndexValueLen, VersionParseValue(IndexType));

    /* Now fix up the block length and return a pointer to it */
    SetItemCount(IndexLen, (USHORT)(GetBufferLen() - wLen));

    return IndexLen;
}



/*  VersionParseValue
 *      Parses the fields following either BLOCK or VALUE and following
 *      their key string which is parsed by VersionParseBlock().
 *      Before writing the first value item out, the field has to be
 *      DWORD aligned.  Returns the length of the value block.
 */

USHORT
VersionParseValue(
    int IndexType
    )
{
    USHORT wFirst = FALSE;
    USHORT wToken;
    USHORT wAlign;
    ULONG dwPadding = 0L;
    USHORT wLen = 0;

    /* Decode all tokens until we get to the end of this item */
    for (; ; ) {
        /* ICGetTok is GetToken(TRUE) ignoring commas */
        wToken =  ICGetTok();

        /* If this is the first item, DWORD align it.  Since empty value
         *  sections are legal, we have to wait until we actually have data
         *  to do this.
         */
        if (!wFirst) {
            wFirst = TRUE;
            wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
            if (wAlign)
                WriteBuffer((PCHAR)&dwPadding, wAlign);
        }

        switch (wToken) {
            case TKVALUE:
            case TKBLOCK:
            case BEGIN:
            case END:
                return wLen;

            case LSTRLIT:                   /* String, write characters */
                if (tokenbuf[0] == L'\0')   /* ignore null strings */
                    break;

                /* remove extra nuls */
                while (tokenbuf[token.val-1] == L'\0')
                    token.val--;

                wAlign = token.val + 1;     /* want the character count */
                wLen += wAlign;
                if (fComma) {
                    WriteString(tokenbuf, TRUE);
                } else {
                    AppendString(tokenbuf, TRUE);
                    wLen--;
                }
                break;

            case NUMLIT:            /* Write the computed number out */
                SetItemCount(IndexType, 0);        /* mark data binary */
                if (token.flongval) {
                    WriteLong(token.longval);
                    wLen += sizeof(LONG);
                } else {
                    WriteWord(token.val);
                    wLen += sizeof(WORD);
                }
                break;

            default:
                ParseError1(2133); //"Unexpected value in value data"
                return 0;
        }
    }
}


VOID
DlgIncludeParse(
    PRESINFO pRes
    )
{
    INT     i;
    INT     nbytes;
    char *  lpbuf;

    if (token.type != LSTRLIT) {
        ParseError1(2165);
        return;
    }

    // the DLGINCLUDE statement must be written in ANSI (8-bit) for compatibility
    //    WriteString(tokenbuf);
    nbytes = WideCharToMultiByte (CP_ACP, 0, tokenbuf, -1, NULL, 0, NULL, NULL);
    lpbuf = (char *) MyAlloc (nbytes);
    WideCharToMultiByte (CP_ACP, 0, tokenbuf, -1, lpbuf, nbytes, NULL, NULL);

    for (i = 0; i < nbytes; i++)
         WriteByte (lpbuf[i]);

    MyFree(lpbuf);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
        Note that as of Aug 91, rcpp will not fully transfer the unicode
        characters but only the string constants are guaranteed to be passed
        cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include "rc.h"

extern BOOL WINAPI LocalIsTextUnicode(CONST LPVOID Buffer, int Size, LPINT Result);

INT
DetermineFileType (
    IN      PFILE        fpInputFile
    )

/*++

Routine Description:

    This function is used to determine what type of file is being read.
        Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile                 - File pointer to file we are checking, must be
                                                  open with read permissions.

Return Value:

        DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
                                                          we were checking.  This usually happens when EOF
                                                          is unexpectedly reached.
        DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
                                                          format.
        DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
                                                          which can be directly read into a WCHAR array.
        DFT_FILE_IS_16_BIT_REV  - File was determined to be a 16 bit unicode file
                                                          which has it's bytes reversed in order.

--*/

{
   LONG   lStartFilePos;                     // Storage for file position.
   BYTE   buf[DFT_TEST_SIZE+2];
   LONG   chRead;
   INT    val = 0xFFFF;
   INT    fFileType;

    //
    // Store position so we can get back to it.
    //
    lStartFilePos = ftell (fpInputFile);

    //
    // Make sure we start on an even byte to simplify routines.
    //
    if (lStartFilePos % 2)
        fgetc (fpInputFile);

    chRead = fread (buf, 1, DFT_TEST_SIZE, fpInputFile);
    memset (buf + chRead, 0, sizeof(WCHAR));

    if (LocalIsTextUnicode (buf, chRead, &val))
    {
        if ((val & IS_TEXT_UNICODE_REVERSE_SIGNATURE) == IS_TEXT_UNICODE_REVERSE_SIGNATURE)
            fFileType = DFT_FILE_IS_16_BIT_REV;
        else
            fFileType = DFT_FILE_IS_16_BIT;
    }
    else
        fFileType = DFT_FILE_IS_8_BIT;

    //
    // Return to starting file position.  (usually beginning)
    //

    if (fseek (fpInputFile, lStartFilePos, SEEK_SET) == -1)
        fatal(1002);

    return (fFileType);
}


INT
DetermineSysEndianType (
        VOID
    )

/*++

Routine Description:

    This function is used to determine how the current system stores its
        integers in memory.

    For those of us who are confused by little endian and big endian formats,
        here is a brief recap.

    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
                 is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80

    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high order bytes of a short or long are stored lower
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            80
             01            40
             02            20
             03            10
       This looks correct when memory is dumped in order: 80 40 20 10

Arguments:

        None.

Return Value:

        DSE_SYS_LITTLE_ENDIAN   - The system stores integers in little endian
                                                          format.  (this is 80x86 default).
        DSE_SYS_BIG_ENDIAN      - The system stores integers in big endian format.

--*/

{
    INT     nCheckInteger;
    CHAR    rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT *)rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (CHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT *)rgchTestBytes);

    //
    // See if value was stored in low order of integer.
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF)
        return (DSE_SYS_LITTLE_ENDIAN);
    else
        return (DSE_SYS_LITTLE_ENDIAN);
}


//
// UnicodeCommandLine
//
// Makes a Unicode buffer copy of command line argv arguments
//
WCHAR ** UnicodeCommandLine (int argc, char ** argv)
{
    WCHAR ** argv_U;
    WCHAR ** pU;
    WCHAR *  str;
    int      nbytes;
    int      i;

    // Calculate the size of buffer
    for (i = 0, nbytes = 0; i < argc; i++)
        nbytes += strlen(argv[i]) + 1;
    nbytes *= sizeof(WCHAR);

    /* allocate space for argv[] vector and strings */
    argv_U = (WCHAR **) MyAlloc((argc + 1) * sizeof(WCHAR *) + nbytes);
    if (!argv_U)
        return (NULL);

    /* store args and argv ptrs in just allocated block */
    str = (WCHAR *)(((PBYTE)argv_U) + (argc + 1) * sizeof(WCHAR *));
    for (i = 0, pU = argv_U; i < argc; i++)
    {
        *pU++ = str;
        nbytes = strlen(argv[i]) + 1;
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, argv[i], nbytes, str, nbytes);
        str += nbytes;
    }
    *pU = NULL;

    return (argv_U);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rcpp 16-bit unicode support.  It contains
        the translatation table for codepage 1252.  This was taken from the
        nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#define IN
#define OUT


#define DFT_TEST_SIZE                     250      // The number of bytes to test to get
                                                   //    an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN             0       // File type not yet determined.
#define DFT_FILE_IS_8_BIT               1       // File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT              2       // File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV          3       // File is reversed 16-bit unicode file.

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      PFILE        fpInputFile
    );

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN   1       // Return values from determine system
#define DSE_SYS_BIG_ENDIAN      2       // endian type.

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
        VOID
    );


//
// This function converts command line arguments to Unicode buffer
//
WCHAR ** UnicodeCommandLine (
    int,
    char **
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcx.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"

/////////////////////////////////////////////////////////////////////////////

// Symbol information
static PFILE    fhFileMap;
static LONG     lFileMap;

static PFILE    fhResMap;
static LONG     lResMap;

static PFILE    fhRefMap;
static LONG     lRefMap;

static PFILE    fhSymList;
static LONG     lSymList;

static LONG     HdrOffset;

static CHAR     szEndOfResource[2] = {'$', '\000'};

static wchar_t  szSymList[_MAX_PATH];
static wchar_t  szFileMap[_MAX_PATH];
static wchar_t  szRefMap[_MAX_PATH];
static wchar_t  szResMap[_MAX_PATH];

static WCHAR    szName[] = L"HWB";


#define OPEN_FLAGS (_O_TRUNC | _O_BINARY | _O_CREAT | _O_RDWR)
#define PROT_FLAGS (S_IWRITE | S_IWRITE)

void
wtoa(
    WORD value,
    char* string,
    int radix
    )
{
    if (value == (WORD)-1)
        _itoa(-1, string, radix);
    else
        _itoa(value, string, radix);
}

int
ConvertAndWrite(
    PFILE fp,
    PWCHAR pwch
    )
{
    int  n;
    char szMultiByte[_MAX_PATH];        // assumes _MAX_PATH >= MAX_SYMBOL

    n = wcslen(pwch) + 1;
    n = WideCharToMultiByte(uiCodePage, 0,
                pwch, n,
                szMultiByte, MAX_PATH,
                NULL, NULL);
    return MyWrite(fp, (PVOID)szMultiByte, n);
}

VOID
WriteResHdr (
    FILE *fh,
    LONG size,
    WORD id
    )
{
    LONG     val;

    /* add data size and header size */
    MyWrite(fh, (PVOID)&size, sizeof(ULONG)); // will backpatch
    MyWrite(fh, (PVOID)&HdrOffset, sizeof(ULONG));

    /* add type and name */
    MyWrite(fh, (PVOID)szName, sizeof(szName));
    val = 0xFFFF;
    MyWrite(fh, (PVOID)&val, sizeof(WORD));
    MyWrite(fh, (PVOID)&id, sizeof(WORD));

    MyAlign(fh);

    /* add data struct version, flags, language, resource data version
    /*  and characteristics */
    val = 0;
    MyWrite(fh, (PVOID)&val, sizeof(ULONG));
    val = 0x0030;
    MyWrite(fh, (PVOID)&val, sizeof(WORD));
    MyWrite(fh, (PVOID)&language, sizeof(WORD));
    val = 2;
    MyWrite(fh, (PVOID)&val, sizeof(ULONG));
    MyWrite(fh, (PVOID)&characteristics, sizeof(ULONG));
}

BOOL
InitSymbolInfo(
    void
    )
{
    wchar_t *szTmp;

    if (!fAFXSymbols)
        return(TRUE);

    if ((szTmp = _wtempnam(NULL, L"RCX1")) != NULL) {
        wcscpy(szSymList, szTmp);
        free(szTmp);
    } else {
        wcscpy(szSymList, _wtmpnam(NULL));
    }

    if ((szTmp = _wtempnam(NULL, L"RCX2")) != NULL) {
        wcscpy(szFileMap, szTmp);
        free(szTmp);
    } else {
        wcscpy(szFileMap, _wtmpnam(NULL));
    }

    if ((szTmp = _wtempnam(NULL, L"RCX3")) != NULL) {
        wcscpy(szRefMap, szTmp);
        free(szTmp);
    } else {
        wcscpy(szRefMap, _wtmpnam(NULL));
    }

    if ((szTmp = _wtempnam(NULL, L"RCX4")) != NULL) {
        wcscpy(szResMap, szTmp);
        free(szTmp);
    } else {
        wcscpy(szResMap, _wtmpnam(NULL));
    }

    if (!(fhFileMap = _wfopen(szFileMap, L"w+b")) ||
        !(fhSymList = _wfopen(szSymList, L"w+b")) ||
        !(fhRefMap  = _wfopen(szRefMap,  L"w+b")) ||
        !(fhResMap  = _wfopen(szResMap,  L"w+b")))
        return FALSE;

    /* calculate header size */
    HdrOffset = sizeof(szName);
    HdrOffset += 2 * sizeof(WORD);
    if (HdrOffset % 4)
        HdrOffset += sizeof(WORD);        // could only be off by 2
    HdrOffset += sizeof(RESADDITIONAL);

    WriteResHdr(fhSymList, lSymList, 200);
    WriteResHdr(fhFileMap, lFileMap, 201);
    WriteResHdr(fhRefMap, lRefMap, 202);
    WriteResHdr(fhResMap, lResMap, 2);

    return TRUE;
}

BOOL
TermSymbolInfo(
    PFILE fhResFile
    )
{
    long        lStart;
    PTYPEINFO   pType;
    RESINFO     r;

    if (!fAFXSymbols)
        return(TRUE);

    if (fhResFile == NULL_FILE)
        goto termCloseOnly;

    WriteSymbolDef(L"", L"", L"", 0, (char)0);
    MySeek(fhSymList, 0L, SEEK_SET);
    MyWrite(fhSymList, (PVOID)&lSymList, sizeof(lSymList));

    MySeek(fhFileMap, 0L, SEEK_SET);
    MyWrite(fhFileMap, (PVOID)&lFileMap, sizeof(lFileMap));

    WriteResInfo(NULL, NULL, FALSE);
    MySeek(fhRefMap, 0L, SEEK_SET);
    MyWrite(fhRefMap, (PVOID)&lRefMap, sizeof(lRefMap));

    // now append these to .res
    pType = AddResType(L"HWB", 0);
    r.flags = 0x0030;
    r.name = NULL;
    r.next = NULL;
    r.language = language;
    r.version = version;
    r.characteristics = characteristics;

    MySeek(fhSymList, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lSymList;
    r.nameord = 200;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhSymList, fhResFile);

    MySeek(fhFileMap, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lFileMap;
    r.nameord = 201;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhFileMap, fhResFile);

    MySeek(fhRefMap, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lRefMap;
    r.nameord = 202;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhRefMap, fhResFile);

    MyAlign(fhResFile);
    lStart = MySeek(fhResFile, 0L, SEEK_CUR);
    MySeek(fhResMap, 0L, SEEK_SET);
    MyWrite(fhResMap, (PVOID)&lResMap, sizeof(lResMap));
    MySeek(fhResMap, 0L, SEEK_SET);
    MyCopyAll(fhResMap, fhResFile);

    // patch the HWB:1 resource with HWB:2's starting point
    MySeek(fhResFile, lOffIndex, SEEK_SET);
    MyWrite(fhResFile, (PVOID)&lStart, sizeof(lStart));

    MySeek(fhResFile, 0L, SEEK_END);

termCloseOnly:;

    if (fhFileMap) {
        fclose(fhFileMap);
        _wremove(szFileMap);
    }

    if (fhRefMap) {
        fclose(fhRefMap);
        _wremove(szRefMap);
    }

    if (fhSymList) {
        fclose(fhSymList);
        _wremove(szSymList);
    }

    if (fhResMap) {
        fclose(fhResMap);
        _wremove(szResMap);
    }

    return TRUE;
}


void
WriteSymbolUse(
    PSYMINFO pSym
    )
{
    if (!fAFXSymbols)
        return;

    if (pSym == NULL) {
        WORD nID = (WORD)-1;

        lRefMap += MyWrite(fhRefMap, (PVOID)&szEndOfResource, sizeof(szEndOfResource));
        lRefMap += MyWrite(fhRefMap, (PVOID)&nID, sizeof(nID));
    } else {
        lRefMap += ConvertAndWrite(fhRefMap, pSym->name);
        lRefMap += MyWrite(fhRefMap, (PVOID)&pSym->nID, sizeof(pSym->nID));
    }
}


void
WriteSymbolDef(
    PWCHAR name,
    PWCHAR value,
    PWCHAR file,
    WORD line,
    char flags
    )
{
    if (!fAFXSymbols)
        return;

    if (name[0] == L'$' && value[0] != L'\0') {
        RESINFO     res;
        TYPEINFO    typ;

        res.nameord  = (USHORT) -1;
        res.language = language;
        typ.typeord  = (USHORT) -1;
        WriteFileInfo(&res, &typ, value);
        return;
    }

    lSymList += ConvertAndWrite(fhSymList, name);
    lSymList += ConvertAndWrite(fhSymList, value);

    lSymList += MyWrite(fhSymList, (PVOID)&line, sizeof(line));
    lSymList += MyWrite(fhSymList, (PVOID)&flags, sizeof(flags));
}


void
WriteFileInfo(
    PRESINFO pRes,
    PTYPEINFO pType,
    PWCHAR szFileName
    )
{
    WORD n1 = 0xFFFF;

    if (!fAFXSymbols)
        return;

    if (pType->typeord == 0) {
        lFileMap += MyWrite(fhFileMap, (PVOID)pType->type,
                            (wcslen(pType->type) + 1) * sizeof(WCHAR));
    } else {
        WORD n2 = pType->typeord;

        if (n2 == (WORD)RT_MENUEX)
            n2 = (WORD)RT_MENU;
        else if (n2 == (WORD)RT_DIALOGEX)
            n2 = (WORD)RT_DIALOG;
        lFileMap += MyWrite(fhFileMap, (PVOID)&n1, sizeof(WORD));
        lFileMap += MyWrite(fhFileMap, (PVOID)&n2, sizeof(WORD));
    }

    if (pRes->nameord == 0) {
        lFileMap += MyWrite(fhFileMap, (PVOID)pRes->name,
                            (wcslen(pRes->name) + 1) * sizeof(WCHAR));
    } else {
        lFileMap += MyWrite(fhFileMap, (PVOID)&n1, sizeof(WORD));
        lFileMap += MyWrite(fhFileMap, (PVOID)&pRes->nameord, sizeof(WORD));
    }

    lFileMap += MyWrite(fhFileMap, (PVOID)&pRes->language, sizeof(WORD));
    lFileMap += MyWrite(fhFileMap, (PVOID)szFileName,
                        (wcslen(szFileName) + 1) * sizeof(WCHAR));
}


void
WriteResInfo(
    PRESINFO pRes,
    PTYPEINFO pType,
    BOOL bWriteMapEntry
    )
{
    if (!fAFXSymbols)
        return;

    if (pRes == NULL) {
        WORD nID = (WORD)-1;

        //assert(bWriteMapEntry == FALSE);
        lRefMap += MyWrite(fhRefMap, (PVOID)&szEndOfResource, sizeof(szEndOfResource));
        lRefMap += MyWrite(fhRefMap, (PVOID)&nID, sizeof(nID));

        return;
    }

    if (bWriteMapEntry) {
        WORD n1 = 0xFFFF;
        ULONG t0 = 0;

        /* add data size and data offset */
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->size, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->BinOffset, sizeof(ULONG));

        /* Is this an ordinal type? */
        if (pType->typeord) {
            WORD n2 = pType->typeord;

            if (n2 == (WORD)RT_MENUEX)
                n2 = (WORD)RT_MENU;
            else if (n2 == (WORD)RT_DIALOGEX)
                n2 = (WORD)RT_DIALOG;
            lResMap += MyWrite(fhResMap, (PVOID)&n1, sizeof(WORD));
            lResMap += MyWrite(fhResMap, (PVOID)&n2, sizeof(WORD));
        } else {
            lResMap += MyWrite(fhResMap, (PVOID)pType->type,
                               (wcslen(pType->type) + 1) * sizeof(WCHAR));
        }

        if (pRes->nameord) {
            lResMap += MyWrite(fhResMap, (PVOID)&n1, sizeof(WORD));
            lResMap += MyWrite(fhResMap, (PVOID)&pRes->nameord, sizeof(WORD));
        } else {
            lResMap += MyWrite(fhResMap, (PVOID)pRes->name,
                               (wcslen(pRes->name) + 1) * sizeof(WCHAR));
        }

        lResMap += MyAlign(fhResMap);

        /* add data struct version, flags, language, resource data version
        /*  and characteristics */
        lResMap += MyWrite(fhResMap, (PVOID)&t0, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->flags, sizeof(WORD));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->language, sizeof(WORD));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->version, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->characteristics, sizeof(ULONG));

        return;
    }

    if (pType->typeord == 0) {
        lRefMap += ConvertAndWrite(fhRefMap, pType->type);
    } else {
        char szID[33];
        WORD n2 = pType->typeord;

        if (n2 == (WORD)RT_MENUEX)
            n2 = (WORD)RT_MENU;
        else if (n2 == (WORD)RT_DIALOGEX)
            n2 = (WORD)RT_DIALOG;

        wtoa(n2, szID, 10);
        lRefMap += MyWrite(fhRefMap, (PVOID)szID, strlen(szID)+1);
    }

    if (pRes->nameord == 0) {
        lRefMap += ConvertAndWrite(fhRefMap, pRes->name);
    } else {
        char szID[33];

        wtoa(pRes->nameord, szID, 10);
        lRefMap += MyWrite(fhRefMap, (PVOID)szID, strlen(szID)+1);
    }

    lRefMap += ConvertAndWrite(fhRefMap, pRes->sym.name);
    lRefMap += ConvertAndWrite(fhRefMap, pRes->sym.file);
    lRefMap += MyWrite(fhRefMap,(PVOID)&pRes->sym.line,sizeof(pRes->sym.line));
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GetSymbolDef() - get a symbol def record and write out info          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
GetSymbolDef(
    int fReportError,
    WCHAR curChar
    )
{
    SYMINFO sym;
    WCHAR   szDefn[_MAX_PATH];
    WCHAR   szLine[16];
    PWCHAR  p;
    CHAR    flags = 0;
    WCHAR   currentChar = curChar;

    if (!fAFXSymbols)
        return;

    currentChar = LitChar(); // get past SYMDEFSTART

    /* read the symbol name */
    p = sym.name;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    if (p - sym.name > MAX_SYMBOL) {
        ParseError1(2247);
        return;
    }
    currentChar = LitChar(); /* read past the delimiter */

    p = szDefn;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    currentChar = LitChar(); /* read past the delimiter */

    sym.file[0] = L'\0';

    p = szLine;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    sym.line = (WORD)wcsatoi(szLine);
    currentChar = LitChar(); /* read past the delimiter */

    flags = (CHAR)currentChar;
    flags &= 0x7f; // clear the hi bit
    currentChar = LitChar(); /* read past the delimiter */

    /* leave positioned at last character (LitChar will bump) */
    if (currentChar != SYMDELIMIT) {
        ParseError1(2248);
    }

    WriteSymbolDef(sym.name, szDefn, sym.file, sym.line, flags);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/* GetSymbol() - read a symbol and put id in the token if there              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
GetSymbol(
    int fReportError,
    WCHAR curChar
    )
{
    WCHAR currentChar = curChar;

    token.sym.name[0] = L'\0';
    token.sym.file[0] = L'\0';
    token.sym.line = 0;

    if (!fAFXSymbols)
        return;

    /* skip whitespace */
    while (iswhite(currentChar))
        currentChar = LitChar();

    if (currentChar == SYMUSESTART) {
        WCHAR * p;
        int i = 0;
        WCHAR szLine[16];

        currentChar = LitChar(); // get past SYMUSESTART

        if (currentChar != L'\"') {
            ParseError1(2249);
            return;
        }
        currentChar = LitChar(); // get past the first \"

        /* read the symbol name */
        p = token.sym.name;
        while ((*p++ = currentChar) != SYMDELIMIT)
            currentChar = LitChar();
        *--p = L'\0';
        if (p - token.sym.name > MAX_SYMBOL) {
            ParseError1(2247);
            return;
        }
        currentChar = LitChar(); /* read past the delimiter */

        p = token.sym.file;
        while ((*p++ = currentChar) != SYMDELIMIT)
            currentChar = LitChar();
        *--p = L'\0';
        currentChar = LitChar(); /* read past the delimiter */

        p = szLine;
        while ((*p++ = currentChar) != L'\"')
            currentChar = LitChar();
        *--p = L'\0';
        token.sym.line = (WORD)wcsatoi(szLine);

        if (currentChar != L'\"') {
            ParseError1(2249);
            return;
        }

        currentChar = LitChar(); // get past SYMDELIMIT

        /* skip whitespace */
        while (iswhite(currentChar))
            currentChar = LitChar();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\rcutil.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyAlloc() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

//  HACK Alert.  Allocate an extra longlong and return past it (to allow for PREVCH()
//  to store a byte before the allocation block and to maintain 8 byte alignment).

void *MyAlloc(size_t nbytes)
{
    void *pv = HeapAlloc(hHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, nbytes + 8);

    if (pv == NULL) {
        fatal(1120, nbytes + 8);
    }

    return(((BYTE *) pv) + 8);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyFree() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void MyFree(void *pv)
{
    if (pv != NULL) {
        HeapFree(hHeap, HEAP_NO_SERIALIZE, ((BYTE *) pv) - 8);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyMakeStr() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WCHAR *
MyMakeStr(
    const wchar_t *s
    )
{
    wchar_t *s1;

    if (s != NULL) {
        s1 = (wchar_t *) MyAlloc((wcslen(s) + 1) * sizeof(wchar_t));  /* allocate buffer */
        wcscpy(s1, s);                          /* copy string */
    } else {
        s1 = NULL;
    }

    return(s1);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyRead() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

size_t
MyRead(
    FILE *fh,
    VOID *p,
    size_t n
    )
{
    size_t n1;

    n1 = fread(p, 1, n, fh);

    if (ferror(fh)) {
        fatal(1121);
    }

    return(n1);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyWrite() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

size_t
MyWrite(
    FILE *fh,
    const void *p,
    size_t n
    )
{
    size_t n1;

    if ((n1 = fwrite(p, 1, n, fh)) != n) {
        quit(L"RC : fatal error RW1022: I/O error writing file.");
    }

    return(n1);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyAlign() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

UINT
MyAlign(
    PFILE fh
    )
{
    DWORD t0 = 0;
    DWORD ib;

    /* align file to dword */
    ib = MySeek(fh, 0, SEEK_CUR);

    if (ib % 4) {
        ib = 4 - ib % 4;
        MyWrite(fh, (PVOID)&t0, (UINT)ib);
        return(ib);
    }

    return(0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MySeek() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

LONG
MySeek(
    FILE *fh,
    LONG pos,
    int cmd
    )
{
    if (fseek(fh, pos, cmd))
        quit(L"RC : fatal error RW1023: I/O error seeking in file");

    if ((pos = ftell (fh)) == -1L)
        quit(L"RC : fatal error RW1023: I/O error seeking in file");

    return(pos);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyCopy() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

size_t
MyCopy(
    FILE *srcfh,
    FILE *dstfh,
    size_t nbytes
    )
{
    void *buffer = MyAlloc(BUFSIZE);

    size_t n = 0;

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;

        nbytes -= n;

        MyRead(srcfh, buffer, n);
        MyWrite(dstfh, buffer, n);
    }

    MyFree(buffer);

    return(n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyCopyAll() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
MyCopyAll(
    FILE *srcfh,
    PFILE dstfh
    )
{
    PCHAR  buffer = (PCHAR) MyAlloc(BUFSIZE);

    UINT n;

    while ((n = fread(buffer, 1, BUFSIZE, srcfh)) != 0)
        MyWrite(dstfh, buffer, n);

    MyFree(buffer);

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  strpre() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* strpre: return -1 if pch1 is a prefix of pch2, 0 otherwise.
 * compare is case insensitive.
 */

int
strpre(
    const wchar_t *pch1,
    const wchar_t *pch2
    )
{
    while (*pch1) {
        if (!*pch2)
            return 0;
        else if (towupper(*pch1) == towupper(*pch2))
            pch1++, pch2++;
        else
            return 0;
    }
    return - 1;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  iswhite() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
iswhite (
    WCHAR c
    )
{
    /* returns true for whitespace and linebreak characters */
    switch (c) {
        case L' ':
        case L'\t':
        case L'\r':
        case L'\n':
        case EOF:
            return(-1);
            break;
        default:
            return(0);
            break;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IsSwitchChar() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL
IsSwitchChar(
    wchar_t c
    )
{
    /* true for switch characters */
    return (c == L'/' || c == L'-');
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ExtractFileName(szFullName, szFileName) -                                */
/*                                                                           */
/*      This routine is used to extract just the file name from a string     */
/*  that may or may not contain a full or partial path name.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
ExtractFileName(
    const wchar_t *szFullName,
    wchar_t *szFileName
    )
{
    int iLen;
    PWCHAR pCh;

    iLen = wcslen(szFullName);

    /* Goto the last character of the full name; */
    pCh = (PWCHAR)(szFullName + iLen);
    pCh--;

    /* Look for '/', '\\' or ':' character */
    while (iLen--) {
        if ((*pCh == L'\\') || (*pCh == L'/') || (*pCh == L':'))
            break;
        pCh--;
    }

    wcscpy(szFileName, ++pCh);
}


DWORD
wcsatoi(
    const wchar_t *s
    )
{
    DWORD       t = 0;

    while (*s) {
        t = 10 * t + (DWORD)((CHAR)*s - '0');
        s++;
    }
    return t;
}


WCHAR *
wcsitow(
    LONG   v,
    WCHAR *s,
    DWORD  r
    )
{
    DWORD       cb = 0;
    DWORD       t;
    DWORD       tt = v;

    while (tt) {
        t = tt % r;
        cb++;
        tt /= r;
    }

    s += cb;
    *s-- = 0;
    while (v) {
        t = v % r;
        *s-- = (WCHAR)((CHAR)t + '0');
        v /= r;
    }
    return ++s;
}


// ----------------------------------------------------------------------------
//
//  PreBeginParse
//
// ----------------------------------------------------------------------------

VOID
PreBeginParse(
    PRESINFO pRes,
    int id
    )
{
    while (token.type != BEGIN) {
        switch (token.type) {
            case TKLANGUAGE:
                pRes->language = GetLanguage();
                break;

            case TKVERSION:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2139);
                pRes->version = token.longval;
                break;

            case TKCHARACTERISTICS:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2140);
                pRes->characteristics = token.longval;
                break;

            default:
                ParseError1(id);
                break;
        }
        GetToken(FALSE);
    }

    if (token.type != BEGIN)
        ParseError1(id);

    GetToken(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\tokens.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.	All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include <rc.h>

/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
const keytab_t Tokstrings[] = {
#define DAT(tok1, name2, map3, il4, mmap5)      { name2, map3 },
#include "tokdat.h"
#undef DAT
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\resfile.h ===
typedef struct tagRESADDITIONAL
{
    DWORD       DataSize;               // size of data without header
    DWORD       HeaderSize;     // Length of the header
    // [Ordinal or Name TYPE]
    // [Ordinal or Name NAME]
    DWORD       DataVersion;    // version of data struct
    WORD        MemoryFlags;    // state of the resource
    WORD        LanguageId;     // Unicode support for NLS
    DWORD       Version;        // Version of the resource data
    DWORD       Characteristics;        // Characteristics of the data
} RESADDITIONAL, *PRESADDITIONAL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\strings.h ===
#define RCON_REAL(p)    ((p)->rcon_real)

/*
**  given a VALUE ptr, return the various fields.
*/
#define PV_RCON(P)      ((P)->v_rcon)
#define PV_DOUBLE(P)    (PV_RCON(P)->rcon_real)
#define PV_LONG(P)      ((P)->v_long)
#define PV_STRPTR(P)    ((P)->v_string.str_ptr)
#define PV_STRLEN(P)    ((P)->v_string.str_len)
#define PV_SYM(P)       ((P)->v_symbol)
/*
**  given a reference to a VALUE, return the given field
*/
#define V_RCON(V)       ((V).v_rcon)
#define V_DOUBLE(V)     (V_RCON(V)->rcon_real)
#define V_LONG(V)       ((V).v_long)
#define V_STRPTR(V)     ((V).v_string.str_ptr)
#define V_STRLEN(V)     ((V).v_string.str_len)
#define V_SYM(V)        ((V).v_symbol)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\trees.h ===
/*
**      Tree types
*/
#define TTfree                  0x0
#define TTconstant              0x01
#define TTsymbol                0x02
#define TTunary                 0x04
#define TTleaf                  0x08
#define TTbinary                0x10
#define TThybrid                0x20
#define TTBasicShape    (TTfree|TTconstant|TTsymbol|TTunary|TTbinary|TThybrid)
#define TTzero                  0x40

typedef USHORT          p2type_t;
typedef p2type_t        *pp2type_t;

typedef struct  tree_200        {
        ptree_t         tr_left;        /*  left child  */
        ptree_t         tr_right;       /*  right child  */
        } tree_200_st;

typedef struct  tree_190        {
        ptree_t         tr_uchild;      /*  unary child  */
        } tree_190_st;

typedef struct  tree_180        {
        psym_t          tr_symbol;      /*  symbol  */
        } tree_180_st;

typedef struct  tree_170        {
        value_t         tr_value;       /*  value of the tree  */
        } tree_170_st;

typedef union   tree_100        {
        tree_200_st     t200;
        tree_190_st     t190;
        tree_180_st     t180;
        tree_170_st     t170;
        } tree_100_st;

struct  s_tree  {
        token_t         tr_token;       /*  tree's token  */
        shape_t         tr_shape;       /*  tree shape  */
        ptype_t         tr_p1type;      /*  p1's view of the type  */
        p2type_t        tr_p2type;      /*  p1's view of the type p2 should have */
        tree_100_st     t100;
        };

#define TR_SHAPE(P)     ((P)->tr_shape)
#define BASIC_SHAPE(S)  ((S) & TTBasicShape)
#define TR_TOKEN(P)     ((P)->tr_token)
#define TR_P1TYPE(P)    ((P)->tr_p1type)                /*  resultant type  */
#define TR_P2TYPE(P)    ((P)->tr_p2type)                /*  resultant type  */
#define TR_ISZERO(P)    (TR_SHAPE(P) & TTzero)

#define TR_LEFT(P)      ((P)->t100.t200.tr_left)        /*  left child  */
#define TR_RIGHT(P)     ((P)->t100.t200.tr_right)       /*  right child  */
#define TR_UCHILD(P)    ((P)->t100.t190.tr_uchild)      /*  unary's child */
#define TR_SVALUE(P)    ((P)->t100.t180.tr_symbol)      /*  ptr to the symbol */
#define TR_VALUE(P)     ((P)->t100.t170.tr_value)       /*  value of tree  */

#define TR_RCON(P)      (TR_VALUE(P).v_rcon)            /*  real constant  */
#define TR_DVALUE(P)    (TR_RCON(P)->rcon_real) /*  double value  */
#define TR_LVALUE(P)    (TR_VALUE(P).v_long)            /*  long value  */
#define TR_STRING(P)    (TR_VALUE(P).v_string)  /*  string value  */

#define TR_CVALUE(P)    (TR_STRING(P).str_ptr)  /*  ptr to string  */
#define TR_CLEN(P)      (TR_STRING(P).str_len)  /*  length of string  */

#define TR_BTYPE(P)     (TY_BTYPE(TR_P1TYPE(P)))/*  base type  */
#define TR_ESU(P)       (TY_ESU(TR_P1TYPE(P)))  /*  parent enum/struct/union  */
#define TR_INDIR(P)     (TY_INDIR(TR_P1TYPE(P)))

#define TR_INEXT(P)     (INDIR_INEXT(TR_INDIR(P)))
#define TR_ITYPE(P)     (INDIR_ITYPE(TR_INDIR(P)))
#define TR_ISUB(P)      (INDIR_ISUB(TR_INDIR(P)))
#define TR_IFORMALS(P)  (INDIR_IFORMALS(TR_INDIR(P)))
/*
**  for cases
*/
struct  s_case  {
        case_t  *c_next;        /*  next in list  */
        long    c_expr;         /*  value of constant expression  */
        p1key_t c_label;        /*  label to which to jump if expr  */
        };

#define NEXT_CASE(p)    ((p)->c_next)
#define CASE_EXPR(p)    ((p)->c_expr)
#define CASE_LABEL(p)   ((p)->c_label)

/*
**  loop inversion structs
**  for( init; test; incr ) { ... }
**  we handle : sym | const relop sym | const; sym op sym | const
*/
typedef struct  s_loopia         loopia_t, *loopiap_t;
typedef struct  s_liarray        liarray_t, *liarrayp_t;

struct  s_loopia        {
        token_t         lia_token;
        union   {
                psym_t          lia_sym;
                long            lia_value;
                liarrayp_t      lia_array;
                } lia_union;
        };

#define LIA_TOKEN(p)    ((p)->lia_token)
#define LIA_SYM(p)      ((p)->lia_union.lia_sym)
#define LIA_VALUE(p)    ((p)->lia_union.lia_value)
#define LIA_ARRAY(p)    ((p)->lia_union.lia_array)

typedef struct  s_liarray       {
        loopia_t        liar_left;
        loopia_t        liar_right;
        } liarray;

#define LIAR_LEFT(p)    (&((p)->liar_left))
#define LIAR_RIGHT(p)   (&((p)->liar_right))

typedef struct  s_loopi {
        int             li_relop;
        int             li_incop;
        loopia_t        li_w;
        loopia_t        li_x;
        loopia_t        li_y;
        loopia_t        li_z;
        } loopi_t, *loopip_t;

#define LOOP_RELOP(p)   ((p)->li_relop)
#define LOOP_INCOP(p)   ((p)->li_incop)

#define LOOP_W(p)       (&((p)->li_w))
#define LOOP_X(p)       (&((p)->li_x))
#define LOOP_Y(p)       (&((p)->li_y))
#define LOOP_Z(p)       (&((p)->li_z))

#define LOOP_W_TOKEN(p) LIA_TOKEN(LOOP_W(p))
#define LOOP_X_TOKEN(p) LIA_TOKEN(LOOP_X(p))
#define LOOP_Y_TOKEN(p) LIA_TOKEN(LOOP_Y(p))
#define LOOP_Z_TOKEN(p) LIA_TOKEN(LOOP_Z(p))

#define LOOP_W_SYM(p)   LIA_SYM(LOOP_W(p))
#define LOOP_X_SYM(p)   LIA_SYM(LOOP_X(p))
#define LOOP_Y_SYM(p)   LIA_SYM(LOOP_Y(p))
#define LOOP_Z_SYM(p)   LIA_SYM(LOOP_Z(p))

#define LOOP_W_VALUE(p) LIA_VALUE(LOOP_W(p))
#define LOOP_X_VALUE(p) LIA_VALUE(LOOP_X(p))
#define LOOP_Y_VALUE(p) LIA_VALUE(LOOP_Y(p))
#define LOOP_Z_VALUE(p) LIA_VALUE(LOOP_Z(p))
/*
**      stack structure for saving items which must be stacked at various places
*/
struct  s_stack {
        stack_t *stk_next;
        union   {
                ptree_t         sv_tree;
                psym_t          sv_sym;
                int             sv_int;
                loopip_t        sv_loopi;
                } stk_value;
        };

#define TEST_LAB                (Test->stk_value.sv_tree)
#define START_LAB               (Start->stk_value.sv_tree)
#define CONTINUE_LAB            (Continue->stk_value.sv_tree)
#define BREAK_LAB               (Break->stk_value.sv_tree)
#define CA_LAB                  (Case->stk_value.sv_tree)
#define DEFAULT_LAB             (Default->stk_value.sv_tree)

#define LOOPI(p)                ((p)->stk_value.sv_loopi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdump\rcdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rcdump.c

Abstract:

    Program to dump the resources from an image file.

Author:

    Steve Wood (stevewo) 17-Jul-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
Usage( void );

void
DumpResources( char *FileName );


BOOL VerboseOutput;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    int i;

    VerboseOutput = FALSE;
    if (argc > 1) {
        for (i=1; i<argc; i++) {
            s = _strupr( argv[i] );
            if (*s == '-' || *s == '/') {
                while (*++s)
                    switch( *s ) {
                    case 'V':
                        VerboseOutput = TRUE;
                        break;

                    default:
                        fprintf( stderr,
                                 "RCDUMP: Invalid switch letter '%c'\n",
                                 *s
                               );
                        Usage();
                    }
                }
            else {
                DumpResources( argv[i] );
                }
            }
        }
    else {
        Usage();
        }

    exit( 0 );
    return 1;
}


void
Usage( void )
{
    fprintf( stderr, "usage: RCDUMP [-v] ImageFileName(s)\n" );
    exit( 1 );
}

BOOL
EnumTypesFunc(
    HMODULE hModule,
    LPSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LPARAM lParam
    );


void
DumpResources(
    char *FileName
    )
{
    HMODULE hModule;

    if (FileName != NULL) {
        int i;
        i = SetErrorMode(SEM_FAILCRITICALERRORS);
        hModule = LoadLibraryEx( FileName, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE );
        SetErrorMode(i);
    } else {
        hModule = NULL;
    }

    if (FileName != NULL && hModule == NULL) {
        printf( "RCDUMP: Unable to load image file %s - rc == %u\n",
                FileName,
                GetLastError()
              );
    } else {
        printf( "%s contains the following resources:\n",
                FileName ? FileName : "RCDUMP"
              );
        EnumResourceTypes( hModule, EnumTypesFunc, -1L );
    }
}


CHAR const *pTypeName[] = {
    NULL,           //  0
    "CURSOR",       //  1 RT_CURSOR
    "BITMAP",       //  2 RT_BITMAP
    "ICON",         //  3 RT_ICON
    "MENU",         //  4 RT_MENU
    "DIALOG",       //  5 RT_DIALOG
    "STRING",       //  6 RT_STRING
    "FONTDIR",      //  7 RT_FONTDIR
    "FONT",         //  8 RT_FONT
    "ACCELERATOR",  //  9 RT_ACCELERATOR
    "RCDATA",       // 10 RT_RCDATA
    "MESSAGETABLE", // 11 RT_MESSAGETABLE
    "GROUP_CURSOR", // 12 RT_GROUP_CURSOR
    NULL,           // 13 RT_NEWBITMAP -- according to NT
    "GROUP_ICON",   // 14 RT_GROUP_ICON
    NULL,           // 15 RT_NAMETABLE
    "VERSION",      // 16 RT_VERSION
    "DIALOGEX",     // 17 RT_DIALOGEX     ;internal
    "DLGINCLUDE",   // 18 RT_DLGINCLUDE
    "PLUGPLAY",     // 19 RT_PLUGPLAY
    "VXD",          // 20 RT_VXD
    "ANICURSOR",    // 21 RT_ANICURSOR    ;internal
    "ANIICON",      // 22 RT_ANIICON      ;internal
    "HTML"          // 23 RT_HTML
    };

BOOL
EnumTypesFunc(
    HMODULE hModule,
    LPSTR lpType,
    LPARAM lParam
    )
{
    if (lParam != -1L) {
        printf( "RCDUMP: EnumTypesFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "Type: " );
    if ((ULONG_PTR)lpType & 0xFFFF0000) {
        printf("%s\n", lpType);
        }
    else {
        WORD wType = (WORD) lpType;

        if ((wType > sizeof(pTypeName) / sizeof(char *)) || (pTypeName[wType] == NULL))
            printf("%u\n", wType);
        else
            printf("%s\n", pTypeName[wType]);
        }

    EnumResourceNames( hModule,
                       lpType,
                       EnumNamesFunc,
                       -2L
                     );

    return TRUE;
}


BOOL
EnumNamesFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LPARAM lParam
    )
{
    if (lParam != -2L) {
        printf( "RCDUMP: EnumNamesFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "    Name: " );
    if ((ULONG_PTR)lpName & 0xFFFF0000) {
        printf("%s\n", lpName);
    } else {
        printf( "%u\n", (USHORT)lpName );
    }

    EnumResourceLanguages( hModule,
                       lpType,
                       lpName,
                       EnumLangsFunc,
                       -3L
                     );
    return TRUE;
}


BOOL
EnumLangsFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LPARAM lParam
    )
{
    HRSRC hResInfo;
    PVOID pv;
    HGLOBAL hr;

    if (lParam != -3L) {
        printf( "RCDUMP: EnumLangsFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "        Resource: " );
    if ((ULONG_PTR)lpName & 0xFFFF0000) {
        printf( "%s . ", lpName );
    } else {
        printf( "%u . ", (USHORT)lpName );
    }

    if ((ULONG_PTR)lpType & 0xFFFF0000) {
        printf("%s . ", lpType );
        }
    else {
        WORD wType = (WORD) lpType;

        if ((wType > sizeof(pTypeName) / sizeof(char *)) || (pTypeName[wType] == NULL))
            printf("%u\n", wType);
        else
            printf("%s\n", pTypeName[wType]);
        }

    printf( "%08x", language );
    hResInfo = FindResourceEx( hModule, lpType, lpName, language );
    if (hResInfo == NULL) {
        printf( " - FindResourceEx failed, rc == %u\n", GetLastError() );
    } else {
        hr = LoadResource(hModule, hResInfo);
        pv = LockResource(hr);

        if (VerboseOutput && pv) {
            if (lpType == RT_MESSAGETABLE) {
                PMESSAGE_RESOURCE_DATA pmrd;
                PMESSAGE_RESOURCE_BLOCK pmrb;
                PMESSAGE_RESOURCE_ENTRY pmre;
                ULONG i, j;
                ULONG cb;

                printf("\n");
                pmrd = (PMESSAGE_RESOURCE_DATA) pv;
                pmrb = &(pmrd->Blocks[0]);
                for (i=pmrd->NumberOfBlocks ; i>0 ; i--,pmrb++) {
                    pmre = (PMESSAGE_RESOURCE_ENTRY)(((char*)pv)+pmrb->OffsetToEntries);
                    for (j=pmrb->LowId ; j<=pmrb->HighId ; j++) {
                        if (pmre->Flags & MESSAGE_RESOURCE_UNICODE) {
                            printf("%d - \"%ws\"\n", j, &(pmre->Text));
                        } else {
                            printf("%d - \"%s\"\n", j, &(pmre->Text));
                        }
                        pmre = (PMESSAGE_RESOURCE_ENTRY)(((char*)pmre) + pmre->Length);
                    }
                }
            } else
            if (lpType == RT_STRING) {
                int i;
                PWCHAR pw;

                printf("\n");
                pw = (PWCHAR) pv;
                for (i=0 ; i<16 ; i++,pw++) {
                    if (*pw) {
                        printf("%d - \"%-.*ws\"\n", i+((USHORT)lpName)*16, *pw, pw+1);
                        pw += *pw;
                    }
                }
            } else {
                printf( " - hResInfo == %p,\n\t\tAddress == %p - Size == %lu\n",
                    hResInfo, pv, SizeofResource( hModule, hResInfo )
                      );
            }
        } else {
            printf( " - hResInfo == %p,\n\t\tAddress == %p - Size == %lu\n",
                hResInfo,
                pv, SizeofResource( hModule, hResInfo )

              );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\tokdat.h ===
/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC
 * and inline assembler.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
/* token        TEXT             MAPPED TO       IL OPCODE       ASM TOKEN */

DAT(L_NOTOKEN,  L"newline",      L_NOTOKEN,      MAX_OPCODE,     ML_NL)
DAT(L_IDENT,    L"identifier",   L_IDENT,        OPname,         ML_IDENT)
DAT(L_STRING,   L"string",       L_STRING,       OPconstant,     ML_NOTOKEN)
DAT(L_CFLOAT,   L"float constant", L_CONSTANT,   OPconstant,     ML_NOTOKEN)
DAT(L_CDOUBLE,  L"double constant", L_CONSTANT,  OPconstant,     ML_NOTOKEN)
DAT(L_CLDOUBLE, L"long double constant",L_CONSTANT, OPconstant,  ML_NOTOKEN)
DAT(L_CINTEGER, L"int constant", L_CONSTANT,     OPconstant,     ML_CONSTANT)
DAT(L_LONGINT,  L"long constant", L_CONSTANT,    OPconstant,     ML_CONSTANT)
DAT(L_CUNSIGNED,L"unsigned int constant",L_CONSTANT,OPconstant,  ML_CONSTANT)
DAT(L_LONGUNSIGNED,L"unsigned long constant",L_CONSTANT,OPconstant,ML_CONSTANT)
DAT(L_AUTO,     L"auto",         L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_STATIC,   L"static",       L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_EXTERN,   L"extern",       L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_REGISTER, L"register",     L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_TYPEDEF,  L"typedef",      L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_FORTRAN,  Fortran_str,     L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_PASCAL,   Pascal_str,      L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_C,        Cdecl_str,       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_INTERRUPT,L"interrupt",    L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_SAVEREGS, L"saveregs",     L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_LOADDS,   L"loadds",       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_EXPORT,   L"export",       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_ASM,      L"_asm",         L_ASM,          MAX_OPCODE,     ML_NL)
DAT(L_NEAR,     L"near",         L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_FAR,      L"far",          L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_HUGE,     L"huge",         L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_CONST,    L"const",        L_MODIFIER,     MAX_OPCODE,     ML_CDATATYPE)
DAT(L_VOLATILE, L"volatile",     L_MODIFIER,     MAX_OPCODE,     ML_CDATATYPE)
DAT(L_CHAR,     L"char",         L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_INT,      L"int",          L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_FLOAT,    L"float",        L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_DOUBLE,   L"double",       L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_SHORT,    L"short",        L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_LONG,     L"long",         L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_VOID,     L"void",         L_TYPE,         MAX_OPCODE,     ML_IDENT)
DAT(L_SIGNED,   L"signed",       L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_UNSIGNED, L"unsigned",     L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_ENUM,     L"enum",         L_ENUM,         MAX_OPCODE,     ML_IDENT)
DAT(L_ENUM_TAG, L"enum tag",     L_ENUM_TAG,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_STRUCT,   L"struct",       L_STRUCT,       MAX_OPCODE,     ML_IDENT)
DAT(L_STRUCT_TAG,L"struct tag",  L_STRUCT_TAG,   MAX_OPCODE,     ML_NOTOKEN)
DAT(L_UNION,    L"union",        L_UNION,        MAX_OPCODE,     ML_IDENT)
DAT(L_UNION_TAG,L"union tag",    L_UNION_TAG,    MAX_OPCODE,     ML_NOTOKEN)
DAT(L_AND,      L"&",            L_AND,          OPband,         ML_AND)
DAT(L_ANDAND,   L"&&",           L_ANDAND,       OPandif,        ML_NOTOKEN)
DAT(L_ANDEQ,    L"&=",           L_ASOP,         OPandeq,        ML_NOTOKEN)
DAT(L_ASSIGN,   L"=",            L_ASSIGN,       OPassign,       ML_NOTOKEN)
DAT(L_BIT,      L"bit field",    L_BIT,          OPbit,          ML_NOTOKEN)
DAT(L_COLON,    L":",            L_COLON,        OPcolon,        ML_COLON)
DAT(L_COMMA,    L",",            L_COMMA,        OPcomma,        ML_COMMA)
DAT(L_DECR,     L"--",           L_INCOP,        OPpostdecr,     ML_NOTOKEN)
DAT(L_DIV,      L"/",            L_DIVOP,        OPdiv,          ML_DIV)
DAT(L_DIVEQ,    L"/=",           L_ASOP,         OPdiveq,        ML_NOTOKEN)
DAT(L_EQUALS,   L"==",           L_EQUOP,        OPeq,           ML_EQ)
DAT(L_EXCLAIM,  L"!",            L_EXCLAIM,      OPnot,          ML_NOTOKEN)
DAT(L_EXTRACT,  L"*",            L_EXTRACT,      OPextract,      ML_NOTOKEN)
DAT(L_GT,       L">",            L_RELOP,        OPgt,           ML_GT)
DAT(L_GTEQ,     L">=",           L_RELOP,        OPge,           ML_GE)
DAT(L_INCR,     L"++",           L_INCOP,        OPpostincr,     ML_NOTOKEN)
DAT(L_LBRACK,   L"[",            L_LBRACK,       OPindex,        ML_LBRACK)
DAT(L_LSHFTEQ,  L"<<=",          L_ASOP,         OPlsheq,        ML_NOTOKEN)
DAT(L_LSHIFT,   L"<<",           L_SHIFTOP,      OPlshift,       ML_SHL)
DAT(L_LT,       L"<",            L_RELOP,        OPlt,           ML_LT)
DAT(L_LTEQ,     L"<=",           L_RELOP,        OPle,           ML_LE)
DAT(L_MINUS,    L"-",            L_MINUS,        OPminus,        ML_SUB)
DAT(L_MINUSEQ,  L"-=",           L_ASOP,         OPminuseq,      ML_NOTOKEN)
DAT(L_MOD,      L"%",            L_DIVOP,        OPrem,          ML_MOD)
DAT(L_MODEQ,    L"%=",           L_ASOP,         OPremeq,        ML_NOTOKEN)
DAT(L_MULT,     L"*",            L_MULT,         OPmult,         ML_MUL)
DAT(L_MULTEQ,   L"*=",           L_ASOP,         OPmulteq,       ML_NOTOKEN)
DAT(L_NOTEQ,    L"!=",           L_EQUOP,        OPne,           ML_NE)
DAT(L_OR,       L"|",            L_OR,           OPbor,          ML_OR)
DAT(L_OREQ,     L"|=",           L_ASOP,         OPoreq,         ML_NOTOKEN)
DAT(L_OROR,     L"||",           L_OROR,         OPorelse,       ML_NOTOKEN)
DAT(L_PERIOD,   L".",            L_STUNOP,       OPfield,        ML_PERIOD)
DAT(L_PLUS,     L"+",            L_PLUS,         OPplus,         ML_ADD)
DAT(L_PLUSEQ,   L"+=",           L_ASOP,         OPpluseq,       ML_NOTOKEN)
DAT(L_POINTSTO, L"->",           L_STUNOP,       OPfield,        ML_NOTOKEN)
DAT(L_PREDECR,  L"--",           L_INCOP,        OPminuseq,      ML_NOTOKEN)
DAT(L_PREINCR,  L"++",           L_INCOP,        OPpluseq,       ML_NOTOKEN)
DAT(L_QUEST,    L"?",            L_QUEST,        OPquestion,     ML_NOTOKEN)
DAT(L_RSHFTEQ,  L">>=",          L_ASOP,         OPrsheq,        ML_NOTOKEN)
DAT(L_RSHIFT,   L">>",           L_SHIFTOP,      OPrshift,       ML_SHR)
DAT(L_TILDE,    L"~",            L_TILDE,        OPcompl,        ML_NOT)
DAT(L_UMINUS,   L"unary minus",  L_UMINUS,       OPneg,          ML_NOTOKEN)
DAT(L_XOR,      L"^",            L_XOR,          OPxor,          ML_XOR)
DAT(L_XOREQ,    L"^=",           L_ASOP,         OPxoreq,        ML_NOTOKEN)
DAT(L_ARG,      L"argument",     L_ARG,          OPargument,     ML_NOTOKEN)
DAT(L_ASOP,     L"assign op",    L_ASOP,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_BREAK,    L"break",        L_BREAK,        MAX_OPCODE,     ML_IDENT)
DAT(L_CASE,     L"case",         L_CASE,         OPcase,         ML_IDENT)
DAT(L_CAST,     L"cast",         L_CAST,         OPcast,         ML_NOTOKEN)
DAT(L_CLASS,    L"storage class",L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_CONSTANT, L"constant",     L_CONSTANT,     MAX_OPCODE,     ML_MAPPED)
DAT(L_CONTINUE, L"continue",     L_CONTINUE,     MAX_OPCODE,     ML_IDENT)
DAT(L_DEFAULT,  L"default",      L_DEFAULT,      MAX_OPCODE,     ML_IDENT)
DAT(L_DIVOP,    L"div op",       L_DIVOP,        MAX_OPCODE,     ML_MAPPED)
DAT(L_DO,       L"do",           L_DO,           MAX_OPCODE,     ML_IDENT)
DAT(L_ELLIPSIS, L"...",          L_ELLIPSIS,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_ELSE,     L"else",         L_ELSE,         MAX_OPCODE,     ML_IDENT)
DAT(L_ENTRY,    L"entry",        L_ENTRY,        OPentry,        ML_NOTOKEN)
DAT(L_EOF,      L"end of file",  0,              MAX_OPCODE,     ML_EOF)
DAT(L_EQUOP,    L"equ op",       L_EQUOP,        MAX_OPCODE,     ML_NOTOKEN)
DAT(L_FILE,     0,               L_FILE,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_FOR,      L"for",          L_FOR,          MAX_OPCODE,     ML_IDENT)
DAT(L_FUNCTION, L"argument",     L_FUNCTION,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_GOTO,     L"goto",         L_GOTO,         MAX_OPCODE,     ML_IDENT)
DAT(L_IF,       L"if",           L_IF,           MAX_OPCODE,     ML_IDENT)
DAT(L_INCOP,    L"incr op",      L_INCOP,        MAX_OPCODE,     ML_NOTOKEN)
DAT(L_INIT,     L"initializing", L_INIT,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_LCURLY,   L"{",            L_LCURLY,       MAX_OPCODE,     ML_LCURLY)
DAT(L_LINE,     L"line",         L_LINE,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_LPAREN,   L"(",            L_LPAREN,       OPfunction,     ML_LPAREN)
DAT(L_INTRINSIC,L"intrinsic",    L_INTRINSIC,    OPintrinsic,    ML_NOTOKEN)
DAT(L_MODIFIER, L"modifier",     L_MODIFIER,     MAX_OPCODE,     ML_MAPPED)
DAT(L_MODULE,   L"module",       L_MODULE,       MAX_OPCODE,     ML_NOTOKEN)
DAT(L_RBRACK,   L"]",            L_RBRACK,       MAX_OPCODE,     ML_RBRACK)
DAT(L_RCURLY,   L"}",            L_RCURLY,       MAX_OPCODE,     ML_NL)
DAT(L_RELOP,    L"rel op",       L_RELOP,        MAX_OPCODE,     ML_MAPPED)
DAT(L_RETURN,   L"return",       L_RETURN,       MAX_OPCODE,     ML_IDENT)
DAT(L_RPAREN,   L")",            L_RPAREN,       MAX_OPCODE,     ML_RPAREN)
DAT(L_SELF,     L"_self",        L_SELF,         OPself,         ML_IDENT)
DAT(L_SEMI,     L";",            L_SEMI,         MAX_OPCODE,     ML_SEMI)
DAT(L_SHIFTOP,  L"shift op",     L_SHIFTOP,      MAX_OPCODE,     ML_MAPPED)
DAT(L_SIZEOF,   L"sizeof",       L_SIZEOF,       MAX_OPCODE,     ML_IDENT)
DAT(L_STUNOP,   L"struct op",    L_STUNOP,       MAX_OPCODE,     ML_MAPPED)
DAT(L_SW,       L"switch",       L_SW,           OPswitch,       ML_IDENT)
DAT(L_SWEXP,    0,               L_SWEXP,        OPswexp,        ML_NOTOKEN)
DAT(L_TYPE,     L"type",         L_TYPE,         MAX_OPCODE,     ML_MAPPED)
DAT(L_TYPENAME, L"typedef name", L_TYPENAME,     MAX_OPCODE,     ML_CTYPENAME)
DAT(L_UPLUS,    L"unary plus",   L_UPLUS,        OPparen,        ML_NOTOKEN)
DAT(L_WHILE,    L"while",        L_WHILE,        MAX_OPCODE,     ML_IDENT)
DAT(0,          0,               0,              MAX_OPCODE,     ML_NOTOKEN)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\scanner.c ===
/***********************************************************************
* Microsoft (R) Windows (R) Resource Compiler
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#include "rc.h"


#define ABS(x) ((x > 0) ? x : -1 * x)


#define ALERT_CHAR      L'\007'          /* ANSI alert character is ASCII BEL */

ULONG lCPPTotalLinenumber = 0;

extern int vfCurrFileType;      //- Added for 16-bit file support.


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
token_t c_size(long);
int     ctoi(int);
int     escape(int);
token_t get_real(PWCHAR);
token_t l_size(long);
long    matol(PWCHAR, int);
token_t uc_size(long);
token_t ul_size(long);
void    skip_1comment(void);



/************************************************************************/
/* local_c_hash                                                         */
/************************************************************************/
hash_t
local_c_hash(
    REG WCHAR *name
    )
{
    REG hash_t  i;

    i = 0;
    while(*name) {
        i += (*name & HASH_MASK);
        name++;
    }
    return(i);
}


/************************************************************************
 * GETID - Get an identifier or keyword.
 * (we know that we're given at least 1 id char)
 * in addition, we'll hash the value using 'c'.
 ************************************************************************/
void
getid(
    REG  UINT c
    )
{
    REG WCHAR   *p;

    p = Reuse_W;
    *p++ = (WCHAR)c;
    c &= HASH_MASK;

repeat:
    while(LXC_IS_IDENT(*p = GETCH())) {    /* while it's an id char . . . */
        c += (*p & HASH_MASK);                  /* hash it */
        p++;
    }
    if(*p != EOS_CHAR) {
        if((*p == L'\\') && (checknl())) {
            goto repeat;
        }
        UNGETCH();
        if(p >= LIMIT(Reuse_W)) {
            fatal(1067);
        }
        if(     ((p - Reuse_W) > LIMIT_ID_LENGTH) && ( ! Prep )) {
            p = Reuse_W + LIMIT_ID_LENGTH;
            *p++ = L'\0';
            c = local_c_hash(Reuse_W);
            warning(4011, Reuse_W);      /* id truncated */
        } else {
            *p++ = L'\0';
        }
        Reuse_W_hash = (hash_t)c;
        Reuse_W_length = (UINT)(p - Reuse_W);
        return;
    }

    if(io_eob()) {                      /* end of file in middle of id */
        fatal(1004);
    }

    goto repeat;
}


/************************************************************************
**      prep_string : outputs char/string constants when preprocessing only
************************************************************************/
void
prep_string(
    REG WCHAR c
    )
{
    REG WCHAR *p_buf;
    int term_char;

    p_buf = Reuse_W;

    term_char = c;

    *p_buf++ = c;               /*  save the open quote  */

    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == (WCHAR)term_char) {
                    *p_buf++ = (WCHAR)term_char;/* save the terminating quote */
                    goto out_of_loop;
                }
                break;
            case LX_BACKSLASH:
                *p_buf++ = c;
                break;
            case LX_CR:
                continue;
            case LX_NL:
                UNGETCH();
                goto out_of_loop;
            case LX_EOS:
                if(c == L'\\') {
                    *p_buf++ = c;
                    c = get_non_eof();
                    break;
                }
                handle_eos();
                continue;
        }
        *p_buf++ = c;
        if(p_buf >= &Reuse_W[MED_BUFFER - 1]) {
            *p_buf = L'\0';
            myfwrite(Reuse_W, (size_t)(p_buf - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
            p_buf = Reuse_W;
        }
    }

out_of_loop:
    *p_buf = L'\0';
    myfwrite(Reuse_W, (size_t)(p_buf - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
}


/************************************************************************
**      char_const : gather up a character constant
**  we're called after finding the openning single quote.
************************************************************************/
token_t
char_const(
    void
    )
{
    REG WCHAR c;
    value_t value;
    token_t tok;

    tok = (token_t)(Jflag ? L_CUNSIGNED : L_CINTEGER);

first_switch:

    switch(CHARMAP(c = GETCH())) {
        case LX_BACKSLASH:
            break;
        case LX_SQUOTE:
            error(2137);    //"empty character constant"
            value.v_long = 0;
            UNGETCH();
            break;
        case LX_EOS:                /* ??? assumes i/o buffering > 1 char */
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
            value.v_long = escape(get_non_eof());
            if( tok == L_CUNSIGNED ) {              /* don't sign extend */
                value.v_long &= 0xff;
            }
            break;
        case LX_NL:
            /* newline in character constant */
            error(2001);
            UNGETCH();
            /*
                    **  FALLTHROUGH
                    */
        default:
            value.v_long = c;
            break;
    }

    if((c = get_non_eof()) != L'\'') {
        error(2015);           /* too many chars in constant */
        do {
            if(c == L'\n') {
                error(2016);            /* missing closing ' */
                break;
            }
        } while((c = get_non_eof()) != L'\'');
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**      str_const : gather up a string constant
************************************************************************/
void
str_const(
    VOID
    )
{
    REG WCHAR c;
    REG PWCHAR  p_buf;
    int not_warned_yet = TRUE;

    p_buf = yylval.yy_string.str_ptr = Macro_buffer;
    /*
        **      Is it possible that reading this string during a rescan will
        **      overwrite the expansion being rescanned?  No, because a macro
        **      expansion is limited to the top half of Macro_buffer.
        **      For Macro_depth > 0, this is like copying the string from
        **      somewhere in the top half of Macro_buffer to the bottom half
        **      of Macro_buffer.
        **      Note that the restriction on the size of an expanded macro is
        **      stricter than the limit on an L_STRING length.  An expanded
        **      macro is limited to around 1019 bytes, but an L_STRING is
        **      limited to 2043 bytes.
        */
    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                UNGETCH();
                error(2001);
                /*
                **  FALLTHROUGH
                */
            case LX_DQUOTE:
                *p_buf++ = L'\0';
                yylval.yy_string.str_len = (USHORT)(p_buf-yylval.yy_string.str_ptr);
                return;
                break;
            case LX_EOS:
                if(handle_eos() != BACKSLASH_EOS) {
                    continue;
                }
                if(InInclude) {
                    break;
                }
                else {
                    c = (WCHAR)escape(get_non_eof());  /* process escaped char */
                }
                break;
        }
        if(p_buf - Macro_buffer > LIMIT_STRING_LENGTH) {
            if( not_warned_yet ) {
                warning(4009);          /* string too big, truncating */
                not_warned_yet = FALSE;
            }
        } else {
            *p_buf++ = c;
        }
    }
}


/************************************************************************
**  do_newline : does work after a newline has been found.
************************************************************************/

void
do_newline(
    void
    )
{
    ++Linenumber;
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_BOM:  // ignore Byte Order Mark
                break;
            case LX_CR:
                break;
            case LX_POUND:
                preprocess();
                break;
            case LX_SLASH:
                if( ! skip_comment()) {
                    goto leave_do_newline;
                }
                break;
            case LX_NL:
                if ((lCPPTotalLinenumber++ & RC_PREPROCESS_UPDATE) == 0)
                    UpdateStatus(1, lCPPTotalLinenumber);
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if( Prep ) {                /*  preprocessing only */
                    myfwrite(L"\r", sizeof(WCHAR), 1, OUTPUTFILE);
                }
                /*
                **  FALLTHROUGH
                */
            case LX_WHITE:
                if( Prep ) {                /*  preprocessing only, output whitespace  */
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                } else {
                    do {
                        ;
                    } while(LXC_IS_WHITE(GETCH()));
                    UNGETCH();
                }
                break;
            case LX_EOS:
                if(PREVCH() == EOS_CHAR || PREVCH() == CONTROL_Z) {
                    if(io_eob()) {          /* leaves us pointing at a valid char */
                        return;
                    }
                    break;
                }
                if(checknl()) {
                    continue;
                }
                /* it's a backslash */
                /*
                **      FALLTHROUGH
                */
            default:                        /* first non-white is not a '#', leave */

leave_do_newline:

                UNGETCH();
                return;
        }
    }
}


/************************************************************************
 * GETNUM - Get a number from the input stream.
 *
 * ARGUMENTS
 *      radix - the radix of the number to be accumulated.  Can only be 8, 10,
 *                      or 16
 *      pval - a pointer to a VALUE union to be filled in with the value
 *
 * RETURNS - type of the token (L_CINTEGER or L_CFLOAT)
 *
 * SIDE EFFECTS -
 *      does push back on the input stream.
 *      writes into pval by reference
 *  uses buffer Reuse_W
 *
 * DESCRIPTION -
 *      Accumulate the number according to the rules for each radix.
 *      Set up the format string according to the radix (or distinguish
 *      integer from float if radix is 10) and convert to binary.
 *
 * AUTHOR - Ralph Ryan, Sept. 8, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
token_t
getnum(
    REG WCHAR c
    )
{
    REG WCHAR   *p;
    WCHAR       *start;
    int         radix;
    token_t     tok;
    value_t     value;

    tok = L_CINTEGER;
    start = (Tiny_lexer_nesting ? Exp_ptr : Reuse_W);
    p = start;
    if( c == L'0' ) {
        c = get_non_eof();
        if( IS_X(c) ) {
            radix = 16;
            if( Prep ) {
                *p++ = L'0';
                *p++ = L'x';
            }
            for(c = get_non_eof(); LXC_IS_XDIGIT(c); c = get_non_eof()) {
                /* no check for overflow? */
                *p++ = c;
            }
            if((p == Reuse_W) && (Tiny_lexer_nesting == 0)) {
                error(2153);
            }
            goto check_suffix;
        } else {
            radix = 8;
            *p++ = L'0'; /* for preprocessing or 0.xxx case */
        }
    } else {
        radix = 10;
    }

    while( LXC_IS_DIGIT((WCHAR)c) ) {
        *p++ = c;
        c = get_non_eof();
    }

    if( IS_DOT(c) || IS_E(c) ) {
        UNGETCH();
        return(get_real(p));
    }

check_suffix:
    if( IS_EL(c) ) {
        if( Prep ) {
            *p++ = c;
        }
        c = get_non_eof();
        if( IS_U(c) ) {
            if(Prep) {
                *p++ = c;
            }
            tok = L_LONGUNSIGNED;
        } else {
            tok = L_LONGINT;
            UNGETCH();
        }
    } else if( IS_U(c) ) {
        if( Prep ) {
            *p++ = c;
        }
        c = get_non_eof();
        if( IS_EL(c) ) {
            if( Prep ) {
                *p++ = c;
            }
            tok = L_LONGUNSIGNED;
        } else {
            tok = L_CUNSIGNED;
            UNGETCH();
        }
    } else {
        UNGETCH();
    }
    *p = L'\0';
    if( start == Exp_ptr ) {
        Exp_ptr = p;
        return(L_NOTOKEN);
    } else if( Prep ) {
        myfwrite( Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        return(L_NOTOKEN);
    }
    value.v_long = matol(Reuse_W,radix);
    switch(tok) {
        case L_CINTEGER:
            tok = (radix == 10)
                ? c_size(value.v_long)
                : uc_size(value.v_long)
                ;
            break;
        case L_LONGINT:
            tok = l_size(value.v_long);
            break;
        case L_CUNSIGNED:
            tok = ul_size(value.v_long);
            break;
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**  get_real : gathers the real part/exponent of a real number.
**              Input  : ptr to the null terminator of the whole part
**                               pointer to receive value.
**              Output : L_CFLOAT
**
**  ASSUMES whole part is either at Exp_ptr or Reuse_W.
************************************************************************/
token_t
get_real(
    REG PWCHAR p
    )
{
    REG int c;
    token_t tok;

    c = get_non_eof();
    if(Cross_compile && (Tiny_lexer_nesting == 0)) {
        warning(4012);  /* float constant in cross compilation */
        Cross_compile = FALSE;  /*  only one msg per file */
    }
    /*
    **  if the next char is a digit, then we've been called after
    **  finding a '.'. if this is true, then
    **  we want to find the fractional part of the number.
    **  if it's a '.', then we've been called after finding
    **  a whole part, and we want the fraction.
    */
    if( LXC_IS_DIGIT((WCHAR)c) || IS_DOT(c) ) {
        do {
            *p++ = (WCHAR)c;
            c = (int)get_non_eof();
        } while( LXC_IS_DIGIT((WCHAR)c) );
    }
    if( IS_E((WCHAR)c) ) {              /*  now have found the exponent  */
        *p++ = (WCHAR)c;                /*  save the 'e'  */
        c = (WCHAR)get_non_eof();       /*  skip it  */
        if( IS_SIGN(c) ) {              /*  optional sign  */
            *p++ = (WCHAR)c;            /*  save the sign  */
            c = (int)get_non_eof();
        }
        if( ! LXC_IS_DIGIT((WCHAR)c)) {
            if( ! Rflag ) {
                if(Tiny_lexer_nesting == 0) {
                    error(2021, c); /* missing or malformed exponent */
                }
                *p++ = L'0';
            }
        } else {
            do {                        /* gather the exponent */
                *p++ = (WCHAR)c;
                c = (int)get_non_eof();
            } while( LXC_IS_DIGIT((WCHAR)c) );
        }
    }
    if( IS_F((WCHAR)c) ) {
        tok = L_CFLOAT;
        if( Prep ) {
            *p++ = (WCHAR)c;
        }
    } else if( IS_EL((WCHAR)c) ) {
        tok = L_CLDOUBLE;
        if( Prep ) {
            *p++ = (WCHAR)c;
        }
    } else {
        UNGETCH();
        tok = L_CDOUBLE;
    }
    *p = L'\0';
    if( Tiny_lexer_nesting > 0 ) {
        Exp_ptr = p;
        return(L_NOTOKEN);
    }
    else if( Prep ) {
        myfwrite( Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        return(L_NOTOKEN);
    }
    /*
        ** reals aren't used during preprocessing
        */
    return(tok);
}


/************************************************************************
**  matol : ascii to long, given a radix.
************************************************************************/
long
matol(
    REG PWCHAR p_start,
    REG int radix
    )
{
    long        result, old_result;
    unsigned    int     i;

    old_result = result = 0;
    while(*p_start) {
        result *= radix;
        i = ctoi(*p_start);
        if( ((int)i >= radix) && (! Prep) ) {
            error(2020, *p_start, radix); /* illegal digit % for base % */
        }
        result += i;
        p_start++;
        if(radix == 10) {
            if(result < old_result) {
                p_start--;   /*  fix the string ptr since we have overflowed  */
                break;
            }
        } else if(*p_start) {
            /*
                **  the loop is not finished.
                **  we will multiply by the radix again
                **  check the upper bits. if they're on, then
                **  that mult will overflow the value
                */
            if(radix == 8) {
                if(result & 0xe0000000) {
                    break;
                }
            } else if(result & 0xf0000000) {
                break;
            }
        }
        old_result = result;
    }
    if(*p_start) {
        error(2177);            /* constant too big */
        result = 0;
    }
    return(result);
}


/************************************************************************
**  uc_size : returns 'int' or 'long' (virtual unsigned).
**  if their are no bits in the upper part of the value,
**  then it's an int. otherwise, it's a long.
**  this is valid too if target sizeof(int) != sizeof(long).
**  then L_CINTEGER and L_LONGINT are synonymous.
************************************************************************/
token_t
uc_size(
    long value
    )
{
    return((token_t)((value > INT_MAX) ? L_CUNSIGNED : L_CINTEGER));
}


/************************************************************************
**  c_size : returns 'int' or 'long' for signed numbers.
**  if the sign bit of the lower word is on or any bits
**  in the upper word are on, then we must use 'long'.
************************************************************************/
token_t
c_size(
    long value
    )
{
    return((token_t)((ABS(value) > INT_MAX) ? L_LONGINT : L_CINTEGER));
}


/************************************************************************
**  l_size : returns 'longint' or 'longunsigned' for long numbers.
**  if the sign bit of the high word is on this is 'longunsigned';
************************************************************************/
token_t
l_size(
    long value
    )
{
    return((token_t)((value > LONG_MAX) ? L_LONGUNSIGNED : L_LONGINT));
}


/************************************************************************
**      ul_size : returns 'unsigned' or 'longunsigned' for unsigned numbers.
**      if the number can't be represented as unsigned, it is promoted to
**      unsignedlong.
************************************************************************/
token_t
ul_size(
    long value
    )
{
    return((token_t)((ABS(value) > UINT_MAX-1) ? L_LONGUNSIGNED : L_CUNSIGNED));
}


/************************************************************************
**  ctoi : character to int.
************************************************************************/
int
ctoi(
    int c
    )
{
    if(LXC_IS_DIGIT((WCHAR)c)) {
        return(c - L'0');
    } else {
        return(towupper((WCHAR)c) - towupper(L'A') + 10);
    }
}


/************************************************************************
 * ESCAPE - get an escaped character
 *
 * ARGUMENTS - none
 *
 * RETURNS - value of escaped character
 *
 * SIDE EFFECTS - may push back input
 *
 * DESCRIPTION - An escape ( '\' ) was discovered in the input.  Translate
 *       the next symbol or symbols into an escape sequence.
 *
 * AUTHOR - Ralph Ryan, Sept. 7, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
escape(
    REG int c
    )
{
    REG int value;
    int cnt;

escape_again:

    if( LXC_IS_ODIGIT((WCHAR)c) ) {/* \ooo is an octal number, must fit into a byte */
        cnt = 1;
        for(value = ctoi(c), c = get_non_eof();
            (cnt < 3) && LXC_IS_ODIGIT((WCHAR)c);
            cnt++, c = get_non_eof()
            ) {
            value *= 8;
            value += ctoi(c);
        }
        if( ! Prep ) {
            if(value > 255) {
                error(2022, value);
            }
        }
        UNGETCH();
        return((char)value);
    }
    switch( c ) {
        case L'a':
            return(ALERT_CHAR);
            break;
        case L'b':
            return(L'\b');
            break;
        case L'f':
            return(L'\f');
            break;
        case L'n':
            return fMacRsrcs ? (L'\r') : (L'\n');
            break;
        case L'r':
            return fMacRsrcs ? (L'\n') : (L'\r');
            break;
        case L't':
            return(L'\t');
            break;
        case L'v':
            return(L'\v');
            break;
        case L'x':
            cnt = 0;
            value = 0;
            c = get_non_eof();
            while((cnt < 3) && LXC_IS_XDIGIT((WCHAR)c)) {
                value *= 16;
                value += ctoi(c);
                c = get_non_eof();
                cnt++;
            }
            if(cnt == 0) {
                error(2153);
            }
            UNGETCH();
            return((char)value);    /* cast to get sign extend */
        default:
            if(c != L'\\') {
                return(c);
            } else {
                if(checknl()) {
                    c = get_non_eof();
                    goto escape_again;
                } else {
                    return(c);
                }
            }
    }
}


/************************************************************************
 * CHECKOP - Check whether the next input character matches the argument.
 *
 * ARGUMENTS
 *      short op - the character to be checked against
 *
 * RETURNS
 *      TRUE or FALSE
 *
 * SIDE EFFECTS
 *      Will push character back onto the input if there is no match.
 *
 * DESCRIPTION
 *      If the next input character matches op, return TRUE.  Otherwise
 *      push it back onto the input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
checkop(
    int op
    )
{
    if(op == (int)get_non_eof()) {
        return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}


/************************************************************************
**  DumpSlashComment : while skipping a comment, output it.
************************************************************************/
void
DumpSlashComment(
    VOID
    )
{
    if( ! Cflag ) {
        skip_NLonly();
        return;
    }
    myfwrite(L"//", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
    for(;;) {
        WCHAR c;

        switch(CHARMAP(c = GETCH())) {
            // must manually write '\r' with '\n' when writing 16-bit strings
            //case LX_CR:
            //    continue;
            case LX_EOS:
                handle_eos();
                continue;
            case LX_NL:
                UNGETCH();
                return;
        }
        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
    }
}


/************************************************************************
**  dump_comment : while skipping a comment, output it.
************************************************************************/
void
dump_comment(
    void
    )
{
    if( ! Cflag ) {
        skip_1comment();
        return;
    }
    myfwrite(L"/*", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
    for(;;) {
        WCHAR c;

        switch(CHARMAP(c = GETCH())) {
            case LX_STAR:
                if(checkop(L'/')) {
                    myfwrite(L"*/", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                    return;
                }
                break;
            case LX_EOS:
                handle_eos();
                continue;
            case LX_NL:
                Linenumber++;
                break;      /* output below */
            // must manually write '\r' with '\n' when writing 16-bit strings
            //case LX_CR:
            //    continue;
        }
        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
    }
}

/************************************************************************/
/* skip_comment()                                                       */
/************************************************************************/
int
skip_comment(
    void
    )
{
    if(checkop(L'*')) {
        skip_1comment();
        return(TRUE);
    } else if(checkop(L'/')) {
        skip_NLonly();
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/************************************************************************
**  skip_1comment : we're called when we're already in a comment.
**  we're looking for the comment close. we also count newlines
**  and output them if we're preprocessing.
************************************************************************/
void
skip_1comment(
    void
    )
{
    UINT c;

    for(;;) {
        c = GETCH();
        if(c == L'*') {
recheck:
            c = GETCH();
            if(c == L'/') {      /* end of comment */
                return;
            } else if(c == L'*') {
                /*
                **  if we get another '*' go back and check for a slash
                */
                goto recheck;
            } else if(c == EOS_CHAR) {
                handle_eos();
                goto recheck;
            }
        }
        /*
        **  note we fall through here. we know this baby is not a '*'
        **  we used to unget the char and continue. since we check for
        **  another '*' inside the above test, we can fall through here
        **  without ungetting/getting and checking again.
        */
        if(c <= L'\n') {
            /*
            **  hopefully, the above test is less expensive than doing two tests
            */
            if(c == L'\n') {
                Linenumber++;
                if(Prep) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
            } else if(c == EOS_CHAR) {
                handle_eos();
            }
        }
    }
}


/************************************************************************
**  skip_cwhite : while the current character is whitespace or a comment.
**  a newline is NOT whitespace.
************************************************************************/
WCHAR
skip_cwhite(
    void
    )
{
    REG WCHAR           c;

skip_cwhite_again:
    while((c = GETCH()) <= L'/') {      /* many chars are above this */
        if(c == L'/') {
            if( ! skip_comment()) {
                return(L'/');
            }
        } else if(c > L' ') {           /* char is between '!' and '.' */
            return(c);
        } else {
            switch(CHARMAP(c)) {
                case LX_EOS:
                    handle_eos();
                    break;
                case LX_WHITE:
                    continue;
                    break;
                case LX_CR:
                    continue;
                    break;
                default:
                    return(c);
                    break;
            }
        }
    }
    if((c == L'\\') && (checknl())) {
        goto skip_cwhite_again;
    }
    return(c);
}


/************************************************************************
**  checknl : check for newline, skipping carriage return if there is one.
**  also increments Linenumber, so this should be used by routines which
**  will not push the newline back in such a way that rawtok() will be invoked,
**  find the newline and do another increment.
************************************************************************/
int
checknl(
    void
    )
{
    REG WCHAR  c;

    for(;;) {
        c = GETCH();
        if(c > L'\r') {
            UNGETCH();
            return(FALSE);
        }
        switch(c) {
            case L'\n':
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if( Prep ) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                return(TRUE);
                break;
            case L'\r':
                continue;
                break;
            case EOS_CHAR:
                handle_eos();
                PREVCH() = L'\\';    /* M00HACK - needs pushback */
                continue;
                break;
            default:
                UNGETCH();
                return(FALSE);
                break;
        }
    }
}


/************************************************************************
**  get_non_eof : get a real char.
************************************************************************/
WCHAR
get_non_eof(
    void
    )
{
    WCHAR    c;

get_non_eof_again:
    while((c = GETCH()) <= L'\r') {
        if(c == L'\r') {
            continue;
        } else if(c != EOS_CHAR) {
            break;
        }
        if(Tiny_lexer_nesting > 0) {
            break;
        }
        handle_eos();
    }
    if((c == L'\\') && (checknl())) {
        goto get_non_eof_again;
    }
    return(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rcdll\symbols.h ===
/*
**  Symbol types . . .
*/
#define SYMV_SYMBOL             0x0001
#define SYMV_RAWSYMBOL          0x0002
#define SYMV_FORMAL             0x0004
#define SYMV_SEGMENT            0x0008

#define SYMV_FUNCTION           0x0010
#define SYMV_INTRINSIC          0x0020
#define SYMV_LABEL              0x0040

#define SYMV_TAG                0x0080
#define SYMV_MOE                0x0100
#define SYMV_MEMBER             0x0200
#define SYMV_FIELD              0x0400
#define SYMV_OPC                0x0800

#define SYMV_ABSTRSYM           0x1000

#define SYM_ISSYMBOL(p)         (SYM_ANYVTAG(p) & SYMV_SYMBOL)
#define SYM_ISFUNCTION(p)       (SYM_ANYVTAG(p) & SYMV_FUNCTION)
#define SYM_ISFORMAL(p)         (SYM_ANYVTAG(p) & SYMV_FORMAL)
#define SYM_ISABSTRSYM(p)       (SYM_ANYVTAG(p) & SYMV_ABSTRSYM)
#define SYM_ISLABEL(p)          (SYM_ANYVTAG(p) & SYMV_LABEL)
#define SYM_ISTAG(p)            (SYM_ANYVTAG(p) & SYMV_TAG)
#define SYM_ISMOE(p)            (SYM_ANYVTAG(p) & SYMV_MOE)
#define SYM_ISMEMBER(p)         (SYM_ANYVTAG(p) & SYMV_MEMBER)
#define SYM_ISFIELD(p)          (SYM_ANYVTAG(p) & SYMV_FIELD)
#define SYM_ISINTRINSIC(p)      (SYM_ANYVTAG(p) & SYMV_INTRINSIC)
#define SYM_ISRAWSYMBOL(p)      (SYM_ANYVTAG(p) & SYMV_RAWSYMBOL)
#define SYM_ISSEGMENT(p)        (SYM_ANYVTAG(p) & SYMV_SEGMENT)
/*
**  parameter list types
*/
#define NO_LIST         0
#define EMPTY_LIST      1
#define NAME_LIST       2
#define PASCAL_LIST     3
#define TYPE_LIST       4
/*
**  symbol storage classes
**  symbol adjectives, these have nothing to do with types.
*/
#define SCundef         0
#define SCauto          0x01
#define SCextern        0x02
#define SCregister      0x04
#define SCstatic        0x08
#define SCtypedef       0x10
#define SCglobal        0x20
#define SCabsolute      0x40
#define SCreally        0x80    /* used w/ SCregister by p2 if it allocs a reg */

#define SCp2stuff       SCreally

/*
**  symbol table sizes
*/
#define LEVEL_0         0xff
#define LEVEL_N         0x0f

struct  s_adj   {
        uchar_t bit_0:1;
        uchar_t bit_1:1;
        uchar_t bit_2:1;
        uchar_t bit_3:1;

        uchar_t bit_4:1;
        uchar_t bit_5:1;
        uchar_t bit_6:1;
        uchar_t bit_7:1;

        uchar_t bit_8:1;
        uchar_t bit_9:1;
        uchar_t bit_10:1;
        uchar_t bit_11:1;

        uchar_t bit_12:1;
        uchar_t bit_13:1;
        uchar_t bit_14:1;
        uchar_t bit_15:1;
        };

#if VERS_DEBUG
/*
 * d=DEFINED o=OUTPUT S=INASEGMENT n=NEAR
 * v=VISIBLE p=PASCAL i=INIT s=STRING
 * N=HASANAMELIST E=DEFNBEFOREUSE C=CODESEGNAME D=DATASEGNAME
 * B=ISBACKREF F=FORWARDREF
 */
#define SYM_ADJFMT                      "??FBDCENsipvnSod"      /* prword() fmt */
#endif

#define IS_INVISIBLE                    0
#define IS_VISIBLE                      1

#define SYM_ISDEFINED(s)                ((SYM_ANYADJ(s)).bit_0) /* all */
#define SYM_ISOUTPUT(s)                 ((SYM_ANYADJ(s)).bit_1) /* all */
#define SYM_ISINASEGMENT(s)             ((SYM_ANYADJ(s)).bit_2) /* all */
#define SYM_ISNEAR(s)                   ((SYM_ANYADJ(s)).bit_3) /* all */
#define SYM_ISVISIBLE(s)                ((SYM_ANYADJ(s)).bit_4) /* all */
#define SYM_ISPASCAL(s)                 ((SYM_ANYADJ(s)).bit_5) /* all */

#define SYM_ISINITIALIZED(s)            ((SYM_ANYADJ(s)).bit_6) /* symbol */
#define SYM_ISSTRING(s)                 ((SYM_ANYADJ(s)).bit_7) /* symbol */

#define SYM_HASANAMELIST(s)             ((SYM_ANYADJ(s)).bit_8) /* funcs */
#define SYM_DEFNBEFOREUSE(s)            ((SYM_ANYADJ(s)).bit_9) /* overload for QC */

#define SYM_ISCODESEGNAME(s)            ((SYM_ANYADJ(s)).bit_10)/* segment */
#define SYM_ISDATASEGNAME(s)            ((SYM_ANYADJ(s)).bit_11)/* segment */

#define SYM_ISBACKREF(s)                ((SYM_ANYADJ(s)).bit_12)/* label */
#define SYM_ISFORWARDREF(s)             ((SYM_ANYADJ(s)).bit_13)/* label */
#define SYM_ISMASM(s)                   ((SYM_ANYADJ(s)).bit_14)/* label */
#define SYM_TOLEVEL0(s)                 ((SYM_ANYADJ(s)).bit_15)/* funcs moved to 0 */

typedef struct  sym_200 {                       /* for fields */
        uchar_t         field_bitstart;         /* in which bit does the field start */
        uchar_t         field_nbits;            /* number of bits in this field */
        } sym_200_t;

typedef struct  sym_190 {                       /* struct/union members/fields */
        fpsym_t         member_prev;            /* previous member */
        ushort_t        member_offset;          /* offset of this member in the struct */
        sym_200_t       m200;
        } sym_190_t;

#define SOB_sym_190     (sizeof(sym_190_t) - sizeof(sym_200_t))

typedef struct  sym_180 {                       /* struct/union/enum tags */
        len_t           tag_size;                       /* sizeof the struct/union */
        ushort_t        tag_align;                      /* alignment of this struct */
        } sym_180_t;

typedef struct  sym_170 {                       /* intrinsics */
        ushort_t        intrin_ino;                     /* intrinsic number */
        ushort_t        intrin_nparms;          /* number of actuals it takes */
        } sym_170_t;

typedef struct  sym_160 {                       /* labels */
        NA_TYPE         label_template;         /* label template */
        } sym_160_t;

typedef struct  sym_150 {                       /* formals */
        fpsym_t         formal_prev;            /* ptr to previous formal */
        } sym_150_t;

typedef struct  sym_140 {                       /* raw symbols */
        hash_t          raw_hash;                       /* the hash of this symbol */
        } sym_140_t;

typedef union   sym_135 {
        sym_140_t       m140;                           /* raw symbols */
        sym_150_t       m150;                           /* formals */
        sym_160_t       m160;                           /* labels */
        } sym_135_t;

typedef struct  sym_130 {
/*
        SYMV_SYMBOL
        SYMV_RAWSYMBOL
        SYMV_FORMAL
        SYMV_SEGMENT
        SYMV_FUNCTION
        SYMV_LABEL
*/
        fpsym_t         sym_anysegment;         /* ptr to segment this is alloc'd in */
        sym_135_t       m135;
        } sym_130_t;

#define SOB_sym_130     (sizeof(sym_130_t) - sizeof(sym_135_t))

typedef union   sym_125 {
        sym_130_t       m130;
        sym_170_t       m170;
        } sym_125_t;

typedef struct  sym_120 {
/*
        case SYMV_SYMBOL:
        case SYMV_RAWSYMBOL:
        case SYMV_FORMAL:
        case SYMV_SEGMENT:
        case SYMV_FUNCTION:
        case SYMV_INTRINSIC:
        case SYMV_LABEL:
*/
        refcnt_t        sym_anyrefcnt;  /* reference count  */
        class_t         sym_anyclass;   /* symbol's class */
        symadj_t        sym_anyadj;             /* adjectives  */
        sym_125_t       m125;
        } sym_120_t;

#define SOB_sym_120     (sizeof(sym_120_t) - sizeof(sym_125_t))

typedef union   sym_115 {
        sym_120_t       m120;
        sym_180_t       m180;
        } sym_115_t;

typedef struct  sym_110 {
/*
        case SYMV_SYMBOL:
        case SYMV_RAWSYMBOL:
        case SYMV_FORMAL:
        case SYMV_SEGMENT:
        case SYMV_FUNCTION:
        case SYMV_INTRINSIC:
        case SYMV_LABEL:
        case SYMV_TAG:
*/
        p1key_t         sym_anykey;
        sym_115_t       m115;
        } sym_110_t;

#define SOB_sym_110     (sizeof(sym_110_t) - sizeof(sym_115_t))

typedef union   sym_105 {
        sym_110_t       m110;
        sym_190_t       m190;
        } sym_105_t;

typedef struct  sym_100 {
        ptype_t         sym_anytype;
        sym_105_t       m105;
        } sym_100_t;

#define SOB_sym_100     (sizeof(sym_100_t) - sizeof(sym_105_t))

typedef union   sym_95  {
        long            moe_value;
        sym_100_t       m100;
        } sym_95_t;

struct  s_sym   {
        fpsym_t         sym_anynext;            /*  pointer to next ident  */
        fpuchar_t       sym_anyname;            /*  pointer to name */
        ushort_t        sym_anyvtag;            /*  which variant do we have? */
        sym_95_t                m95;
        };

#define M95(p)  ((p)->m95)
#define M100(p) ((p)->m95.m100)
#define M105(p) ((p)->m95.m100.m105)
#define M110(p) ((p)->m95.m100.m105.m110)
#define M115(p) ((p)->m95.m100.m105.m110.m115)
#define M120(p) ((p)->m95.m100.m105.m110.m115.m120)
#define M125(p) ((p)->m95.m100.m105.m110.m115.m120.m125)
#define M130(p) ((p)->m95.m100.m105.m110.m115.m120.m125.m130)
#define M135(p) (M130(p).m135)
#define M140(p) (M135(p).m140)
#define M150(p) (M135(p).m150)
#define M160(p) (M135(p).m160)
#define M170(p) ((p)->m95.m100.m105.m110.m115.m120.m125.m170)
#define M180(p) ((p)->m95.m100.m105.m110.m115.m180)
#define M190(p) ((p)->m95.m100.m105.m190)
#define M200(p) (M190(p).m200)

#define SO_BASICSYM     (sizeof(sym_t) - sizeof(sym_95_t))

#define SO_SYMBOL               (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + SOB_sym_120\
                                             + SOB_sym_130\
                                             )
#define SO_SEGMENT              (SO_SYMBOL)
#define SO_FUNCTION             (SO_SYMBOL)
#define SO_RAWSYMBOL            (SO_SYMBOL \
                                           + sizeof(sym_140_t)\
                                           )
#define SO_FORMAL               (SO_SYMBOL \
                                           + sizeof(sym_150_t)\
                                           )
#define SO_LABEL                (SO_SYMBOL \
                                           + sizeof(sym_160_t)\
                                           )
#define SO_INTRINSIC            (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + SOB_sym_120\
                                             + sizeof(sym_170_t)\
                                             )
#define SO_TAG                  (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + sizeof(sym_180_t)\
                                             )

#define SO_MEMBER               (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_190\
                                             )
#define SO_FIELD                (SO_MEMBER \
                                           + sizeof(sym_200_t)\
                                           )
#define SO_MOE                  (SO_BASICSYM + sizeof(long))    /* sizeof(moe_value) */

#if 0   /* this is just a big comment */

*all* use s_sym and the following parts.

SYMV_SYMBOL(and SYMV_SEGMENT, SYMV_FUNCTION)
                                uses : sym_100, sym_110, sym_120, sym_130

SYMV_RAWSYMBOL  uses : SYMV_SYMBOL *and* sym_140
SYMV_FORMAL             uses : SYMV_SYMBOL *and* sym_150
SYMV_LABEL              uses : SYMV_SYMBOL *and* sym_160

SYMV_INTRINSIC  uses : sym_100, sym_110, sym_120, sym_170

SYMV_TAG                uses : sym_100, sym_110, sym_180

SYMV_MEMBER             uses : sym_100, sym_190

SYMV_FIELD              uses : SYMV_MEMBER *and* sym_200

SYMV_MOE                uses : moe_value

SYMV_OPC

#endif

#define SYM_ANYNEXT(p)          ((p)->sym_anynext)
#define SYM_ANYNAME(p)          ((p)->sym_anyname)
#define SYM_ANYVTAG(p)          ((p)->sym_anyvtag)

#define SYM_ANYTYPE(p)          ((p)->m95.m100.sym_anytype)
#define SYM_ANYKEY(p)           ((p)->m95.m100.m105.m110.sym_anykey)
#define SYM_ANYREFCNT(p)        ((p)->m95.m100.m105.m110.m115.m120.sym_anyrefcnt)
#define SYM_ANYCLASS(p)         ((p)->m95.m100.m105.m110.m115.m120.sym_anyclass)
#define SYM_ANYADJ(p)           ((p)->m95.m100.m105.m110.m115.m120.sym_anyadj)
#define SYM_ANYSEGMENT(p)       (M130(p).sym_anysegment)
#define SYM_ANYAOFF(p)          (M130(p).sym_anyaoff)   /* P-2 allocation offset */
#define SYM_ANYAREGS(p)         (M130(p).sym_anyaregs)  /* P-2 allocation regs */
#define SYM_ANYASEG(p)          (M130(p).sym_anyaseg)   /* P-2 allocation segment */

#define SYM_SYNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_SYNAME(p)           (SYM_ANYNAME(p))
#define SYM_SYTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_SYKEY(p)            (SYM_ANYKEY(p))
#define SYM_SYREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_SYCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_SYADJ(p)            (SYM_ANYADJ(p))
#define SYM_SYSEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_SYAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_SYASEG(p)           (SYM_ANYASEG(p))

#define SYM_SENEXT(p)           (SYM_ANYNEXT(p))
#define SYM_SENAME(p)           (SYM_ANYNAME(p))
#define SYM_SETYPE(p)           (SYM_ANYTYPE(p))
#define SYM_SEKEY(p)            (SYM_ANYKEY(p))
#define SYM_SEREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_SECLASS(p)          (SYM_ANYCLASS(p))
#define SYM_SEADJ(p)            (SYM_ANYADJ(p))
#define SYM_SEAOFF(p)           (SYM_ANYAOFF(p))

#define SYM_RANAME(p)           (SYM_ANYNAME(p))
#define SYM_RATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_RASEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_RAHASH(p)           (M140(p).raw_hash)

#define SYM_FUNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FUNAME(p)           (SYM_ANYNAME(p))
#define SYM_FUTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FUKEY(p)            (SYM_ANYKEY(p))
#define SYM_FUREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_FUCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_FUADJ(p)            (SYM_ANYADJ(p))
#define SYM_FUSEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_FUAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_FUASEG(p)           (SYM_ANYASEG(p))

#define SYM_FONEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FONAME(p)           (SYM_ANYNAME(p))
#define SYM_FOTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FOKEY(p)            (SYM_ANYKEY(p))
#define SYM_FOREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_FOCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_FOADJ(p)            (SYM_ANYADJ(p))
#define SYM_FOAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_FOPREV(p)           (M150(p).formal_prev)

#define SYM_LANEXT(p)           (SYM_ANYNEXT(p))
#define SYM_LANAME(p)           (SYM_ANYNAME(p))
#define SYM_LATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_LAKEY(p)            (SYM_ANYKEY(p))
#define SYM_LAREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_LACLASS(p)          (SYM_ANYCLASS(p))
#define SYM_LAADJ(p)            (SYM_ANYADJ(p))
#define SYM_LAAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_LAASEG(p)           (SYM_ANYASEG(p))
#define SYM_LATEMPLATE(p)       (M160(p).label_template)

#define SYM_INNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_INNAME(p)           (SYM_ANYNAME(p))
#define SYM_INTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_INKEY(p)            (SYM_ANYKEY(p))
#define SYM_INREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_INCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_INADJ(p)            (SYM_ANYADJ(p))
#define SYM_INNUMBER(p)         (M170(p).intrin_ino)
#define SYM_INNPARMS(p)         (M170(p).intrin_nparms)

#define SYM_TANEXT(p)           (SYM_ANYNEXT(p))
#define SYM_TANAME(p)           (SYM_ANYNAME(p))
#define SYM_TATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_TAKEY(p)            (SYM_ANYKEY(p))
#define SYM_TASIZE(p)           (M180(p).tag_size)
#define SYM_TAALIGN(p)          (M180(p).tag_align)

#define SYM_MENEXT(p)           (SYM_ANYNEXT(p))
#define SYM_MENAME(p)           (SYM_ANYNAME(p))
#define SYM_METYPE(p)           (SYM_ANYTYPE(p))
#define SYM_MEPREV(p)           (M190(p).member_prev)
#define SYM_MEOFFSET(p)         (M190(p).member_offset)
#define SYM_MEVACCESS(p)        (M190(p).member_vaccess)

#define SYM_FINEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FINAME(p)           (SYM_ANYNAME(p))
#define SYM_FITYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FIPREV(p)           (M190(p).member_prev)
#define SYM_FIOFFSET(p)         (M190(p).member_offset)
#define SYM_FIVACCESS(p)        (M190(p).member_vaccess)
#define SYM_FIBITSTART(p)       (M200(p).field_bitstart)
#define SYM_FINBITS(p)          (M200(p).field_nbits)

#define SYM_MONEXT(p)           (SYM_ANYNEXT(p))
#define SYM_MONAME(p)           (SYM_ANYNAME(p))
#define SYM_MOVALUE(p)          ((p)->m95.moe_value)

/*
**      macros for acessing informmation on symbols type
*/
#define SYM_ANYBTYPE(P)         (TY_BTYPE(SYM_ANYTYPE(P)))
#define SYM_ANYESU(P)           (TY_ESU(SYM_ANYTYPE(P)))
#define SYM_ANYTINDEX(P)        (TY_TINDEX(SYM_ANYTYPE(P)))
#define SYM_ANYINDIR(P)         (TY_INDIR(SYM_SYTYPE(P)))

#define SYM_ANYISUB(P)          (INDIR_ISUB(SYM_ANYINDIR(P)))
#define SYM_ANYINEXT(P)         (INDIR_INEXT(SYM_ANYINDIR(P)))
#define SYM_ANYITYPE(P)         (INDIR_ITYPE(SYM_ANYINDIR(P)))
#define SYM_ANYIFORMALS(P)      (INDIR_IFORMALS(SYM_ANYINDIR(P)))

#define SYM_NEAR(P)             (IS_NEAR(SYM_ANYBTYPE(P)))
#define SYM_FAR(P)              (IS_FAR(SYM_ANYBTYPE(P)))
#define SYM_HUGE(P)             (IS_HUGE(SYM_ANYBTYPE(P)))
#define SYM_CONST(P)            (IS_CONST(SYM_ANYBTYPE(P)))
/*
**  the symbol table
*/
struct  s_table {
        table_t         *st_next;       /*  link to next  */
        table_t         *st_incl;       /*  block is included in block pointer  */
        fpsym_t         *st_table;      /*  ptr to hash table  */
        blknum_t        st_level;       /*  block level  */
        uchar_t         st_size;        /*  number of entries in hash table  */
        };
/*
**  macros for accessing the symbol tables.
**      `level' is the level of interest.
**      `ptab' is a ptr to a symbol table
*/
#define ST_NEXT(ptab)                   ((ptab)->st_next)
#define ST_INCL(ptab)                   ((ptab)->st_incl)
#define ST_SYM(ptab)                    ((ptab)->st_table)
#define ST_LEVEL(ptab)                  ((ptab)->st_level)
#define ST_MOD(ptab)                    ((ptab)->st_size)

#define ST_TABLE(level)                 ((level) ? Table_n : Table_0)
#define ST_BUCKET(ptab,hash)            (((ptab)->st_table[hash & ST_MOD(ptab)]))

/*
**      A Hash/Length/Name string is one where the first character is the hash
**      of the name.  The second character is the length of the identifier
**      including the hash and length characters.  The name begins at the third
**      character.
*/
#define HLN_IDENT_HASH(P)               (HLN_HASH(*(P)))
#define HLN_IDENT_LENGTH(P)             (HLN_LENGTH(*(P)))
#define HLN_IDENTP_NAME(P)              (HLN_NAME(*(P)))
/*
**  delcaration specifiers, used by to hold both the class and the type.
*/
struct  s_declspec      {
        class_t ds_class;
        ptype_t ds_type;
        };

#define DSP_CLASS(p)            ((p)->ds_class)
#define DSP_TYPE(p)             ((p)->ds_type)
#define DS_CLASS(p)             ((p).ds_class)
#define DS_TYPE(p)              ((p).ds_type)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\main.c ===
#include "precomp.h"
#pragma hdrstop

int
__cdecl
wmain (
    int argc,
    WCHAR *argv[]
    )
{
    return DoFullRegBackup( argv[1] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\precomp.h ===
#define SECURITY_WIN32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winldap.h>
#include <dsgetdc.h>
#include <sspi.h>
#include <secext.h>

#include <ntdddisk.h>

#include <aclapi.h>
#include <remboot.h>

#include "copy.h"
#include "regtool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\regcopy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regcopy.c

Abstract:

    This is for supporting copying and munging the registry files.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

typedef BOOL (*PFNGETPROFILESDIRECTORYW)(LPWSTR lpProfile, LPDWORD dwSize);

HKEY HiveRoot;
REG_CONTEXT RegistryContext;

PWSTR MachineName;
PWSTR HiveFileName;
PWSTR HiveRootName;



DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    )

/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    None.

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    PWSTR w;
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR ConfigPath[ MAX_PATH ];
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    WCHAR DirectoryPath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
    HANDLE hInstDll;
    PFNGETPROFILESDIRECTORYW pfnGetProfilesDirectory;
    NTSTATUS Status;
    BOOLEAN savedBackup;

    //
    // First try and give ourselves enough priviledge
    //
    if (!RTEnableBackupRestorePrivilege()) {
        return(GetLastError());
    }

    //
    // Now attach to the registry
    //
    Error = RTConnectToRegistry(MachineName,
                                HiveFileName,
                                HiveRootName,
                                NULL,
                                &RegistryContext
                               );

    if (Error != NO_ERROR) {
        RTDisableBackupRestorePrivilege();
        return Error;
    }

    //
    // Get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey(&RegistryContext,
                      NULL,
                      KeyName,
                      MAXIMUM_ALLOWED,
                      0,
                      &HiveListKey
                     );

    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }

    //
    // get path data for system hive, which will allow us to compute
    // path name to config dir in form that hivelist uses.
    // (an NT internal form of path)  this is NOT the way the path to
    // the config directory should generally be computed.
    //

    ValueDataLength = sizeof(ConfigPath);
    Error = RTQueryValueKey(&RegistryContext,
                            HiveListKey,
                            L"\\Registry\\Machine\\System",
                            &ValueType,
                            &ValueDataLength,
                            ConfigPath
                           );
    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }
    w = wcsrchr(ConfigPath, L'\\');
    *w = UNICODE_NULL;


    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path then save it.
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {

        savedBackup = FALSE;
        ValueType = REG_NONE;
        ValueNameLength = ARRAYSIZE( HiveName );
        ValueDataLength = sizeof( HivePath );

        Error = RTEnumerateValueKey(&RegistryContext,
                                    HiveListKey,
                                    ValueIndex,
                                    &ValueType,
                                    &ValueNameLength,
                                    HiveName,
                                    &ValueDataLength,
                                    HivePath
                                   );
        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Error != NO_ERROR) {
            RTDisconnectFromRegistry(&RegistryContext);
            return Error;
        }
        //printf("HiveName='%ws', HivePath='%ws'\n", HiveName, HivePath);

        if ((ValueType == REG_SZ) && (ValueDataLength > sizeof(UNICODE_NULL))) {
            //
            // there's a file, compute it's path, hive branch, etc
            //

            if (w = wcsrchr( HivePath, L'\\' )) {
                *w++ = UNICODE_NULL;
            }
            FileName = w;

            if (w = wcsrchr( HiveName, L'\\' )) {
                *w++ = UNICODE_NULL;
            }
            Name = w;

            HiveRoot = NULL;
            if (w = wcsrchr( HiveName, L'\\' )) {
                w += 1;
                if (!_wcsicmp( w, L"MACHINE" )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                } else if (!_wcsicmp( w, L"USER" )) {
                    HiveRoot = HKEY_USERS;
                } else {
                    printf("Unexpected hive with hive name %ws skipped\n", HiveName);
                    continue;
                }

            }

            if (FileName != NULL && Name != NULL && HiveRoot != NULL) {

                //
                // Extract the path name from HivePath
                //
                if (_wcsicmp(HivePath, L"\\Device")) {

                    w = HivePath + 1;
                    w = wcsstr(w, L"\\");
                    w++;
                    w = wcsstr(w, L"\\");
                    w++;

                } else if (*(HivePath + 1) == L':') {

                    w = HivePath + 2;

                } else {

                    printf("Unexpected hive with file name %ws skipped\n", HivePath);
                    continue;
                }

                //
                // Do the save
                //

                swprintf( DirectoryPath, L"%ws\\%ws", MirrorRoot, w );
                swprintf( FilePath, L"%ws\\%ws\\%ws", MirrorRoot, w, FileName );

                printf("Now copying hive %ws\\%ws to %ws\n", HiveName, Name, FilePath);

#if 1
                Error = DoSpecificRegBackup(DirectoryPath,
                                            FilePath,
                                            HiveRoot,
                                            Name
                                           );
#else
                Error = NO_ERROR;
#endif

                if (Error != NO_ERROR) {

                    printf("Error %d copying hive\n", Error);
                    //return Error;
                }
            }
        }
    }

    RTDisconnectFromRegistry(&RegistryContext);
    return NO_ERROR;
}

DWORD
CreateHiveDirectory (
    PWSTR HiveDirectory
    )
{
    PWSTR p;

    p = wcschr( HiveDirectory, L'\\' );
    if ( (p == HiveDirectory) ||
         ((p != HiveDirectory) && (*(p-1) == L':')) ) {
        p = wcschr( p + 1, L'\\' );
    }
    while ( p != NULL ) {
        *p = 0;
        CreateDirectory( HiveDirectory, NULL );
        *p = L'\\';
        p = wcschr( p + 1, L'\\' );
    }
    CreateDirectory( HiveDirectory, NULL );

    return 0;
}

DWORD
DeleteHiveFile (
    PWSTR HiveDirectoryAndFile
    )
{
    SetFileAttributes( HiveDirectoryAndFile, FILE_ATTRIBUTE_NORMAL );
    DeleteFile( HiveDirectoryAndFile );

    return 0;
}

DWORD
DoSpecificRegBackup(
    PWSTR HiveDirectory,
    PWSTR HiveDirectoryAndFile,
    HKEY HiveRoot,
    PWSTR HiveName
    )


/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    HiveDirectory - name of directory for hive file

    HiveDirectoryAndFile - file name to pass directly to OS

    HiveRoot - HKEY_LOCAL_MACHINE or HKEY_USERS

    HiveName - 1st level subkey under machine or users

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    HKEY HiveKey;
    ULONG Disposition;
    LONG Error;
    char *Reason;

    //
    // get a handle to the hive.  use special create call what will
    // use privileges
    //

    Reason = "accessing";
    Error = RTCreateKey(&RegistryContext,
                        HiveRoot,
                        HiveName,
                        KEY_READ,
                        REG_OPTION_BACKUP_RESTORE,
                        NULL,
                        &HiveKey,
                        &Disposition
                       );
    if (Error == NO_ERROR) {
        Reason = "saving";
        CreateHiveDirectory(HiveDirectory);
        DeleteHiveFile(HiveDirectoryAndFile);
        Error = RegSaveKey(HiveKey, HiveDirectoryAndFile, NULL);
        RTCloseKey(&RegistryContext, HiveKey);
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\copy.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.h

Abstract:

    This the include file for supporting copying files, creating new files, and
    copying the registries to the remote server.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#define ALIGN(p,val) (PVOID)((((UINT_PTR)(p) + (val) - 1)) & (~((val) - 1)))
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))

//
// Helper functions in regcopy.c
//
DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    );

DWORD
DoSpecificRegBackup(
    PWSTR HiveDirectory,
    PWSTR HiveDirectoryAndFile,
    HKEY HiveRoot,
    PWSTR HiveName
    );

//
// Global Defines
//
#define TMP_BUFFER_SIZE 1024
#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) )

//
// Memory functions
//
#define IMirrorAllocMem(x) LocalAlloc( LPTR, x)
#define IMirrorFreeMem(x)  LocalFree(x)
#define IMirrorReallocMem(x, sz)  LocalReAlloc(x, sz, LMEM_MOVEABLE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\regtool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regtool.c

Abstract:

    This file contains functions for supporting the registry tools
    REGINI, REGDMP, REGDIR and REGFIND

Author:

    Steve Wood (stevewo) 15-Nov-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    );

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    );

BOOLEAN PrivilegeEnabled;
BOOLEAN RestoreWasEnabled;
BOOLEAN BackupWasEnabled;

BOOLEAN
RTEnableBackupRestorePrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable backup and restore privileges
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &RestoreWasEnabled  // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &BackupWasEnabled   // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    PrivilegeEnabled = TRUE;
    return TRUE;
}


void
RTDisableBackupRestorePrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                        RestoreWasEnabled,
                        FALSE,
                        &RestoreWasEnabled
                      );

    RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                        BackupWasEnabled,
                        FALSE,
                        &BackupWasEnabled
                      );

    PrivilegeEnabled = FALSE;
    return;
}


LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    )
{
    LONG Error;

    if (MachineName != NULL) {
        if (HiveRootName || HiveFileName ) {
            return ERROR_INVALID_PARAMETER;
            }

        Error = RegConnectRegistry( MachineName, HKEY_LOCAL_MACHINE, (PHKEY)&RegistryContext->MachineRoot );
        if (Error == NO_ERROR) {
            Error = RegConnectRegistry( MachineName, HKEY_USERS, (PHKEY)&RegistryContext->UsersRoot );
            if (Error == NO_ERROR) {
                Error = RegOpenKey( RegistryContext->UsersRoot, L".Default", &RegistryContext->CurrentUserRoot );
                }
            }

        if (Error != NO_ERROR) {
            if (RegistryContext->MachineRoot != NULL) {
                RegCloseKey( RegistryContext->MachineRoot );
                RegistryContext->MachineRoot = NULL;
                }

            if (RegistryContext->UsersRoot != NULL) {
                RegCloseKey( RegistryContext->UsersRoot );
                RegistryContext->UsersRoot = NULL;
                }

            return Error;
            }

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        wcscpy( RegistryContext->CurrentUserPath, L"\\Registry\\Users\\.Default" );
        RegistryContext->Target = REG_TARGET_REMOTE_REGISTRY;
        }
    else if (HiveRootName != NULL || HiveFileName != NULL) {
        if (HiveRootName == NULL || HiveFileName == NULL ) {
            return ERROR_INVALID_PARAMETER;
            }

        if (!PrivilegeEnabled && !RTEnableBackupRestorePrivilege()) {
            return ERROR_PRIVILEGE_NOT_HELD;
            }

        RegistryContext->MachineRoot = NULL;
        RegistryContext->UsersRoot = NULL;
        RegistryContext->CurrentUserRoot = NULL;

        Error = RegLoadHive( RegistryContext, HiveFileName, HiveRootName );
        if (Error != NO_ERROR) {
            return Error;
            }

        if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
            *DefaultRootKeyName = HiveRootName;
            }
        RegistryContext->Target = REG_TARGET_HIVE_REGISTRY;
        }
    else {
        NTSTATUS Status;
        UNICODE_STRING CurrentUserKeyPath;

        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegistryContext->UsersRoot = HKEY_USERS;
        RegistryContext->CurrentUserRoot = HKEY_CURRENT_USER;

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError( Status ) );
            return FALSE;
            }

        wcscpy( RegistryContext->CurrentUserPath, CurrentUserKeyPath.Buffer );
        RtlFreeUnicodeString( &CurrentUserKeyPath );

        RegistryContext->Target = REG_TARGET_LOCAL_REGISTRY;
        }

    if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
        *DefaultRootKeyName = L"\\Registry";
        }
    RegistryContext->MachinePathLength = wcslen( RegistryContext->MachinePath );
    RegistryContext->UsersPathLength = wcslen( RegistryContext->UsersPath );
    RegistryContext->CurrentUserPathLength = wcslen( RegistryContext->CurrentUserPath );
    return NO_ERROR;
}


LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    )
{
    switch( RegistryContext->Target ) {
        case REG_TARGET_DISCONNECTED:
            break;

        case REG_TARGET_LOCAL_REGISTRY:
            break;

        case REG_TARGET_REMOTE_REGISTRY:
            break;

        case REG_TARGET_HIVE_REGISTRY:
            RegUnloadHive( RegistryContext );
            break;
        }

    if (PrivilegeEnabled) {
        RTDisableBackupRestorePrivilege();
        }

    RegistryContext->Target = REG_TARGET_DISCONNECTED;
    return NO_ERROR;
}

UNICODE_STRING RegHiveRootName;

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES File;

    if (!RtlDosPathNameToNtPathName_U( HiveFileName,
                                       &NtFileName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return ERROR_BAD_PATHNAME;
        }
    InitializeObjectAttributes( &File,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    RtlInitUnicodeString( &RegHiveRootName, L"\\Registry");
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &RegistryContext->HiveRootHandle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );

    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
        }

    RtlInitUnicodeString( &RegHiveRootName, HiveRootName );
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                RegistryContext->HiveRootHandle,
                                NULL
                              );
    NtUnloadKey( &RegistryContext->HiveRootKey );
    Status = NtLoadKey( &RegistryContext->HiveRootKey, &File );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
        }

    return NO_ERROR;

}

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    PREG_CONTEXT_OPEN_HIVE_KEY p, p1;

    Status = NtOpenKey( &Handle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (NT_SUCCESS( Status )) {
        NtFlushKey( Handle );
        NtClose( Handle );
        }

    p = RegistryContext->OpenHiveKeys;
    while (p) {
        RegCloseKey( p->KeyHandle );
        p1 = p;
        p = p->Next;
        HeapFree( GetProcessHeap(), 0, p1 );
        };

    do {
        Status = NtUnloadKey( &RegistryContext->HiveRootKey );
        }
    while (NT_SUCCESS( Status ) );

    NtClose( RegistryContext->HiveRootHandle );
    return;
}


void
RegRememberOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount += 1;
            return;
            }
        else {
            pp = &p->Next;
            }
        }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) );
    if (p != NULL) {
        p->KeyHandle = KeyHandle;
        p->ReferenceCount = 1;
        p->Next = NULL;
        *pp = p;
        }

    return;
}


void
RegForgetOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount -= 1;
            if (p->ReferenceCount == 0) {
                *pp = p->Next;
                HeapFree( GetProcessHeap(), 0, p );
                return;
                }
            }
        else {
            pp = &p->Next;
            }
        }

    return;
}

BOOLEAN
RegCheckPrefix(
    IN OUT PCWSTR *s,
    IN PCWSTR Prefix,
    IN ULONG PrefixLength
    )
{
    if (PrefixLength == 0) {
        return FALSE;
        }

    if (!_wcsnicmp( *s, Prefix, PrefixLength )) {
        *s += PrefixLength;
        return TRUE;
        }

    return FALSE;
}


BOOLEAN
RegValidateKeyPath(
    IN PREG_CONTEXT RegistryContext,
    IN OUT PHKEY RootKeyHandle,
    IN OUT PCWSTR *SubKeyName
    )
{
    PCWSTR s;

    s = *SubKeyName;
    if (*RootKeyHandle == NULL) {
        if (RegCheckPrefix( &s, L"USER:", 5 ) ||
            RegCheckPrefix( &s, L"HKEY_CURRENT_USER", 17 )
           ) {
            if (RegistryContext->CurrentUserRoot == NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            if (*s == L'\\') {
                s += 1;
                }
            else
            if (s[-1] != L':' && *s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_LOCAL_MACHINE", 18 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_USERS", 10 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->UsersRoot;
            }
        else
        if (*s != L'\\') {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->MachinePath, RegistryContext->MachinePathLength )) {
            *RootKeyHandle = RegistryContext->MachineRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->UsersPath, RegistryContext->UsersPathLength )) {
            *RootKeyHandle = RegistryContext->UsersRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->CurrentUserPath, RegistryContext->CurrentUserPathLength )) {
            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (!_wcsicmp( *SubKeyName, L"\\Registry" )) {
            *RootKeyHandle = NULL;
            }
        else {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        }
    else
    if (*s == L'\\') {
        SetLastError( ERROR_BAD_PATHNAME );
        return FALSE;
        }

    *SubKeyName = s;
    return TRUE;
}

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    )
{
    LONG Error;
    SECURITY_ATTRIBUTES SecurityAttributes;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *Disposition = REG_OPENED_EXISTING_KEY;
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }


        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    SecurityAttributes.nLength = sizeof( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;
    Error = RegCreateKeyEx( RootKeyHandle,
                            SubKeyName,
                            0,
                            NULL,
                            CreateOptions,
                            (REGSAM)DesiredAccess,
                            &SecurityAttributes,
                            ReturnedKeyHandle,
                            Disposition
                          );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

    if (Error == NO_ERROR &&
        *Disposition == REG_OPENED_EXISTING_KEY &&
        SecurityDescriptor != NULL
       ) {
        RegSetKeySecurity( *ReturnedKeyHandle,
                           DACL_SECURITY_INFORMATION,
                           SecurityDescriptor
                         );
        }

    return Error;
}

LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }

        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    Error = RegOpenKeyEx( RootKeyHandle,
                          SubKeyName,
                          OpenOptions,
                          DesiredAccess,
                          ReturnedKeyHandle
                        );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

    return Error;
}

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
        }
    else {
        Error = RegCloseKey( KeyHandle );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegForgetOpenKey( RegistryContext, KeyHandle );
            }

        return Error;
        }
}

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return ERROR_NO_MORE_ITEMS;
        }
    else {
        Error = RegEnumValue( KeyHandle,
                              Index,
                              ValueName,
                              ValueNameLength,
                              NULL,
                              ValueType,
                              ValueData,
                              ValueDataLength
                            );
        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
            }

        return Error;
        }
}

LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    LONG Error;

    Error = RegQueryValueEx( KeyHandle,
                             ValueName,
                             NULL,
                             ValueType,
                             ValueData,
                             ValueDataLength
                           );

    if (Error == NO_ERROR) {
        RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
        }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regcopy\regtool.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regtool.h

Abstract:

    This is the include file for the REGTOOL.DLL registry helper.

Author:

    Steve Wood (stevewo) 16-Nov-1995

Revision History:

--*/

//
// Routines for accessing registry.  Allows code to access any of the following
// registry locations with the same code:
//
//      Windows NT registry on local machine
//      Windows NT registry on remote machine
//      Windows NT hive files
//

#define REG_TARGET_DISCONNECTED    0
#define REG_TARGET_LOCAL_REGISTRY  1
#define REG_TARGET_REMOTE_REGISTRY 2
#define REG_TARGET_HIVE_REGISTRY   4

typedef struct _REG_CONTEXT_OPEN_HIVE_KEY {
    struct _REG_CONTEXT_OPEN_HIVE_KEY *Next;
    HKEY KeyHandle;
    ULONG ReferenceCount;
} REG_CONTEXT_OPEN_HIVE_KEY, *PREG_CONTEXT_OPEN_HIVE_KEY;

typedef struct _REG_CONTEXT {
    struct _REG_CONTEXT *Next;
    ULONG Target;
    HKEY MachineRoot;
    HKEY UsersRoot;
    HKEY CurrentUserRoot;
    WCHAR MachinePath[ MAX_PATH ];
    WCHAR UsersPath[ MAX_PATH ];
    WCHAR CurrentUserPath[ MAX_PATH ];
    ULONG MachinePathLength;
    ULONG UsersPathLength;
    ULONG CurrentUserPathLength;
    HKEY HiveRootHandle;
    OBJECT_ATTRIBUTES HiveRootKey;
    PREG_CONTEXT_OPEN_HIVE_KEY OpenHiveKeys;
} REG_CONTEXT, *PREG_CONTEXT;


BOOLEAN
RTEnableBackupRestorePrivilege( void );

void
RTDisableBackupRestorePrivilege( void );

LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    );

LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    );

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    );


LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    );

#define HKEY_REGISTRY_ROOT          (( HKEY ) (ULONG_PTR)((LONG)0x8000000A) )

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );


LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regacl.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regacl.c

Abstract:

    This provides routines to parse the ACE lists present in the regini
    text input files.  It also provides routines to create the appropriate
    security descriptor from the list of ACEs.

Author:

    John Vert (jvert) 15-Sep-1992

Notes:

    This is based on the SETACL program used in SETUP, written by RobertRe

Revision History:

    John Vert (jvert) 15-Sep-1992
        created
        
    Lonny McMichael (lonnym) 25-March-1999
        added new predefined ACEs (UserR and PowerR)
        
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>

#include <seopaque.h>
#include <sertlp.h>


//
// Private function prototypes
//
BOOLEAN
RegpInitializeACEs(
    VOID
    );

//
// Universal well-known SIDs
//
PSID SeNullSid;
PSID SeWorldSid;
PSID SeCreatorOwnerSid;
PSID SeInteractiveUserSid;
PSID SeTerminalUserSid;

//
// SIDs defined by NT
//
PSID SeNtAuthoritySid;
PSID SeLocalSystemSid;
PSID SeLocalAdminSid;
PSID SeAliasAdminsSid;
PSID SeAliasSystemOpsSid;
PSID SeAliasPowerUsersSid;
PSID SeAliasUsersSid;


SID_IDENTIFIER_AUTHORITY SepNullSidAuthority = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepWorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;

//
// SID of primary domain, and admin account in that domain.
//
PSID SepPrimaryDomainSid;
PSID SepPrimaryDomainAdminSid;

//
// Number of ACEs currently defined
//

#define ACE_COUNT 32

typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    PSID *Sid;
    UCHAR AceType;
    UCHAR AceFlags;
} ACE_DATA, *PACE_DATA;

//
// Table describing the data to put into each ACE.
//
// This table is read during initialization and used to construct a
// series of ACEs.  The index of each ACE in the Aces array defined below
// corresponds to the ordinals used in the input data file.
//

ACE_DATA AceDataTable[ACE_COUNT] = {

    {
        0,
        NULL,
        0,
        0
    },

    //
    // ACE 1 - ADMIN Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 2 - ADMIN Read
    //
    {
        KEY_READ,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 3 - ADMIN Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 4 - ADMIN Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 5 - Creator Full
    //
    {
        KEY_ALL_ACCESS,
        &SeCreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 6 - Creator Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeCreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 7 - World Full
    //
    {
        KEY_ALL_ACCESS,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 8 - World Read
    //
    {
        KEY_READ,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 9 - World Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 10 - World Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 11 - PowerUser Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 12 - PowerUser Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 13 - PowerUser Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 14 - System Ops Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 15 - System Ops Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 16 - System Ops Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 17 - System Full
    //
    {
        KEY_ALL_ACCESS,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 18 - System Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 19 - System Read
    //
    {
        KEY_READ,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 20 - ADMIN Read Write Execute
    //
    {
        KEY_READ | KEY_WRITE | KEY_EXECUTE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 21 - Interactive User Full
    //
    {
        KEY_ALL_ACCESS,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 22 - Interactive User Read
    //
    {
        KEY_READ,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 23 - Interactive User Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 24 - Interactive User Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 25 - Normal Users Read / Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 26 - Terminal User Full
    //
    {
        KEY_ALL_ACCESS,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 27 - Terminal User Read
    //
    {
        KEY_READ,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 28 - Terminal User Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 29 - Terminal User Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 30 - Normal Users Read
    //
    {
        KEY_READ,
        &SeAliasUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 31 - PowerUser Read
    //
    {
        KEY_READ,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    }

};

PKNOWN_ACE Aces[ACE_COUNT];

BOOLEAN
RegInitializeSecurity(
    VOID
    )

/*++

Routine Description:

    This routine initializes the defined ACEs.  It must be called before any
    of the routines to create security descriptors

Arguments:

    None.

Return Value:

    TRUE  - initialization successful
    FALSE - initialization failed

--*/

{
    NTSTATUS Status;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
    SID_IDENTIFIER_AUTHORITY SeNtAuthority;

    NullSidAuthority = SepNullSidAuthority;
    WorldSidAuthority = SepWorldSidAuthority;
    LocalSidAuthority = SepLocalSidAuthority;
    CreatorSidAuthority = SepCreatorSidAuthority;
    SeNtAuthority = SepNtAuthority;

    SeNullSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeWorldSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeCreatorOwnerSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeInteractiveUserSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeTerminalUserSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );

    //
    // Fail initialization if we didn't get enough memory for the universal
    // SIDs
    //
    if (SeNullSid==NULL ||
        SeWorldSid==NULL ||
        SeCreatorOwnerSid==NULL ||
        SeInteractiveUserSid == NULL ||
        SeTerminalUserSid == NULL
       ) {
        return FALSE;
    }

    Status = RtlInitializeSid(SeNullSid, &NullSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid(SeWorldSid, &WorldSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid(SeCreatorOwnerSid, &CreatorSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeInteractiveUserSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeTerminalUserSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    *(RtlSubAuthoritySid(SeNullSid, 0)) = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid(SeWorldSid, 0)) = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid(SeCreatorOwnerSid, 0)) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid(SeInteractiveUserSid, 0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid(SeTerminalUserSid, 0 )) = SECURITY_TERMINAL_SERVER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //
    SeNtAuthoritySid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(0) );
    SeLocalSystemSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeAliasAdminsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasSystemOpsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );

    //
    // fail initialization if we couldn't allocate memory for the NT SIDs
    //

    if (SeNtAuthoritySid == NULL ||
        SeLocalSystemSid == NULL ||
        SeAliasAdminsSid == NULL ||
        SeAliasPowerUsersSid == NULL ||
        SeAliasSystemOpsSid == NULL
       ) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeNtAuthoritySid, &SeNtAuthority, 0 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeLocalSystemSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasAdminsSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasSystemOpsSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasPowerUsersSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasUsersSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    *(RtlSubAuthoritySid( SeLocalSystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

    *(RtlSubAuthoritySid( SeAliasAdminsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasAdminsSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    *(RtlSubAuthoritySid( SeAliasSystemOpsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid, 1 )) = DOMAIN_ALIAS_RID_SYSTEM_OPS;

    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    *(RtlSubAuthoritySid( SeAliasUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasUsersSid, 1 )) = DOMAIN_ALIAS_RID_USERS;

    //
    // The SIDs have been successfully created.  Now create the table of ACEs
    //

    return RegpInitializeACEs();
}

BOOLEAN
RegpInitializeACEs(
    VOID
    )

/*++

Routine Description:

    Initializes the table of ACEs described in the AceDataTable.  This is
    called at initialization time by RiInitializeSecurity after the SIDs
    have been created.

Arguments:

    None.

Return Value:

    TRUE  - ACEs successfully constructed.
    FALSE - initialization failed.

--*/

{
    ULONG i;
    ULONG LengthRequired;
    NTSTATUS Status;

    for (i=1; i<ACE_COUNT; i++) {
        LengthRequired = RtlLengthSid( *(AceDataTable[i].Sid) ) +
                         sizeof( KNOWN_ACE ) - sizeof( ULONG );

        Aces[i] = (PKNOWN_ACE)RtlAllocateHeap( RtlProcessHeap(), 0, LengthRequired );
        if (Aces[i] == NULL) {
            return FALSE;
            }

        Aces[i]->Header.AceType = AceDataTable[i].AceType;
        Aces[i]->Header.AceFlags = AceDataTable[i].AceFlags;
        Aces[i]->Header.AceSize = (USHORT)LengthRequired;

        Aces[i]->Mask = AceDataTable[i].AccessMask;

        Status = RtlCopySid( RtlLengthSid(*(AceDataTable[i].Sid)),
                             &Aces[i]->SidStart,
                             *(AceDataTable[i].Sid)
                           );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }
        }

    return TRUE;
}


BOOLEAN
RegUnicodeToDWORD(
    IN OUT PWSTR *String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    s = *String;
    Sign = UNICODE_NULL;
    while (*s != UNICODE_NULL && *s <= ' ') {
        s += 1;
        }

    c = *s;
    if (c == L'-' || c == L'+') {
        Sign = c;
        c = *++s;
        }

    if (Base == 0) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            c = *++s;
            if (c == L'x') {
                c = *++s;
                Base = 16;
                Shift = 4;
                }
            else
            if (c == L'o') {
                c = *++s;
                Base = 8;
                Shift = 3;
                }
            else
            if (c == L'b') {
                c = *++s;
                Base = 2;
                Shift = 1;
                }
            else {
                c = *--s;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return FALSE;
            }
        }

    //
    // Return an error if end of string before we start
    //
    if (c == UNICODE_NULL) {
        return FALSE;
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *++s;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *String = (PWSTR)s;
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return FALSE;
        }

    return TRUE;
}



BOOLEAN
RegUnicodeToQWORD(
    IN OUT PWSTR *String,
    IN ULONG Base OPTIONAL,
    OUT PDWORDLONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Digit, Shift;
    DWORDLONG Result;

    s = *String;
    Sign = UNICODE_NULL;
    while (*s != UNICODE_NULL && *s <= ' ') {
        s += 1;
        }

    c = *s;
    if (c == L'-' || c == L'+') {
        Sign = c;
        c = *++s;
        }

    if (Base == 0) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            c = *++s;
            if (c == L'x') {
                c = *++s;
                Base = 16;
                Shift = 4;
                }
            else
            if (c == L'o') {
                c = *++s;
                Base = 8;
                Shift = 3;
                }
            else
            if (c == L'b') {
                c = *++s;
                Base = 2;
                Shift = 1;
                }
            else {
                c = *--s;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return FALSE;
            }
        }

    //
    // Return an error if end of string before we start
    //
    if (c == UNICODE_NULL) {
        return FALSE;
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *++s;
        }

    if (Sign == L'-') {
        Result = (DWORDLONG)(-(LONGLONG)Result);
        }

    try {
        *String = (PWSTR)s;
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return FALSE;
        }

    return TRUE;
}



BOOLEAN
RegCreateSecurity(
    IN PWSTR AclStart,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    Computes the appropriate security descriptor based on a string of the
    form "1 2 3 ..." where each number is the index of a particular
    ACE from the pre-defined list of ACEs.

Arguments:

    AclStart - Supplies a unicode string representing a list of ACEs

    SecurityDescriptor - Returns the initialized security descriptor
        that represents all the ACEs supplied

Return Value:

    TRUE if successful and FALSE if not.

--*/

{
    PWSTR p;
    PWSTR StringEnd, StringStart;
    ULONG AceCount=0;
    ULONG AceIndex;
    ULONG i;
    PACL Acl;
    NTSTATUS Status;

    //
    // First we need to count the number of ACEs in the ACL.
    //

    p=AclStart;
    StringEnd = AclStart + wcslen( AclStart );

    //
    // strip leading white space
    //
    while ((*p == L' ' || *p == L'\t') && p != StringEnd) {
        p += 1;
        }

    StringStart = p;

    //
    // Count number of digits in the string
    //

    while (p != StringEnd) {
        if (iswdigit( *p )) {
            ++AceCount;
            do {
                p += 1;
                }
            while (iswdigit( *p ) && p != StringEnd);
            }
        else {
            p += 1;
            }
        }

    Acl = RtlAllocateHeap( RtlProcessHeap(), 0, 256 );
    if (Acl == NULL) {
        return FALSE;
        }

    Status = RtlCreateAcl( Acl, 256, ACL_REVISION2 );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    p = StringStart;
    for (i=0; i<AceCount; i++) {
        AceIndex = wcstoul( p, &p, 10 );
        if (AceIndex == 0) {
            //
            // zero is not a valid index, so it must mean there is some
            // unexpected garbage in the ACE list
            //
            break;
            }

        Status = RtlAddAce( Acl,
                            ACL_REVISION2,
                            MAXULONG,
                            Aces[AceIndex],
                            Aces[AceIndex]->Header.AceSize
                          );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, Acl );
            return FALSE;
            }
        }

    //
    // We now have an appropriately formed ACL, initialize the security
    // descriptor.
    //
    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION
                                        );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           Acl,
                                           FALSE
                                         );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    return TRUE;
}


BOOLEAN
RegFormatSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PWSTR AceList
    )
{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;
    PACL Acl;
    PWSTR s;
    ULONG AceIndex, MyAceIndex;
    PKNOWN_ACE Ace;

    s = AceList;
    *s = UNICODE_NULL;
    Acl = NULL;
    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Acl,
                                           &DaclDefaulted
                                         );
    if (NT_SUCCESS( Status ) && DaclPresent && Acl != NULL) {
        for (AceIndex=0; AceIndex<Acl->AceCount; AceIndex++) {
            Status = RtlGetAce( Acl, AceIndex, &Ace );
            if (!NT_SUCCESS( Status )) {
                return FALSE;
                }

            for (MyAceIndex=1; MyAceIndex<ACE_COUNT; MyAceIndex++) {
                if (Ace->Header.AceType == Aces[ MyAceIndex ]->Header.AceType &&
                    Ace->Header.AceFlags == Aces[ MyAceIndex ]->Header.AceFlags &&
                    Ace->Mask == Aces[ MyAceIndex ]->Mask
                   ) {
                    if (RtlEqualSid( (PSID)&Ace->SidStart, (PSID)&Aces[ MyAceIndex ]->SidStart )) {
                        if (s != AceList) {
                            *s++ = L' ';
                            }

                        s += swprintf( s, L"%d", MyAceIndex );
                        break;
                        }
                    }
                }
            }
        }

    *s = UNICODE_NULL;
    return s != AceList;
}


VOID
RegDestroySecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine cleans up and destroys a security descriptor that was
    previously created with RegCreateSecurity.

Arguments:

    SecurityDescriptor - Supplies a pointer to the security descriptor that
        was previously initialized by RegCreateSecurity.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;
    PACL Acl;
    ULONG AceIndex;
    PKNOWN_ACE Ace;

    Acl = NULL;
    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Acl,
                                           &DaclDefaulted
                                         );
    if (NT_SUCCESS( Status ) && DaclPresent && Acl != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regdiff\regdiff.c ===
/***************************************************************************
*
* MODULE: REGDIFF
*
* This module implements a charmode utility for snapshoting, diffing,
* merging, and unmerging the registry.
*
* If your wondering why this isn't simpler than it is, its because the
* registry is not consistant across all nodes thus special hacks were
* done to make it work.  I have endeavored to keep it clean though and
* there are many functions out of here you can just grab and use for
* the most part.
*
* Happy diffing.
*
* Created 8/20/93 sanfords
***************************************************************************/
#define UNICODE
#define _UNICODE
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <windows.h>

/*
 * By using macros for all IO its easy to just cut it out.
 */
#define DPRINTF(x) if (fDebug) { _fputts(TEXT("DBG:"), stdout); _tprintf##x; }
#define VPRINTF(x) if (fVerbose) _tprintf##x
#define DVPRINTF(x) if (fVerbose | fDebug) _tprintf##x
#define EPRINTF(x) _fputts(TEXT("ERR:"), stdout); _tprintf##x; if (fBreak) DebugBreak()
#define EPUTS(x) _fputts(TEXT("ERR:"), stdout); _putts##x; if (fBreak) DebugBreak()
#define WPRINTF(x) _fputts(TEXT("WARNING:-----\n"), stdout); _tprintf##x
#define MEMFAILED   EPUTS((pszMemFailed));

/*
 * Constants for the LogRegAccess() worker function.
 */
#define LRA_OPEN    0
#define LRA_CREATE  1

/*
 * Structure used to associate any open key with its parent key and
 * subkey name allowing us to optain the full key name of any open
 * key at any time.  Useful for decent output w/o high overhead.
 */
typedef struct tagKEYLOG {
    struct tagKEYLOG *next;
    HKEY hKey;
    HKEY hKeyParent;
    LPTSTR psz;
} KEYLOG, *PKEYLOG;

/*
 * Linked list of all open key logs.
 */
PKEYLOG pKeyLogList = NULL;

/*
 * Flags - mostly set by command line parameters.
 */
BOOL fEraseInputFileWhenDone = FALSE;
BOOL fInclusionListSpecified = FALSE;
BOOL fExclusionListSpecified = FALSE;
BOOL fSnap =    FALSE;
BOOL fDiff =    FALSE;
BOOL fMerge =   FALSE;
BOOL fUnmerge = FALSE;
BOOL fRemoveDiffInfo =  FALSE;
BOOL fWriteDiffInfo = FALSE;
BOOL fLoadDiffInfo = FALSE;
BOOL fVerbose = FALSE;
BOOL fDebug =   FALSE;
BOOL fBreak =   FALSE;
BOOL fSafe =    FALSE;

LPSTR pszSnapFileIn = NULL;
LPSTR pszSnapFileOut = NULL;
LPSTR pszDiffFileIn = NULL;
LPSTR pszDiffFileOut = NULL;
LPSTR pszTempFile = "regdiff1";
LPSTR pszTempFileLog = "regdiff1.log";
LPSTR pszTempFile2 = "regdiff2";
LPSTR pszTempFile2Log = "regdiff2.log";
LPSTR pszDummyFile = "_regdiff";
LPSTR pszDummyFileLog = "_regdiff.log";

LPTSTR pszMemFailed = TEXT("Memory Failure.\n");
LPTSTR pszTemp1 = NULL;
LPTSTR pszTemp2 = NULL;
LPTSTR pszTemp3 = NULL;

LPTSTR pszCurUserSID = NULL;
LPTSTR pszHKEY_LOCAL_MACHINE = TEXT("HKEY_LOCAL_MACHINE");
LPTSTR pszHKEY_USERS =  TEXT("HKEY_USERS");
LPTSTR pszHKEY_CURRENT_USER =  TEXT("HKEY_CURRENT_USER");
LPTSTR pszHKEY_CURRENT_USER_Real = NULL;    // made from user's SID
LPTSTR pszHKEY_CLASSES_ROOT = TEXT("HKEY_CLASSES_ROOT");
LPTSTR pszHKEY_CLASSES_ROOT_Real = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes");
LPTSTR pszRealClassesRoot = TEXT("SOFTWARE\\Classes");
LPTSTR pszDiffRoot = TEXT("regdiff");
LPTSTR pszAddKey = TEXT("Add");
LPTSTR pszDelKey = TEXT("Del");
LPTSTR pszSnapshotSubkeyName = TEXT("Regdiff_SnapshotKey");

/*
 * default Exception list
 */
LPTSTR apszExceptKeys[] = {
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\Clone"),
        TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CacheLastUpdate"),
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet"),
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet???"),
    };
DWORD cExceptKeys = sizeof(apszExceptKeys)/sizeof(LPTSTR);
LPTSTR *ppszExceptKeys = apszExceptKeys;  // pointer to current exception list.

/*
 * default Inclusion list
 */
LPTSTR apszIncludeKeys[] = {
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM"),
        TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE"),
        TEXT("HKEY_CURRENT_USER"),
    };
DWORD cIncludeKeys = sizeof(apszIncludeKeys)/sizeof(LPTSTR);
LPTSTR *ppszIncludeKeys = apszIncludeKeys;  // pointer to current inclusion list.

/*
 * array of flags used to make sure that our loaded snapfile contained
 * at least all the keys in the inclusion list.
 */
BOOL afIncludeKeyMarks[sizeof(apszIncludeKeys)/sizeof(LPTSTR)] = {
    FALSE,
    FALSE,
    FALSE,
};
BOOL *pfIncludeKeyMarks = afIncludeKeyMarks;

/*
 * Necessary prototypes.
 */
BOOL AddNodeInfo(HKEY hKeyInfo, HKEY hKeyTarget);



VOID PrintUsage(VOID)
{
    DWORD i;

    _tprintf(
            TEXT("regdiff usage:\n")
            TEXT("\n")
            TEXT("-s <snapfile>\n")
            TEXT("    save current registry contents to snapfile.\n")
            TEXT("-d <snapfile>\n")
            TEXT("    create diff info from current registry state and <snapfile>.\n")
            TEXT("-l <difffile>\n")
            TEXT("    load diff info into registry from <difffile>.\n")
            TEXT("-w <difffile>\n")
            TEXT("    write diff info to <difffile> from registry when done.\n")
            TEXT("-e  erase input file(s) after done.\n")
            TEXT("-m  merge diff info into current registry.\n")
            TEXT("-u  unmerge diff info from current registry.\n")
            TEXT("-r  remove diff info from registry when done.\n")
            TEXT("-x <exceptionsfile>\n")
            TEXT("    use <exceptionsfile> to bypass diff, merge or unmerge on certain keys.\n")
            TEXT("-i <inclusionsfile>\n")
            TEXT("    use <inclusionsfile> to snap or diff only certain keys.\n")
            TEXT("-v  verbose output on.\n")
            TEXT("-@  Debug mode.\n")
            TEXT("-b  break on errors.\n")
            TEXT("-n  neuter - don't really do merges/unmerges. (for safe testing)\n")
            TEXT("\n")
            TEXT("<snapfile> and <difffile> should not have extensions on FAT partitions.\n")
            TEXT("diff info is kept in HKEY_LOCAL_MACHINE\\regdiff\n")
            );

    _tprintf(TEXT("\nThe default inclusions list is:\n"));
    for (i = 0; i < cIncludeKeys; i++) {
        _tprintf(TEXT("  %ws\n"), ppszIncludeKeys[i]);
    }

    _tprintf(TEXT("\nThe default exceptions list is:\n"));
    for (i = 0; i < cExceptKeys; i++) {
        _tprintf(TEXT("  %ws\n"), ppszExceptKeys[i]);
    }
}


/*
 * The following functions allow us to log all registry key openings and
 * closeings so we can know at any time the full path of any open key.
 *
 * This simplifies such things as exception and inclusion lookups.
 */

LPTSTR LookupPathFromKey(
HKEY hKey,
PHKEY phKeyParent)
{
    PKEYLOG pkl;

    *phKeyParent = NULL;
    if (hKey == HKEY_LOCAL_MACHINE) {
        return(pszHKEY_LOCAL_MACHINE);
    } else if (hKey == HKEY_USERS) {
        return(pszHKEY_USERS);
    } else if (hKey == HKEY_CURRENT_USER) {
        return(pszHKEY_CURRENT_USER_Real);
    } else if (hKey == HKEY_CLASSES_ROOT) {
        return(pszHKEY_CLASSES_ROOT_Real);
    } else {
        pkl = pKeyLogList;
        while (pkl != NULL) {
            if (pkl->hKey == hKey) {
                *phKeyParent = pkl->hKeyParent;
                return(pkl->psz);
            }
            pkl = pkl->next;
        }
        return(NULL);
    }
}

/*
 * This removes pseudo-key root names from paths and changes them to
 * real-root names.
 *
 * Return string must be freed by caller if pfFree is set.
 */
LPTSTR NormalizePathName(
LPTSTR pszPath,
BOOL *pfFree)
{
    LPTSTR pszOffender, pszFixed;

    if (pfFree != NULL) {
        *pfFree = FALSE;
    }
    pszOffender = _tcsstr(pszPath, pszHKEY_CURRENT_USER);
    if (pszOffender != NULL) {
        pszFixed = malloc((
                _tcslen(pszPath) +
                _tcslen(pszHKEY_CURRENT_USER_Real) -
                _tcslen(pszHKEY_CURRENT_USER) +
                1) * sizeof(TCHAR));
        if (pszFixed == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszFixed, pszHKEY_CURRENT_USER_Real);
        _tcscat(pszFixed, pszOffender + _tcslen(pszHKEY_CURRENT_USER));
        if (pfFree != NULL) {
            *pfFree = TRUE;
        }
        return(pszFixed);
    }
    pszOffender = _tcsstr(pszPath, pszHKEY_CLASSES_ROOT);
    if (pszOffender != NULL) {
        pszFixed = malloc((
                _tcslen(pszPath) +
                _tcslen(pszHKEY_CLASSES_ROOT_Real) -
                _tcslen(pszHKEY_CLASSES_ROOT) +
                1) * sizeof(TCHAR));
        if (pszFixed == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszFixed, pszHKEY_CLASSES_ROOT_Real);
        _tcscat(pszFixed, pszOffender + _tcslen(pszHKEY_CLASSES_ROOT));
        if (pfFree != NULL) {
            *pfFree = TRUE;
        }
        return(pszFixed);
    }
    return(pszPath);    // already normalized
}


/*
 * return value must be freed by caller.
 *
 * NULL is returned on error.
 */
LPTSTR GetFullPathFromKey(
HKEY hKey,
LPCTSTR pszSubkey)
{
    LPTSTR pszPart, pszNewSubkey;
    HKEY hKeyParent;

    pszPart = LookupPathFromKey(hKey, &hKeyParent);
    if (pszPart != NULL) {
        pszNewSubkey = malloc((_tcslen(pszPart) + 1 +
            (pszSubkey == NULL ? 0 : (_tcslen(pszSubkey) + 1))) *
            sizeof(TCHAR));
        if (pszNewSubkey == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszNewSubkey, pszPart);
        if (pszSubkey != NULL) {
            _tcscat(pszNewSubkey, TEXT("\\"));
            _tcscat(pszNewSubkey, pszSubkey);
        }
        if (hKeyParent != NULL) {
            pszPart = GetFullPathFromKey(hKeyParent, pszNewSubkey);
            free(pszNewSubkey);
        } else {
            pszPart = pszNewSubkey;
        }
    }
    return(pszPart);
}

/*
 * Same as GetFullPathFromKey but the pointer given is reused.
 */
LPTSTR ReuseFullPathFromKey(
HKEY hKey,
LPCTSTR pszSubkey,
LPTSTR *ppsz)
{
    if (*ppsz != NULL) {
        free(*ppsz);
    }
    *ppsz = GetFullPathFromKey(hKey, pszSubkey);
    return(*ppsz);
}



LONG LogRegAccessKey(
DWORD AccessType,
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    PKEYLOG pkl;
    LONG status;
    DWORD dwDisp;

    DPRINTF((TEXT("LogRegAccessKey(%s, %s, %s)\n"),
            (AccessType == LRA_OPEN ? TEXT("Open") : TEXT("Create")),
            ReuseFullPathFromKey(hKey, NULL, &pszTemp1),
            pszSubkeyName));

    switch (AccessType) {
    case LRA_OPEN:
        status = RegOpenKeyEx(hKey, pszSubkeyName, 0, KEY_ALL_ACCESS, phSubkey);
        if (status != ERROR_SUCCESS) {
            DPRINTF((TEXT("Failed to open key %s with ALL_ACCESS.\n"),
                    ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));
            /*
             * Loaded keys can't be written to - so try opening readonly.
             */
            status = RegOpenKeyEx(hKey, pszSubkeyName, 0, KEY_READ, phSubkey);
        }
        break;

    case LRA_CREATE:
        status = RegCreateKeyEx(hKey, pszSubkeyName, 0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, phSubkey, \
                &dwDisp);
        if (status != ERROR_SUCCESS) {
            /*
             * Loaded keys can't be written to - so try opening readonly.
             */
            DPRINTF((TEXT("Failed to create key %s with ALL_ACCESS.\n"),
                    ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));
            status = RegCreateKeyEx(hKey, pszSubkeyName, 0, TEXT(""),
                    REG_OPTION_NON_VOLATILE, KEY_READ, NULL, phSubkey, \
                    &dwDisp);
        }
        break;
    }
    if (status == ERROR_SUCCESS) {
        pkl = malloc(sizeof(KEYLOG));
        if (pkl != NULL) {
            pkl->psz = malloc((_tcslen(pszSubkeyName) + 1) * sizeof(TCHAR));
            if (pkl->psz != NULL) {
                pkl->next = pKeyLogList;
                pkl->hKey = *phSubkey;
                pkl->hKeyParent = hKey;
                _tcscpy(pkl->psz, pszSubkeyName);
                pKeyLogList = pkl;
            } else {
                status = ERROR_NOT_ENOUGH_MEMORY;
                free(pkl);
            }
        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}




LONG LogRegOpenKey(
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    return(LogRegAccessKey(LRA_OPEN, hKey, pszSubkeyName, phSubkey));
}



LONG LogRegCreateKey(
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    return(LogRegAccessKey(LRA_CREATE, hKey, pszSubkeyName, phSubkey));
}


LONG LogRegCloseKey(
HKEY hKey)
{
    PKEYLOG pkl, pklPrev;

    DPRINTF((TEXT("LogRegCloseKey(%s)\n"),
            ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));

    pkl = pKeyLogList;
    pklPrev = NULL;
    while (pkl != NULL) {
        if (hKey == pkl->hKey) {
            if (pklPrev != NULL) {
                pklPrev->next = pkl->next;
            } else {
                pKeyLogList = pkl->next;
            }
            free(pkl->psz);
            free(pkl);
            break;
        }
        pklPrev = pkl;
        pkl = pkl->next;
    }
    if (pkl == NULL) {
        EPRINTF((TEXT("Key %s being closed was not found in KeyLog.\n"),
                ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));
    }
    return(RegCloseKey(hKey));
}



/*
 * Simpler privilege enabling mechanism.
 */
BOOL EnablePrivilege(
LPCTSTR lpszPrivilege)
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken = NULL;

    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_READ | TOKEN_WRITE, &hToken)) {
        EPUTS((TEXT("Could not open process token.\n")));
        return(FALSE);
    }
    if (hToken == NULL) {
        EPUTS((TEXT("Could not open process token.\n")));
        return(FALSE);
    }
    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &tp.Privileges[0].Luid)) {
        EPRINTF((TEXT("Could not lookup privilege value %s.\n"), lpszPrivilege));
        return(FALSE);
    }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL)) {
        EPRINTF((TEXT("Could not adjust privilege %s.\n"), lpszPrivilege));
        return(FALSE);
    }
    return(TRUE);
}



/*
 * a little more sane version of the real API that can handle NULLs.
 */
LONG MyRegQueryInfoKey(
HKEY hKey,
LPDWORD lpcSubkeys,
LPDWORD lpcchMaxSubkey,
LPDWORD lpcValues,
LPDWORD lpcchMaxValueName,
LPDWORD lpcbMaxValueData,
LPFILETIME lpft)
{
    DWORD cchClass, cSubkeys, cchMaxSubkey, cchMaxClass, cValues;
    DWORD cchMaxValueName, cbMaxValueData, cbSID;
    FILETIME LastWriteTime;
    TCHAR szClass[100];
    LONG status;

    cchClass = 100;
    status = RegQueryInfoKey(hKey,
            szClass,
            &cchClass,
            NULL,
            (lpcSubkeys == NULL)        ?   &cSubkeys           : lpcSubkeys,
            (lpcchMaxSubkey == NULL)    ?   &cchMaxSubkey       : lpcchMaxSubkey,
            &cchMaxClass,
            (lpcValues == NULL)         ?   &cValues            : lpcValues,
            (lpcchMaxValueName == NULL) ?   &cchMaxValueName    : lpcchMaxValueName,
            (lpcbMaxValueData == NULL)  ?   &cbMaxValueData     : lpcbMaxValueData,
            &cbSID,
            (lpft == NULL)              ?   &LastWriteTime      : lpft);
    if (status == ERROR_MORE_DATA) {
        status = ERROR_SUCCESS;
    }
    return(status);
}


/*
 * Frees strings allocated with GetCurUserSidString().
 */
VOID DeleteSidString(
LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/*
 * Gets the current user's SID in text form.
 * The return string should be freed using DeleteSidString().
 */
LPTSTR GetCurUserSidString(VOID)
{
    HANDLE hToken;
    TOKEN_USER tu;
    DWORD cbRequired;
    PTOKEN_USER ptu = NULL, ptuUse;
    UNICODE_STRING UnicodeString;
#ifndef UNICODE
    STRING String;
#endif
    NTSTATUS NtStatus;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken)) {
        EPUTS((TEXT("Could not open process token.\n")));
        return(NULL);
    }
    if (hToken == NULL) {
        EPUTS((TEXT("Could not open process token.\n")));
        return(NULL);
    }
    if (!GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &cbRequired)) {
        if (cbRequired > sizeof(tu)) {
            ptu = malloc(cbRequired);
            if (ptu == NULL) {
                return(NULL);
            }
            if (!GetTokenInformation(hToken, TokenUser, ptu, cbRequired, &cbRequired)) {
                free(ptu);
                EPUTS((TEXT("Could not get token information.\n")));
                return(NULL);
            }
            ptuUse = ptu;
        } else {
            EPUTS((TEXT("Could not get token information.\n")));
            return(NULL);
        }
    } else {
        ptuUse = &tu;
    }
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString, ptuUse->User.Sid, TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        EPRINTF((TEXT("Could not get current user SID string.  NtError=%d\n"), NtStatus));
        return(NULL);
    }

    if (ptu) {
        free(ptu);
    }

#ifdef UNICODE

    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        EPRINTF((TEXT("Could not convert user SID string to ANSI.  NtError=%d\n"), NtStatus));
        return(NULL);
    }

    return(String.Buffer);

#endif
}



/*
 * This function stores/appends the contents of the hKey subkey specified to
 * hfOut.  pszKeyName is for error output use.
 *
 * Returns fSuccess - TRUE if ALL info was successfully saved.
 */
BOOL StoreSubKey(
HKEY hKey,
LPTSTR pszSubkeyName,
FILE *hfOut)
{
    DWORD status, cb;
    HKEY hSubkey;
    FILE *hfIn;
    VOID *pBuf;

    DVPRINTF((TEXT("  Snapping %s...\n"),
            ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));

    DeleteFileA(pszTempFile);       // RegSaveKey() won't work if this exists.

    status = LogRegOpenKey(hKey, pszSubkeyName, &hSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s. Error=%d.\n"),
                ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1), status));
        return(FALSE);
    }
    /*
     * store key in temp file.
     */
    status = RegSaveKeyA(hSubkey, pszTempFile, NULL);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not save %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1), status));
Exit1:
        LogRegCloseKey(hSubkey);
        return(FALSE);
    }

    /*
     * open key data file
     */
    hfIn = fopen(pszTempFile, "rb+");
    if (hfIn == NULL) {
        EPUTS((TEXT("File read error.\n")));
        goto Exit1;
    }

    /*
     * write sizeof Subkey name.
     */
    cb = (_tcslen(pszSubkeyName) + 1) * sizeof(TCHAR);
    if (fwrite(&cb, 1, sizeof(DWORD), hfOut) != sizeof(DWORD) || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [sizeof(%s).]\n"), pszSubkeyName));
Exit2:
        fclose(hfIn);
        DeleteFileA(pszTempFile);
        goto Exit1;
    }
    /*
     * write Subkey name.
     */
    if (fwrite(pszSubkeyName, 1, cb, hfOut) != cb || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [%s]\n"), pszSubkeyName));
        goto Exit2;
    }

    /*
     * write root key handle (MUST BE AN HKEY_ CONSTANT!)
     */
    if (fwrite(&hKey, 1, sizeof(HKEY), hfOut) != sizeof(HKEY) || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [Handle of %s.]\n"),
                ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));
        goto Exit2;
    }

    /*
     * get key data file size
     */
    if (fseek(hfIn, 0, SEEK_END)) {
        EPUTS((TEXT("Seek failure.\n")));
        goto Exit2;
    }
    cb = ftell(hfIn);

    /*
     * write sizeof key data
     */
    if (fwrite(&cb, 1, sizeof(DWORD), hfOut) != sizeof(DWORD) || ferror(hfOut)) {
        EPUTS((TEXT("Write failure. [sizeof key data]\n")));
        goto Exit2;
    }
    /*
     * alocate key data buffer
     */
    pBuf = malloc(cb);
    if (pBuf == NULL) {
        EPUTS((TEXT("memory error. [key data buffer.]\n")));
        goto Exit2;
    }
    /*
     * read key data into buffer
     */
    if (fseek(hfIn, 0, SEEK_SET)) {
        EPUTS((TEXT("Seek failure.\n")));
        goto Exit2;
    }
    if (fread(pBuf, 1, cb, hfIn) != cb || ferror(hfIn)) {
        EPUTS((TEXT("Read failure. [key data.]\n")));
        goto Exit2;
    }
    /*
     * write key data
     */
    if (fwrite(pBuf, 1, cb, hfOut) != cb || ferror(hfOut)) {
        EPUTS((TEXT("Write failure. [key data.]\n")));
        goto Exit2;
    }
    free(pBuf);
    fclose(hfIn);
    LogRegCloseKey(hSubkey);

    /*
     * remove temp file
     */
    DeleteFileA(pszTempFile);
    return(TRUE);
}


/*
 * Creates a canonical key name from hKeyRoot and prefixes it with pszPrefix.
 *
 * ppszNode must be freed by caller.
 * returns fSuccess.
 */
BOOL GetKeyNameWithPrefix(
LPTSTR *ppszNode,   // results needs to be freed
HKEY hKeyRoot,
LPTSTR pszPrefix)
{
    LPTSTR pszPrefix1;

    pszPrefix1 = ReuseFullPathFromKey(hKeyRoot, NULL, &pszTemp1);
    *ppszNode = malloc(
            (_tcslen(pszPrefix1) +
            _tcslen(pszPrefix) +
            3) * sizeof(TCHAR));
    if (*ppszNode == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(*ppszNode, pszPrefix);
    _tcscat(*ppszNode, TEXT("\\"));
    _tcscat(*ppszNode, pszPrefix1);
    return(TRUE);
}




/*
 * Breaks up a canonical key name into its root, and subkey names and
 * also returns the root HKEY key value as well.
 *
 * pfFreeSubkeyString is set to TRUE if the ppszSubkey returned
 * was allocated.
 *
 * returns fSuccess.
 */
BOOL KeyPartsFromNodeName(
LPTSTR pszNode,
LPTSTR *ppszRootkey,
LPTSTR *ppszSubkey,      // FREE this if pfFreeSubkeyString is set on return.
HKEY *phKeyRoot,
BOOL *pfFreeSubkeyString)
{
    *pfFreeSubkeyString = FALSE;
    if (_tcsstr(pszNode, pszHKEY_LOCAL_MACHINE) == pszNode) {
        *ppszRootkey = pszHKEY_LOCAL_MACHINE;
        *phKeyRoot = HKEY_LOCAL_MACHINE;
        *ppszSubkey = &pszNode[_tcslen(pszHKEY_LOCAL_MACHINE) + 1];
    } else if (_tcsstr(pszNode, pszHKEY_USERS) == pszNode) {
        *ppszRootkey = pszHKEY_USERS;
        *phKeyRoot = HKEY_USERS;
        *ppszSubkey = &pszNode[_tcslen(pszHKEY_USERS) + 1];
    } else if (_tcsstr(pszNode, pszHKEY_CURRENT_USER) == pszNode) {
        *ppszRootkey = pszHKEY_USERS;
        *phKeyRoot = HKEY_USERS;
        *ppszSubkey = malloc((_tcslen(pszCurUserSID) +
               _tcslen(pszNode)) * sizeof(TCHAR));
        if (*ppszSubkey == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy(*ppszSubkey, pszCurUserSID);
        _tcscat(*ppszSubkey, &pszNode[_tcslen(pszHKEY_CURRENT_USER)]);
        *pfFreeSubkeyString = TRUE;
    } else if (_tcsstr(pszNode, pszHKEY_CLASSES_ROOT) == pszNode) {
        *ppszRootkey = pszHKEY_LOCAL_MACHINE;
        *phKeyRoot = HKEY_LOCAL_MACHINE;
        *ppszSubkey = malloc((_tcslen(pszRealClassesRoot) +
               _tcslen(pszNode)) * sizeof(TCHAR));
        if (*ppszSubkey == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy(*ppszSubkey, pszRealClassesRoot);
        _tcscat(*ppszSubkey, &pszNode[_tcslen(pszHKEY_CLASSES_ROOT)]);
        *pfFreeSubkeyString = TRUE;
    } else {
        return(FALSE);
    }
    return(TRUE);
}



/*
 * Snapshots the local hives and puts the into into pszOutFile.
 */
BOOL SnapHives(
LPSTR pszOutFile)
{
    FILE *hfOut;
    LPTSTR pszRootkey, pszSubkey;
    HKEY hKeyRoot;
    BOOL fFree;
    DWORD i;

    DPRINTF((TEXT("SnapHives(%hs)\n"), pszOutFile));

    hfOut = fopen(pszOutFile, "wb");
    if (hfOut == NULL) {
        EPRINTF((TEXT("Couldn't create %hs.\n"), pszOutFile));
        return(FALSE);
    }
    for (i = 0; i < cIncludeKeys; i++) {
        if (!KeyPartsFromNodeName(ppszIncludeKeys[i], &pszRootkey,
                &pszSubkey, &hKeyRoot, &fFree)) {
            EPRINTF((TEXT("Invalid Inclusion list entry: %s.\n"),
                    ppszIncludeKeys[i]));
            fclose(hfOut);
            return(FALSE);
        }
        if (!StoreSubKey(hKeyRoot, pszSubkey, hfOut)) {
            EPUTS((TEXT("Snapshot failed.\n")));
            if (fFree) {
                free(pszSubkey);
            }
            fclose(hfOut);
            return(FALSE);
        }
        if (fFree) {
            free(pszSubkey);
        }
    }
    fclose(hfOut);
    VPRINTF((TEXT("Snapshot to %hs completed ok.\n"), pszOutFile));
    return(TRUE);
}


/*
 * Special string searching code that sees if pszSearch is a proper
 * substring of pszData where '?'s in pszSearch match any character in
 * pszData.  pszData must not be '\' when pszSearch is '?'.
 *
 * returns fMatched.
 */
BOOL substrrexp(
LPCTSTR pszSearch,
LPCTSTR pszData)
{
    // DPRINTF(("substrrexp(%s,%s) = ", pszData, pszSearch));

    while (*pszData != TEXT('\0') && *pszSearch != TEXT('\0')) {
        if (*pszSearch != TEXT('?')) {
            if (*pszData != *pszSearch) {
                break;
            }
        } else {
            if (*pszData == TEXT('\\')) {
                break;      // prevents \ from matching a ?
            }
        }
        pszData++;
        pszSearch++;
    }
    // DPRINTF(("%d\n", *pszSearch == TEXT('\0')));
    return(*pszSearch == TEXT('\0'));
}



/*
 * Searches all the node names in the node list given and sets the
 * corresponding afMarkFound[] element to TRUE if hKey\pszSubkey is
 * referenced within that node name.  Returns TRUE if ANY node names
 * reference the subkey name.
 *
 * afMarkFound may be NULL.
 * pszSubkey may be NULL.
 */
BOOL IsKeyWithinNodeList(
HKEY hKey,
LPTSTR pszSubkey,   // optional
LPTSTR *apszNodes,
DWORD cNodes,
BOOL *afMarkFound)  // optional
{
    DWORD i;
    BOOL fRet;
    LPTSTR pszFullName;

    fRet = FALSE;
    pszFullName = GetFullPathFromKey(hKey, pszSubkey);
    if (pszFullName != NULL) {
        for (i = 0; i < cNodes; i++) {
            if (substrrexp(apszNodes[i], pszFullName) &&
                    (pszFullName[_tcslen(apszNodes[i])] == TEXT('\\') ||
                    pszFullName[_tcslen(apszNodes[i])] == TEXT('\0'))) {
                fRet = TRUE;
                if (afMarkFound != NULL) {
                    afMarkFound[i] = TRUE;
                }
            }
            if (fRet && afMarkFound == NULL) {
                break;  // no need to cycle if not marking found nodes.
            }
        }
        free(pszFullName);
    }
    return(fRet);
}



BOOL CopyKeySubkey(
HKEY hKeyFrom,
LPTSTR pszSubkeyFrom,
HKEY hKeyTo,
LPTSTR pszSubkeyTo)
{
    LONG status;
    HKEY hSubkeyFrom, hSubkeyTo;
    BOOL fRet;

    DPRINTF((TEXT("CopyKeySubkey(%s, %s)\n"),
            ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1),
            ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp2)));

    /*
     * This key could be in our exclusion list - check first.
     */
    if (IsKeyWithinNodeList(hKeyFrom, pszSubkeyFrom, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (IsKeyWithinNodeList(hKeyTo, pszSubkeyTo, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (!fSafe) {
        status = LogRegOpenKey(hKeyFrom, pszSubkeyFrom, &hSubkeyFrom);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not open key %s. Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1), status));
            return(FALSE);
        }
        status = LogRegCreateKey(hKeyTo, pszSubkeyTo, &hSubkeyTo);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not create key %s. Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp1), status));
            return(FALSE);
        }
        fRet = AddNodeInfo(hSubkeyFrom, hSubkeyTo);
        LogRegCloseKey(hSubkeyTo);
        LogRegCloseKey(hSubkeyFrom);
    } else if (fDebug || fVerbose) {
        LPTSTR pszInfo = GetFullPathFromKey(hKeyFrom, pszSubkeyFrom);
        LPTSTR pszTarget = GetFullPathFromKey(hKeyTo, pszSubkeyTo);
        VPRINTF((TEXT("Would have copied %s to %s.\n"),
                ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1),
                ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp2)));
        free(pszInfo);
        free(pszTarget);
        fRet = TRUE;
    }
    return(fRet);
}



/*
 * Combines the pszName entries into one string and passes control on to
 * CopyKeySubkey().
 */
BOOL CopyKeySubkeyEx(
HKEY hKeyFrom,
LPTSTR pszSubkeyName,
HKEY hKeyTo,
LPTSTR pszNameTo1,
LPTSTR pszNameTo2)
{
    LPTSTR psz;

    psz = malloc((_tcslen(pszNameTo1) + _tcslen(pszNameTo2) +
            _tcslen(pszSubkeyName) + 3) * sizeof(TCHAR));
    if (psz == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(psz, pszNameTo1);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszNameTo2);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszSubkeyName);

    if (!CopyKeySubkey(hKeyFrom, pszSubkeyName, hKeyTo, psz)) {
        free(psz);
        return(FALSE);
    }
    free(psz);
    return(TRUE);
}



BOOL CopyKeyValue(
HKEY hKeyFrom,
HKEY hKeyTo,
LPTSTR pszValue)
{
    LONG status;
    PVOID pBuf;
    DWORD dwType, cbData;

    DPRINTF((TEXT("CopyKeyValue(%s, %s, %s)\n"),
            ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
            ReuseFullPathFromKey(hKeyTo, NULL, &pszTemp2),
            pszValue));

    /*
     * This key could be in our exclusion list - check first.
     */
    if (IsKeyWithinNodeList(hKeyFrom, pszValue, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Source Value \"%s\" was EXCLUDED.\n"), pszValue));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (IsKeyWithinNodeList(hKeyTo, pszValue, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Target Value \"%s\" was EXCLUDED.\n"), pszValue));
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = RegQueryValueEx(hKeyFrom, pszValue, NULL, &dwType, NULL, &cbData);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not query value %s size from %s.  Error=%d.\n"),
                pszValue, ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
                status));
        return(FALSE);
    }
    pBuf = malloc(cbData);
    if (pBuf == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    status = RegQueryValueEx(hKeyFrom, pszValue, NULL, &dwType, pBuf, &cbData);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not query value %s from %s.  Error=%d.\n"),
                pszValue, ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
                status));
        free(pBuf);
        return(FALSE);
    }
    status = RegSetValueEx(hKeyTo, pszValue, 0, dwType, (BYTE *)pBuf, cbData);
    free(pBuf);
    if (status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        EPRINTF((TEXT("Could not set value %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKeyTo, pszValue, &pszTemp1), status));
        return(FALSE);
    }
}



/*
 * Combines the pszName entries into one string and passes control on to
 * CopyKeyValue().
 */
BOOL CopyKeyValueEx(
HKEY hKeyFrom,
LPTSTR pszValueName,
HKEY hKeyTo,
LPTSTR pszNameTo1,
LPTSTR pszNameTo2)
{
    LPTSTR psz;
    HKEY hKeyToFull;
    LONG status;

    psz = malloc((_tcslen(pszNameTo1) + _tcslen(pszNameTo2) + 2) * sizeof(TCHAR));
    if (psz == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(psz, pszNameTo1);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszNameTo2);

    status = LogRegCreateKey(hKeyTo, psz, &hKeyToFull);
    if (status != ERROR_SUCCESS) {
        free(psz);
        return(FALSE);
    }
    free(psz);

    if (!CopyKeyValue(hKeyFrom, hKeyToFull, pszValueName)) {
        EPRINTF((TEXT("Key value %s could not be copied from %s to %s.\n"),
                pszValueName,
                ReuseFullPathFromKey(hKeyFrom, (LPCTSTR)NULL, &pszTemp1),
                ReuseFullPathFromKey(hKeyToFull, (LPCTSTR)NULL, &pszTemp2)));
        LogRegCloseKey(hKeyToFull);
        return(FALSE);
    }
    LogRegCloseKey(hKeyToFull);
    return(TRUE);
}



BOOL AreValuesEqual(
HKEY hSubkey1,
LPTSTR pszValueName1,
HKEY hSubkey2,
LPTSTR pszValueName2)
{
    LONG status;
    BOOL fRet = FALSE;
    DWORD dwType1, cbData1;
    DWORD dwType2, cbData2;
    PVOID pBuf1, pBuf2;

    DPRINTF((TEXT("AreValuesEqual(%s, %s)\n"),
            ReuseFullPathFromKey(hSubkey1, pszValueName1, &pszTemp1),
            ReuseFullPathFromKey(hSubkey2, pszValueName2, &pszTemp2)));

    status = RegQueryValueEx(hSubkey1, pszValueName1, NULL, &dwType1, NULL, &cbData1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value size of %s. Error=%d.\n"), pszValueName1, status));
        return(FALSE);
    }
    status = RegQueryValueEx(hSubkey2, pszValueName2, NULL, &dwType2, NULL, &cbData2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value size of %s. Error=%d.\n"), pszValueName2, status));
        return(FALSE);
    }
    if (dwType1 != dwType2 || cbData1 != cbData2) {
        return(FALSE);
    }

    pBuf1 = malloc(cbData1);
    if (pBuf1 == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    status = RegQueryValueEx(hSubkey1, pszValueName1, NULL, &dwType1, pBuf1, &cbData1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value %s. Error=%d.\n"), pszValueName1, status));
        goto Exit1;
    }

    pBuf2 = malloc(cbData2);
    if (pBuf2 == NULL) {
        MEMFAILED;
        goto Exit1;
    }
    status = RegQueryValueEx(hSubkey2, pszValueName2, NULL, &dwType2, pBuf2, &cbData2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value %s. Error=%d.\n"), pszValueName2, status));
        goto Exit2;
    }

    fRet = memcmp(pBuf1, pBuf2, cbData1) == 0;
Exit2:
    free(pBuf2);
Exit1:
    free(pBuf1);
    return(fRet);
}


int __cdecl mycmp(
LPCTSTR *ppsz1,
LPCTSTR *ppsz2)
{
    return(_tcscmp(*ppsz1, *ppsz2));
}


VOID FreeSortedValues(
LPTSTR *ppsz,
DWORD cValues)
{
    DWORD i;

    if (cValues) {
        for (i = 0; i < cValues; i++) {
            free(ppsz[i]);
        }
        free(ppsz);
    }
}




LPTSTR * EnumAndSortValues(
HKEY hKey,
DWORD cValues,
DWORD cchMaxValueName)
{
    LONG status;
    LPTSTR *ppsz;
    DWORD cch, dwType, cb;
    DWORD i;

    DPRINTF((TEXT("EnumAndSortValues(%s, %d, %d)\n"),
            ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1),
            cValues,
            cchMaxValueName));

    cchMaxValueName++;
    ppsz = malloc(cValues * sizeof(LPTSTR));
    if (ppsz == NULL) {
        MEMFAILED;
        return(NULL);
    }
    for (i = 0; i < cValues; i++) {
        ppsz[i] = malloc(cchMaxValueName * sizeof(TCHAR));
        if (ppsz[i] == NULL) {
            MEMFAILED;
            FreeSortedValues(ppsz, i);
            return(NULL);
        }
        cch = cchMaxValueName;
        cb = 0;
        status = RegEnumValue(hKey, i, ppsz[i], &cch, NULL, &dwType, NULL, &cb);
        if (status != ERROR_SUCCESS) {
            if (status != ERROR_NO_MORE_ITEMS) {
                EPRINTF((TEXT("Could not enumerate value %d of %s. Error=%d.\n"),
                i, ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1), status));
            }
            FreeSortedValues(ppsz, i + 1);
            return(NULL);
        }
    }
    qsort(ppsz, cValues, sizeof(LPTSTR), mycmp);
    if (fDebug && fVerbose) {
        DPRINTF((TEXT("--Value List--\n")));
        for (i = 0; i < cValues; i++) {
            DPRINTF((TEXT("  %s\n"), ppsz[i]));
        }
    }
    return(ppsz);
}




VOID FreeSortedSubkeys(
LPTSTR *ppsz,
DWORD cSubkeys)
{
    DWORD i;

    if (cSubkeys) {
        for (i = 0; i < cSubkeys; i++) {
            free(ppsz[i]);
        }
        free(ppsz);
    }
}




LPTSTR * EnumAndSortSubkeys(
HKEY hKey,
DWORD cSubkeys,
DWORD cchMaxSubkeyName)
{
    LONG status;
    LPTSTR *ppsz;
    DWORD cch;
    FILETIME ft;
    DWORD i;

    DPRINTF((TEXT("EnumAndSortSubkeys(%s, %d, %d)\n"),
            ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1),
            cSubkeys,
            cchMaxSubkeyName));

    cchMaxSubkeyName++;     // poor APIs take different than what they give.
    ppsz = malloc(cSubkeys * sizeof(LPTSTR));
    if (ppsz == NULL) {
        MEMFAILED;
        return(NULL);
    }
    for (i = 0; i < cSubkeys; i++) {
        ppsz[i] = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (ppsz[i] == NULL) {
            MEMFAILED;
            FreeSortedSubkeys(ppsz, i);
            return(NULL);
        }
        cch = cchMaxSubkeyName;
        status = RegEnumKeyEx(hKey, i, ppsz[i], &cch, NULL, NULL, NULL, &ft);
        if (status != ERROR_SUCCESS) {
            if (status != ERROR_NO_MORE_ITEMS) {
                EPRINTF((TEXT("Could not enumerate key %d of %s. Error=%d.\n"),
                i, ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1), status));
            }
            FreeSortedSubkeys(ppsz, i + 1);
            return(NULL);
        }
    }
    qsort(ppsz, cSubkeys, sizeof(LPTSTR), mycmp);
    if (fDebug && fVerbose) {
        DPRINTF((TEXT("--Subkey List--\n")));
        for (i = 0; i < cSubkeys; i++) {
            DPRINTF((TEXT("  %s\n"), ppsz[i]));
        }
    }
    return(ppsz);
}




/*
 * Recursively compares two nodes in the registry and places the added and
 * deleted differences into subnodes of the Diffkey given.
 *
 * Additions go into hRootDiffKey\pszAddKey\<pszSubkeyName1>
 * Deletions go into hRootDiffKey\pszDelKey\<pszSubkeyName1>
 */
BOOL DiffNodes(
HKEY hKeyRoot,
LPTSTR pszSubkeyName1,  // Key BEFORE changes (modified name)
LPTSTR pszSubkeyName2,  // Key AFTER changes (original name)
HKEY hRootDiffKey)
{
    DWORD status;
    DWORD cSubkeys1, cchMaxSubkey1, cValues1, cchMaxValueName1, cbMaxValueData1;
    DWORD cSubkeys2, cchMaxSubkey2, cValues2, cchMaxValueName2, cbMaxValueData2;
    FILETIME FileTime1, FileTime2;
    HKEY hSubkey1, hSubkey2;
    LPTSTR pszNewSubkeyName1, pszNewSubkeyName2;
    LPTSTR *apszValueName1, *apszValueName2, *apszSubkeyName1, *apszSubkeyName2;
    BOOL fRet;
    DWORD i1, i2;
    int comp;
    LPTSTR pszFullDelKey, pszFullAddKey;

    DPRINTF((TEXT("DiffNodes(%s and %s to %s.)\n"),
            ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
            ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp2),
            ReuseFullPathFromKey(hRootDiffKey, (LPCTSTR)NULL, &pszTemp3)));

    if (!GetKeyNameWithPrefix(&pszFullDelKey, hKeyRoot, pszDelKey)) {
        return(FALSE);
    }
    if (!GetKeyNameWithPrefix(&pszFullAddKey, hKeyRoot, pszAddKey)) {
Exit0:
        free(pszFullDelKey);
        return(FALSE);
    }
    /*
     * Skip it if its in the exception list
     */
    for (i1 = 0; i1 < cExceptKeys; i1++) {
        if (!_tcscmp(pszSubkeyName1, ppszExceptKeys[i1])) {
            DPRINTF((TEXT("Diff on node %s EXCEPTED.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1)));
            return(TRUE);
        }
    }
    /*
     * Open subkeys
     */
    status = LogRegOpenKey(hKeyRoot, pszSubkeyName1, &hSubkey1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s.  Error=%d\n"),
                ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
                status));
        return(FALSE);
    }
    status = LogRegOpenKey(hKeyRoot, pszSubkeyName2, &hSubkey2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s.  Error=%d\n"),
                ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp1),
                status));
        EPUTS((TEXT("Try adding this key to the exception list.\n")));
        return(FALSE);
    }
    /*
     * Enumerate subkeys
     */
    status = MyRegQueryInfoKey(hSubkey1, &cSubkeys1, &cchMaxSubkey1, &cValues1,
            &cchMaxValueName1, &cbMaxValueData1, &FileTime1);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_NO_MORE_ITEMS) {
            EPRINTF((TEXT("Could not enumerate key %s.  Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
                    status));
        }
        return(FALSE);
    }
    cchMaxSubkey1++;
    cchMaxValueName1++;
    cbMaxValueData1++;
    status = MyRegQueryInfoKey(hSubkey2, &cSubkeys2, &cchMaxSubkey2, &cValues2,
            &cchMaxValueName2, &cbMaxValueData2, &FileTime2);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_NO_MORE_ITEMS) {
            EPRINTF((TEXT("Could not enumerate key %s.  Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp1),
                    status));
        }
        return(FALSE);
    }
    cchMaxSubkey2++;
    cchMaxValueName2++;
    cbMaxValueData2++;

    /*
     * Compare subkey values
     */
    if (CompareFileTime(&FileTime1, &FileTime2)) {
        /*
         * Timestamps differ so values may be different.
         *
         * Enumerate values on nodes, sort, and compare.
         */
        if (cValues1) {
            apszValueName1 = EnumAndSortValues(hSubkey1, cValues1, cchMaxValueName1);
            if (apszValueName1 == NULL) {
Exit1:
                LogRegCloseKey(hSubkey1);
                LogRegCloseKey(hSubkey2);
                free(pszFullAddKey);
                goto Exit0;
            }
        }
        if (cValues2) {
            apszValueName2 = EnumAndSortValues(hSubkey2, cValues2, cchMaxValueName2);
            if (apszValueName2 == NULL) {
Exit2:
                FreeSortedValues(apszValueName1, cValues1);
                goto Exit1;
            }
        }
        i1 = i2 = 0;
        while (i1 < cValues1 && i2 < cValues2) {
            comp = _tcscmp(apszValueName1[i1], apszValueName2[i2]);
            if (comp < 0) {
                /*
                 * Value1 is NOT in Key2.  Add Value1 to Del Node.
                 */
                if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                        pszFullDelKey, pszSubkeyName2)) {
Exit3:
                    FreeSortedValues(apszValueName2, cValues2);
                    goto Exit2;
                }
                i1++;
            } else if (comp > 0) {
                /*
                 * Value2 is NOT in Key1,  Add Value2 to Add Node.
                 */
                if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                        pszFullAddKey, pszSubkeyName2)) {
                    goto Exit3;
                }
                i2++;
            } else {
                /*
                 * Compare data of Value1 and Value2
                 */
                if (!AreValuesEqual(hSubkey1, apszValueName1[i1],
                        hSubkey2, apszValueName2[i2])) {
                    /*
                     * Value has changed.  Add to both Add and Del nodes.
                     */
                    if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                            pszFullDelKey, pszSubkeyName2)) {
                        goto Exit3;
                    }
                    if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                            pszFullAddKey, pszSubkeyName2)) {
                        goto Exit3;
                    }
                }
                i1++;
                i2++;
            }
        }
        while (i1 < cValues1) {
            if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                    pszFullDelKey, pszSubkeyName2)) {
                goto Exit3;
            }
            i1++;
        }
        while (i2 < cValues2) {
            if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                    pszFullAddKey, pszSubkeyName2)) {
                goto Exit3;
            }
            i2++;
        }
        FreeSortedValues(apszValueName1, cValues1);
        FreeSortedValues(apszValueName2, cValues2);
    }
    /*
     * Enumerate subkeys and compare.
     */
    if (cSubkeys1) {
        apszSubkeyName1 = EnumAndSortSubkeys(hSubkey1, cSubkeys1, cchMaxSubkey1);
        if (apszSubkeyName1 == NULL) {
            goto Exit1;
        }
    }
    if (cSubkeys2) {
        apszSubkeyName2 = EnumAndSortSubkeys(hSubkey2, cSubkeys2, cchMaxSubkey2);
        if (apszSubkeyName2 == NULL) {
Exit4:
            FreeSortedSubkeys(apszSubkeyName1, cSubkeys1);
            goto Exit1;
        }
    }
    i1 = i2 = 0;
    while (i1 < cSubkeys1 && i2 < cSubkeys2) {
        comp = _tcscmp(apszSubkeyName1[i1], apszSubkeyName2[i2]);
        if (comp < 0) {
            /*
             * Subkey1 is NOT in Key2.  Add Subkey1 to Del Node.
             */
            if (!CopyKeySubkeyEx(hSubkey1, apszSubkeyName1[i1], hRootDiffKey,
                    pszFullDelKey, pszSubkeyName2)) {
Exit5:
                FreeSortedSubkeys(apszSubkeyName2, cSubkeys2);
                goto Exit4;
            }
            i1++;
        } else if (comp > 0) {
            /*
             * Subkey2 is NOT in Key1,  Add Subkey2 to Add Node.
             */
            if (!CopyKeySubkeyEx(hSubkey2, apszSubkeyName2[i2], hRootDiffKey,
                    pszFullAddKey, pszSubkeyName2)) {
                goto Exit5;
            }
            i2++;
        } else {
            /*
             * Compare subkeys of Subkey1 and Subkey2
             */
            pszNewSubkeyName1 = malloc((_tcslen(pszSubkeyName1) +
                    _tcslen(apszSubkeyName1[i1]) + 2) * sizeof(TCHAR));
            if (pszNewSubkeyName1 == NULL) {
                MEMFAILED;
                goto Exit5;
            }
            _tcscpy(pszNewSubkeyName1, pszSubkeyName1);
            _tcscat(pszNewSubkeyName1, TEXT("\\"));
            _tcscat(pszNewSubkeyName1, apszSubkeyName1[i1]);

            pszNewSubkeyName2 = malloc((_tcslen(pszSubkeyName2) +
                    _tcslen(apszSubkeyName2[i2]) + 2) * sizeof(TCHAR));
            if (pszNewSubkeyName2 == NULL) {
                MEMFAILED;
                free(pszNewSubkeyName1);
                goto Exit5;
            }
            _tcscpy(pszNewSubkeyName2, pszSubkeyName2);
            _tcscat(pszNewSubkeyName2, TEXT("\\"));
            _tcscat(pszNewSubkeyName2, apszSubkeyName2[i2]);

            fRet = DiffNodes(hKeyRoot, pszNewSubkeyName1, pszNewSubkeyName2,
                    hRootDiffKey);

            free(pszNewSubkeyName1);
            free(pszNewSubkeyName2);
            if (fRet == FALSE) {
                goto Exit5;
            }
            i1++;
            i2++;
        }
    }
    while (i1 < cSubkeys1) {
        if (!CopyKeySubkeyEx(hSubkey1, apszSubkeyName1[i1], hRootDiffKey,
                pszFullDelKey, pszSubkeyName2)) {
            goto Exit5;
        }
        i1++;
    }
    while (i2 < cSubkeys2) {
        if (!CopyKeySubkeyEx(hSubkey2, apszSubkeyName2[i2], hRootDiffKey,
                pszFullAddKey, pszSubkeyName2)) {
            goto Exit5;
        }
        i2++;
    }
    FreeSortedSubkeys(apszSubkeyName1, cSubkeys1);
    FreeSortedSubkeys(apszSubkeyName2, cSubkeys2);

    LogRegCloseKey(hSubkey1);
    LogRegCloseKey(hSubkey2);
    free(pszFullAddKey);
    free(pszFullDelKey);
    return(TRUE);
}



/*
 * Removes a key and all its subkeys from the registry.  Returns fSuccess.
 */
BOOL DeleteKeyNode(
HKEY hKey,
LPCTSTR lpszSubkey)
{
    LONG status;
    HKEY hSubkey;
    DWORD cSubkeys;
    DWORD cchMaxSubkey;
    DWORD i;
    LPTSTR *apszSubkeyNames;

    if (fDebug) {
        DPRINTF((TEXT("DeleteKeyNode(%s)\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1)));
    }

    /*
     * First, just try to delete it.  We might just be lucky!
     */
    status = RegDeleteKey(hKey, lpszSubkey);
    if (status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND) {
        return(TRUE);
    }

    /*
     * Ok ok, so we weren't lucky.
     */
    status = LogRegOpenKey(hKey, lpszSubkey, &hSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s for deletion. Error=%d\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
        return(FALSE);
    }
    status = MyRegQueryInfoKey(hSubkey, &cSubkeys, &cchMaxSubkey, NULL, NULL,
            NULL, NULL);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get info on key %s for deletion. Error=%d\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
Exit1:
        LogRegCloseKey(hSubkey);
        return(FALSE);
    }
    cchMaxSubkey++;

    apszSubkeyNames = EnumAndSortSubkeys(hSubkey, cSubkeys, cchMaxSubkey);
    if (apszSubkeyNames == NULL) {
        EPRINTF((TEXT("Could not enumerate key %s for deletion.\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1)));
        goto Exit1;
    }
    for (i = 0; i < cSubkeys; i++) {
        DeleteKeyNode(hSubkey, apszSubkeyNames[i]);
    }
    FreeSortedSubkeys(apszSubkeyNames, cSubkeys);

    LogRegCloseKey(hSubkey);
    /*
     * Ok, the key no longer has subkeys so we should be able to delete it now.
     */
    status = RegDeleteKey(hKey, lpszSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not delete key %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
        return(FALSE);
    }
    return(TRUE);
}


LONG MyRegLoadKey(
HKEY hKey,
LPCTSTR pszSubkey,
LPCSTR pszFile)
{
    LONG status;
#ifdef UNICODE
    LPWSTR pszWBuf;

    pszWBuf = malloc((strlen(pszFile) + 1) * sizeof(WCHAR));
    if (pszWBuf != NULL) {
        _stprintf(pszWBuf, TEXT("%hs"), pszFile);
        status = RegLoadKey(hKey, pszSubkey, pszWBuf);
        free(pszWBuf);
    } else {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
#else
    status = RegLoadKey(hKey, pszSubkey, pszFile);
#endif // UNICODE
    return(status);
}




BOOL DiffHive(
LPSTR pszSnapFileIn)
{
    FILE *hfIn, *hfOut;
    LPTSTR pszSubkeyName;
    LPVOID pBuf;
    DWORD cb, i;
    LONG status;
    HKEY hKeyRoot, hKeyDiffRoot;

    DPRINTF((TEXT("DiffHive(%hs)\n"),
            pszSnapFileIn));

    /*
     * remove any diff info laying around in the registry.
     */
    RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);
    DeleteKeyNode(HKEY_LOCAL_MACHINE, pszDiffRoot);
    /*
     * Load an empty file to create the regdiff key off of the
     * HKEY_LOCAL_MACHINE root key.
     * (a hack that should not be necessary!)
     */
    DeleteFileA(pszDummyFile);
    status = MyRegLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot, pszDummyFile);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Unable to load %s\\%s from %hs.\n"),
                pszHKEY_LOCAL_MACHINE, pszDiffRoot, pszDummyFile));
        return(FALSE);
    }

    /*
     * Open snapshot file
     */
    hfIn = fopen(pszSnapFileIn, "rb");
    if (hfIn == NULL) {
        EPRINTF((TEXT("Could not open %hs.\n"), pszSnapFileIn));
        return(FALSE);
    }

    /*
     * for each section...
     */
    DeleteFileA(pszTempFile);   // RegSaveKey will fail if this exists.
    while(fread(&cb, 1, sizeof(DWORD), hfIn) == sizeof(DWORD) && !ferror(hfIn)) {
        /*
         * alocate a buffer for full key name.
         */
        pszSubkeyName = malloc(cb);
        if (pszSubkeyName == NULL) {
            MEMFAILED;
Exit4:
            fclose(hfIn);
            return(FALSE);
        }

        /*
         * read full key name
         */
        if (fread(pszSubkeyName, 1, cb, hfIn) != cb || ferror(hfIn)) {
            EPUTS((TEXT("Read failure. [key name.]\n")));
Exit6:
            free(pszSubkeyName);
            goto Exit4;
        }

        /*
         * read root key handle
         */
        if (fread(&hKeyRoot, 1, sizeof(HKEY), hfIn) != sizeof(HKEY) || ferror(hfIn)) {
            EPUTS((TEXT("Read failure. [Root key handle.]\n")));
            goto Exit6;
        }

        /*
         * Find out if pszSubkeyName is covered by our include key list.
         * If so, do a diff on it.
         */
        if (IsKeyWithinNodeList(hKeyRoot, pszSubkeyName, ppszIncludeKeys,
                cIncludeKeys, afIncludeKeyMarks)) {
            /*
             * read sizeof key data
             */
            if (fread(&cb, 1, sizeof(DWORD), hfIn) != sizeof(DWORD) || ferror(hfIn)) {
                EPUTS((TEXT("Read failure. [key data length.]\n")));
                goto Exit6;
            }
            /*
             * Allocate key data buffer
             */
            pBuf = malloc(cb);
            if (pBuf == NULL) {
                MEMFAILED;
                goto Exit6;
            }
            /*
             * Read key data
             */
            if (fread(pBuf, 1, cb, hfIn) != cb || ferror(hfIn)) {
                EPUTS((TEXT("Read failure. [key data.]\n")));
Exit7:
                free(pBuf);
                goto Exit6;
            }
            /*
             * Create temp file.
             */
            hfOut = fopen(pszTempFile, "wb");
            if (hfOut == NULL) {
                EPRINTF((TEXT("File open error. [temp file %hs.]\n"),
                        pszTempFile));
                goto Exit7;
            }
            /*
             * Write data to temp file
             */
            if (fwrite(pBuf, 1, cb, hfOut) != cb || ferror(hfOut)) {
                EPUTS((TEXT("Write failure. [temp file data.]\n")));
Exit8:
                fclose(hfOut);
                goto Exit7;
            }
            /*
             * close temp file
             */
            fclose(hfOut);

            /*
             * load temp file into registry.
             */
            VPRINTF((TEXT("  Loading key %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            status = MyRegLoadKey(hKeyRoot, pszSnapshotSubkeyName, pszTempFile);
            if (status != ERROR_SUCCESS) {
                EPRINTF((TEXT("Could not load key %s from %hs. Error=%d.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                        pszTempFile, status));
                goto Exit8;
            }

            status = LogRegCreateKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKeyDiffRoot);
            if (status != ERROR_SUCCESS) {
                EPRINTF((TEXT("Could not create %s. Error=%d\n"),
                        ReuseFullPathFromKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &pszTemp1),
                        status));
Exit9:
                status = RegUnLoadKey(hKeyRoot, pszSnapshotSubkeyName);
                if (status != ERROR_SUCCESS) {
                    EPRINTF((TEXT("  Unloading key %s, Error=%d.\n"),
                            ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                            status));
                }
                goto Exit8;
            }
            /*
             * Compare nodes and put differences into add and delete keys
             */

            VPRINTF((TEXT("  Diffing node %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            if (!DiffNodes(hKeyRoot, pszSnapshotSubkeyName, pszSubkeyName,
                    hKeyDiffRoot)) {
                EPRINTF((TEXT("Diff on node %s failed.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
                LogRegCloseKey(hKeyDiffRoot);
//Exit10:
                goto Exit9;
            }

            LogRegCloseKey(hKeyDiffRoot);

            /*
             * unload temporary key node
             */
            VPRINTF((TEXT("  Unloading %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            status = RegUnLoadKey(hKeyRoot, pszSnapshotSubkeyName);
            if (status != ERROR_SUCCESS) {
                DPRINTF((TEXT("Unloading key %s, Error=%d.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                        status));
            }

            /*
             * free buffers
             */
            free(pBuf);
        } else {
            /*
             * skip past this snapshot node in the file.
             */
            if (fseek(hfIn, sizeof(HKEY), SEEK_CUR) == -1) {
                EPUTS((TEXT("Seek failure. [key data length.]\n")));
                goto Exit6;
            }
            /*
             * read sizeof key data
             */
            if (fread(&cb, 1, sizeof(DWORD), hfIn) != sizeof(DWORD) || ferror(hfIn)) {
                EPUTS((TEXT("Read failure. [key data length.]\n")));
                goto Exit6;
            }
            if (fseek(hfIn, cb, SEEK_CUR) == -1) {
                EPUTS((TEXT("Seek failure. [key data length.]\n")));
                goto Exit6;
            }
        }

        free(pszSubkeyName);
        /*
         * delete temp file
         */
        DeleteFileA(pszTempFile);
    }
    /*
     * Close add and delete keys.
     */
    fclose(hfIn);

    /*
     * Make sure all nodes in the include keys list were diffed.
     */
    for (i = 0; i < cIncludeKeys; i++) {
        if (afIncludeKeyMarks[i] == FALSE) {
            WPRINTF((TEXT("Node %s was not included in %hs.\nDiff may be incomplete."),
                    ppszIncludeKeys[i], pszSnapFileIn));
        }
    }
    return(TRUE);
}



/*
 * Adds values and subkeys found on hKeyInfo to hKeyTarget.
 *
 * Returns fSuccess.
 */
BOOL AddNodeInfo(
HKEY hKeyInfo,
HKEY hKeyTarget)
{
    DWORD cSubkeys = (DWORD)-1;
    DWORD cchMaxSubkeyName, cValues, cchMaxValueName;
    LPTSTR pszValueName, pszSubkeyName;
    LONG status;
    DWORD i, cch, dwType, cb;

    if (fDebug) {
        DPRINTF((TEXT("AddNodeInfo(%s, %s)\n"),
                ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1),
                ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
    }

    if (IsKeyWithinNodeList(hKeyTarget, NULL, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = MyRegQueryInfoKey(hKeyInfo, &cSubkeys, &cchMaxSubkeyName,
            &cValues, &cchMaxValueName, NULL, NULL);

    if (status == ERROR_SUCCESS) {
        cchMaxSubkeyName++;
        cchMaxValueName++;
        pszValueName = malloc(cchMaxValueName * sizeof(TCHAR));
        if (pszValueName == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        /*
         * Enumerate all the values and copy them to the target.
         */
        for (i = 0; i < cValues; i++) {
            cch = cchMaxValueName;
            cb = 0;
            status = RegEnumValue(hKeyInfo, i, pszValueName, &cch, NULL, &dwType, NULL, &cb);
            if (status == ERROR_SUCCESS) {
                if (!fSafe) {
                    status = CopyKeyValue(hKeyInfo, hKeyTarget, pszValueName);
                } else {
                    if (fDebug || fVerbose) {
                        WPRINTF((TEXT("Would have copied value \"%s\" to \"%s\".\n"),
                                ReuseFullPathFromKey(hKeyInfo, pszValueName, &pszTemp1),
                                ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
                    }
                    status = TRUE;
                }
                if (!status) {
                    EPRINTF((TEXT("Unable to copy value %s from %s to %s.\n"),
                            pszValueName,
                            ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1),
                            ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %s.\n"),
                        i + 1, ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1)));
            }
        }
        free(pszValueName);

        pszSubkeyName = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            MEMFAILED;
            return(0);
        }
        for (i = 0; i < cSubkeys; i++) {
            status = RegEnumKey(hKeyInfo, i, pszSubkeyName, cchMaxSubkeyName);
            if (status == ERROR_SUCCESS) {
                status = CopyKeySubkey(hKeyInfo, pszSubkeyName, hKeyTarget, pszSubkeyName);
                if (!status) {
                    EPRINTF((TEXT("Unable to copy subkey %s.\n"), pszSubkeyName));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %d.\n"), i + 1, cSubkeys));
            }
        }
        free(pszSubkeyName);
    }
    return(TRUE);
}



/*
 * Deletes values and leaf keys found on hKeyInfo from hKeyTarget.
 *
 * Returns:
 *  0   error
 *  1   leaf node
 *  2   nonleaf node
 */
int DelNodeInfo(
HKEY hKeyInfo,
HKEY hKeyTarget)
{
    DWORD cSubkeys, i, cch, dwType, cb;
    DWORD cchMaxSubkeyName, cValues, cchMaxValueName;
    LPTSTR pszValueName, pszSubkeyName;
    LONG status;
    int iLeafNode;

    iLeafNode = 0;

    if (fDebug) {
        LPTSTR psz1, psz2;

        psz1 = GetFullPathFromKey(hKeyInfo, NULL);
        psz2 = GetFullPathFromKey(hKeyTarget, NULL);
        DPRINTF((TEXT("DelNodeInfo(%s, %s)\n"), psz1, psz2));
        free(psz1);
        free(psz2);
    }

    if (IsKeyWithinNodeList(hKeyTarget, NULL, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"), psz));
            free(psz);
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = MyRegQueryInfoKey(hKeyInfo, &cSubkeys, &cchMaxSubkeyName,
            &cValues, &cchMaxValueName, NULL, NULL);

    if (status == ERROR_SUCCESS) {
        cchMaxSubkeyName++;
        cchMaxValueName++;
        pszValueName = malloc(cchMaxValueName * sizeof(TCHAR));
        if (pszValueName == NULL) {
            MEMFAILED;
            return(0);
        }
        /*
         * Enumerate all the values and delete them from the target.
         */
        for (i = 0; i < cValues; i++) {
            cch = cchMaxValueName;
            cb = 0;
            status = RegEnumValue(hKeyInfo, i, pszValueName, &cch, NULL, &dwType, NULL, &cb);
            if (status == ERROR_SUCCESS) {
                if (!fSafe) {
                    status = RegDeleteValue(hKeyTarget, pszValueName);
                } else {
                    if (fDebug || fVerbose) {
                        LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                        VPRINTF((TEXT("Would have deleted value \"%s\" from \"%s\".\n"),
                                pszValueName, psz));
                        free(psz);
                    }
                    status = ERROR_SUCCESS;
                }
                if (status != ERROR_SUCCESS) {
                    EPRINTF((TEXT("Unable to delete value %s.\n"), pszValueName));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %d.\n"), i + 1, cValues));
            }
        }
        free(pszValueName);

        pszSubkeyName = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            MEMFAILED;
            return(0);
        }
        /*
         * Enumerate all the subkeys and recurse.
         */
        for (i = 0; i < cSubkeys; i++) {
            status = RegEnumKey(hKeyInfo, i, pszSubkeyName, cchMaxSubkeyName);
            if (status == ERROR_SUCCESS) {
                HKEY hSubkeyInfo, hSubkeyTarget;

                status = LogRegOpenKey(hKeyInfo, pszSubkeyName, &hSubkeyInfo);
                if (status == ERROR_SUCCESS) {
                    status = LogRegOpenKey(hKeyTarget, pszSubkeyName, &hSubkeyTarget);
                    if (status == ERROR_SUCCESS) {
                        iLeafNode = DelNodeInfo(hSubkeyInfo, hSubkeyTarget);
                        LogRegCloseKey(hSubkeyTarget);
                    } else if (status == ERROR_FILE_NOT_FOUND) {
                        iLeafNode = 2;  // target is gone already.
                    } else {
                        iLeafNode = 0;  // target not accessible.
                        EPRINTF((TEXT("%s could not be deleted.\n"), pszSubkeyName));
                    }
                    LogRegCloseKey(hSubkeyInfo);
                } else {
                    iLeafNode = 0;   // somethings wrong with our info.
                }
                if (iLeafNode == 1) {
                    /*
                     * If the key is a leaf, delete it.
                     */
                    if (!fSafe) {
                        status = RegDeleteKey(hKeyTarget, pszSubkeyName);    // leaf
                        if (status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND) {
                            LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                            EPRINTF((TEXT("Could not delete key \"%s\" from \"%s\".\n"),
                                    pszSubkeyName, psz));
                            free(psz);
                        }
                    } else if (fDebug || fVerbose) {
                        LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                        VPRINTF((TEXT("Would have deleted key \"%s\" from \"%s\"\n"),
                                pszSubkeyName, psz));
                        free(psz);
                    }
                } else if (iLeafNode == 0) {
                    /*
                     * propigate errors upline.
                     */
                    free(pszSubkeyName);
                    return(0);
                }
            }
        }
        free(pszSubkeyName);
        /*
         * Now reenumerate the TARGET key to find out if its now a leaf.
         */
        MyRegQueryInfoKey(hKeyTarget, &cSubkeys, NULL, &cValues,
                NULL, NULL, NULL);

        if (cSubkeys == 0 && cValues == 0) {
            iLeafNode = 1;
        } else {
            iLeafNode = 2;
        }
    }
    return(iLeafNode);
}


/*
 * The DiffRoot contains subkeys of the form:
 *  diffroot\add\canonicalkeyname
 *  diffroot\del\canonicalkeyname
 *
 * The pszAddKey and pszDelKey allow this function to work in reverse.
 *
 * returns fSuccess.
 */
BOOL MergeHive(
LPTSTR pszAddName,
LPTSTR pszDelName)
{
    LONG status;
    HKEY hKeyDiffRoot, hKeyRoot, hKey;

    DPRINTF((TEXT("MergeHive(%s, %s)\n"),
            pszAddName, pszDelName));

    status = LogRegOpenKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKeyDiffRoot);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_FILE_NOT_FOUND) {
            EPRINTF((TEXT("Could not open key KEY_LOCAL_MACHINE\\%s.  Error=%d.\n"),
                    pszDiffRoot, status));
        } else {
            VPRINTF((TEXT("No diff information found.\n")));
        }
        return(FALSE);
    }

    status = LogRegOpenKey(hKeyDiffRoot, pszDelName, &hKeyRoot);
    if (status == ERROR_SUCCESS) {
        status = LogRegOpenKey(hKeyRoot, pszHKEY_LOCAL_MACHINE, &hKey);
        if (status == ERROR_SUCCESS) {
            DelNodeInfo(hKey, HKEY_LOCAL_MACHINE);
            LogRegCloseKey(hKey);
        }
        status = LogRegOpenKey(hKeyRoot, pszHKEY_USERS, &hKey);
        if (status == ERROR_SUCCESS) {
            DelNodeInfo(hKey, HKEY_USERS);
            LogRegCloseKey(hKey);
        }
        LogRegCloseKey(hKeyRoot);
    }

    status = LogRegOpenKey(hKeyDiffRoot, pszAddName, &hKeyRoot);
    if (status == ERROR_SUCCESS) {
        status = LogRegOpenKey(hKeyRoot, pszHKEY_LOCAL_MACHINE, &hKey);
        if (status == ERROR_SUCCESS) {
            AddNodeInfo(hKey, HKEY_LOCAL_MACHINE);
            LogRegCloseKey(hKey);
        }
        status = LogRegOpenKey(hKeyRoot, pszHKEY_USERS, &hKey);
        if (status == ERROR_SUCCESS) {
            AddNodeInfo(hKey, HKEY_USERS);
            LogRegCloseKey(hKey);
        }
        LogRegCloseKey(hKeyRoot);
    }

    LogRegCloseKey(hKeyDiffRoot);
    return(TRUE);
}




BOOL ReadNodeListFile(
LPSTR pszFile,
LPTSTR **papszNodeList,
DWORD *pcNodes,
BOOL **pafNodeMarks)
{
    FILE *hfIn;
    TCHAR szBuf[MAX_PATH];
    LPTSTR pszEOL, pszRootkey, pszSubkey;
    HKEY hKeyRoot;
    BOOL fFree;

    DPRINTF((TEXT("ReadNodeListFile(%hs)\n"), pszFile));

    *pcNodes = 0;
    if (pafNodeMarks != NULL) {
        *pafNodeMarks = NULL;
    }
    *papszNodeList = NULL;

    hfIn = fopen(pszFile, "r");
    if (hfIn == NULL) {
        EPRINTF((TEXT("Could not read %hs.\n"), pszFile));
        return(FALSE);
    }
    while (!feof(hfIn)) {
        if (fgets((char *)szBuf, MAX_PATH * sizeof(TCHAR), hfIn) == NULL) {
            break;
        }
#ifdef UNICODE
        {
            WCHAR szwBuf[MAX_PATH];

            _stprintf(szwBuf, TEXT("%hs"), (LPSTR)szBuf);
            _tcscpy(szBuf, szwBuf);
        }
#endif
        pszEOL = _tcsrchr(szBuf, TEXT('\n'));
        if (pszEOL == NULL) {
            EPRINTF((TEXT("Line too long in %hs.\n"), pszFile));
            return(FALSE);
        }
        *pszEOL = TEXT('\0');
        if (!KeyPartsFromNodeName(szBuf, &pszRootkey, &pszSubkey, &hKeyRoot, &fFree)) {
            EPRINTF((TEXT("Invalid path %s in %hs.\n"), szBuf, pszFile));
            if (fFree) {
                free(pszSubkey);
            }
            return(FALSE);
        }
        if (*pcNodes == 0) {
            *papszNodeList = malloc(sizeof(LPTSTR));
            if (*papszNodeList == NULL) {
                MEMFAILED;
                return(FALSE);
            }
        } else {
            void *pv = realloc(*papszNodeList, sizeof(LPTSTR) * ((*pcNodes) + 1));
            if (!pv) {
                MEMFAILED;
                return (FALSE);
            } else {
                *papszNodeList = pv;
            }
        }
        (*papszNodeList)[*pcNodes] = malloc((_tcslen(pszRootkey) +
                _tcslen(pszSubkey) + 2) * sizeof(TCHAR));
        if ((*papszNodeList)[*pcNodes] == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy((*papszNodeList)[*pcNodes], pszRootkey);
        _tcscat((*papszNodeList)[*pcNodes], TEXT("\\"));
        _tcscat((*papszNodeList)[*pcNodes], pszSubkey);
        DPRINTF((TEXT("Read in %s\n"), (*papszNodeList)[*pcNodes]));
        (*pcNodes)++;
        if (fFree) {
            free(pszSubkey);
        }
    }

    fclose(hfIn);
    if (pafNodeMarks != NULL) {
        *pafNodeMarks = malloc(sizeof(BOOL) * (*pcNodes));
        if (*pafNodeMarks == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        /*
         * Set all NodeMarks to FALSE.
         */
        memset(*pafNodeMarks, 0, sizeof(BOOL) * (*pcNodes));
    }
    return((*pcNodes) != 0);
}




__cdecl CDECL main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD i;

    if (argc == 1) {
        PrintUsage();
        return(1);
    }

    /*
     * find out what the nodename is for the current user (current SID text form)
     * so we can snapshot the current user the same way we do other root nodes.
     */
    pszCurUserSID = GetCurUserSidString();
    if (pszCurUserSID == NULL) {
        EPUTS((TEXT("Could not get current user SID.\n")));
        return(1);
    }
    DPRINTF((TEXT("Current user Sid:%s\n"), pszCurUserSID));
    /*
     * Set up pszHKEY_CURRENT_USER_Real
     */
    pszHKEY_CURRENT_USER_Real = malloc((_tcslen(pszHKEY_USERS) + 1 +
            _tcslen(pszCurUserSID) + 1) * sizeof(TCHAR));
    if (pszHKEY_CURRENT_USER_Real == NULL) {
        MEMFAILED;
        return(1);
    }
    _tcscpy(pszHKEY_CURRENT_USER_Real, pszHKEY_USERS);
    _tcscat(pszHKEY_CURRENT_USER_Real, TEXT("\\"));
    _tcscat(pszHKEY_CURRENT_USER_Real, pszCurUserSID);

    while (++argv && *argv != NULL) {
        if (*argv[0] == TEXT('-') || *argv[0] == TEXT('/')) {
            switch ((*argv)[1]) {
            case TEXT('s'):
            case TEXT('S'):
                fSnap = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszSnapFileOut = *argv;
                break;

            case TEXT('d'):
            case TEXT('D'):
                fDiff = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszSnapFileIn = *argv;
                break;

            case TEXT('l'):
            case TEXT('L'):
                fLoadDiffInfo = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszDiffFileIn = *argv;
                break;

            case TEXT('w'):
            case TEXT('W'):
                fWriteDiffInfo = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszDiffFileOut = *argv;
                break;

            case TEXT('e'):
            case TEXT('E'):
                fEraseInputFileWhenDone = TRUE;
                break;

            case TEXT('m'):
            case TEXT('M'):
                fMerge = TRUE;
                break;

            case TEXT('b'):
            case TEXT('B'):
                fBreak = TRUE;
                break;

            case TEXT('u'):
            case TEXT('U'):
                fUnmerge = TRUE;
                break;

            case TEXT('r'):
            case TEXT('R'):
                fRemoveDiffInfo = TRUE;
                break;

            case TEXT('n'):
            case TEXT('N'):
                fSafe = TRUE;
                break;

            case TEXT('v'):
            case TEXT('V'):
                fVerbose = TRUE;
                break;

            case TEXT('x'):
            case TEXT('X'):
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                if (!ReadNodeListFile(*argv, &ppszExceptKeys,
                        &cExceptKeys, NULL)) {
                    PrintUsage();
                    return(1);
                }
                fExclusionListSpecified = TRUE;
                break;

            case TEXT('i'):
            case TEXT('I'):
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                if (!ReadNodeListFile(*argv, &ppszIncludeKeys,
                        &cIncludeKeys, &pfIncludeKeyMarks)) {
                    PrintUsage();
                    return(1);
                }
                fInclusionListSpecified = TRUE;
                break;

            case TEXT('@'):
                fDebug = TRUE;
                break;

            default:
                PrintUsage();
                return(1);
            }
        } else {
            PrintUsage();
            return(1);
        }
    }

    DPRINTF((TEXT("fEraseInputFileWhenDone = %d\n"), fEraseInputFileWhenDone));
    DPRINTF((TEXT("fSnap = %d\n"), fSnap));
    DPRINTF((TEXT("fDiff = %d\n"), fDiff));
    DPRINTF((TEXT("fMerge = %d\n"), fMerge));
    DPRINTF((TEXT("fUnmerge = %d\n"), fUnmerge));
    DPRINTF((TEXT("fRemoveDiffInfo = %d\n"), fRemoveDiffInfo));
    DPRINTF((TEXT("fWriteDiffInfo = %d\n"), fWriteDiffInfo));
    DPRINTF((TEXT("fDebug = %d\n"), fDebug));
    DPRINTF((TEXT("fVerbose = %d\n"), fVerbose));
    DPRINTF((TEXT("fBreak = %d\n"), fBreak));

    if (pszSnapFileIn != NULL) {
        DPRINTF((TEXT("pszSnapFileIn = %hs\n"), pszSnapFileIn));
    }
    if (pszSnapFileOut != NULL) {
        DPRINTF((TEXT("pszSnapFileOut = %hs\n"), pszSnapFileOut));
    }
    if (pszDiffFileIn != NULL) {
        DPRINTF((TEXT("pszDiffFileIn = %hs\n"), pszDiffFileIn));
    }
    if (pszDiffFileOut != NULL) {
        DPRINTF((TEXT("pszDiffFileOut = %hs\n"), pszDiffFileOut));
    }

    /*
     * The registry APIs need us to get Backup and Restore privileges
     * to work correctly.
     */
    if (!EnablePrivilege(SE_BACKUP_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_BACKUP_NAME));
        return(0);
    }
    if (!EnablePrivilege(SE_RESTORE_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_RESTORE_NAME));
        return(0);
    }
#if 0   // other privileges that regedit has we may need.
    if (!EnablePrivilege(SE_CHANGE_NOTIFY_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_CHANGE_NOTIFY_NAME));
        return(0);
    }
    if (!EnablePrivilege(SE_SECURITY_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_SECURITY_NAME));
        return(0);
    }
#endif // 0

    /*
     * Normalize our inlcude and exception lists before we start.
     */
    for (i = 0; i < cExceptKeys; i++) {
        apszExceptKeys[i] = NormalizePathName(ppszExceptKeys[i], NULL);
    }
    for (i = 0; i < cIncludeKeys; i++) {
        apszIncludeKeys[i] = NormalizePathName(ppszIncludeKeys[i], NULL);
    }
    /*
     * Let the debug dudes see the lists.
     */
    if (fDebug) {
        _tprintf(TEXT("\nUsing normalized inclusion list:\n"));
        for (i = 0; i < cIncludeKeys; i++) {
            _tprintf(TEXT("  %s\n"), ppszIncludeKeys[i]);
        }
        _tprintf(TEXT("\nUsing normalized exclusion list:\n"));
        for (i = 0; i < cExceptKeys; i++) {
            _tprintf(TEXT("  %s\n"), ppszExceptKeys[i]);
        }
    }

    /*
     * Make sure snapshot key is unloaded - help insure
     * temp file is useable.
     */
    RegUnLoadKey(HKEY_LOCAL_MACHINE, pszSnapshotSubkeyName);
    RegUnLoadKey(HKEY_USERS, pszSnapshotSubkeyName);

    if (fVerbose) {
        if (fInclusionListSpecified) {
            _tprintf(TEXT("Using inclusion list:\n"));
            for (i = 0; i < cIncludeKeys; i++) {
                _tprintf(TEXT("  %s\n"), ppszIncludeKeys[i]);
            }
            _tprintf(TEXT("\n"));
        }
        if (fExclusionListSpecified) {
            _tprintf(TEXT("Using exception list:\n"));
            for (i = 0; i < cExceptKeys; i++) {
                _tprintf(TEXT("  %s\n"), ppszExceptKeys[i]);
            }
            _tprintf(TEXT("\n"));
        }
    }
    if (fSnap) {
        VPRINTF((TEXT("Snapping registry.\n")));
        SnapHives(pszSnapFileOut);
        _tprintf(TEXT("\n"));
    }
    if (fDiff) {
        VPRINTF((TEXT("Diffing current registry with %hs.\n"), pszSnapFileIn));
        DiffHive(pszSnapFileIn);
        _tprintf(TEXT("\n"));
    } else if (fLoadDiffInfo) {
        LONG status;

        RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);   // incase a dummy is loaded
        VPRINTF((TEXT("Loading diff info from %hs.\n"), pszDiffFileIn));
        status = MyRegLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot, pszDiffFileIn);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not load key %s. Error=%d.\n"), pszDiffRoot, status));
            return(0);
        }
        _tprintf(TEXT("\n"));
    }
    if (fLoadDiffInfo && fDiff) {
        WPRINTF((TEXT("Ignoring -l flag.  Diff info was already created by diff operation.\n")));
    }
    if (fMerge) {
        VPRINTF((TEXT("Mergeing diff info into current registry.\n")));
        MergeHive(pszAddKey, pszDelKey);
        _tprintf(TEXT("\n"));
    }
    if (fUnmerge) {
        VPRINTF((TEXT("Unmergeing diff info from current registry.\n")));
        MergeHive(pszDelKey, pszAddKey);
        _tprintf(TEXT("\n"));
    }
    if (fWriteDiffInfo) {
        HKEY hKey;
        LONG status;

        DeleteFileA(pszDiffFileOut);     // cannot already exist.
        VPRINTF((TEXT("Saving diff info to %hs.\n"), pszDiffFileOut));
        status = LogRegOpenKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKey);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not open key HKEY_LOCAL_MACHINE\\%s. Error=%d.\n"),
                    pszDiffRoot, status));
            return(0);
        }
        status = RegSaveKeyA(hKey, pszDiffFileOut, NULL);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not save key %s. Error=%d.\n"), pszDiffRoot, status));
            return(0);
        }
        LogRegCloseKey(hKey);
        _tprintf(TEXT("\n"));
    }
    if (fEraseInputFileWhenDone) {
        if (pszDiffFileIn != NULL) {
            VPRINTF((TEXT("Erasing diff info file %hs.\n"), pszDiffFileIn));
            DeleteFileA(pszDiffFileIn);
        }
        if (pszSnapFileIn != NULL) {
            VPRINTF((TEXT("Erasing snapshot file %hs.\n"), pszSnapFileIn));
            DeleteFileA(pszSnapFileIn);
        }
        _tprintf(TEXT("\n"));
    }
    if (fRemoveDiffInfo) {
        VPRINTF((TEXT("Unloading diff info from registry.\n")));
        /*
         * Don't leave loaded keys in
         */
        RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);
        _tprintf(TEXT("\n"));
    }

    DeleteSidString(pszCurUserSID);

    while (pKeyLogList != NULL) {
        EPRINTF((TEXT("Leftover open key:%x, %x, %s.\n"),
                (LONG)(LONG_PTR)pKeyLogList->hKey,
                (LONG)(LONG_PTR)pKeyLogList->hKeyParent,
                pKeyLogList->psz));
        LogRegCloseKey(pKeyLogList->hKey);
    }
    DeleteFileA(pszDummyFile);
    DeleteFileA(pszDummyFileLog);
    DeleteFileA(pszTempFile);
    DeleteFileA(pszTempFile2);
    DeleteFileA(pszTempFileLog);
    DeleteFileA(pszTempFile2Log);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regback.c ===
/*

    regback.c - registry backup program

    this program allows the user to back up active registry hives,
    while the system is running.

    basic structure:

        DoFullBackup ennumerate entries in HiveList, computes which
        ones to save and where, and calls DoSpecificBackup for each.

        Three argument case of app is just a call to DoSpecificBackup.

*/

#include "regutil.h"

#define MACH_NAME   L"machine"
#define USERS_NAME  L"users"

BOOLEAN DumpUserHive;
PWSTR DirectoryPath;
PWSTR UserHiveFileName;
PWSTR HivePath;
HKEY HiveRoot;
PWSTR HiveName;

LONG
DoFullBackup(
    PWSTR DirectoryPath,
    PWSTR UserHiveFileName
    );

LONG
DoSpecificBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    );


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    LONG Error;
    PWSTR w;

    if (!RTEnableBackupRestorePrivilege()) {
        FatalError( "Unable to enable backup/restore priviledge.", 0, 0 );
        }

    InitCommonCode( CtrlCHandler,
                    "REGBACK",
                    "directoryPath [-u | -U outputFile]",
                    "directoryPath specifies where to save the output files.\n"
                    "\n"
                    "-u specifies to dump the logged on user's profile.  Default name is\n"
                    "   username.dat  User -U with a file name to save it under a different name.\n"
                    "\n"
                    "outputFile specifies the file name to use for the user profile\n"
                    "\n"
                    "If the -m switch is specified to backup the registry of a remote machine\n"
                    "   then the directoryPath is relative to that machine.\n"
                  );

    DirectoryPath = NULL;
    UserHiveFileName = NULL;
    HivePath = NULL;
    HiveRoot = NULL;
    HiveName = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'u':
                        DumpUserHive = TRUE;
                        if (*s == 'U') {
                            if (!--argc) {
                                Usage( "Missing argument to -U switch", 0 );
                                }

                            UserHiveFileName = GetArgAsUnicode( *++argv );
                            }

                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (DirectoryPath == NULL) {
            HivePath = DirectoryPath = GetArgAsUnicode( s );
            }
        else
        if (HivePath != NULL) {
            if (HiveRoot == NULL) {
                w = GetArgAsUnicode( s );
                if (!_wcsicmp( w, MACH_NAME )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                    }
                else
                if (!_wcsicmp( w, USERS_NAME )) {
                    HiveRoot = HKEY_USERS;
                    }
                else {
                    Usage( "Invalid hive type specified (%ws)", (ULONG_PTR)w );
                    }
                }
            else
            if (HiveName == NULL) {
                HiveName = GetArgAsUnicode( s );
                }
            else {
                Usage( "Too many arguments specified.", 0 );
                }
            }
        else {
            Usage( NULL, 0 );
            }
        }

    if (DirectoryPath == NULL) {
        Usage( NULL, 0 );
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 NULL,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    if (HiveRoot == NULL) {
        Error = DoFullBackup( DirectoryPath, UserHiveFileName );
        }
    else {
        Error = DoSpecificBackup( HivePath, HiveRoot, HiveName );
        }

    RTDisconnectFromRegistry( &RegistryContext );
    return Error;
}

typedef BOOL (*PFNGETPROFILESDIRECTORYW)(LPWSTR lpProfile, LPDWORD dwSize);


LONG
DoFullBackup(
    PWSTR DirectoryPath,
    PWSTR UserHiveFileName
    )

/*++

Routine Description:

    Scan the hivelist, for each hive which has a file (i.e. not hardware)
    if the file is in the config dir (e.g. not some remote profile) call
    DoSpecificBackup to save the hive out.

Arguments:

    DirectoryPath - specifies where to write the output files.

    UserHiveFileName - optional parameter that specifies the name of the file
                       to use when saving the user profile.  If NULL, then
                       username.dat is used.

Return Value:

    0 for success, otherwise, non-zero error code.

--*/
{
    PWSTR w;
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR ConfigPath[ MAX_PATH ];
    WCHAR ProfilePath[ MAX_PATH ];
    WCHAR MyHiveName[ MAX_PATH ];
    WCHAR MyHivePath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
    DWORD dwSize;
    HANDLE hInstDll;
    PFNGETPROFILESDIRECTORYW pfnGetProfilesDirectory;


    hInstDll = LoadLibrary (TEXT("userenv.dll"));

    if (!hInstDll) {
        return (GetLastError());
    }

    pfnGetProfilesDirectory = (PFNGETPROFILESDIRECTORYW)GetProcAddress (hInstDll,
                                        "GetProfilesDirectoryW");

    if (!pfnGetProfilesDirectory) {
        FreeLibrary (hInstDll);
        return (GetLastError());
    }

    dwSize = MAX_PATH;
    if (!pfnGetProfilesDirectory(ProfilePath, &dwSize)) {
        FreeLibrary (hInstDll);
        return (GetLastError());
    }

    FreeLibrary (hInstDll);



    //
    // get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey( &RegistryContext,
                       NULL,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       0,
                       &HiveListKey
                     );

    if (Error != NO_ERROR) {
        FatalError( "Unable to open key '%ws' (%u)\n",
                    (ULONG_PTR)KeyName,
                    (ULONG)Error
                  );
        return Error;
        }

    //
    // get path data for system hive, which will allow us to compute
    // path name to config dir in form that hivelist uses.
    // (an NT internal form of path)  this is NOT the way the path to
    // the config directory should generally be computed.
    //

    ValueDataLength = sizeof( ConfigPath );
    Error = RTQueryValueKey( &RegistryContext,
                             HiveListKey,
                             L"\\Registry\\Machine\\System",
                             &ValueType,
                             &ValueDataLength,
                             ConfigPath
                            );
    if (Error != NO_ERROR) {
        FatalError( "Unable to query 'SYSTEM' hive path.", 0, Error );
        }
    w = wcsrchr( ConfigPath, L'\\' );
    if (w) {
        *w = UNICODE_NULL;
    }


    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path.  if it's file path matches ConfigPath, then save it.
    // else, print a message telling the user that it must be saved
    // manually, unless the file name is of the form ....\username\ntuser.dat
    // in which case save it as username.dat
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( MyHiveName ) / sizeof( WCHAR );
        ValueDataLength = sizeof( MyHivePath );
        Error = RTEnumerateValueKey( &RegistryContext,
                                     HiveListKey,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     MyHiveName,
                                     &ValueDataLength,
                                     MyHivePath
                                   );
        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
            }
        else
        if (Error != NO_ERROR) {
            return Error;
            }

        if (ValueType == REG_SZ && ValueDataLength > sizeof( UNICODE_NULL )) {
            //
            // there's a file, compute it's path, hive branch, etc
            //

            if (w = wcsrchr( MyHivePath, L'\\' )) {
                *w++ = UNICODE_NULL;
                }
            FileName = w;

            if (w = wcsrchr( MyHiveName, L'\\' )) {
                *w++ = UNICODE_NULL;
                }
            Name = w;

            HiveRoot = NULL;
            if (w = wcsrchr( MyHiveName, L'\\' )) {
                w += 1;
                if (!_wcsicmp( w, L"MACHINE" )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                    }
                else
                if (!_wcsicmp( w, L"USER" )) {
                    HiveRoot = HKEY_USERS;
                    }
                else {
                    Error = ERROR_PATH_NOT_FOUND;
                    }
                }

            if (FileName != NULL && Name != NULL && HiveRoot != NULL) {
                if (!wcscmp( ConfigPath, MyHivePath )) {
                    //
                    // hive's file is in config dir, we can back it up
                    // without fear of collision
                    //
                    swprintf( FilePath, L"%s\\%s", DirectoryPath, FileName );
                    Error = DoSpecificBackup( FilePath,
                                              HiveRoot,
                                              Name
                                            );
                    }
                else
                if (DumpUserHive && !_wcsnicmp( ProfilePath, MyHivePath, wcslen( ProfilePath ) )) {
                    //
                    // hive's file is in profile dir, we can back it up
                    // without fear of collision if we use username.dat
                    // for the file name.
                    //
                    if (UserHiveFileName != NULL) {
                        FileName = UserHiveFileName;
                        }
                    else {
                        FileName = wcsrchr(MyHivePath, '\\') + 1;
                        }
                    swprintf( FilePath, L"%s\\%s.dat", DirectoryPath, FileName );

                    printf( "%ws %ws %ws\n",
                            FilePath,
                            HiveRoot == HKEY_LOCAL_MACHINE ? MACH_NAME : USERS_NAME,
                            Name
                          );
                    Error = DoSpecificBackup( FilePath,
                                              HiveRoot,
                                              Name
                                            );
                    }
                else {
                    printf( "\n***Hive = '%ws'\\'%ws'\nStored in file '%ws'\\'%ws'\n",
                            MyHiveName,
                            Name,
                            MyHivePath,
                            FileName
                          );
                    printf( "Must be backed up manually\n" );
                    printf( "regback <filename you choose> %ws %ws\n\n",
                            HiveRoot == HKEY_LOCAL_MACHINE ? MACH_NAME : USERS_NAME,
                            Name
                          );
                    }
                }
            }
        }

    return Error;
}


LONG
DoSpecificBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    )
/*
    Do backup of one hive to one file.  Any valid hive and any
    valid file will do.  RegSaveKey does all the real work.

    Arguments:
        HivePath - file name to pass directly to OS

        HiveRoot - HKEY_LOCAL_MACHINE or HKEY_USERS

        HiveName - 1st level subkey under machine or users
*/
{
    HKEY HiveKey;
    ULONG Disposition;
    LONG Error;
    char *Reason;

    //
    // print some status
    //
    printf( "saving %ws to %ws", HiveName, HivePath );

    //
    // get a handle to the hive.  use special create call what will
    // use privileges
    //

    Reason = "accessing";
    Error = RTCreateKey( &RegistryContext,
                         HiveRoot,
                         HiveName,
                         KEY_READ,
                         REG_OPTION_BACKUP_RESTORE,
                         NULL,
                         &HiveKey,
                         &Disposition
                       );
    if (Error == NO_ERROR) {
        Reason = "saving";
        Error = RegSaveKey( HiveKey, HivePath, NULL );
        RTCloseKey( &RegistryContext, HiveKey );
        }

    if (Error != NO_ERROR) {
        printf( " - error %s (%u)\n", Reason, Error );
        }
    else {
        printf( "\n" );
        }
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regdir.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regdir.c

Abstract:

    Utility to display all or part of the registry directory.

    REGDIR [KeyPath]

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

--*/

#include "regutil.h"

void
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );


BOOLEAN RecurseIntoSubkeys = FALSE;


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    PWSTR RegistryPath;

    InitCommonCode( CtrlCHandler,
                    "REGDIR",
                    "[-r] registryPath",
                    "-r specifies to recurse into subdirectories\n"
                    "registryPath specifies where to start displaying.\n"
                  );

    RegistryPath = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'r':
                        RecurseIntoSubkeys = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (RegistryPath == NULL) {
            RegistryPath = GetArgAsUnicode( s );
            }
        else {
            Usage( "May only specify one registry path to display", 0 );
            }
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &RegistryPath,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    DumpKeys( RegistryContext.HiveRootHandle, RegistryPath, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        if (DebugOutput) {
            fprintf( stderr,
                     "Unable to open key '%ws' (%u)\n",
                     KeyName,
                     (ULONG)Error
                   );
            }

        return;
        }

    //
    // Print name of node we are about to dump out
    //
    printf( "%.*s%ws",
            Depth * IndentMultiple,
            "                                                                                  ",
            KeyName
          );
    RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)fprintf, stdout, KeyHandle, NULL );
    printf( "\n" );

    //
    // Print out node's values
    //
    if (Depth != 1 || RecurseIntoSubkeys) {
        DumpValues( KeyHandle, KeyName, Depth + 1 );
        }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    if (Depth == 0 || RecurseIntoSubkeys) {
        for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
            SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
            Error = RTEnumerateKey( &RegistryContext,
                                    KeyHandle,
                                    SubKeyIndex,
                                    &LastWriteTime,
                                    &SubKeyNameLength,
                                    SubKeyName
                                  );

            if (Error != NO_ERROR) {
                if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                    fprintf( stderr,
                             "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                             KeyName,
                             Error
                           );
                    }

                break;
                }

            DumpKeys( KeyHandle, SubKeyName, Depth + 1 );
            }
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}

void
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {
            RTFormatKeyValue( OutputWidth,
                              (PREG_OUTPUT_ROUTINE)fprintf,
                              stdout,
                              TRUE,
                              Depth * IndentMultiple,
                              ValueName,
                              ValueDataLength,
                              ValueType,
                              OldValueBuffer
                            );
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            return;
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regdmp.c

Abstract:

    Utility to display all or part of the registry in a format that
    is suitable for input to the REGINI program.

    REGDMP [KeyPath]

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Handles all value types (e.g. REG_???) defined in ntregapi.h

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

--*/

#include "regutil.h"

BOOL
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    PWSTR FullPath,
    ULONG Depth
    );

BOOLEAN SummaryOutput;

BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    PWSTR RegistryPath;

    InitCommonCode( CtrlCHandler,
                    "REGDMP",
                    "[-s] [-o outputWidth] registryPath",
                    "-s specifies summary output.  Value names, type and first line of data\n"
                    "\n"
                    "registryPath specifies where to start dumping.\n"
                    "\n"
                    "If REGDMP detects any REG_SZ or REG_EXPAND_SZ that is missing the\n"
                    "trailing null character, it will prefix the value string with the\n"
                    "following text: (*** MISSING TRAILING NULL CHARACTER ***)\n"
                    "The REGFIND tool can be used to clean these up, as this is a common\n"
                    "programming error.\n"
                  );

    RegistryPath = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'f':
                        FullPathOutput = TRUE;
                        break;

                    case 's':
                        SummaryOutput = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (RegistryPath == NULL) {
            RegistryPath = GetArgAsUnicode( s );
            }
        else {
            Usage( "May only specify one registry path to dump", 0 );
            }
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &RegistryPath,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    DumpKeys( RegistryContext.HiveRootHandle, RegistryPath, RegistryPath, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    PWSTR FullPath,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    WCHAR ComputeFullPath[ MAX_PATH ];
    FILETIME LastWriteTime;
    BOOL AnyValues;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        return;
        }

    //
    // Print name of node we are about to dump out
    //

    if (!FullPathOutput) {

        RTFormatKeyName( (PREG_OUTPUT_ROUTINE)fprintf, stdout, Depth * IndentMultiple, KeyName );
        RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)fprintf, stdout, KeyHandle, NULL );
        printf( "\n" );
        }

    //
    // Print out node's values
    //
    if (FullPathOutput)
        AnyValues = DumpValues( KeyHandle, FullPath, 0 );
    else
        DumpValues( KeyHandle, KeyName, Depth + 1 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( &RegistryContext,
                                KeyHandle,
                                SubKeyIndex,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error != NO_ERROR) {
            if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                fprintf( stderr,
                         "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                         KeyName,
                         Error
                       );
                }

            break;
            }

        if (FullPathOutput) {

            wcscpy(ComputeFullPath, FullPath);
            wcscat(ComputeFullPath, L"\\");
            wcscat(ComputeFullPath, SubKeyName);
            }

        DumpKeys( KeyHandle, SubKeyName, ComputeFullPath, Depth + 1 );
        }

    if (FullPathOutput) {
        if (SubKeyIndex == 0) {
            if (!AnyValues) {
                fprintf(stdout, "%ws\n", FullPath );
                }
            }
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}

BOOL
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {

            if (FullPathOutput) {
                fprintf(stdout, "%ws -> ", KeyName );
                }

            RTFormatKeyValue( OutputWidth,
                              (PREG_OUTPUT_ROUTINE)fprintf,
                              stdout,
                              SummaryOutput,
                              Depth * IndentMultiple,
                              ValueName,
                              ValueDataLength,
                              ValueType,
                              OldValueBuffer
                            );
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            if (ValueIndex == 0) {
                return FALSE;
                }
            else {
                return TRUE;
                }
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return FALSE;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regfind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regfind.c

Abstract:

    Utility to search all or part of the registry for a particular
    string value.  The search string is a literal, the format of which
    depends upon the data type.

    REGFIND [-p KeyPath] [-n | -t DataType] searchString

    Will ennumerate and all the subkeys and values of KeyPath,
    applying itself recursively to each subkey it finds.  For each
    value find that is of the appropriate type, it will search the
    value for a match.  If found, it will print out the path and data
    of the value. The -n flag tells the program to search the names
    of keys and values for searchString and print out any that contain
    the searchString.

    Default KeyPath if none specified is \Registry

    Default DataType is any of the _SZ registry data types (REG_SZ,
    REG_EXPAND_SZ or REG_MULTI_SZ).

Author:

    Steve Wood (stevewo)  08-Nov-95

Revision History:

--*/

#include "regutil.h"

void
SearchValues(
    PWSTR KeyName,
    HKEY KeyHandle,
    ULONG Depth
    );

void
SearchKeys(
    PWSTR KeyName,
    HKEY ParentKeyHandle,
    ULONG Depth
    );


BOOLEAN IgnoreCase;
BOOLEAN SearchKeyAndValueNames;
BOOLEAN IncludeBinaryDataInTextSearch;
BOOLEAN LookForAnsiInBinaryData;
BOOLEAN SearchingForMatchOnDataLength;
ULONG SearchValueType;
BOOLEAN ReplaceSZwithEXPAND_SZ;
BOOLEAN SearchForMissingNULLs;
BOOLEAN FixupMissingNULLs;

#define REG_ANY_SZ  12

typedef struct _VALUE_BUFFER {
    PVOID Base;
    ULONG Length;
    ULONG MaximumLength;
    PWSTR CurrentDest;
} VALUE_BUFFER, *PVALUE_BUFFER;


PVALUE_BUFFER SearchBuffer;
PVOID SearchData;
ULONG SearchDataLength;
WCHAR SearchData1UpperCase[ 2 ];
LPSTR SearchDataAnsi;
ULONG SearchDataAnsiLength;
UCHAR SearchDataAnsi1UpperCase[ 2 ];

PVALUE_BUFFER ReplacementBuffer;
PVOID ReplacementData;
ULONG ReplacementDataLength;
LPSTR ReplacementDataAnsi;
ULONG ReplacementDataAnsiLength;

BOOLEAN
AppendToValueBuffer(
    PVALUE_BUFFER p,
    PWSTR s
    )
{
    ULONG n, cb;

    n = wcslen( s );
    cb = n * sizeof( WCHAR );

    if ((cb + p->Length + sizeof( WCHAR )) >= p->MaximumLength) {
        return FALSE;
        }

    if (p->Length != 0) {
        *(p->CurrentDest)++ = L' ';
        p->Length += 1;
        }

    memcpy( p->CurrentDest, s, cb );
    p->Length += cb;
    p->CurrentDest += n;
    return TRUE;
}


PVALUE_BUFFER
AllocateValueBuffer(
    ULONG MaximumLength,
    PWSTR InitialContents
    )
{
    PVALUE_BUFFER p;

    p = (PVALUE_BUFFER)VirtualAlloc( NULL, MaximumLength, MEM_COMMIT, PAGE_READWRITE );
    if (p != NULL) {
        p->Base = (p+1);
        p->MaximumLength = MaximumLength;
        p->Length = 0;
        p->CurrentDest = (PWSTR)p->Base;
        if (InitialContents != NULL) {
            AppendToValueBuffer( p, InitialContents );
            }
        }

    return p;
}


PVOID
ApplyReplacementBuffer(
    IN OUT PULONG ValueDataLength,
    IN PVOID Match,
    OUT PBOOLEAN BufferOverflow
    )
{
    ULONG LengthBeforeMatch;
    LONG DeltaLength;

    if (ReplacementBuffer == NULL) {
        return NULL;
        }

    LengthBeforeMatch = (ULONG)((PCHAR)Match - (PCHAR)OldValueBuffer);
    DeltaLength = ReplacementDataLength - SearchDataLength;
    if (DeltaLength <= 0) {
        memcpy( Match, ReplacementData, ReplacementDataLength );
        Match = (PCHAR)Match + ReplacementDataLength;
        if (DeltaLength < 0) {
            memcpy( Match,
                    (PCHAR)Match - DeltaLength,
                    *ValueDataLength - LengthBeforeMatch - ReplacementDataLength
                  );
            }
        }
    else {
        if (*ValueDataLength + DeltaLength > OldValueBufferSize) {
            *BufferOverflow = TRUE;
            return NULL;
            }

        memmove( (PCHAR)Match + DeltaLength,
                 Match,
                 *ValueDataLength - LengthBeforeMatch
               );
        memcpy( Match, ReplacementData, ReplacementDataLength );
        Match = (PCHAR)Match + ReplacementDataLength;
        }

    *ValueDataLength += DeltaLength;
    return Match;
}

typedef struct _KEY_INFO {
    PWSTR Name;
    BOOLEAN NameDisplayed;
} KEY_INFO, *PKEY_INFO;

#define MAX_LEVELS 256

KEY_INFO KeyPathInfo[ MAX_LEVELS ];

void
DisplayPath(
    PKEY_INFO p,
    ULONG Depth
    )
{
    ULONG i;

    for (i=0; i<Depth; i++) {
        if (!p[ i ].NameDisplayed) {
            p[ i ].NameDisplayed = TRUE;
            RTFormatKeyName( (PREG_OUTPUT_ROUTINE)fprintf, stdout, i * IndentMultiple, p[ i ].Name );
            printf( "\n" );
            }
        }
}


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}

int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char *s, *s1;
    LONG Error;
    ULONG Type;
    PWSTR KeyName;
    PWSTR SearchValueTypeString;
    REG_UNICODE_PARSE ParsedLine;


    InitCommonCode( CtrlCHandler,
                    "REGFIND",
                    "[-p RegistryKeyPath] [-z | -t DataType] [-b | -B] [-y] [-n]\n"
                    "    [searchString [-r ReplacementString]]\n",
                    "-p RegistryKeyPath specifies where to start searching\n"
                    "\n"
                    "-t specifies which registry types to look at:\n"
                    "       REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ\n"
                    "       REG_DWORD, REG_BINARY, REG_QWORD, REG_NONE\n"
                    "   Default is any of the _SZ types\n"
                    "\n"
                    "-b only valid with _SZ searches, and specifies that REGFIND should\n"
                    "   look for occurrences of the searchString inside of REG_BINARY data.\n"
                    "   May not be specified with a replacementString that is not the same length\n"
                    "   as the searchString\n"
                    "\n"
                    "-B same as -b but also looks for ANSI version of string within REG_BINARY values.\n"
                    "\n"
                    "-y only valid with _SZ searches, and specifies that REGFIND should\n"
                    "   ignore case when searching.\n"
                    "\n"
                    "-n specifies to include key and value names in the search.\n"
                    "   May not specify -n with -t\n"
                    "\n"
                    "-z specifies to search for REG_SZ and REG_EXPAND_SZ values that\n"
                    "   are missing a trailing null character and/or have a length that is\n"
                    "   not a multiple of the size of a Unicode character.  If -r is also\n"
                    "   specified then any replacement string is ignored, and REGFIND will\n"
                    "   add the missing null character and/or adjust the length up to an\n"
                    "   even multiple of the size of a Unicode character.\n"
                    "\n"
                    "searchString is the value to search for.  Use quotes if it contains\n"
                    "   any spaces.  If searchString is not specified, just searches based on type.\n"
                    "\n"
                    "-r replacementString is an optional replacement string to replace any\n"
                    "   matches with.\n"
                    "\n"
                    "searchString and replacementString must be of the same type as specified\n"
                    "to the -t switch.  For any of the _SZ types, it is just a string\n"
                    "For REG_DWORD or REG_QWORD, it is a single number (i.e. 0x1000 or 4096)\n"
                    "For REG_BINARY, it is a number specifing #bytes, optionally followed by \n"
                    "the actual bytes, with a separate number for each DWORD\n"
                    "    (e.g. 0x06 0x12345678 0x1234)\n"
                    "If just the byte count is specified, then REGFIND will search for all\n"
                    "REG_BINARY values that have that length.  May not search for length\n"
                    "and specify -r\n"
                    "\n"
                    "When doing replacements, REGFIND displays the value AFTER the replacement\n"
                    "has been.  It is usually best to run REGFIND once without the -r switch\n"
                    "to see what will be change before it is changed.\n"
                    "\n"
                  );

    IgnoreCase = FALSE;
    SearchKeyAndValueNames = FALSE;
    IncludeBinaryDataInTextSearch = FALSE;
    LookForAnsiInBinaryData = FALSE;
    SearchingForMatchOnDataLength = FALSE;
    SearchValueType = REG_ANY_SZ;
    SearchValueTypeString = NULL;
    SearchBuffer = NULL;
    ReplacementBuffer = NULL;
    ReplaceSZwithEXPAND_SZ = FALSE;

    KeyName = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'y':
                        IgnoreCase = TRUE;
                        break;

                    case 'n':
                        SearchKeyAndValueNames = TRUE;
                        break;

                    case 'z':
                        SearchForMissingNULLs = TRUE;
                        break;

                    case 'p':
                        if (!--argc) {
                            Usage( "Missing argument to -p switch", 0 );
                            }

                        KeyName = GetArgAsUnicode( *++argv );
                        break;

                    case 'b':
                        IncludeBinaryDataInTextSearch = TRUE;
                        if (*s == 'B') {
                            LookForAnsiInBinaryData = TRUE;
                            }
                        break;

                    case 't':
                        if (!--argc) {
                            Usage( "Missing argument to -t switch", 0 );
                            }

                        s1 = *++argv;
                        if (!_stricmp( s1, "REG_SZ" )) {
                            SearchValueType = REG_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_EXPAND_SZ" )) {
                            SearchValueType = REG_EXPAND_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_MULTI_SZ" )) {
                            SearchValueType = REG_MULTI_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_DWORD" )) {
                            SearchValueType = REG_DWORD;
                            SearchValueTypeString = L"REG_DWORD";
                            }
                        else
                        if (!_stricmp( s1, "REG_BINARY" )) {
                            SearchValueType = REG_BINARY;
                            SearchValueTypeString = L"REG_BINARY";
                            }
                        else
                        if (!_stricmp( s1, "REG_QWORD" )) {
                            SearchValueType = REG_QWORD;
                            SearchValueTypeString = L"REG_QWORD";
                            }
                        else
                        if (!_stricmp( s1, "REG_NONE" )) {
                            SearchValueType = REG_NONE;
                            }
                        else {
                            Usage( "Invalid argument (%s) to the -t switch\n", 
                                   (ULONG_PTR)s1 );
                            }
                        break;

                    case 'r':
                        if (SearchForMissingNULLs) {
                            FixupMissingNULLs = TRUE;
                            }
                        else {
                            if (SearchBuffer == NULL) {
                                Usage( "May not specify -r without a searchString first", 0 );
                                }

                            ReplacementBuffer = AllocateValueBuffer( 63 * 1024,
                                                                     SearchValueTypeString
                                                                   );
                            if (ReplacementBuffer == NULL) {
                                FatalError( "Unable to allocate buffer for replacement string", 0, 0 );
                                }
                            }
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                    }
                }
            }
        else {
            if (SearchBuffer == NULL) {
                SearchBuffer = AllocateValueBuffer( 63 * 1024,
                                                    SearchValueTypeString
                                                  );
                if (SearchBuffer == NULL) {
                    FatalError( "Unable to allocate buffer for search string", 0, 0 );
                    }
                }

            if (ReplacementBuffer != NULL) {
                if (!AppendToValueBuffer( ReplacementBuffer, GetArgAsUnicode( s ) )) {
                    FatalError( "replacementString too long (> %d bytes)", ReplacementBuffer->MaximumLength, 0 );
                    }
                }
            else
            if (!AppendToValueBuffer( SearchBuffer, GetArgAsUnicode( s ) )) {
                FatalError( "searchString too long (> %d bytes)", SearchBuffer->MaximumLength, 0 );
                }
            }
        }

    if (SearchKeyAndValueNames) {
        if (SearchValueType != REG_ANY_SZ) {
            Usage( "May not specify -n with -t", 0 );
            }

        if (ReplacementBuffer != NULL) {
            Usage( "May not specify -n with -r", 0 );
            }

        if (SearchForMissingNULLs) {
            Usage( "May not specify -n with -z", 0 );
            }

        }

    if ((IncludeBinaryDataInTextSearch || IgnoreCase) &&
        SearchValueType != REG_ANY_SZ &&
        SearchValueType != REG_SZ &&
        SearchValueType != REG_MULTI_SZ &&
        SearchValueType != REG_EXPAND_SZ
       ) {
        Usage( "May not specify -b or -y with -t other than _SZ types", 0 );
        }

    if (SearchForMissingNULLs) {
        if (SearchBuffer != NULL) {
            Usage( "May not specify -z with a searchString", 0 );
            }

        if (SearchValueType != REG_ANY_SZ) {
            Usage( "May not specify -z with -t", 0 );
            }

        if (IncludeBinaryDataInTextSearch) {
            Usage( "May not specify -z with -b", 0 );
            }

        if (IgnoreCase) {
            Usage( "May not specify -z with -y", 0 );
            }
        }
    else
    if (SearchBuffer == NULL && SearchValueType == REG_ANY_SZ) {
        Usage( "No search type or string specified", 0 );
        }

    if (SearchBuffer != NULL && SearchValueType == REG_NONE) {
        Usage( "May not specify a searchString when searching for REG_NONE type", 0 );
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &KeyName,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    if (SearchBuffer != NULL) {
        RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
        ParsedLine.ValueString = SearchBuffer->Base;
        if (!RTParseValueData( NULL,
                               &ParsedLine,
                               SearchBuffer->Base,
                               SearchBuffer->MaximumLength,
                               &Type,
                               &SearchData,
                               &SearchDataLength
                             )
           ) {
            if (Type == REG_BINARY &&
                SearchDataLength != 0 &&
                GetLastError() == ERROR_NO_DATA
               ) {
                if (SearchValueType != REG_BINARY) {
                    FatalError( "May only search for REG_BINARY datalength with -t REG_BINARY\n", 0, 0 );
                    }

                if (ReplacementBuffer != NULL) {
                    FatalError( "May not specify replacementString if searching for REG_BINARY datalength\n", 0, 0 );
                    }

                SearchingForMatchOnDataLength = TRUE;
                }
            else {
                FatalError( "Invalid searchString format (%u)", GetLastError(), 0 );
                }
            }

        if (Type == REG_SZ || Type == REG_EXPAND_SZ) {
            SearchDataLength -= sizeof( UNICODE_NULL );
            }

        if (SearchDataLength == 0) {
            FatalError( "Zero length search string specified", 0, 0 );
            }

        if (IgnoreCase) {
            SearchData1UpperCase[ 0 ] = *(PWSTR)SearchData;
            SearchData1UpperCase[ 1 ] = UNICODE_NULL;
            _wcsupr( SearchData1UpperCase );
            }

        if (LookForAnsiInBinaryData) {
            SearchDataAnsiLength = SearchDataLength / sizeof( WCHAR );
            SearchDataAnsi = HeapAlloc( GetProcessHeap(), 0, SearchDataAnsiLength );
            if (SearchDataAnsi == NULL) {
                FatalError( "Unable to allocate buffer for ANSI search string", 0, 0 );
                }

            if (WideCharToMultiByte( CP_ACP,
                                     0,
                                     SearchData,
                                     SearchDataAnsiLength,
                                     SearchDataAnsi,
                                     SearchDataAnsiLength,
                                     NULL,
                                     NULL
                                   ) != (LONG)SearchDataAnsiLength
               ) {
                FatalError( "Unable to get ANSI representation of search string", 0, 0 );
                }

            if (IgnoreCase) {
                SearchDataAnsi1UpperCase[ 0 ] = *SearchDataAnsi;
                SearchDataAnsi1UpperCase[ 1 ] = '\0';
                _strupr( SearchDataAnsi1UpperCase );
                }
            }
        }

    if (ReplacementBuffer != NULL) {
        RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
        ParsedLine.ValueString = ReplacementBuffer->Base;
        if (!RTParseValueData( NULL,
                               &ParsedLine,
                               ReplacementBuffer->Base,
                               ReplacementBuffer->MaximumLength,
                               &Type,
                               &ReplacementData,
                               &ReplacementDataLength
                             )
           ) {
            FatalError( "Invalid replacementString format (%u)", GetLastError(), 0 );
            }

        if (Type == REG_SZ || Type == REG_EXPAND_SZ) {
            ReplacementDataLength -= sizeof( UNICODE_NULL );
            }

        if (Type != SearchValueType &&
            (SearchValueType == REG_ANY_SZ && Type != REG_SZ) ||
            (SearchValueType == REG_SZ && Type != REG_EXPAND_SZ)
           ) {
            FatalError( "Incompatible search and replacement types", 0, 0 );
            }

        if (Type == REG_EXPAND_SZ && SearchValueType == REG_SZ) {
            ReplaceSZwithEXPAND_SZ = TRUE;
            }

        if (LookForAnsiInBinaryData) {
            ReplacementDataAnsiLength = ReplacementDataLength / sizeof( WCHAR );
            ReplacementDataAnsi = HeapAlloc( GetProcessHeap(), 0, ReplacementDataAnsiLength );
            if (ReplacementDataAnsi == NULL) {
                FatalError( "Unable to allocate buffer for ANSI replacement string", 0, 0 );
                }

            if (WideCharToMultiByte( CP_ACP,
                                     0,
                                     ReplacementData,
                                     ReplacementDataAnsiLength,
                                     ReplacementDataAnsi,
                                     ReplacementDataAnsiLength,
                                     NULL,
                                     NULL
                                   ) != (LONG)ReplacementDataAnsiLength
               ) {
                FatalError( "Unable to get ANSI representation of replacement string", 0, 0 );
                }
            }
        }

    //
    // Print name of the tree we are about to search
    //
    fprintf( stderr, "Scanning %ws registry tree\n", KeyName );
    if (SearchForMissingNULLs) {
        fprintf( stderr,
                 "Searching for any REG_SZ or REG_EXPAND_SZ value missing a trailing\n"
                 "    NULL character and/or whose length is not a multiple of the\n"
                 "    size of a Unicode character.\n"
               );
        if (FixupMissingNULLs) {
            fprintf( stderr,
                     "Will add the missing NULL whereever needed and/or adjust\n"
                     "    the length up to an even multiple of the size of a Unicode\n"
                     "    character.\n"
                   );
            }
        }
    else
    if (SearchingForMatchOnDataLength) {
        fprintf( stderr,
                 "Searching for any REG_BINARY value with a length of %08x\n",
                 SearchDataLength
               );
        }
    else {
        if (SearchBuffer == NULL) {
            fprintf( stderr, "Searching for any match based on type\n" );
            }
        else {
            fprintf( stderr,
                     "%sSearch for '%ws'\n",
                     IgnoreCase ? "Case Insensitive " : "",
                     SearchBuffer->Base
                   );
            }

        fprintf( stderr, "Will match values of type:" );
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_SZ
           ) {
            fprintf( stderr, " REG_SZ" );
            }
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_EXPAND_SZ
           ) {
            fprintf( stderr, " REG_EXPAND_SZ" );
            }
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_MULTI_SZ
           ) {
            fprintf( stderr, " REG_MULTI_SZ" );
            }
        if (SearchValueType == REG_DWORD) {
            fprintf( stderr, " REG_DWORD" );
            }
        if (SearchValueType == REG_BINARY) {
            fprintf( stderr, " REG_BINARY" );
            }
        if (SearchValueType == REG_QWORD) {
            fprintf( stderr, " REG_QWORD" );
            }
        if (SearchValueType == REG_NONE) {
            fprintf( stderr, " REG_NONE" );
            }
        fprintf( stderr, "\n" );
        if (SearchKeyAndValueNames) {
            fprintf( stderr, "Search will include key or value names\n" );
            }
        if (ReplacementBuffer != NULL) {
            fprintf( stderr, "Will replace each occurence with: '%ws'\n",
                     ReplacementBuffer->Base
                   );
            if (ReplaceSZwithEXPAND_SZ) {
                fprintf( stderr, "Also each matching REG_SZ will have its type changed to REG_EXPAND_SZ\n" );
                }
            }
        }

    SearchKeys( KeyName, RegistryContext.HiveRootHandle, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
SearchKeys(
    PWSTR KeyName,
    HKEY ParentKeyHandle,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        return;
        }

    KeyPathInfo[ Depth ].Name = KeyName;
    KeyPathInfo[ Depth ].NameDisplayed = FALSE;

    //
    // Search node's values first.
    //
    SearchValues( KeyName, KeyHandle, Depth+1 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( &RegistryContext,
                                KeyHandle,
                                SubKeyIndex,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error != NO_ERROR) {
            if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                fprintf( stderr,
                         "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                         KeyName,
                         Error
                       );
                }

            break;
            }

        SearchKeys( SubKeyName, KeyHandle, Depth+1 );
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}


void
SearchValues(
    PWSTR KeyName,
    HKEY KeyHandle,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;
    PWSTR sBegin, sEnd, s, sMatch, sMatchUpper;
    ULONG i;
    BOOLEAN AttemptMatch, MatchFound, MatchedOnType, ReplacementMade, BufferOverflow;

    if (SearchKeyAndValueNames && wcsstr( KeyName, SearchData )) {
        DisplayPath( KeyPathInfo, Depth );
        }

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {
            try {
                MatchFound = FALSE;
                ReplacementMade = FALSE;
                BufferOverflow = FALSE;
                if (SearchForMissingNULLs) {
                    if (ValueType == REG_SZ || ValueType == REG_EXPAND_SZ) {
                        if (ValueDataLength & (sizeof(WCHAR)-1)) {
                            MatchFound = TRUE;
                            }
                        else
                        if (ValueDataLength == 0 ||
                            *(PWSTR)((PCHAR)OldValueBuffer + ValueDataLength - sizeof( WCHAR )) != UNICODE_NULL
                           ) {
                            MatchFound = TRUE;
                            }

                        if (MatchFound && FixupMissingNULLs) {
                            ValueDataLength = (ValueDataLength+sizeof(WCHAR)-1) & ~(sizeof(WCHAR)-1);
                            *(PWSTR)((PCHAR)OldValueBuffer + ValueDataLength) = UNICODE_NULL;
                            ValueDataLength += sizeof( UNICODE_NULL );
                            Error = RTSetValueKey( &RegistryContext,
                                                   KeyHandle,
                                                   ValueName,
                                                   ValueType,
                                                   ValueDataLength,
                                                   OldValueBuffer
                                                 );
                            if (Error != NO_ERROR) {
                                fprintf( stderr,
                                         "REGFIND: Error setting replacement value (%u)\n",
                                         Error
                                       );
                                }
                            }
                        }
                    }
                else
                if (SearchKeyAndValueNames) {
                    MatchFound = (BOOLEAN)(wcsstr( ValueName,
                                                   SearchData
                                                 ) != NULL
                                          );
                    }
                else {
                    if (SearchValueType == REG_ANY_SZ &&
                        (ValueType == REG_SZ ||
                         ValueType == REG_EXPAND_SZ ||
                         ValueType == REG_MULTI_SZ ||
                         (ValueType == REG_BINARY && IncludeBinaryDataInTextSearch)
                        ) ||
                        SearchValueType == ValueType ||
                        (ValueType == REG_BINARY && IncludeBinaryDataInTextSearch) &&
                         (SearchValueType == REG_SZ ||
                          SearchValueType == REG_EXPAND_SZ ||
                          SearchValueType == REG_MULTI_SZ
                         )
                       ) {
                        MatchedOnType = TRUE;
                        }
                    else {
                        MatchedOnType = FALSE;
                        }

                    if (SearchBuffer == NULL) {
                        MatchFound = MatchedOnType;
                        }
                    else {
                        if (MatchedOnType && ValueDataLength != 0) {
                            if (ValueType == REG_SZ ||
                                ValueType == REG_EXPAND_SZ ||
                                ValueType == REG_MULTI_SZ
                               ) {
                                if (SearchDataLength <= ValueDataLength) {
                                    sBegin = OldValueBuffer;
                                    sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                    s = sBegin;
                                    while ((PCHAR)s + SearchDataLength < (PCHAR)sEnd) {
                                        sMatch = wcschr( s, *(PWSTR)SearchData );
                                        if (IgnoreCase) {
                                            sMatchUpper = wcschr( s, SearchData1UpperCase[ 0 ] );
                                            if (sMatch == NULL ||
                                                (sMatchUpper != NULL && sMatchUpper < sMatch)
                                               ) {
                                                sMatch = sMatchUpper;
                                                }
                                            }

                                        if (sMatch != NULL) {
                                            if ((!IgnoreCase &&
                                                 !wcsncmp( sMatch,
                                                           (PWSTR)SearchData,
                                                           SearchDataLength / sizeof( WCHAR )
                                                         )
                                                ) ||
                                                (IgnoreCase &&
                                                 !_wcsnicmp( sMatch,
                                                             (PWSTR)SearchData,
                                                             SearchDataLength / sizeof( WCHAR )
                                                           )
                                                )
                                               ) {
                                                MatchFound = TRUE;
                                                s = ApplyReplacementBuffer( &ValueDataLength,
                                                                            sMatch,
                                                                            &BufferOverflow
                                                                          );
                                                if (s == NULL) {
                                                    if (BufferOverflow) {
                                                        fprintf( stderr,
                                                                 "REGFIND: Buffer overflow doing replacement",
                                                                 Error
                                                               );
                                                        }

                                                    break;
                                                    }

                                                ReplacementMade = TRUE;
                                                sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                                }
                                            else {
                                                s = sMatch + 1;
                                                if (*s == UNICODE_NULL &&
                                                    ValueType != REG_MULTI_SZ
                                                   ) {
                                                    s += 1;
                                                    }
                                                }
                                            }
                                        else {
                                            if (ValueType != REG_MULTI_SZ) {
                                                break;
                                                }

                                            while (*s++) {
                                                }
                                            }
                                        }
                                    }
                                }
                            else
                            if (ValueType == REG_DWORD) {
                                if (*(PULONG)SearchData == *(PULONG)OldValueBuffer) {
                                    MatchFound = TRUE;
                                    }
                                }
                            else
                            if (ValueType == REG_QWORD) {
                                if (*(PDWORDLONG)SearchData == *(PDWORDLONG)OldValueBuffer) {
                                    MatchFound = TRUE;
                                    }
                                }
                            else
                            if (ValueType == REG_BINARY) {
                                if (SearchingForMatchOnDataLength) {
                                    if (ValueDataLength == SearchDataLength) {
                                        MatchFound = TRUE;
                                        }
                                    }
                                else {
                                    sBegin = OldValueBuffer;
                                    sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                    s = sBegin;
                                    while (((PCHAR)s + SearchDataLength) < (PCHAR)sEnd) {
                                        s = memchr( s,
                                                    *(PBYTE)SearchData,
                                                    (UINT)((PCHAR)sEnd - (PCHAR)s)
                                                  );
                                        if (s != NULL) {
                                            if ((ULONG)((PCHAR)sEnd - (PCHAR)s) >= SearchDataLength &&
                                                !memcmp( s, SearchData, SearchDataLength )
                                               ) {
                                                MatchFound = TRUE;
                                                s = ApplyReplacementBuffer( &ValueDataLength,
                                                                            s,
                                                                            &BufferOverflow
                                                                          );
                                                if (s == NULL) {
                                                    if (BufferOverflow) {
                                                        fprintf( stderr,
                                                                 "REGFIND: Buffer overflow doing replacement",
                                                                 Error
                                                               );
                                                        }

                                                    break;
                                                    }

                                                ReplacementMade = TRUE;
                                                sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                                }

                                            s = (PWSTR)((PCHAR)s + 1);
                                            }
                                        else {
                                            break;
                                            }
                                        }
                                    }
                                }

                            if (ReplacementMade) {
                                if (ReplaceSZwithEXPAND_SZ && ValueType == REG_SZ) {
                                    ValueType = REG_EXPAND_SZ;
                                    }

                                Error = RTSetValueKey( &RegistryContext,
                                                       KeyHandle,
                                                       ValueName,
                                                       ValueType,
                                                       ValueDataLength,
                                                       OldValueBuffer
                                                     );
                                if (Error != NO_ERROR) {
                                    fprintf( stderr,
                                             "REGFIND: Error setting replacement value (%u)\n",
                                             Error
                                           );
                                    }
                                }
                            }
                        }
                    }

                if (MatchFound) {
                    DisplayPath( KeyPathInfo, Depth );
                    RTFormatKeyValue( OutputWidth,
                                      (PREG_OUTPUT_ROUTINE)fprintf,
                                      stdout,
                                      FALSE,
                                      Depth * IndentMultiple,
                                      ValueName,
                                      ValueDataLength,
                                      ValueType,
                                      OldValueBuffer
                                    );
                    }
                }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                fprintf( stderr, "REGFIND: Access violation searching value\n" );
                }
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            return;
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "REGFIND: RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regini.c ===
#include "regutil.h"

BOOLEAN BackwardsCompatibleInput;

typedef struct _KEY_INFO {
    ULONG IndentAmount;
    PWSTR Name;
    BOOLEAN NameDisplayed;
    HANDLE Handle;
    FILETIME LastWriteTime;
} KEY_INFO, *PKEY_INFO;

#define MAX_KEY_DEPTH 64

void
DisplayPath(
    PKEY_INFO p,
    ULONG Depth,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    ULONG i;

    for (i=0; i<Depth-1; i++) {
        if (!p[ i ].NameDisplayed) {
            p[ i ].NameDisplayed = TRUE;
            RTFormatKeyName( (PREG_OUTPUT_ROUTINE)MsgFprintf, stdout, i * IndentMultiple, p[ i ].Name );
            if (i+1 == Depth-1) {
                RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)MsgFprintf,
                                     stdout,
                                     NULL,
                                     SecurityDescriptor
                                   );
                }
            MsgFprintf( stdout,"\n" );
            }
        }
}


LONG
DeleteKeyTree(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY ParentKeyHandle,
    IN PCWSTR KeyName
    )
{
    HKEY KeyHandle;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;
    LONG Error;

    Error = RTOpenKey( RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    while (Error == NO_ERROR) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( RegistryContext,
                                KeyHandle,
                                0,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error == NO_ERROR) {
            Error = DeleteKeyTree( RegistryContext, KeyHandle, SubKeyName );
            }
        }

    RTCloseKey( RegistryContext, KeyHandle );

    return RTDeleteKey( RegistryContext,
                        ParentKeyHandle,
                        KeyName
                      );
}


LONG
InitializeRegistryFromAsciiFile(
    IN PWSTR FileName
    )
{
    HKEY RootHandle;
    LONG Error, ReturnedError;
    REG_UNICODE_FILE UnicodeFile;
    REG_UNICODE_PARSE ParsedLine;
    ULONG OldValueType, OldValueLength;
    KEY_INFO KeyPath[ MAX_KEY_DEPTH ];
    PKEY_INFO CurrentKey;
    ULONG KeyPathLength;
    ULONG Disposition;
    ULONG i;
    ULONG PreviousValueIndentAmount;
    LPSTR s;

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 NULL,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        return Error;
        }
    RootHandle = RegistryContext.HiveRootHandle;

    Error = RTLoadAsciiFileAsUnicode( FileName,
                                      &UnicodeFile
                                    );
    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry( &RegistryContext );
        return Error;
        }

    RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
    UnicodeFile.BackwardsCompatibleInput = BackwardsCompatibleInput;
    PreviousValueIndentAmount = 0xFFFFFFFF;
    CurrentKey = 0;
    KeyPathLength = 0;
    ReturnedError = NO_ERROR;
    while (TRUE) {
        if (!RTParseNextLine( &UnicodeFile, &ParsedLine )) {
            if (!ParsedLine.AtEndOfFile) {
                DisplayPath( KeyPath, KeyPathLength+1, NULL );
                if (ParsedLine.IsKeyName) {
                    InputMessage( FileName,
                                  ParsedLine.LineNumber,
                                  TRUE,
                                  ParsedLine.AclString ? "Invalid key '%ws' Acl [%ws]"
                                                       : "Invalid key '%ws'",
                                  (ULONG_PTR)ParsedLine.KeyName,
                                  (ULONG_PTR)ParsedLine.AclString
                                );
                    }
                else {
                    switch( ParsedLine.ParseFailureReason ) {
                        case ParseFailValueTooLarge:
                            s = "Value too large - '%ws = %ws'";
                            break;

                        case ParseFailUnableToAccessFile:
                            s = "Unable to access file - '%ws = %ws'";
                            break;

                        case ParseFailDateTimeFormatInvalid:
                            s = "Date/time format invalid - '%ws = %ws'";
                            break;

                        case ParseFailInvalidLineContinuation:
                            s = "Invalid line continuation - '%ws = %ws'";
                            break;

                        case ParseFailInvalidQuoteCharacter:
                            s = "Invalid quote character - '%ws = %ws'";
                            break;

                        case ParseFailBinaryDataLengthMissing:
                            s = "Missing length for binary data - '%ws = %ws'";
                            break;

                        case ParseFailBinaryDataOmitted:
                        case ParseFailBinaryDataNotEnough:
                            s = "Not enough binary data for length - '%ws = %ws'";
                            break;

                        case ParseFailInvalidRegistryType:
                            s = "Invalid registry type - '%ws = %ws'";
                            break;

                        default:
                            s = "Invalid value - '%ws = %ws'";
                        }

                    InputMessage( FileName,
                                  ParsedLine.LineNumber,
                                  TRUE,
                                  s,
                                  (ULONG_PTR)ParsedLine.ValueName,
                                  (ULONG_PTR)ParsedLine.ValueString
                                );

                    ReturnedError = ERROR_BAD_FORMAT;
                    break;
                    }
                }

            break;
            }
        else
        if (ParsedLine.IsKeyName) {
            if (DebugOutput) {
                MsgFprintf( stdout, "%02u %04u  KeyName: %ws",
                        KeyPathLength,
                        ParsedLine.IndentAmount,
                        ParsedLine.KeyName
                      );
                }

            if (ParsedLine.IndentAmount > PreviousValueIndentAmount) {
                MsgFprintf( stderr,
                         "REGINI: Missing line continuation character for %ws\n",
                         ParsedLine.KeyName
                       );

                ReturnedError = ERROR_BAD_FORMAT;
                break;
                }
            else {
                PreviousValueIndentAmount = 0xFFFFFFFF;
                }

//
// This fixes a 64 bit compiler problem where the statement
//
//            CurrentKey = &KeyPath[ KeyPathLength - 1 ];
//
// Is evaulated as (KeyPath + (ULONG)(KeyPathLength - 1)) this is likely 
// because KeyPathLength is a ULONG so the result is when KeyPathLength is 0
// 0xffffffff is added instead of -1
//
            CurrentKey = &KeyPath[ KeyPathLength ];
            CurrentKey--;


            if (KeyPathLength == 0 ||
                ParsedLine.IndentAmount > CurrentKey->IndentAmount
               ) {
                //
                // If first key seen or this key is indented more than last
                // key, then we care going to create this key as a child of
                // its parent
                //
                if (KeyPathLength == MAX_KEY_DEPTH) {
                    MsgFprintf( stderr,
                             "REGINI: %ws key exceeded maximum depth (%u) of tree.\n",
                             ParsedLine.KeyName,
                             MAX_KEY_DEPTH
                           );

                    ReturnedError = ERROR_FILENAME_EXCED_RANGE;
                    break;
                    }
                KeyPathLength++;
                CurrentKey++;
                }
            else {
                //
                // Not first key seen and indented less than or same as
                // last key.  Close any children keys to get back to
                // our current level.
                //
                do {
                    RTCloseKey( &RegistryContext, CurrentKey->Handle );
                    CurrentKey->Handle = NULL;
                    if (ParsedLine.IndentAmount == CurrentKey->IndentAmount) {
                        break;
                        }
                    CurrentKey--;
                    if (--KeyPathLength <= 1) {
                        break;
                        }
                    }
                while (ParsedLine.IndentAmount <= CurrentKey->IndentAmount);
                }

            if (DebugOutput) {
                MsgFprintf( stdout, "  (%02u)\n", KeyPathLength );
                }


            CurrentKey->Name = ParsedLine.KeyName;
            CurrentKey->NameDisplayed = FALSE;
            CurrentKey->IndentAmount = ParsedLine.IndentAmount;
            CurrentKey->Handle = NULL;

            if (ParsedLine.DeleteKey) {
                Error = DeleteKeyTree( &RegistryContext,
                                       (KeyPathLength < 2 ? RootHandle : \
                                        KeyPath[ KeyPathLength - 2 ].Handle),
                                       ParsedLine.KeyName
                                     );
                if (Error == NO_ERROR) {
                    if (DebugOutput) {
                        MsgFprintf( stderr, "    Deleted key %02x %ws (%x%08x)\n",
                                         CurrentKey->IndentAmount,
                                         CurrentKey->Name,
                                         HI_PTR(CurrentKey->Handle),
                                         LO_PTR(CurrentKey->Handle)
                               );
                        }

                    DisplayPath( KeyPath, KeyPathLength+1, NULL );
                    MsgFprintf( stderr, "; *** Deleted the above key and all of its subkeys ***\n" );
                    }
                else {
                    MsgFprintf( stderr,
                             "REGINI: DeleteKey (%ws) relative to handle (%x%08x) failed - %u\n",
                             ParsedLine.KeyName,
                             (KeyPathLength < 2  ? HI_PTR(RootHandle) : \
                              HI_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             (KeyPathLength < 2  ? LO_PTR(RootHandle) : \
                              LO_PTR(KeyPath[ KeyPathLength - 2 ].Handle)), 
                             Error
                           );

                    ReturnedError = Error;
                    break;
                    }
                }
            else {
                Error = RTCreateKey( &RegistryContext,
                                     (KeyPathLength < 2 ? RootHandle : \
                                      KeyPath[ KeyPathLength - 2 ].Handle),
                                     ParsedLine.KeyName,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     ParsedLine.SecurityDescriptor,
                                     (PHKEY)&CurrentKey->Handle,
                                     &Disposition
                                   );
                if (Error == NO_ERROR) {
                    if (DebugOutput) {
                        MsgFprintf( stderr, "    Created key %02x %ws (%x%08x)\n",
                                         CurrentKey->IndentAmount,
                                         CurrentKey->Name,
                                         HI_PTR(CurrentKey->Handle),
                                         LO_PTR(CurrentKey->Handle)
                               );
                        }

                    Error = RTQueryKey( &RegistryContext,
                                        CurrentKey->Handle,
                                        &CurrentKey->LastWriteTime,
                                        NULL,
                                        NULL
                                      );
                    if (Error != NO_ERROR) {
                        RtlZeroMemory( &CurrentKey->LastWriteTime,
                                       sizeof( CurrentKey->LastWriteTime )
                                     );
                        }

                    if (Disposition == REG_CREATED_NEW_KEY) {
                        DisplayPath( KeyPath, KeyPathLength+1, ParsedLine.SecurityDescriptor );
                        }
                    }
                else {
                    MsgFprintf( stderr,
                             "REGINI: CreateKey (%ws) relative to handle (%x%08x) failed - %u\n",
                             ParsedLine.KeyName,
                             (KeyPathLength < 2  ? 
                              HI_PTR(RootHandle) :
                              HI_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             (KeyPathLength < 2  ?
                              LO_PTR(RootHandle) :
                              LO_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             Error
                           );

                    ReturnedError = Error;
                    break;
                    }
                }
            }
        else {
            //
            // Have a value.  If no current key, then an error
            //
            if (CurrentKey == NULL) {
                InputMessage( FileName,
                              ParsedLine.LineNumber,
                              TRUE,
                              "Value name ('%ws') seen before any key name",
                              (ULONG_PTR)ParsedLine.ValueName,
                              0
                            );
                ReturnedError = ERROR_BAD_FORMAT;
                break;
                }

            //
            // Make sure this value goes under the appropriate key.  That is
            // underneath the key that has an indentation that is <= the
            // key.
            //
            while (ParsedLine.IndentAmount < CurrentKey->IndentAmount) {
                if (DebugOutput) {
                    MsgFprintf( stderr, "    Popping from key %02x %ws (%x%08x)\n",
                                     CurrentKey->IndentAmount,
                                     CurrentKey->Name,
                                     HI_PTR(CurrentKey->Handle),
                                     LO_PTR(CurrentKey->Handle)
                           );
                    }

                RTCloseKey( &RegistryContext, CurrentKey->Handle );
                CurrentKey->Handle = NULL;
                CurrentKey--;
                if (--KeyPathLength <= 1) {
                    break;
                    }
                }

            if (DebugOutput) {
                MsgFprintf( stderr, "    Adding value '%ws = %ws' to key %02x %ws (%x%08x)\n",
                                 ParsedLine.ValueName,
                                 ParsedLine.ValueString,
                                 CurrentKey->IndentAmount,
                                 CurrentKey->Name,
                                 HI_PTR(CurrentKey->Handle),
                                 LO_PTR(CurrentKey->Handle)
                       );

                }

            PreviousValueIndentAmount = ParsedLine.IndentAmount;
            if (ParsedLine.DeleteValue) {
                Error = RTDeleteValueKey( &RegistryContext,
                                          KeyPath[ KeyPathLength - 1 ].Handle,
                                          ParsedLine.ValueName
                                        );
                if (Error == NO_ERROR) {
                    MsgFprintf( stdout, "    %ws = DELETED\n", ParsedLine.ValueName );
                    }
                }
            else {
                OldValueLength = OldValueBufferSize;
                Error = RTQueryValueKey( &RegistryContext,
                                         KeyPath[ KeyPathLength - 1 ].Handle,
                                         ParsedLine.ValueName,
                                         &OldValueType,
                                         &OldValueLength,
                                         OldValueBuffer
                                        );
                if (Error != NO_ERROR ||
                    OldValueType != ParsedLine.ValueType ||
                    OldValueLength != ParsedLine.ValueLength ||
                    RtlCompareMemory( OldValueBuffer,
                                      ParsedLine.ValueData,
                                      ParsedLine.ValueLength
                                    ) != ParsedLine.ValueLength
                   ) {
                    Error = RTSetValueKey( &RegistryContext,
                                           KeyPath[ KeyPathLength - 1 ].Handle,
                                           ParsedLine.ValueName,
                                           ParsedLine.ValueType,
                                           ParsedLine.ValueLength,
                                           ParsedLine.ValueData
                                         );
                    if (Error == NO_ERROR) {
                        DisplayPath( KeyPath, KeyPathLength+1, NULL );
                        RTFormatKeyValue( OutputWidth,
                                          (PREG_OUTPUT_ROUTINE)MsgFprintf,
                                          stdout,
                                          FALSE,
                                          KeyPathLength * IndentMultiple,
                                          ParsedLine.ValueName,
                                          ParsedLine.ValueLength,
                                          ParsedLine.ValueType,
                                          ParsedLine.ValueData
                                        );
                        }
                    else {
                        MsgFprintf( stderr,
                                 "REGINI: SetValueKey (%ws) failed (%u)\n",
                                 ParsedLine.ValueName,
                                 Error
                               );

                        ReturnedError = Error;
                        break;
                        }
                    }
                }
            }
        }

    //
    // Close handles we still have open.
    //
    while (CurrentKey >= KeyPath ) {
        RTCloseKey( &RegistryContext, CurrentKey->Handle );
        --CurrentKey;
        }

    RTDisconnectFromRegistry( &RegistryContext );

    return ReturnedError;
}

BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    BOOL FileArgumentSeen;
    PWSTR FileName;

    
    InitCommonCode( CtrlCHandler,
                    "REGINI",
                    "[-b] textFiles...",
                    "-b specifies that REGINI should be backward compatible with older\n"
                    "    versions of REGINI that did not strictly enforce line continuations\n"
                    "    and quoted strings Specifically, REG_BINARY, REG_RESOURCE_LIST and\n"
                    "    REG_RESOURCE_REQUIREMENTS_LIST data types did not need line\n"
                    "    continuations after the first number that gave the size of the data.\n"
                    "    It just kept looking on following lines until it found enough data\n"
                    "    values to equal the data length or hit invalid input.  Quoted\n"
                    "    strings were only allowed in REG_MULTI_SZ.  They could not be\n"
                    "    specified around key or value names, or around values for REG_SZ or\n"
                    "    REG_EXPAND_SZ  Finally, the old REGINI did not support the semicolon\n"
                    "    as an end of line comment character.\n"
                    "\n"
                    "textFiles is one or more ANSI or Unicode text files with registry data.\n"
                    "\n"
                    "The easiest way to understand the format of the input textFile is to use\n"
                    "the REGDMP command with no arguments to dump the current contents of\n"
                    "your NT Registry to standard out.  Redirect standard out to a file and\n"
                    "this file is acceptable as input to REGINI\n"
                    "\n"
                    "Some general rules are:\n"
                    "    Semicolon character is an end-of-line comment character, provided it\n"
                    "    is the first non-blank character on a line\n"
                    "\n"
                    "    Backslash character is a line continuation character.  All\n"
                    "    characters from the backslash up to but not including the first\n"
                    "    non-blank character of the next line are ignored.  If there is more\n"
                    "    than one space before the line continuation character, it is\n"
                    "    replaced by a single space.\n"
                    "\n"
                    "    Indentation is used to indicate the tree structure of registry keys\n"
                    "    The REGDMP program uses indentation in multiples of 4.  You may use\n"
                    "    hard tab characters for indentation, but embedded hard tab\n"
                    "    characters are converted to a single space regardless of their\n"
                    "    position\n"
                    "    \n"
                    "    Values should come before child keys, as they are associated with\n"
                    "    the previous key at or above the value's indentation level.\n"
                    "\n"
                    "    For key names, leading and trailing space characters are ignored and\n"
                    "    not included in the key name, unless the key name is surrounded by\n"
                    "    quotes.  Imbedded spaces are part of a key name.\n"
                    "\n"
                    "    Key names can be followed by an Access Control List (ACL) which is a\n"
                    "    series of decimal numbers, separated by spaces, bracketed by a\n"
                    "    square brackets (e.g.  [8 4 17]).  The valid numbers and their\n"
                    "    meanings are:\n"
                    "\n"
                    "       1  - Administrators Full Access\n"
                    "       2  - Administrators Read Access\n"
                    "       3  - Administrators Read and Write Access\n"
                    "       4  - Administrators Read, Write and Delete Access\n"
                    "       5  - Creator Full Access\n"
                    "       6  - Creator Read and Write Access\n"
                    "       7  - World Full Access\n"
                    "       8  - World Read Access\n"
                    "       9  - World Read and Write Access\n"
                    "       10 - World Read, Write and Delete Access\n"
                    "       11 - Power Users Full Access\n"
                    "       12 - Power Users Read and Write Access\n"
                    "       13 - Power Users Read, Write and Delete Access\n"
                    "       14 - System Operators Full Access\n"
                    "       15 - System Operators Read and Write Access\n"
                    "       16 - System Operators Read, Write and Delete Access\n"
                    "       17 - System Full Access\n"
                    "       18 - System Read and Write Access\n"
                    "       19 - System Read Access\n"
                    "       20 - Administrators Read, Write and Execute Access\n"
                    "       21 - Interactive User Full Access\n"
                    "       22 - Interactive User Read and Write Access\n"
                    "       23 - Interactive User Read, Write and Delete Access\n"
                    "\n"
                    "    If there is an equal sign on the same line as a left square bracket\n"
                    "    then the equal sign takes precedence, and the line is treated as a\n"
                    "    registry value.  If the text between the square brackets is the\n"
                    "    string DELETE with no spaces, then REGINI will delete the key and\n"
                    "    any values and keys under it.\n"
                    "\n"
                    "    For registry values, the syntax is:\n"
                    "\n"
                    "       value Name = type data\n"
                    "\n"
                    "    Leading spaces, spaces on either side of the equal sign and spaces\n"
                    "    between the type keyword and data are ignored, unless the value name\n"
                    "    is surrounded by quotes.  If the text to the right of the equal sign\n"
                    "    is the string DELETE, then REGINI will delete the value.\n"
                    "\n"
                    "    The value name may be left off or be specified by an at-sign\n"
                    "    character which is the same thing, namely the empty value name.  So\n"
                    "    the following two lines are identical:\n"
                    "\n"
                    "       = type data\n"
                    "       @ = type data\n"
                    "\n"
                    "    This syntax means that you can't create a value with leading or\n"
                    "    trailing spaces, an equal sign or an at-sign in the value name,\n"
                    "    unless you put the name in quotes.\n"
                    "\n"
                    "    Valid value types and format of data that follows are:\n"
                    "\n"
                    "       REG_SZ text\n"
                    "       REG_EXPAND_SZ text\n"
                    "       REG_MULTI_SZ \"string1\" \"str\"\"ing2\" ...\n"
                    "       REG_DATE mm/dd/yyyy HH:MM DayOfWeek\n"
                    "       REG_DWORD numberDWORD\n"
                    "       REG_BINARY numberOfBytes numberDWORD(s)...\n"
                    "       REG_NONE (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_LIST (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_REQUIREMENTS (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_REQUIREMENTS_LIST (same format as REG_BINARY)\n"
                    "       REG_FULL_RESOURCE_DESCRIPTOR (same format as REG_BINARY)\n"
                    "       REG_QWORD numberQWORD\n"
                    "       REG_MULTISZ_FILE fileName\n"
                    "       REG_BINARYFILE fileName\n"
                    "\n"
                    "    If no value type is specified, default is REG_SZ\n"
                    "\n"
                    "    For REG_SZ and REG_EXPAND_SZ, if you want leading or trailing spaces\n"
                    "    in the value text, surround the text with quotes.  The value text\n"
                    "    can contain any number of imbedded quotes, and REGINI will ignore\n"
                    "    them, as it only looks at the first and last character for quote\n"
                    "    characters.\n"
                    "\n"
                    "    For REG_MULTI_SZ, each component string is surrounded by quotes.  If\n"
                    "    you want an imbedded quote character, then double quote it, as in\n"
                    "    string2 above.\n"
                    "\n"
                    "    For REG_BINARY, the value data consists of one or more numbers The\n"
                    "    default base for numbers is decimal.  Hexidecimal may be specified\n"
                    "    by using 0x prefix.  The first number is the number of data bytes,\n"
                    "    excluding the first number.  After the first number must come enough\n"
                    "    numbers to fill the value.  Each number represents one DWORD or 4\n"
                    "    bytes.  So if the first number was 0x5 you would need two more\n"
                    "    numbers after that to fill the 5 bytes.  The high order 3 bytes\n"
                    "    of the second DWORD would be ignored.\n"
                  );


	//
	//  To prevent users from corrupting their registry,
	//  administrators can set a policy switch to prevent editing. 
	//  we should block the user .
	//
	// check the GPO -- if GPO is enabled, we should block the
	// user from using the REGISTRY tool
	//
	if (IsRegistryToolDisabled()) 
	{
		MsgFprintf( stderr, "Error: Registry editing has been disabled by your administrator.\n" );

		return 1;
	}
       
					
	BackwardsCompatibleInput = FALSE;
    FileArgumentSeen = FALSE;
    while (--argc) {
        s = *++argv;

        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'b':
                        BackwardsCompatibleInput = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                    }
                }
            }
        else {
            FileArgumentSeen = TRUE;
            FileName = GetArgAsUnicode( s );
            if (FileName == NULL) {
                Error = GetLastError();
                }
            else {
                Error = InitializeRegistryFromAsciiFile( FileName );
                }

            if (Error != NO_ERROR) {
                FatalError( "Failed to load from file '%s' (%u)\n", 
                            (ULONG_PTR)s, Error );
                exit( Error );
                }
            }
        }

    if (!FileArgumentSeen) {
        Usage( "No textFile specified", 0 );
        }

    return 0;
}

/*******************************************************************************
*
*  IsRegistryToolDisabled
*
*  DESCRIPTION:
*     Checks the policy section of the registry to see if registry editing
*     tools should be disabled.  This switch is set by administrators to
*     protect novice users.
*
*     The Registry Editor is disabled if and only if this value exists and is
*     set.
*
*  PARAMETERS:
*     (returns), TRUE if registry tool should not be run, else FALSE.
*
*******************************************************************************/

BOOL
IsRegistryToolDisabled(
    VOID
    )
{

    BOOL fRegistryToolDisabled;
    HKEY hKey;
    DWORD Type;
    DWORD ValueBuffer;
    DWORD cbValueBuffer;

    fRegistryToolDisabled = FALSE;

    if ( RegOpenKey( HKEY_CURRENT_USER,
                        REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM,
                        &hKey) 
            == ERROR_SUCCESS ) 
    {

        cbValueBuffer = sizeof(DWORD);

        if (RegQueryValueEx(hKey, REGSTR_VAL_DISABLEREGTOOLS, NULL, &Type,
            (LPSTR) &ValueBuffer, &cbValueBuffer) == ERROR_SUCCESS) 
        {

            if ( (Type == REG_DWORD) && 
                    (cbValueBuffer == sizeof(DWORD)) &&
                    (ValueBuffer != FALSE) )
            {
                fRegistryToolDisabled = TRUE;
            }
        }

        RegCloseKey(hKey);

    }

    return fRegistryToolDisabled;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    Utility routines for use by REGINI and REGDMP programs.
Author:

    Steve Wood (stevewo)  10-Mar-92

Revision History:

--*/

#include "regutil.h"

ULONG NumberOfLinesOutput;
BOOLEAN RegBackSwitches;
LPSTR SavedModuleName;
LPSTR SavedModuleUsage1;
LPSTR SavedModuleUsage2;
PHANDLER_ROUTINE SavedCtrlCHandler;

BOOL
CommonCtrlCHandler(
    IN ULONG CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT || CtrlType == CTRL_BREAK_EVENT) {
        if (SavedCtrlCHandler != NULL) {
            (*SavedCtrlCHandler)( CtrlType );
        }
        ExitProcess( 1 );
    }
    return FALSE;
}

void
InitCommonCode(
    PHANDLER_ROUTINE CtrlCHandler,
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    )
{
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;

    if (!RTInitialize()) {
        FatalError( "Unable to initialize registry access functions (%u)",
                    GetLastError(), 0 );
        }

    if (_isatty( _fileno( stdout ) )) {
        if (GetConsoleScreenBufferInfo( GetStdHandle( STD_OUTPUT_HANDLE ),
                                        &ConsoleScreenBufferInfo
                                      )
           ) {
            OutputHeight = ConsoleScreenBufferInfo.srWindow.Bottom -
                           ConsoleScreenBufferInfo.srWindow.Top + 1;
            OutputWidth = ConsoleScreenBufferInfo.srWindow.Right -
                          ConsoleScreenBufferInfo.srWindow.Left + 1;
            }
        else {
            OutputHeight = 24;
            OutputWidth = 80;
            }
        }
    else {
        OutputHeight = 0;       // Dont pause on redirected output
        OutputWidth = 240;      // Larger width for redirected output
        }

    IndentMultiple = 4;
    SavedModuleName = ModuleName;
    if (!_stricmp( SavedModuleName, "REGBACK" )) {
        RegBackSwitches = TRUE;
        }
    else {
        RegBackSwitches = FALSE;
        }
    SavedModuleUsage1 = ModuleUsage1;
    SavedModuleUsage2 = ModuleUsage2;

    SetConsoleCtrlHandler( CtrlCHandler, TRUE );
    OldValueBufferSize = 30 * 4096;
    OldValueBuffer = VirtualAlloc( NULL, OldValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (OldValueBuffer == NULL) {
        FatalError( "Unable to allocate large value buffer (%u)",
                    GetLastError(), 0 );
        }

    return;
}

void
DisplayIndentedString(
    ULONG IndentAmount,
    PCHAR sBegin
    )
{
    PCHAR sEnd;

    while (sBegin != NULL) {
        sEnd = sBegin;
        while (*sEnd && *sEnd != '\n') {
            sEnd += 1;
            }

        MsgFprintf( stderr, "%.*s%.*s\n",
                 IndentAmount,
                 "                                                      ",
                 sEnd - sBegin, sBegin
               );

        NumberOfLinesOutput += 1;

        if (OutputHeight != 0 && NumberOfLinesOutput >= OutputHeight) {
            MsgFprintf( stderr, "more...press any key to continue" );
            TSGetch();
            MsgFprintf( stderr, "\r                                \r" );
            NumberOfLinesOutput = 2;
            }

        if (*sEnd == '\0') {
            break;
            }
        else {
            sBegin = ++sEnd;
            }
        }
    return;
}


void
Usage(
    LPSTR Message,
    ULONG_PTR MessageParameter
    )
{
    ULONG n;
    LPSTR sBegin, sEnd;

    NumberOfLinesOutput += 1;
    n = MsgFprintf( stderr, "usage: %s ", SavedModuleName );
    MsgFprintf( stderr, "[-m \\\\machinename" );
    if (!RegBackSwitches) {
        MsgFprintf( stderr, " | -h hivefile hiveroot | -w Win95 Directory" );
        }
    MsgFprintf( stderr, "]\n" );
    NumberOfLinesOutput += 1;
    if (!RegBackSwitches) {
        DisplayIndentedString( n, "[-i n] [-o outputWidth]" );
        }

    DisplayIndentedString( n, SavedModuleUsage1 );
    MsgFprintf( stderr, "\n" );
    NumberOfLinesOutput += 1;

    n = MsgFprintf( stderr, "where: " );
    MsgFprintf( stderr, "-m specifies a remote Windows NT machine whose registry is to be manipulated.\n" );
    NumberOfLinesOutput += 1;
    if (!RegBackSwitches) {
        DisplayIndentedString( n,
                               "-h specifies a specify local hive to manipulate.\n"
                               "-w specifies the paths to a Windows 95 system.dat and user.dat files\n"
                               "-i n specifies the display indentation multiple.  Default is 4\n"
                               "-o outputWidth specifies how wide the output is to be.  By default the\n"
                               "   outputWidth is set to the width of the console window if standard\n"
                               "   output has not been redirected to a file.  In the latter case, an\n"
                               "   outputWidth of 240 is used."
                             );
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }
    DisplayIndentedString( n, SavedModuleUsage2 );

    if (!RegBackSwitches) {
        DisplayIndentedString( n,
                               "Whenever specifying a registry path, either on the command line\n"
                               "or in an input file, the following prefix strings can be used:\n"
                               "\n"
                               "     HKEY_LOCAL_MACHINE\n"
                               "     HKEY_USERS\n"
                               "     HKEY_CURRENT_USER\n"
                               "     USER:\n"
                               "\n"
                               "   Each of these strings can stand alone as the key name or be followed\n"
                               "   a backslash and a subkey path."
                             );
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }

    //
    // No return from FatalError
    //

    if (Message != NULL) {
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }
    FatalError( Message, MessageParameter, 0 );
}

void
FatalError(
    LPSTR     Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    )
{
    if (Message != NULL) {
        MsgFprintf( stderr, "%s: ", SavedModuleName );
        MsgFprintf( stderr, Message, MessageParameter1, MessageParameter2 );
        MsgFprintf( stderr, "\n" );
        }

    if (SavedCtrlCHandler != NULL) {
        (*SavedCtrlCHandler)( CTRL_BREAK_EVENT );
        }

    exit( 1 );
}

void
InputMessage(
    PWSTR FileName,
    ULONG LineNumber,
    BOOLEAN Error,
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    )
{
    MsgFprintf( stderr, "%ws(%u) : %s: ", FileName, LineNumber, Error ? "error" : "warning" );
    MsgFprintf( stderr, Message, MessageParameter1, MessageParameter2 );
    MsgFprintf( stderr, "\n" );
    return;
}

PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        FatalError( "Out of memory", 0, 0 );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        FatalError( "Unable to convert parameter '%s' to Unicode (%u)",
                    (ULONG_PTR)s, GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}


void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    )
{
    c = (char)tolower( c );
    switch( c ) {
        case 'd':
            DebugOutput = TRUE;
            break;

        case 'o':
            if (--*argc) {
                OutputWidth = atoi( *++(*argv) );
                break;
                }
            else {
                Usage( "Missing argument to -o switch", 0 );
                }

        case 'i':
            if (--*argc) {
                IndentMultiple = atoi( *++(*argv) );
                break;
                }
            else {
                Usage( "Missing parameter for -%c switch", (ULONG)c );
                }

        case 'm':
            if (HiveFileName != NULL || HiveRootName != NULL ||
                Win95Path != NULL || Win95UserPath != NULL
               ) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc) {
                MachineName = GetArgAsUnicode( *++(*argv) );
                if (_wcsnicmp( MachineName, L"\\\\", 2 )) {
                    FatalError( "Invalid machine name - '%ws'",
                                (ULONG_PTR)MachineName, 0 );
                    }
                }
            else {
                Usage( "Missing parameter for -%c switch", (ULONG)c );
                }
            break;


        case 'w':
            if (MachineName != NULL || HiveFileName != NULL || HiveRootName != NULL) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc && --*argc) {
                Win95Path = GetArgAsUnicode( *++(*argv) );
                Win95UserPath = GetArgAsUnicode( *++(*argv) );
                }
            else {
                Usage( "Missing parameter(s) for -%c switch", (ULONG)c );
                }
            break;

        case 'h':
            if (MachineName != NULL || Win95Path != NULL || Win95UserPath != NULL) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc && --*argc) {
                HiveFileName = GetArgAsUnicode( *++(*argv) );
                HiveRootName = GetArgAsUnicode( *++(*argv) );
                }
            else {
                Usage( "Missing parameter(s) for -%c switch", (ULONG)c );
                }
            break;

        case '?':
            Usage( NULL, 0 );
            break;

        default:
            Usage( "Invalid switch (-%c)", (ULONG)c );
            break;
        }

    return;
}

/*
int MsgFprintf (
                 FILE *str,
                 LPSTR format,
                 ...
               )

if we ever need to display messages for english versions we can add the following portion of code.

[
#ifdef OUTPUT_ENGLISH_MSGS
   va_list va;
   if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_ENGLISH ) {
      va_start(va, format);
      i = vfprintf (str, format, va);
      va_end(va);
   }
#endif // OUTPUT_ENGLISH_MSGS
]
*/

int
__cdecl
MsgFprintf (
                 FILE *str,
                 LPSTR format,
                 ...
               )
{
   int i=0;
//#ifndef SILENT_TS_TOOL
   va_list va;
   va_start(va, format);
   i = vfprintf (str, format, va);
   va_end(va);
//#endif // SILENT_TS_TOOL
   return (i);
}
void TSGetch()
{
#ifndef SILENT_TS_TOOL
   _getch();
#endif // SILENT_TS_TOOL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regtool.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regtool.h

Abstract:

    This is the include file for the REGTOOL.DLL registry helper.

Author:

    Steve Wood (stevewo) 16-Nov-1995

Revision History:

--*/

//
// Routines for accessing registry.  Allows code to access any of the following
// registry locations with the same code:
//
//      Windows NT registry on local machine
//      Windows NT registry on remote machine
//      Windows NT hive files
//      Windows 95 registry files (system.dat, user.dat)
//

BOOLEAN
RTInitialize( void );

#define REG_TARGET_DISCONNECTED    0
#define REG_TARGET_LOCAL_REGISTRY  1
#define REG_TARGET_REMOTE_REGISTRY 2
#define REG_TARGET_WIN95_REGISTRY  3
#define REG_TARGET_HIVE_REGISTRY   4

typedef struct _REG_CONTEXT_OPEN_HIVE_KEY {
    struct _REG_CONTEXT_OPEN_HIVE_KEY *Next;
    HKEY KeyHandle;
    ULONG ReferenceCount;
} REG_CONTEXT_OPEN_HIVE_KEY, *PREG_CONTEXT_OPEN_HIVE_KEY;

typedef struct _REG_CONTEXT {
    struct _REG_CONTEXT *Next;
    ULONG Target;
    HKEY MachineRoot;
    HKEY UsersRoot;
    HKEY CurrentUserRoot;
    WCHAR MachinePath[ MAX_PATH ];
    WCHAR UsersPath[ MAX_PATH ];
    WCHAR CurrentUserPath[ MAX_PATH ];
    ULONG MachinePathLength;
    ULONG UsersPathLength;
    ULONG CurrentUserPathLength;
    HKEY HiveRootHandle;
    OBJECT_ATTRIBUTES HiveRootKey;
    PREG_CONTEXT_OPEN_HIVE_KEY OpenHiveKeys;
} REG_CONTEXT, *PREG_CONTEXT;


BOOLEAN
RTEnableBackupRestorePrivilege( void );

void
RTDisableBackupRestorePrivilege( void );

LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    IN PWSTR Win95Path,
    IN PWSTR Win95UserName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    );

LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    );

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    );


LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    );

#define HKEY_REGISTRY_ROOT          (( HKEY ) (ULONG_PTR)((LONG)0x8000000A) )

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTFlushKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTEnumerateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PFILETIME LastWriteTime,
    IN OUT PULONG KeyNameLength,
    OUT PWSTR KeyName
    );

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );


LONG
RTQueryKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    OUT PFILETIME LastWriteTime,
    OUT PULONG NumberOfSubkeys,
    OUT PULONG NumberOfValues
    );

LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );

LONG
RTSetValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN ULONG ValueDataLength,
    IN PVOID ValueData
    );

LONG
RTDeleteKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PCWSTR SubKeyName
    );

LONG
RTDeleteValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName
    );


typedef struct _REG_UNICODE_FILE {
    PWSTR FileName;
    FILETIME LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR NextLine;
    ULONG NextLineNumber;
    BOOLEAN BackwardsCompatibleInput;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

LONG
RTLoadAsciiFileAsUnicode(
    IN PWSTR Path,
    OUT PREG_UNICODE_FILE UnicodeFile
    );

void
RTUnloadUnicodeFile(
    IN OUT PREG_UNICODE_FILE UnicodeFile
    );

typedef enum _REG_UNICODE_PARSE_FAILURE_REASON {
    ParseFailNoFailure = 0,
    ParseFailValueTooLarge,
    ParseFailUnableToAccessFile,
    ParseFailDateTimeFormatInvalid,
    ParseFailInvalidLineContinuation,
    ParseFailInvalidQuoteCharacter,
    ParseFailBinaryDataLengthMissing,
    ParseFailBinaryDataOmitted,
    ParseFailBinaryDataNotEnough,
    ParseFailInvalidRegistryType
} REG_UNICODE_PARSE_FAILURE_REASON;

typedef struct _REG_UNICODE_PARSE {
    ULONG LineNumber;
    ULONG IndentAmount;
    PWSTR BeginLine;
    BOOLEAN AtEndOfFile;
    BOOLEAN IsKeyName;
    REG_UNICODE_PARSE_FAILURE_REASON ParseFailureReason;
    union {
        struct {
            PWSTR KeyName;
            PWSTR AclString;
            PVOID SecurityDescriptor;
            BOOLEAN DeleteKey;
            SECURITY_DESCRIPTOR SecurityDescriptorBuffer;
        };
        struct {
            PWSTR ValueName;
            PWSTR ValueString;
            ULONG ValueType;
            ULONG ValueLength;
            PVOID ValueData;
            BOOLEAN DeleteValue;
        };
    };
} REG_UNICODE_PARSE, *PREG_UNICODE_PARSE;


BOOLEAN
RTParseNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PREG_UNICODE_PARSE ParsedLine
    );

BOOLEAN
RTParseValueData(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN PVOID ValueBuffer,
    IN ULONG ValueBufferSize,
    OUT PULONG ValueType,
    OUT PVOID *ValueData,
    OUT PULONG ValueLength
    );

typedef
int
(_cdecl *PREG_OUTPUT_ROUTINE)(
    PVOID pParameter,
    LPSTR FormatString,
    ...
    );

void
RTFormatKeyName(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    ULONG IndentLevel,
    PWSTR KeyName
    );

void
RTFormatKeySecurity(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    HKEY KeyHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

void
RTFormatKeyValue(
    ULONG OutputWidth,
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    BOOLEAN SummaryOutput,
    ULONG IndentLevel,
    PWSTR ValueName,
    ULONG ValueLength,
    ULONG ValueType,
    PWSTR ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regtool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regtool.c

Abstract:

    This file contains functions for supporting the registry tools
    REGINI, REGDMP, REGDIR and REGFIND

Author:

    Steve Wood (stevewo) 15-Nov-1995

Revision History:

--*/

#include <tchar.h>
#include "regutil.h"

ULONG ValueBufferSize = (4096 * 100);
PVOID ValueBuffer;


UCHAR BlanksForPadding[] =
"                                                                                                                                 ";

//
// routines for creating security descriptors (defined in regacl.c)
//

BOOLEAN
RegInitializeSecurity(
                     VOID
                     );

BOOLEAN
WINAPI
RegUnicodeToDWORD(
                 IN OUT PWSTR *String,
                 IN DWORD Base OPTIONAL,
                 OUT PDWORD Value
                 );

BOOLEAN
WINAPI
RegUnicodeToQWORD(
                 IN OUT PWSTR *String,
                 IN DWORD Base OPTIONAL,
                 OUT PDWORDLONG Value
                 );

BOOLEAN
RegCreateSecurity(
                 IN PWSTR Description,
                 OUT PSECURITY_DESCRIPTOR SecurityDescriptor
                 );

BOOLEAN
RegFormatSecurity(
                 IN PSECURITY_DESCRIPTOR SecurityDescriptor,
                 OUT PWSTR AceList
                 );

VOID
RegDestroySecurity(
                  IN PSECURITY_DESCRIPTOR SecurityDescriptor
                  );

LONG
RegLoadHive(
           IN PREG_CONTEXT RegistryContext,
           IN PWSTR HiveFileName,
           IN PWSTR HiveRootName
           );

void
RegUnloadHive(
             IN PREG_CONTEXT RegistryContext
             );



struct {
    PWSTR TypeName;
    ULONG ValueType;
    BOOLEAN GetDataFromBinaryFile;
    BOOLEAN GetDataFromMultiSzFile;
    BOOLEAN ParseDateTime;
} RegTypeNameTable[] = {
    {L"REG_SZ", REG_SZ, FALSE, FALSE, FALSE},
    {L"REG_EXPAND_SZ", REG_EXPAND_SZ, FALSE, FALSE, FALSE},
    {L"REG_MULTI_SZ", REG_MULTI_SZ, FALSE, FALSE, FALSE},
    {L"REG_MULTISZ_FILE", REG_MULTI_SZ, FALSE, TRUE, FALSE},
    {L"REG_DWORD", REG_DWORD, FALSE, FALSE, FALSE},
    {L"REG_NONE", REG_NONE, FALSE, FALSE, FALSE},
    {L"REG_BINARY", REG_BINARY, FALSE, FALSE, FALSE},
    {L"REG_BINARYFILE", REG_BINARY, TRUE, FALSE, FALSE},
    {L"REG_DATE", REG_BINARY, FALSE, FALSE, TRUE},
    {L"REG_RESOURCE_LIST", REG_RESOURCE_LIST, FALSE, FALSE, FALSE},
    {L"REG_RESOURCE_REQUIREMENTS_LIST", REG_RESOURCE_REQUIREMENTS_LIST, FALSE, FALSE, FALSE},
    {L"REG_RESOURCE_REQUIREMENTS", REG_RESOURCE_REQUIREMENTS_LIST, FALSE, FALSE, FALSE},
    {L"REG_FULL_RESOURCE_DESCRIPTOR", REG_FULL_RESOURCE_DESCRIPTOR, FALSE, FALSE, FALSE},
    {L"REG_QWORD", REG_QWORD, FALSE, FALSE, FALSE},
    {NULL, REG_NONE, FALSE, FALSE, FALSE}
};

struct {
    PWSTR ValueName;
    ULONG Value;
} RegValueNameTable[] = {
    {L"ON", TRUE},
    {L"YES", TRUE},
    {L"TRUE", TRUE},
    {L"OFF", FALSE},
    {L"NO", FALSE},
    {L"FALSE", FALSE},
    {NULL, FALSE}
};


int
RegAnsiToUnicode(
                LPCSTR Source,
                PWSTR Destination,
                ULONG NumberOfChars
                )
{
    int NumberOfXlatedChars;

    if (NumberOfChars == 0) {
        NumberOfChars = strlen( Source );
    }

    NumberOfXlatedChars = MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED,
                                               Source,
                                               NumberOfChars,
                                               Destination,
                                               NumberOfChars
                                             );

    Destination[ NumberOfXlatedChars ] = UNICODE_NULL;

    if ( NumberOfXlatedChars == 0 ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
    }

    return NumberOfXlatedChars;
}


int
RegUnicodeToAnsi(
                PCWSTR Source,
                LPSTR Destination,
                ULONG NumberOfChars
                )
{
    int NumberOfXlatedChars;

    if (NumberOfChars == 0) {
        NumberOfChars = wcslen( Source );
    }

    NumberOfXlatedChars = WideCharToMultiByte( CP_ACP,
                                               0,
                                               Source,
                                               NumberOfChars,
                                               Destination,
                                               NumberOfChars * 2,
                                               NULL,
                                               NULL
                                             );

    Destination[ NumberOfXlatedChars ] = '\0';

    if ( NumberOfXlatedChars == 0 ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
    }

    return NumberOfXlatedChars;
}

typedef
LONG
(APIENTRY *LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE)(
                                                HKEY hKey,
                                                LPCSTR lpFileName,
                                                UINT Flags
                                                );

typedef
LONG
(APIENTRY *LPVMMREGLOADKEY_PROCEDURE)(
                                     HKEY hKey,
                                     LPCSTR lpSubKey,
                                     LPCSTR lpFileName
                                     );

typedef
LONG
(APIENTRY *LPVMMREGUNLOADKEY_PROCEDURE)(
                                       HKEY hKey,
                                       LPCSTR lpSubKey
                                       );

typedef
LONG
(APIENTRY *LPVMMREGCREATEKEY_PROCEDURE)(
                                       HKEY hKey,
                                       LPCSTR lpSubKey,
                                       PHKEY lphSubKey
                                       );

typedef
LONG
(APIENTRY *LPVMMREGDELETEKEY_PROCEDURE)(
                                       HKEY hKey,
                                       LPCSTR lpSubKey
                                       );

typedef
LONG
(APIENTRY *LPVMMREGOPENKEY_PROCEDURE)(
                                     HKEY hKey,
                                     LPCSTR lpSubKey,
                                     PHKEY lphSubKey
                                     );

typedef
LONG
(APIENTRY *LPVMMREGFLUSHKEY_PROCEDURE)(
                                      HKEY hKey
                                      );

typedef
LONG
(APIENTRY *LPVMMREGCLOSEKEY_PROCEDURE)(
                                      HKEY hKey
                                      );

typedef
LONG
(APIENTRY *LPVMMREGQUERYINFOKEY_PROCEDURE)(
                                          HKEY hKey,
                                          LPCSTR lpClass,
                                          LPDWORD lpcbClass,
                                          LPDWORD lpReserved,
                                          LPDWORD lpcSubKeys,
                                          LPDWORD lpcbMaxSubKeyLen,
                                          LPDWORD lpcbMaxClassLen,
                                          LPDWORD lpcValues,
                                          LPDWORD lpcbMaxValueName,
                                          LPDWORD lpcbMaxValueData,
                                          LPVOID lpcbSecurityDescriptor,
                                          LPVOID lpftLastWriteTime
                                          );

typedef
LONG
(APIENTRY *LPVMMREGENUMKEY_PROCEDURE)(
                                     HKEY hKey,
                                     DWORD Index,
                                     LPSTR lpKeyName,
                                     DWORD cbKeyName
                                     );

typedef
LONG
(APIENTRY *LPVMMREGENUMVALUE_PROCEDURE)(
                                       HKEY hKey,
                                       DWORD Index,
                                       LPSTR lpValueName,
                                       LPDWORD lpcbValueName,
                                       LPDWORD lpReserved,
                                       LPDWORD lpType,
                                       LPBYTE lpData,
                                       LPDWORD lpcbData
                                       );

typedef
LONG
(APIENTRY *LPVMMREGQUERYVALUEEX_PROCEDURE)(
                                          HKEY hKey,
                                          LPCSTR lpValueName,
                                          LPDWORD lpReserved,
                                          LPDWORD lpType,
                                          LPBYTE lpData,
                                          LPDWORD lpcbData
                                          );

typedef
LONG
(APIENTRY *LPVMMREGSETVALUEEX_PROCEDURE)(
                                        HKEY hKey,
                                        LPCSTR lpValueName,
                                        DWORD Reserved,
                                        DWORD Type,
                                        LPBYTE lpData,
                                        DWORD cbData
                                        );

typedef
LONG
(APIENTRY *LPVMMREGDELETEVALUE_PROCEDURE)(
                                         HKEY hKey,
                                         LPCSTR lpValueName
                                         );

HMODULE hVMMREG32;
LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE _Win95RegMapPredefKeyToFile;
LPVMMREGLOADKEY_PROCEDURE            _Win95RegLoadKey;
LPVMMREGUNLOADKEY_PROCEDURE          _Win95RegUnLoadKey;
LPVMMREGCREATEKEY_PROCEDURE          _Win95RegCreateKey;
LPVMMREGDELETEKEY_PROCEDURE          _Win95RegDeleteKey;
LPVMMREGOPENKEY_PROCEDURE            _Win95RegOpenKey;
LPVMMREGFLUSHKEY_PROCEDURE           _Win95RegFlushKey;
LPVMMREGCLOSEKEY_PROCEDURE           _Win95RegCloseKey;
LPVMMREGQUERYINFOKEY_PROCEDURE       _Win95RegQueryInfoKey;
LPVMMREGENUMKEY_PROCEDURE            _Win95RegEnumKey;
LPVMMREGENUMVALUE_PROCEDURE          _Win95RegEnumValue;
LPVMMREGQUERYVALUEEX_PROCEDURE       _Win95RegQueryValueEx;
LPVMMREGSETVALUEEX_PROCEDURE         _Win95RegSetValueEx;
LPVMMREGDELETEVALUE_PROCEDURE        _Win95RegDeleteValue;

BOOLEAN
RegInitWin95RegistryAccess(
                          PREG_CONTEXT RegistryContext,
                          PWSTR Win95Path,
                          PWSTR Win95UserPath
                          )
{
    LONG Error;
    char Buffer[ MAX_PATH+1 ];

    if ((hVMMREG32 = LoadLibrary( L"VMMREG32" )) == NULL) {
        return FALSE;
    }

    _Win95RegMapPredefKeyToFile = (LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE)GetProcAddress( hVMMREG32, "VMMRegMapPredefKeyToFile" );
    _Win95RegLoadKey            = (LPVMMREGLOADKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegLoadKey"            );
    _Win95RegUnLoadKey          = (LPVMMREGUNLOADKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegUnLoadKey"          );
    _Win95RegCreateKey          = (LPVMMREGCREATEKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegCreateKey"          );
    _Win95RegDeleteKey          = (LPVMMREGDELETEKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegDeleteKey"          );
    _Win95RegOpenKey            = (LPVMMREGOPENKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegOpenKey"            );
    _Win95RegFlushKey           = (LPVMMREGFLUSHKEY_PROCEDURE          )GetProcAddress( hVMMREG32, "VMMRegFlushKey"           );
    _Win95RegCloseKey           = (LPVMMREGCLOSEKEY_PROCEDURE          )GetProcAddress( hVMMREG32, "VMMRegCloseKey"           );
    _Win95RegQueryInfoKey       = (LPVMMREGQUERYINFOKEY_PROCEDURE      )GetProcAddress( hVMMREG32, "VMMRegQueryInfoKey"       );
    _Win95RegEnumKey            = (LPVMMREGENUMKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegEnumKey"            );
    _Win95RegEnumValue          = (LPVMMREGENUMVALUE_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegEnumValue"          );
    _Win95RegQueryValueEx       = (LPVMMREGQUERYVALUEEX_PROCEDURE      )GetProcAddress( hVMMREG32, "VMMRegQueryValueEx"       );
    _Win95RegSetValueEx         = (LPVMMREGSETVALUEEX_PROCEDURE        )GetProcAddress( hVMMREG32, "VMMRegSetValueEx"         );
    _Win95RegDeleteValue        = (LPVMMREGDELETEVALUE_PROCEDURE       )GetProcAddress( hVMMREG32, "VMMRegDeleteValue"        );

    if ((_Win95RegMapPredefKeyToFile == NULL) ||
        (_Win95RegLoadKey == NULL) ||
        (_Win95RegUnLoadKey == NULL) ||
        (_Win95RegCreateKey == NULL) ||
        (_Win95RegDeleteKey == NULL) ||
        (_Win95RegOpenKey == NULL) ||
        (_Win95RegFlushKey  == NULL) ||
        (_Win95RegCloseKey  == NULL) ||
        (_Win95RegQueryInfoKey == NULL) ||
        (_Win95RegEnumKey == NULL) ||
        (_Win95RegEnumValue == NULL) ||
        (_Win95RegQueryValueEx == NULL) ||
        (_Win95RegSetValueEx == NULL) ||
        (_Win95RegDeleteValue == NULL)
       ) {
        FreeLibrary( hVMMREG32 );
        SetLastError( ERROR_PROC_NOT_FOUND );
        return FALSE;
    }

    //
    //  Map HKEY_LOCAL_MACHINE of Win95 hive
    //

    RegUnicodeToAnsi( Win95Path, Buffer, 0 );
    strcat( Buffer, "\\system.dat" );
    Error = (_Win95RegMapPredefKeyToFile)( HKEY_LOCAL_MACHINE, Buffer, 0 );
    if (Error == NO_ERROR) {
        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegUnicodeToAnsi( Win95Path, Buffer, 0 );
        strcat( Buffer, "\\user.dat" );
        Error = (_Win95RegMapPredefKeyToFile)( HKEY_USERS, Buffer, 0 );
        if (Error == NO_ERROR) {
            RegistryContext->UsersRoot = HKEY_USERS;
            Error = (_Win95RegOpenKey)( HKEY_USERS, ".Default", &RegistryContext->CurrentUserRoot );
        }
    }

    if (Error != NO_ERROR) {
        if (RegistryContext->MachineRoot != NULL) {
            (_Win95RegMapPredefKeyToFile)( RegistryContext->MachineRoot, NULL, 0 );
        }

        if (RegistryContext->UsersRoot) {
            (_Win95RegMapPredefKeyToFile)( RegistryContext->UsersRoot, NULL, 0 );
        }

        FreeLibrary( hVMMREG32 );
        SetLastError( Error );
        return FALSE;
    }

    wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
    wcscpy( RegistryContext->CurrentUserPath, RegistryContext->UsersPath );
    wcscat( RegistryContext->CurrentUserPath, L"\\.Default" );
    return TRUE;
}


BOOLEAN PrivilegeEnabled;
BOOLEAN RestoreWasEnabled;
BOOLEAN BackupWasEnabled;

BOOLEAN
RTEnableBackupRestorePrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable backup and restore privileges
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &RestoreWasEnabled  // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    Status = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &BackupWasEnabled   // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    PrivilegeEnabled = TRUE;
    return TRUE;
}


void
RTDisableBackupRestorePrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                        RestoreWasEnabled,
                        FALSE,
                        &RestoreWasEnabled
                      );

    RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                        BackupWasEnabled,
                        FALSE,
                        &BackupWasEnabled
                      );

    PrivilegeEnabled = FALSE;
    return;
}



BOOLEAN
RTInitialize( void )
/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    ValueBuffer = VirtualAlloc( NULL, ValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (ValueBuffer == NULL) {
        return FALSE;
    }

    if (!RegInitializeSecurity()) {
        return FALSE;
    }

    return TRUE;
}


LONG
RTConnectToRegistry(
                   IN PWSTR MachineName,
                   IN PWSTR HiveFileName,
                   IN PWSTR HiveRootName,
                   IN PWSTR Win95Path,
                   IN PWSTR Win95UserName,
                   OUT PWSTR *DefaultRootKeyName,
                   OUT PREG_CONTEXT RegistryContext
                   )
{
    LONG Error;

    if (MachineName != NULL) {
        if (HiveRootName || HiveFileName || Win95Path || Win95UserName) {
            return ERROR_INVALID_PARAMETER;
        }

        Error = RegConnectRegistry( MachineName, HKEY_LOCAL_MACHINE, (PHKEY)&RegistryContext->MachineRoot );
        if (Error == NO_ERROR) {
            Error = RegConnectRegistry( MachineName, HKEY_USERS, (PHKEY)&RegistryContext->UsersRoot );
            if (Error == NO_ERROR) {
                Error = RegOpenKey( RegistryContext->UsersRoot, L".Default", &RegistryContext->CurrentUserRoot );
            }
        }

        if (Error != NO_ERROR) {
            if (RegistryContext->MachineRoot != NULL) {
                RegCloseKey( RegistryContext->MachineRoot );
                RegistryContext->MachineRoot = NULL;
            }

            if (RegistryContext->UsersRoot != NULL) {
                RegCloseKey( RegistryContext->UsersRoot );
                RegistryContext->UsersRoot = NULL;
            }

            return Error;
        }

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        wcscpy( RegistryContext->CurrentUserPath, L"\\Registry\\Users\\.Default" );
        RegistryContext->Target = REG_TARGET_REMOTE_REGISTRY;
    } else
        if (HiveRootName != NULL || HiveFileName != NULL) {
        if (HiveRootName == NULL || HiveFileName == NULL ||
            Win95Path != NULL || Win95UserName != NULL
           ) {
            return ERROR_INVALID_PARAMETER;
        }

        if (!PrivilegeEnabled && !RTEnableBackupRestorePrivilege()) {
            return ERROR_PRIVILEGE_NOT_HELD;
        }

        RegistryContext->MachineRoot = NULL;
        RegistryContext->UsersRoot = NULL;
        RegistryContext->CurrentUserRoot = NULL;

        Error = RegLoadHive( RegistryContext, HiveFileName, HiveRootName );
        if (Error != NO_ERROR) {
            return Error;
        }

        if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
            *DefaultRootKeyName = HiveRootName;
        }
        RegistryContext->Target = REG_TARGET_HIVE_REGISTRY;
    } else
        if (Win95Path != NULL || Win95UserName != NULL) {
        if (!RegInitWin95RegistryAccess( RegistryContext,
                                         Win95Path,
                                         Win95UserName
                                       )
           ) {
            return GetLastError();
        }

        RegistryContext->Target = REG_TARGET_WIN95_REGISTRY;
    } else {
        NTSTATUS Status;
        UNICODE_STRING CurrentUserKeyPath;

        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegistryContext->UsersRoot = HKEY_USERS;
        RegistryContext->CurrentUserRoot = HKEY_CURRENT_USER;

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError( Status ) );
            return FALSE;
        }

        wcscpy( RegistryContext->CurrentUserPath, CurrentUserKeyPath.Buffer );
        RtlFreeUnicodeString( &CurrentUserKeyPath );

        RegistryContext->Target = REG_TARGET_LOCAL_REGISTRY;
    }

    if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
        *DefaultRootKeyName = L"\\Registry";
    }
    RegistryContext->MachinePathLength = wcslen( RegistryContext->MachinePath );
    RegistryContext->UsersPathLength = wcslen( RegistryContext->UsersPath );
    RegistryContext->CurrentUserPathLength = wcslen( RegistryContext->CurrentUserPath );
    return NO_ERROR;
}


LONG
RTDisconnectFromRegistry(
                        IN PREG_CONTEXT RegistryContext
                        )
{
    switch ( RegistryContext->Target ) {
        case REG_TARGET_DISCONNECTED:
            break;

        case REG_TARGET_LOCAL_REGISTRY:
            break;

        case REG_TARGET_REMOTE_REGISTRY:
            break;

        case REG_TARGET_WIN95_REGISTRY:
            // (_Win95RegMapPredefKeyToFile)( RegistryContext->MachineRoot, NULL, 0 );
            // (_Win95RegMapPredefKeyToFile)( RegistryContext->UsersRoot, NULL, 0 );
            (_Win95RegCloseKey)( RegistryContext->CurrentUserRoot );
            FreeLibrary( hVMMREG32 );
            break;

        case REG_TARGET_HIVE_REGISTRY:
            RegUnloadHive( RegistryContext );
            break;
    }

    if (PrivilegeEnabled) {
        RTDisableBackupRestorePrivilege();
    }

    RegistryContext->Target = REG_TARGET_DISCONNECTED;
    return NO_ERROR;
}

UNICODE_STRING RegHiveRootName;

#pragma prefast(push)
#pragma prefast(disable: 248)       // NULL dacl is by design here, read below.

LONG
RegLoadHive(
           IN PREG_CONTEXT RegistryContext,
           IN PWSTR HiveFileName,
           IN PWSTR HiveRootName
           )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES File;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // Create security descriptor with a NULL Dacl.  This is necessary
    // because the security descriptor we pass in gets used in system
    // context.  So if we just pass in NULL, then the Wrong Thing happens.
    // (but only on NTFS!)
    //
    Status = RtlCreateSecurityDescriptor( &SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION
                                        );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    Status = RtlSetDaclSecurityDescriptor( &SecurityDescriptor,
                                           TRUE,         // Dacl present
                                           NULL,         // but grants all access
                                           FALSE
                                         );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    if (!RtlDosPathNameToNtPathName_U( HiveFileName,
                                       &NtFileName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return ERROR_BAD_PATHNAME;
    }
    InitializeObjectAttributes( &File,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecurityDescriptor
                              );

    RtlInitUnicodeString( &RegHiveRootName, L"\\Registry");
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &RegistryContext->HiveRootHandle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
    }

    RtlInitUnicodeString( &RegHiveRootName, HiveRootName );
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                RegistryContext->HiveRootHandle,
                                NULL
                              );
    NtUnloadKey( &RegistryContext->HiveRootKey );
    Status = NtLoadKey( &RegistryContext->HiveRootKey, &File );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    return NO_ERROR;

}
#pragma prefast(pop)

void
RegUnloadHive(
             IN PREG_CONTEXT RegistryContext
             )
{
    NTSTATUS Status;
    HANDLE Handle;
    PREG_CONTEXT_OPEN_HIVE_KEY p, p1;

    Status = NtOpenKey( &Handle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (NT_SUCCESS( Status )) {
        NtFlushKey( Handle );
        NtClose( Handle );
    }

    p = RegistryContext->OpenHiveKeys;
    while (p) {
        RegCloseKey( p->KeyHandle );
        p1 = p;
        p = p->Next;
        HeapFree( GetProcessHeap(), 0, p1 );
    };

    do {
        Status = NtUnloadKey( &RegistryContext->HiveRootKey );
    }
    while (NT_SUCCESS( Status ) );

    NtClose( RegistryContext->HiveRootHandle );
    return;
}


void
RegRememberOpenKey(
                  IN PREG_CONTEXT RegistryContext,
                  IN HKEY KeyHandle
                  )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount += 1;
            return;
        } else {
            pp = &p->Next;
        }
    }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) );
    if (p != NULL) {
        p->KeyHandle = KeyHandle;
        p->ReferenceCount = 1;
        p->Next = NULL;
        *pp = p;
    }

    return;
}


void
RegForgetOpenKey(
                IN PREG_CONTEXT RegistryContext,
                IN HKEY KeyHandle
                )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount -= 1;
            if (p->ReferenceCount == 0) {
                *pp = p->Next;
                HeapFree( GetProcessHeap(), 0, p );
                return;
            }
        } else {
            pp = &p->Next;
        }
    }

    return;
}

BOOLEAN
RegCheckPrefix(
              IN OUT PCWSTR *s,
              IN PCWSTR Prefix,
              IN ULONG PrefixLength
              )
{
    if (PrefixLength == 0) {
        return FALSE;
    }

    if (!_wcsnicmp( *s, Prefix, PrefixLength )) {
        *s += PrefixLength;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
RegValidateKeyPath(
                  IN PREG_CONTEXT RegistryContext,
                  IN OUT PHKEY RootKeyHandle,
                  IN OUT PCWSTR *SubKeyName
                  )
{
    PCWSTR s;

    s = *SubKeyName;
    if (*RootKeyHandle == NULL) {
        if (RegCheckPrefix( &s, L"USER:", 5 ) ||
            RegCheckPrefix( &s, L"HKEY_CURRENT_USER", 17 )
           ) {
            if (RegistryContext->CurrentUserRoot == NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            if (*s == L'\\') {
                s += 1;
            } else
                if (s[-1] != L':' && *s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->CurrentUserRoot;
        } else
            if (RegCheckPrefix( &s, L"HKEY_LOCAL_MACHINE", 18 )) {
            if (*s == L'\\') {
                s += 1;
            } else
                if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->MachineRoot;
        } else
            if (RegCheckPrefix( &s, L"HKEY_USERS", 10 )) {
            if (*s == L'\\') {
                s += 1;
            } else
                if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
            }

            *RootKeyHandle = RegistryContext->UsersRoot;
        } else
            if (*s != L'\\') {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
        } else
            if (RegCheckPrefix( &s, RegistryContext->MachinePath, RegistryContext->MachinePathLength )) {
            *RootKeyHandle = RegistryContext->MachineRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (RegCheckPrefix( &s, RegistryContext->UsersPath, RegistryContext->UsersPathLength )) {
            *RootKeyHandle = RegistryContext->UsersRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (RegCheckPrefix( &s, RegistryContext->CurrentUserPath, RegistryContext->CurrentUserPathLength )) {
            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            if (*s == L'\\') {
                s += 1;
            }
        } else
            if (!_wcsicmp( *SubKeyName, L"\\Registry" )) {
            *RootKeyHandle = NULL;
        } else {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
        }
    } else
        if (*s == L'\\') {
        SetLastError( ERROR_BAD_PATHNAME );
        return FALSE;
    }

    *SubKeyName = s;
    return TRUE;
}

LONG
RTCreateKey(
           IN PREG_CONTEXT RegistryContext,
           IN HKEY RootKeyHandle,
           IN PCWSTR SubKeyName,
           IN ACCESS_MASK DesiredAccess,
           IN ULONG CreateOptions,
           IN PVOID SecurityDescriptor,
           OUT PHKEY ReturnedKeyHandle,
           OUT PULONG Disposition
           )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
    }

    if (RootKeyHandle == NULL) {
        *Disposition = REG_OPENED_EXISTING_KEY;
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
    } else
        if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
        } else
            if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
        }


        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
        } else {
            return ERROR_PATH_NOT_FOUND;
        }
    }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
            }

            p = AnsiSubKeyName;
        } else {
            p = NULL;
        }

        Error = (_Win95RegOpenKey)( RootKeyHandle, p, ReturnedKeyHandle );
        if (Error == NO_ERROR) {
            *Disposition = REG_OPENED_EXISTING_KEY;
        } else {
            Error = (_Win95RegCreateKey)( RootKeyHandle, p, ReturnedKeyHandle );
            if (Error == NO_ERROR) {
                *Disposition = REG_CREATED_NEW_KEY;
            }
        }
    } else {
        SECURITY_ATTRIBUTES SecurityAttributes;

        SecurityAttributes.nLength = sizeof( SecurityAttributes );
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttributes.bInheritHandle = FALSE;
        Error = RegCreateKeyEx( RootKeyHandle,
                                SubKeyName,
                                0,
                                NULL,
                                CreateOptions,
                                (REGSAM)DesiredAccess,
                                &SecurityAttributes,
                                ReturnedKeyHandle,
                                Disposition
                              );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

        if (Error == NO_ERROR &&
            *Disposition == REG_OPENED_EXISTING_KEY &&
            SecurityDescriptor != NULL
           ) {
            RegSetKeySecurity( *ReturnedKeyHandle,
                               DACL_SECURITY_INFORMATION,
                               SecurityDescriptor
                             );
        }
    }

    return Error;
}

LONG
RTOpenKey(
         IN PREG_CONTEXT RegistryContext,
         IN HKEY RootKeyHandle,
         IN PCWSTR SubKeyName,
         IN ACCESS_MASK DesiredAccess,
         IN ULONG OpenOptions,
         OUT PHKEY ReturnedKeyHandle
         )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
    }

    if (RootKeyHandle == NULL) {
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
    } else
        if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
        } else
            if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
        }

        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
        } else {
            return ERROR_PATH_NOT_FOUND;
        }
    }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
            }

            p = AnsiSubKeyName;
        } else {
            p = NULL;
        }

        return (_Win95RegOpenKey)( RootKeyHandle, p, ReturnedKeyHandle );
    } else {
        Error = RegOpenKeyEx( RootKeyHandle,
                              SubKeyName,
                              OpenOptions,
                              DesiredAccess,
                              ReturnedKeyHandle
                            );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

        return Error;
    }
}

LONG
RTCloseKey(
          IN PREG_CONTEXT RegistryContext,
          IN HKEY KeyHandle
          )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
    } else
        if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        return (_Win95RegCloseKey)( KeyHandle );
    } else {
        Error = RegCloseKey( KeyHandle );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegForgetOpenKey( RegistryContext, KeyHandle );
        }

        return Error;
    }
}

LONG
RTFlushKey(
          IN PREG_CONTEXT RegistryContext,
          IN HKEY KeyHandle
          )
{
    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
    } else
        if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        return (_Win95RegFlushKey)( KeyHandle );
    } else {
        return RegFlushKey( KeyHandle );
    }
}

LONG
RTEnumerateKey(
              IN PREG_CONTEXT RegistryContext,
              IN HKEY KeyHandle,
              IN ULONG Index,
              OUT PFILETIME LastWriteTime,
              IN OUT PULONG KeyNameLength,
              OUT PWSTR KeyName
              )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        if (Index == 0) {
            if (*KeyNameLength <= 7) {
                return ERROR_MORE_DATA;
            } else {
                wcscpy( KeyName, L"Machine" );
                return NO_ERROR;
            }
        } else
            if (Index == 1) {
            if (*KeyNameLength <= 5) {
                return ERROR_MORE_DATA;
            } else {
                wcscpy( KeyName, L"Users" );
                return NO_ERROR;
            }
        } else {
            return ERROR_NO_MORE_ITEMS;
        }
    } else
        if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiKeyName[ MAX_PATH ];
        ULONG AnsiKeyNameLength;

        AnsiKeyNameLength = sizeof( AnsiKeyName );
        Error = _Win95RegEnumKey( KeyHandle,
                                  Index,
                                  AnsiKeyName,
                                  AnsiKeyNameLength
                                );
        if (Error == NO_ERROR) {
            if (strlen( AnsiKeyName ) >= *KeyNameLength) {
                return ERROR_MORE_DATA;
            }

            *KeyNameLength = RegAnsiToUnicode( AnsiKeyName, KeyName, AnsiKeyNameLength );

            if (*KeyNameLength == 0) {
                return GetLastError();
            }

            RtlZeroMemory( LastWriteTime, sizeof( *LastWriteTime ) );
        }
    } else {
        Error = RegEnumKeyEx( KeyHandle,
                              Index,
                              KeyName,
                              KeyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              LastWriteTime
                            );
    }

    return Error;
}

LONG
RTEnumerateValueKey(
                   IN PREG_CONTEXT RegistryContext,
                   IN HKEY KeyHandle,
                   IN ULONG Index,
                   OUT PULONG ValueType,
                   IN OUT PULONG ValueNameLength,
                   OUT PWSTR ValueName,
                   IN OUT PULONG ValueDataLength,
                   OUT PVOID ValueData
                   )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return ERROR_NO_MORE_ITEMS;
    } else
        if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ];
        ULONG AnsiValueNameLength;
        LPSTR AnsiValueData;
        ULONG OriginalValueDataLength;

        AnsiValueNameLength = sizeof( AnsiValueName );
        OriginalValueDataLength = *ValueDataLength;
        Error = (_Win95RegEnumValue)( KeyHandle,
                                      Index,
                                      AnsiValueName,
                                      &AnsiValueNameLength,
                                      0,
                                      ValueType,
                                      ValueData,
                                      ValueDataLength
                                    );

        if (Error != NO_ERROR) {
            return Error;
        }

        if (AnsiValueNameLength >= *ValueNameLength) {
            return ERROR_MORE_DATA;
        }

        if (RegAnsiToUnicode( AnsiValueName, ValueName, AnsiValueNameLength ) == 0) {
            return GetLastError();
        }

        if (*ValueType == REG_SZ) {
            AnsiValueData = HeapAlloc( GetProcessHeap(), 0, *ValueDataLength );
            if (AnsiValueData == NULL) {
                return ERROR_OUTOFMEMORY;
            }

            RtlMoveMemory( AnsiValueData, ValueData, *ValueDataLength );
            if (RegAnsiToUnicode( AnsiValueData, (PWSTR)ValueData, *ValueDataLength ) == 0) {
                Error = GetLastError();
            } else {
                *ValueDataLength *= sizeof( WCHAR );
            }

            HeapFree( GetProcessHeap(), 0, AnsiValueData );
        }

        return Error;
    } else {
        Error = RegEnumValue( KeyHandle,
                              Index,
                              ValueName,
                              ValueNameLength,
                              NULL,
                              ValueType,
                              ValueData,
                              ValueDataLength
                            );
        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
        }

        return Error;
    }
}


LONG
RTQueryKey(
          IN PREG_CONTEXT RegistryContext,
          IN HKEY KeyHandle,
          OUT PFILETIME LastWriteTime,
          OUT PULONG NumberOfSubkeys,
          OUT PULONG NumberOfValues
          )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        if (NumberOfSubkeys != NULL) {
            *NumberOfSubkeys = 2;
        }

        if (NumberOfValues != NULL) {
            *NumberOfValues = 0;
        }

        return NO_ERROR;
    } else
        if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        Error = (_Win95RegQueryInfoKey)( KeyHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NumberOfSubkeys,
                                         NULL,
                                         NULL,
                                         NumberOfValues,
                                         NULL,
                                         NULL,
                                         NULL,
                                         (PVOID)LastWriteTime
                                       );
    } else {
        Error = RegQueryInfoKey( KeyHandle,             // hKey,
                                 NULL,                  // lpClass,
                                 NULL,                  // lpcbClass,
                                 NULL,                  // lpReserved,
                                 NumberOfSubkeys,       // lpcSubKeys,
                                 NULL,                  // lpcbMaxSubKeyLen,
                                 NULL,                  // lpcbMaxClassLen,
                                 NumberOfValues,        // lpcValues,
                                 NULL,                  // lpcbMaxValueNameLen,
                                 NULL,                  // lpcbMaxValueLen,
                                 NULL,                  // lpcbSecurityDescriptor,
                                 LastWriteTime          // lpftLastWriteTime
                               );
    }

    return Error;
}

LONG
RTQueryValueKey(
               IN PREG_CONTEXT RegistryContext,
               IN HKEY KeyHandle,
               IN PWSTR ValueName,
               OUT PULONG ValueType,
               IN OUT PULONG ValueDataLength,
               OUT PVOID ValueData
               )
{
    LONG Error;

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
            }

            p = AnsiValueName;
        } else {
            p = NULL;
        }

        OriginalValueDataLength = *ValueDataLength;
        Error = (_Win95RegQueryValueEx)( KeyHandle,
                                         p,
                                         NULL,
                                         ValueType,
                                         ValueData,
                                         ValueDataLength
                                       );
        if (Error == NO_ERROR && *ValueType == REG_SZ) {
            if ((*ValueDataLength * sizeof( WCHAR )) > OriginalValueDataLength) {
                return ERROR_MORE_DATA;
            }

            p = HeapAlloc( GetProcessHeap(), 0, *ValueDataLength );
            if (p == NULL) {
                return ERROR_OUTOFMEMORY;
            }

            RtlMoveMemory( p, ValueData, *ValueDataLength );
            if (RegAnsiToUnicode( (LPCSTR)p, (PWSTR)ValueData, *ValueDataLength ) == 0) {
                Error = GetLastError();
            } else {
                *ValueDataLength *= sizeof( WCHAR );
                *ValueDataLength += sizeof( UNICODE_NULL );
            }

            HeapFree( GetProcessHeap(), 0, p );
        }
    } else {
        Error = RegQueryValueEx( KeyHandle,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 ValueData,
                                 ValueDataLength
                               );

        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
        }
    }

    return Error;
}

LONG
RTSetValueKey(
             IN PREG_CONTEXT RegistryContext,
             IN HKEY KeyHandle,
             IN PWSTR ValueName,
             IN ULONG ValueType,
             IN ULONG ValueDataLength,
             IN PVOID ValueData
             )
{
    LONG Error;

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;
        LPSTR AnsiValueData;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
            }

            p = AnsiValueName;
        } else {
            p = NULL;
        }

        if (ValueType == REG_SZ) {
            AnsiValueData = HeapAlloc( GetProcessHeap(), 0, ValueDataLength * 2 );
            if (AnsiValueData == NULL) {
                return ERROR_OUTOFMEMORY;
            }

            ValueDataLength = RegUnicodeToAnsi( ValueData, AnsiValueData, ValueDataLength );
            if (ValueDataLength == 0) {
                return GetLastError();
            }

            ValueData = AnsiValueData;
        } else {
            AnsiValueData = NULL;
        }

        Error = (_Win95RegSetValueEx)( KeyHandle,
                                       p,
                                       0,
                                       ValueType,
                                       ValueData,
                                       ValueDataLength
                                     );

        if (AnsiValueData != NULL) {
            HeapFree( GetProcessHeap(), 0, AnsiValueData );
        }

        if (p != NULL) {
            HeapFree( GetProcessHeap(), 0, p );
        }
    } else {
        Error = RegSetValueEx( KeyHandle,
                               ValueName,
                               0,
                               ValueType,
                               ValueData,
                               ValueDataLength
                             );
    }

    return Error;
}

LONG
RTDeleteKey(
           IN PREG_CONTEXT RegistryContext,
           IN HKEY KeyHandle,
           IN PCWSTR SubKeyName
           )
{
    if (!RegValidateKeyPath( RegistryContext, &KeyHandle, &SubKeyName )) {
        return GetLastError();
    }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
            }

            p = AnsiSubKeyName;
        } else {
            p = NULL;
        }

        return (_Win95RegDeleteKey)( KeyHandle, p );
    } else {
        return RegDeleteKey( KeyHandle, SubKeyName );
    }
}


LONG
RTDeleteValueKey(
                IN PREG_CONTEXT RegistryContext,
                IN HKEY KeyHandle,
                IN PWSTR ValueName
                )
{
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;
        LPSTR AnsiValueData;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
            }

            p = AnsiValueName;
        } else {
            p = NULL;
        }

        return (_Win95RegDeleteValue)( KeyHandle,
                                       p
                                     );
    } else {
        return RegDeleteValue( KeyHandle, ValueName );
    }
}


LONG
RTLoadAsciiFileAsUnicode(
                        IN PWSTR FileName,
                        OUT PREG_UNICODE_FILE UnicodeFile
                        )
{
    LONG Error = NO_ERROR;
    HANDLE File;
    DWORD FileSize;
    DWORD CharsInFile;
    DWORD BytesRead;
    DWORD BufferSize, i, i1, LineCount, DeferredLineCount;
    PVOID BufferBase;
    PWSTR Src, Src1, Dst;

    File = CreateFile( FileName,
                       FILE_GENERIC_READ,
                       FILE_SHARE_DELETE |
                       FILE_SHARE_READ |
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                     );
    if (File == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    FileSize = GetFileSize( File, NULL );
    if (FileSize == INVALID_FILE_SIZE) {
        CloseHandle( File );
        return GetLastError();
    }

    BufferSize = FileSize * sizeof( WCHAR );
    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    BufferBase = VirtualAlloc( NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (BufferBase != NULL) {
        if (ReadFile( File, BufferBase, FileSize, &BytesRead, NULL )) {
            if (BytesRead != FileSize) {
                Error = ERROR_HANDLE_EOF;
            } else
                if (!GetFileTime( File, NULL, NULL, &UnicodeFile->LastWriteTime )) {
                Error = GetLastError();
            } else {
                Error = NO_ERROR;
            }
        }

        if (Error != NO_ERROR) {
            VirtualFree( BufferBase, 0, MEM_RELEASE );
        }
    } else {
        Error = GetLastError();
    }

    CloseHandle( File );
    if (Error != NO_ERROR) {
        return Error;
    }

    Src = (PWSTR)BufferBase;

    if (!IsTextUnicode( BufferBase, FileSize, NULL )) {
        RtlMoveMemory( (PCHAR)BufferBase + FileSize, BufferBase, FileSize );
        CharsInFile = RegAnsiToUnicode( (PCHAR)BufferBase + FileSize, BufferBase, FileSize );
        if (CharsInFile == 0) {
            return GetLastError();
        }
    } else {
        CharsInFile = FileSize / sizeof( WCHAR );

        //
        // Skip ByteOrderMark
        //
        if (Src[0] == 0xfeff || Src[0] == 0xfffe) {
            Src++;
            CharsInFile--;
        }
    }

    DeferredLineCount = 0;
    Dst = (PWSTR)BufferBase;

    i = 0;

    //
    // Now loop over the in memory copy of the file, collapsing all carriage 
    // return line feed pairs into just new lines, and removing all line 
    // continuation characters and the spaces that surround them.  This lets
    // RTParseNextLine see a single line for each Key Name or Value input, 
    // terminated by a new line character.
    //
    while (i < CharsInFile) {
        //
        // See if we just went over a line continuation character
        //
        if (i > 0 && Src[-1] == L'\\' && (*Src == L'\r' || *Src == L'\n')) {
            //
            // Move back over the line continuation we just copied the previous iteration
            //
            if (Dst[-1] == L'\\') {
                --Dst;
            }

            //
            // Move back over all but one of any space characters that preceed
            // the line continuation character.  The may be none, in which case
            // we leave it be, as the user must want no space
            //
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                }
                Dst -= 1;
            }

            //
            // Leave one space, if there is one
            //
            if (Dst[0] == L' ') {
                Dst += 1;
            }

            //
            // Now, skip over the new line after the line continuation.  We
            // actually will skip over any number of them, keeping count so
            // we can update the source file line number correctly.
            //
            LineCount = 0;
            while (i < CharsInFile) {
                if (*Src == L'\n') {
                    i++;
                    Src++;
                    LineCount++;
                } else
                    if (*Src == L'\r' &&
                        (i+1) < CharsInFile &&
                        Src[ 1 ] == L'\n'
                       ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                } else {
                    break;
                }
            }

            //
            // If we saw more than just new line after the line continuation
            // character, then put them back into the destination as just
            // new lines, without any carriage returns.
            //
            if (LineCount > 1) {
                DeferredLineCount += LineCount;
                while (DeferredLineCount) {
                    DeferredLineCount -= 1;
                    *Dst++ = L'\n';
                }
            } else {
                DeferredLineCount += 1;

                //
                // Skip leading spaces of next line of continuation

                while (i < CharsInFile && (*Src == L' ' || *Src == L'\t')) {
                    i++;
                    Src++;
                }
            }

            //
            // All done if we hit the end of the file
            //
            if (i >= CharsInFile) {
                break;
            }
        } else
            if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
            while (TRUE) {
                while (i < CharsInFile && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                }
                Src1 = Src;
                i1 = i;
                while (i1 < CharsInFile && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                }
                if (i1 < CharsInFile &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                } else {
                    break;
                }
            }

            while (DeferredLineCount) {
                DeferredLineCount -= 1;
                *Dst++ = L'\n';
            }
            *Dst++ = L'\n';
        } else {
            i++;
            *Dst++ = *Src++;
        }
    }

    //
    // Make sure line ends with a CRLF sequence.
    //
    while (DeferredLineCount) {
        DeferredLineCount -= 1;
        *Dst++ = L'\n';
    }
    *Dst++ = L'\n';
    *Dst = UNICODE_NULL;
    UnicodeFile->FileName = FileName;
    UnicodeFile->FileContents = BufferBase;
    UnicodeFile->EndOfFile = Dst;
    UnicodeFile->NextLine = BufferBase;
    UnicodeFile->NextLineNumber = 1;

    return NO_ERROR;
}

void
RTUnloadUnicodeFile(
                   IN OUT PREG_UNICODE_FILE UnicodeFile
                   )
{
    VirtualFree( UnicodeFile->FileContents, 0, MEM_RELEASE );
    return;
}

#define ACL_LIST_START L'['
#define ACL_LIST_END L']'

BOOLEAN
RegGetMultiString(
                 IN BOOLEAN BackwardsCompatibleInput,
                 IN OUT PWSTR *ValueString,
                 IN OUT PWSTR *ValueData,
                 IN ULONG MaximumValueLength,
                 IN OUT PULONG ValueLength
                 );


BOOLEAN
RegReadMultiSzFile(
                  IN OUT PREG_UNICODE_PARSE ParsedLine,
                  IN BOOLEAN BackwardsCompatibleInput,
                  IN PWSTR FileName,
                  IN OUT PVOID ValueData,
                  IN OUT PULONG ValueLength
                  );

BOOLEAN
RegReadBinaryFile(
                 IN OUT PREG_UNICODE_PARSE ParsedLine,
                 IN PWSTR FileName,
                 IN OUT PVOID ValueData,
                 IN OUT PULONG ValueLength
                 );

BOOLEAN
RTParseNextLine(
               IN OUT PREG_UNICODE_FILE UnicodeFile,
               OUT PREG_UNICODE_PARSE ParsedLine
               )
{
    PWSTR BeginLine, EqualSign, AclBracket, AclStart, s, s1;
    WCHAR QuoteChar;

    if (ParsedLine->IsKeyName && ParsedLine->SecurityDescriptor) {
        RegDestroySecurity( ParsedLine->SecurityDescriptor );
    }

    RtlZeroMemory( ParsedLine, sizeof( *ParsedLine ) );
    while (TRUE) {
        if (!(s = UnicodeFile->NextLine)) {
            ParsedLine->AtEndOfFile = TRUE;
            return FALSE;
        }
        UnicodeFile->NextLine = NULL;
        if (*s == UNICODE_NULL) {
            ParsedLine->AtEndOfFile = TRUE;
            return FALSE;
        }

        while (*s <= L' ') {
            if (*s == L' ') {
                ParsedLine->IndentAmount += 1;
            } else
                if (*s == L'\t') {
                ParsedLine->IndentAmount = ((ParsedLine->IndentAmount + 8) -
                                            (ParsedLine->IndentAmount % 8)
                                           );
            }

            if (++s >= UnicodeFile->EndOfFile) {
                ParsedLine->AtEndOfFile = TRUE;
                return FALSE;
            }
        }

        BeginLine = s;
        EqualSign = NULL;
        AclBracket = NULL;
        if (!UnicodeFile->BackwardsCompatibleInput && *s == L';') {
            while (s < UnicodeFile->EndOfFile) {
                if (*s == L'\n') {
                    do {
                        UnicodeFile->NextLineNumber += 1;
                        *s++ = UNICODE_NULL;
                    }
                    while (*s == L'\n');
                    break;
                } else {
                    s += 1;
                }
            }

            BeginLine = s;
            UnicodeFile->NextLine = s;
        } else
            if (*s != '\n') {

            //
            // If not being backward compatible, see if the first thing on
            // the line is the beginning of a quoted string.
            //

            if (!UnicodeFile->BackwardsCompatibleInput && (*s == L'"' || *s == L'\'')) {
                //
                // Yes, it is either a quoted key name or value name.  Find the
                // the trailing quote.  Specifically do NOT support quotes inside
                // a quoted string, other than a different kind.  Which means unless
                // you want both types of quoted characters within the same name
                // you wont care.
                //
                QuoteChar = *s++;
                BeginLine += 1;
                while (s < UnicodeFile->EndOfFile && *s != QuoteChar) {
                    s += 1;
                }

                //
                // If trailing quote not found, then return an error
                //
                if (*s != QuoteChar) {
                    ParsedLine->ParseFailureReason = ParseFailInvalidQuoteCharacter;
                    return FALSE;
                }

                //
                // Mark the end of the name and move past the trailing quote
                //
                *s++ = UNICODE_NULL;
            }

            //
            // Now scan forward looking for one of the following:
            //
            //      equal sign - this would mean the stuff to the left
            //          of the equal sign is a value name and the stuff
            //          to the right is the value type and data.
            //
            //      left square bracket - this would mean the stuff to the
            //          left of the square bracket is a key name and the
            //          stuff to the right is the security descriptor information
            //
            //      end of line - this would mean the stuff to the left
            //          is a key name, with no security descriptor.
            //

            while (s < UnicodeFile->EndOfFile) {
                if (*s == L'=') {
                    //
                    // We found an equal sign, so value name is to the left
                    // and value type and data follows.
                    //
                    EqualSign = s;

                    //
                    // Ignore any left square bracket we might have seen
                    // in before this.  It must have been part of the value
                    // name.
                    AclBracket = NULL;

                    //
                    // All done scanning
                    //
                    break;
                } else
                    if (*s == ACL_LIST_START) {
                    //
                    // We found a left square bracket.  Keep scanning
                    // in case there is an equal sign later.
                    //
                    AclBracket = s;
                    s += 1;
                } else
                    if (*s == L'\n') {
                    //
                    // We found end of line, so key name is to the left.
                    // Update where to start next time we are called.
                    //
                    UnicodeFile->NextLine = s + 1;
                    break;
                } else
                    if (*s == L'\t') {
                    //
                    // Convert imbedded hard tabs to single spaces
                    //
                    *s++ = L' ';
                } else {
                    //
                    // Nothing interesting, keep looking.
                    //
                    s += 1;
                }
            }

            //
            // Trim any trailing spaces off the end of what is to the
            // left of where we are.  The make sure we stop looking
            // if we see the null character put down over the trailing
            // quote character above, if any.
            //
            *s = UNICODE_NULL;
            while (s > BeginLine && *--s <= L' ' && *s) {
                *s = UNICODE_NULL;
            }

            //
            // BeginLine now points to either the null terminated value
            // name or key name.  EqualSign, if non-null, points to the
            // equal sign, so scan forward and find the terminating new line,
            // and store a null there to terminate the input.  Otherwise,
            // we already stored a null over the terminating new line above.
            //
            if (EqualSign != NULL) {
                s = EqualSign + 1;
                while (s < UnicodeFile->EndOfFile) {
                    if (*s == '\n') {
                        *s = UNICODE_NULL;
                        break;
                    }

                    s += 1;
                }

                //
                // Update where we should start next time we are called.
                //
                UnicodeFile->NextLine = s + 1;
            } else
                if (AclBracket != NULL) {
                //
                // Since we did not stop on the AclBracket, go back an
                // clobber it and any spaces before it.
                //
                s = AclBracket;
                *s = UNICODE_NULL;
                while (s > BeginLine && *--s <= L' ' && *s) {
                    *s = UNICODE_NULL;
                }
            }

            //
            // Tell them which line number and where the line begins
            //
            ParsedLine->LineNumber = UnicodeFile->NextLineNumber;
            UnicodeFile->NextLineNumber += 1;
            ParsedLine->BeginLine = BeginLine;

            //
            // Now handle value or key semantics
            //
            if (EqualSign != NULL) {
                //
                // We have ValueName = ValueType ValueData
                //

                //
                // Value name is the beginning of the line, unless
                // it was the special symbol or null
                //
                if (*BeginLine != L'@' && BeginLine != EqualSign) {
                    ParsedLine->ValueName = BeginLine;
                }

                //
                // Skip any blanks after the equal sign.
                //
                while (*++EqualSign && *EqualSign <= L' ') {
                }

                //
                // If all that is left is the DELETE keyword, then
                // tell the caller
                //
                if (!_wcsicmp( L"DELETE", EqualSign )) {
                    ParsedLine->DeleteValue = TRUE;
                    return TRUE;
                } else {
                    //
                    // Otherwise parse the data after the equal sign.
                    //
                    ParsedLine->ValueString = EqualSign;
                    return RTParseValueData( UnicodeFile,
                                             ParsedLine,
                                             ValueBuffer,
                                             ValueBufferSize,
                                             &ParsedLine->ValueType,
                                             &ParsedLine->ValueData,
                                             &ParsedLine->ValueLength
                                           );
                }
            } else {
                //
                // We have a key name.  Tell the caller and handle any
                // security descriptor info if present.
                //
                ParsedLine->IsKeyName = TRUE;
                ParsedLine->KeyName = BeginLine;
                if (AclBracket != NULL) {
                    //
                    // We have found an ACL name
                    //
                    AclStart = ++AclBracket;
                    ParsedLine->AclString = AclStart;
                    while (*AclBracket != UNICODE_NULL && *AclBracket != ACL_LIST_END) {
                        AclBracket += 1;
                    }
                    if (*AclBracket != ACL_LIST_END) {
                        return FALSE;
                    }

                    *AclBracket = UNICODE_NULL;
                    if (!_wcsicmp( L"DELETE", AclStart )) {
                        ParsedLine->DeleteKey = TRUE;
                    } else {
                        ParsedLine->SecurityDescriptor = &ParsedLine->SecurityDescriptorBuffer;
                        if (!RegCreateSecurity( AclStart, ParsedLine->SecurityDescriptor )) {
                            ParsedLine->SecurityDescriptor = NULL;
                            return FALSE;
                        }
                    }
                }

                return TRUE;
            }
        } else {
            UnicodeFile->NextLineNumber += 1;
        }
    }

    return FALSE;
}

BOOLEAN
RTParseValueData(
                IN OUT PREG_UNICODE_FILE UnicodeFile,
                IN OUT PREG_UNICODE_PARSE ParsedLine,
                IN PVOID ValueBuffer,
                IN ULONG ValueBufferSize,
                OUT PULONG ValueType,
                OUT PVOID *ValueData,
                OUT PULONG ValueLength
                )
{
    PWSTR ValueString;
    ULONG PrefixLength = 0, MaximumValueLength;
    PULONG p;
    PWSTR s, Src, Dst;
    ULONG i, n, cchValue;
    BOOLEAN BackwardsCompatibleInput = FALSE;
    BOOLEAN GetDataFromBinaryFile = FALSE;
    BOOLEAN GetDataFromMultiSzFile = FALSE;
    BOOLEAN ParseDateTime = FALSE;

    if (UnicodeFile != NULL) {
        BackwardsCompatibleInput = UnicodeFile->BackwardsCompatibleInput;
    }
    ValueString = ParsedLine->ValueString;
    *ValueData = NULL;
    *ValueLength = 0;
    *ValueType = REG_SZ;
    for (i=0; RegTypeNameTable[i].TypeName != NULL; i++) {
        PrefixLength = wcslen( RegTypeNameTable[i].TypeName );
        if (ValueString[ PrefixLength ] <= L' ' &&
            !_wcsnicmp( RegTypeNameTable[i].TypeName,
                        ValueString,
                        PrefixLength
                      )
           ) {
            *ValueType = RegTypeNameTable[i].ValueType;
            GetDataFromBinaryFile = RegTypeNameTable[i].GetDataFromBinaryFile;
            GetDataFromMultiSzFile = RegTypeNameTable[i].GetDataFromMultiSzFile;
            ParseDateTime = RegTypeNameTable[i].ParseDateTime;
            break;
        }
    }

    if (RegTypeNameTable[i].TypeName != NULL) {
        ValueString += PrefixLength;
        while (*ValueString != UNICODE_NULL && *ValueString <= L' ') {
            ValueString += 1;
        }
    }

    if (GetDataFromMultiSzFile) {
        *ValueData = ValueBuffer;
        *ValueLength = ValueBufferSize;
        return RegReadMultiSzFile( ParsedLine,
                                   BackwardsCompatibleInput,
                                   ValueString,
                                   ValueBuffer,
                                   ValueLength
                                 );
    }

    if (GetDataFromBinaryFile) {
        *ValueData = ValueBuffer;
        *ValueLength = ValueBufferSize;
        return RegReadBinaryFile( ParsedLine,
                                  ValueString,
                                  ValueBuffer,
                                  ValueLength
                                );
    }

    cchValue = wcslen( ValueString );
    Src = ValueString;
    switch ( *ValueType ) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            //
            // Strip off any surrounding quote characters
            //
            if (cchValue > 1 && Src[ 0 ] == Src[ cchValue - 1 ] &&
                (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
               ) {
                Src += 1;
                cchValue -= 2;
            }

            //
            // Fall through after stripping any quotes.
            //

        case REG_LINK:
            *ValueLength = (cchValue + 1) * sizeof( WCHAR );
            if (*ValueLength > ValueBufferSize) {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
                return FALSE;
            }
            *ValueData = ValueBuffer;
            RtlMoveMemory( *ValueData, Src, *ValueLength );
            *((PWSTR)*ValueData + cchValue) = UNICODE_NULL;
            return TRUE;

        case REG_DWORD:
            *ValueData = ValueBuffer;
            *ValueLength = sizeof( ULONG );
            for (i=0; RegValueNameTable[i].ValueName != NULL; i++) {
                PrefixLength = wcslen( RegValueNameTable[i].ValueName );
                if (!_wcsnicmp( RegValueNameTable[i].ValueName,
                                ValueString,
                                PrefixLength
                              )
                   ) {
                    *(PULONG)*ValueData = RegValueNameTable[i].Value;
                    return TRUE;
                }
            }
            return RegUnicodeToDWORD( &Src, 0, (PULONG)*ValueData );

        case REG_BINARY:
            if (ParseDateTime) {
#define NUMBER_DATE_TIME_FIELDS 6
                ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
                //
                // Month/Day/Year HH:MM DayOfWeek
                //

                ULONG CurrentField = 0;
                PCSHORT Fields;
                TIME_FIELDS DateTimeFields;
                PWSTR Field;
                ULONG FieldValue;

                RtlZeroMemory( &DateTimeFields, sizeof( DateTimeFields ) );
                Fields = &DateTimeFields.Year;
                while (cchValue) {
                    if (CurrentField >= 7) {
                        return ( FALSE );
                    }

                    while (cchValue && *Src == L' ') {
                        cchValue--;
                        Src += 1;
                    }

                    Field = Src;
                    while (cchValue) {
                        if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                        } else
                            if (*Src < L'0' || *Src > L'9') {
                            break;
                        }

                        cchValue--;
                        Src += 1;
                    }

                    if (cchValue) {
                        cchValue--;
                        Src += 1;
                    }

                    if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                        if (cchValue < 3) {
                            SetLastError( ERROR_INVALID_PARAMETER );
                            ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                            return FALSE;
                        }

                        if (DateTimeFields.Year != 0) {
                            SetLastError( ERROR_INVALID_PARAMETER );
                            ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                            return FALSE;
                        }

                        if (!_wcsnicmp( Field, L"SUN", 3 )) {
                            FieldValue = 0;
                        } else
                            if (!_wcsnicmp( Field, L"MON", 3 )) {
                            FieldValue = 1;
                        } else
                            if (!_wcsnicmp( Field, L"TUE", 3 )) {
                            FieldValue = 2;
                        } else
                            if (!_wcsnicmp( Field, L"WED", 3 )) {
                            FieldValue = 3;
                        } else
                            if (!_wcsnicmp( Field, L"THU", 3 )) {
                            FieldValue = 4;
                        } else
                            if (!_wcsnicmp( Field, L"FRI", 3 )) {
                            FieldValue = 5;
                        } else
                            if (!_wcsnicmp( Field, L"SAT", 3 )) {
                            FieldValue = 6;
                        } else {
                            SetLastError( ERROR_INVALID_PARAMETER );
                            return FALSE;
                        }
                    } else
                        if (!RegUnicodeToDWORD( &Field, 0, &FieldValue )) {
                        ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                        return FALSE;
                    }

                    Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
                }

                if (DateTimeFields.Year == 0) {
                    if (DateTimeFields.Day > 5) {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                        return FALSE;
                    }
                } else
                    if (DateTimeFields.Year < 100) {
                    DateTimeFields.Year += 1900;
                }

                *ValueLength = sizeof( DateTimeFields );
                if (*ValueLength > ValueBufferSize) {
                    SetLastError( ERROR_BUFFER_OVERFLOW );
                    ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
                    return FALSE;
                }
                *ValueData = ValueBuffer;
                RtlMoveMemory( *ValueData, &DateTimeFields, sizeof( DateTimeFields ) );
                return TRUE;
            }

        case REG_RESOURCE_LIST:
        case REG_RESOURCE_REQUIREMENTS_LIST:
        case REG_FULL_RESOURCE_DESCRIPTOR:
        case REG_NONE:
            if (!RegUnicodeToDWORD( &Src, 0, ValueLength )) {
                ParsedLine->ParseFailureReason = ParseFailBinaryDataLengthMissing;
                return FALSE;
            }

            if (*ValueLength >= ValueBufferSize) {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
                return FALSE;
            }

            //
            // Calculate number of DWORD's of data based on specified byte count
            //
            n = (*ValueLength + sizeof( ULONG ) - 1) / sizeof( ULONG );

            //
            // Store converted binary data in ValueBuffer
            //
            *ValueData = ValueBuffer;
            p = ValueBuffer;

            //
            // Src points to remaining text to convert.
            //
            while (n--) {
                if (!RegUnicodeToDWORD( &Src, 0, p )) {
                    if (BackwardsCompatibleInput) {
                        Src = UnicodeFile->NextLine;
                        s = Src;
                        while (TRUE) {
                            if (*s == '\n') {
                                *s = UNICODE_NULL;
                                UnicodeFile->NextLineNumber += 1;
                                break;
                            } else
                                if (s >= UnicodeFile->EndOfFile || *s == UNICODE_NULL) {
                                UnicodeFile->NextLine = NULL;
                                ParsedLine->ParseFailureReason = ParseFailBinaryDataNotEnough;
                                SetLastError( ERROR_MORE_DATA );
                                return FALSE;
                            } else {
                                break;
                            }
                        }

                        UnicodeFile->NextLine = s + 1;
                        n += 1;
                    } else {
                        if (p == ValueBuffer) {
                            ParsedLine->ParseFailureReason = ParseFailBinaryDataOmitted;
                            SetLastError( ERROR_NO_DATA );
                        } else {
                            ParsedLine->ParseFailureReason = ParseFailBinaryDataNotEnough;
                            SetLastError( ERROR_MORE_DATA );
                        }

                        return FALSE;
                    }
                } else {
                    p += 1;
                }
            }
            return TRUE;

        case REG_MULTI_SZ:
            *ValueLength = 0;
            *ValueData = ValueBuffer;
            MaximumValueLength = ValueBufferSize;
            Dst = *ValueData;
            while (RegGetMultiString( BackwardsCompatibleInput,
                                      &Src,
                                      &Dst,
                                      MaximumValueLength,
                                      ValueLength
                                    )
                  ) {
            }

            if (GetLastError() == NO_ERROR) {
                return TRUE;
            } else {
                ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
                return FALSE;
            }
            break;

        case REG_QWORD:
            *ValueData = ValueBuffer;
            *ValueLength = sizeof( DWORDLONG );
            for (i=0; RegValueNameTable[i].ValueName != NULL; i++) {
                PrefixLength = wcslen( RegValueNameTable[i].ValueName );
                if (!_wcsnicmp( RegValueNameTable[i].ValueName,
                                ValueString,
                                PrefixLength
                              )
                   ) {
                    *(PDWORDLONG)*ValueData = RegValueNameTable[i].Value;
                    return TRUE;
                }
            }
            return RegUnicodeToQWORD( &Src, 0, (PDWORDLONG)*ValueData );

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ParsedLine->ParseFailureReason = ParseFailInvalidRegistryType;
            return FALSE;
    }

}

BOOLEAN
RegGetMultiString(
                 IN BOOLEAN BackwardsCompatibleInput,
                 IN OUT PWSTR *ValueString,
                 IN OUT PWSTR *ValueData,
                 IN ULONG MaximumValueLength,
                 IN OUT PULONG ValueLength
                 )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           ValueData: foo

Arguments:

    BackwardsCompatibleInput - TRUE if supporting old format input

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    ValueData - Supplies the location where the removed multi-string is
                to be stored.
              - Returns the location to the first byte after the returned
                multi-string

    MaximumValueLength - Supplies the maximum length of data that can be
                         stored in ValueData.

    ValueLength - Supplies a pointer to the current length of data stored
                  in ValueData.
                - Returns the size of the


Return Value:

    TRUE if successful and FALSE if not.

--*/

{
    PWSTR Src, Dst;
    ULONG n;
    BOOLEAN Result;

    //
    // Find the first quote mark.
    //
    Src = *ValueString;
    while (*Src != UNICODE_NULL && *Src != L'"') {
        Src += 1;
    }

    Dst = *ValueData;
    if (*Src == UNICODE_NULL) {
        SetLastError( NO_ERROR );
        Result = FALSE;
    } else {
        //
        // We have found the start of the multi-string.  Now find the end,
        // building up our return ValueData as we go.
        //

        Src += 1;
        while (*Src != UNICODE_NULL) {
            if (*Src == L'"') {
                if (!BackwardsCompatibleInput &&
                    Src[1] == L'"'
                   ) {
                    Src += 1;
                } else {
                    *Src++ = UNICODE_NULL;
                    break;
                }
            }

            *ValueLength += sizeof( WCHAR );
            if (*ValueLength >= MaximumValueLength) {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                return FALSE;
            }

            *Dst++ = *Src++;
        }

        Result = TRUE;
    }

    *ValueLength += sizeof( WCHAR );
    if (*ValueLength >= MaximumValueLength) {
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
    }

    *Dst++ = UNICODE_NULL;
    *ValueData = Dst;
    *ValueString = Src;
    return Result;
}


BOOLEAN
RegReadMultiSzFile(
                  IN OUT PREG_UNICODE_PARSE ParsedLine,
                  IN BOOLEAN BackwardsCompatibleInput,
                  IN PWSTR FileName,
                  IN OUT PVOID ValueData,
                  IN OUT PULONG ValueLength
                  )
{
    PWSTR Src, Dst;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MaximumValueLength;
    BOOLEAN Result;

    if (!RTLoadAsciiFileAsUnicode( FileName, &MultiSzFile )) {
        ParsedLine->ParseFailureReason = ParseFailUnableToAccessFile;
        return FALSE;
    }

    MaximumValueLength = *ValueLength;
    *ValueLength = 0;
    Src = MultiSzFile.NextLine;
    Dst = ValueData;
    while (RegGetMultiString( BackwardsCompatibleInput,
                              &Src,
                              &Dst,
                              MaximumValueLength,
                              ValueLength
                            )
          ) {
    }

    if (GetLastError() == NO_ERROR) {
        Result = TRUE;
    } else {
        ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
        Result = FALSE;
    }

    RTUnloadUnicodeFile( &MultiSzFile );

    return Result;
}

BOOLEAN
RegReadBinaryFile(
                 IN OUT PREG_UNICODE_PARSE ParsedLine,
                 IN PWSTR FileName,
                 IN OUT PVOID ValueData,
                 IN OUT PULONG ValueLength
                 )
{
    BOOLEAN Result;
    HANDLE File;
    DWORD FileSize, FileSizeHigh;
    DWORD BytesRead;

    File = CreateFile( FileName,
                       FILE_GENERIC_READ,
                       FILE_SHARE_DELETE |
                       FILE_SHARE_READ |
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                     );
    if (File == INVALID_HANDLE_VALUE) {
        ParsedLine->ParseFailureReason = ParseFailUnableToAccessFile;
        return FALSE;
    }

    ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
    FileSize = GetFileSize( File, &FileSizeHigh );
    if (FileSizeHigh != 0 ||
        FileSize == INVALID_FILE_SIZE ||
        FileSize >= *ValueLength
       ) {
        CloseHandle( File );
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
    }

    Result = FALSE;
    if (ReadFile( File, ValueData, FileSize, &BytesRead, NULL )) {
        if (BytesRead != FileSize) {
            SetLastError( ERROR_HANDLE_EOF );
        } else {
            ParsedLine->ParseFailureReason = ParseFailNoFailure;
            *ValueLength = FileSize;
            Result = TRUE;
        }
    }

    CloseHandle( File );
    return Result;
}


BOOLEAN
NeedQuotedString(
                PWSTR Name,
                PWSTR Value,
                PWCHAR QuoteChar
                )
{
    ULONG i;

    if (Name != NULL) {
        if (*Name != UNICODE_NULL &&
            (*Name == L' ' || Name[ wcslen( Name ) - 1 ] == L' ')
           ) {
            *QuoteChar = '"';
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        i = wcslen( Value ) - 1;
        if (*Value != UNICODE_NULL) {
            if ((*Value == L' ' || Value[ i ] == L' ' || Value[ i ] == L'\\')) {
                *QuoteChar = '"';
                return TRUE;
            } else
                if (*Value == L'"' && Value[ i ] == L'"') {
                *QuoteChar = '\'';
                return TRUE;
            } else
                if (*Value == L'\'' && Value[ i ] == L'\'') {
                *QuoteChar = '"';
                return TRUE;
            }
        }

        return FALSE;
    }
}

void
RTFormatKeyName(
               PREG_OUTPUT_ROUTINE OutputRoutine,
               PVOID OutputRoutineParameter,
               ULONG IndentLevel,
               PWSTR KeyName
               )
{
    PWSTR pw;
    WCHAR QuoteChar;

    if (NeedQuotedString( KeyName, NULL, &QuoteChar )) {
        (OutputRoutine)( OutputRoutineParameter,
                         "%.*s%c%ws%c",
                         IndentLevel,
                         BlanksForPadding,
                         QuoteChar,
                         KeyName,
                         QuoteChar
                       );
    } else {
        (OutputRoutine)( OutputRoutineParameter,
                         "%.*s%ws",
                         IndentLevel,
                         BlanksForPadding,
                         KeyName
                       );
    }

    return;
}

void
RTFormatKeySecurity(
                   PREG_OUTPUT_ROUTINE OutputRoutine,
                   PVOID OutputRoutineParameter,
                   HKEY KeyHandle,
                   PSECURITY_DESCRIPTOR SecurityDescriptor
                   )
{
    ULONG SecurityBufferLength;
    BOOLEAN FormattedAces;
    WCHAR AceList[ 256 ];

    FormattedAces = FALSE;
    if (KeyHandle != NULL) {
        SecurityBufferLength = 0;
        if (RegGetKeySecurity( KeyHandle,
                               DACL_SECURITY_INFORMATION,
                               SecurityDescriptor,
                               &SecurityBufferLength
                             ) == ERROR_INSUFFICIENT_BUFFER ) {
            SecurityDescriptor = (PSECURITY_DESCRIPTOR)HeapAlloc( GetProcessHeap(),
                                                                  0,
                                                                  SecurityBufferLength
                                                                );

            if (SecurityDescriptor) {
                if (RegGetKeySecurity( KeyHandle,
                                       DACL_SECURITY_INFORMATION,
                                       SecurityDescriptor,
                                       &SecurityBufferLength
                                     ) != NO_ERROR ) {
                    HeapFree( GetProcessHeap(), 0, SecurityDescriptor );
                } else {
                    FormattedAces = RegFormatSecurity( SecurityDescriptor, AceList );
                    HeapFree( GetProcessHeap(), 0, SecurityDescriptor );
                }
            }
        }
    } else
        if (SecurityDescriptor != NULL) {
        FormattedAces = RegFormatSecurity( SecurityDescriptor, AceList );
    }

    if (FormattedAces) {
        (OutputRoutine)( OutputRoutineParameter,
                         " %wc%ws%wc",
                         ACL_LIST_START,
                         AceList,
                         ACL_LIST_END
                       );
    }

    return;
}

void
RegDisplayResourceListAsComment(
                               ULONG OutputWidth,
                               PREG_OUTPUT_ROUTINE OutputRoutine,
                               PVOID OutputRoutineParameter,
                               ULONG IndentLevel,
                               ULONG ValueLength,
                               ULONG ValueType,
                               PWSTR ValueData
                               );

void
RTFormatKeyValue(
                ULONG OutputWidth,
                PREG_OUTPUT_ROUTINE OutputRoutine,
                PVOID OutputRoutineParameter,
                BOOLEAN SummaryOutput,
                ULONG IndentLevel,
                PWSTR ValueName,
                ULONG ValueLength,
                ULONG ValueType,
                PWSTR ValueData
                )
{
    PULONG p;
    PWSTR pw, pw1, pwBreak;
    WCHAR QuoteChar, BreakChar;
    ULONG i, j, k, m, cbPrefix, cb;
    PUCHAR pbyte;
    char eol[11];

    cbPrefix = (OutputRoutine)( OutputRoutineParameter,
                                "%.*s",
                                IndentLevel,
                                BlanksForPadding
                              );

    if (ValueName != NULL && *ValueName != UNICODE_NULL) {
        if (NeedQuotedString( ValueName, NULL, &QuoteChar )) {
            cbPrefix += (OutputRoutine)( OutputRoutineParameter,
                                         "%c%ws%c ",
                                         QuoteChar,
                                         ValueName,
                                         QuoteChar
                                       );
        } else {
            cbPrefix += (OutputRoutine)( OutputRoutineParameter, "%ws ", ValueName );
        }
    }
    cbPrefix += (OutputRoutine)( OutputRoutineParameter, "= " );

    switch ( ValueType ) {
        case REG_SZ:
        case REG_EXPAND_SZ:

            if (ValueType == REG_EXPAND_SZ) {
                cbPrefix += (OutputRoutine)( OutputRoutineParameter, "REG_EXPAND_SZ " );
            }
            pw = (PWSTR)ValueData;
            if (ValueLength & (sizeof(WCHAR)-1)) {
                (OutputRoutine)( OutputRoutineParameter, "(*** Length not multiple of WCHAR ***)" );
                ValueLength = (ValueLength+sizeof(WCHAR)-1) & ~(sizeof(WCHAR)-1);
            }

            if (ValueLength == 0 ||
                *(PWSTR)((PCHAR)pw + ValueLength - sizeof( WCHAR )) != UNICODE_NULL
               ) {
                (OutputRoutine)( OutputRoutineParameter, "(*** MISSING TRAILING NULL CHARACTER ***)" );
                *(PWSTR)((PCHAR)pw + ValueLength) = UNICODE_NULL;
            }

            if (NeedQuotedString( NULL, pw, &QuoteChar )) {
                (OutputRoutine)( OutputRoutineParameter, "%c%ws%c", QuoteChar, pw, QuoteChar );
            } else
                if ((cbPrefix + wcslen(pw)) <= OutputWidth) {
                (OutputRoutine)( OutputRoutineParameter, "%ws", pw );
            } else {
                while (*pw) {
                    pw1 = pw;
                    pwBreak = NULL;
                    while (*pw1 && *pw1 >= L' ') {
                        if ((cbPrefix + (ULONG)(pw1 - pw)) > (OutputWidth-4)) {
                            break;
                        }

                        if (wcschr( L" ,;", *pw1 )) {
                            pwBreak = pw1;
                        }

                        pw1++;
                    }

                    if (pwBreak != NULL) {
                        while (*pwBreak == pwBreak[1]) {
                            pwBreak += 1;
                        }
                        pw1 = pwBreak + 1;
                    } else {
                        while (*pw1) {
                            pw1 += 1;
                        }
                    }

                    (OutputRoutine)( OutputRoutineParameter, "%.*ws", pw1 - pw, pw );
                    if (*pw1 == UNICODE_NULL) {
                        break;
                    }
                    if (SummaryOutput) {
                        (OutputRoutine)( OutputRoutineParameter, "\\..." );
                        break;
                    }

                    (OutputRoutine)( OutputRoutineParameter,
                                     "\\\n%.*s",
                                     IndentLevel == 0 ? 4 : cbPrefix,
                                     BlanksForPadding
                                   );
                    pw = pw1;
                }
            }

            (OutputRoutine)( OutputRoutineParameter, "\n" );
            break;

        case REG_RESOURCE_LIST:
        case REG_FULL_RESOURCE_DESCRIPTOR:
        case REG_RESOURCE_REQUIREMENTS_LIST:
        case REG_BINARY:
        case REG_NONE:
            switch ( ValueType ) {
                case REG_NONE:
                    pw = L"REG_NONE";
                    break;
                case REG_BINARY:
                    pw = L"REG_BINARY";
                    break;
                case REG_RESOURCE_REQUIREMENTS_LIST:
                    pw = L"REG_RESOURCE_REQUIREMENTS_LIST";
                    break;
                case REG_RESOURCE_LIST:
                    pw = L"REG_RESOURCE_LIST";
                    break;
                case REG_FULL_RESOURCE_DESCRIPTOR:
                    pw = L"REG_FULL_RESOURCE_DESCRIPTOR";
                    break;
            }
            cb = (OutputRoutine)( OutputRoutineParameter, "%ws 0x%08lx", pw, ValueLength );

            if (ValueLength != 0) {
                p = (PULONG)ValueData;
                i = (ValueLength + 3) / sizeof( ULONG );
                if (!SummaryOutput || i <= 2) {
                    for (j=0; j<i; j++) {
                        if ((cbPrefix + cb + 11) > (OutputWidth - 2)) {
                            (OutputRoutine)( OutputRoutineParameter,
                                             " \\\n%.*s",
                                             IndentLevel == 0 ? 4 : cbPrefix,
                                             BlanksForPadding
                                           );
                            cb = 0;
                        } else {
                            cb += (OutputRoutine)( OutputRoutineParameter, " " );
                        }

                        cb += (OutputRoutine)( OutputRoutineParameter, "0x%08lx", *p++ );
                    }
                } else {
                    (OutputRoutine)( OutputRoutineParameter, " \\..." );
                }
            }

            (OutputRoutine)( OutputRoutineParameter, "\n" );

            if (!SummaryOutput) {
                RegDisplayResourceListAsComment( OutputWidth,
                                                 OutputRoutine,
                                                 OutputRoutineParameter,
                                                 IndentLevel,
                                                 ValueLength,
                                                 ValueType,
                                                 ValueData
                                               );
            }

            break;

//  case REG_DWORD_LITTLE_ENDIAN:
        case REG_DWORD:
            (OutputRoutine)( OutputRoutineParameter, "REG_DWORD 0x%08lx\n",
                             *(PULONG)ValueData
                           );
            break;

        case REG_DWORD_BIG_ENDIAN:
            (OutputRoutine)( OutputRoutineParameter, "REG_DWORD_BIG_ENDIAN 0x%08lx\n",
                             *(PULONG)ValueData
                           );
            break;

        case REG_LINK:
            (OutputRoutine)( OutputRoutineParameter, "REG_LINK %ws\n",
                             (PWSTR)ValueData
                           );
            break;

        case REG_MULTI_SZ:
            (!FullPathOutput) ? strcpy (eol, " \\\n%.*s") : strcpy (eol, " \\ ->%.*s");
            cbPrefix += (OutputRoutine)( OutputRoutineParameter, "REG_MULTI_SZ " );
            pw = (PWSTR)ValueData;
            i  = 0;
            if (*pw)
                while (i < (ValueLength - 1) / sizeof( WCHAR )) {
                    if (i > 0) {
                        (OutputRoutine)( OutputRoutineParameter,
                                         eol,
                                         IndentLevel == 0 ? 4 : cbPrefix,
                                         BlanksForPadding
                                       );
                    }
                    (OutputRoutine)( OutputRoutineParameter, "\"");
                    do {
                        if (pw[i] == '"') {
                            (OutputRoutine)( OutputRoutineParameter, "%wc",pw[i]);
                        }
                        (OutputRoutine)( OutputRoutineParameter, "%wc",pw[i]);
                        ++i;
                    }
                    while ( pw[i] != UNICODE_NULL );
                    (OutputRoutine)( OutputRoutineParameter, "\" ");

                    if (SummaryOutput) {
                        (OutputRoutine)( OutputRoutineParameter, " \\..." );
                        break;
                    }

                    ++i;
                }

            (OutputRoutine)( OutputRoutineParameter, "\n" );
            break;

//  case REG_QWORD_LITTLE_ENDIAN:
        case REG_QWORD:
            (OutputRoutine)( OutputRoutineParameter, "REG_QWORD 0x%016I64x\n",
                             *(PDWORDLONG)ValueData
                           );
            break;

        default:
            (OutputRoutine)( OutputRoutineParameter, "*** Unknown Registry Data Type (%08lx)  Length: 0x%lx\n",
                             ValueType,
                             ValueLength
                           );
            break;
    }

    return;
}


void
RegDisplayResourceListAsComment(
                               ULONG OutputWidth,
                               PREG_OUTPUT_ROUTINE OutputRoutine,
                               PVOID OutputRoutineParameter,
                               ULONG IndentLevel,
                               ULONG ValueLength,
                               ULONG ValueType,
                               PWSTR ValueData
                               )
{
    PCM_RESOURCE_LIST ResourceList = (PCM_RESOURCE_LIST)ValueData;
    PCM_FULL_RESOURCE_DESCRIPTOR FullDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG i, j, k, l, count, cb;
    PWSTR TypeName;
    PWSTR FlagName;
    ULONG Size = ValueLength;
    PULONG p;

    if (ValueType == REG_RESOURCE_LIST) {
        if (ValueLength < sizeof( *ResourceList )) {
            return;
        }

        count = ResourceList->Count;
        FullDescriptor = &ResourceList->List[0];
        (OutputRoutine)( OutputRoutineParameter,
                         ";%.*sNumber of Full resource Descriptors = %d",
                         IndentLevel - 1,
                         BlanksForPadding,
                         count
                       );
    } else
        if (ValueType == REG_FULL_RESOURCE_DESCRIPTOR) {
        if (ValueLength < sizeof( *FullDescriptor )) {
            return;
        }

        count = 1;
        FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)ValueData;
    } else {
        return;
    }

    for (i=0; i< count; i++) {
        (OutputRoutine)( OutputRoutineParameter, "\n;%.*sPartial List number %d\n",
                         IndentLevel+4-1,
                         BlanksForPadding,
                         i
                       );

        switch (FullDescriptor->InterfaceType) {
            case InterfaceTypeUndefined:    TypeName = L"Undefined";break;
            case Internal:      TypeName = L"Internal";             break;
            case Isa:           TypeName = L"Isa";                  break;
            case Eisa:          TypeName = L"Eisa";                 break;
            case MicroChannel:  TypeName = L"MicroChannel";         break;
            case TurboChannel:  TypeName = L"TurboChannel";         break;
            case PCIBus:        TypeName = L"PCI";                  break;
            case VMEBus:        TypeName = L"VME";                  break;
            case NuBus:         TypeName = L"NuBus";                break;
            case PCMCIABus:     TypeName = L"PCMCIA";               break;
            case CBus:          TypeName = L"CBUS";                 break;
            case MPIBus:        TypeName = L"MPI";                  break;
            case MPSABus:       TypeName = L"MPSA";                 break;
            case ProcessorInternal: TypeName = L"ProcessorInternal";break;
            case InternalPowerBus:  TypeName = L"InternalPower";    break;
            case PNPISABus:         TypeName = L"PNP Isa";          break;

            default:
                TypeName = L"***invalid bus type***";
                break;
        }

        (OutputRoutine)( OutputRoutineParameter, ";%.*sINTERFACE_TYPE %ws\n",
                         IndentLevel+8-1,
                         BlanksForPadding,
                         TypeName
                       );

        (OutputRoutine)( OutputRoutineParameter, ";%.*sBUS_NUMBER  %d\n",
                         IndentLevel+8-1,
                         BlanksForPadding,
                         FullDescriptor->BusNumber
                       );

        //
        // This is a basic test to see if the data format is right.
        // We know at least some video resource list are bogus ...
        //

        if (Size < FullDescriptor->PartialResourceList.Count *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) ) {

            (OutputRoutine)( OutputRoutineParameter, "\n;%.*s *** !!! Invalid ResourceList !!! *** \n",
                             IndentLevel+8-1,
                             BlanksForPadding,
                             i
                           );

            break;
        }

        Size -= FullDescriptor->PartialResourceList.Count *
                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);



        for (j=0; j<FullDescriptor->PartialResourceList.Count; j++) {

            (OutputRoutine)( OutputRoutineParameter, ";%.*sDescriptor number %d\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             j
                           );

            PartialResourceDescriptor = &(FullDescriptor->PartialResourceList.PartialDescriptors[j]);
            switch (PartialResourceDescriptor->ShareDisposition) {
                case CmResourceShareUndetermined:
                    TypeName = L"CmResourceShareUndetermined";
                    break;
                case CmResourceShareDeviceExclusive:
                    TypeName = L"CmResourceDeviceExclusive";
                    break;
                case CmResourceShareDriverExclusive:
                    TypeName = L"CmResourceDriverExclusive";
                    break;
                case CmResourceShareShared:
                    TypeName = L"CmResourceShared";
                    break;
                default:
                    TypeName = L"***invalid share disposition***";
                    break;
            }

            (OutputRoutine)( OutputRoutineParameter, ";%.*sShare Disposition %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             TypeName
                           );

            FlagName = L"***invalid Flags";

            switch (PartialResourceDescriptor->Type) {
                case CmResourceTypeNull:
                    TypeName = L"NULL";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypePort:
                    TypeName = L"PORT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_MEMORY) {
                        FlagName = L"CM_RESOURCE_PORT_MEMORY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_IO) {
                        FlagName = L"CM_RESOURCE_PORT_IO";
                    }
                    break;
                case CmResourceTypeInterrupt:
                    TypeName = L"INTERRUPT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LATCHED";
                    }
                    break;
                case CmResourceTypeMemory:
                    TypeName = L"MEMORY";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_WRITE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_ONLY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_WRITE_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_WRITE_ONLY";
                    }
                    break;
                case CmResourceTypeDma:
                    TypeName = L"DMA";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypeDeviceSpecific:
                    TypeName = L"DEVICE SPECIFIC";
                    FlagName = L"***Unused";
                    break;
                default:
                    TypeName = L"***invalid type***";
                    break;
            }

            (OutputRoutine)( OutputRoutineParameter, ";%.*sTYPE              %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             TypeName
                           );

            (OutputRoutine)( OutputRoutineParameter, ";%.*sFlags             %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             FlagName
                           );

            switch (PartialResourceDescriptor->Type) {
                case CmResourceTypePort:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sSTART 0x%08lx  LENGTH 0x%08lx\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Port.Start.LowPart,
                                     PartialResourceDescriptor->u.Port.Length
                                   );
                    break;

                case CmResourceTypeInterrupt:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sLEVEL %d  VECTOR %d  AFFINITY %d\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Interrupt.Level,
                                     PartialResourceDescriptor->u.Interrupt.Vector,
                                     PartialResourceDescriptor->u.Interrupt.Affinity
                                   );
                    break;

                case CmResourceTypeMemory:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sSTART 0x%08lx%08lx  LENGTH 0x%08lx\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Memory.Start.HighPart,
                                     PartialResourceDescriptor->u.Memory.Start.LowPart,
                                     PartialResourceDescriptor->u.Memory.Length
                                   );
                    break;

                case CmResourceTypeDma:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sCHANNEL %d  PORT %d\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Dma.Channel,
                                     PartialResourceDescriptor->u.Dma.Port
                                   );
                    break;

                case CmResourceTypeDeviceSpecific:
                    cb = (OutputRoutine)( OutputRoutineParameter, ";%.*sDataSize 0x%08lx  Data:",
                                          IndentLevel+12-1,
                                          BlanksForPadding,
                                          PartialResourceDescriptor->u.DeviceSpecificData.DataSize
                                        );

                    p = (PULONG)(PartialResourceDescriptor + 1);
                    k = (PartialResourceDescriptor->u.DeviceSpecificData.DataSize + 3) / sizeof( ULONG );
                    for (l=0; l<k; l++) {
                        if ((cb + 11) >= OutputWidth) {
                            cb = (OutputRoutine)( OutputRoutineParameter, "\n;%.*s",
                                                  IndentLevel+12-1,
                                                  BlanksForPadding
                                                ) - 1;
                        }

                        cb += (OutputRoutine)( OutputRoutineParameter, " 0x%08lx", *p++ );
                    }

                    (OutputRoutine)( OutputRoutineParameter, "\n" );
                    break;

                default:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*s*** Unknown resource list type: 0x%x ****\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->Type
                                   );
                    break;
            }

            (OutputRoutine)( OutputRoutineParameter, ";\n" );
        }

        FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (PartialResourceDescriptor+1);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\makefile.inc ===
$(O)\remoteds.res: remoteds.rc

$(O)\rdsrelay.res: rdsrelay.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regsvr32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by regsvr.rc
//
#define IDS_USAGE                       1
#define IDS_UNRECOGNIZEDFLAG            2
#define IDS_EXTRAARGUMENT               3
#define IDS_NOPROJECT                   4
#define IDS_NODLLNAME                   5
#define IDS_OLEINITFAILED               6
#define IDS_LOADLIBFAILED               7
#define IDS_NOTDLLOROCX                 8
#define IDS_NOENTRYPOINT                9
#define IDS_CALLFAILED                  10
#define IDS_CALLSUCCEEDED               11
#define IDS_OLEUNINITFAILED             12
#define IDS_NOTEXEORHELPER              13

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regini\regutil.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

    This is the include file for the registry utility functions.

Author:

    Steve Wood (stevewo) 10-Mar-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <conio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <string.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <regstr.h>
#include "regtool.h"


_inline ULONG
HiPtrToUlong( const void *p )
{
    DWORDLONG dwl;

    dwl=(ULONG_PTR)p;
    dwl >>= 32;

    return (ULONG)dwl;
}

#define LO_PTR  PtrToUlong
#define HI_PTR  HiPtrToUlong

REG_CONTEXT RegistryContext;
PVOID OldValueBuffer;
ULONG OldValueBufferSize;
PWSTR MachineName;
PWSTR HiveFileName;
PWSTR HiveRootName;
PWSTR Win95Path;
PWSTR Win95UserPath;

ULONG OutputHeight;
ULONG OutputWidth;
ULONG IndentMultiple;
BOOLEAN DebugOutput;
BOOLEAN FullPathOutput;

void
InitCommonCode(
    PHANDLER_ROUTINE CtrlCHandler,
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    );

void
Usage(
    LPSTR Message,
    ULONG_PTR MessageParameter
    );

void
FatalError(
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    );

void
InputMessage(
    PWSTR FileName,
    ULONG LineNumber,
    BOOLEAN Error,
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    );

PWSTR
GetArgAsUnicode(
    LPSTR s
    );

void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    );

int
__cdecl
MsgFprintf (
    FILE *str,
    LPSTR Format,
    ...
    );

void TSGetch(void);

BOOL IsRegistryToolDisabled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\regsvr32\regsvr32.cpp ===
// regsvr.cpp : Program to invoke OLE self-registration on a DLL.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>
#include "resource.h"

#define FAIL_ARGS   1
#define FAIL_OLE    2
#define FAIL_LOAD   3
#define FAIL_ENTRY  4
#define FAIL_REG    5

const TCHAR _szAppName[] = _T("RegSvr32");
const char _szDllInstall[] = "DllInstall";
const TCHAR _tszDllInstall[] = TEXT("DllInstall");
TCHAR _szDllPath[_MAX_PATH];

// Leave room for "Ex" to be tacked onto end
char _szDllRegSvr[32] = "DllRegisterServer";
TCHAR _tszDllRegSvr[32] = TEXT("DllRegisterServer");
char _szDllUnregSvr[32] = "DllUnregisterServer";
TCHAR _tszDllUnregSvr[32] = TEXT("DllUnregisterServer");
char _szRegContext[_MAX_PATH];

HINSTANCE _hInstance;

BOOL _bSilent;

#define MAX_DLL_COUNT  255

void
FormatString3(
    LPTSTR lpszOut,
    LPCTSTR lpszFormat,
    LPCTSTR lpsz1,
    LPCTSTR lpsz2,
    LPCTSTR lpsz3
    )
{
    LPCTSTR pchSrc = lpszFormat;
    LPTSTR pchDest = lpszOut;
    LPCTSTR pchTmp;
    while (*pchSrc != '\0') {
        if (pchSrc[0] == '%' && (pchSrc[1] >= '1' && pchSrc[1] <= '3')) {
            if (pchSrc[1] == '1')
                pchTmp = lpsz1;
            else if (pchSrc[1] == '2')
                pchTmp = lpsz2;
            else 
                pchTmp = lpsz3;

            if (lstrlen(pchTmp) > MAX_PATH) {
                lstrcpyn(pchDest, pchTmp, MAX_PATH/2);
                lstrcat(pchDest, TEXT("..."));
                lstrcat(pchDest, pchTmp+lstrlen(pchTmp)-(MAX_PATH/2));
            } else {
                lstrcpy(pchDest, pchTmp);
            }

            pchDest += lstrlen(pchDest);
            pchSrc += 2;
        } else {
            if (_istlead(*pchSrc))
                *pchDest++ = *pchSrc++; // copy first of 2 bytes
            *pchDest++ = *pchSrc++;
        }
    }
    *pchDest = '\0';
}

#define MAX_STRING 1024

void
DisplayMessage(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL,
    LPCTSTR pszArg3 = NULL,
    BOOL bUsage = FALSE,
    BOOL bInfo = FALSE
    )
{
    if (_bSilent)
        return;

    TCHAR szFmt[MAX_STRING];
    LoadString(_hInstance, ids, szFmt, MAX_STRING);

    TCHAR szText[MAX_STRING];
    FormatString3(szText, szFmt, pszArg1, pszArg2, pszArg3);
    if (bUsage) {
        int cch = _tcslen(szText);
        LoadString(_hInstance, IDS_USAGE, szText + cch, MAX_STRING - cch);
    }

    if (! _bSilent)
        MessageBox(NULL, szText, _szAppName,
            MB_TASKMODAL | (bInfo ? MB_ICONINFORMATION : MB_ICONEXCLAMATION));
}

inline void
Usage(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL
    )
{
    DisplayMessage(ids, pszArg1, pszArg2, NULL, TRUE);
}

inline void
Info(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL
    )
{
    DisplayMessage(ids, pszArg1, pszArg2, NULL, FALSE, TRUE);
}

#define MAX_APPID    256

BOOL IsContextRegFileType(LPCTSTR *ppszDllName)
{
    HKEY hk1, hk2;
    LONG lRet;
    LONG cch;
    TCHAR szExt[_MAX_EXT];
    TCHAR szAppID[MAX_APPID];
    _tsplitpath(*ppszDllName, NULL, NULL, NULL, szExt);

    // Find [HKEY_CLASSES_ROOT\.foo]
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szExt, 0, KEY_QUERY_VALUE, &hk1))
        return FALSE;

    // Read [HKEY_CLASSES_ROOT\.foo\"foo_auto_file"]
    cch = sizeof(szAppID);
    lRet = RegQueryValue(hk1, NULL, szAppID, &cch);
    RegCloseKey(hk1);
    if (ERROR_SUCCESS != lRet)
        return FALSE;

    // Find [HKEY_CLASSES_ROOT\foo_auto_file]
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szAppID, 0, KEY_QUERY_VALUE, &hk1))
        return FALSE;

    // Find [HKEY_CLASSES_ROOT\foo_auto_file\AutoRegister]
    if (ERROR_SUCCESS != RegOpenKeyEx(hk1, TEXT("AutoRegister"), 0, KEY_QUERY_VALUE, &hk2))
    {
        RegCloseKey(hk1);
        return FALSE;
    }

    // Read [HKEY_CLASSES_ROOT\foo_auto_file\AutoRegister\"d:\...\fooreg.dll"]
    cch = MAX_PATH;
    lRet = RegQueryValue(hk2, NULL, _szDllPath, &cch);
    RegCloseKey(hk1);
    RegCloseKey(hk2);
    if (ERROR_SUCCESS != lRet)
        return FALSE;

    _szDllPath[cch] = TEXT('\0');
    *ppszDllName = _szDllPath;
 
    return TRUE;
}

int PASCAL
_tWinMain(
    HINSTANCE hInstance,
    HINSTANCE,
    LPSTR,
    int
    )
{
    int iReturn = 0;
    HRESULT (STDAPICALLTYPE * lpDllEntryPointReg)(void);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointRegEx)(LPCSTR);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointRegExW)(LPCWSTR);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointInstall)(BOOL, LPWSTR);
    HRESULT rc;
    BOOL bVisualC = FALSE;
    BOOL bUnregister = FALSE;
    BOOL bCallDllInstall = FALSE;
    BOOL bCallDllRegisterServer = TRUE;
    BOOL bErrorsOnly = FALSE;
    BOOL bContextReg = FALSE;
    BOOL bUnicodeContextReg = FALSE;
    LPSTR pszDllEntryPoint = _szDllRegSvr;
    LPTSTR ptszDllEntryPoint = _tszDllRegSvr;
    LPTSTR pszTok;
    LPCTSTR pszDllName;
    LPSTR pszContext;
    LPCTSTR pszContextW;
    TCHAR pszDllInstallCmdLine[MAX_PATH+1];
#ifdef UNICODE
    PWCHAR pwszDllInstallCmdLine = pszDllInstallCmdLine;
#else
    WCHAR pwszDllInstallCmdLine[MAX_PATH+1];
#endif
    int iNumDllsToRegister = 0;
    int iCount;
    LPCTSTR ppszDllNames[MAX_DLL_COUNT];
    TCHAR szError[1024];

    _hInstance = hInstance;

    // Parse command line arguments.
    int iTok;
    for (iTok = 1; iTok < __argc; iTok++) {
        pszTok = __targv[iTok];

        if ((pszTok[0] == TEXT('-')) || (pszTok[0] == TEXT('/'))) {
            switch (pszTok[1]) {
                case TEXT('e'):
                case TEXT('E'):
                    bErrorsOnly = TRUE;
                    break;

                case TEXT('i'):
                case TEXT('I'):
                    bCallDllInstall = TRUE;

                    if (pszTok[2] == TEXT(':'))
                    {
                        if (pszTok[3] == TEXT('"')) {
                            // handle quoted InstallCmdLine (
                            // (e.g. /i:"c:\my dll dir\mydll.dll")
                            LPTSTR pszEndQuote = &pszTok[4];
                            int iLength = lstrlen(pszEndQuote);

                            if (iLength > MAX_PATH) {
                                if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                                  ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                                    DisplayMessage(IDS_LOADLIBFAILED, pszEndQuote, szError);
                                }
                                return FAIL_ARGS;
                            }

                            if ((iLength > 0) && pszEndQuote[iLength - 1] == TEXT('"')) {
                                // they quoted the string but it wasent really necessary
                                // (e.g. /i:"shell32.dll")
                                pszEndQuote[iLength - 1] = TEXT('\0');
                        
                                lstrcpy(pszDllInstallCmdLine, pszEndQuote);
                            } else {
                                // we have a quoted string that spans multiple tokens
                                lstrcpy(pszDllInstallCmdLine, pszEndQuote);

                                for (iTok++; iTok < __argc; iTok++) {
                                    // grab the next token
                                    pszEndQuote = __targv[iTok];
                                    iLength = lstrlen(pszEndQuote);

                                    if (lstrlen(pszDllInstallCmdLine) + iLength + 1 > MAX_PATH) {
                                        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                                          ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                                            DisplayMessage(IDS_LOADLIBFAILED, pszDllInstallCmdLine, szError);
                                        }
                                        return FAIL_ARGS;
                                    }

                                    if ((iLength > 0) && (pszEndQuote[iLength - 1] == '"')) {
                                        pszEndQuote[iLength - 1] = TEXT('\0');
                                        lstrcat(pszDllInstallCmdLine, TEXT(" "));
                                        lstrcat(pszDllInstallCmdLine, pszEndQuote);
                                        break;
                                    }

                                    lstrcat(pszDllInstallCmdLine, TEXT(" "));
                                    lstrcat(pszDllInstallCmdLine, pszEndQuote);
                                }
                            }
                        } else {
                            if (lstrlen(&pszTok[3]) > MAX_PATH) {
                                if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                                  ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                                    DisplayMessage(IDS_LOADLIBFAILED, &pszTok[3], szError);
                                }
                                return FAIL_ARGS;
                            }

                            // cmd line is NOT quoted
                            lstrcpy(pszDllInstallCmdLine, &pszTok[3]);
                        }
#ifndef UNICODE
                        if (!MultiByteToWideChar(CP_ACP,
                                                 0,
                                                 (LPCTSTR)pszDllInstallCmdLine,
                                                 -1,
                                                 pwszDllInstallCmdLine,
                                                 MAX_PATH))
                        {
                            Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                            return FAIL_ARGS;
                        }
#endif
                    }
                    else
                    {
                        lstrcpyW((LPWSTR)pwszDllInstallCmdLine, L"");
                    }
                    break;

                case TEXT('n'):
                case TEXT('N'):
                    bCallDllRegisterServer = FALSE;
                    break;

                case TEXT('s'):
                case TEXT('S'):
                    _bSilent = TRUE;
                    break;

                case TEXT('u'):
                case TEXT('U'):
                    bUnregister = TRUE;
                    pszDllEntryPoint = _szDllUnregSvr;
                    ptszDllEntryPoint = _tszDllUnregSvr;
                    break;

                case TEXT('v'):
                case TEXT('V'):
                    bVisualC = TRUE;
                    break;

                case TEXT('c'):
                case TEXT('C'):
                    // Ignore this
                    break;

                default:
                    Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                    return FAIL_ARGS;
            }
        } else {
            if (pszTok[0] == TEXT('"')) {
                // handle quoted DllName
                TCHAR szTemp[MAX_PATH+1];
                LPTSTR pszQuotedDllName;
                int iLength;

                iLength = lstrlen(&pszTok[1]);

                if (iLength > MAX_PATH) {
                    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                      ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                        DisplayMessage(IDS_LOADLIBFAILED, &pszTok[3], szError);
                    }
                    return FAIL_ARGS;
                }

                lstrcpy(szTemp, &pszTok[1]);

                if ((iLength > 0) && szTemp[iLength - 1] != TEXT('"')) {
                    // handle quoted dll name that spans multiple tokens
                    for (iTok++; iTok < __argc; iTok++) {
                        iLength = lstrlen(__targv[iTok]);

                        if (lstrlen(szTemp) + iLength + 1 > MAX_PATH) {
                            if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                              ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                                DisplayMessage(IDS_LOADLIBFAILED, szTemp, szError);
                            }
                            return FAIL_ARGS;
                        }

                        lstrcat(szTemp, TEXT(" "));
                        lstrcat(szTemp, __targv[iTok]);
                        if ((iLength > 0) && __targv[iTok][iLength - 1] == TEXT('"')) {
                            // this token has the end quote, so stop here
                            break;
                        }
                    }
                }

                iLength = lstrlen(szTemp);

                // remove the trailing " if one exists
                if ( (iLength > 0) && (szTemp[iLength - 1] == TEXT('"')) ) {
                    szTemp[iLength - 1] = TEXT('\0');
                }

                pszQuotedDllName = (LPTSTR) LocalAlloc(LPTR, (iLength + 1) * sizeof(TCHAR));

                if (pszQuotedDllName)
                {
                    if (iNumDllsToRegister == MAX_DLL_COUNT) {
                        Usage(IDS_UNRECOGNIZEDFLAG, TEXT("Excessive # of DLL's on cmdline"));
                        return FAIL_ARGS;
                    }
                    lstrcpy(pszQuotedDllName, szTemp);
                    ppszDllNames[iNumDllsToRegister] = pszQuotedDllName;
                    iNumDllsToRegister++;
                }

            } else {
                // no leading " so assume that this token is one of the dll names
                if (iNumDllsToRegister == MAX_DLL_COUNT) {
                    Usage(IDS_UNRECOGNIZEDFLAG, TEXT("Excessive # of DLL's on cmdline"));
                    return FAIL_ARGS;
                }
                if (lstrlen(pszTok) > MAX_PATH) {
                    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                      ERROR_FILENAME_EXCED_RANGE, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                        DisplayMessage(IDS_LOADLIBFAILED, pszTok, szError);
                    }
                    return FAIL_ARGS;
                }
                ppszDllNames[iNumDllsToRegister] = pszTok;
                iNumDllsToRegister++;
            }
        }
    }

    // check to see if we were passed a '-n' but no '-i'
    if (!bCallDllRegisterServer && !bCallDllInstall) {
        Usage(IDS_UNRECOGNIZEDFLAG, TEXT("/n must be used with the /i switch"));
        return FAIL_ARGS;
    }

    if (iNumDllsToRegister == 0) {
        if (bVisualC)
            DisplayMessage(IDS_NOPROJECT);
        else
            Usage(IDS_NODLLNAME);

        return FAIL_ARGS;
    }

    // Initialize OLE.
    __try {
        rc = OleInitialize(NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = (HRESULT) GetExceptionCode();
    }

    if (FAILED(rc)) {
        DisplayMessage(IDS_OLEINITFAILED);
        return FAIL_OLE;
    }

    if (_bSilent) {
        SetErrorMode(SEM_FAILCRITICALERRORS);       // Make sure LoadLib fail in silent mode (no popups).
    }

    for (iCount = 0; iCount < iNumDllsToRegister; iCount++) {
        pszDllName = ppszDllNames[iCount];

        /*
         * See if this is a non-executable file that requires special handling. If so,
         * bContextReg will be set to TRUE and pszDllName (which original pointed to
         * the path to the special file) will be set to the path to the executable that
         * is responsible for doing the actual registration. The path to the special
         * file will be passed in as context info in the call Dll[Un]RegisterServerEx.
         */
        pszContextW = pszDllName;
        pszContext = (LPSTR)pszContextW;
        bContextReg = IsContextRegFileType(&pszDllName);
        if (TRUE == bContextReg) {
            lstrcatA(pszDllEntryPoint, "Ex");
            lstrcat(ptszDllEntryPoint, TEXT("Ex"));
            // Convert pszContext to a real char *
#ifdef UNICODE
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     (LPCWSTR)pszContext,
                                     lstrlenW((LPCWSTR)pszContext),
                                     _szRegContext,
                                     sizeof(_szRegContext),
                                     0,
                                     NULL))
            {
                Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                return FAIL_ARGS;
            } else {
                pszContext = _szRegContext;
            }
#endif

        }

        // Load the library -- fail silently if problems
        UINT errMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HINSTANCE hLib = LoadLibraryEx(pszDllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        SetErrorMode(errMode);

        if (hLib < (HINSTANCE)HINSTANCE_ERROR) {
            DWORD dwErr = GetLastError();

            if (ERROR_BAD_EXE_FORMAT == dwErr) {
                DisplayMessage(IDS_NOTEXEORHELPER, pszDllName);
            } else {
                if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                  dwErr, 0, szError, sizeof(szError)/sizeof(szError[0]), NULL)) {
                    DisplayMessage(IDS_LOADLIBFAILED, pszDllName, szError);
                }
            }
            iReturn = FAIL_LOAD;
            goto CleanupOle;
        }

        // during unregister we need to call DllInstall first, and then DllUnregisterServer
        if (bUnregister)
            goto DllInstall;

DllRegisterServer:
        // Call the entry point for DllRegisterServer/DllUnregisterServer
        if (bCallDllRegisterServer) {
            if (bContextReg) {
                (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, "DllRegisterServerExW");
                if (lpDllEntryPointRegEx) {
                    (FARPROC&)lpDllEntryPointRegExW = (FARPROC&)lpDllEntryPointRegEx;
                    bUnicodeContextReg = TRUE;
                } else {
                    (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, "DllRegisterServerEx");
                }

                (FARPROC&)lpDllEntryPointReg = (FARPROC&)lpDllEntryPointRegEx;
            } else {
                (FARPROC&)lpDllEntryPointReg = (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, pszDllEntryPoint);
            }

            if (lpDllEntryPointReg == NULL) {
                TCHAR szExt[_MAX_EXT];
                _tsplitpath(pszDllName, NULL, NULL, NULL, szExt);

                if (FALSE == bContextReg && (lstrcmp(szExt, TEXT(".dll")) != 0) && (lstrcmp(szExt, TEXT(".ocx")) != 0))
                    DisplayMessage(IDS_NOTDLLOROCX, pszDllName, ptszDllEntryPoint);
                else
                    DisplayMessage(IDS_NOENTRYPOINT, pszDllName, ptszDllEntryPoint);

                iReturn = FAIL_ENTRY;
                goto CleanupLibrary;
            }

            // try calling DllRegisterServer[Ex]() / DllUnregisterServer[Ex]()
            __try {
                if (bUnicodeContextReg) {
                    rc = (*lpDllEntryPointRegExW)(pszContextW);
                } else {
                    if (bContextReg) {
                        rc = (*lpDllEntryPointRegEx)(pszContext);
                    } else {
                        rc = (*lpDllEntryPointReg)();
                    }
                }
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                rc = (HRESULT) GetExceptionCode();
            }

            if (FAILED(rc)) {
                wsprintf(szError, _T("0x%08lx"), rc);
                DisplayMessage(IDS_CALLFAILED, ptszDllEntryPoint, pszDllName, szError);
                iReturn = FAIL_REG;
                goto CleanupLibrary;
            }
        }

        // during unregister we need to call DllInstall first, then DllRegisterServer,
        // since we already called DllInstall and then jumped back up to DllRegisterServer:
        // skip over it and goto CheckErrors:
        if (bUnregister)
            goto CheckErrors;

DllInstall:
        // Call the entry point for DllInstall
        if (bCallDllInstall) {
            (FARPROC&)lpDllEntryPointInstall = GetProcAddress(hLib, _szDllInstall);

            if (lpDllEntryPointInstall == NULL) {
                TCHAR szExt[_MAX_EXT];
                _tsplitpath(pszDllName, NULL, NULL, NULL, szExt);

                if ((lstrcmp(szExt, TEXT(".dll")) != 0) && (lstrcmp(szExt, TEXT(".ocx")) != 0))
                    DisplayMessage(IDS_NOTDLLOROCX, pszDllName, _tszDllInstall);
                else
                    DisplayMessage(IDS_NOENTRYPOINT, pszDllName, _tszDllInstall);

                iReturn = FAIL_ENTRY;
                goto CleanupLibrary;
            }

            // try calling DllInstall(BOOL bRegister, LPWSTR lpwszCmdLine) here...
            // NOTE: the lpwszCmdLine string must be UNICODE!
            __try {
                rc = (*lpDllEntryPointInstall)(!bUnregister, pwszDllInstallCmdLine);

            } __except(EXCEPTION_EXECUTE_HANDLER) {
                rc = (HRESULT) GetExceptionCode();
            }

            if (FAILED(rc)) {
                wsprintf(szError, _T("0x%08lx"), rc);
                DisplayMessage(IDS_CALLFAILED, _tszDllInstall, pszDllName, szError);
                iReturn = FAIL_REG;
                goto CleanupLibrary;
            }
        }

        // during unregister we now need to call DllUnregisterServer
        if (bUnregister)
            goto DllRegisterServer;

CheckErrors:
        if (!bErrorsOnly) {
            TCHAR szMessage[MAX_PATH];

            // set up the success message text
            if (bCallDllRegisterServer)
            {
                lstrcpy(szMessage, ptszDllEntryPoint);
                if (bCallDllInstall)
                {
                    lstrcat(szMessage, TEXT(" and "));
                    lstrcat(szMessage, _tszDllInstall);
                }
            }
            else if (bCallDllInstall)
            {
                lstrcpy(szMessage, _tszDllInstall);
            }

            Info(IDS_CALLSUCCEEDED, szMessage, pszDllName);
        }

CleanupLibrary:
        FreeLibrary(hLib);
    }

CleanupOle:
    __try {
        OleUninitialize();
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DisplayMessage(IDS_OLEUNINITFAILED);
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\client.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1992 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1992 - 1997 Microsoft Corporation

Module Name:

    Client.c

Abstract:

    The Client component of Remote. Connects to the remote
    server using named pipes. It sends its stdin to
    the server and output everything from server to
    its stdout.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart        Summer 1997   single-pipe operation

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"

BOOL fAsyncPipe = TRUE;    // need this so server has it TRUE


HANDLE*
EstablishSession(
    char *server,
    char *pipe
    );

DWORD
WINAPI
SendServerInp(
    LPVOID pvParam
    );

BOOL
FilterClientInp(
    char *buff,
    int count
    );


BOOL
Mych(
    DWORD ctrlT
    );

VOID
SendMyInfo(
    PHANDLE Pipes
    );


#define ZERO_LENGTH_READ_LIMIT  200

HANDLE MyStdInp;
HANDLE MyStdOut;

//
// ReadPipe and WritePipe are referenced by multiple
// threads so need to be volatile.
//

volatile HANDLE ReadPipe;
volatile HANDLE WritePipe;


CONSOLE_SCREEN_BUFFER_INFO csbi;

char   MyEchoStr[30];
BOOL   CmdSent;
DWORD  LinesToSend=LINESTOSEND;

int
Client(
    char* Server,
    char* Pipe
    )
{
    HANDLE *Connection;
    DWORD  dwThreadID;
    HANDLE hThread;
    DWORD  cb;
    OVERLAPPED ol;
    char   rgchBuf[1024];
    DWORD  dwZeroCount = 0;
    CWCDATA cwcData = {NULL};
    int    rc = 0;

    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    fputs("**************************************\n"
          "***********     REMOTE    ************\n"
          "***********     CLIENT    ************\n"
          "**************************************\n",
          stdout);

    if ((Connection=EstablishSession(Server,Pipe))==NULL)
        return 1;


    ReadPipe=Connection[0];
    WritePipe=Connection[1];

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE);

    // Start Thread For Client --> Server Flow
    hThread = (HANDLE)
        _beginthreadex(
            NULL,             // security
            0,                // default stack size
            SendServerInp,    // thread proc
            NULL,             // parm
            0,                // not suspended
            &dwThreadID
            );

    if ( !hThread) 
    {
        Errormsg("REMOTE /C Could Not Create Thread.");
        return 1;
    }

    // We don't need the thread handle - it lives to the process exits
    CloseHandle(hThread);

    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );

    while (ReadFileSynch(ReadPipe, rgchBuf, sizeof rgchBuf, &cb, 0, &ol)) {

        if (cb) {
           // If we are interested in colors, do special output
           if ( pWantColorLines() )
           {
               if ( !WriteConsoleWithColor( MyStdOut,
                                            rgchBuf,
                                            cb,
                                            &cwcData ) )
               {
                   rc = 1;
                   break;
               }
           }
           else
           {
               if ( ! WriteFile(MyStdOut, rgchBuf, cb, &cb, NULL)) {
                   rc = 1;
                   break;
               }
           }
           dwZeroCount = 0;
        } else {
            if (++dwZeroCount > ZERO_LENGTH_READ_LIMIT) {

                //
                // If we get a bunch of zero length reads in a row,
                // something's broken, don't loop forever.
                // (bug #115866).
                //

                fputs("\nREMOTE: bailing out, server must have gone away.\n", stdout);
                rc = 1;
                break;
            }
        }
    }

    CloseHandle(ol.hEvent);

    fputs("*** SESSION OVER ***", stdout);
    fflush(stdout);

    CloseClientPipes();

    fputs("\n", stdout);
    fflush(stdout);

    return rc;
}


DWORD
WINAPI
SendServerInp(
    LPVOID pvParam
    )
{
    DWORD  dread,dwrote;
    OVERLAPPED ol;
    char buff[512];

    UNREFERENCED_PARAMETER(pvParam);

    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );


    while(ReadFile(MyStdInp,buff,sizeof buff,&dread,NULL))
    {
        if (FilterClientInp(buff,dread))
            continue;
        if (!WriteFileSynch(WritePipe,buff,dread,&dwrote,0,&ol))
            break;
    }

    CloseClientPipes();

    return 0;
}



BOOL
FilterClientInp(
    char *buff,
    int count
    )
{

    if (count==0)
        return(TRUE);

    if (buff[0]==2)     // Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);   // do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
              CloseClientPipes();
              return(FALSE);

        case 'h':
        case 'H':
              printf("%cM : Send Message\n",COMMANDCHAR);
              printf("%cP : Show Popup on Server\n",COMMANDCHAR);
              printf("%cS : Status of Server\n",COMMANDCHAR);
              printf("%cQ : Quit client\n",COMMANDCHAR);
              printf("%cH : This Help\n",COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
Mych(
   DWORD ctrlT
   )

{
    char  c[2];
    DWORD tmp;
    OVERLAPPED ol;

    c[0]=CTRLC;

    if (ctrlT==CTRL_C_EVENT)
    {
        ZeroMemory(&ol, sizeof(ol));

        ol.hEvent =
            CreateEvent(
                NULL,      // security
                TRUE,      // auto-reset
                FALSE,     // initially nonsignaled
                NULL       // unnamed
                );

        if (INVALID_HANDLE_VALUE != WritePipe &&
            !WriteFileSynch(WritePipe,c,1,&tmp,0,&ol))
        {
            CloseHandle(ol.hEvent);
            Errormsg("Error Sending ^c");
            return(FALSE);
        }
        CloseHandle(ol.hEvent);
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)
       ) {

       CloseClientPipes();
    }
    return(FALSE);
}

VOID
CloseClientPipes(
    VOID
    )
{
    HANDLE WriteHandle, ReadHandle;

    WriteHandle = (HANDLE) InterlockedExchangePointer(
        (PVOID *)   &WritePipe,
        INVALID_HANDLE_VALUE
        );

    if (INVALID_HANDLE_VALUE != WriteHandle) {

        CloseHandle(WriteHandle);

        ReadHandle = (HANDLE) InterlockedExchangePointer(
            (PVOID *) &ReadPipe,
            INVALID_HANDLE_VALUE
            );

        if (INVALID_HANDLE_VALUE != ReadHandle &&
            WriteHandle != ReadHandle) {

            CloseHandle(ReadHandle);
        }
    }
}


VOID
HandleConnectError(
    char *server,
    char *srvpipename
    )
{
    DWORD Err = GetLastError();
    char  msg[128];

    Errormsg("*** Unable to Connect ***");

    //
    // Print a helpful message
    //

    switch(Err)
    {
        case ERROR_FILE_NOT_FOUND:
            sprintf(msg,"invalid pipe name \"%s\"", srvpipename);
            break;

        case ERROR_BAD_NETPATH:
            sprintf(msg,"\\\\%s not found", server);
            break;

        default:
            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM|
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL, Err, 0, msg, sizeof(msg), NULL);
            break;

    }

    printf("Diagnosis: %s\n",msg);

    //
    // If the machine exists but the pipe doesn't do an
    // automatic remote /q to list pipes available on
    // that machine.
    //

    if (ERROR_FILE_NOT_FOUND == Err) {

        printf("\nREMOTE /Q %s\n", server);
        fflush(stdout);
        QueryRemotePipes(server);
    }
}



HANDLE*
EstablishSession(
    char *server,
    char *srvpipename
    )
{
    extern BOOL bForceTwoPipes;
    static HANDLE PipeH[2];
    char   pipenameSrvIn[200];
    char   pipenameSrvOut[200];
    BOOL   fOldServer;
    DWORD  dwError;
    DWORD  RetryCount = 0;

    //
    // Since in single-pipe operation we'll be using the same
    // pipe in two threads, we have to open the handles for
    // overlapped operation, even though we always want
    // synchronous operation.
    //

    sprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename);
    sprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename);

    if (bForceTwoPipes) {

        dwError = ERROR_NOT_SUPPORTED;

    } else {

      RetrySrvBidi:

        if (INVALID_HANDLE_VALUE ==
               (PipeH[1] =
                    CreateFile(
                        pipenameSrvIn,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED,
                        NULL
                        ))) {

            dwError = GetLastError();

            if (ERROR_PIPE_BUSY == dwError) {

                fputs( "All pipe instances busy, waiting for another...\n", stdout);

                WaitNamedPipe(
                    pipenameSrvIn,
                    15000
                    );

                if (RetryCount++ < 6) {
                    goto RetrySrvBidi;
                }
            }

            if (ERROR_ACCESS_DENIED != dwError &&
                ERROR_NOT_SUPPORTED != dwError) {

                HandleConnectError(server, srvpipename);
                return NULL;
            }

        } else {

            PipeH[0] = PipeH[1];
            fAsyncPipe = TRUE;

            fputs("Connected...\n\n", stdout);

            SendMyInfo(PipeH);

            return PipeH;
        }
    }


    //
    // Old remote servers don't allow you to open the
    // server IN pipe for READ access, so go down the
    // old path, notably opening OUT first so the
    // server knows we'll be using both pipes.  We'll
    // also come down this path on Win95 because
    // it doesn't allow you to open an overlapped
    // pipe handle.  Or if remote /c mach pipe /2 is used.
    //

    fOldServer = (ERROR_ACCESS_DENIED == dwError);

  RetrySrvOut:

    if (INVALID_HANDLE_VALUE ==
            (PipeH[0] =
                CreateFile(
                    pipenameSrvOut,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    ))) {

        if (ERROR_PIPE_BUSY == GetLastError()) {

            fputs( "All OUT pipe instances busy, waiting for another...\n", stdout);

            WaitNamedPipe(
                pipenameSrvOut,
                32000              // server recycles abandoned
                );                 // OUT pipe after two minutes

            if (RetryCount++ < 6) {
                goto RetrySrvOut;
            }
        }

        HandleConnectError(server, srvpipename);
        return NULL;

    }


  RetrySrvIn:

    if (INVALID_HANDLE_VALUE ==
           (PipeH[1] =
               CreateFile(
                    pipenameSrvIn,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    ))) {

        dwError = GetLastError();

        if (ERROR_PIPE_BUSY == dwError) {

            fputs( "All IN pipe instances busy, waiting for another...\n", stdout);

            WaitNamedPipe(
                pipenameSrvIn,
                15000
                );

            if (RetryCount++ < 6) {
                goto RetrySrvIn;
           }
        }

        HandleConnectError(server, srvpipename);
        return NULL;

    }

    fAsyncPipe = FALSE;

    printf("Connected... %s\n\n",
           fOldServer
               ? "to two-pipe remote server."
               : "using two pipes."
           );

    SendMyInfo(PipeH);

    return PipeH;
}



VOID
SendMyInfo(
    PHANDLE pipeH
    )
{
    HANDLE rPipe=pipeH[0];
    HANDLE wPipe=pipeH[1];

    DWORD  hostlen;
    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO);
    DWORD  tmp;
    OVERLAPPED ol;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    hostlen = sizeof(ssi.ClientName) / sizeof(ssi.ClientName[0]);
    GetComputerName(ssi.ClientName, &hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    {
        DWORD NewCode=MAGICNUMBER;
        char  Name[MAX_COMPUTERNAME_LENGTH+1];

        strcpy(Name,(char *)ssi.ClientName);
        memcpy(&Name[11],(char *)&NewCode,sizeof(NewCode));

        //
        // The server needs to know if we're doing single-pipe
        // operation so it can complete the connection properly.
        // So if we are, change the first byte of the first
        // send (the computername, which is later superceded
        // by the one in the SESSION_STARTUPINFO structure)
        // to an illegal computername character, question mark.
        //

        if (wPipe == rPipe) {

             Name[0] = '?';
        }

        WriteFileSynch(wPipe,(char *)Name,HOSTNAMELEN-1,&tmp,0,&ol);
        ReadFileSynch(rPipe ,(char *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,0,&ol);

        if (ssr.MagicNumber!=MAGICNUMBER)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            ErrorExit("Pipe connected but server not recognized.\n");
        }

        //Get Rest of the info-its not the old server

        ReadFileSynch(
            rPipe,
            (char *)&ssr + sizeof(ssr.MagicNumber),
            sizeof(ssr)-sizeof(ssr.MagicNumber),
            &tmp,
            0,
            &ol
            );

    }

    if (!WriteFileSynch(wPipe,(char *)&ssi,BytesToSend,&tmp,0,&ol))
    {
       Errormsg("INFO Send Error");
    }

    CloseHandle(ol.hEvent);
}


VOID
QueryRemotePipes(
    char* pszServer
    )
{
    HANDLE hQPipe;
    DWORD  dwRead;
    DWORD  dwError;
    char   fullname[400] = {0};
    char*  msg;
    int    msgLen;

    if (pszServer[0] == '\\' && pszServer[1] == '\\') {
        pszServer += 2;
    }

    printf("Querying server \\\\%s\n", pszServer);

    _snprintf(fullname, sizeof(fullname)-1, QUERY_DEBUGGERS_PIPE, pszServer);

    //
    // Send request and display the query result
    //

    hQPipe = CreateFile(fullname,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if(hQPipe == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();

        if (ERROR_FILE_NOT_FOUND == dwError) {

            printf("No Remote servers running on \\\\%s\n", pszServer);

        } else if (ERROR_BAD_NETPATH == dwError) {

            printf("\\\\%s not found on the network\n", pszServer);

        } else {

            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL, dwError, 0,
                           fullname, sizeof(fullname), NULL);

            printf("Can't query server %s: %s\n", pszServer, fullname);
        }

        return;
    }

    //  Send Query Command
    if(!WriteFile(hQPipe, "q", 1, &dwRead, NULL) || (dwRead != 1))
    {
        fputs("\nError: Can't send command\n", stdout);
        goto failure;
    }

    // read msg dimension
    if(!ReadFile(hQPipe, &msgLen, sizeof(int), &dwRead, NULL) || (dwRead != sizeof(int)))
    {
        fputs("\nError: Can't read message\n", stdout);
        goto failure;
    }

    if(!msgLen)
    {
        printf("\nNo visible sessions on server %s", pszServer);
        goto failure;
    }

    if(msgLen > 65535)        // error
    {
        printf("Error querying server %s, got %d for msg length, 65535 max.\n",
               pszServer,
               msgLen
               );
        goto failure;
    }

    // +1 for null terminator
    if((msg = (char*)malloc( (msgLen +1) *sizeof(char))) == NULL)
    {
        fputs("\nOut of memory\n", stdout);
        goto failure;
    }

    if (!ReadFile(hQPipe, msg, msgLen * sizeof(char), &dwRead, NULL)) {
        fputs("\nUnable to read from pipe\n", stdout);
        goto failure;
    }

    // Make sure the string is terminated
    msg[dwRead] = 0;

    printf("\nVisible sessions on server %s:\n\n", pszServer);

    fputs(msg, stdout);
    fputs("\n",stdout);
    free(msg);

 failure:

    CloseHandle(hQPipe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\rdsrelay.c ===
//
// rdsrelay.c
//
// Relays recieved remote.exe broadcasts (for remoteds.exe)
// to another domain/workgroup.
//
// WARNING:  There are no checks in this program for looping
//           relays, only one copy should be run per network.
//           I wrote this to relay ntdev remote.exe broadcasts
//           to ntwksta so that remoteds.exe running on \\ntstress
//           can see remote servers in both ntdev and ntwksta.
//           \\ntstress is in ntwksta.
//
// Usage:
//
//    rdsrelay <targetdomain>
//
//
// Dave Hart (davehart) written Aug 29, 1997.
//
// Copyright 1997 Microsoft Corp.
//
//

#include <precomp.h>

typedef char BUF[1024];

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    char   *pszReceiveMailslot = "\\\\.\\MAILSLOT\\REMOTE\\DEBUGGERS";
    HANDLE  hReceiveMailslot;
    HANDLE  hSendMailslot;
    BOOL    b;
    DWORD   dwErr;
    int     nReceived = 0;
    int     nRelayed = 0;
    int     iBuf;
    DWORD   cbWritten;
    DWORD   rgcbBuf[2];
    char    szSendMailslot[128];
    BUF     rgBuf[2];

    if (argc != 2) {
        printf("Usage: \n"
               "rdsrelay <targetdomain>\n");
        return 1;
    }

    sprintf(szSendMailslot, "\\\\%s\\MAILSLOT\\REMOTE\\DEBUGGERS", argv[1]);
    printf("Relaying remote.exe broadcasts to %s.\n", szSendMailslot);

    hReceiveMailslot =
        CreateMailslot(
            pszReceiveMailslot,
            0,
            MAILSLOT_WAIT_FOREVER,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hReceiveMailslot) {

        dwErr = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwErr) {
            printf("Cannot receive on %s,\n"
                   "is rdsrelay or remoteds already running on this machine?\n",
                   pszReceiveMailslot);
        } else {
            printf("CreateMailslot(%s) failed error %d\n",
                    pszReceiveMailslot,
                    dwErr);
        }
        return 2;
    }

    hSendMailslot =
        CreateFile(
            szSendMailslot,
            GENERIC_WRITE,
            FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hSendMailslot) {

        printf("CreateFile(%s) failed error %d\n",
                pszReceiveMailslot,
                GetLastError());
        return 3;
    }

    iBuf = 0;
    ZeroMemory(rgcbBuf, sizeof(rgcbBuf));
    ZeroMemory(rgBuf, sizeof(rgBuf));

    while(TRUE)
    {
        printf("\r%d received, %d relayed", nReceived, nRelayed);

        //
        // Multiple transports mean we get duplicates for
        // each transport shared by us and the sender.
        // Meanwhile when we relay on we generate duplicates
        // for each transport shared by this machine and
        // the remoteds.exe receiver(s) on the domain we're
        // relaying to.  They will eliminate duplicates, but
        // to avoid exponential effects we should eliminate
        // duplicates before relaying.  Thus the two buffers
        // in rgBuf, we alternate between them, and compare
        // the two to see if the last and this are dupes.
        //

        b = ReadFile(
                hReceiveMailslot,
                rgBuf[ iBuf ],
                sizeof(rgBuf[ iBuf ]),
                &rgcbBuf[ iBuf ],
                NULL
                );

        if (! b) {
            printf("ReadFile(hReceiveMailslot) failed error %d\n", GetLastError());
            return 4;
        }

        nReceived++;

        if ( rgcbBuf[0] == rgcbBuf[1] &&
             ! memcmp(rgBuf[0], rgBuf[1], rgcbBuf[0])) {

            continue;               // duplicate
        }

        b = WriteFile(
                hSendMailslot,
                rgBuf[ iBuf ],
                rgcbBuf[ iBuf ],
                &cbWritten,
                NULL
                );

        if (! b) {
            printf("WriteFile(hSendMailslot) failed error %d\n", GetLastError());
            return 5;
        }

        if (cbWritten != rgcbBuf[ iBuf ]) {
            printf("WriteFile(hSendMailslot) wrote %d instead of %d.\n", cbWritten, rgcbBuf[ iBuf ]);
            return 6;
        }

        nRelayed++;

        iBuf = !iBuf;

    }

    return 0;    // never executed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\remote.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1993 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1993 - 1997 Microsoft Corporation

Module Name:

    Remote.c

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath  2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"

char   HostName[HOSTNAMELEN];
char*  ChildCmd;
char*  PipeName;
char*  ServerName;
char * DaclNames[ MAX_DACL_NAMES ];
DWORD  DaclNameCount = 0;
char * DaclDenyNames[ MAX_DACL_NAMES ];
DWORD  DaclDenyNameCount = 0 ;
BOOL   SaveDaclToRegistry ;
HANDLE MyStdOut;
HANDLE hAttachedProcess = INVALID_HANDLE_VALUE;
HANDLE hAttachedWriteChildStdIn = INVALID_HANDLE_VALUE;
HANDLE hAttachedReadChildStdOut = INVALID_HANDLE_VALUE;

BOOL   IsAdvertise;
DWORD  ClientToServerFlag;
BOOL   bForceTwoPipes;

typedef struct _tagKeywordAndColor
{
    char *szKeyword;
    WORD color;
    struct _tagKeywordAndColor *next;
} KeywordAndColor;
KeywordAndColor *pKeyColors;

const char* ColorList[]={"black" ,"blue" ,"green" ,"cyan" ,"red" ,"purple" ,"yellow" ,"white",
                   "lblack","lblue","lgreen","lcyan","lred","lpurple","lyellow","lwhite"};

typedef enum { LINE_TOO_LONG } WARNING_MESSAGE;

VOID
DisplayWarning(
    WARNING_MESSAGE warn
    );

WORD
GetColorNum(
    char* color
    );

VOID
SetColor(
    WORD attr
    );

BOOL
GetColorFromBuffer(
    char **ppBuffer,
    char *pBufferInvalid,
    WORD *color,
    BOOL bStayOnLine
    );

VOID
AssocKeysAndColors(
    KeywordAndColor **ppKeyAndColors,
    char *szFileName
    );

BOOL
GetNextConnectInfo(
    char** SrvName,
    char** PipeName
    );



CONSOLE_SCREEN_BUFFER_INFO csbiOriginal;

int
__cdecl
main(
    int    argc,
    char** argv
    )
{
    WORD  RunType;              // Server or Client end of Remote
    DWORD len=HOSTNAMELEN;
    int   i, FirstArg;

    char  sTitle[120];          // New Title
    char  orgTitle[200];        // Old Title
    BOOL  bPromptForArgs=FALSE; // Is /P option
    WORD  wAttrib;              // Console Attributes
    int   privacy;              // Allows exposing or hidng sessions to remote /q
    BOOL  Deny ;
    int   rc=1;

    GetComputerName((LPTSTR)HostName,&len);

    MyStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (GetConsoleScreenBufferInfo(MyStdOut,&csbiOriginal)) {

        wAttrib = csbiOriginal.wAttributes;
        if (!GetConsoleTitle(orgTitle,sizeof(orgTitle))) {
            orgTitle[0] = 0;
        }

    } else {

        //
        // either stdout is a pipe, or it wasn't opened for
        // GENERIC_READ along with GENERIC_WRITE, in which
        // case our color manipulations will work so we need
        // to pick default colors.
        //

        wAttrib = FOREGROUND_GREEN |
                  FOREGROUND_INTENSITY;

        orgTitle[0] = 0;
    }

    privacy = PRIVACY_DEFAULT;

    pKeyColors = NULL;


    //
    // Parameter Processing
    //
    // For Server:
    // Remote /S <Executable>  <PipeName> [Optional Params]
    //
    // For Client:
    // Remote /C <Server Name> <PipeName> [Optional Params]
    // or
    // Remote /P
    // This will loop continously prompting for different
    // Servers and Pipename


    if ((argc<2)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
    {

        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    switch(argv[1][1])
    {
    case 'c':
    case 'C':

        //
        // Is Client End of Remote
        //

        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ServerName=argv[2];
        PipeName=argv[3];
        FirstArg=4;
        RunType=RUNTYPE_CLIENT;
        break;


    case 'q':
    case 'Q':

        //
        //  Query for possible conexions
        //


        if ((argc != 3)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        QueryRemotePipes(argv[2]);  //  Send ServerName as a param
        return(0);


    case 'p':
    case 'P':

        //
        // Is Client End of Remote
        //

        bPromptForArgs=TRUE;
        RunType=RUNTYPE_CLIENT;
        FirstArg=2;
        break;


    case 's':
    case 'S':
        //
        // Is Server End of Remote
        //
        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ChildCmd=argv[2];
        PipeName=argv[3];
        FirstArg=4;

        RunType=REMOTE_SERVER;
        break;


    case 'a':
    case 'A':
        //
        // Is Server End of Remote Attaching to existing process.
        //
        if ((argc<7)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        hAttachedProcess = (HANDLE)IntToPtr(atoi(argv[2]));
        hAttachedWriteChildStdIn = (HANDLE)IntToPtr(atoi(argv[3]));
        hAttachedReadChildStdOut = (HANDLE)IntToPtr(atoi(argv[4]));
        ChildCmd=argv[5]; // for display only
        PipeName=argv[6];
        FirstArg=7;

        RunType = REMOTE_SERVER;
        privacy = PRIVACY_VISIBLE;  // presumably ntsd/*kd
        break;

    default:
        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    if (RunType==REMOTE_SERVER)
    {
        //
        // Base Name of Executable
        // For setting the title
        //

        char *tcmd=ChildCmd;

        while ((*tcmd!=' ')      && (*tcmd!=0))    tcmd++;
        while ((tcmd > ChildCmd) && (*tcmd!='\\')) tcmd--;
        if (*tcmd=='\\') tcmd++;
        ZeroMemory(sTitle, sizeof(sTitle));
        _snprintf(sTitle,sizeof(sTitle),"%-41.40s [Remote /C %s \"%.30s\"]",tcmd,HostName,PipeName);
    }

    //
    //Process Common (Optional) Parameters
    //

    for (i=FirstArg;i<argc;i++)
    {

        if ((argv[i][0]!='/')&&(argv[i][0]!='-'))
        {
            printf("Invalid parameter %s:Ignoring\n",argv[i]);
            continue;
        }

        switch(argv[i][1])
        {
        case 'l':    // Only Valid for client End
        case 'L':    // Max Number of Lines to recieve from Server
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            LinesToSend=(DWORD)atoi(argv[i])+1;
            break;

        case 't':    // Title to be set instead of the default
        case 'T':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            ZeroMemory(sTitle, sizeof(sTitle));
            strncpy(sTitle,argv[i], sizeof(sTitle)/sizeof(sTitle[0])-1);
            break;

        case 'b':    // Background color
        case 'B':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    wAttrib=col<<4|(wAttrib&0x000f);
                }
                break;
            }

        case 'f':    // Foreground color
        case 'F':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    wAttrib=col|(wAttrib&0x00f0);
                }
                break;
            }

        case 'k':    // Color "keyword" lines
        case 'K':
            i++;
            // Currently only support client-side coloring
            if (RunType==REMOTE_SERVER)
            {
                printf("%s invalid on server side..Ignoring\n",argv[i-1]);
                break;
            }
            else if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            else
            {
                AssocKeysAndColors( &pKeyColors, argv[i] );
                break;
            }

        case 'v':
        case 'V':
            privacy = PRIVACY_VISIBLE;
            break;

        case '-':
            if( (argv[i][2] == 'v')
                || (argv[i][2] == 'V'))
                privacy = PRIVACY_NOT_VISIBLE;
            else
                printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]);
            break;

        case 'q':
        case 'Q':
            ClientToServerFlag|=0x80000000;
            break;

        case 'u':
        case 'U':
            if ( (argv[i][2] == 'd') ||
                 (argv[i][2] == 'D' ) )
            {
                Deny = TRUE ;
            }
            else if ( (argv[i][2] == 's' ) ||
                      (argv[i][2] == 'S' ) )
            {
                SaveDaclToRegistry = TRUE ;
                break;
                
            }
            else
            {
                Deny = FALSE ;
            }

            i++ ;

            if ( i >= argc )
            {
                printf( "Incomplete Param %s..Ignoring\n", argv[i-1] );
                break;
            }

            if ( Deny )
            {
                if (DaclDenyNameCount == MAX_DACL_NAMES )
                {
                    printf("Too many names specified (max %d).  Ignoring user %s\n",
                            MAX_DACL_NAMES, argv[i] );

                    break;
                }

                DaclDenyNames[ DaclDenyNameCount++ ] = argv[i];

            }
            else
            {
                if (DaclNameCount == MAX_DACL_NAMES )
                {
                    printf("Too many names specified (max %d).  Ignoring user %s\n",
                            MAX_DACL_NAMES, argv[i] );

                    break;
                }

                DaclNames[ DaclNameCount++ ] = argv[i];

            }

            break;

        case '2':
            bForceTwoPipes = TRUE;
            break;

        default:
            printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]);
            break;

        }

    }

    //
    //Now Set various Parameters
    //

    //
    //Colors
    //

    SetColor(wAttrib);

    if (RunType==RUNTYPE_CLIENT)
    {
        BOOL done=FALSE;
        BOOL gotinfo;

        //
        // Set Client end defaults and start client
        //

        while(!done)
        {
            if (!bPromptForArgs ||
                (gotinfo = GetNextConnectInfo(&ServerName,&PipeName))
               )
            {
                ZeroMemory(sTitle, sizeof(sTitle));
                _snprintf(sTitle,sizeof(sTitle), "Remote /C %s \"%s\"",ServerName,PipeName);
                SetConsoleTitle(sTitle);

                //
                // Start Client (Client.C)
                //
                rc = Client(ServerName,PipeName);
            }
            done = !bPromptForArgs || !gotinfo;
        }
    }

    if (RunType==REMOTE_SERVER)
    {
        if (privacy == PRIVACY_VISIBLE ||
             (privacy == PRIVACY_DEFAULT && IsKdString(ChildCmd))) {

            strncat(sTitle, " visible", sizeof(sTitle) - strlen(sTitle) - 1);
            IsAdvertise = TRUE;
        }

        SetConsoleTitle(sTitle);

        rc = OverlappedServer(ChildCmd, PipeName);
    }

    //
    //Reset Colors
    //
    SetColor(csbiOriginal.wAttributes);
    if (orgTitle[0]) {
        SetConsoleTitle(orgTitle);
    }

    return rc;
}

/*************************************************************/
VOID
ErrorExit(
    char* str
    )
{
    extern PSZ pszPipeName;
    DWORD dwErr;

    dwErr = GetLastError();

    printf("REMOTE error %d: %s\n", dwErr, str);

    #if DBG
    {
        char szMsg[1024];

        _snprintf(szMsg, sizeof(szMsg), "REMOTE error %d: %s\n", dwErr, str);
        OutputDebugString(szMsg);

        if (pszPipeName) {               // ad-hoc:  if server
            if (IsDebuggerPresent()) {
                DebugBreak();
            }
        }
    }
    #endif

    exit(1);
}

/*************************************************************/
VOID
DisplayClientHlp()
{
    printf("\n"
           "   To Start the CLIENT end of REMOTE\n"
           "   ---------------------------------\n"
           "   Syntax : REMOTE /C <ServerName> \"<Unique Id>\" [Param]\n"
           "   Example1: REMOTE /C %s imbroglio\n"
           "            This would connect to a server session on %s with Id\n"
           "            \"imbroglio\" if there is a REMOTE /S <\"Cmd\"> imbroglio\n"
           "            running on %s.\n\n"
           "   Example2: REMOTE /C %s \"name with spaces\"\n"
           "            This would connect to a server session on %s with Id\n"
           "            \"name with spaces\" if there is a REMOTE /S <\"Cmd\"> \"name with spaces\"\n"
           "            running on %s.\n\n"
           "   To Exit: %cQ (Leaves the Remote Server Running)\n"
           "   [Param]: /L <# of Lines to Get>\n"
           "   [Param]: /F <Foreground color eg blue, lred..>\n"
           "   [Param]: /K <Set keywords and colors from file>\n"
           "   [Param]: /B <Background color eg cyan, lwhite..>\n"
           "\n"
           "   Keywords And Colors File Format\n"
           "   -------------------------------\n"
           "   <KEYWORDs - CASE INSENSITIVE>\n"
           "   <FOREGROUND>[, <BACKGROUND>]\n"
           "   ...\n"
           "   EX:\n"
           "       ERROR\n"
           "       black, lred\n"
           "       WARNING\n"
           "       lblue\n"
           "       COLOR THIS LINE\n"
           "       lgreen\n"
           "\n"
           "   To Query the visible sessions on a server\n"
           "   -----------------------------------------\n"
           "   Syntax:  REMOTE /Q %s\n"
           "            This would retrieve the available <Unique Id>s\n"
           "            visible connections on the computer named %s.\n"
           "\n",
           HostName, HostName, HostName,
           HostName, HostName, HostName,
           COMMANDCHAR, HostName, HostName);
}
/*************************************************************/

VOID
DisplayServerHlp()
{
    printf("\n"
           "   To Start the SERVER end of REMOTE\n"
           "   ---------------------------------\n"
           "   Syntax : REMOTE /S <\"Cmd\">     <Unique Id> [Param]\n"
           "   Example1: REMOTE /S \"i386kd -v\" imbroglio\n"
           "            To interact with this \"Cmd\" from some other machine,\n"
           "            start the client end using:  REMOTE /C %s imbroglio\n\n"
           "   Example2: REMOTE /S \"i386kd -v\" \"name with spaces\"\n"
           "            start the client end using:  REMOTE /C %s \"name with spaces\"\n\n"
           "   To Exit: %cK \n"
           "   [Param]: /F  <Foreground color eg yellow, black..>\n"
           "   [Param]: /B  <Background color eg lblue, white..>\n"
           "   [Param]: /U  username or groupname\n"
           "                specifies which users or groups may connect\n"
           "                may be specified more than once, e.g\n"
           "                /U user1 /U group2 /U user2\n"
           "   [Param]: /UD username or groupname\n"
           "                specifically denies access to that user or group\n"
           "   [Param]: /V  Makes this session visible to remote /Q\n"
           "   [Param]: /-V Hides this session from remote /q (invisible)\n"
           "                By default, if \"Cmd\" looks like a debugger,\n"
           "                the session is visible, otherwise not\n"
           "\n",
           HostName, HostName, COMMANDCHAR);
}

VOID
DisplayWarning(
    WARNING_MESSAGE warn
    )
{
    switch ( warn )
    {
        case LINE_TOO_LONG:
            fputs( "\n[REMOTE: WARNING: LINE TOO LONG TO PARSE FOR COLOR KEYWORDS]\n", stdout );
            break;
        default:
            fputs( "\n[REMOTE: WARNING: UNSPECIFIED PROBLEM COLORING LINE]\n", stdout );
    }
}

WORD
GetColorNum(
    char *color
    )
{
    WORD i;

    _strlwr(color);
    for (i=0;i<16;i++)
    {
        if (strcmp(ColorList[i],color)==0)
        {
            return(i);
        }
    }
    return ((WORD)atoi(color));
}

VOID
SetColor(
    WORD attr
    )
{
    COORD  origin={0,0};
    DWORD  dwrite;
    FillConsoleOutputAttribute
    (
        MyStdOut,attr,csbiOriginal.dwSize.
        X*csbiOriginal.dwSize.Y,origin,&dwrite
    );
    SetConsoleTextAttribute(MyStdOut,attr);
}

BOOL
pColorLine(
    char *sLine,
    int cbLine,
    WORD wDefaultColor,
    WORD *color
    )
{
    KeywordAndColor *pCurKeyColor = NULL;
    char *pString1;
    int cbCmpString;

    pCurKeyColor = pKeyColors;
    while ( pCurKeyColor )
    {
        cbCmpString = strlen( pCurKeyColor->szKeyword );
        pString1 = sLine;
        // Need to do case-insensitive compare
        while ( pString1 <= sLine + cbLine - cbCmpString )
        {
            if ( !_memicmp( (PVOID)pString1,
                            (PVOID)pCurKeyColor->szKeyword,
                            cbCmpString ) )
            {
                *color = pCurKeyColor->color;
                // Check if we are to use default background color
                if ( (0xfff0 & *color) == 0xfff0 )
                    *color = (wDefaultColor & 0x00f0) |
                             (*color & 0x000f);
                return TRUE;
            }

            pString1++;
        }

        // Next keyword/color combination
        pCurKeyColor = pCurKeyColor->next;
    }

    return FALSE;
}

BOOL
pWantColorLines(
    VOID
    )
{
    return ( NULL != pKeyColors );
}

VOID
AssocKeysAndColors(
    KeywordAndColor **ppKeyColors,
    char *szFileName
    )
{
    char szPathName[_MAX_PATH],
         *szSimpleName;
    char *buffer,
         *pBegin,
         *pEnd;

    USHORT usForeColor,
           usBackColor;

    KeywordAndColor *pCurKeyColor,
                    *pNextKeyColor;

    HANDLE hFile;
    WIN32_FIND_DATA wfdInfo;
    DWORD dwBytesRead;

    // Locate the specified file somewhere in the path
    if ( !SearchPath( NULL,
                      szFileName,
                      NULL,
                      _MAX_PATH,
                      szPathName,
                      &szSimpleName ) )
    {
        fprintf( stderr, "Error locating keyword/color file \"%s\"!\n",
                 szFileName );
        return;
    }

    // Get the size of the file so we can read all of it in
    hFile = FindFirstFile( szPathName, &wfdInfo );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        fprintf( stderr, "Error locating keyword/color file \"%s\"!\n",
                 szPathName );
        return;
    }
    FindClose( hFile );
    hFile = INVALID_HANDLE_VALUE;

    if ( wfdInfo.nFileSizeLow < 5 ||
         wfdInfo.nFileSizeHigh )
    {
        fprintf( stderr, "Invalid keyword/color file: %s!\n",
                 szPathName );
        return;
    }

    // Allocate memory to store file contents
    buffer = malloc( wfdInfo.nFileSizeLow );
    if ( NULL == buffer )
    {
        fputs( "Error!  Unable to allocate memory to read in keyword/color file!\n", stderr );
        return;
    }

    // Attempt to open the given file-name
    hFile = CreateFile( szPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        fprintf( stderr, "Error opening keyword/color file %s!\n",
                 szPathName );
        return;
    }

    // Attempt to read in the contents of the file
    if (!ReadFile( hFile, buffer, wfdInfo.nFileSizeLow, &dwBytesRead, NULL ))
    {
        fprintf( stderr, "Error reading keyword/color file: %s!\n", szPathName );
        free( buffer );
        return;
    }

    CloseHandle( hFile );

    if ( dwBytesRead != wfdInfo.nFileSizeLow )
    {
        fprintf( stderr, "Error reading keyword/color file: %s!\n", szPathName );
        free( buffer );
        return;
    }

    // Parse contents of file, storing keyword(s) and color combinations
    pBegin = buffer;
    pCurKeyColor = NULL;
    while ( pBegin < buffer + dwBytesRead )
    {
        // Skip any newline/CR at beginning
        while ( pBegin < buffer + dwBytesRead &&
                ( *pBegin == '\r' ||
                  *pBegin == '\n' ) ) pBegin++;
        if ( pBegin >= buffer + dwBytesRead )
            continue;

        pEnd = pBegin;
        while ( pEnd < buffer + dwBytesRead &&
                *pEnd != '\r' ) pEnd++;
        // point at last character
        pEnd--;

        // Add new KeywordAndColor member to list
        if ( NULL == pCurKeyColor )
        {
            *ppKeyColors = pCurKeyColor = malloc( sizeof( KeywordAndColor ) );
        }
        else
        {
            pCurKeyColor->next = malloc( sizeof( KeywordAndColor ) );
            pCurKeyColor = pCurKeyColor->next;
        }

        // Verify we allocated memory for another list member
        if ( NULL == pCurKeyColor )
        {
            fputs( "Error allocating memory for keyword/color storage!\n", stderr );
            // Cleanup any we did create
            while ( *ppKeyColors )
            {
                pCurKeyColor = ((KeywordAndColor *)*ppKeyColors)->next;
                if ( ((KeywordAndColor *)*ppKeyColors)->szKeyword )
                    free( ((KeywordAndColor *)*ppKeyColors)->szKeyword );
                free( (KeywordAndColor *)*ppKeyColors );
                (KeywordAndColor *)*ppKeyColors = pCurKeyColor;
            }

            return;
        }

        // This is now the last member of the list
        pCurKeyColor->next = NULL;

        // Already have keyword(s) -- allocate room for it
        pCurKeyColor->szKeyword = malloc( pEnd - pBegin + 2 );
        if ( NULL == pCurKeyColor->szKeyword )
        {
            fputs( "Error allocating memory for keyword/color storage!\n", stderr );
            // Cleanup any we did create
            while ( *ppKeyColors )
            {
                pCurKeyColor = ((KeywordAndColor *)*ppKeyColors)->next;
                if ( ((KeywordAndColor *)*ppKeyColors)->szKeyword )
                    free( ((KeywordAndColor *)*ppKeyColors)->szKeyword );
                free( (KeywordAndColor *)*ppKeyColors );
                *ppKeyColors = pCurKeyColor;
            }

            return;
        }

        // Store keyword(s)
        memcpy( (PVOID)pCurKeyColor->szKeyword, (PVOID)pBegin, pEnd-pBegin+1 );
        pCurKeyColor->szKeyword[pEnd-pBegin+1] = '\0';

        pBegin = pEnd + 1;
        // Get color information
        if ( GetColorFromBuffer( &pBegin,
                                 (char *)(buffer + dwBytesRead),
                                 &usForeColor,
                                 FALSE ) )
        {
            // Check if there is a comma following
            while ( pBegin < buffer + dwBytesRead &&
                    *pBegin != ',' &&
                    *pBegin != '\r' ) pBegin++;
            if ( *pBegin == ',' )
            {
                pBegin++;
                if ( GetColorFromBuffer( &pBegin,
                                         (char *)(buffer + dwBytesRead),
                                         &usBackColor,
                                         TRUE ) )
                    goto noError;
            }
            else
            {
                // Default to current background color
                usBackColor = 0xffff;
                goto noError;
            }
        }
        // ERROR
        fprintf( stderr, "Invalid color information for: %s\n", pCurKeyColor->szKeyword );
        // We will leave any previous entries but delete this one
        pNextKeyColor = *ppKeyColors;
        if ( pNextKeyColor == pCurKeyColor )
        {
            free( pCurKeyColor );
            *ppKeyColors = NULL;
        }
        else
        {
            while ( pCurKeyColor != pNextKeyColor->next )
                pNextKeyColor = pNextKeyColor->next;
            free ( pCurKeyColor );
            pNextKeyColor->next = NULL;
        }
        return;

noError:
        // Store color information
        if ( usBackColor == 0xffff )
            pCurKeyColor->color = 0xfff0 |
                                  (usForeColor & 0x0f);
        else
            pCurKeyColor->color = ((usBackColor << 4) & 0x00f0) |
                                  (usForeColor & 0x0f );
    }
}

BOOL
GetColorFromBuffer(
    char **ppBuffer,
    char *pBufferInvalid,
    WORD *color,
    BOOL bStayOnLine
    )
{
    char *pBegin,
         *pEnd,
         temp;

    pBegin = *ppBuffer;
    if ( bStayOnLine )
    {
        // Skip to the next character (on this line)
        while ( pBegin < pBufferInvalid &&
                !isalnum( (int)*pBegin ) &&
                *pBegin != '\r' ) pBegin++;
    }
    else
    {
        // Skip to next character (in buffer)
        while ( pBegin < pBufferInvalid &&
                !isalnum( (int)*pBegin ) ) pBegin++;
    }

    if ( pBegin >= pBufferInvalid ||
         *pBegin == '\r' )
        return FALSE;

    // Read in color
    pEnd = pBegin + 1;
    while ( isalnum( (int)*pEnd ) &&
            *pEnd != ',' ) pEnd++;

    temp = *pEnd;
    *pEnd = '\0';
    *color = GetColorNum( pBegin );
    *pEnd = temp;

    // Use same valid color check as used for foreground/background
    if ( *color == 0xffff )
        return FALSE;

    // Move the pointer we were given to next unread portion
    *ppBuffer = pEnd;

    return TRUE;
}

BOOL
GetNextConnectInfo(
    char** SrvName,
    char** PipeName
    )
{
    char *s;

    static char szServerName[64];
    static char szPipeName[32];
    int StringLen;

    try
    {
        ZeroMemory(szServerName,64);
        ZeroMemory(szPipeName,32);
        SetConsoleTitle("Remote - Prompting for next Connection");
        fputs("Debugger machine (server): ", stdout);
        fflush(stdout);

        if (!fgets(szServerName, sizeof(szServerName), stdin)) {
            return FALSE;
        }

        StringLen = strlen(szServerName);

        if (!StringLen || (!feof(stdin) && szServerName[StringLen-1] != '\n')) {
            return FALSE;
        }

        if (szServerName[StringLen-1] == '\n') {
            if (StringLen == 1) {
                return (FALSE);
            }
            szServerName[StringLen-1] = '\0';
        }

        if (szServerName[0] == COMMANDCHAR &&
            (szServerName[1] == 'q' || szServerName[1] == 'Q')
           )
        {
            return(FALSE);
        }


        if (s = strchr( szServerName, ' ' )) {
            *s++ = '\0';
            while (*s == ' ') {
                s += 1;
            }
            *PipeName=strcpy(szPipeName, s);
            fputs(szPipeName, stdout);
            fflush(stdout);
        }
        if (strlen(szPipeName) == 0) {
            fputs("Target machine (pipe)    : ", stdout);
            fflush(stdout);

            if (!fgets(szPipeName, sizeof(szPipeName), stdin)) {
                return FALSE;
            }
    
            StringLen = strlen(szPipeName);
    
            if (!StringLen || (!feof(stdin) && szPipeName[StringLen-1] != '\n')) {
                return FALSE;
            }
    
            if (szPipeName[StringLen-1] == '\n') {
                szPipeName[StringLen-1] = '\0';
            }
        }

        if (s = strchr(szPipeName, ' ')) {
            *s++ = '\0';
        }

        if (szPipeName[0] == COMMANDCHAR &&
            (szPipeName[1] == 'q' || szPipeName[1] == 'Q')
           )
        {
            return(FALSE);
        }
        fputs("\n\n", stdout);
    }

    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);  // Ignore exceptions
    }

    *SrvName = szServerName;
    *PipeName = szPipeName;

    return(TRUE);
}


/*************************************************************/

VOID
Errormsg(
    char* str
    )
{
    printf("Error (%d) - %s\n",GetLastError(),str);
}

/*************************************************************/

BOOL
IsKdString(
    char* string
    )
{

    char* start;

    //
    // some heuristic for uninvented yet platforms
    // if the first word has "kd" in it ok
    //

    if(    ((start = strstr(string, "kd")) != NULL)
        || ((start = strstr(string, "dbg")) != NULL)
        || ((start = strstr(string, "remoteds")) != NULL)
        || ((start = strstr(string, "ntsd")) != NULL)
        || ((start = strstr(string, "cdb")) != NULL) )
    {
        // is it in the first word?
        while(--start > string)
        {
            if((*start == ' ') || (*start == '\t'))
            {
                while(--start > string)
                    if((*start != '\t') && (*start != ' '))
                        return(FALSE);
            }
        }
        return TRUE;
    }
    return(FALSE);
}


//
// WriteFileSynch is a synchronous WriteFile for overlapped
// file handles.  As a special case, two-pipe client operation
// sets fAsyncPipe FALSE and this routine then passes NULL
// for lpOverlapped.
//

BOOL
FASTCALL
WriteFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    )
{
    BOOL Success;


    lpO->OffsetHigh = 0;
    lpO->Offset = dwFileOffset;

    Success =
        WriteFile(
            hFile,
            lpBuffer,
            cbWrite,
            lpNumberOfBytesWritten,
            fAsyncPipe ? lpO : NULL
            );

    if ( ! Success ) {

        if (ERROR_IO_PENDING == GetLastError()) {

            Success =
                GetOverlappedResult(
                    hFile,
                    lpO,
                    lpNumberOfBytesWritten,
                    TRUE
                    );
        }
    }

    return Success;
}


BOOL
FASTCALL
ReadFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    )
{
    BOOL Success;

    lpO->OffsetHigh = 0;
    lpO->Offset = dwFileOffset;

    Success =
        ReadFile(
            hFile,
            lpBuffer,
            cbRead,
            lpNumberOfBytesRead,
            fAsyncPipe ? lpO : NULL
            );

    if ( ! Success ) {

        if (ERROR_IO_PENDING == GetLastError()) {

            Success =
                GetOverlappedResult(
                    hFile,
                    lpO,
                    lpNumberOfBytesRead,
                    TRUE
                    );
        }
    }

    return Success;
}

BOOL
FASTCALL
WriteConsoleWithColor(
    HANDLE MyStdOut,
    char *buffer,
    DWORD cbBuffer,
    CWCDATA *persist
    )
{
    DWORD cbWrite,
          cbFill;
    WORD color;
    BOOL bAltColor,
         bNewLine,
         bCanColor = FALSE;
    char *pCurLine,
         *pEndOfLine,
         *pPrevLine,
         *pTemp;
    CONSOLE_SCREEN_BUFFER_INFO conBufferInfo;

    if ( persist->bLineContinues )
        bNewLine = FALSE;
    else
        bNewLine = TRUE;

    // Split buffer into individual lines
    pCurLine = buffer;
    while ( pCurLine < buffer + cbBuffer )
    {
        // Get console information
        bCanColor = GetConsoleScreenBufferInfo( MyStdOut, &conBufferInfo );

        // Find end of current line
        pEndOfLine = pCurLine;
        // Print out any beginning newlines/CR's -- this will avoid
        // coloring large blocks of nothing associated with keywords
        while ( pEndOfLine < buffer + cbBuffer &&
                ( *pEndOfLine == '\r' ||
                  *pEndOfLine == '\n' ) )
        {
            // New line
            if ( !bNewLine )
            {
                bNewLine = TRUE;

                // If this was a continuation line -- end it
                if ( persist->bLineContinues )
                {
                    persist->bLineContinues = FALSE;
                    // Check if we just ended a line that couldn't be parsed
                    // because of its size -- if so output warning
                    if ( persist->bLineTooLarge )
                        DisplayWarning( LINE_TOO_LONG );
                    // Otherwise check for keyword(s)
                    // and color if appropriate
                    else if ( bCanColor &&
                              pColorLine( persist->sLine,
                                          persist->cbCurPos + 1,
                                          conBufferInfo.wAttributes,
                                          &color ) )
                    {
                        // If we were unable to get the cursor position when
                        // the line started we won't be able to color it now,
                        // but because we aren't printing any warning elsewhere
                        // if we can't get console info, we will just quietly
                        // not output color here
                        if ( 0xFF != persist->cLineBegin.X ||
                             0xFF != persist->cLineBegin.Y )
                        {
                            // Color in beginning portion of line (actually all of
                            //  line up to current point gets colored to reduce
                            //  calculations)
                            FillConsoleOutputAttribute( MyStdOut,
                                                        color,
                                                        ( (conBufferInfo.dwCursorPosition.Y -
                                                           persist->cLineBegin.Y + 1) *
                                                          (conBufferInfo.srWindow.Right -
                                                           conBufferInfo.srWindow.Left) ),
                                                        persist->cLineBegin,
                                                        &cbFill );
                        }
                    }
                }
            }
            pEndOfLine++;
        }
        // Print newline characters if some were found
        if ( pEndOfLine > pCurLine )
        {
            if ( ! WriteFile(MyStdOut, pCurLine, (DWORD)(pEndOfLine - pCurLine), &cbWrite, NULL) )
            {
                // Bail out
                return FALSE;
            }

            // Move line pointer
            pCurLine = pEndOfLine;
        }

        // Get the line
        while ( pEndOfLine < buffer + cbBuffer &&
                *pEndOfLine != '\r' &&
                *pEndOfLine != '\n' ) pEndOfLine++;
        // If we got characters we are in a line
        // Check it for keywords or add it to
        // a continuation line and/or print it
        if ( pEndOfLine > pCurLine )
        {
            bNewLine = FALSE;

            // Point to last character
            pEndOfLine--;

            // Check for current console information
            if ( !bCanColor )
            {
                // Couldn't get information -- handle might
                // be redirected.  Don't change colors
                bAltColor = FALSE;
            }
            else if ( persist->bLineContinues )
            {
                // See if we have enough room to construct this new line
                if ( !persist->bLineTooLarge &&
                     (DWORD)(pEndOfLine - pCurLine + 1) >=
                     (persist->cbLine - persist->cbCurPos) )
                {
                    // Attempt to build a bigger buffer
                    pTemp = realloc( (PVOID)persist->sLine,
                                     persist->cbLine + (pEndOfLine - pCurLine + 1) );
                    if ( NULL == pTemp )
                    {
                        persist->bLineTooLarge = TRUE;
                    }
                    else
                    {
                        persist->sLine = pTemp;
                        persist->cbLine += (DWORD)(pEndOfLine - pCurLine + 1);
                    }
                }

                // Add this piece to the line
                if ( !persist->bLineTooLarge )
                {
                    // Add new piece to line
                    memcpy( (PVOID)(persist->sLine + persist->cbCurPos + 1),
                            (PVOID)pCurLine,
                            (pEndOfLine - pCurLine + 1) );
                    // Point at new end of line
                    persist->cbCurPos += (DWORD)(pEndOfLine - pCurLine + 1);
                }

                // Don't color this line portion
                bAltColor = FALSE;

            }
            // Check if line needs colored unless this is going
            // to be a continued line (last line in buffer and
            // does not end with a newline).  We do not want
            // to determine the color of the line until we
            // have the complete thing
            else if ( (char *)(pEndOfLine + 1) < (char *)(buffer + cbBuffer) )
            {
                // Parse line for keywords that will cause
                // this line to show up in a different color
                bAltColor = pColorLine( pCurLine,
                                        (DWORD)(pEndOfLine - pCurLine + 1),
                                        conBufferInfo.wAttributes,
                                        &color );
            }
            else
            {
                bAltColor = FALSE;
            }

            if ( bAltColor )
            {
                // Change color for output of this line
                SetConsoleTextAttribute( MyStdOut, color );
            }

            if ( ! WriteFile(MyStdOut, pCurLine, (DWORD)(pEndOfLine - pCurLine + 1), &cbWrite, NULL))
            {
                if ( bAltColor )
                {
                    SetConsoleTextAttribute( MyStdOut, conBufferInfo.wAttributes );
                }
                // Bail out
                return FALSE;
            }
            // Restore default colors if necessary
            if ( bAltColor )
            {
                SetConsoleTextAttribute( MyStdOut, conBufferInfo.wAttributes );
            }

            // Point to the next line, saving off this line
            // in case we need to store it in a continuation
            // line
            pPrevLine = pCurLine;
            pCurLine = pEndOfLine + 1;
        } // End only check line if there is one
    }

    // If the buffer did not end with a CR, and we are
    // not already in a continuation, remember this line
    if ( !bNewLine &&
         pPrevLine <= pEndOfLine &&
         !persist->bLineContinues )
    {
        persist->bLineContinues = TRUE;
        persist->bLineTooLarge = FALSE;

        if ( bCanColor )
            persist->cLineBegin = conBufferInfo.dwCursorPosition;
        else // Signal we were unable to obtain cursor location
        {
            persist->cLineBegin.X = 0xFF;
            persist->cLineBegin.Y = 0xFF;
        }

        // See if we have enough room to construct this new line
        if ( (DWORD)(pEndOfLine - pPrevLine + 1) >= persist->cbLine )
        {
            // Attempt to build a bigger buffer
            pTemp = realloc( (PVOID)persist->sLine,
                             persist->cbLine + (pEndOfLine - pPrevLine + 1) );
            if ( NULL == pTemp )
            {
                persist->bLineTooLarge = TRUE;
            }
            else
            {
                persist->sLine = pTemp;
                persist->cbLine = (DWORD)(pEndOfLine - pPrevLine + 1);
            }
        }

        // Store the beginning of the line
        if ( !persist->bLineTooLarge )
        {
            // Add new piece to line
            memcpy( (PVOID)persist->sLine,
                    (PVOID)pPrevLine,
                    (pEndOfLine - pPrevLine + 1) );
            // Point at new end of line
            persist->cbCurPos = (DWORD)(pEndOfLine - pPrevLine);
        }
    }

    // Success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\pipeex.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pipeex.c

Abstract:

    CreatePipe-like function that lets one or both handles be overlapped

Author:

    Dave Hart  Summer 1997

Revision History:

--*/

#include <precomp.h>

ULONG PipeSerialNumber;

BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    )

/*++

Routine Description:

    The CreatePipeEx API is used to create an anonymous pipe I/O device.
    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
    both handles.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE ReadPipeHandle, WritePipeHandle;
    DWORD dwError;
    UCHAR PipeNameBuffer[ MAX_PATH ];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    //  Set the default timeout to 120 seconds
    //

    if (nSize == 0) {
        nSize = 4096;
        }

    sprintf( PipeNameBuffer,
             "\\\\.\\Pipe\\RemoteExeAnon.%08x.%08x",
             GetCurrentProcessId(),
             PipeSerialNumber++
           );

    ReadPipeHandle = CreateNamedPipeA(
                         PipeNameBuffer,
                         PIPE_ACCESS_INBOUND | dwReadMode,
                         PIPE_TYPE_BYTE | PIPE_WAIT,
                         1,             // Number of pipes
                         nSize,         // Out buffer size
                         nSize,         // In buffer size
                         120 * 1000,    // Timeout in ms
                         lpPipeAttributes
                         );

    if (! ReadPipeHandle) {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(
                        PipeNameBuffer,
                        GENERIC_WRITE,
                        0,                         // No sharing
                        lpPipeAttributes,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
                        NULL                       // Template file
                      );

    if (INVALID_HANDLE_VALUE == WritePipeHandle) {
        dwError = GetLastError();
        CloseHandle( ReadPipeHandle );
        SetLastError(dwError);
        return FALSE;
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\server.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    Server.h

Abstract:

    The server component of Remote, rewritten using
    ReadFileEx/WriteFileEx completion routines.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <lm.h>                // needed for NET_API_STATUS below

#if !defined(SERVER_H_NOEXTERN)
#define SRVEXTERN extern
#else
#define SRVEXTERN
#endif


#if DBG
  DWORD Trace;         // bits set in here trigger trace printfs

  #define TR_SESSION            (0x01)
  #define TR_CHILD              (0x02)
  #define TR_SHAKE              (0x04)
  #define TR_CONNECT            (0x08)
  #define TR_QUERY              (0x10)
  #define TR_COPYPIPE           (0x20)
#endif


#if DBG
  #define TRACE(tracebit, printfargs)                        \
              ((Trace & (TR_##tracebit)                      \
                   ? (printf printfargs, fflush(stdout), 0)  \
                   : 0))
#else
  #define TRACE(tracebit, printfargs)    (0)
#endif

#if defined(ASSERT)
#undef ASSERT
#endif

#if DBG
  #define ASSERT(exp)  ((exp) || (ErrorExit("Assertion failed in " __FILE__ ": " #exp ),0))
#else
  #define ASSERT(exp)  (0)
#endif


//
// Size of transfer buffers
//

#define BUFFSIZE      (4 * 1024)

//
// ServerFlags bit values in REMOTE_CLIENT below
//

#define SFLG_CLOSING               0x01
#define SFLG_HANDSHAKING           0x02
#define SFLG_READINGCOMMAND        0x04
#define SFLG_LOCAL                 0x08

#define SFLG_VALID                 \
            (SFLG_CLOSING        | \
             SFLG_HANDSHAKING    | \
             SFLG_READINGCOMMAND | \
             SFLG_LOCAL)


//
// Per-client state
//

typedef struct tagREMOTE_CLIENT {
    LIST_ENTRY Links;
    DWORD   dwID;           // 1, 2, ...
    DWORD   ServerFlags;
    DWORD   Flag;           //from Client's ClientToServerFlag
    DWORD   cbWrite;        //zero if no read temp/write client ops pending
    HANDLE  PipeReadH;      //Client sends its StdIn  through this
    HANDLE  PipeWriteH;     //Client gets  its StdOut through this
    DWORD   dwFilePos;      //offset of temp file where next read begins
    OVERLAPPED ReadOverlapped;
    OVERLAPPED WriteOverlapped;
    HANDLE  rSaveFile;      //Sessions read handle to SaveFile
    DWORD   cbReadTempBuffer;
    DWORD   cbWriteBuffer;
    DWORD   cbCommandBuffer;
    char    HexAsciiId[8];         // dwID as 8 hex chars -- no terminator
    char    Name[HOSTNAMELEN];     //Name of client Machine;
    char    UserName[16];          //Name of user on client machine.
    BYTE    ReadBuffer[BUFFSIZE];
    BYTE    ReadTempBuffer[BUFFSIZE];
    BYTE    WriteBuffer[BUFFSIZE];
    BYTE    CommandBuffer[BUFFSIZE];
} REMOTE_CLIENT, *PREMOTE_CLIENT;

//
// Client lists, see srvlist.c
//

SRVEXTERN LIST_ENTRY       HandshakingListHead;
SRVEXTERN CRITICAL_SECTION csHandshakingList;

SRVEXTERN LIST_ENTRY       ClientListHead;
SRVEXTERN CRITICAL_SECTION csClientList;

SRVEXTERN LIST_ENTRY       ClosingClientListHead;
SRVEXTERN CRITICAL_SECTION csClosingClientList;


SRVEXTERN DWORD   dwNextClientID;
SRVEXTERN LPSTR   pszPipeName;
SRVEXTERN HANDLE  ChldProc;
SRVEXTERN DWORD   pidChild;
SRVEXTERN HANDLE  hWriteChildStdIn;
SRVEXTERN BOOL    bShuttingDownServer;
SRVEXTERN HANDLE  hHeap;

SRVEXTERN volatile DWORD cPendingCtrlCEvents;

SRVEXTERN OSVERSIONINFO OsVersionInfo;

// File containing all that was output by child process.
// Each connection opens a handle to this file
// and sends its contents through PipeWriteH.

SRVEXTERN HANDLE  hWriteTempFile;

SRVEXTERN char    SaveFileName[MAX_PATH]; //Name of above file - all new sessions need


//
// Generic "wide-open" security descriptor as well
// as the possibly-restricted pipe SD.
//

SRVEXTERN PSECURITY_DESCRIPTOR sdPublic;
SRVEXTERN SECURITY_ATTRIBUTES saPublic;
SRVEXTERN SECURITY_ATTRIBUTES saPipe;
SRVEXTERN SECURITY_ATTRIBUTES saLocalNamedObjects ;
extern BOOL SaveDaclToRegistry ;

//
// To minimize client "all pipe instances are busy" errors,
// we wait on connection to several instances of the IN pipe,
// the sole pipe used by single-pipe clients.  Because of the
// requirement to support two-pipe clients (old software as
// well as new software on Win95), we cannot easily create
// and wait for connection on several instances of the OUT pipe.
// This is because two-pipe clients connect to both pipes before
// handshaking commences, and they connect to OUT first.  If we
// had several OUT pipe instances waiting, when an IN pipe was
// connected by the two-pipe client, we wouldn't know which of
// the possibly several connected OUT pipe instances to pair
// it with.  With only one OUT pipe, at IN connect time we need
// to distinguish two-pipe from one-pipe clients so a one-pipe
// client doesn't sneak in between the OUT and IN connects of
// a two-pipe client and wrongly be paired with the OUT pipe.
// To do so we look at the first byte of the initial write
// from the client (of the computername and magic value), if
// it's a question mark we know we have a new client and won't
// accidentally link it to a connected OUT instance.
//

#define CONNECT_COUNT  3

SRVEXTERN DWORD      cConnectIns;
SRVEXTERN OVERLAPPED rgolConnectIn[CONNECT_COUNT];
SRVEXTERN HANDLE     rghPipeIn[CONNECT_COUNT];

SRVEXTERN OVERLAPPED olConnectOut;
SRVEXTERN BOOL       bOutPipeConnected;
SRVEXTERN HANDLE     hPipeOut;
SRVEXTERN HANDLE     hConnectOutTimer;

//
// Indexes into rghWait array for multiple-wait
//

#define WAITIDX_CHILD_PROCESS           0
#define WAITIDX_READ_STDIN_DONE         1
#define WAITIDX_QUERYSRV_WAIT           2
#define WAITIDX_PER_PIPE_EVENT          3
#define WAITIDX_CONNECT_OUT             4
#define WAITIDX_CONNECT_IN_BASE         5
#define MAX_WAIT_HANDLES                (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT)

SRVEXTERN HANDLE rghWait[MAX_WAIT_HANDLES];

SRVEXTERN OVERLAPPED ReadChildOverlapped;
SRVEXTERN HANDLE     hReadChildOutput;
SRVEXTERN BYTE       ReadChildBuffer[BUFFSIZE];

SRVEXTERN PREMOTE_CLIENT pLocalClient;

typedef struct tagCOPYPIPE {
    HANDLE     hRead;
    HANDLE     hWrite;
} COPYPIPE, *PCOPYPIPE;

SRVEXTERN COPYPIPE rgCopyPipe[2];

SRVEXTERN volatile DWORD dwWriteFilePointer;   // used by SrvCtrlHand (thread)

SRVEXTERN OVERLAPPED QueryOverlapped;
SRVEXTERN HANDLE hQPipe;

SRVEXTERN OVERLAPPED olMainThread;


BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    );

DWORD
WINAPI
CopyPipeToPipe(
    LPVOID   lpCopyPipeData
    );

DWORD
WINAPI
CopyStdInToPipe(
    LPVOID   lpCopyPipeData
    );

VOID
FASTCALL
StartSession(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
StartLocalSession(
    VOID
    );

VOID
FASTCALL
StartReadClientInput(
    PREMOTE_CLIENT pClient
    );

VOID
WINAPI
ReadClientInputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteChildStdInCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

#define OUT_PIPE -1

VOID
FASTCALL
CreatePipeAndIssueConnect(
    int  nIndex   // IN pipe index or OUT_PIPE
    );

VOID
FASTCALL
HandleOutPipeConnected(
    VOID
    );

VOID
APIENTRY
ConnectOutTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    );

VOID
FASTCALL
HandleInPipeConnected(
    int nIndex
    );

VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
StartChildOutPipeRead(
    VOID
    );

VOID
WINAPI
ReadChildOutputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteTempFileCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
StartServerToClientFlow(
    VOID
    );

VOID
FASTCALL
StartReadTempFile(
    PREMOTE_CLIENT pClient
    );

VOID
WINAPI
ReadTempFileCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
StartWriteSessionOutput(
    PREMOTE_CLIENT pClient
    );

BOOL
FASTCALL
WriteSessionOutputCompletedCommon(
    PREMOTE_CLIENT pClient,
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

VOID
WINAPI
WriteSessionOutputCompletedWriteNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteSessionOutputCompletedReadNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    );


VOID
WINAPI
ReadClientNameCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteServerReplyCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
ReadClientStartupInfoSizeCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
ReadClientStartupInfoCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

PCHAR
GetFormattedTime(
    BOOL bDate
    );

HANDLE
ForkChildProcess(          // Creates a new process
    char *cmd,             // Redirects its stdin,stdout
    PHANDLE in,            // and stderr - returns the
    PHANDLE out            // corresponding pipe ends.
    );

BOOL
FilterCommand(             //Filters input from client
    REMOTE_CLIENT *cl,      //for commands intended for REMOTE
    char *buff,
    int dread
    );

BOOL
WINAPI
SrvCtrlHand(
    DWORD event
    );

DWORD
WINAPI
SendStatus(
    LPVOID   lpSendStatusParm
    );

DWORD
WINAPI
ShowPopup(
    void *vpArg
    );

VOID
RemoveInpMark(
    char* Buff,
    DWORD Size
    );

VOID
CloseClient(
    REMOTE_CLIENT *Client
    );

PSECURITY_DESCRIPTOR
FormatSecurityDescriptor(
    CHAR * * DenyNames,
    DWORD    DenyCount,
    CHAR * * Names,
    DWORD    Count
    );

BOOL
FASTCALL
HandleSessionError(
    PREMOTE_CLIENT pClient,
    DWORD         dwError
    );

VOID
FASTCALL
CleanupTempFiles(
    PSZ pszTempDir
    );

VOID
FASTCALL
SetupSecurityDescriptors(
    VOID
    );

VOID
FASTCALL
InitializeClientLists(
    VOID
    );

VOID
FASTCALL
AddClientToHandshakingList(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
MoveClientToNormalList(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
MoveClientToClosingList(
    PREMOTE_CLIENT pClient
    );

PREMOTE_CLIENT
FASTCALL
RemoveFirstClientFromClosingList(
    VOID
    );


VOID
InitAd(
   BOOL IsAdvertise
   );

VOID
ShutAd(
   BOOL IsAdvertise
   );

VOID
APIENTRY
AdvertiseTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    );

VOID
WINAPI
WriteMailslotCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
InitializeQueryServer(
    VOID
    );

VOID
FASTCALL
QueryWaitCompleted(
    VOID
    );

VOID
FASTCALL
StartServingQueryPipe(
    VOID
    );

DWORD
WINAPI
QueryHandlerThread(
    LPVOID   lpUnused
    );

BOOL
CALLBACK
EnumWindowProc(
    HWND hWnd,
    LPARAM lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\remote.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1993 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1993 - 1997 Microsoft Corporation

Module Name:

    Remote.h

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath  2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/

#if !defined(FASTCALL)
#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif
#endif

#define VERSION         4
#define REMOTE_SERVER       1
#define RUNTYPE_CLIENT      2

#define SERVER_READ_PIPE    "\\\\%s\\PIPE\\%sIN"   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   "\\\\%s\\PIPE\\%sOUT"  //Server Writes and Client Reads

#define QUERY_DEBUGGERS_PIPE "\\\\%s\\PIPE\\QueryDebuggerPipe"

// PRIVACY_DEFAULT:     this session will be listed only if it looks like a debugging one
// PRIVACY_NON_VISIBLE: whatever the name of command, it will not show up with remote /q
// PRIVACY_VISIBLE:     this session will be visible for querying

#define PRIVACY_DEFAULT       1
#define PRIVACY_VISIBLE       2
#define PRIVACY_NOT_VISIBLE   3


#define COMMANDCHAR         '@' //Commands intended for remote begins with this
#define CTRLC               3

#define CLIENT_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_RED|BACKGROUND_BLUE
#define SERVER_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE|BACKGROUND_RED

//
//Some General purpose Macros
//
#define MINIMUM(x,y)          ((x)>(y)?(y):(x))
#define MAXIMUM(x,y)          ((x)>(y)?(x):(y))

#define HOSTNAMELEN         MAX_COMPUTERNAME_LENGTH+1

#define CHARS_PER_LINE      45

#define MAGICNUMBER     0x31109000
#define BEGINMARK       '\xfe'
#define ENDMARK         '\xff'
#define LINESTOSEND     200

#define MAX_DACL_NAMES  64

typedef struct
{
    DWORD    Size;
    DWORD    Version;
    char     ClientName[HOSTNAMELEN];
    DWORD    LinesToSend;
    DWORD    Flag;
}   SESSION_STARTUPINFO;

typedef struct
{
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
}   SESSION_STARTREPLY;



typedef struct
{
    char* out;              // message
    int  size;              // message length
    int  allocated;         // length of allocated memory
} QUERY_MESSAGE;

typedef struct
{
    char *sLine;
    BOOL bLineContinues;
    BOOL bLineTooLarge;
    DWORD cbLine;
    DWORD cbCurPos;
    COORD cLineBegin;
} CWCDATA;

VOID
QueryRemotePipes(
    char* serverName
    );

int
OverlappedServer(
    char* ChildCmd,
    char* PipeName
    );


int
Client(
    char* ServerName,
    char* PipeName
    );

VOID
ErrorExit(
    char* str
    );

VOID
DisplayClientHlp(
    );

VOID
DisplayServerHlp(
    );

VOID
Errormsg(
    char* str
    );

BOOL
IsKdString(
    char* string
    );

BOOL
pWantColorLines(
    VOID
    );

BOOL
FASTCALL
WriteFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    );

BOOL
FASTCALL
ReadFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    );

BOOL
FASTCALL
WriteConsoleWithColor(
    HANDLE MyStdOut,
    char *buffer,
    DWORD cbBuffer,
    CWCDATA *persist
    );

VOID
CloseClientPipes(
    VOID
    );

BOOL
pColorLine(
    char *sLine,
    int cbLine,
    WORD wDefaultColor,
    WORD *color );

extern char   HostName[HOSTNAMELEN];
extern char*  ChildCmd;
extern char*  PipeName;
extern char*  ServerName;
extern HANDLE MyOutHandle;
extern DWORD  LinesToSend;
extern BOOL   IsAdvertise;
extern DWORD  ClientToServerFlag;
extern char * DaclNames[];
extern DWORD  DaclNameCount;
extern char * DaclDenyNames[];
extern DWORD  DaclDenyNameCount;
extern BOOL   fAsyncPipe;
extern HANDLE hAttachedProcess;
extern HANDLE hAttachedWriteChildStdIn;
extern HANDLE hAttachedReadChildStdOut;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\remoteds.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

//
// remoteds.c, a "directory service" for the limited job of
// finding remote.exe servers on the same domain/workgroup.
//
// Dave Hart written summer 1997.
//
// Copyright 1997 Microsoft Corp.
//
//
// A handy way to use this program is under remote on a single
// or a few machines:
//
//    remote /s remoteds FindRemote
//
// Clients connect with remote /c machinename FindRemote
//
// Only remote.exe's running debuggers or with /V+ are visible
// via remoteds, as with remote /q.
//
// Remote clients notify remoteds using mailslots, see srvad.c.
//
//

#include <precomp.h>

typedef char RECEIVEBUF[1024];

typedef struct tagSERVERENTRY {
    int     nPID;                   // zero PID means unused slot
    union {
        FILETIME FileTime;
        LARGE_INTEGER liTime;
    };
    char   *pszMachine;
    char   *pszPipe;
    char   *pszChildCmd;
} SERVERENTRY;

#define TABLE_INITIAL_ALLOC 1 // 128       // beginning table size
#define TABLE_ALLOC_DELTA   1 // 16        // grows by this many units

HANDLE       hTableHeap;
SERVERENTRY *Table;
int          nTableSize;
int          nTableHiWater;          // highest used slot so far
CRITICAL_SECTION csTable;

const char szPrompt[] = "remote server search> ";

unsigned WINAPI     InteractThread(void * UnusedParm);
unsigned WINAPI     CleanupThread(void * UnusedParm);
VOID     __fastcall UpdateTimeStamp(LPFILETIME lpFileTime);
VOID     __fastcall ReallocTable(int nNewTableSize);

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    char *      pszMailslot = "\\\\.\\MAILSLOT\\REMOTE\\DEBUGGERS";
    HANDLE      hMailslot;
    BOOL        b;
    HANDLE      hThread;
    DWORD       dwTID;
    char *      pszMachine;
    int         cchMachine;
    char *      pszPID;
    int         nPID;
    char *      pszPipe;
    int         cchPipe;
    char *      pszChildCmd;
    int         i;
    int         nFirstAvailable;
    BOOL        fStopping;
    BOOL        fFound;
    int         cb;
    char *      pchStrings;
    char *      pch;
    DWORD       cbRead;
    DWORD       iBuf;
    DWORD       rgcbBuf[2];
    RECEIVEBUF  rgBuf[2];
    RECEIVEBUF  szBuf;
    char        szRemoteCmd[512];

    InitializeCriticalSection(&csTable);

    ReallocTable(TABLE_INITIAL_ALLOC);

    hMailslot =
        CreateMailslot(
            pszMailslot,
            0,
            MAILSLOT_WAIT_FOREVER,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hMailslot) {

        DWORD dwErr = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwErr) {
            printf("Cannot receive on %s,\n"
                   "is remoteds or rdsrelay already running on this machine?\n",
                   pszMailslot);
        } else {
            printf("CreateMailslot(%s) failed error %d\n",
                    pszMailslot,
                    dwErr);
        }
        return 2;
    }


    hThread = (HANDLE) _beginthreadex(
                                      NULL,
                                      0,
                                      InteractThread,
                                      NULL,
                                      0,
                                      &dwTID
                                     );

    if ( ! hThread) {
        printf("Can't start InteractThread %d\n", GetLastError());
        return 3;
    }

    CloseHandle(hThread);

    hThread = (HANDLE) _beginthreadex(
                                      NULL,
                                      0,
                                      CleanupThread,
                                      NULL,
                                      0,
                                      &dwTID
                                     );


    if ( ! hThread) {
        printf("Can't start CleanupThread %d\n", GetLastError());
        return 3;
    }

    CloseHandle(hThread);


    //
    // loop reading and processing mailslot messsages
    //

    iBuf = 0;
    ZeroMemory(rgcbBuf, sizeof(rgcbBuf));
    ZeroMemory(rgBuf, sizeof(rgBuf));

    while(TRUE)
    {
        b = ReadFile(
                hMailslot,
                rgBuf[ iBuf ],
                sizeof(rgBuf[ iBuf ]) - 1,  // so I can null terminate if needed
                &rgcbBuf[ iBuf ],
                NULL
                );

        if ( ! b) {
            printf("ReadFile(hMailslot) failed error %d\n", GetLastError());
            return 4;
        }

        //
        // It's the nature of mailslots and multiple transports
        // that we'll get the identical message several times in
        // quick succession.  Don't waste time searching the table
        // for these duplicates.
        //

        if ( rgcbBuf[0] == rgcbBuf[1] &&
             ! memcmp(rgBuf[0], rgBuf[1], rgcbBuf[0])) {

            continue;               // duplicate
        }

        //
        // Make a working copy into szBuf/cbRead that we can
        // modify so the original buffer is available for
        // detecting received duplicates.
        //

        cbRead = rgcbBuf[ iBuf ];
        CopyMemory(szBuf, rgBuf[ iBuf ], cbRead);

        //
        // Toggle buffers for the next read.
        //

        iBuf = !iBuf;

        if (szBuf[ cbRead - 1 ]) {
            fputs("Received string not null terminated.\n", stdout);
            szBuf[cbRead] = 0;
        }

        pszMachine = szBuf;

        pch = strchr(szBuf, '\t');

        if (!pch) {
            fputs("Received string no 1st tab\n", stdout);
            continue;
        }
        *pch = '\0';

        pszPID = ++pch;

        pch = strchr(pch, '\t');

        if (!pch) {
            fputs("Received string no 2nd tab\n", stdout);
            continue;
        }
        *pch = '\0';

        pszPipe = ++pch;

        pch = strchr(pch, '\t');

        if (!pch) {
            fputs("Received string no 3nd tab\n", stdout);
            continue;
        }
        *pch = '\0';

        pszChildCmd = ++pch;

        //
        // If it ends with ^B it's going away.
        //

        pch = strchr(pch, '\x2');

        if (pch) {
            *pch = 0;
            fStopping = TRUE;
        } else {
            fStopping = FALSE;
        }


        nPID = strtol(pszPID, NULL, 10);
        _strlwr(pszMachine);
        _strlwr(pszPipe);

        if (fStopping) {

            //
            // display the ending remote's info
            //

            ZeroMemory(szRemoteCmd, sizeof(szRemoteCmd));
            _snprintf(szRemoteCmd, sizeof(szRemoteCmd), "remote /c %s %s", pszMachine, pszPipe);
            printf("\r%-36s %-20s   [stop]\n%s", szRemoteCmd, pszChildCmd, szPrompt);
            fflush(stdout);
        }

        EnterCriticalSection(&csTable);

        nFirstAvailable = -1;

        for (i = 0, fFound = FALSE;
             i <= nTableHiWater;
             i++) {

            if (-1 == nFirstAvailable && 0 == Table[i].nPID) {
                nFirstAvailable = i;
            }

            if (Table[i].nPID == nPID &&
                ! strcmp(Table[i].pszMachine, pszMachine) &&
                ! strcmp(Table[i].pszPipe, pszPipe)) {

                fFound = TRUE;
                break;
            }
        }


        if (fFound) {

            if (fStopping) {

                //
                // Remove it from the table
                //

                free(Table[i].pszMachine);
                ZeroMemory(&Table[i], sizeof(Table[i]));

                if (nTableHiWater == i) {
                    nTableHiWater--;
                }

            } else { // starting

                // printf("Found at slot %d\n", i);
                // timestamp is updated below
            }

        } else if ( ! fStopping) {

            //
            // we have a new entry, display it
            //

            ZeroMemory(szRemoteCmd, sizeof(szRemoteCmd));
            _snprintf(szRemoteCmd, sizeof(szRemoteCmd), "remote /c %s %s", pszMachine, pszPipe);
            printf("\r%-36s %-20s   [start]\n%s", szRemoteCmd, pszChildCmd, szPrompt);
            fflush(stdout);

            //
            // Does it fit in the table or do we need to grow it?
            //

            if (-1 == nFirstAvailable) {

                if (++nTableHiWater >= nTableSize) {
                    ReallocTable(nTableSize + TABLE_ALLOC_DELTA);
                }

                i = nTableHiWater;

            } else {

                i = nFirstAvailable;
            }


            //
            // Fill in a server entry in table, if we can
            // allocate memory for the strings.
            //

            cb = (cchMachine  = strlen(pszMachine) + 1) +
                 (cchPipe     = strlen(pszPipe) + 1) +
                 (              strlen(pszChildCmd) + 1);

            pchStrings = malloc(cb);

            if (pchStrings) {

                Table[i].nPID = nPID;
                UpdateTimeStamp(&Table[i].FileTime);

                Table[i].pszMachine = pchStrings;
                strcpy(Table[i].pszMachine, pszMachine);

                Table[i].pszPipe = Table[i].pszMachine + cchMachine;
                strcpy(Table[i].pszPipe, pszPipe);

                Table[i].pszChildCmd = Table[i].pszPipe + cchPipe;
                strcpy(Table[i].pszChildCmd, pszChildCmd);
            }

        }

        UpdateTimeStamp(&Table[i].FileTime);

        LeaveCriticalSection(&csTable);

    }   // while (TRUE)

    return 0;    // never executed
}


//
// InteractThread lets the user query the list of remote servers.
//

unsigned WINAPI InteractThread(void * UnusedParm)
{
    char szQuery[1024] = {0};
    char szLowerQuery[1024] = {0};
    char szRemoteCmd[400];
    int  i;
    BOOL fAll;

    while (TRUE) {

        fputs(szPrompt, stdout);
        fflush(stdout);
        if (!fgets(szQuery, sizeof(szQuery), stdin))
            continue;
        _strlwr( strcpy(szLowerQuery, szQuery) );

        if (!strlen(szLowerQuery) ||
            !strcmp(szLowerQuery, "?") ||
            !strcmp(szLowerQuery, "h") ||
            !strcmp(szLowerQuery, "help")) {

            fputs("Enter a string to search for, a machine or pipe name or command.\n"
                  "Enter * to list all remote servers.\n"
                  "Exit with ^B.\n", 
                  stdout);
        
            continue;
        }

        if (2 == szLowerQuery[0]) {           // ^B

            ExitProcess(0);
        }

        fAll = ! strcmp(szLowerQuery, "*");

        EnterCriticalSection(&csTable);

        for (i = 0; i <= nTableHiWater; i++) {
            if (Table[i].nPID) {
                if (fAll ||
                    strstr(Table[i].pszMachine, szLowerQuery) ||
                    strstr(Table[i].pszPipe, szLowerQuery) ||
                    strstr(Table[i].pszChildCmd, szLowerQuery)) {

                    ZeroMemory(szRemoteCmd, sizeof(szRemoteCmd));
                    _snprintf(szRemoteCmd, sizeof(szRemoteCmd), "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe);
                    printf("%-40s %s\n", szRemoteCmd, Table[i].pszChildCmd);
                }
            }
        }

        LeaveCriticalSection(&csTable);

    }

    return 0;    // never executed
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

//
// CleanupThread scavenges for old entries and frees them.
// remote /s sends a broadcast at least every 2 hours.
// We get some of them.  Age out entries after 12 hours.
//

unsigned WINAPI CleanupThread(void * UnusedParm)
{
    LARGE_INTEGER liNow;
    LARGE_INTEGER liTimeout;
    int i;
    char szRemoteCmd[400];

    liTimeout.QuadPart = (LONGLONG)10000000 * 60 * 60 * 12;  // 12 hours

    while (TRUE) {

        Sleep(15 * 60 * 1000);    // 10 minutes

        UpdateTimeStamp((LPFILETIME)&liNow);

        EnterCriticalSection(&csTable);

        for (i = nTableHiWater; i >= 0; i--) {

            if (Table[i].nPID) {

                if (liNow.QuadPart - Table[i].liTime.QuadPart > liTimeout.QuadPart) {

                    //
                    // display the ending remote's info
                    //

                    ZeroMemory(szRemoteCmd, sizeof(szRemoteCmd));
                    _snprintf(szRemoteCmd, sizeof(szRemoteCmd), "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe);
                    printf("\r%-36s %-20s   [aged out]\n%s", szRemoteCmd, Table[i].pszChildCmd, szPrompt);
                    fflush(stdout);

                    free(Table[i].pszMachine);
                    ZeroMemory(&Table[i], sizeof(Table[i]));

                    if (nTableHiWater == i) {
                        nTableHiWater--;
                    }
                }

            }

        }

        LeaveCriticalSection(&csTable);
    }

    return 0;    // never executed
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


VOID __fastcall UpdateTimeStamp(LPFILETIME lpFileTime)
{
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, lpFileTime);
}


VOID __fastcall ReallocTable(int nNewTableSize)
{
    SERVERENTRY *pTableSave = Table;

    EnterCriticalSection(&csTable);

    nTableSize = nNewTableSize;

    if ( ! hTableHeap) {

        hTableHeap = HeapCreate(
                         HEAP_NO_SERIALIZE,
                         (TABLE_INITIAL_ALLOC + 1) * sizeof(Table[0]),  // size
                         50000 * sizeof(Table[0])                       // max
                         );
        if (hTableHeap)
            Table = HeapAlloc(
                        hTableHeap,
                        HEAP_ZERO_MEMORY,
                        nTableSize * sizeof(Table[0])
                        );
        else
            Table = NULL;

        if (!Table) {
            fputs("\nremoteds: Out of memory allocating remote server table\n", stdout);
            exit(ERROR_NOT_ENOUGH_MEMORY);
        }
    
    } else {
        void *pv = HeapReAlloc(
                    hTableHeap,
                    HEAP_ZERO_MEMORY,
                    Table,
                    nTableSize * sizeof(Table[0])
                    );

        if (!pv) {
            fputs("\nremoteds: Out of memory allocating remote server table\n", stdout);
            exit(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            Table = pv;
        }
    }

    LeaveCriticalSection(&csTable);

    if (Table != pTableSave && pTableSave) {
        printf("\nremoteds:  remote server table moved in HeapRealloc from %p to %p.\n", pTableSave, Table);
        fflush(stdout);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvad.c ===
#include <precomp.h>
#include "Remote.h"
#include "Server.h"

//
// This module uses mailslots to broadcast the existence of
// this remote server to allow a form of browsing for
// remote server instances.  This is disabled in the
// customer version of remote.exe, and can be disabled
// in the internal version using the /v- switch to
// remote /s.
//
// remoteds.c implements a listener that allows searching.
//

#define  INITIAL_SLEEP_PERIOD (35 * 1000)          // 35 seconds before first
#define  INITIAL_AD_RATE      (10 * 60 * 1000)     // 10 minutes between 1 & 2,
#define  MAXIMUM_AD_RATE      (120 * 60 * 1000)    // doubling until 120 minutes max

OVERLAPPED olMailslot;
HANDLE     hAdTimer = INVALID_HANDLE_VALUE;
HANDLE     hMailslot = INVALID_HANDLE_VALUE;
DWORD      dwTimerInterval;      // milliseconds
BOOL       bSynchAdOnly;
BOOL       bSendingToMailslot;
char       szMailslotName[64];    // netbios names are short
char       szSend[1024];

#define MAX_MAILSLOT_SPEWS 2
DWORD      dwMailslotErrors;

VOID
InitAd(
   BOOL IsAdvertise
   )
{
    DWORD           cb;
    PWKSTA_INFO_101 pwki101;
    LARGE_INTEGER   DueTime;

    if (IsAdvertise) {

        // Unless Win32s or Win9x support named pipe servers...

        ASSERT(OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);

        // Problems with overlapped writes to a mailslot sometimes
        // cause remote.exe to zombie on exit on NT4, undebuggable
        // and unkillable because of an abandoned RDR1 IRP which
        // never completes.
        //
        // So on NT4 we only send messages at startup and shutdown
        // and send them synchronously using a nonoverlapped handle.
        //

        bSynchAdOnly = (OsVersionInfo.dwMajorVersion <= 4);

        //
        // Get currently active computername and browser/mailslot
        // domain/workgroup using one call to NetWkstaGetInfo.
        // This is unicode-only, we'll use wsprintf's %ls to
        // convert to 8-bit characters.
        //
        // remoteds.exe needs to be run on a workstation that is
        // part of the domain or workgroup of the same name,
        // and be in broadcast range, to receive our sends.
        //

        if (NetWkstaGetInfo(NULL, 101, (LPBYTE *) &pwki101)) {
            printf("REMOTE: unable to get computer/domain name, not advertising.\n");
            return;
        }

        wsprintf(
            szMailslotName,
            "\\\\%ls\\MAILSLOT\\REMOTE\\DEBUGGERS",
            pwki101->wki101_langroup
            );

        wsprintf(
            szSend,
            "%ls\t%d\t%s\t%s",
            pwki101->wki101_computername,
            GetCurrentProcessId(),
            PipeName,
            ChildCmd
            );

        NetApiBufferFree(pwki101);
        pwki101 = NULL;

        //
        // Broadcast mailslots are limited to 400 message bytes
        //

        szSend[399] = 0;

        if (bSynchAdOnly) {

            hMailslot =
                CreateFile(
                    szMailslotName,
                    GENERIC_WRITE,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
            if (hMailslot != INVALID_HANDLE_VALUE) {
                if ( ! WriteFile(
                           hMailslot,
                           szSend,
                           strlen(szSend) + 1,
                           &cb,
                           NULL
                           )) {
    
                    printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError());
                }
            } else {
                printf("REMOTE: Failed to create mailslot, error %d\n", GetLastError());
            }


        } else {  // we can do async mailslot I/O

            //
            // Create a waitable timer and set it to fire first in
            // INITIAL_SLEEP_PERIOD milliseconds by calling the
            // completion routine AdvertiseTimerFired.  It will
            // be given an inital period of INITIAL_AD_RATE ms.
            //

            hAdTimer =
                CreateWaitableTimer(
                    NULL,               // security
                    FALSE,              // bManualReset, we want auto-reset
                    NULL                // unnamed
                    );
            if (hAdTimer == NULL) {
                hAdTimer = INVALID_HANDLE_VALUE;
            } else {

                DueTime.QuadPart = Int32x32To64(INITIAL_SLEEP_PERIOD, -10000);
                dwTimerInterval = INITIAL_AD_RATE;

                SetWaitableTimer(
                    hAdTimer,
                    &DueTime,
                    dwTimerInterval,
                    AdvertiseTimerFired,
                    0,                     // arg to compl. rtn
                    TRUE
                    );
            }
        }
    }
}


VOID
ShutAd(
   BOOL IsAdvertise
   )
{
    DWORD cb;
    BOOL  b;

    if (IsAdvertise) {

        if (INVALID_HANDLE_VALUE != hAdTimer) {

            CancelWaitableTimer(hAdTimer);
            CloseHandle(hAdTimer);
            hAdTimer = INVALID_HANDLE_VALUE;
        }

        if (INVALID_HANDLE_VALUE != hMailslot &&
            ! bSendingToMailslot) {

            //
            // Tell any listening remoteds's we're
            // outta here.  Do this by tacking on
            // a ^B at the end of the string (as
            // in Bye).
            //

            strcat(szSend, "\x2");


            if (bSynchAdOnly) {   // overlapped handle or not?
                b = WriteFile(
                        hMailslot,
                        szSend,
                        strlen(szSend) + 1,
                        &cb,
                        NULL
                        );
            } else {
                b = WriteFileSynch(
                        hMailslot,
                        szSend,
                        strlen(szSend) + 1,
                        &cb,
                        0,
                        &olMainThread
                        );
            }

            if ( ! b ) {

                printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError());
            }

        }

        if (INVALID_HANDLE_VALUE != hMailslot) {

            printf("\rREMOTE: closing mailslot...       ");
            fflush(stdout);
            CloseHandle(hMailslot);
            hMailslot = INVALID_HANDLE_VALUE;
            printf("\r                                  \r");
            fflush(stdout);
        }
    }
}


VOID
APIENTRY
AdvertiseTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    )
{
    UNREFERENCED_PARAMETER( pArg );
    UNREFERENCED_PARAMETER( dwTimerLo );
    UNREFERENCED_PARAMETER( dwTimerHi );


    if (INVALID_HANDLE_VALUE == hMailslot) {

        hMailslot =
            CreateFile(
                szMailslotName,
                GENERIC_WRITE,
                FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    }

    if (INVALID_HANDLE_VALUE != hMailslot) {

        ZeroMemory(&olMailslot, sizeof(olMailslot));

        bSendingToMailslot = TRUE;

        if ( ! WriteFileEx(
                   hMailslot,
                   szSend,
                   strlen(szSend) + 1,
                   &olMailslot,
                   WriteMailslotCompleted
                   )) {

            bSendingToMailslot = FALSE;

            if (++dwMailslotErrors <= MAX_MAILSLOT_SPEWS) {

                DWORD dwError;
                char szErrorText[512];

                dwError = GetLastError();

                FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwError,
                    0,
                    szErrorText,
                    sizeof szErrorText,
                    NULL
                    );

                //
                // FormatMessage has put a newline at the end of szErrorText
                //

                printf(
                    "REMOTE: Advertisement failed, mailslot error %d:\n%s",
                    dwError,
                    szErrorText
                    );
            }

            //
            // Try reopening the mailslot next time, can't hurt.
            //

            CloseHandle(hMailslot);
            hMailslot = INVALID_HANDLE_VALUE;
        }
    }
}


VOID
WINAPI
WriteMailslotCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    LARGE_INTEGER DueTime;

    bSendingToMailslot = FALSE;

    if (dwError ||
        (strlen(szSend) + 1) != cbWritten) {

            if (++dwMailslotErrors <= MAX_MAILSLOT_SPEWS) {
                printf("REMOTE: write failed on mailslot, error %d cb %d (s/b %d)\n",
                    dwError, cbWritten, (strlen(szSend) + 1));
            }
        return;
    }

    //
    // If we succeeded in writing the mailslot, double the timer interval
    // up to the limit.
    //

    if (dwTimerInterval < MAXIMUM_AD_RATE) {

        dwTimerInterval = max(dwTimerInterval * 2, MAXIMUM_AD_RATE);

        DueTime.QuadPart = Int32x32To64(dwTimerInterval, -10000);

        if (INVALID_HANDLE_VALUE != hAdTimer) {

            SetWaitableTimer(
                hAdTimer,
                &DueTime,
                dwTimerInterval,
                AdvertiseTimerFired,
                0,                     // arg to compl. rtn
                TRUE
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvlist.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvList.c

Abstract:

    The server component of Remote.  This module
    implements three lists of REMOTE_CLIENT structures,
    for handshaking, connected, and closing clients.
    To simplify the interface items always progress
    through the three lists in order, with list node
    memory being freed as it is removed from the
    closing list.


Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"
#include "SrvList.h"


VOID
FASTCALL
InitializeClientLists(
    VOID
    )
{
    InitializeCriticalSection( &csHandshakingList );
    InitializeCriticalSection( &csClientList );
    InitializeCriticalSection( &csClosingClientList );

    InitializeListHead( &HandshakingListHead );
    InitializeListHead( &ClientListHead );
    InitializeListHead( &ClosingClientListHead );
}


VOID
FASTCALL
AddClientToHandshakingList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csHandshakingList );

    InsertTailList( &HandshakingListHead, &pClient->Links );

    LeaveCriticalSection( &csHandshakingList );
}


VOID
FASTCALL
MoveClientToNormalList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csHandshakingList );

    RemoveEntryList( &pClient->Links );

    LeaveCriticalSection( &csHandshakingList );


    EnterCriticalSection( &csClientList );

    InsertTailList( &ClientListHead, &pClient->Links );

    LeaveCriticalSection( &csClientList );
}


VOID
FASTCALL
MoveClientToClosingList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csClientList );

    RemoveEntryList( &pClient->Links );

    LeaveCriticalSection( &csClientList );


    EnterCriticalSection( &csClosingClientList );

    InsertTailList( &ClosingClientListHead, &pClient->Links );

    LeaveCriticalSection( &csClosingClientList );
}


PREMOTE_CLIENT
FASTCALL
RemoveFirstClientFromClosingList(
    VOID
    )
{
    PREMOTE_CLIENT pClient;

    EnterCriticalSection( &csClosingClientList );

    if (IsListEmpty(&ClosingClientListHead)) {

        pClient = NULL;

    } else {

        pClient = (PREMOTE_CLIENT) RemoveHeadList( &ClosingClientListHead );

        ZeroMemory( &pClient->Links, sizeof(&pClient->Links) );

    }

    LeaveCriticalSection( &csClosingClientList );

    return pClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvhshak.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvHShak.c

Abstract:

    The server component of Remote.  Handshake with
    client at start of session.


Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    )
{
    pClient->ServerFlags |= SFLG_HANDSHAKING;

    AddClientToHandshakingList(pClient);

    //
    // Read hostname from client
    //

    ZeroMemory(
        &pClient->ReadOverlapped,
        sizeof(pClient->ReadOverlapped)
        );

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->Name,
               HOSTNAMELEN - 1,
               &pClient->ReadOverlapped,
               ReadClientNameCompleted
               )) {

        CloseClient(pClient);
    }
}

VOID
WINAPI
ReadClientNameCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    SESSION_STARTREPLY ssr;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return;
    }

    if (dwError) {
        CloseClient(pClient);
        return;
    }

    if ((HOSTNAMELEN - 1) != cbRead) {
        printf("ReadClientNameCompleted read %d s/b %d.\n", cbRead, (HOSTNAMELEN - 1));
        CloseClient(pClient);
        return;
    }

    //
    // The client name read is 15 bytes always.  The last four
    // should match MAGICNUMBER, which conveniently has the
    // low byte zeroed to terminate the client name after 11
    // characters.
    //

    if (MAGICNUMBER != *(DWORD UNALIGNED *)&pClient->Name[11]) {

        pClient->Name[11] = 0;
        CloseClient(pClient);
        return;
    }

    //
    // Now we can tell if this is a single-pipe or two-pipe
    // client, because single-pipe clients replace the
    // first byte of the computername with the illegal
    // character '?'.
    //

    if ('?' == pClient->Name[0]) {

        pClient->PipeWriteH = pClient->PipeReadH;

        TRACE(CONNECT, ("Client %d pipe %p is single-pipe.\n", pClient->dwID, pClient->PipeWriteH));

        //
        // In order for things to work reliably for 2-pipe clients
        // when there are multiple remote servers on the same pipename,
        // we need to tear down the listening OUT pipe and recreate it so
        // that the oldest listening IN pipe will be from the same process
        // as the oldest listening OUT pipe.
        //

        if (1 == cConnectIns) {

            TRACE(CONNECT, ("Recycling OUT pipe %p as well for round-robin behavior.\n",
                            hPipeOut));

            CancelIo(hPipeOut);
            DisconnectNamedPipe(hPipeOut);
            CloseHandle(hPipeOut);
            hPipeOut = INVALID_HANDLE_VALUE;
            bOutPipeConnected = FALSE;

            CreatePipeAndIssueConnect(OUT_PIPE);
        }

    } else {

        if ( ! bOutPipeConnected ) {

            printf("Remote: %p two-pipe client connected to IN pipe but not OUT?\n", pClient);
            CloseClient(pClient);
            return;
        }

        bOutPipeConnected = FALSE;

        if (INVALID_HANDLE_VALUE != hConnectOutTimer) {
            CancelWaitableTimer(hConnectOutTimer);
        }

        pClient->PipeWriteH = hPipeOut;
        hPipeOut = INVALID_HANDLE_VALUE;

        TRACE(CONNECT, ("Client %d is dual-pipe IN %p OUT %p.\n", pClient->dwID, pClient->PipeReadH, pClient->PipeWriteH));

        CreatePipeAndIssueConnect(OUT_PIPE);
    }

    TRACE(SHAKE, ("Read client name %s\n", pClient->Name));

    //
    // Send our little pile of goodies to the client
    //

    ssr.MagicNumber = MAGICNUMBER;
    ssr.Size = sizeof(ssr);
    ssr.FileSize = dwWriteFilePointer;

    //
    // Copy ssr structure to a buffer that will be around
    // for the entire I/O.
    //

    CopyMemory(pClient->WriteBuffer, &ssr, sizeof(ssr));

    if ( ! WriteFileEx(
               pClient->PipeWriteH,
               pClient->WriteBuffer,
               sizeof(ssr),
               &pClient->WriteOverlapped,
               WriteServerReplyCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
WriteServerReplyCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return;
    }

    if (HandleSessionError(pClient, dwError)) {
        return;
    }

    TRACE(SHAKE, ("Wrote server reply\n"));

    //
    // Read the size of the SESSION_STARTUPINFO the client is
    // sending us, to deal gracefully with different versions
    // on client and server.
    //

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer,
               sizeof(DWORD),
               &pClient->ReadOverlapped,
               ReadClientStartupInfoSizeCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientStartupInfoSizeCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    DWORD dwSize;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    if (cbRead != sizeof(DWORD)) {

        CloseClient(pClient);
        return;
    }

    //
    // Sanity check the size
    //

    dwSize = *(DWORD *)pClient->ReadBuffer;

    if (dwSize > 1024) {
        CloseClient(pClient);
        return;
    }

    //
    // Squirrel away the size in the write buffer,
    // since during handshaking we never have both a
    // read and write pending this is OK.
    //

    *(DWORD *)pClient->WriteBuffer = dwSize;

    TRACE(SHAKE, ("Read client reply size %d\n", dwSize));

    //
    // Read the rest of the SESSION_STARTUPINFO into the read buffer
    // after the size.
    //

    RtlZeroMemory(
        &pClient->ReadOverlapped,
        sizeof(pClient->ReadOverlapped)
        );

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer + sizeof(DWORD),
               dwSize - sizeof(DWORD),
               &pClient->ReadOverlapped,
               ReadClientStartupInfoCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientStartupInfoCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    DWORD dwSize;
    SESSION_STARTUPINFO ssi;
    char  Buf[256];

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    dwSize = *(DWORD *)pClient->WriteBuffer;

    if (cbRead != (dwSize - sizeof(ssi.Size))) {

        CloseClient(pClient);
        return;
    }

    CopyMemory(&ssi, pClient->ReadBuffer, min(dwSize, sizeof(ssi)));

    CopyMemory(pClient->Name, ssi.ClientName, sizeof(pClient->Name));
    pClient->Flag = ssi.Flag;

    if (ssi.Version != VERSION) {

        printf("Remote Warning: Server Version=%d Client Version=%d for %s\n", VERSION, ssi.Version, pClient->Name);
    }

    TRACE(SHAKE, ("Read client info, new name %s, %d lines\n", pClient->Name, ssi.LinesToSend));


    //
    // Set temp file position according to the client's
    // requested lines to send.  The heuristic of 45 chars
    // per average line is used by the client.  However since old clients
    // hardcode this knowledge and sit and spin trying to read that many
    // bytes before completing initialization, and because we might not send
    // that many due to stripping BEGINMARK and ENDMARK characters, we
    // use 50 chars per line to calculate the temp file position in hopes
    // the extra bytes will overcome the missing MARK characters.
    //

    pClient->dwFilePos = dwWriteFilePointer > (ssi.LinesToSend * 50)
                             ? dwWriteFilePointer - (ssi.LinesToSend * 50)
                             : 0;

    //
    // This client's ready to roll.
    //

    pClient->ServerFlags &= ~SFLG_HANDSHAKING;

    MoveClientToNormalList(pClient);

    //
    // Start read operation against this client's input.
    //

    StartReadClientInput(pClient);

    //
    // Announce the connection.
    //

    sprintf(Buf,
            "\n**Remote: Connected to %s %s%s [%s]\n",
            pClient->Name,
            pClient->UserName,
            (pClient->PipeReadH != pClient->PipeWriteH)
              ? " (two pipes)"
              : "",
            GetFormattedTime(TRUE));

    if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&dwSize,dwWriteFilePointer,&olMainThread)) {
        dwWriteFilePointer += dwSize;
        StartServerToClientFlow();
    }

    //
    // Start write cycle for client output from the temp
    // file.
    // not needed because of StartServerToClientFlow() just above
    // StartReadTempFile(pClient);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvchild.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1992 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1992 - 1997 Microsoft Corporation

Module Name:

    SrvChild.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart        30 May 1997 split from Server.c

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>

#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
StartChildOutPipeRead(
    VOID
    )
{
    ReadChildOverlapped.OffsetHigh =
        ReadChildOverlapped.Offset = 0;

    if ( ! ReadFileEx(
               hReadChildOutput,
               ReadChildBuffer,
               sizeof(ReadChildBuffer) - 1,                  // allow for null term
               &ReadChildOverlapped,
               ReadChildOutputCompleted
               )) {

        if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

            CancelIo( hWriteChildStdIn );
            CloseHandle( hWriteChildStdIn );
            hWriteChildStdIn = INVALID_HANDLE_VALUE;
        }
    }
}


VOID
WINAPI
ReadChildOutputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    UNREFERENCED_PARAMETER(lpO);

    //
    // We can get called after hWriteTempFile
    // is closed after the child has exited.
    //

    if (! dwError &&
        INVALID_HANDLE_VALUE != hWriteTempFile) {

        //
        // Start a write to the temp file.
        //

        ReadChildOverlapped.OffsetHigh = 0;
        ReadChildOverlapped.Offset = dwWriteFilePointer;

        if ( ! WriteFileEx(
                   hWriteTempFile,
                   ReadChildBuffer,
                   cbRead,
                   &ReadChildOverlapped,
                   WriteTempFileCompleted
                   )) {

            dwError = GetLastError();

            if (ERROR_DISK_FULL == dwError) {

                printf("Remote: disk full writing temp file %s, exiting\n", SaveFileName);

                if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                    CancelIo( hWriteChildStdIn );
                    CloseHandle( hWriteChildStdIn );
                    hWriteChildStdIn = INVALID_HANDLE_VALUE;
                }
            } else {
                ErrorExit("WriteFileEx for temp file failed.");
            }
        }
    }
}


VOID
WINAPI
WriteTempFileCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    UNREFERENCED_PARAMETER(lpO);

    if (dwError) {

        if (ERROR_DISK_FULL == dwError) {

            printf("Remote: disk full writing temp file %s, exiting\n", SaveFileName);

            if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                CancelIo( hWriteChildStdIn );
                CloseHandle( hWriteChildStdIn );
                hWriteChildStdIn = INVALID_HANDLE_VALUE;
            }

            return;
        } else {

            SetLastError(dwError);
            ErrorExit("WriteTempFileCompleted may need work");
        }
    }

    dwWriteFilePointer += cbWritten;

    TRACE(CHILD, ("Wrote %d bytes to temp file\n", cbWritten));

    StartServerToClientFlow();

    //
    // Start another read against the child input.
    //

    StartChildOutPipeRead();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvlist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvList.h

Abstract:

    List package for SrvList.c

Environment:

    Console App. User mode.

Revision History:

--*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvctos.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvCtoS.c

Abstract:

    This file implements the client-to-server flow
    of data for remote server.  The data is the keyboard
    or piped input that the client received and sent
    over the wire to us, bracketed by BEGINMARK and ENDMARK
    bytes so we can display nice attribution comments in
    brackets next to input lines.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"



VOID
FASTCALL
StartReadClientInput(
    PREMOTE_CLIENT pClient
    )
{
    //
    // Start read of data from this client's stdin.
    //

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer,
               BUFFSIZE - 1,                  // allow for null term
               &pClient->ReadOverlapped,
               ReadClientInputCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientInputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError) ||
        !cbRead) {

        return;
    }

    pClient->ReadBuffer[cbRead] = 0;

    if (FilterCommand(pClient, pClient->ReadBuffer, cbRead)) {

        //
        // Local command, don't pass it to child app, just
        // start another client read.
        //

        if ( ! ReadFileEx(
                   pClient->PipeReadH,
                   pClient->ReadBuffer,
                   BUFFSIZE - 1,                  // allow for null term
                   &pClient->ReadOverlapped,
                   ReadClientInputCompleted
                   )) {

            CloseClient(pClient);
        }

    } else {

        //
        // Write buffer to child stdin.
        //

        if ( ! WriteFileEx(
                   hWriteChildStdIn,
                   pClient->ReadBuffer,
                   cbRead,
                   &pClient->ReadOverlapped,
                   WriteChildStdInCompleted
                   )) {

            // Child is going away.  Let this client's chain of IO stop.
        }
    }
}


VOID
WINAPI
WriteChildStdInCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    //
    // Start another read against the client input.
    //

    StartReadClientInput(pClient);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvmain.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvMain.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

    This version uses overlapped I/O to do in one thread what
    the original uses 9 for.  Almost.  Because there is no way to
    get overlapped stdin/stdout handles, two threads sit around
    doing blocking I/O on stdin and stdout.  3 is better than 9.

    Unfortunately there's no CreatePipe()
    or equivalent option to open an overlapped handle to an anonymous
    pipe, so I stole the source for NT CreatePipe and hacked it to
    accept flags indicating overlapped for one or both ends of the
    anonymous pipe.  In our usage the child end handles are not
    overlapped but the server end handles are.


Author:

    Dave Hart  30 May 1997 after Server.c by
    Rajivendra Nath  2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#if DBG
    #undef NDEBUG           // so asserts work on chk builds
#endif
#include "Remote.h"
#define SERVER_H_NOEXTERN
#include "Server.h"


DWORD cbRemoteClient = sizeof(REMOTE_CLIENT);  // for debugging



/*************************************************************/
int
OverlappedServer(                    //Main routine for server.
    char* pszChildCmd,
    char* pszPipeNameArg
    )
{
    int    i;
    BOOL   b;
    DWORD  cWait;
    DWORD  dwWait;
    PREMOTE_CLIENT pClientRemove;

#if DBG
    // Trace = -1;   // all TR_ bits on (and then some)
#endif

    //
    // Initialize globals
    //

    pszPipeName = pszPipeNameArg;

    dwNextClientID = 1;           // local client will be 1
    cConnectIns = CONNECT_COUNT;
    cWait = MAX_WAIT_HANDLES;

    hHeap = HeapCreate(
                0,
                3 * sizeof(REMOTE_CLIENT),    // initial size
                3000 * sizeof(REMOTE_CLIENT)  // max
                );

    OsVersionInfo.dwOSVersionInfoSize = sizeof OsVersionInfo;
    b = GetVersionEx(&OsVersionInfo);
    ASSERT( b );

    puts("**************************************\n"
         "***********     REMOTE    ************\n"
         "***********     SERVER    ************\n"
         "**************************************");
    fflush(stdout);

    //
    // Setup the ACLs we need, taking into account any /u switches
    //

    SetupSecurityDescriptors();

    printf("To Connect: Remote /C %s \"%s\"\n\n", HostName, pszPipeName);
    fflush(stdout);

    //
    // Setup our three lists of clients:  handshaking,
    // connected, and closing/closed.
    //

    InitializeClientLists();


    //
    // set _REMOTE environment variable to the pipe name (why?)
    //

    SetEnvironmentVariable("_REMOTE", pszPipeName);


    //
    // Create a tempfile for storing Child process output.
    //

    {
        char szTempDirectory[MAX_PATH + 1];

        GetTempPath(sizeof(szTempDirectory), szTempDirectory);

        //
        // Before we litter the temp directory with more REMnnn.TMP
        // files, let's delete all the orphaned ones we can.  This
        // will fail for temp files open by other remote servers.
        //

        CleanupTempFiles(szTempDirectory);

        GetTempFileName(szTempDirectory, "REM", 0, SaveFileName);
    }

    if ( ! (hWriteTempFile =
            CreateFile(
                SaveFileName,                       /* name of the file  */
                GENERIC_READ | GENERIC_WRITE,       /* access (read/write) mode */
                FILE_SHARE_READ | FILE_SHARE_WRITE, /* share mode   */
                NULL,                               /* security descriptor  */
                CREATE_ALWAYS,                      /* how to create    */
                FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
                NULL
                ))) {

        ErrorExit("Could not Create Temp File");
    }


    //
    // We don't want to have multiple IN pipes created and
    // awaiting connection simultaneously if there are
    // multiple remote server processes sharing different
    // sessions under the same pipe name.  This would be
    // hairy for several reasons including breaking the
    // current round-robin behavior of connections, since
    // the oldest server pipe is connected first.  So
    // we create/open a named event based on the pipe name and
    // set the event so that any other remote servers on the
    // same pipe will fall back to a single IN pipe listening.
    //

    {
        char szPerPipeEventName[1024];

        sprintf(
            szPerPipeEventName,
            "MSRemoteSrv%s",
            pszPipeName
            );

        rghWait[WAITIDX_PER_PIPE_EVENT] =
            CreateEvent(
                    &saLocalNamedObjects,
                    TRUE,       // manual reset (synchronization)
                    FALSE,      // initially nonsignaled
                    szPerPipeEventName
                    );

        if (! rghWait[WAITIDX_PER_PIPE_EVENT]) {

            ErrorExit("Unable to create per-pipe event.");
        }

        if (ERROR_ALREADY_EXISTS == GetLastError()) {

            TRACE(CONNECT, ("Found previous server on '%s', using 1 listening pipe.\n", pszPipeName));

            SetEvent(rghWait[WAITIDX_PER_PIPE_EVENT]);

            for (i = 1; i < (int) cConnectIns; i++) {

                rghPipeIn[i] = INVALID_HANDLE_VALUE;
            }

            cWait = MAX_WAIT_HANDLES - cConnectIns + 1;
            cConnectIns = 1;

            //
            // We don't want to wait on the event handle, but it's easier
            // to have a handle in its slot, so dupe a handle to our own
            // process.  Note we toss the value of the created event handle
            // without closing it -- we want it to stay around but we're
            // done with it.
            //

            DuplicateHandle(
                GetCurrentProcess(),
                GetCurrentProcess(),
                GetCurrentProcess(),
                &rghWait[WAITIDX_PER_PIPE_EVENT],
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                );

        }
    }


    //
    // Create the event for the OVERLAPPED structure
    // used by the main server thread for WriteFileSynch calls.
    //

    olMainThread.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );


    //
    // Create the events for the OVERLAPPED structures
    // used for ConnectNamedPipe operations.
    //

    olConnectOut.hEvent =
        rghWait[WAITIDX_CONNECT_OUT] =
            CreateEvent(
                NULL,    // security
                TRUE,    // manual reset as ConnectNamedPipe demands
                FALSE,   // initially nonsignaled
                NULL
                );

    for (i = 0;
         i < (int) cConnectIns;
         i++) {

        rgolConnectIn[i].hEvent =
            rghWait[WAITIDX_CONNECT_IN_BASE + i] =
                CreateEvent(
                    NULL,    // security
                    TRUE,    // manual reset as ConnectNamedPipe demands
                    FALSE,   // initially nonsignaled
                    NULL
                    );

    }


    //
    // Create a timer we'll use to detect 2-pipe clients connected to
    // OUT without ever connecting to IN so we can recycle our single
    // OUT instance and allow other two-pipe clients in again.
    // NT 3.51 doesn't have waitable timers, so we don't do that
    // error handling on that OS.  Same as old remote.exe.
    //

    hConnectOutTimer =
        CreateWaitableTimer(
                NULL,               // security
                FALSE,              // bManualReset, we want auto-reset
                NULL                // unnamed
                );
    if (hConnectOutTimer == NULL) {
        hConnectOutTimer = INVALID_HANDLE_VALUE;
    }

    //
    // Start the command as a child process
    //

    if (hAttachedProcess != INVALID_HANDLE_VALUE) {

        ChldProc = hAttachedProcess;
        hWriteChildStdIn = hAttachedWriteChildStdIn;
        hReadChildOutput = hAttachedReadChildStdOut;

    } else {

        ChldProc =
             ForkChildProcess(
                 ChildCmd,
                 &hWriteChildStdIn,
                 &hReadChildOutput
                 );
    }

    rghWait[WAITIDX_CHILD_PROCESS] = ChldProc;

    //
    // Set ^c/^break handler.  It will kill the child process on
    // ^break and pass ^c through to it.
    //

    SetConsoleCtrlHandler(SrvCtrlHand, TRUE);


    //
    // Setup local session and start first read against its input.
    // This starts a chain of completion routines that continues
    // until this server exits.
    //

    StartLocalSession();


    //
    // Start a read operation on the child output pipe.
    // This starts a chain of completion routines that continues
    // until the child terminates.
    //

    StartChildOutPipeRead();


    //
    // Start several async ConnectNamedPipe operations, to reduce the chance
    // of a client getting pipe busy errors.  Since there is no
    // completion port version of ConnectNamedPipe, we'll wait on the
    // events in the main loop below that indicate completion.
    //

    CreatePipeAndIssueConnect(OUT_PIPE);

    for (i = 0;
         i < (int) cConnectIns;
         i++) {

        CreatePipeAndIssueConnect(i);
    }


    InitAd(IsAdvertise);


    //
    // We may need to service the query pipe for remote /q clients.
    //

    InitializeQueryServer();


    //
    // main loop of thread, waits for ConnectNamedPipe completions
    // and handles them while remaining alertable for completion
    // routines to get called.
    //

    while (1) {

        dwWait =
            WaitForMultipleObjectsEx(
                cWait,
                rghWait,
                FALSE,          // wait on any handle, not all
                30 * 1000,      // ms
                TRUE            // alertable (completion routines)
                );


        if (WAIT_IO_COMPLETION == dwWait) {

            //
            // A completion routine was called.
            //

            continue;
        }


        if (WAIT_TIMEOUT == dwWait) {

            //
            // Presumably since we've timed out for 30 seconds
            // with no IO completion, closing clients have
            // finished any pending IOs and the memory can be
            // released.
            //

            while (pClientRemove = RemoveFirstClientFromClosingList()) {

                HeapFree(hHeap, 0, pClientRemove);
            }

            continue;
        }


        if (WAITIDX_CONNECT_OUT == dwWait) {

            HandleOutPipeConnected();
            continue;
        }


        if (WAITIDX_CONNECT_IN_BASE <= dwWait &&
            (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT) > dwWait) {

            HandleInPipeConnected( dwWait - WAITIDX_CONNECT_IN_BASE );
            continue;
        }


        if (WAITIDX_QUERYSRV_WAIT == dwWait ||
            WAITIDX_QUERYSRV_WAIT + WAIT_ABANDONED_0 == dwWait ) {

            //
            // The remote server which was handling the query pipe
            // has gone away.  We'll try to take over.
            //

            QueryWaitCompleted();

            continue;
        }


        if (WAITIDX_PER_PIPE_EVENT == dwWait) {

            //
            // Another server is starting on this same
            // pipename.  To be most compatible we need
            // to fall back to listening on only one
            // IN pipe instance.
            //

            if (1 != cConnectIns) {

                TRACE(CONNECT,
                      ("Another server starting on '%s', falling back to 1 IN listening pipe.\n",
                       pszPipeName
                       ));

                for (i = 1; i < (int) cConnectIns; i++) {

                    CancelIo( rghPipeIn[i] );
                    DisconnectNamedPipe( rghPipeIn[i] );
                    CloseHandle( rghPipeIn[i] );
                    rghPipeIn[i] = INVALID_HANDLE_VALUE;

                }

                cWait = MAX_WAIT_HANDLES - cConnectIns + 1;

                cConnectIns = 1;

                //
                // We don't want to wait on the event handle, but it's easier
                // to have a handle in its slot, so dupe a handle to our own
                // process.  We toss the event handle without closing it so
                // it will stay around for future remote servers on the same
                // pipe name.
                //

                DuplicateHandle(
                    GetCurrentProcess(),
                    GetCurrentProcess(),
                    GetCurrentProcess(),
                    &rghWait[WAITIDX_PER_PIPE_EVENT],
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    );
            }

            continue;
        }

        if (WAITIDX_CHILD_PROCESS == dwWait ||
            WAITIDX_READ_STDIN_DONE == dwWait) {

            if (INVALID_HANDLE_VALUE != hConnectOutTimer) {

                CloseHandle(hConnectOutTimer);
                hConnectOutTimer = INVALID_HANDLE_VALUE;
            }

            //
            // Cancel ConnectNamedPipe operations and close
            // the pipes
            //

            if (INVALID_HANDLE_VALUE != hPipeOut) {

                DisconnectNamedPipe( hPipeOut );
                CancelIo( hPipeOut );
                CloseHandle( rghWait[WAITIDX_CONNECT_OUT] );
                rghWait[WAITIDX_CONNECT_OUT] = INVALID_HANDLE_VALUE;
            }

            for (i = 0;
                 i < (int) cConnectIns;
                 i++) {

                if (INVALID_HANDLE_VALUE != rghPipeIn[i]) {

                    TRACE(CONNECT, ("Tearing down listening IN pipe #%d.\n", i + 1));

                    DisconnectNamedPipe( rghPipeIn[i] );
                    CancelIo( rghPipeIn[i] );
                    CloseHandle( rghPipeIn[i] );
                    rghPipeIn[i] = INVALID_HANDLE_VALUE;
                }

            }

            //
            // Cancel read against child process in/out pipes
            //

            if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                CancelIo( hWriteChildStdIn );
                CloseHandle( hWriteChildStdIn );
                hWriteChildStdIn = INVALID_HANDLE_VALUE;
            }

            if (INVALID_HANDLE_VALUE != hReadChildOutput) {

                CancelIo( hReadChildOutput );
                CloseHandle( hReadChildOutput );
                hReadChildOutput = INVALID_HANDLE_VALUE;
            }

            //
            // Cancel client I/Os
            //

            bShuttingDownServer = TRUE;

            //
            // Note that CloseClient will remove entries from this list,
            // so we walk it starting at the head at each step.
            //

            for (pClientRemove = (PREMOTE_CLIENT) ClientListHead.Flink;
                 pClientRemove != (PREMOTE_CLIENT) &ClientListHead;
                 pClientRemove = (PREMOTE_CLIENT)  ClientListHead.Flink ) {

                CloseClient(pClientRemove);
            }

            //
            // on our way out...
            //

            break;
        }

        //
        // Unexpected WaitForMulipleObjectsEx return
        //

        printf("Remote: unknown wait return %d\n", dwWait);
        ErrorExit("fix srvmain.c");

    } // endless loop


    ShutAd(IsAdvertise);

    while (i = 0, GetExitCodeProcess(ChldProc, &i) &&
           STILL_ACTIVE == i) {

        printf("\nRemote: Waiting for child to exit.\n");
        WaitForSingleObjectEx(ChldProc, 10 * 1000, TRUE);
    }

    //
    // For some interesting reason when we're attached to
    // a debugger like ntsd and it exits, our printf
    // below comes out *after* the cmd.exe prompt, making
    // it look like we hung on exit even though cmd.exe is
    // patiently awaiting a command.  So suppress it.
    //

    if (hAttachedProcess == INVALID_HANDLE_VALUE) {
        printf("\nRemote exiting. Child (%s) exit code was %d.\n", ChildCmd, i);
    }

    CancelIo(hWriteTempFile);
    CloseHandle(hWriteTempFile);
    hWriteTempFile = INVALID_HANDLE_VALUE;

    //
    // Flush any pending completion routines.
    //

    while (WAIT_IO_COMPLETION == SleepEx(50, TRUE)) {
        ;
    }

    if (!DeleteFile(SaveFileName)) {

        printf("Remote: Temp File %s not deleted..\n",SaveFileName);
    }

    return i;
}



VOID
FASTCALL
StartLocalSession(
    VOID
    )
{
    DWORD dwThreadId;
    char szHexAsciiId[9];

    pLocalClient = HeapAlloc(
                       hHeap,
                       HEAP_ZERO_MEMORY,
                       sizeof(*pLocalClient)
                       );

    if (!pLocalClient) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ErrorExit("Unable to allocate local client.");
    }

    pLocalClient->dwID = dwNextClientID++;
    sprintf(szHexAsciiId, "%08x", pLocalClient->dwID);
    CopyMemory(pLocalClient->HexAsciiId, szHexAsciiId, sizeof(pLocalClient->HexAsciiId));

    strcpy(pLocalClient->Name, "Local");
    pLocalClient->ServerFlags = SFLG_LOCAL;


    //
    // we need overlapped handles to stdin/stdout,
    // and woefully DuplicateHandle can't do it.
    // So we'll create two anonymous pipes and two
    // threads to shuffle data between stdin/stdout
    // and the pipes.  The server end of the pipes
    // is opened overlapped, the "client" end (used
    // by the threads) is not overlapped.
    //


    rgCopyPipe[0].hRead = GetStdHandle(STD_INPUT_HANDLE);
    if ( ! MyCreatePipeEx(&pLocalClient->PipeReadH, &rgCopyPipe[0].hWrite, NULL, 0, FILE_FLAG_OVERLAPPED, 0)) {
        ErrorExit("Cannot create local input pipe");
    }

    rgCopyPipe[1].hWrite = GetStdHandle(STD_OUTPUT_HANDLE);
    if ( ! MyCreatePipeEx(&rgCopyPipe[1].hRead, &pLocalClient->PipeWriteH, NULL, 0, 0, FILE_FLAG_OVERLAPPED)) {
        ErrorExit("Cannot create local output pipe");
    }

    rghWait[WAITIDX_READ_STDIN_DONE] = (HANDLE)
        _beginthreadex(
            NULL,                    // security
            0,                       // default stack size
            CopyPipeToPipe,          // proc
            (LPVOID) &rgCopyPipe[0], // parm
            0,                       // flags
            &dwThreadId
            );

    CloseHandle( (HANDLE)
        _beginthreadex(
            NULL,                    // security
            0,                       // default stack size
            CopyPipeToPipe,          // proc
            (LPVOID) &rgCopyPipe[1], // parm
            0,                       // flags
            &dwThreadId
            )
        );


    StartSession( pLocalClient );
}


//
// Two of these threads to deal with non-overlapped stdin/stdout.
// CRT is OK.
//

DWORD
WINAPI
CopyPipeToPipe(
    LPVOID   lpCopyPipeData
    )
{
    PCOPYPIPE psd = (PCOPYPIPE) lpCopyPipeData;
    DWORD cb;
    char achBuffer[BUFFSIZE];

    while (1) {
        if ( ! ReadFile(
                   psd->hRead,
                   achBuffer,
                   sizeof(achBuffer),
                   &cb,
                   NULL
                   )) {

            TRACE(COPYPIPE, ("CopyPipeToPipe ReadFile %s failed, exiting thread.\n",
                             (psd == &rgCopyPipe[0])
                                 ? "stdin"
                                 : "local client output pipe"));
            break;
        }

        if ( ! WriteFile(
                   psd->hWrite,
                   achBuffer,
                   cb,
                   &cb,
                   NULL
                   )) {

            TRACE(COPYPIPE, ("CopyPipeToPipe WriteFile %s failed, exiting thread.\n",
                             (psd == &rgCopyPipe[0])
                                 ? "local client input pipe"
                                 : "stdout"));
            break;
        }
    }

    return 0;
}


VOID
FASTCALL
StartSession(
    PREMOTE_CLIENT pClient
    )
{
    pClient->rSaveFile =
        CreateFile(
            SaveFileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL
            );

    if ( ! pClient->rSaveFile) {

        printf("Remote:Cannot open ReadHandle to temp file:%d\n",GetLastError());

    } else {

        pClient->UserName[0] = 0;

        GetNamedPipeHandleState(
            pClient->PipeReadH,
            NULL,
            NULL,
            NULL,
            NULL,
            pClient->UserName,
            sizeof(pClient->UserName)
            );

        //
        // For every client except the local
        // stdin/stdout client, there's a copy of remote.exe
        // running in client mode on the other side.  Do
        // handshaking with it to setup options and check
        // versions.  HandshakeWithRemoteClient will start
        // the "normal" I/O cycle once the handshake cycle is
        // done.  Note it returns as soon as the first handshake
        // I/O is submitted.
        //

        if (pClient->ServerFlags & SFLG_LOCAL) {

            AddClientToHandshakingList(pClient);
            MoveClientToNormalList(pClient);

            //
            // Start read operation against this client's input.
            //

            StartReadClientInput(pClient);

            //
            // Start write cycle for client output from the temp
            // file.
            //

            StartReadTempFile(pClient);

        } else {

            HandshakeWithRemoteClient(pClient);
        }
    }
}




VOID
FASTCALL
CreatePipeAndIssueConnect(
    int  nIndex   // IN pipe index or OUT_PIPE
    )
{
    BOOL b;
    DWORD dwError;
    char szPipeName[BUFFSIZE];


    if (OUT_PIPE == nIndex) {
        TRACE(CONNECT, ("Creating listening OUT pipe.\n"));
    } else {
        TRACE(CONNECT, ("Creating listening IN pipe #%d.\n", nIndex + 1));
    }

    if (OUT_PIPE == nIndex) {

        sprintf(szPipeName, SERVER_WRITE_PIPE, ".", pszPipeName);

        hPipeOut =
            CreateNamedPipe(
                szPipeName,
                PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPipe
                );

        if (INVALID_HANDLE_VALUE == hPipeOut) {

            ErrorExit("Unable to CreateNamedPipe OUT");
        }

        b = ConnectNamedPipe(hPipeOut, &olConnectOut);


        if ( ! b ) {

            dwError = GetLastError();

            if (ERROR_PIPE_CONNECTED == dwError) {

                b = TRUE;
            }
        }

        if ( b ) {

            TRACE(CONNECT, ("Quick connect on OUT pipe.\n"));

            HandleOutPipeConnected();

        } else {

            if (ERROR_IO_PENDING != dwError) {

                ErrorExit("ConnectNamedPipe out failed");
            }
        }

    } else {

        sprintf(szPipeName, SERVER_READ_PIPE, ".", pszPipeName);

        rghPipeIn[nIndex] =
            CreateNamedPipe(
                szPipeName,
                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPipe
                );

        if (INVALID_HANDLE_VALUE == rghPipeIn[nIndex]) {

            if (ERROR_ACCESS_DENIED == GetLastError()) {
                if (DaclNameCount) {
                    ErrorExit("Unable to CreateNamedPipe, are YOU in the list of permitted users?");
                } else {
                    ErrorExit("Unable to CreateNamedPipe, maybe old remote server on same pipe name?");
                }
            } else {
                ErrorExit("Unable to CreateNamedPipe IN");
            }
        }

        b = ConnectNamedPipe(rghPipeIn[nIndex], &rgolConnectIn[nIndex]);

        if ( ! b ) {

            dwError = GetLastError();

            if (ERROR_PIPE_CONNECTED == dwError) {
                b = TRUE;
            }
        }

        if ( b ) {

            TRACE(CONNECT, ("Quick connect on IN pipe #%d.\n", nIndex));

            HandleInPipeConnected(nIndex);

        } else {

            if (ERROR_IO_PENDING != dwError) {

                ErrorExit("ConnectNamedPipe in failed");
            }
        }

    }

    if (OUT_PIPE == nIndex) {
        TRACE(CONNECT, ("Listening OUT pipe handle %p.\n", hPipeOut));
    } else {
        TRACE(CONNECT, ("Listening IN pipe #%d handle %p.\n", nIndex + 1, rghPipeIn[nIndex]));
    }
}


VOID
FASTCALL
HandleOutPipeConnected(
    VOID
    )
{
    LARGE_INTEGER DueTime;

    ResetEvent(rghWait[WAITIDX_CONNECT_OUT]);

    bOutPipeConnected = TRUE;

    TRACE(CONNECT, ("Two-pipe caller connected to OUT pipe %p.\n",
                    hPipeOut));

    //
    // Start a 1 minute timer in case we don't get a connection
    // on an IN pipe from this client, we'll recycle the OUT
    // pipe.
    //

    if (INVALID_HANDLE_VALUE != hConnectOutTimer) {

        DueTime.QuadPart = Int32x32To64(60 * 1000, -10000);

        SetWaitableTimer(
            hConnectOutTimer,
            &DueTime,
            0,                     // not periodic, single-fire
            ConnectOutTimerFired,
            0,                     // arg to compl. rtn
            TRUE
            );
    }
}


VOID
APIENTRY
ConnectOutTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    )
{
    UNREFERENCED_PARAMETER( pArg );
    UNREFERENCED_PARAMETER( dwTimerLo );
    UNREFERENCED_PARAMETER( dwTimerHi );

    //
    // We've had a connected OUT pipe for a minute now,
    // only two-pipe clients connect to that and they
    // immediately connect to IN afterwards.  Presumably
    // the client died between these two operations.  Until
    // we recycle the OUT pipe all two-pipe clients are
    // unable to connect getting pipe busy errors.
    //

    if ( ! bOutPipeConnected ) {

        TRACE(CONNECT, ("ConnectOut timer fired but Out pipe not connected.\n"));
        return;
    }

    TRACE(CONNECT, ("Two-pipe caller hung for 1 minute, recycling OUT pipe %p.\n",
                    hPipeOut));

    bOutPipeConnected = FALSE;

    CancelIo(hPipeOut);
    DisconnectNamedPipe(hPipeOut);
    CloseHandle(hPipeOut);
    hPipeOut = INVALID_HANDLE_VALUE;

    CreatePipeAndIssueConnect(OUT_PIPE);

    //
    // In order for things to work reliably for 2-pipe clients
    // when there are multiple remote servers on the same pipename,
    // we need to tear down the listening IN pipe and recreate it so
    // that the oldest listening OUT pipe will be from the same process
    // as the oldest listening IN pipe.
    //

    if (1 == cConnectIns) {

        TRACE(CONNECT, ("Recycling IN pipe %p as well for round-robin behavior.\n",
                        rghPipeIn[0]));

        CancelIo(rghPipeIn[0]);
        DisconnectNamedPipe(rghPipeIn[0]);
        CloseHandle(rghPipeIn[0]);
        rghPipeIn[0] = INVALID_HANDLE_VALUE;

        CreatePipeAndIssueConnect(0);
    }
}


VOID
FASTCALL
HandleInPipeConnected(
    int nIndex
    )
{
    PREMOTE_CLIENT pClient;
    char szHexAsciiId[9];

    ResetEvent(rghWait[WAITIDX_CONNECT_IN_BASE + nIndex]);

    if (nIndex >= (int) cConnectIns) {

        //
        // The I/O was cancelled on the excess
        // listening pipes, causing the event to
        // fire.
        //

        ASSERT(INVALID_HANDLE_VALUE == rghPipeIn[nIndex]);

        TRACE(CONNECT, ("IN pipe #%d, handle %p listen cancelled.\n",
                        nIndex + 1, rghPipeIn[nIndex]));

        return;
    }


    TRACE(CONNECT, ("Caller connected to IN pipe #%d, handle %p.\n",
                    nIndex + 1, rghPipeIn[nIndex]));

    //
    // A client is fully connected, but we don't know if
    // it's a single-pipe or two-pipe client.  Until
    // we do its PipeWriteH will be invalid.  We'll figure
    // it out in ReadClientNameCompleted.
    //

    pClient = HeapAlloc(
                  hHeap,
                  HEAP_ZERO_MEMORY,
                  sizeof(*pClient)
                  );

    if ( ! pClient) {

        printf("Out of memory connecting client, hanging up.\n");

        CloseHandle( rghPipeIn[nIndex] );
        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE;
        CreatePipeAndIssueConnect( nIndex );


        if (bOutPipeConnected) {

             //
             // Hang up on the two-pipe caller connected to the
             // OUT pipe as well -- it may be this client or it
             // may be another, no way to tell, and really no
             // great need to because if it's another caller
             // we probably wouldn't be able to allocate memory
             // for it either.
             //
             // Also if we're using a single IN pipe for
             // multiple-server round-robin behavior we
             // want to recycle both pipes at the same time.
             //

            TRACE(CONNECT, ("Also hanging up on connected two-pipe caller on OUT pipe %p.\n",
                            hPipeOut));

            bOutPipeConnected = FALSE;

            if (INVALID_HANDLE_VALUE != hConnectOutTimer) {
                 CancelWaitableTimer(hConnectOutTimer);
            }

            DisconnectNamedPipe(hPipeOut);
            CloseHandle(hPipeOut);
            hPipeOut = INVALID_HANDLE_VALUE;

            CreatePipeAndIssueConnect( OUT_PIPE );
        }

    } else {

        //
        // Initialize the Client
        //

        pClient->dwID = dwNextClientID++;
        sprintf(szHexAsciiId, "%08x", pClient->dwID);
        CopyMemory(pClient->HexAsciiId, szHexAsciiId, sizeof(pClient->HexAsciiId));

        pClient->PipeReadH   = rghPipeIn[nIndex];
        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE;

        pClient->PipeWriteH  = INVALID_HANDLE_VALUE;

        TRACE(CONNECT, ("Handshaking new client %d (%p) on IN pipe handle %p.\n",
                        pClient->dwID, pClient, pClient->PipeReadH));

        //
        // Start another connect operation to replace this completed one.
        //

        CreatePipeAndIssueConnect( nIndex );

        //
        // Start session I/Os with the new client.  This will link it
        // into the handshaking list.
        //

        StartSession( pClient );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvquery.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvQuery.c

Abstract:

    The server component of Remote.   Respond to client
    "remote /q" requests to list available remote servers
    on this machine.


Author:

    Dave Hart  30 May 1997
        derived from code by Mihai Costea in server.c.

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
InitializeQueryServer(
    VOID
    )
{
    //
    // hQPipe is the handle to the listening query pipe,
    // if we're serving it.
    //

    hQPipe = INVALID_HANDLE_VALUE;

    QueryOverlapped.hEvent =
        CreateEvent(
            NULL,       // security
            TRUE,       // manual-reset
            FALSE,      // initially nonsignaled
            NULL        // unnamed
            );

    rghWait[WAITIDX_QUERYSRV_WAIT] =
        CreateMutex(
            &saLocalNamedObjects,
            FALSE,       // not owner in case we open not create
            "MS RemoteSrv Q Mutex"
            );
    if (NULL == rghWait[WAITIDX_QUERYSRV_WAIT]) {
        rghWait[WAITIDX_QUERYSRV_WAIT] = INVALID_HANDLE_VALUE;
    }
    
    if (INVALID_HANDLE_VALUE == rghWait[WAITIDX_QUERYSRV_WAIT]) {

        ErrorExit("Remote: Unable to create/open query server mutex.\n");
    }
}


VOID
FASTCALL
QueryWaitCompleted(
    VOID
    )
{
    HANDLE hWait;
    DWORD dwThreadId;
    BOOL b;
    DWORD dwRead;

    //
    // The remote server (not us) which was servicing the query
    // pipe has left the arena.  Or someone has connected.
    //

    hWait = rghWait[WAITIDX_QUERYSRV_WAIT];

    if (hWait == QueryOverlapped.hEvent) {

        //
        // We're the query server and someone has connected.
        // Start a thread to service them.
        //

        b = GetOverlappedResult(hQPipe, &QueryOverlapped, &dwRead, TRUE);


        if ( !b && ERROR_PIPE_CONNECTED != GetLastError()) {

            TRACE(QUERY,("Connect Query Pipe returned %d\n", GetLastError()));

            if (INVALID_HANDLE_VALUE != hQPipe) {

                CloseHandle(hQPipe);
                hQPipe = INVALID_HANDLE_VALUE;
            }

        } else {

            TRACE(QUERY, ("Client connected to query pipe.\n"));

            ResetEvent(hWait);

            CloseHandle( (HANDLE)
                _beginthreadex(
                        NULL,             // security
                        0,                // default stack size
                        QueryHandlerThread,
                        (LPVOID) hQPipe,  // parameter
                        0,                // not suspended
                        &dwThreadId
                        ));

            hQPipe = INVALID_HANDLE_VALUE;
        }

    } else {

        TRACE(QUERY, ("Remote server entered query mutex, will handle queries.\n"));

        rghWait[WAITIDX_QUERYSRV_WAIT] = QueryOverlapped.hEvent;
    }


    //
    // Either a client has connected and we've handed that pipe
    // off to a query thread to deal with, or we're just starting
    // to serve the query pipe, or we had an error from
    // ConnectNamedPipe.  In any case we want to create another
    // query pipe instance and start listening on it.
    //

    ASSERT(INVALID_HANDLE_VALUE == hQPipe);

    StartServingQueryPipe();
}



VOID
FASTCALL
StartServingQueryPipe(
    VOID
    )
{
    BOOL  b;
    DWORD dwThreadId;
    char  fullname[BUFFSIZE];

    sprintf(fullname, QUERY_DEBUGGERS_PIPE, ".");

    do {      // hand off each pipe as connected until IO_PENDING
    
        hQPipe =
            CreateNamedPipe(
                fullname,
                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE | PIPE_WAIT,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPublic
                );
        
        if (INVALID_HANDLE_VALUE == hQPipe) {

            ErrorExit("Unable to create query server pipe.");
        }

        b = ConnectNamedPipe(hQPipe, &QueryOverlapped);


        if ( ! b && ERROR_PIPE_CONNECTED == GetLastError()) {

            b = TRUE;
        }

        if (b) {

            //
            // That was fast.
            //

            TRACE(QUERY, ("Client connected quickly to query pipe.\n"));

            CloseHandle( (HANDLE)
                _beginthreadex(
                    NULL,              // security
                    0,                 // default stack size
                    QueryHandlerThread,
                    (LPVOID) hQPipe,   // parameter
                    0,                 // not suspended
                    &dwThreadId
                    ));

            hQPipe = INVALID_HANDLE_VALUE;


        } else if (ERROR_IO_PENDING == GetLastError()) {

            //
            // The main thread will call QueryWaitCompleted when
            // someone connects.
            //

            TRACE(QUERY, ("Awaiting query pipe connect\n"));

        } else {

            sprintf(fullname, "Remote: error %d connecting query pipe.\n", GetLastError());

            OutputDebugString(fullname);
            ErrorExit(fullname);
        }

    } while (b);
}


DWORD
WINAPI
QueryHandlerThread(
    LPVOID   lpvArg
    )
{
    HANDLE hQueryPipe = (HANDLE) lpvArg;
    DWORD cb;
    BOOL  b;
    OVERLAPPED ol;
    QUERY_MESSAGE QData;
    char  pIn[1];


    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,       // security
            TRUE,       // manual-reset
            FALSE,      // initially nonsignaled
            NULL        // unnamed
            );


    // get command

    b = ReadFileSynch(
            hQueryPipe,
            pIn,
            1,
            &cb,
            0,
            &ol
            );

    if ( ! b || 1 != cb ) {
        TRACE(QUERY, ("Query server unable to read byte from query pipe.\n"));
        goto failure;
    }

    TRACE(QUERY, ("Query server read command '%c'\n", pIn[0]));

        //
        // !!!!!!
        // REMOVE 'h' support, it's only here for transitional compatibility
        // with 1570+ remote /q original server implementation.
        //

        if(pIn[0] == 'h') {

            DWORD dwMinusOne = (DWORD) -1;

            b = WriteFileSynch(
                    hQueryPipe,
                    &dwMinusOne,
                    sizeof(dwMinusOne),
                    &cb,
                    0,
                    &ol
                    );

            if ( !b || sizeof(dwMinusOne) != cb )
            {
                goto failure;
            }
        }

    if(pIn[0] == 'q') {

        QData.size  = 0;
        QData.allocated = 0;
        QData.out   = NULL;
                
        EnumWindows(EnumWindowProc, (LPARAM)&QData);

        b = WriteFileSynch(
                hQueryPipe,
                &QData.size,
                sizeof(QData.size),
                &cb,
                0,
                &ol
                );

        if ( ! b || sizeof(int) != cb) {

            TRACE(QUERY, ("Remote: Can't write query length\n"));
            goto failure;
        }
        
        if (QData.size) {         // anything to say?

            b = WriteFileSynch(
                     hQueryPipe,
                     QData.out,
                     QData.size * sizeof(char),
                     &cb,
                     0,
                     &ol
                     );

            free(QData.out);

            if ( ! b || QData.size * sizeof(char) != cb) {

                TRACE(QUERY, ("Remote: Can't write query"));
                goto failure;
            }


            TRACE(QUERY, ("Sent query response\n"));
        }
    }
            
    FlushFileBuffers(hQueryPipe);

  failure:
    DisconnectNamedPipe(hQueryPipe);
    CloseHandle(hQueryPipe);
    CloseHandle(ol.hEvent);

    return 0;
}






BOOL
CALLBACK
EnumWindowProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    #define MAX_TITLELEN 200
    QUERY_MESSAGE *pQm;
    int titleLen;
    char title[MAX_TITLELEN];
    char* tmp;

    pQm = (QUERY_MESSAGE*)lParam;

    if(titleLen = GetWindowText(hWnd, title, sizeof(title)/sizeof(title[0])))
    {
        //
        // search for all windows that are visible 
        //

        if (strstr(title, "] visible") &&
            strstr(title, "[Remote "))
        {
            if(pQm->size)                           // if message not empty
                pQm->out[(pQm->size)++] = '\n';     // overwrite ending null with \n
            else
            {                                       
                pQm->out  = (char*)malloc(MAX_TITLELEN);     // first allocation
                if(!pQm->out)
                {
                    printf("\nOut of memory\n");
                    return FALSE;
                }
                pQm->allocated = MAX_TITLELEN;                               
            }

            // fill the result
            
            if((pQm->size + titleLen) >= pQm->allocated)
            {   
                tmp = (char*)realloc(pQm->out, pQm->allocated + MAX_TITLELEN);
                if(!tmp)
                {
                    printf("\nOut of memory\n");
                    free(pQm->out);
                    pQm->size = 0;                    
                    return FALSE;
                }
                pQm->out = tmp;            
                pQm->allocated += MAX_TITLELEN;
            }
            strcpy(pQm->out + pQm->size, title);
            pQm->size += titleLen;                
        }
    }
    
    return TRUE;
    #undef MAX_TITLELEN
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvstoc.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvStoC.c

Abstract:

    This file implements the server-to-client flow
    of data for remote server.  The data is the output
    of the child program intermingled with client input.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
StartServerToClientFlow(
    VOID
    )
{
    PREMOTE_CLIENT pClient;

    //
    // Start read operations against the temp file for
    // all active clients that aren't currently doing
    // read temp/write client operations and that are
    // fully connected.
    //

    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {


        if (! pClient->cbWrite) {

            StartReadTempFile( pClient );
        }
    }
}


VOID
FASTCALL
StartReadTempFile(
    PREMOTE_CLIENT pClient
    )
{
    //
    // pClient->cbWrite is used dually.  WriteSessionOutputCompleted
    // uses it when 0 bytes are written to know how much to ask
    // to write when it resubmits the request.  We use it to
    // indicate whether a read temp/write session chain of I/Os
    // is currently active for this client.
    //

    if (pClient->cbWrite) {

        ErrorExit("StartReadTempFile entered with nonzero cbWrite.");
    }

    if (dwWriteFilePointer > pClient->dwFilePos) {

        pClient->cbWrite = min(BUFFSIZE,
                               dwWriteFilePointer - pClient->dwFilePos);

        pClient->WriteOverlapped.OffsetHigh = 0;
        pClient->WriteOverlapped.Offset = pClient->dwFilePos;

        if ( ! ReadFileEx(
                   pClient->rSaveFile,
                   pClient->ReadTempBuffer,
                   pClient->cbWrite,
                   &pClient->WriteOverlapped,
                   ReadTempFileCompleted
                   )) {

            if (ERROR_HANDLE_EOF == GetLastError()) {

                pClient->cbWrite = 0;

            } else {

                TRACE(SESSION, ("ReadFileEx for temp file failed error %d, closing client.\n", GetLastError()));

                CloseClient(pClient);
            }
        }

    }
}

VOID
WINAPI
ReadTempFileCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }


    if (cbRead != pClient->cbWrite) {

        TRACE(SESSION, ("Read %d from temp file asked for %d\n", cbRead, pClient->cbWrite));
    }

    if (cbRead) {

        pClient->cbReadTempBuffer = cbRead;
        pClient->dwFilePos += cbRead;

        StartWriteSessionOutput(pClient);

    } else {

        //
        // Note that the server to client flow is halting for now
        // for this client.
        //

        pClient->cbWrite = 0;
    }
}


VOID
FASTCALL
StartWriteSessionOutput(
    PREMOTE_CLIENT pClient
    )
{
    DWORD cbRead;
    char *pch;

    cbRead = pClient->cbReadTempBuffer;

    //
    // We need to split commands from other text read
    // from the temp file and hold off on writing them
    // to the client until we make sure we're not the
    // client that submitted it.  This isn't perfect
    // since we match on client name which can be
    // duplicated but it solves the problem of
    // duplicated input most of the time.
    //

    for (pch = pClient->ReadTempBuffer;
         pch < pClient->ReadTempBuffer + cbRead;
         pch++) {

        if ( ! (pClient->ServerFlags & SFLG_READINGCOMMAND) ) {

            if (BEGINMARK == *pch) {

                pClient->ServerFlags |= SFLG_READINGCOMMAND;

                if (pch != pClient->ReadTempBuffer &&
                    pClient->cbWriteBuffer) {

                    //
                    // Start a write of everything we've come across
                    // before the start of this command, with
                    // WriteSessionOutputCompletedWriteNext specified
                    // so we can continue processing the remainder
                    // of pReadTempBuffer.
                    //

                    pClient->cbReadTempBuffer -= (DWORD)( pch - pClient->ReadTempBuffer) + 1;
                    cbRead = pClient->cbReadTempBuffer;

                    #if DBG
                        if (pClient->cbReadTempBuffer == (DWORD)-1) {
                            ErrorExit("cbReadTempBuffer underflow.");
                        }
                    #endif

                    MoveMemory(pClient->ReadTempBuffer, pch + 1, cbRead);

                    pClient->cbWrite = pClient->cbWriteBuffer;

                    pClient->WriteOverlapped.OffsetHigh = 0;
                    pClient->WriteOverlapped.Offset = 0;

                    if ( ! WriteFileEx(
                               pClient->PipeWriteH,
                               pClient->WriteBuffer,
                               pClient->cbWrite,
                               &pClient->WriteOverlapped,
                               WriteSessionOutputCompletedWriteNext
                               )) {

                        CloseClient(pClient);
                    }

                    TRACE(SESSION, ("%p Wrote %d bytes pre-command output\n", pClient, pClient->cbWrite));

                    pClient->cbWriteBuffer = 0;

                    return;
                }

            } else {

                if (pClient->cbWriteBuffer == BUFFSIZE) {

                    ErrorExit("cbWriteBuffer overflow");
                }

                pClient->WriteBuffer[ pClient->cbWriteBuffer++ ] = *pch;
            }

        } else {

            if (ENDMARK == *pch ||
                pClient->cbCommandBuffer == BUFFSIZE) {

                pClient->ServerFlags &= ~SFLG_READINGCOMMAND;

                //
                // Preceding ENDMARK is the pClient in hex ascii of the
                // client that generated the command, not null terminated.
                //

                if (ENDMARK == *pch) {

                    pClient->cbCommandBuffer -=
                        min(pClient->cbCommandBuffer, sizeof(pClient->HexAsciiId));

                }

                //
                // We hide each client's input from their output pipe
                // because their local remote.exe has already displayed it.
                //

                if ( pClient->cbCommandBuffer &&
                     ! (ENDMARK == *pch &&
                        ! memcmp(
                              pch - sizeof(pClient->HexAsciiId),
                              pClient->HexAsciiId,
                              sizeof(pClient->HexAsciiId)))) {

                    //
                    // Start a write of the accumulated command with
                    // WriteSessionOutputCompletedWriteNext specified
                    // so we can continue processing the remainder
                    // of pReadTempBuffer.
                    //

                    pClient->cbReadTempBuffer -= (DWORD)(pch - pClient->ReadTempBuffer) + 1;
                    MoveMemory(pClient->ReadTempBuffer, pch + 1, pClient->cbReadTempBuffer);

                    pClient->cbWrite = pClient->cbCommandBuffer;
                    pClient->cbCommandBuffer = 0;

                    pClient->WriteOverlapped.OffsetHigh = 0;
                    pClient->WriteOverlapped.Offset = 0;

                    if ( ! WriteFileEx(
                               pClient->PipeWriteH,
                               pClient->CommandBuffer,
                               pClient->cbWrite,
                               &pClient->WriteOverlapped,
                               WriteSessionOutputCompletedWriteNext
                               )) {

                        CloseClient(pClient);
                        return;

                    } else {

                        TRACE(SESSION, ("%p Wrote %d bytes command\n", pClient, pClient->cbWrite));

                        return;

                    }

                } else {

                    //
                    // We're eating this command for this session.
                    //

                    pClient->cbCommandBuffer = 0;
                }

            } else {

                pClient->CommandBuffer[ pClient->cbCommandBuffer++ ] = *pch;

            }
        }
    }

    //
    // We're done with the ReadTempBuffer.
    //

    pClient->cbReadTempBuffer = 0;

    if (pClient->cbWriteBuffer) {

        pClient->cbWrite = pClient->cbWriteBuffer;

        pClient->WriteOverlapped.OffsetHigh = 0;
        pClient->WriteOverlapped.Offset = 0;

        if ( ! WriteFileEx(
                   pClient->PipeWriteH,
                   pClient->WriteBuffer,
                   pClient->cbWrite,
                   &pClient->WriteOverlapped,
                   WriteSessionOutputCompletedReadNext
                   )) {

            CloseClient(pClient);
            return;

        } else {

            TRACE(SESSION, ("%p Wrote %d bytes normal\n", pClient, pClient->cbWrite));

            pClient->cbWriteBuffer = 0;
        }

    } else {

        //
        // Write buffer is empty.
        //

        pClient->cbWrite = 0;

        StartReadTempFile(pClient);

    }
}


BOOL
FASTCALL
WriteSessionOutputCompletedCommon(
    PREMOTE_CLIENT pClient,
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    if (HandleSessionError(pClient, dwError)) {

        return TRUE;
    }

    if (!pClient->cbWrite) {

        ErrorExit("Zero cbWrite in WriteSessionOutputCompletedCommon");
    }

    if (!cbWritten && pClient->cbWrite) {

        printf("WriteSessionOutput zero bytes written of %d.\n", pClient->cbWrite);
        ErrorExit("WriteSessionOutputCompletedCommon failure");

        return TRUE;
    }

    #if DBG
        if (cbWritten != pClient->cbWrite) {
            printf("%p cbWritten %d cbWrite %d\n", pClient, cbWritten, pClient->cbWrite);
        }
    #endif

    return FALSE;
}


VOID
WINAPI
WriteSessionOutputCompletedWriteNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (WriteSessionOutputCompletedCommon(
            pClient,
            dwError,
            cbWritten,
            WriteSessionOutputCompletedWriteNext
            )) {

        return;
    }

    StartWriteSessionOutput(pClient);
}


VOID
WINAPI
WriteSessionOutputCompletedReadNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (WriteSessionOutputCompletedCommon(
            pClient,
            dwError,
            cbWritten,
            WriteSessionOutputCompletedReadNext
            )) {

        return;
    }

    //
    // Start another temp file read.
    //

    pClient->cbWrite = 0;

    StartReadTempFile(pClient);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\inc\common.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    common.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define IN
#define OUT
#define INOUT

//
// An ID_WORD indicates the following WORD is an ordinal rather 
// than a string
// 

#define ID_WORD 0xffff

typedef struct _STRING {
        DWORD discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct _STRING *pnext;
                  DWORD  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  sz[1];
		} ss;
		WORD     Ordinal;
	} uu;
} STRING, *PSTRING, **PPSTRING;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz
#define pn             uu.ss.pnext

typedef struct _RESNAME {
    struct _RESNAME *pnext;    // The first three fields should be the
    PSTRING Name;              // same in both res structures
    DWORD   OffsetToData;      //

    PSTRING Type;
    struct _RESNAME *pnextRes;
    RESADDITIONAL	*pAdditional;
    DWORD   OffsetToDataEntry;
    USHORT  ResourceNumber;
    USHORT  NumberOfLanguages;
    POBJLST pObjLst;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
    struct _RESTYPE *pnext;    // The first three fields should be the
    PSTRING Type;              // same in both res structures
    DWORD   OffsetToData;      //

    struct _RESNAME *NameHeadID;
    struct _RESNAME *NameHeadName;
    DWORD  NumberOfNamesID;
    DWORD  NumberOfNamesName;
    POBJLST pObjLst;
} RESTYPE, *PRESTYPE, **PPRESTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rescan\makefile.inc ===
$(O)\rescan.res: rescan.rc

$(O)\setpriv.res: setpriv.rc

$(O)\remove.res: remove.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rescan\remove.c ===
#include <nt.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

int __cdecl
main( int argc, char **argv )
{
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    ULONG BytesTransferred;

    if( argc < 2 ) {

        printf( "usage: %s DriveLetter:\n", argv[0] );
        exit(4);
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n",
                argv[1],
                GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_CDROM_REMOVE_DEVICE,
                          NULL,
                          0,
                          NULL,
                          0,
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to remove device [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);

    } else {
        printf( "Removed %s\n", argv[1] );
        CloseHandle( VolumeHandle );
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\remote\srvutil.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvUtil.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart  30 May 1997 split from Server.c

Environment:

    Console App. User mode.

Revision History:

--*/

#include <precomp.h>
#include "Remote.h"
#include "Server.h"
#include <sddl.h>
#define DEFAULT_SECURITY_DESCRIPTOR L"D:(A;;FA;;;BA)(A;;FA;;;CO)(A;;0x1301bf;;;WD)"
#define REGISTRY_PATH L"Software\\Microsoft\\Remote"
#define REGISTRY_VALUE L"DefaultSecurity"

#define COMMANDFORMAT     "%c%-20s    [%-12s %s]\n%08x%c"
#define CMDSTRING(OutBuff,OutSize,InpBuff,Client,szTime,ForceShow) \
{                                                                  \
    char *pch;                                                     \
                                                                   \
    for (pch = InpBuff;                                            \
         *pch;                                                     \
         pch++) {                                                  \
                                                                   \
        if (ENDMARK == *pch ||                                     \
            BEGINMARK == *pch) {                                   \
                                                                   \
            *pch = '`';                                            \
        }                                                          \
    }                                                              \
                                                                   \
    OutSize =                                                      \
        sprintf(                                                   \
            (OutBuff),                                             \
            COMMANDFORMAT,                                         \
            BEGINMARK,                                             \
            (InpBuff),                                             \
            (Client)->Name,                                        \
            (szTime),                                              \
            (ForceShow) ? 0 : (Client)->dwID,                      \
            ENDMARK                                                \
            );                                                     \
}


/*************************************************************/
// GetFormattedTime -- returns pointer to formatted time
//
// returns pointer to static buffer, only the main thread
// should use this.
//

PCHAR
GetFormattedTime(
    BOOL bDateToo
    )
{
    static char szTime[64];
    int cch = 0;

    if (bDateToo) {

        cch =
            GetDateFormat(
                LOCALE_USER_DEFAULT,
                0,
                NULL,    // current date
                "ddd",   // short day of week
                szTime,
                sizeof szTime
                );

        // cch includes null terminator, change it to
        // a space to separate from time.

        szTime[ cch - 1 ] = ' ';
    }

    //
    // Get time and format to characters
    //

    GetTimeFormat(
        LOCALE_USER_DEFAULT,
        TIME_NOSECONDS,
        NULL,   // use current time
        NULL,   // use default format
        szTime + cch,
        (sizeof szTime) - cch );

    return szTime;
}

/*************************************************************/

BOOL
FilterCommand(
    REMOTE_CLIENT *cl,
    char *buff,
    int dread
    )
{
    char       tmpchar;
    DWORD      tmp;
    int        len, i;
    DWORD      ThreadID;
    char       inp_buff[2048];
    char       ch[3];

    if (dread==0)
        return(FALSE);

    buff[dread]=0;

    if (buff[0]==COMMANDCHAR)
    {

        switch(buff[1]) {
            case 'k':
            case 'K':

                if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                    printf("Remote: killing child softly, @K again to be more convincing.\n");

                    CancelIo( hWriteChildStdIn );
                    CloseHandle( hWriteChildStdIn );
                    hWriteChildStdIn = INVALID_HANDLE_VALUE;

                    GenerateConsoleCtrlEvent(CTRL_CLOSE_EVENT, 0);
                    SleepEx(200, TRUE);
                    cPendingCtrlCEvents++;
                    GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
                    SleepEx(20, TRUE);
                    GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 0);

                } else {

                    printf("Remote: Resorting to TerminateProcess.\n");

                    TerminateProcess(ChldProc, ERROR_PROCESS_ABORTED);
                }


                 break;
            case 's':
            case 'S':
                CloseHandle( (HANDLE)
                    _beginthreadex(
                        NULL,             // security
                        0,                // default stack size
                        SendStatus,
                        (void *) cl->PipeWriteH,
                        0,                // not suspended
                        &ThreadID
                        ));
                break;

            case 'p':
            case 'P':
            {
                char  *msg;

                msg = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 4096 );
                if ( ! msg) {
                    break;
                }

                sprintf(msg,"From %s %s [%s]\n\n%s\n",cl->Name,cl->UserName,GetFormattedTime(TRUE),&buff[2]);

                if (WriteFileSynch(hWriteTempFile,msg,strlen(msg),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }

                CloseHandle( (HANDLE)
                    CreateThread(                              // no CRT for ShowPopup
                        NULL,             // security
                        0,                // default stack size
                        ShowPopup,
                        (void *) msg,
                        0,                // not suspended
                        &ThreadID
                        ));

                break;
             }

            case 'm':
            case 'M':
                buff[dread-2]=0;
                CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(TRUE),TRUE);

                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }
                break;

            case '@':
                buff[dread-2]=0;
                CMDSTRING(inp_buff,len,&buff[1],cl,GetFormattedTime(FALSE),FALSE);
                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process


            default :
                ZeroMemory(inp_buff, sizeof(inp_buff));
                strncpy(inp_buff, "** Unknown Command **\n", sizeof(inp_buff)-1);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    // we do this below // StartServerToClientFlow();
                }
            case 'h':
            case 'H':
                _snprintf(inp_buff,sizeof(inp_buff), "%cM: To Send Message\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                _snprintf(inp_buff,sizeof(inp_buff), "%cP: To Generate popup\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                _snprintf(inp_buff,sizeof(inp_buff), "%cK: To kill the server\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                _snprintf(inp_buff,sizeof(inp_buff), "%cQ: To Quit client\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                _snprintf(inp_buff,sizeof(inp_buff), "%cH: This Help\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                StartServerToClientFlow();
                break;
        }
        return(TRUE);
    }


    if ((buff[0]<26)) {
        BOOL ret=FALSE;

        _snprintf(ch, sizeof(ch), "^%c", buff[0] + 'A' - 1);

        if (buff[0]==CTRLC) {
            // show this even to this client
            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),TRUE);

            cPendingCtrlCEvents++;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
            ret = TRUE;  // Already sent to child
        } else {
            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),FALSE);
        }

        if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
            dwWriteFilePointer += tmp;
            StartServerToClientFlow();
        }
        return(ret); //FALSE:send it to child StdIn
    }

    // options here are CRLF(\r\n) or just LF(\n)
    if (buff[dread-2] == 13) { 
        i = 2;      // 13 is CR
    } else {
        i = 1;
    }

    tmpchar=buff[dread-i]; 
    buff[dread-i]=0;
    CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(FALSE),FALSE);
    buff[dread-i]=tmpchar;
    if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
        dwWriteFilePointer += tmp;
        StartServerToClientFlow();
    }
    return(FALSE);
}

/*************************************************************/
HANDLE
ForkChildProcess(           // Creates a new process
    char *cmd,              // Redirects its stdin,stdout
    PHANDLE inH,            // and stderr - returns the
    PHANDLE outH            // corresponding pipe ends.
    )
{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    HANDLE ChildIn;
    HANDLE ChildOut, ChildOutDup;
    HANDLE hWriteChild;
    HANDLE hReadChild;
    BOOL Success;

    BOOL                                     // pipeex.c
    APIENTRY
    MyCreatePipeEx(
        OUT LPHANDLE lpReadPipe,
        OUT LPHANDLE lpWritePipe,
        IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
        IN DWORD nSize,
        DWORD dwReadMode,
        DWORD dwWriteMode
        );

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //
    // Create Parent_Write to ChildStdIn Pipe.  Then
    // duplicate the parent copy to a noninheritable
    // handle and close the inheritable one so that
    // the child won't be holding open a handle to
    // the server end of its stdin pipe when we try
    // to nuke that pipe to close the child.
    //

    Success = MyCreatePipeEx(
                  &ChildIn,
                  &hWriteChild,
                  &lsa,
                  0,
                  0,
                  FILE_FLAG_OVERLAPPED) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  hWriteChild,
                  GetCurrentProcess(),
                  inH,
                  0,                       // ignored b/c SAME_ACCESS
                  FALSE,                   // not inheritable
                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE
                  );

    if (!Success) {
        ErrorExit("Could Not Create Parent-->Child Pipe");
    }

    //
    //Create ChildStdOut/stderr to Parent_Read pipe
    //

    Success = MyCreatePipeEx(
                  &hReadChild,
                  &ChildOut,
                  &lsa,
                  0,
                  FILE_FLAG_OVERLAPPED,
                  0) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  hReadChild,
                  GetCurrentProcess(),
                  outH,
                  0,                       // ignored b/c SAME_ACCESS
                  FALSE,                   // not inheritable
                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE
                  ) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  ChildOut,
                  GetCurrentProcess(),
                  &ChildOutDup,
                  0,                       // ignored b/c SAME_ACCESS
                  TRUE,                    // inheritable
                  DUPLICATE_SAME_ACCESS
                  );

    if (!Success) {
        ErrorExit("Could Not Create Child-->Parent Pipe");
    }

    ZeroMemory(&si, sizeof(si));
    si.cb            = sizeof(STARTUPINFO);
    si.dwFlags       = STARTF_USESTDHANDLES;
    si.hStdInput     = ChildIn;
    si.hStdOutput    = ChildOut;
    si.hStdError     = ChildOutDup;
    si.wShowWindow   = SW_SHOW;

    //
    // Create Child Process
    //

    if ( ! CreateProcess(
               NULL,
               cmd,
               NULL,
               NULL,
               TRUE,
               GetPriorityClass( GetCurrentProcess() ),
               NULL,
               NULL,
               &si,
               &pi)) {

        if (GetLastError()==2) {
            printf("Executable %s not found\n",cmd);
        } else {
            printf("CreateProcess(%s) failed, error %d.\n", cmd, GetLastError());
        }
        ErrorExit("Could Not Create Child Process");
    }

    //
    // Close unneccesary Handles
    //

    CloseHandle(ChildIn);
    CloseHandle(ChildOut);
    CloseHandle(ChildOutDup);
    CloseHandle(pi.hThread);

    pidChild = pi.dwProcessId;

    return(pi.hProcess);
}

//
// SendStatus runs as its own thread, with C runtime available.
//

DWORD
WINAPI
SendStatus(
    LPVOID   lpSendStatusParm
    )
{
    HANDLE hClientPipe = (HANDLE) lpSendStatusParm;
    char *pch;
    DWORD tmp;
    PREMOTE_CLIENT pClient;
    OVERLAPPED ol;
    char  buff[2048];
    char szSep[] = " ------------------------------\n";

    //
    // Since we're in our own thread we need our own
    // overlapped structure for our client pipe writes.
    //

    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent = CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );

    //
    // Dump the closing client list
    //

    pch = buff;

    EnterCriticalSection(&csClosingClientList);

    for (pClient = (PREMOTE_CLIENT) ClosingClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClosingClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s (Disconnected)\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csClosingClientList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);

    //
    // Dump the normal client list
    //

    pch = buff;

    EnterCriticalSection(&csClientList);

    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csClientList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);

    //
    // Dump the handshaking client list
    //

    pch = buff;

    EnterCriticalSection(&csHandshakingList);

    for (pClient = (PREMOTE_CLIENT) HandshakingListHead.Flink;
         pClient != (PREMOTE_CLIENT) &HandshakingListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s (Connecting)\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csHandshakingList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);

    //
    // Dump summary information.
    //

    pch = buff;

    pch += sprintf(pch, "REMOTE /C %s \"%s\"\n", HostName, PipeName);
    pch += sprintf(pch, "Command: %s\n", ChildCmd);
    pch += sprintf(pch, "Windows NT %d.%d build %d \n",
                   OsVersionInfo.dwMajorVersion,
                   OsVersionInfo.dwMinorVersion,
                   OsVersionInfo.dwBuildNumber);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);

    CloseHandle(ol.hEvent);

    return 0;
}

/*************************************************************/

DWORD                // NO CRT for ShowPopup
WINAPI
ShowPopup(
    void *vpArg
    )
{
    char *msg = (char *) vpArg;

    MessageBox(GetActiveWindow(),msg,"** REMOTE.EXE **",MB_OK|MB_SETFOREGROUND);
    HeapFree(hHeap, 0, msg);
    return(0);
}

/*************************************************************/

//
// SrvCtrlHand is the console event handler for the server side
// of remote.  If our stdin is a console handle, we've disabled
// generation of ^C events by the console code.  Therefore
// any we see are either generated by us for the benefit of
// our child processes sharing the console, or generated by
// some other process.  We want to ignore the ones we generate
// (since we're already done with everything that needs to be
// done at that point), and also ignore ^C's generated by
// other processes since we don't need to do anything with those.
// For example if someone runs:
//
// remote /s "remote /s cmd inner" outer
//
// Then local keyboard ^C's will be read by the outer remote.exe
// from its stdin handle, then it will generate a CTRL_C_EVENT that
// all processes in the console will see, including both remote.exe's
// and the child cmd.exe.  So the handler needs do nothing but indicate
// the event was handled by returning TRUE so the default handler
// won't kill us.  For ^BREAK we want to specifically kill our child
// process so that cmd.exe and others that ignore ^BREAK will go away.
// Of course this won't kill our grandchildren and so on.  Oh well.
//
// For all other events we return FALSE and let the default handler
// have it.
//

BOOL
WINAPI
SrvCtrlHand(
    DWORD event
    )
{
    BOOL bRet = FALSE;
    DWORD cb;
    DWORD dwTempFileOffset;
    OVERLAPPED ol;
    char szTime[64];
    char szCmd[128];

    if (event == CTRL_BREAK_EVENT) {
        TerminateProcess(ChldProc, 3);
        bRet = TRUE;
    } else if (event == CTRL_C_EVENT) {
        if ( ! cPendingCtrlCEvents ) {

            //
            // This came from the local keyboard or
            // was generated by another process in
            // this console.  Echo it as a local
            // command.  We have use GetTimeFormat
            // here not our GetFormattedTime since
            // the latter is for the use of the
            // main thread only.
            //

            GetTimeFormat(
                LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                NULL,   // use current time
                NULL,   // use default format
                szTime,
                sizeof(szTime)
                );

            CMDSTRING(szCmd, cb, "^C", pLocalClient, szTime, TRUE);

            ZeroMemory(&ol, sizeof(ol));
            ol.hEvent =
                CreateEvent(
                    NULL,      // security
                    TRUE,      // auto-reset
                    FALSE,     // initially nonsignaled
                    NULL       // unnamed
                    );

            //
            // Practically all writes to the tempfile are happening on
            // the primary server thread.  We're on a Ctrl-C thread.
            // We can't start the server to client I/O going after
            // writing because we're on the wrong thread, so we
            // punt.  To fix this we need an event we can signal
            // that causes the main thread to call StartServerToClientFlow.
            //

            dwTempFileOffset = dwWriteFilePointer;
            dwWriteFilePointer += cb;
            WriteFileSynch(hWriteTempFile, szCmd, cb, &cb, dwTempFileOffset, &ol);
            // wrong thread // StartServerToClientFlow();

            CloseHandle(ol.hEvent);

        } else {

            //
            // We generated this event in response to a ^C received from
            // a client, it's already been displayed to all clients.
            //

            cPendingCtrlCEvents--;
        }

        bRet = TRUE;
    }

    return bRet;
}


/*************************************************************/

typedef BOOL (STRINGSDTOSDW)(
    LPWSTR String,
    DWORD Version,
    PSECURITY_DESCRIPTOR * pSD,
    PULONG SDSize
    );
typedef STRINGSDTOSDW * PSTRINGSDTOSDW ;

typedef BOOL (SDTOSTRINGSDW)(
    PSECURITY_DESCRIPTOR SD,
    DWORD StringVersion,
    SECURITY_INFORMATION SecInfo,
    LPWSTR * StringDescriptor,
    PULONG Size
    );
typedef SDTOSTRINGSDW * PSDTOSTRINGSDW ;

BOOL
SddlToSecurityDescriptor(
    LPWSTR String,
    DWORD Version,
    PSECURITY_DESCRIPTOR * pSD,
    PULONG SDSize
    )
{
    HMODULE hModule ;
    PSTRINGSDTOSDW pStringSecurityDescriptorToSecurityDescriptor ;
    BOOL Success = FALSE ;
    PSECURITY_DESCRIPTOR sd ;

    hModule = GetModuleHandle( "advapi32.dll" );

    if ( hModule )
    {
        pStringSecurityDescriptorToSecurityDescriptor = (PSTRINGSDTOSDW) GetProcAddress( 
                                    hModule, "ConvertStringSecurityDescriptorToSecurityDescriptorW" );

        if ( pStringSecurityDescriptorToSecurityDescriptor )
        {
            Success = pStringSecurityDescriptorToSecurityDescriptor( String, Version, pSD, SDSize);
            return Success ;
        }
    }

    sd = LocalAlloc( LMEM_FIXED, sizeof( SECURITY_DESCRIPTOR ) );

    if ( sd )
    {
        InitializeSecurityDescriptor(
            sd,
            SECURITY_DESCRIPTOR_REVISION
            );

        SetSecurityDescriptorDacl(
            sd,
            TRUE,
            NULL,
            FALSE
            );

        *pSD = sd ;
        if ( SDSize )
        {
            *SDSize = sizeof( SECURITY_DESCRIPTOR );
            
        }

        return TRUE ;
    }

    return FALSE ;
}

/*************************************************************/

BOOL
SDtoStringSD(
    PSECURITY_DESCRIPTOR pSD,
    DWORD Version,
    SECURITY_INFORMATION SecInfo,
    LPWSTR * StringSD,
    PULONG StringSize
    )
{
    HMODULE hModule ;
    PSDTOSTRINGSDW pSDtoStringSD ;
    BOOL Success = FALSE ;

    hModule = GetModuleHandle( "advapi32.dll" );

    if ( hModule )
    {
        pSDtoStringSD = (PSDTOSTRINGSDW) GetProcAddress(
                                    hModule, "ConvertSecurityDescriptorToStringSecurityDescriptorW" );

        if ( pSDtoStringSD )
        {
            Success = pSDtoStringSD(pSD, Version, SecInfo, StringSD, StringSize );
            
            FreeLibrary( hModule );

            return Success ;
        }
    }

    return FALSE ;
}

/*************************************************************/

PSECURITY_DESCRIPTOR
FormatSecurityDescriptor(
    CHAR * * DenyNames,
    DWORD    DenyCount,
    CHAR * * Names,
    DWORD    Count)
{
    PSECURITY_DESCRIPTOR    Sd;
    PACL    Acl;
    DWORD   i;
    PSID    Sids;
    DWORD   SidLength ;
    CHAR    ReferencedDomain[ MAX_PATH ];
    UCHAR   SidBuffer[ 8 * sizeof(DWORD) + 8 ];
    DWORD   DomainLen ;
    SID_NAME_USE    Use;
    DWORD   SdLen;

    SdLen = sizeof(SECURITY_DESCRIPTOR) +
                        DenyCount * (sizeof( ACCESS_DENIED_ACE ) ) +
                        DenyCount * GetSidLengthRequired( 8 ) +
                        Count * (sizeof( ACCESS_ALLOWED_ACE ) ) + sizeof(ACL) +
                        (Count * GetSidLengthRequired( 8 ) );

    Sd = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SdLen );
    if ( !Sd ) {
        ErrorExit("Could not allocate SD");
    }

    InitializeSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION );

    Acl = (PACL)( (PUCHAR) Sd + sizeof( SECURITY_DESCRIPTOR) );

    InitializeAcl( Acl, SdLen - sizeof( SECURITY_DESCRIPTOR) ,
                    ACL_REVISION );

    Sids = SidBuffer;
    for (i = 0 ; i < DenyCount ; i ++ ) {
        SidLength = sizeof( SidBuffer );

        DomainLen = MAX_PATH ;

        if (! LookupAccountName(NULL,
                                DenyNames[ i ],
                                Sids,
                                &SidLength,
                                ReferencedDomain,
                                &DomainLen,
                                &Use ) )
        {
            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", DenyNames[ i ]);
            ErrorExit( ReferencedDomain );
        }

        //
        // Got the sid.  Now, add it as an access denied ace:
        //

        AddAccessDeniedAce( Acl,
                            ACL_REVISION,
                            FILE_GENERIC_READ |
                                FILE_GENERIC_WRITE |
                                FILE_CREATE_PIPE_INSTANCE,
                            Sids );


    }

    for (i = 0 ; i < Count ; i ++ ) {
        SidLength = sizeof( SidBuffer );

        DomainLen = MAX_PATH ;

        if (! LookupAccountName(NULL,
                                Names[ i ],
                                Sids,
                                &SidLength,
                                ReferencedDomain,
                                &DomainLen,
                                &Use ) )
        {
            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", Names[ i ]);
            ErrorExit( ReferencedDomain );
        }

        //
        // Got the sid.  Now, add it as an access allowed ace:
        //

        AddAccessAllowedAce(Acl,
                            ACL_REVISION,
                            FILE_GENERIC_READ |
                                FILE_GENERIC_WRITE |
                                FILE_CREATE_PIPE_INSTANCE,
                            Sids );
    }

    //
    // Now the ACL should be complete, so set it into the SD and return:
    //

    SetSecurityDescriptorDacl( Sd, TRUE, Acl, FALSE );

    return Sd ;
}


/*************************************************************/

VOID
CloseClient(
    REMOTE_CLIENT *pClient
    )
{
    DWORD tmp;
    char  Buf[200];

    #if DBG
        if (pClient->ServerFlags & ~SFLG_VALID) {

            printf("pClient %p looks nasty in CloseClient.\n", pClient);
            ErrorExit("REMOTE_CLIENT structure corrupt.");
        }
    #endif

    //
    // If we're still active (on the normal client list)
    // start tearing things down and move to the closing
    // list.
    //

    if (pClient->ServerFlags & SFLG_CLOSING) {
        return;
    }

    if (pClient->ServerFlags & SFLG_HANDSHAKING) {
        MoveClientToNormalList(pClient);
    }

    MoveClientToClosingList(pClient);

    pClient->ServerFlags |= SFLG_CLOSING;


    if (pClient->PipeWriteH != INVALID_HANDLE_VALUE) {
        TRACE(CONNECT, ("Disconnecting %d PipeWriteH (%p).\n", pClient->dwID, pClient->PipeWriteH));
        CancelIo(pClient->PipeWriteH);
        DisconnectNamedPipe(pClient->PipeWriteH);
        CloseHandle(pClient->PipeWriteH);
    }

    if (pClient->PipeReadH != INVALID_HANDLE_VALUE &&
        pClient->PipeReadH != pClient->PipeWriteH) {

        TRACE(CONNECT, ("Disconnecting %d PipeReadH (%p).\n", pClient->dwID, pClient->PipeReadH));
        CancelIo(pClient->PipeReadH);
        DisconnectNamedPipe(pClient->PipeReadH);
        CloseHandle(pClient->PipeReadH);
    }


    if (pClient->rSaveFile != INVALID_HANDLE_VALUE) {
        CancelIo(pClient->rSaveFile);
        CloseHandle(pClient->rSaveFile);
    }

    pClient->rSaveFile =
        pClient->PipeWriteH =
            pClient->PipeReadH =
                INVALID_HANDLE_VALUE;


    if ( ! bShuttingDownServer ) {
        ZeroMemory(Buf, sizeof(Buf));
        _snprintf(Buf, sizeof(Buf)-1, "\n**Remote: Disconnected from %s %s [%s]\n", pClient->Name, pClient->UserName, GetFormattedTime(TRUE));

        if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&tmp,dwWriteFilePointer,&olMainThread)) {
            dwWriteFilePointer += tmp;
            StartServerToClientFlow();
        }
    }

    return;
}

BOOL
FASTCALL
HandleSessionError(
    PREMOTE_CLIENT pClient,
    DWORD         dwError
    )
{
    if (pClient->ServerFlags & SFLG_CLOSING) {
        return TRUE;
    }

    if (dwError) {
        if (ERROR_BROKEN_PIPE == dwError ||
            ERROR_OPERATION_ABORTED == dwError ||
            ERROR_NO_DATA == dwError ) 
        {
            CloseClient(pClient);
            return TRUE;
        }

        SetLastError(dwError);
        ErrorExit("Unhandled session error.");
    }

    return FALSE;
}


VOID
FASTCALL
CleanupTempFiles(
    PSZ pszTempDir
    )
{
    HANDLE          hSearch;
    WIN32_FIND_DATA FindData;
    char            szPath[MAX_PATH + 1] = {0};
    char            szFile[MAX_PATH + 1];

    //
    // pszTempDir, from GetTempPath, has a trailing backslash.
    //

    _snprintf(szPath, sizeof(szPath)-1, "%sREM*.tmp", pszTempDir);

    hSearch = FindFirstFile(szPath, &FindData);

    if (INVALID_HANDLE_VALUE != hSearch) {
        do {
            ZeroMemory(szFile, sizeof(szFile));
            _snprintf(szFile, sizeof(szFile)-1, "%s%s", pszTempDir, FindData.cFileName);

            DeleteFile(szFile);
        } while (FindNextFile(hSearch, &FindData));

        FindClose(hSearch);
    }
}

VOID
SaveDacl(
    PSECURITY_DESCRIPTOR psd
    )
{
    HKEY hKey ;
    int err ;
    DWORD disp ;
    LPWSTR StringSD ;
    DWORD StringLen; 

    err = RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            REGISTRY_PATH,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,
            &hKey,
            &disp );

    if ( err == 0 ) {
        if ( SDtoStringSD(sdPublic, 1, DACL_SECURITY_INFORMATION, &StringSD, &StringLen ) ) {
            err = RegSetValueExW(
                    hKey,
                    REGISTRY_VALUE,
                    0,
                    REG_SZ,
                    (LPBYTE) StringSD,
                    StringLen * sizeof(WCHAR) );
        }
        
        RegCloseKey( hKey );
    }
}

#pragma prefast(push)
#pragma prefast(disable: 248)       // NULL dacl is by design here, really
VOID
FASTCALL
SetupSecurityDescriptors(
    VOID
    )
{
    int i;
    int err ;
    HKEY hKey ;
    PWSTR TextSD ;
    DWORD Type ;
    DWORD Size ;
    PSID Everyone ;
    PACL pDacl ;
    SID_IDENTIFIER_AUTHORITY World = SECURITY_WORLD_SID_AUTHORITY ;
    PSECURITY_DESCRIPTOR psd ;

    pDacl = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 12 + sizeof( ACCESS_ALLOWED_ACE ) + sizeof( ACL ));
    psd = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( SECURITY_DESCRIPTOR ));

    //
    // initialize the struct
    //
    saLocalNamedObjects.nLength = sizeof( SECURITY_ATTRIBUTES );

    if ( (pDacl != NULL) && (psd != NULL ) ) {
        if ( AllocateAndInitializeSid(&World, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &Everyone) ) {
            InitializeAcl(pDacl, 12 + sizeof( ACCESS_ALLOWED_ACE ) + sizeof( ACL ), ACL_REVISION);

            AddAccessAllowedAce(pDacl, ACL_REVISION, 
                EVENT_ALL_ACCESS | MUTEX_ALL_ACCESS | SYNCHRONIZE, Everyone );

            InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION );

            SetSecurityDescriptorDacl( psd, TRUE, pDacl, FALSE );

            saLocalNamedObjects.bInheritHandle = FALSE ;
            saLocalNamedObjects.lpSecurityDescriptor = psd ;

            HeapFree(GetProcessHeap(), 0, Everyone );
        }
    }

    //
    // Initialize the wide-open security descriptor.
    //

    if ( !SddlToSecurityDescriptor(DEFAULT_SECURITY_DESCRIPTOR, 1, &sdPublic, NULL ) ) {
        sdPublic = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( SECURITY_DESCRIPTOR ) );

        if ( sdPublic ) {
            InitializeSecurityDescriptor( sdPublic, SECURITY_DESCRIPTOR_REVISION );
            SetSecurityDescriptorDacl( sdPublic, TRUE, NULL, FALSE );
        }
    }

    saPublic.nLength = sizeof(saPublic);
    saPublic.lpSecurityDescriptor = sdPublic;

    //
    // if /u was specified once or more, build the security descriptor to
    // enforce it.
    //

    saPipe.nLength = sizeof(saPipe);

    if ( DaclNameCount  || DaclDenyNameCount ) {
        saPipe.lpSecurityDescriptor =
            FormatSecurityDescriptor( DaclDenyNames, DaclDenyNameCount, DaclNames, DaclNameCount );

        if ( SaveDaclToRegistry ) {
            SaveDacl( saPipe.lpSecurityDescriptor );
        }

        if (DaclNameCount) {
            fputs( "\nProtected Server!  Only the following users or groups can connect:\n", stdout );

            for (i = 0 ; i < (int) DaclNameCount ; i++) {
                printf( "    %s\n", DaclNames[i] );
            }
        }

        if (DaclDenyNameCount) {
            fputs("The following users or groups explicitly cannot connect:\n", stdout );

            for (i = 0 ; i < (int) DaclDenyNameCount ; i++) {
                printf("    %s\n", DaclDenyNames[i] );
            }
        }
    } else {

        saPipe.lpSecurityDescriptor = sdPublic;

        err = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    REGISTRY_PATH,
                    0,
                    KEY_READ,
                    &hKey );

        if ( err == 0 ) {
            err = RegQueryValueExW(
                    hKey,
                    REGISTRY_VALUE,
                    0,
                    &Type,
                    NULL,
                    &Size );

            if ( err != ERROR_FILE_NOT_FOUND ) {
                TextSD = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size );

                if ( TextSD ) {
                    err = RegQueryValueExW(
                            hKey,
                            REGISTRY_VALUE,
                            0,
                            &Type,
                            (LPBYTE) TextSD,
                            &Size );

                    if ( err == 0 ) {
                        SddlToSecurityDescriptor(
                            TextSD, 1, &saPipe.lpSecurityDescriptor, NULL );
                    }
                }
            }

            RegCloseKey( hKey );
        }
    }
}
#pragma prefast(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rescan\rescan.c ===
#include <nt.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

#define _NTSCSI_USER_MODE_

#include <scsi.h>

VOID
GetDriverName(
    IN ULONG PortNumber
    )
{
    UNICODE_STRING name;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    HANDLE key;
    HANDLE portKey;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    UCHAR buffer[64];
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION keyData = (PKEY_VALUE_FULL_INFORMATION)buffer;

    printf("\nSCSI PORT %d\n", PortNumber);

    //
    // Obtain handle to SCSI path in device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Open the key.
    //

    status = NtOpenKey(&key,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Create Scsi port name.
    //

    sprintf(buffer,
            "Scsi Port %d",
            PortNumber);

    RtlInitString(&ansiString, buffer);

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &ansiString,
                                          TRUE);

    if (!NT_SUCCESS(status)) {
        return;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                key,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = NtOpenKey(&portKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&name,
                         L"Driver");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        return;
    }

    printf("Driver name: %S\n",
           (PUCHAR)keyData + keyData->DataOffset);

    RtlInitUnicodeString(&name,
                         L"Interrupt");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        return;
    }

    printf("IRQ %d ",
           *((PUCHAR)keyData + keyData->DataOffset));

    RtlInitUnicodeString(&name,
                         L"IOAddress");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        printf("\n");
        return;
    }

    printf("IO Address %x\n",
           *((PULONG)keyData + keyData->DataOffset/4));

    return;
}

int __cdecl
main( int argc, char **argv )
{
    BYTE buffer[32];
    HANDLE volumeHandle;
    STRING string;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    NTSTATUS ntStatus;
    IO_STATUS_BLOCK statusBlock;
    ULONG portNumber = 0;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA busData;
    PSCSI_INQUIRY_DATA inquiryData;
    UCHAR prevDeviceInquiryData[INQUIRYDATABUFFERSIZE];
    PINQUIRYDATA deviceInquiryData;
    ULONG bytesTransferred, i, j;
    ULONG deviceNumber;
    BOOLEAN newDisk = FALSE;
    BOOLEAN newCdrom = FALSE;
    UCHAR prevPathId;
    UCHAR prevTargetId;
    UCHAR prevLun;
    BOOLEAN prevDeviceClaimed;
    BOOLEAN listAdapters = FALSE;
    BOOLEAN allAdapters = TRUE;
    UCHAR lunExtra;

    if(argc == 2) {
        if(argv[1][0] == '*') {
            listAdapters = TRUE;
        } else {
            portNumber = atoi(argv[1]);
            allAdapters = FALSE;
        }
    }

    printf("\nWindows NT SCSI Bus Rescan Version 1.1\n");

    if(listAdapters) {
        printf("[only listing adapters]\n");
    } else if(allAdapters) {
        printf("[scanning all adapters]\n");
    } else {
        printf("[scanning adapter %d only]\n", portNumber);
    }

    while (TRUE) {

        memset( buffer, 0, sizeof( buffer ) );
        sprintf( buffer,
                 "\\\\.\\Scsi%d:",
                 portNumber);

        //
        // Open the volume with the DOS name.
        //

        volumeHandle = CreateFile( buffer,
                                   GENERIC_READ,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

        if( volumeHandle == INVALID_HANDLE_VALUE ) {
            break;
        }

        if(listAdapters) {
            GetDriverName(portNumber);
            portNumber++;
            CloseHandle(volumeHandle);
            continue;
        }

        //
        // Issue rescan device control.
        //

        if( !DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_RESCAN_BUS,
                              NULL,
                              0,
                              NULL,
                              0,
                              &bytesTransferred,
                              NULL ) ) {

            printf( "Rescan SCSI port %d failed [Error %d].\n", portNumber, GetLastError() );
            CloseHandle( volumeHandle );
            exit(4);
        }

        //
        // Get a big chuck of memory to store the SCSI bus data.
        //

        adapterInfo = malloc( 0x1000 );

        if (adapterInfo == NULL) {
            printf( "Can't allocate memory for bus data\n" );
            CloseHandle( volumeHandle );
            exit(4);
        }

        //
        // Issue device control to get configuration information.
        //

        if (!DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_GET_INQUIRY_DATA,
                              NULL,
                              0,
                              adapterInfo,
                              0x1000,
                              &bytesTransferred,
                              NULL)) {

            printf( "Get SCSI bus data failed [Error %d].\n", GetLastError() );
            CloseHandle( volumeHandle );
            exit(4);
        }

        GetDriverName(portNumber);

        //
        // Display devices on buses.
        //

        for (i=0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];
            printf( "\nBus  TID  LUN  In use  Type        Vendor                 FW Rev  Advanced SCSI\n" );
            printf( "===============================================================================\n" );
            printf("%2d   %2d   %2d     %2d    Initiator",
                   i,
                   busData->InitiatorBusId & 0x7,
                   0,
                   1);

            inquiryData =
                (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            memset(&prevDeviceInquiryData, 0, INQUIRYDATABUFFERSIZE);
            prevPathId = 0xFF;
            prevTargetId = 0xFF;
            prevLun = 0xFF;
            prevDeviceClaimed = 0xFF;
            for (j=0; j<busData->NumberOfLogicalUnits; j++) {

                int k;

                //
                // Make sure VendorId string is null terminated.
                //

                deviceInquiryData = (PINQUIRYDATA)&inquiryData->InquiryData[0];

                deviceInquiryData->VendorSpecific[0] = '\0';
                if (prevPathId != inquiryData->PathId ||
                    prevTargetId != inquiryData->TargetId ||
                    prevLun != (inquiryData->Lun-1) ||
                    prevDeviceClaimed != inquiryData->DeviceClaimed ||
                    memcmp( &prevDeviceInquiryData, deviceInquiryData, INQUIRYDATABUFFERSIZE)
                   ) {
                    lunExtra = 0;
                    printf("\n%2d   %2d   %2d     %2d    ",
                            inquiryData->PathId,
                            inquiryData->TargetId,
                            inquiryData->Lun,
                            inquiryData->DeviceClaimed);
                } else {
                    lunExtra += 1;
                    printf("\r%2d   %2d   %2d-%1d   %2d    ",
                            inquiryData->PathId,
                            inquiryData->TargetId,
                            inquiryData->Lun-lunExtra,
                            inquiryData->Lun,
                            inquiryData->DeviceClaimed);
                    }

                prevPathId = inquiryData->PathId;
                prevTargetId = inquiryData->TargetId;
                prevLun = inquiryData->Lun;
                prevDeviceClaimed = inquiryData->DeviceClaimed;
                memmove( &prevDeviceInquiryData, deviceInquiryData, INQUIRYDATABUFFERSIZE);

                //
                // Determine the perpherial type.
                //

                switch (deviceInquiryData->DeviceType) {
                case DIRECT_ACCESS_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newDisk = TRUE;
                    }
                    printf("Disk Drive ");
                    break;

                case SEQUENTIAL_ACCESS_DEVICE:
                    printf("Tape Drive ");
                    break;

                case PRINTER_DEVICE:
                    printf("Printer    ");
                    break;

                case WRITE_ONCE_READ_MULTIPLE_DEVICE:
                    printf("Worm Drive ");
                    break;

                case READ_ONLY_DIRECT_ACCESS_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newCdrom = TRUE;
                    }
                    printf("CdRom Drive");
                    break;

                case SCANNER_DEVICE:
                    printf("Scanner    ");
                    break;

                case OPTICAL_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newDisk = TRUE;
                    }
                    printf("OpticalDisk");
                    break;

                case MEDIUM_CHANGER:
                    printf("MediumChanger");
                    break;

                case COMMUNICATION_DEVICE:
                    printf("Communication");
                    break;

                default:
                    printf("OtherPeripheral");
                }

                //
                // Display product information.
                //

                printf(" %s", deviceInquiryData->VendorId);

                //
                // Display SCSI capabilities.
                //

                printf("   ");
                if (deviceInquiryData->Synchronous) {
                    printf(" SN");
                }

                if (deviceInquiryData->CommandQueue) {
                    printf(" CQ");
                }

                if (deviceInquiryData->Wide16Bit) {
                    printf(" W16");
                }

                if (deviceInquiryData->Wide32Bit) {
                    printf(" W32");
                }

                if (deviceInquiryData->SoftReset) {
                    printf(" SR");
                }

                if (deviceInquiryData->LinkedCommands) {
                    printf(" LC");
                }

                if (deviceInquiryData->RelativeAddressing) {
                    printf(" RA");
                }

                if (deviceInquiryData->DeviceTypeQualifier != DEVICE_QUALIFIER_ACTIVE) {
                    printf(" DQ%d", deviceInquiryData->DeviceTypeQualifier);
                }

                printf("\n                        [ ");
                for(k = 0; k < 8; k++) {
                    printf("%02x ", ((PUCHAR) deviceInquiryData)[k]);
                }
                printf("]");

                //
                // Get next device data.
                //

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);
            }

            printf("\n");
        }

        free (adapterInfo);

        if(allAdapters) {
            CloseHandle( volumeHandle );
            portNumber++;
        } else {
            break;
        }
    }

    if (newDisk) {

        //
        // Send IOCTL_DISK_FIND_NEW_DEVICES commands to each existing disk.
        //

        deviceNumber = 0;
        while (TRUE) {

            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer,
                    "\\Device\\Harddisk%d\\Partition0",
                    deviceNumber);

            RtlInitString(&string,
                          buffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = NtOpenFile(&volumeHandle,
                                  FILE_READ_DATA  |
                                  FILE_WRITE_DATA |
                                  SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  |
                                  FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            //
            // Issue find device device control.
            //

            if (DeviceIoControl( volumeHandle,
                                 IOCTL_DISK_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL ) ) {

                printf( "Found new disk (%d)\n", deviceNumber );
            }

            CloseHandle( volumeHandle );
            deviceNumber++;
        }
    }

    if (newCdrom) {

        //
        // Send IOCTL_CDROM_FIND_NEW_DEVICES commands to each existing cdrom.
        //

        deviceNumber = 0;
        while (TRUE) {

            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer,
                    "\\Device\\Cdrom%d",
                    deviceNumber);

            RtlInitString(&string,
                          buffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = NtOpenFile(&volumeHandle,
                                  FILE_READ_DATA  |
                                  FILE_WRITE_DATA |
                                  SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  |
                                  FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            //
            // Issue find device device control.
            //

            if (DeviceIoControl( volumeHandle,
                                 IOCTL_CDROM_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL ) ) {

                printf( "Found new cdrom (%d)\n", deviceNumber );
            }

            CloseHandle( volumeHandle );
            deviceNumber++;
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\inc\rc.h ===
#include <stdio.h>
#include <windef.h>

#define	wcsdigit(w) (w >= 0x0030 && w <= 0x0039)

#define TRUE	1
#define FALSE	0

/* The ResType field of NewHeader identifies the resource type */
#define  ICONTYPE      1
#define  CURSORTYPE    2

/* Identifies the menu item template version number */
#define  MENUITEMTEMPLATEVERISONNUMBER 0
#define  MENUITEMTEMPLATEBYTESINHEADER 0

#define DIFFERENCE	11

/* Predefined resource types */
#define RT_NAMETABLE	MAKEINTRESOURCE((DWORD)15)
#define RT_NEWRESOURCE	0x2000
#define RT_ERROR	0x7fff
#define RT_NEWBITMAP	MAKEINTRESOURCE((DWORD)RT_BITMAP+DIFFERENCE)

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

/* Translater flag bits */
#define fVIRTKEY    1
#define fNOINVERT   2
#define fSHIFT      4
#define fCONTROL    8
#define fALT        16

/* menu flag bits */

#define OPGRAYED          0x0001
#define OPINACTIVE        0x0002
#define OPBITMAP          0x0004
#define OPOWNERDRAW       0x0100
#define OPUSECHECKBITMAPS 0x0200
#define OPCHECKED         0x0008
#define OPPOPUP           0x0010
#define OPBREAKWBAR       0x0020
#define OPBREAK           0x0040
#define OPENDMENU         0x0080
#define OPHELP            0x4000
#define OPSEPARATOR       0x0800
/*#define OPPOPHELP         0x0004*/

/*
** dialog & menu template tokens (these start at 40)
*/

/* buttons */
#define TKRADIOBUTTON   40
#define TKCHECKBOX      41
#define TKPUSHBUTTON    42
#define TKDEFPUSHBUTTON 43
#define TKAUTOCHECKBOX	44
#define TK3STATE	45
#define TKAUTO3STATE	46
#define TKUSERBUTTON	47
#define TKAUTORADIOBUTTON	48
#define TKOWNERDRAW	50
#define TKGROUPBOX      51

/* static/edit */
#define TKEDITTEXT      60
#define TKLTEXT         61
#define TKRTEXT         62
#define TKCTEXT         63
#define TKEDIT          64
#define TKSTATIC        65
#define TKICON          66
#define TKBITMAP        67

/* menu stuff */
#define TKMENU          70
#define TKMENUITEM      71
#define TKSEPARATOR     72
#define TKCHECKED       73
#define TKGRAYED        74
#define TKINACTIVE      75
#define TKBREAKWBAR     76
#define TKBREAK         77
#define TKPOPUP         78
#define TKHELP          79

/* other controls */
#define TKLISTBOX       90
#define TKCOMBOBOX      91
#define TKRCDATA        92
#define TKSCROLLBAR	93
#define TKFONT		94
#define TKBUTTON        95
#define TKMESSAGETABLE  96

/* math expression tokens */
#define TKCLASS         100
#define TKPLUS          101
#define TKMINUS         102
#define TKNOINVERT      103
#define TKNOT           104
#define TKKANJI         105
#define TKSHIFT         106

/* Accel table */
#define TKALT           110
#define TKASCII         111
#define TKVIRTKEY       112
#define TKVALUE         113
#define TKBLOCK         114

/* verison */
#define TKFILEVERSION   120
#define TKPRODUCTVERSION	121
#define TKFILEFLAGSMASK 122
#define TKFILEFLAGS     123
#define TKFILEOS        124
#define TKFILETYPE      125
#define TKFILESUBTYPE   126

/* misc */
#define	TKCHARACTERISTICS	130
#define	TKLANGUAGE	131
#define	TKVERSION	132
#define TKSTYLE         133
#define TKCONTROL       134
#define TKCAPTION       135
#define TKDLGINCLUDE    136
#define TKLSTR	        137
#define	TKEXSTYLE	0xfff7	/* so as not to conflict with x-coordinate */

/* memory and load flags */
#define TKFIXED         0xfff0
#define TKMOVEABLE      0xfff1
#define TKDISCARD       0xfff2
#define TKLOADONCALL    0xfff3
#define TKPRELOAD       0xfff4
#define TKPURE          0xfff5
#define TKIMPURE        0xfff6

/* special tokens */
#define CHCARRIAGE	'\r'
#define CHSPACE		' '
#define CHNEWLINE	'\n'
#define CHTAB		9
#define CHDIRECTIVE	'#'
#define CHQUOTE		'"'
#define CHEXTENSION	'.'
#define CHCSOURCE	'c'
#define CHCHEADER	'h'

#define DEBUGLEX    1
#define DEBUGPAR    2
#define DEBUGGEN    4

/* The following switches, when defined enable various options
**  #define DEBUG enables debugging output.  Use one or more of the
**  values defined above to enable debugging output for different modules */

/* Version number.  VERSION and REVISION are used to set the API number
** in an RCed file.  SIGNON_* are used just to print the signon banner.
** Changing VERSION and REVISION means that applications RCed with this
** version will not run with earlier versions of Windows.  */

#define VERSION  2
#define REVISION 03
#define SIGNON_VER 3
#define SIGNON_REV 20

/* GetToken() flags */
#define TOKEN_NOEXPRESSION 0x8000

/* Current token structure */
#define MAXSTR (4096+1)
#define MAXTOKSTR (256+1)

#pragma pack(2)
typedef struct tok {
    LONG	longval;
    int		row;			/* line number of current token */
    int		col;			/* column number of current token */
    BOOL	flongval;		/* is parsed number a long? */
    USHORT	val;
    UCHAR	type;
} TOKEN;

typedef struct _fontdir {
    USHORT	ordinal;
    USHORT	nbyFont;
    struct _fontdir	*next;
} FONTDIR;

typedef struct _OBJLST {
    struct _OBJLST	*next;
    DWORD       nObj;         /* objecty number */
    DWORD       cb;           /* number of bytes used */
    DWORD       cpg;          /* number of pages used */
    DWORD       flags;        /* object memory flags */
} OBJLST, *POBJLST;

typedef struct Control {
    /* don't re-order the first items! */
    LONG	style;
    LONG	exstyle;
    SHORT	x,y,cx,cy;
    SHORT	id;
    /* end of don't re-order */
    WCHAR	fOrdinalText;
    WCHAR	class[ MAXTOKSTR ];
    WCHAR	text[ MAXTOKSTR ];
} CNTRL;

struct DialogHeader {
    /* don't re-order the first items! */
    LONG	style;
    LONG	exstyle;
    WORD	bNumberOfItems;
    SHORT	x,y,cx,cy;
    /* end of don't re-order */
    WCHAR	MenuName [ MAXTOKSTR ];
    WCHAR	Class[ MAXTOKSTR ];
    WCHAR	Title[ MAXTOKSTR ];
    USHORT	pointsize;
    WCHAR	Font[ MAXTOKSTR ];
    UCHAR	fOrdinalMenu, fClassOrdinal;
};

typedef struct mnHeader {
    USHORT   menuTemplateVersionNumber;
    USHORT   menuTemplateBytesInHeader;
} MNHEADER;


typedef struct mnStruc {
    SHORT	id;
    WCHAR	szText[ MAXTOKSTR ];
    UCHAR	OptFlags;
    UCHAR	PopFlag;
}  MNSTRUC;

/* End of file character/token */
#define EOFMARK 127

/* single character keywords that we ignore */
#define LPAREN   1      /* ( */
#define RPAREN   2      /* ) */

/* multiple character keywords */
#define FIRSTKWD 11             /* for adding to table indices */

#define OR       FIRSTKWD+1
#define BEGIN    FIRSTKWD+2
#define END      FIRSTKWD+3
#define COMMA    FIRSTKWD+4
#define TILDE    FIRSTKWD+5
#define AND      FIRSTKWD+6
#define EQUAL    FIRSTKWD+7
#define LASTKWD  FIRSTKWD+8  /* 19 */

/* Token types */
#define NUMLIT     LASTKWD+1  /* 20 */
#define STRLIT     LASTKWD+2
#define CHARLIT    LASTKWD+3
#define LSTRLIT    LASTKWD+4

#define BLOCKSIZE 16
struct StringEntry {
    struct StringEntry *next;
    DWORD       version;
    DWORD       characteristics;
    USHORT	hibits;
    SHORT       flags;
    WORD	language;
    WCHAR	*rgsz[ BLOCKSIZE ];
};

struct AccEntry {
    WORD	flags;
    WCHAR	ascii;
    USHORT	id;
    USHORT	unused;
};

typedef struct resinfo {
    DWORD       version;
    DWORD       characteristics;
    LONG	exstyleT;
    LONG	BinOffset;
    LONG	size;
    struct resinfo *next;
    DWORD       poffset;
    WCHAR	*name;
    POBJLST	pObjLst;
    WORD	language;
    SHORT	flags;
    USHORT	nameord;
    USHORT	cLang;
} RESINFO;

typedef struct typinfo {
    struct typinfo *next;
    struct resinfo *pres;
    WCHAR	*type;
    USHORT	typeord;
    USHORT	cTypeStr;
    USHORT	cNameStr;
    SHORT	nres;
} TYPINFO;

int	ResCount;   /* number of resources */
TYPINFO	*pTypInfo;

typedef struct tagResAdditional {
    DWORD       DataSize;               // size of data without header
    DWORD       HeaderSize;     // Length of the header
    // [Ordinal or Name TYPE]
    // [Ordinal or Name NAME]
    DWORD       DataVersion;    // version of data struct
    WORD	MemoryFlags;	// state of the resource
    WORD	LanguageId;	// Unicode support for NLS
    DWORD	Version;  	// Version of the resource data
    DWORD	Characteristics;	// Characteristics of the data
} RESADDITIONAL;

#pragma pack()


/* Global variables */
extern	SHORT	nFontsRead;
extern	FONTDIR	*pFontList;
extern	FONTDIR	*pFontLast;
extern	FILE	*errfh;
extern	FILE	*outfh;
extern	TOKEN	token;
extern	int	errorCount;
extern	CHAR	tokenbuf[ MAXSTR ];
extern	WCHAR	unicodebuf[ MAXSTR ];
extern	UCHAR	separators[EOFMARK+1];
extern	UCHAR	exename[_MAX_PATH], fullname[_MAX_PATH];
extern	UCHAR	curFile[_MAX_PATH];
extern	WORD	language;
extern	LONG	version;
extern	LONG	characteristics;

extern	struct	DialogHeader *pLocDlg;
extern	int	mnEndFlagLoc;	/* patch location for end of a menu. */
				/* we set the high order bit there    */

extern	BOOL	fFoundBinFile;	/* is there a .res file to read?	*/
extern	BOOL	fVerbose;	/* verbose mode (-v) */
extern	BOOL	fKanjiMode;
extern	SHORT	k1,k2,k3,k4;
extern	RESINFO*pResString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\inc\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *	85/04/01	Pete Stewart	Segment alignment field, error bit
 *	88/03/28	Craig Critchley Version 3.00 stuff
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    USHORT      e_magic;        /* Magic number */
    USHORT      e_cblp;         /* Bytes on last page of file */
    USHORT      e_cp;           /* Pages in file */
    USHORT      e_crlc;         /* Relocations */
    USHORT      e_cparhdr;      /* Size of header in paragraphs */
    USHORT      e_minalloc;     /* Minimum extra paragraphs needed */
    USHORT      e_maxalloc;     /* Maximum extra paragraphs needed */
    USHORT      e_ss;           /* Initial (relative) SS value */
    USHORT      e_sp;           /* Initial SP value */
    USHORT      e_csum;         /* Checksum */
    USHORT      e_ip;           /* Initial IP value */
    USHORT      e_cs;           /* Initial (relative) CS value */
    USHORT      e_lfarlc;       /* File address of relocation table */
    USHORT      e_ovno;         /* Overlay number */
    USHORT      e_res[ERESWDS]; /* Reserved words */
    LONG        e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    USHORT      ne_magic;       /* Magic number NE_MAGIC */
    CHAR        ne_ver;         /* Version number */
    CHAR        ne_rev;         /* Revision number */
    USHORT      ne_enttab;      /* Offset of Entry Table */
    USHORT      ne_cbenttab;    /* Number of bytes in Entry Table */
    LONG        ne_crc;         /* Checksum of whole file */
    USHORT      ne_flags;       /* Flag word */
    USHORT      ne_autodata;    /* Automatic data segment number */
    USHORT      ne_heap;        /* Initial heap allocation */
    USHORT      ne_stack;       /* Initial stack allocation */
    LONG        ne_csip;        /* Initial CS:IP setting */
    LONG        ne_sssp;        /* Initial SS:SP setting */
    USHORT      ne_cseg;        /* Count of file segments */
    USHORT      ne_cmod;        /* Entries in Module Reference Table */
    USHORT      ne_cbnrestab;   /* Size of non-resident name table */
    USHORT      ne_segtab;      /* Offset of Segment Table */
    USHORT      ne_rsrctab;     /* Offset of Resource Table */
    USHORT      ne_restab;      /* Offset of resident name table */
    USHORT      ne_modtab;      /* Offset of Module Reference Table */
    USHORT      ne_imptab;      /* Offset of Imported Names Table */
    LONG        ne_nrestab;     /* Offset of Non-resident Names Table */
    USHORT      ne_cmovent;     /* Count of movable entries */
    USHORT      ne_align;       /* Segment alignment shift count */
    USHORT    	ne_cres;	/* Count of resource segments */
    UCHAR	ne_exetyp;	/* Target operating system */
    UCHAR	ne_flagsother;	/* Additional exe flags */
    USHORT    	ne_gangstart;	/* offset to gangload area */
    USHORT    	ne_ganglength;	/* length of gangload area */
    USHORT      ne_swaparea;    /* Minimum code swap area size */
    USHORT      ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   l					Private Library
 *    e 				Errors in image
 *     xxxx				Unused
 *	   ww				Uses PM API
 *	     G				Library GlobalAlloc above the line
 *	      M 			Multiple Instance
 *	       L			Uses LIM 3.2
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP		0x8000		/* Not a process */
#define NEPRIVLIB	0x4000		/* Private Library */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR		0x2000		/* Errors in image */
#define NEWINAPI        0x0300          /* Uses PM API. For binary compat */
#define NEEMSLIB	0x0040		/* Library GA above EMS line */
#define NEMULTINST	0x0020		/* multiple instance flag */
#define NELIM32 	0x0010		/* LIM 32 expanded memory */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO		0x0001		/* Solo data */

/*
 *  Format of additional flags:
 *
 *  xxxx
 *	p				Preload area defined after seg table
 *	 P				2.X supports protected mode
 *	  F				2.X supports proportional font
 *	   L				Long file name support
 */

#define NEPRELOAD	0x08		/* preload segments */
#define NEINPROT	0x04		/* protect mode */
#define NEINFONT	0x02		/* prop. system font */
#define NELONGNAMES	0x01		/* long file names */

struct new_seg                          /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
    USHORT      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            USHORT      ns_niter;       /* number of iterations */
            USHORT      ns_nbytes;      /* number of bytes */
            CHAR        ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            CHAR        ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    USHORT      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    CHAR        nr_stype;       /* Source type */
    CHAR        nr_flags;       /* Flag byte */
    USHORT      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            CHAR        nr_segno;       /* Target segment number */
            CHAR        nr_res;         /* Reserved */
            USHORT nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            USHORT nr_mod;      /* Index into Module Reference Table */
            USHORT nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */


/* Resource type or name string */
struct rsrc_string
    {
    CHAR rs_len;            /* number of bytes in string */
    CHAR rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    USHORT rt_id;
    USHORT rt_nres;
    LONG   rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    USHORT rn_offset;   /* file offset to resource data */
    USHORT rn_length;   /* length of resource data */
    USHORT rn_flags;    /* resource flags */
    USHORT rn_id;       /* resource name id */
    USHORT rn_handle;   /* If loaded, then global handle */
    USHORT rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    USHORT rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\inc\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rc 16-bit unicode support.  It contains
	the translatation table for codepage 1252.  This was taken from the
	nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#ifndef __RCUNICOD

#define __RCUNICOD


#define IN
#define OUT

#define DFT_TEST_SIZE			10	// The number of words to test to get
									// an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN		0	// File type not yet determined.
#define DFT_FILE_IS_8_BIT		1	// File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT		2	// File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV	3	// File is reversed 16-bit unicode file.

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN	1	// Return values from determine system
#define DSE_SYS_BIG_ENDIAN		2	// endian type.

//
// This is all the translation we currently need.
//

INT
A_fwrite (
	IN		CHAR	*pchMBString,
    IN		INT		nSizeOfItem,
    IN		INT		nCountToWrite,
    IN      FILE	*fpOutputFile
    );

INT
U_fwrite (
	IN		WCHAR	*pwchUnicodeString,
    IN		INT		nSizeOfItem,
    IN		INT		nCountToWrite,
    IN      FILE	*fpOutputFile
    );

INT
A_fputc (
    IN		CHAR	chCharToWrite,
    IN      FILE	*fpOutputFile
    );

INT
U_fputc (
    IN		WCHAR	wcCharToWrite,
    IN      FILE	*fpOutputFile
    );

BOOL
UnicodeFromMBString (
    OUT		WCHAR	*pwchUnicodeString,
    IN		CHAR	*pchMBString,
	IN		INT		nCountStrLength
    );

BOOL
MBStringFromUnicode (
    OUT		CHAR	*pchMBString,
    IN		WCHAR	*pwchUnicodeString,
	IN		INT		nCountStrLength
    );

#ifdef DBCS
BOOL
UnicodeFromMBStringN (
    OUT		WCHAR	*pwchUnicodeString,
    IN		CHAR	*pchMBString,
    IN		INT	nCountStrLength,
    IN          UINT    uiCodePage
    );

BOOL
MBStringFromUnicodeN (
    OUT		CHAR	*pchMBString,
    IN		WCHAR	*pwchUnicodeString,
    IN		INT	nCountStrLength,
    IN          UINT    uiCodePage
    );
#endif // DBCS

INT
Char1252FromUnicode (
    IN		WCHAR	wchUnicodeChar
    );

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      FILE	*fpInputFile
    );

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
	VOID
    );

#endif  // __RCUNICOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rescan\setpriv.c ===
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <process.h>



BOOL
EnableCreatePermanentPrivilege(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivileges
    );

BOOL
OpenToken(
    PHANDLE TokenHandle
    );


VOID
__cdecl main  (int argc, char *argv[])
{
    int i;
    PACL Dacl;
    LPSTR FileName;
    TOKEN_PRIVILEGES OldPrivileges;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminAliasSid;
    BOOL Result;
    ULONG DaclSize;
    HANDLE TokenHandle;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    Result = OpenToken( &TokenHandle );

    if ( !Result ) {

        printf("Unable to open token\n");
        exit(-1);
    }


    Result = EnableCreatePermanentPrivilege(
                TokenHandle,
                &OldPrivileges
                );

    if ( !Result ) {

        //
        // This account doesn't have SeCreatePermanent
        // privilege.  Tell them to try running it again
        // from an account that does.
        //

        printf("Unable to enable SeCreatePermanent privilege\n");

        //
        // do what you want here...
        //

        exit(4);
    }

    //
    // Display privileges.
    //



    //
    // Put things back the way they were
    //

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &OldPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

    if ( GetLastError() != NO_ERROR ) {

        //
        // This is unlikely to happen,
        //

        printf("AdjustTokenPrivileges failed turning off SeCreatePermanent privilege\n");
    }
}



BOOL
EnableCreatePermanentPrivilege(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivileges
    )
{
    TOKEN_PRIVILEGES NewPrivileges;
    BOOL Result;
    LUID CreatePermanentValue;
    ULONG ReturnLength;

    //
    // Mike: change SeCreatePermanentPrivilege to SeCreatePermanentPrivilege
    // and you'll be pretty much there.
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeCreatePermanetPrivilegePrivilege",
                 &CreatePermanentValue
                 );

    if ( !Result ) {

        printf("Unable to obtain value of CreatePermanent privilege\n");
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = CreatePermanentValue;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;



    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &NewPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                OldPrivileges,
                &ReturnLength
                );

    if ( GetLastError() != NO_ERROR ) {

        return( FALSE );

    } else {

        return( TRUE );
    }

}


BOOL
OpenToken(
    PHANDLE TokenHandle
    )
{
    HANDLE Process;
    BOOL Result;

    Process = OpenProcess(
                PROCESS_QUERY_INFORMATION,
                FALSE,
                GetCurrentProcessId()
                );

    if ( Process == NULL ) {

        //
        // This can happen, but is unlikely.
        //

        return( FALSE );
    }


    Result = OpenProcessToken (
                 Process,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 TokenHandle
                 );

    CloseHandle( Process );

    if ( !Result ) {

        //
        // This can happen, but is unlikely.
        //

        return( FALSE );

    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\config16.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    config16.c

Abstract:

    Remove Far East 16bit drivers from config.nt.

Author:

    Geoffrey Guo (geoffguo) 30-Jul-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#include "StdAfx.h"
#include "clmt.h"

char *szFEDrivers[] = {"ntfont.sys", "font_win.sys", "$disp.sys",
                       "disp_win.sys", "kkcfunc.sys", "MSIMEK.SYS",
                       "MSIMEI.SYS", "\0"};

BOOL 
Remove16bitFEDrivers(void)
{
    BOOL    bRet = FALSE;
    HRESULT hr;
    FILE   *pInFile, *pOutFile;
    DWORD   i;
    TCHAR   szFileIn[MAX_PATH];
    TCHAR   szFileOut[MAX_PATH];
    char    szInBuf[MAX_PATH];
    char    szOutBuf[MAX_PATH];

    DPF(SHLmsg, L"Enter Remove16bitFEDrivers: ");

    if (!GetEnvironmentVariable(TEXT("windir"), szFileIn, MAX_PATH))
        goto Exit;

    if ( (hr = StringCchCopy(szFileOut, MAX_PATH, szFileIn)) != S_OK)
        goto Exit;
    if ((hr = StringCchCat(szFileIn, MAX_PATH, TEXT("\\system32\\config.nt"))) != S_OK)
        goto Exit;

    if ((pInFile = _wfopen(szFileIn, TEXT("r"))) == NULL)
        goto Exit;

    if ((hr = StringCchCat(szFileOut, MAX_PATH, TEXT("\\system32\\config.clm"))) != S_OK)
    {
        fclose(pInFile);
        goto Exit;
    }
    if ((pOutFile = _wfopen(szFileOut, TEXT("w"))) == NULL)
    {
        fclose(pInFile);
        goto Exit;
    }

    while (fgets(szInBuf, MAX_PATH-1, pInFile))
    {
        i = 0;
        szOutBuf[0] = (char)'\0';
        while (*(szFEDrivers[i]) != (char)'\0')
        {
            if (StrStrIA((char*)szInBuf, szFEDrivers[i]))
            {
                if ((hr = StringCchCopyA(szOutBuf, MAX_PATH, "REM ")) != S_OK)
                    goto Exit1;
                if ((hr = StringCchCatA(szOutBuf, MAX_PATH, szInBuf)) != S_OK)
                    goto Exit1;
                break;
            }
            i++;
        }
        if (szOutBuf[0] == (char)'\0')
        {
            if ((hr = StringCchCopyA(szOutBuf, MAX_PATH, szInBuf)) != S_OK)
                goto Exit1;
        }
        
        fputs (szOutBuf, pOutFile);
    }

    bRet = TRUE;
Exit1:
    fclose(pOutFile);
    fclose(pInFile);
    if (bRet)
    {
        CopyFile(szFileOut, szFileIn, FALSE);
        DPF(SHLmsg, L"Exit Remove16bitFEDrivers:");
    }
    else
        DPF(SHLerr, L"Remove16bitFEDrivers: failed");

    DeleteFile(szFileOut);

Exit:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\clmt.h ===
/****************************** Module Header ******************************\
* Module Name: clmt.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Cross Language Migration Tool, main header file
*
\***************************************************************************/
#ifndef CLMT_H
#define CLMT_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <userenv.h>
#include <userenvp.h>
#include <setupapi.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <string.h>
#include <Sddl.h>
#include <assert.h>
#include <tchar.h>
#include <lm.h>
#include <resource.h>
#include <locale.h>
#include <iadmw.h>
#include <sfcapip.h>
#include <Aclapi.h>
#include <aclui.h>
#ifndef NOT_USE_SAFE_STRING
    #define STRSAFE_LIB
    #include <strsafe.h>
#endif


typedef struct _REG_STRING_REPLACE {
DWORD   nNumOfElem;
DWORD   cchUserName;
LPTSTR  szUserNameLst;
DWORD   cchSearchString;
LPTSTR  lpSearchString;          //Orignal Multi-String
DWORD   cchReplaceString;
LPTSTR  lpReplaceString;         //Replaced Multi-String
DWORD   cchAttribList;   //String Attribute
LPDWORD lpAttrib;                //String Attribute
DWORD   cchFullStringList;
LPTSTR  lpFullStringList;
DWORD   cchMaxStrLen;             //Max String Length in search and replac strings
} REG_STRING_REPLACE, *PREG_STRING_REPLACE;

typedef struct value_list {
    VALENT             ve;
    METADATA_RECORD    md;
    LPTSTR             lpPre_valuename;
    DWORD              val_type;
    DWORD              val_attrib;
    struct value_list *pvl_next;
} VALLIST, *PVALLIST;

typedef struct str_list {
    LPTSTR  lpstr;
    struct str_list *pst_prev;
    struct str_list *pst_next;
} STRLIST, *PSTRLIST;


//struc used for folder renaming
typedef struct {
    int id;                    // CSIDL_ value
    LPCTSTR pszIdInString;
    int idsDefault;             // string id of default folder name name
    LPCTSTR pszValueName;       // reg key (not localized)
} FOLDER_INFO;

typedef struct _PROFILE {
    DWORD       dwFlags;
    DWORD       dwInternalFlags;
    DWORD       dwUserPreference;
    HANDLE      hTokenUser;
    HANDLE      hTokenClient;
    LPTSTR      lpUserName;
    LPTSTR      lpProfilePath;
    LPTSTR      lpRoamingProfile;
    LPTSTR      lpDefaultProfile;
    LPTSTR      lpLocalProfile;
    LPTSTR      lpPolicyPath;
    LPTSTR      lpServerName;
    HKEY        hKeyCurrentUser;
    FILETIME    ftProfileLoad;
    FILETIME    ftProfileUnload;
    LPTSTR      lpExclusionList;
} USERPROFILE, *LPPROFILE;


// Structure of translation table to map <root key string> to <HKEY value>
typedef struct _STRING_TO_DATA {
    TCHAR  String[MAX_PATH];
    HKEY   Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

typedef struct _DENIED_ACE_LIST {
    DWORD                    dwAclSize;
    ACCESS_DENIED_ACE       *pace;
    LPTSTR                   lpObjectName;
    struct _DENIED_ACE_LIST *previous;
    struct _DENIED_ACE_LIST *next;
} DENIED_ACE_LIST, *LPDENIED_ACE_LIST;

//our main version is 1.0 and then followed by build number(Major/Minor)
//used in res.rc
#define VER_FILEVERSION             1,0,50,01
#define VER_FILEVERSION_STR         "1.0.0050.1"

//used in INF file to specify the file/folder move type
#define TYPE_DIR_MOVE               0  //move a folder
#define TYPE_FILE_MOVE              1  //move a file
#define TYPE_SFPFILE_MOVE           2  //move a file which is system protected

//used in INF file to specify registry rename type 
#define TYPE_VALUE_RENAME           0  //rename registry data renaming
#define TYPE_VALUENAME_RENAME       1  //rename registry name renaming
#define TYPE_KEY_RENAME             2  //rename registry key renaming
#define TYPE_SERVICE_MOVE           3  //rename a service name

//our inf file name
#define CLMTINFFILE                  TEXT("clmt.inf")
//section name in the inf file listed user/group account we need to rename
#define USERGRPSECTION               TEXT("UserGrp.ObjectRename")

//string buffer size for multisz string 
#define MULTI_SZ_BUF_DELTA 3*1024
#define DWORD_BUF_DELTA 1024

//following are section (or part of) constants
#define SHELL_FOLDER_PREFIX                 TEXT("ShellFolder.")
#define SHELL_FOLDER_REGISTRY               TEXT("Registry")
#define SHELL_FOLDER_FOLDER                 TEXT("Folder")
#define SHELL_FOLDER_LONGPATH_TEMPLATE      TEXT("LongPathNameTemplate")
#define SHELL_FOLDER_SHORTPATH_TEMPLATE     TEXT("ShortPathNameTemplate")


// registry value name for 
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList
#define PROFILES_DIRECTORY                  TEXT("ProfilesDirectory")


#define  DEFAULT_USER                       TEXT("Default User") 

//out backup direcory name(located in %windir%\$CLMT_BACKUP$
//used for saving files that we need to delete and also the INF file
#define CLMT_BACKUP_DIR                      TEXT("$CLMT_BACKUP$")

//registry key for we created for saving our tools running status 
//it's  in HKEY_LOCAL_MACHINE\SYSTEM\System\CrossLanguageMigration
#define CLMT_REGROOT         TEXT("System\\CrossLanguageMigration")
#define CLMT_RUNNING_STATUS  TEXT("InProgress")
#define CLMT_OriginalInstallLocale  TEXT("OriginalInstallLocale")

//Flag used to specify what the current running status
#define CLMT_DOMIG                 0x01  // we are doing migration
#define CLMT_UNDO_PROGRAM_FILES    0x02  // we are undoing %programfiles% changes
#define CLMT_UNDO_APPLICATION_DATA 0x04  // we are undoing %userprofile%application data  changes
#define CLMT_UNDO_ALL              0x08  // we are undoing what we changed
#define CLMT_CURE_PROGRAM_FILES    0x10  // create symbolic link between english and localized folder 
                                         // for those folder that will affect functionality(eg.%programfiles%)
#define CLMT_REMINDER              0x20  // reminder user to convert to NTFS....
#define CLMT_CLEANUP_AFTER_UPGRADE 0x40  // cleaning up the machine after upgrade to .NET
#define CLMT_CURE_ALL              0x80  // create symbolic link between english and localized folder for all folders we changed
#define CLMT_CURE_AND_CLEANUP      0x100 // This to enable /CURE and /FINAL to run independently on machine with FAT

#define CLMT_DOMIG_DONE                      (0xFF00 | CLMT_DOMIG)  // migration is done 
#define CLMT_UNDO_PROGRAM_FILES_DONE         (0xFF00 | CLMT_UNDO_PROGRAM_FILES) //undoing %programfiles%
#define CLMT_UNDO_APPLICATION_DATA_DONE      (0xFF00 | CLMT_UNDO_APPLICATION_DATA) //undoing %userprofile%application data is done
#define CLMT_UNDO_ALL_DONE                   (0xFF00 | CLMT_UNDO_ALL)//undoing what we changed is done

// Constants used to keep track of machine state
#define CLMT_STATE_ORIGINAL                     1       // Original Win2K machine
#define CLMT_STATE_PROGRAMFILES_UNDONE          10      // CLMT'ed machine is undone the program files operation
#define CLMT_STATE_APPDATA_UNDONE               11      // CLMT'ed machine is undone the application data operation
#define CLMT_STATE_MIGRATION_DONE               100     // Machine has been CLMT'ed
#define CLMT_STATE_UPGRADE_DONE                 200     // CLMT'ed machine has been Upgraded to .NET
#define CLMT_STATE_PROGRAMFILES_CURED           400     // Machine has been CLMT'ed and Hardlink is created
#define CLMT_STATE_FINISH                       800     // .NET machine has been cleaned up by CLMT

// Constants used to identify status of CLM tool
#define CLMT_STATUS_ANALYZING_SYSTEM            0
#define CLMT_STATUS_MODIFYING_SYSTEM            1

// Constants used by lstrXXX functions
#define LSTR_EQUAL          0

// Calcalate array size (in number of elements)
#define ARRAYSIZE(s)    (sizeof(s) / (sizeof(s[0])))

// Macro used by CompareString() API
#define LOCALE_ENGLISH  MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

// Macros for heap memory management
#define MEMALLOC(cb)        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define MEMFREE(pv)         HeapFree(GetProcessHeap(), 0, pv);
#define MEMREALLOC(pv, cb)  HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pv, cb)

// Locale ID constants
#define LCID_SWEDISH              0x041d 
#define LCID_PORTUGUESE_BRAZILIAN 0x0416
#define LCID_PORTUGUESE_STANDARD  0x0816
#define LCID_HUNGARIAN            0x040e 
#define LCID_CZECH                0x0405
#define LCID_TURKISH              0x041f

//Private CSIDL used in shell folder renaming
#define CSIDL_LOCAL_SETTINGS                                    0x7f
#define CSIDL_COMMON_ACCESSORIES                                0x7e
#define CSIDL_ACCESSORIES                                       0x7d
#define CSIDL_USER_PROFILE                                      0x7c
#define CSIDL_PROFILES_DIRECTORY                                0x7b
#define CSIDL_PF_ACCESSORIES                                    0x7a
#define CSIDL_COMMON_ACCESSORIES_ACCESSIBILITY                  0x79
#define CSIDL_COMMON_ACCESSORIES_ENTERTAINMENT                  0x78 
#define CSIDL_COMMON_ACCESSORIES_SYSTEM_TOOLS                   0x77
#define CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS                 0x76 
#define CSIDL_COMMON_ACCESSORIES_MS_SCRIPT_DEBUGGER             0x75
#define CSIDL_COMMON_WINDOWSMEDIA                               0x74
#define CSIDL_COMMON_COVERPAGES                                 0x73
#define CSIDL_COMMON_RECEIVED_FAX                               0x72 
#define CSIDL_COMMON_SENT_FAX                                   0x71
#define CSIDL_COMMON_FAX                                        0x70 
#define CSIDL_FAVORITES_LINKS                                   0x6e 
#define CSIDL_FAVORITES_MEDIA                                   0x6d
#define CSIDL_ACCESSORIES_ACCESSIBILITY                         0x6c 
#define CSIDL_ACCESSORIES_SYSTEM_TOOLS                          0x6b
#define CSIDL_ACCESSORIES_ENTERTAINMENT                         0x6a
#define CSIDL_ACCESSORIES_COMMUNICATIONS                        0x69
#define CSIDL_ACCESSORIES_COMMUNICATIONS_HYPERTERMINAL          0x68
#define CSIDL_COMMON_ACCESSORIES_GAMES                          0x67
#define CSIDL_QUICKLAUNCH                                       0x66
#define CSIDL_COMMON_COMMONPROGRAMFILES_SERVICES                0x65
#define CSIDL_COMMON_PROGRAMFILES_ACCESSARIES                   0x64
#define CSIDL_COMMON_PROGRAMFILES_WINNT_ACCESSARIES             0x63
#define CSIDL_USERNAME_IN_USERPROFILE                           0x62
#define CSIDL_UAM_VOLUME                                        0x61
#define CSIDL_COMMON_SHAREDTOOLS_STATIONERY                     0x60
#define CSIDL_NETMEETING_RECEIVED_FILES                         0x5f
#define CSIDL_COMMON_NETMEETING_RECEIVED_FILES                  0x5e
#define CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS_FAX             0x5d
#define CSIDL_FAX_PERSONAL_COVER_PAGES                          0x5c
#define CSIDL_FAX                                               0x5b



#define USER_SHELL_FOLDER         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define c_szDot                   TEXT(".")
#define c_szDotDot                TEXT("..")
#define c_szStarDotStar           TEXT("*.*")
#define TEXT_WINSTATION_KEY       TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations")
#define TEXT_RUN_KEY              TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")
#define TEXT_CLMT_RUN_VALUE       TEXT("CLMT")


//Type specify registr change used in regfind.c and ReplaceValueSettings in utils.c
#define REG_CHANGE_VALUENAME        1
#define REG_CHANGE_VALUEDATA        2
#define REG_CHANGE_KEYNAME          4

#define MAXDOMAINLENGTH             MAX_PATH

#define  CONSTANT_REG_VALUE_DATA_RENAME     0  //indicates Registry Value Data Rename
#define  CONSTANT_REG_VALUE_NAME_RENAME     1  //indicates Registry Value Name Rename
#define  CONSTANT_REG_KEY_RENAME            2  //indicates Registry Key Rename

#define REG_PERSYS_UPDATE                   TEXT("REG.Update.Sys")
#define REG_PERUSER_UPDATE_PREFIX TEXT("REG.Update.")

#define APPLICATION_DATA_METABASE   TEXT("$MetaBase")

#define PROFILE_PATH_READ                          0
#define PROFILE_PATH_WRITE                         1 


#define DS_OBJ_PROPERTY_UPDATE TEXT("DS_OBJ_PROPERTY_UPDATE")

#define FOLDER_CREATE_HARDLINK TEXT("Folder.HardLink")
#define FOLDER_UPDATE_HARDLINK TEXT("Folder.HardLink.UPDATE")

#define TEXT_SERVICE_STATUS_SECTION             TEXT("Services.ConfigureStatus")
#define TEXT_SERVICE_STATUS_CLEANUP_SECTION     TEXT("Services.ConfigureStatus.Cleanup")
#define TEXT_SERVICE_STARTUP_SECTION            TEXT("Services.ConfigureStartupType")
#define TEXT_SERVICE_STARTUP_CLEANUP_SECTION    TEXT("Services.ConfigureStartupType.Cleanup")

#ifdef __cplusplus
extern "C" {
#endif

//global variables declartion, see detail in globals.c
extern HINSTANCE                ghInst;
extern TCHAR                    g_szToDoINFFileName[MAX_PATH];
extern DWORD                    g_dwKeyIndex;
extern HINF                     g_hInfDoItem;
extern FOLDER_INFO              c_rgFolderInfo[];
extern REG_STRING_REPLACE       g_StrReplaceTable,g_StrReplaceTablePerUser;
extern BOOL                     g_bBeforeMig;
extern DWORD                    g_dwRunningStatus;
extern BOOL                     g_fRunWinnt32;
extern BOOL                     g_fNoAppChk;
extern BOOL                     g_fUseInf;
extern TCHAR                    g_szInfFile[MAX_PATH];
extern HINF                     g_hInf;
extern HANDLE                   g_hMutex;
extern HANDLE                   g_hInstance ;
extern HANDLE                   g_hInstDll;
extern TCHAR                    g_szChangeLog[MAX_PATH];
extern DWORD                    g_dwIndex;
extern LPDENIED_ACE_LIST        g_DeniedACEList;


//BUGBUG xiaoz
static TCHAR g_cszProfileImagePath[]      = TEXT("ProfileImagePath");
static TCHAR g_cszProfileList[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList");





//
//From regfind.c
//

HRESULT     RegistryAnalyze(HKEY,LPTSTR,LPTSTR,PREG_STRING_REPLACE,LPTSTR,DWORD,LPTSTR,BOOL);


//
//From iis.cpp
//

HRESULT     MetabaseAnalyze (LPTSTR,PREG_STRING_REPLACE,BOOL);
HRESULT     SetMetabaseValue (LPCTSTR, LPCTSTR, DWORD, LPCTSTR);
HRESULT     BatchUpateIISMetabase(HINF, LPTSTR);
HRESULT     MigrateMetabaseSettings(HINF);

//
//  From Utils.c
//
HRESULT     ConstructUIReplaceStringTable(LPTSTR, LPTSTR,PREG_STRING_REPLACE);
HRESULT     Sz2MultiSZ(IN OUT LPTSTR, IN  TCHAR);
HRESULT     AddHardLinkEntry(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR,LPTSTR);
HRESULT     GetSharePath(LPTSTR, LPTSTR, PDWORD);
HRESULT     FRSUpdate();
HRESULT     Ex2000Update();
LONG        SDBCleanup(OUT LPTSTR, IN DWORD, OUT LPBOOL);
HRESULT     SetProtectedRenamesFlag(BOOL);
HRESULT     DoCriticalWork ();
HRESULT     IsNTFS(IN  LPTSTR, OUT BOOL*);
HRESULT     IsSysVolNTFS(OUT BOOL*);
HRESULT     CreateAdminsSd( PSECURITY_DESCRIPTOR*);
int         MyStrCmpIW(LPCWSTR, LPCWSTR );
int         MyStrCmpIA(LPCSTR, LPCSTR );
#ifdef UNICODE
#define MyStrCmpI  MyStrCmpIW
#else
#define MyStrCmpI  MyStrCmpIA
#endif // !UNICODE

HRESULT     ReconfigureServiceStartType(IN LPCTSTR,IN DWORD,IN DWORD,IN DWORD) ;
HRESULT     AddExtraQuoteEtc(LPTSTR,LPTSTR*);
HRESULT     CopyMyselfTo(LPTSTR);
HRESULT     SetRunOnceValue (IN LPCTSTR,IN LPCTSTR);
HRESULT     SetRunValue(LPCTSTR, LPCTSTR);
HRESULT     LogMachineInfo();
BOOL        StopService(IN LPCTSTR pServiceName,IN DWORD dwMaxWait);
HRESULT     GetSIDFromName(IN LPTSTR,OUT PSID *);
BOOL        ConcatenatePaths (LPTSTR, LPCTSTR, UINT);
UINT        StrToUInt (LPTSTR);
BOOL        INIFile_ChangeSectionName (LPCTSTR, LPCTSTR, LPCTSTR);
BOOL        INIFile_IsSectionExist(LPCTSTR, LPCTSTR);
void        IntToString (DWORD, LPTSTR);
UINT        GetInstallLocale (VOID);
BOOL        IsDirExisting (LPTSTR);
LONG        IsDirExisting2(LPTSTR, PBOOL); 
BOOL        IsFileFolderExisting (LPTSTR);
BOOL        RenameDirectory (LPTSTR, LPTSTR);
HRESULT     UpdateINFFilePerUser(LPCTSTR, LPCTSTR, LPCTSTR, BOOL);
HRESULT     UpdateINFFileSys(LPTSTR);
HRESULT     MyMoveDirectory(LPTSTR,LPTSTR,BOOL,BOOL,BOOL,DWORD);
HRESULT     GetInfFilePath(LPTSTR, SIZE_T);
HRESULT     GetInfFromResource(LPCTSTR);
BOOL        ReplaceString(LPCTSTR, LPCTSTR, LPCTSTR, LPTSTR, size_t, LPCTSTR, LPCTSTR, LPDWORD, BOOL);
BOOL        IsStrInMultiSz(LPCTSTR,LPCTSTR);
BOOL        MultiSzSubStr(LPTSTR,LPTSTR);
DWORD       MultiSzLen(LPCTSTR);
LPCTSTR     MultiSzTok(LPCTSTR);
BOOL        CmpMultiSzi(LPCTSTR,LPCTSTR);
LPTSTR      GetStrInMultiSZ(DWORD, LPCTSTR);
DWORD       StrNumInMultiSZ(LPCTSTR, LPCTSTR);
HRESULT     GetSetUserProfilePath(LPCTSTR,LPTSTR,size_t,UINT,UINT);
void        ReStartSystem(UINT);
int         DoMessageBox(HWND, UINT, UINT, UINT);
HRESULT     StringMultipleReplacement(LPCTSTR,LPCTSTR,LPCTSTR,LPTSTR,size_t);
BOOL        Str2KeyPath(LPTSTR,PHKEY,LPTSTR*);
BOOL        HKey2Str(HKEY, LPTSTR,size_t);
HRESULT     MyMoveFile(LPCTSTR, LPCTSTR, BOOL, BOOL);
BOOL        AppendSzToMultiSz(IN LPCTSTR,IN OUT LPTSTR *,IN OUT PDWORD);
BOOL        AddItemToStrRepaceTable(LPTSTR,LPTSTR,LPTSTR,LPTSTR,DWORD,PREG_STRING_REPLACE);
void        PrintMultiSz(LPTSTR);
BOOL        StringValidationCheck(LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, LPDWORD, DWORD);
BOOL        ReverseStrCmp(LPCTSTR, LPCTSTR);
BOOL        ReplaceMultiMatchInString(LPTSTR, LPTSTR, size_t, DWORD, PREG_STRING_REPLACE, LPDWORD, BOOL);
BOOL        ComputeLocalProfileName(LPCTSTR, LPCTSTR, LPTSTR, size_t, UINT);
void        UpdateProgress();
BOOL        IsAdmin();
HRESULT     ReplaceValueSettings (LPTSTR, LPTSTR, DWORD, LPTSTR, DWORD, PREG_STRING_REPLACE, PVALLIST*, LPTSTR, BOOL);
LPTSTR      ReplaceSingleString (LPTSTR, DWORD, PREG_STRING_REPLACE, LPTSTR, LPDWORD, BOOL);
DWORD       AddNodeToList (PVALLIST, PVALLIST*);
DWORD       RemoveValueList (PVALLIST*);
DWORD       GetMaxStrLen (PREG_STRING_REPLACE);
BOOL        DoesUserHavePrivilege(PTSTR);
BOOL        EnablePrivilege(PTSTR,BOOL);
BOOL        UnProtectSFPFiles(LPTSTR,LPDWORD);
HRESULT     MyGetShortPathName(LPCTSTR,LPCTSTR,LPCTSTR,LPTSTR,DWORD);
BOOL        Str2KeyPath2(LPCTSTR, PHKEY, LPCTSTR*);
DWORD       Str2REG(LPCTSTR);
BOOL        GetBackupDir(LPCTSTR,LPTSTR, size_t,BOOL);
HRESULT     ReplaceCurrentControlSet(LPTSTR);
HRESULT     AddRegKeyRename(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
HRESULT     AddRegValueRename(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, DWORD, DWORD, LPTSTR);
HRESULT     AddFolderRename(LPTSTR, LPTSTR,DWORD, LPTSTR);
DWORD       GetMaxMatchNum (LPTSTR,PREG_STRING_REPLACE);
HRESULT     InfGenerateStringsSection(LPCTSTR, LPTSTR, SIZE_T);
HRESULT     InfCopySectionWithPrefix(LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR);
HRESULT     MultiSZ2String(IN LPTSTR, IN  TCHAR,OUT LPTSTR *);
DWORD       MultiSZNumOfString(IN  LPTSTR );
void        FreePointer(void *);
HRESULT     GetCLMTStatus(PDWORD pdwRunStatus);
HRESULT     SetCLMTStatus(DWORD dwRunStatus);
HRESULT     GetSavedInstallLocale(LCID *plcid);
HRESULT     SaveInstallLocale(void);
HRESULT     MultiSZ2String(IN LPTSTR, IN TCHAR,OUT LPTSTR *);
DWORD       MultiSZNumOfString(IN LPTSTR );
void        BoostMyPriority(void);
HRESULT     SetInstallLocale(LCID);
HRESULT     MyCreateHardLink(LPCTSTR, LPCTSTR);
BOOL        CreateSymbolicLink(LPTSTR,LPTSTR,BOOL);
BOOL        GetSymbolicLink(LPTSTR, LPTSTR, DWORD);

HRESULT     MergeDirectory(LPCTSTR, LPCTSTR);
BOOL CALLBACK DoCriticalDlgProc(HWND, UINT, WPARAM, LPARAM);
HRESULT     RenameRegRoot (LPCTSTR, LPTSTR, DWORD, LPCTSTR, LPCTSTR);
DWORD       AdjustRegSecurity (HKEY, LPCTSTR, LPCTSTR, BOOL);
HRESULT     GetFirstNTFSDrive(LPTSTR, DWORD);
HRESULT     DuplicateString(LPTSTR *, LPDWORD, LPCTSTR);
HRESULT     DeleteDirectory(LPCTSTR);
HRESULT     MyDeleteFile(LPCTSTR);
HRESULT     GetDCInfo(PBOOL, LPTSTR, PDWORD);
VOID        RemoveSubString(LPTSTR, LPCTSTR);




//
//utils2.cpp
//
BOOL        IsServiceRunning(LPCTSTR);
HRESULT     AddNeedUpdateLnkFile(LPTSTR, PREG_STRING_REPLACE);
HRESULT     UpdateSecurityTemplates(LPTSTR, PREG_STRING_REPLACE);
HRESULT     BatchFixPathInLink(HINF hInf,LPTSTR lpszSection);
HRESULT     RenameRDN(LPTSTR, LPTSTR, LPTSTR);
HRESULT     PropertyValueHelper(LPTSTR, LPTSTR, LPTSTR*, LPTSTR);
HRESULT     BatchINFUpdate(HINF);

//
//From table.c
//
BOOL        InitStrRepaceTable(void);
void        DeInitStrRepaceTable(void);

//
// From loopuser.c
//
#ifdef STRICT
typedef HRESULT (CALLBACK *USERENUMPROC)(HKEY,LPTSTR,LPTSTR,LPTSTR);
#else // !STRICT
typedef FARPROC USERENUMPROC;
#endif // !STRICT

BOOL        LoopUser(USERENUMPROC);


//
// From user.c
//
#ifdef STRICT
typedef HRESULT (CALLBACK *PROFILEENUMPROC)(LPCTSTR, LPCTSTR);
#else // !STRICT
typedef FARPROC PROFILEENUMPROC;
#endif // !STRICT

HRESULT EnumUserProfile(PROFILEENUMPROC);
HRESULT AnalyzeMiscProfilePathPerUser(LPCTSTR, LPCTSTR);
HRESULT ResetMiscProfilePathPerUser(LPCTSTR, LPCTSTR);
LPTSTR  ReplaceLocStringInPath(LPCTSTR, BOOL);
HRESULT GetFQDN(LPTSTR, LPTSTR, LPTSTR *);


//
//  From inf.c
//
HRESULT     UpdateDSObjProp(HINF, LPTSTR);
HRESULT     FinalUpdateRegForUser(HKEY, LPTSTR, LPTSTR, LPTSTR);
HRESULT     UpdateRegPerUser(HKEY, LPTSTR, LPTSTR,LPTSTR);
BOOL        LnkFileUpdate(LPTSTR);
BOOL        SecTempUpdate(LPTSTR);
HRESULT     StopServices(HINF);
HRESULT     RegUpdate(HINF hInf, HKEY hKey , LPTSTR lpszUsersid);
BOOL        LookUpStringInTable(PSTRING_TO_DATA, LPCTSTR, PHKEY);
HRESULT     UsrGrpAndDoc_and_SettingsRename(HINF,BOOL);
HRESULT     EnsureDoItemInfFile(LPTSTR,size_t);
HRESULT     INFCreateHardLink(HINF,LPTSTR,BOOL);
HRESULT     FolderMove(HINF, LPTSTR,BOOL);
HRESULT     ResetServiceStatus(LPCTSTR, DWORD, DWORD);
HRESULT     AnalyzeServicesStartUp(HINF, LPCTSTR);
HRESULT     AnalyzeServicesStatus(HINF, LPCTSTR);
HRESULT     ResetServicesStatus(HINF, LPCTSTR);
HRESULT     ResetServicesStartUp(HINF, LPCTSTR);
VOID        DoServicesAnalyze();
HRESULT     INFVerifyHardLink(HINF,LPTSTR);



//
//From DLL.C
//
BOOL        DoMigPerSystem (VOID);
HRESULT     MigrateShellPerUser(HKEY, LPCTSTR, LPCTSTR,LPTSTR);
LONG        DoMig(DWORD);
BOOL        InitGlobals(DWORD);


//
//From Registry.C
//
LONG        MyRegSetDWValue(HKEY, LPCTSTR, LPCTSTR, LPCTSTR);
LONG        RegResetValue(HKEY, LPCTSTR, LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD, LPCTSTR);
LONG        RegResetValueName(HKEY, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR);
LONG        RegResetKeyName(HKEY, LPCTSTR, LPCTSTR, LPCTSTR);
LONG        RegGetValue(HKEY,LPTSTR,LPTSTR,LPDWORD,LPBYTE,LPDWORD);
LONG        RegRenameValueName(HKEY, LPCTSTR, LPCTSTR);
LONG        SetRegistryValue(HKEY, LPCTSTR, LPCTSTR, DWORD, LPBYTE, DWORD);
LONG        GetRegistryValue(HKEY, LPCTSTR, LPCTSTR, LPBYTE, LPDWORD);
HRESULT     MigrateRegSchemesPerSystem(HINF);
HRESULT     MigrateRegSchemesPerUser(HKEY, LPCTSTR, LPCTSTR, LPCTSTR);
LONG        My_QueryValueEx(HKEY, LPCTSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
HRESULT     SetSectionName (LPTSTR, LPTSTR *);
HRESULT     ReadFieldFromContext(PINFCONTEXT, LPWSTR[], DWORD, DWORD);


//
//From enumfile.c
//
typedef     FARPROC     ENUMPROC;

#ifdef STRICT
typedef BOOL (CALLBACK *FILEENUMPROC)(LPTSTR);
#else // !STRICT
typedef FARPROC FILEENUMPROC;
#endif // !STRICT

BOOL        MyEnumFiles(LPTSTR, LPTSTR, FILEENUMPROC);

//
//for log.c
//
typedef enum 
{    
    dlNone     = 0,
    dlPrint,
    dlFail,
    dlError,
    dlWarning,
    dlInfo

} DEBUGLEVEL;

typedef struct _LOG_REPORT
{
    DWORD    dwMsgNum;
    DWORD    dwFailNum;
    DWORD    dwErrNum;
    DWORD    dwWarNum;
    DWORD    dwInfNum;
} LOG_REPORT;

#define DEBUG_SPEW

extern FILE *pLogFile;
extern LOG_REPORT g_LogReport;

//define debug area
#define DEBUG_ALL                  0x0
#define DEBUG_APPLICATION          0x10
#define DEBUG_REGISTRY             0x20
#define DEBUG_SHELL                0x30
#define DEBUG_PROFILE              0x40
#define DEBUG_INF_FILE             0x80

#define APPmsg  (DEBUG_APPLICATION | dlPrint)
#define APPfail (DEBUG_APPLICATION | dlFail)
#define APPerr  (DEBUG_APPLICATION | dlError)
#define APPwar  (DEBUG_APPLICATION | dlWarning)
#define APPinf  (DEBUG_APPLICATION | dlInfo)
#define REGmsg  (DEBUG_REGISTRY | dlPrint)
#define REGfail (DEBUG_REGISTRY | dlFail)
#define REGerr  (DEBUG_REGISTRY | dlError)
#define REGwar  (DEBUG_REGISTRY | dlWarning)
#define REGinf  (DEBUG_REGISTRY | dlInfo)
#define SHLmsg  (DEBUG_SHELL | dlPrint)
#define SHLfail (DEBUG_SHELL | dlFail)
#define SHLerr  (DEBUG_SHELL | dlError)
#define SHLwar  (DEBUG_SHELL | dlWarning)
#define SHLinf  (DEBUG_SHELL | dlInfo)
#define PROmsg  (DEBUG_PROFILE | dlPrint)
#define PROfail  (DEBUG_PROFILE | dlFail)
#define PROerr  (DEBUG_PROFILE | dlError)
#define PROwar  (DEBUG_PROFILE | dlWarning)
#define PROinf  (DEBUG_PROFILE | dlInfo)
#define INFmsg  (DEBUG_INF_FILE | dlPrint)
#define INFfail  (DEBUG_INF_FILE | dlFail)
#define INFerr  (DEBUG_INF_FILE | dlError)
#define INFwar  (DEBUG_INF_FILE | dlWarning)
#define INFinf  (DEBUG_INF_FILE | dlInfo)

#define DPF DebugPrintfEx
#define LOG_FILE_NAME              TEXT("\\debug\\clmt.log")

void    DebugPrintfEx(DWORD dwDetail, LPWSTR pszFmt, ...);
HRESULT InitDebugSupport(DWORD);
void    CloseDebug(void);
HRESULT InitChangeLog(VOID);
HRESULT AddFileChangeLog(DWORD, LPCTSTR, LPCTSTR);
HRESULT AddServiceChangeLog(LPCTSTR, DWORD, DWORD);
HRESULT AddUserNameChangeLog(LPCTSTR, LPCTSTR);
BOOL    GetUserNameChangeLog(LPCTSTR, LPTSTR, DWORD);


//
// From shell.c
//

HRESULT     DoShellFolderRename(HINF, HKEY, LPTSTR);
HRESULT     FixFolderPath(INT, HKEY ,HINF, LPTSTR, BOOL );


//
// From criteria.c
//
BOOL        CheckSystemCriteria(VOID);
HRESULT     CheckCLMTStatus(LPDWORD, LPDWORD, PUINT);
HRESULT     CLMTGetMachineState(LPDWORD);
HRESULT     CLMTSetMachineState(DWORD);
BOOL        IsNT5(VOID);
BOOL        IsDotNet(VOID);
BOOL        IsNEC98(VOID);
BOOL        IsIA64(VOID);
BOOL        IsDomainController(VOID);
BOOL        IsOnTSClient(VOID);
BOOL        IsTSInstalled(VOID);
BOOL        IsTSConnectionEnabled(VOID);
BOOL        IsTSServiceRunning(VOID);
BOOL        IsOtherSessionOnTS(VOID);
BOOL        IsUserOKWithCheckUpgrade(VOID);
HRESULT     DisableWinstations(DWORD, LPDWORD);
BOOL        DisplayTaskList();
INT         ShowStartUpDialog();
BOOL        IsOneInstance(VOID);
BOOL        CheckAdminPrivilege(VOID);
VOID        ShowReadMe();

//
// From aclmgmt.cpp
//
DWORD AdjustObjectSecurity (LPTSTR, SE_OBJECT_TYPE, BOOL);
HRESULT IsObjectAccessiablebyLocalSys(
    LPTSTR          lpObjectName,
    SE_OBJECT_TYPE  ObjectType,
    PBOOL           pbCanAccess);


//
// From outlook.cpp
//
HRESULT UpdatePSTpath(HKEY, LPTSTR, LPTSTR, LPTSTR, PREG_STRING_REPLACE);

//
// From config16.c
//
BOOL Remove16bitFEDrivers(void);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\globals.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    globals.c

Abstract:

    global variables declaretion

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/


#include "StdAfx.h"
#include "clmt.h"

//Globla instance used mainly to load resource(eg LoadString...)
HANDLE  g_hInstance = NULL;

//Flag specifies whether we are running in win2k, or after running after OS upgarded
BOOL    g_bBeforeMig;

//Flag specifies whether we are in normal run mode or undo mode
DWORD    g_dwRunningStatus;

//global string search -replacement table
REG_STRING_REPLACE g_StrReplaceTable;

//current equals g_hInstance, for future use when we convert to DLL 
HANDLE  g_hInstDll;

//global flag to bypass running Winnt32.exe with Checkupgrade option
BOOL g_fRunWinnt32 = TRUE;

//global flag to bypass app check option
BOOL g_fNoAppChk = FALSE;

//global variable for log report
LOG_REPORT g_LogReport;

TCHAR  g_szToDoINFFileName[MAX_PATH];
TCHAR  g_szUoDoINFFileName[MAX_PATH];
DWORD  g_dwKeyIndex=0;

// Undocumented flag to bypass internal INF, and use user-supply INF file
BOOL  g_fUseInf = FALSE;
TCHAR g_szInfFile[MAX_PATH];
HINF  g_hInf = INVALID_HANDLE_VALUE;
HANDLE  g_hMutex = NULL;
HINF   g_hInfDoItem;

// Handle to the Change log file
TCHAR g_szChangeLog[MAX_PATH];
DWORD g_dwIndex;

// Denied ACE List
LPDENIED_ACE_LIST g_DeniedACEList = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\aclmgmt.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    aclmgmt.cpp

Abstract:

    Routines to manage access control lists

    Geoffrey Guo (geoffguo) 26-Apr-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#include "clmt.h"
#define STRSAFE_LIB
#include <strsafe.h>

DWORD ChangeOwner (
LPTSTR         lpObjectName,
SE_OBJECT_TYPE ObjectType)
{
    DWORD dwRet = ERROR_SUCCESS;
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION;

    if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		                         SECURITY_BUILTIN_DOMAIN_RID,
		                         DOMAIN_ALIAS_RID_ADMINS,
		                         0, 0, 0, 0, 0, 0,
		                         &psidAdministrators))
    {
        dwRet = GetLastError();
        goto Exit;
    }

    EnablePrivilege(SE_TAKE_OWNERSHIP_NAME,TRUE);
    si |= SI_OWNER_RECURSE;

    dwRet = SetNamedSecurityInfo(lpObjectName,
                                 ObjectType,
                                 si,
                                 psidAdministrators,
                                 NULL,
                                 NULL,
                                 NULL);

    EnablePrivilege(SE_TAKE_OWNERSHIP_NAME,FALSE);
    FreeSid(psidAdministrators);

Exit:
    return dwRet;
}

//-----------------------------------------------------------------------//
//
// CopyACL: Copy ACL
//
// OldACL: Pointer to source Access Control List
// NewACL: Pointer to destination Access Control List
//-----------------------------------------------------------------------//
DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL)
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------//
//
// AddAccessAllowedACEToACL: Add Administrator Allowed ACE to ACL
//
// Acl:            Pointer to Access Control List
// PermissionMask: Permission will be set for new ACE
//-----------------------------------------------------------------------//
DWORD
AddAccessAllowedACEToACL (
    PACL  *Acl,
    DWORD  PermissionMask)
{
    ACL_SIZE_INFORMATION     aclSizeInfo;
    int                      aclSize;
    DWORD                    dwRet = ERROR_SUCCESS;
    USHORT                   AceSize;
    PSID                     psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PACL                     oldACL, newACL;
    ACCESS_ALLOWED_ACE      *pAllowedAce;
    

    oldACL = *Acl;

    if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		                         SECURITY_BUILTIN_DOMAIN_RID,
		                         DOMAIN_ALIAS_RID_ADMINS,
		                         0, 0, 0, 0, 0, 0,
		                         &psidAdministrators))
    {
        dwRet = GetLastError();
        goto Exit;
    }

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (psidAdministrators) - sizeof (DWORD);

    newACL = (PACL) calloc(aclSize, 1);

    if (!newACL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit1;
    }

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        dwRet = GetLastError();
        free (newACL);
        goto Exit1;
    }

    dwRet = CopyACL (oldACL, newACL);
    if (dwRet != ERROR_SUCCESS)
    {
        free (newACL);
        goto Exit1;
    }

    AceSize = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + (USHORT)GetLengthSid(psidAdministrators);
    pAllowedAce = (ACCESS_ALLOWED_ACE *)calloc(AceSize, 1);
    if (!(pAllowedAce))
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit1;
    }

    pAllowedAce->Header.AceFlags = 0;
    pAllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAllowedAce->Header.AceSize = AceSize;
    pAllowedAce->Mask = PermissionMask;
    CopySid(GetLengthSid(psidAdministrators), &(pAllowedAce->SidStart), psidAdministrators);
    if (!AddAce (newACL, ACL_REVISION, 0, pAllowedAce, AceSize))
    {
        dwRet = GetLastError();
        free (newACL);
        goto Exit1;
    }

    *Acl = newACL;

Exit1:
    FreeSid(psidAdministrators);
Exit:
    return dwRet;
}

//-----------------------------------------------------------------------//
//
// RestoreACE: Restore denied ACE
//
// pACE:         Pointer to source Access Control Entry
// lpOnjectName: Pointer to the object name
//-----------------------------------------------------------------------//
DWORD
RestoreACE (
    PACL    *ppAcl,
    LPTSTR  lpObjectName)
{
    DWORD  dwRet = ERROR_INVALID_PARAMETER;
    DWORD  dwLen;
    PACL   newACL;
    LPDENIED_ACE_LIST pList;

    if (!*ppAcl)
        goto Exit;

    pList = g_DeniedACEList;
    if (pList)
    {
        do
        {
            if (lstrcmp(lpObjectName, pList->lpObjectName) == 0)
            {
                newACL = (PACL) calloc(pList->dwAclSize, 1);

                if (!newACL)
                {
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                    goto Exit;
                }

                if (!InitializeAcl (newACL, pList->dwAclSize, ACL_REVISION))
                {
                    free(newACL);
                    dwRet = GetLastError();
                    goto Exit;
                }

                dwRet = CopyACL (*ppAcl, newACL);
                if (dwRet != ERROR_SUCCESS)
                {
                    free(newACL);
                    dwRet = GetLastError();
                    goto Exit;
                }

                if (!AddAce (newACL,
                        ACL_REVISION,
                        0,
                        pList->pace,
                        ((PACE_HEADER)(pList->pace))->AceSize))
                {
                    dwRet = GetLastError();
                    goto Exit;
                }
                else
                    DPF(REGmsg, L"Restore denied ACE to ACL: ObjectName=%s", lpObjectName);

                if (pList->previous)
                    pList->previous->next = pList->next;
                else
                    g_DeniedACEList = pList->next;

                if (pList->next)
                    pList->next->previous = pList->previous;
                *ppAcl = newACL;
                free (pList->lpObjectName);
                free (pList->pace);
                free (pList);
                break;
            }
            pList = pList->next;
        } while (pList->next);
    }
    dwRet = ERROR_SUCCESS;

Exit:
    return dwRet;
}

//-----------------------------------------------------------------------//
//
// RemoveACEFromACL: Remove Administrator ACE from ACL
//
// Acl: Pointer to Access Control List
//-----------------------------------------------------------------------//
DWORD
RemoveACEFromACL (
    PACL   Acl)
{
    ACL_SIZE_INFORMATION     aclSizeInfo;
    ULONG                    i;
    LPVOID                   ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                     psidAdministrators;
    DWORD                    returnValue;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    ACE_HEADER              *aceHeader;

    if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		                         SECURITY_BUILTIN_DOMAIN_RID,
		                         DOMAIN_ALIAS_RID_ADMINS,
		                         0, 0, 0, 0, 0, 0,
		                         &psidAdministrators))
        return GetLastError();

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            FreeSid(psidAdministrators);
            return GetLastError();
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (psidAdministrators, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                FreeSid(psidAdministrators);
                return ERROR_SUCCESS;
            }
        }
    }

    FreeSid(psidAdministrators);
    return ERROR_NO_MORE_ITEMS;
}

//-----------------------------------------------------------------------//
//
// AddACE2List: Add ACE to the list
//
// pACE:         Pointer to source Access Control Entry
// lpOnjectName: Pointer to the object name
//-----------------------------------------------------------------------//
DWORD
AddACE2List (
    ACCESS_DENIED_ACE *pACE,
    LPTSTR             lpObjectName,
    DWORD              dwAclSize)
{
    HRESULT hr;
    DWORD   dwRet = ERROR_SUCCESS;
    DWORD   dwLen;
    LPDENIED_ACE_LIST pList1;
    LPDENIED_ACE_LIST pList2;

    if (!pACE)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    pList1 = (LPDENIED_ACE_LIST)calloc (sizeof(DENIED_ACE_LIST), 1);
    if (!pList1)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    pList1->next = NULL;
    pList1->dwAclSize = dwAclSize;
    pList1->pace = (ACCESS_DENIED_ACE *)calloc(((PACE_HEADER)pACE)->AceSize, 1);
    if (!(pList1->pace))
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        free (pList1);
        goto Exit;
    }
    memcpy (pList1->pace, pACE, ((PACE_HEADER)pACE)->AceSize);
    dwLen = lstrlen(lpObjectName)+1;
    pList1->lpObjectName = (LPTSTR)calloc (dwLen, sizeof(TCHAR));
    if (!(pList1->lpObjectName))
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        free (pList1);
        free (pList1->pace);
        goto Exit;
    }
    hr = StringCchCopy (pList1->lpObjectName, dwLen, lpObjectName);
    if (hr != S_OK)
    {
        dwRet = HRESULT_CODE(hr);
        free (pList1);
        free (pList1->pace);
        goto Exit;
    }

    pList2 = g_DeniedACEList;
    if (pList2)
    {
        while (pList2->next)
            pList2 = pList2->next;

        pList2->next = pList1;
        pList1->previous = pList2;
    }
    else
    {
        g_DeniedACEList = pList1;
        pList1->previous = NULL;
    }

Exit:
    return dwRet;
}

//-----------------------------------------------------------------------//
//
// RemoveDeniedACEFromACL: Remove Denied ACE from ACL
//
// Acl: Pointer to Access Control List
// lpOnjectName: Pointer to the object name
//-----------------------------------------------------------------------//
DWORD
RemoveDeniedACEFromACL (
    PACL   Acl,
    LPTSTR lpObjectName)
{
    ACL_SIZE_INFORMATION     aclSizeInfo;
    ULONG                    i;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    LPVOID                   ace;
    DWORD                    dwRet = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_ITEMS)
                dwRet = ERROR_SUCCESS;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
            AddACE2List (accessDeniedAce, lpObjectName, aclSizeInfo.AclBytesInUse);
            if (!DeleteAce (Acl, i))
                dwRet = GetLastError();
            else
                DPF(REGmsg, L"Remove denied ACE from ACL: ObjectName=%s", lpObjectName);

            break;
        }
    }

    return dwRet;
}

//-----------------------------------------------------------------------//
//
// AdjustObjectSecurity: Add full control ACE for local administrator.
//
// lpObjectName:        Object Name
// ObjectType:          Object Type
// ppOldSidOwner:       Current object owner
// bSetOrRestore:       True --- Add ACE, FALSE --- Remove ACE
//-----------------------------------------------------------------------//
DWORD AdjustObjectSecurity (
LPTSTR         lpObjectName,
SE_OBJECT_TYPE ObjectType,
BOOL           bSetOrRestore)
{
    DWORD                 dwErr;
    HRESULT               hr;
    PSID                  psid = NULL;
    PSECURITY_DESCRIPTOR  pSD;
    PACL                  pDacl = NULL;
    PACL                  psidDacl = NULL;
    SECURITY_INFORMATION  secInfo = DACL_SECURITY_INFORMATION;


    dwErr = GetNamedSecurityInfo(lpObjectName,
                                 ObjectType,
                                 secInfo,
                                 NULL,
                                 NULL,
                                &psidDacl,
                                 NULL,
                                &pSD);

    if (dwErr == ERROR_ACCESS_DENIED)
    {
        TCHAR szString[MAX_PATH*2];
        TCHAR szCaption[MAX_PATH];

        LoadString((HINSTANCE)g_hInstDll, IDS_OWNERSHIP, szCaption, MAX_PATH-1);
        hr = StringCchPrintf(szString, MAX_PATH*2-1, szCaption, lpObjectName);
        LoadString((HINSTANCE)g_hInstDll, IDS_MAIN_TITLE, szCaption, MAX_PATH-1);

        if (SUCCEEDED(hr) && MessageBox(GetConsoleWindow(), szString, szCaption, MB_YESNO) == IDYES)
        {
            if (ChangeOwner(lpObjectName, ObjectType) == ERROR_SUCCESS)
            {
                DPF(REGmsg, L"Administrator takes over the ownership: ObjectName=%s", lpObjectName);
                dwErr = GetNamedSecurityInfo(lpObjectName,
                                 ObjectType,
                                 secInfo,
                                 NULL,
                                 NULL,
                                &psidDacl,
                                 NULL,
                                &pSD);
            }
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {
        pDacl = psidDacl;

        if (bSetOrRestore)
        {
            dwErr = AddAccessAllowedACEToACL (&pDacl, GENERIC_ALL | SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL);
            if (dwErr == ERROR_SUCCESS)
                DPF(REGmsg, L"Add Administrator with full control to ACL: ObjectName=%s", lpObjectName);
            else
                DPF(REGerr, L"Fails to add Administrator with full control to ACL: ObjectName=%s", lpObjectName);
        }
        else
        {
            dwErr = RemoveACEFromACL(pDacl);
            if (dwErr == ERROR_SUCCESS)
                DPF(REGmsg, L"Remove Administrator with full control from ACL: ObjectName=%s", lpObjectName);
            else
                DPF(REGerr, L"Fails to remove Administrator with full control from ACL: ObjectName=%s", lpObjectName);
        }

        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = SetNamedSecurityInfo(lpObjectName,
                                         ObjectType,
                                         secInfo,
                                         NULL,
                                         NULL,
                                         pDacl,
                                         NULL);
        }
        if (psidDacl != pDacl && pDacl)
            free(pDacl);

        LocalFree(pSD);
    }

    return dwErr;
}

#define ACCESS_STATUS_ALLOWED       0
#define ACCESS_STATUS_DENIED        1
#define ACCESS_STATUS_NOTPRESENT    2

HRESULT GetObjectAccessStatus(
    LPTSTR          lpObjectName,
    SE_OBJECT_TYPE  ObjectType,
    PSID            pOwnerSid,
    PDWORD          pdwStatus)
{
    DWORD                 dwErr;
    HRESULT               hr;
    PSECURITY_DESCRIPTOR  pSD = NULL;
    PACL                  psidDacl = NULL;
    SECURITY_INFORMATION  secInfo = DACL_SECURITY_INFORMATION;

    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;
    ACCESS_MASK           dwAllowMask,dwDeniedMask;



    if (!lpObjectName || !pOwnerSid || !pdwStatus)
    {
        hr = E_INVALIDARG;
        goto cleanup;
    }
    dwErr = GetNamedSecurityInfo(lpObjectName,
                                 ObjectType,
                                 secInfo,
                                 NULL,
                                 NULL,
                                 &psidDacl,
                                 NULL,
                                 &pSD);

    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto cleanup;
    }
    if (!psidDacl)
    {
        // in FS, this must be FAT/FAT32
        hr = S_OK;
        *pdwStatus = ACCESS_STATUS_ALLOWED;
        goto cleanup;
    }
    if (!GetAclInformation (psidDacl, 
                            (LPVOID) &aclSizeInfo, 
                            (DWORD) sizeof (ACL_SIZE_INFORMATION), 
                            AclSizeInformation))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    *pdwStatus = ACCESS_STATUS_NOTPRESENT;
    dwAllowMask = dwDeniedMask = 0;

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        ACCESS_ALLOWED_ACE              *accessAllowedAce;
        ACCESS_DENIED_ACE               *accessDeniedAce;
        PSID                            pAclSid;
     
        if (!GetAce (psidDacl, i, &ace))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }

        aceHeader = (ACE_HEADER *) ace;
        switch (aceHeader->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
                accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
                pAclSid = (PSID) &accessAllowedAce->SidStart;
                if (EqualSid (pOwnerSid, pAclSid))
                {
                    dwAllowMask  |=  accessAllowedAce->Mask;
                }
                break;
            case ACCESS_DENIED_ACE_TYPE:
                accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
                pAclSid = (PSID) &accessDeniedAce->SidStart;
                if (EqualSid (pOwnerSid, pAclSid))
                {
                    dwDeniedMask |= accessDeniedAce->Mask;
                }
                break;
            default:
                continue;
        }
    }    
    GENERIC_MAPPING  gm;
    gm.GenericRead    = FILE_GENERIC_READ ;
    gm.GenericWrite   = FILE_GENERIC_WRITE ;
    gm.GenericExecute = FILE_GENERIC_EXECUTE ;
    gm.GenericAll     = FILE_ALL_ACCESS ;

    DWORD dwExpected = GENERIC_ALL|GENERIC_WRITE|GENERIC_READ;

    MapGenericMask(&dwExpected,&gm);
    
    if (AreAnyAccessesGranted(dwDeniedMask,dwExpected))
    {
        *pdwStatus = ACCESS_STATUS_DENIED;
        hr = S_OK;
        goto cleanup;
    }
    dwExpected = GENERIC_ALL;
    MapGenericMask(&dwExpected,&gm);
    if (AreAllAccessesGranted(dwAllowMask,dwExpected))
    {
        *pdwStatus = ACCESS_STATUS_ALLOWED;
        hr = S_OK;
        goto cleanup;
    }
    dwExpected = GENERIC_WRITE|GENERIC_READ;
    MapGenericMask(&dwExpected,&gm);
    if (AreAllAccessesGranted(dwAllowMask,dwExpected))
    {
        *pdwStatus = ACCESS_STATUS_ALLOWED;
        hr = S_OK;
        goto cleanup;
    }
    *pdwStatus = ACCESS_STATUS_NOTPRESENT;
    hr = S_OK;

cleanup:
    if (pSD)
    {
        LocalFree(pSD);
    }
    return hr;
}

HRESULT IsObjectAccessiablebyLocalSys(
    LPTSTR          lpObjectName,
    SE_OBJECT_TYPE  ObjectType,
    PBOOL           pbCanAccess)
{
    HRESULT                     hr = S_OK;
    PSID                        pUserSid = NULL;
    DWORD                       dwLocal,dwEveryone,dwAdmins;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    
    *pbCanAccess = FALSE;
    
    //Local System
    if (!ConvertStringSidToSid(TEXT("S-1-5-18"),&pUserSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        pUserSid = NULL;
        goto cleanup;
    }
    hr = GetObjectAccessStatus(lpObjectName,ObjectType,pUserSid,&dwLocal);
    if (hr != S_OK)
    {
        goto cleanup;
    }
    if (dwLocal == ACCESS_STATUS_DENIED)
    {
        *pbCanAccess = FALSE;
        goto cleanup;
    }
    LocalFree(pUserSid);    
    pUserSid = NULL;

    //Everyone
    if (!ConvertStringSidToSid(TEXT("S-1-1-0"),&pUserSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        pUserSid = NULL;
        goto cleanup;
    }
    hr = GetObjectAccessStatus(lpObjectName,ObjectType,pUserSid,&dwEveryone);
    if (hr != S_OK)
    {
        goto cleanup;
    }
    if (dwEveryone == ACCESS_STATUS_DENIED)
    {
        *pbCanAccess = FALSE;
        goto cleanup;
    }
    LocalFree(pUserSid);    
    pUserSid = NULL;
    
    //Local Admins
    if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		                         SECURITY_BUILTIN_DOMAIN_RID,
		                         DOMAIN_ALIAS_RID_ADMINS,
		                         0, 0, 0, 0, 0, 0,
		                         &pUserSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        pUserSid = NULL;
        goto cleanup;
    }
    hr = GetObjectAccessStatus(lpObjectName,ObjectType,pUserSid,&dwAdmins);
    if (hr != S_OK)
    {
        goto cleanup;
    }
    if (dwAdmins == ACCESS_STATUS_DENIED)
    {
        *pbCanAccess = FALSE;
        goto cleanup;
    }
    LocalFree(pUserSid);    
    pUserSid = NULL;
    if (dwEveryone == ACCESS_STATUS_ALLOWED)
    {
        *pbCanAccess = TRUE;
    }
    else if ( (dwAdmins ==ACCESS_STATUS_ALLOWED) && (dwLocal ==ACCESS_STATUS_ALLOWED) )
    {
        *pbCanAccess = TRUE;
    }
    else
    {
        *pbCanAccess = FALSE;
    }
    hr = S_OK;
    
cleanup:
    if (pUserSid)
    {
        LocalFree(pUserSid);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\enumfile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enumfile.c

Abstract:

    File enumater, given a root direcory, it will enumerates all file under 
    this directory.

Author:

    Xiaofeng Zang (xiaoz) 08-Oct-2001  Created

Revision History:

    <alias> <date> <comments>

--*/

#include "StdAfx.h"
#include "clmt.h"



BOOL EnumBranch
(
    HANDLE              hFile, 
    LPWIN32_FIND_DATA   pfd, 
    LPTSTR              szCurDir,
    LPTSTR              szExt,
    FILEENUMPROC        lpEnumProc
)
{
    TCHAR   *p;
    BOOL    bDone;
    TCHAR   szSubDir[3*MAX_PATH+3],*lpSubDir;
    HANDLE  hFileSub;
    TCHAR   szFullPath[3*MAX_PATH+3],*lpFullPath;
    HRESULT hr;
    size_t  cchSubDirLen,cchFullPathLen;
    BOOL    bExit;
    BOOL    bReturn = TRUE;


    if (!pfd || !szCurDir)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    bExit = FALSE;
    do
    {
        if(pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {       

            if(0 == lstrcmp(pfd->cFileName , TEXT(".")))
            {
                continue;
            }
            if(0 == lstrcmp(pfd->cFileName , TEXT("..")))
            {
                continue;
            }

            //we statically allocated szSubDir 3*MAX_PATH
            //but limit the len use to 2*MAX_PATH, so that
            //later on ConcatenatePaths a file name will not fail 
            hr = StringCchCopy(szSubDir, 2*(MAX_PATH+1),szCurDir);
            if (SUCCEEDED(hr)) 
            {
                cchSubDirLen = 3*(MAX_PATH+1);
                lpSubDir = szSubDir;
            }
            else
            {
                if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)
                {
                    cchSubDirLen = lstrlen(szCurDir)+1 + MAX_PATH + 1;
                    lpSubDir = malloc(cchSubDirLen * sizeof(TCHAR));
                    if (!lpSubDir)
                    {
                        bExit = TRUE;
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        bReturn = FALSE;
                        goto Exit1;
                    }
                    if (FAILED(StringCchCopy(lpSubDir, cchSubDirLen,szCurDir)))
                    {
                        bExit = TRUE;
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        bReturn = FALSE;
                        goto Exit1;
                    }
                }
                else
                {
                    bExit = TRUE;
                    goto Exit1;
                }
            }
            ConcatenatePaths(lpSubDir, pfd->cFileName ,cchSubDirLen);

            p = lpSubDir + lstrlen(lpSubDir);

            ConcatenatePaths(lpSubDir, TEXT("*.*"),cchSubDirLen);

            hFileSub = FindFirstFile(lpSubDir, pfd);
            if(INVALID_HANDLE_VALUE == hFileSub)
            {
                continue;
            }

            *p = TEXT('\0');

            if (!EnumBranch(hFileSub, pfd, lpSubDir,szExt,lpEnumProc))
            {
                bReturn = FALSE;
                bExit = TRUE;
            }
            FindClose(hFileSub);
Exit1:
            if (lpSubDir && (lpSubDir != szSubDir))
            {
                free(lpSubDir);
                lpSubDir = NULL;
            }
        }
        else
        if(pfd->cFileName)
        {
            if (lstrlen(pfd->cFileName) > lstrlen(szExt))
            {
                p = pfd->cFileName + (lstrlen(pfd->cFileName) - lstrlen(szExt));
                if (!MyStrCmpI(p,szExt))
                {
                    hr = StringCchCopy(szFullPath, 2*(MAX_PATH+1),szCurDir);
                    if (SUCCEEDED(hr)) 
                    {
                        cchFullPathLen = 3*(MAX_PATH+1);
                        lpFullPath = szFullPath;
                    }
                    else
                    {
                        if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)
                        {
                            cchFullPathLen = lstrlen(szCurDir)+1 + MAX_PATH + 1;
                            lpFullPath = malloc(cchFullPathLen * sizeof(TCHAR));
                            if (!lpFullPath)
                            {
                                bExit = TRUE;
                                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                bReturn = FALSE;
                                goto Exit2;
                            }
                            if (FAILED(StringCchCopy(lpFullPath, cchFullPathLen,szCurDir)))
                            {
                                bExit = TRUE;
                                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                bReturn = FALSE;
                                goto Exit2;
                            }
                        }
                        else
                        {
                            bExit = TRUE;
                            goto Exit2;
                        }
                    }
                    ConcatenatePaths(lpFullPath, pfd->cFileName,cchFullPathLen);

                    if (!lpEnumProc(szFullPath))
                    {
                        bReturn = FALSE;
                        bExit = TRUE;
                    }
Exit2:
                    if (lpFullPath && (lpFullPath != szFullPath))
                    {
                        free(lpFullPath);
                        lpFullPath = NULL;
                    }
                }
            }
            
        }
    }
    while(FindNextFile( hFile, pfd) && !bExit);
    return (bReturn);
}

BOOL 
MyEnumFiles
(
    LPTSTR       szRoot,    
    LPTSTR       szExt,
    FILEENUMPROC lpEnumProc
)
{
    HANDLE              hFile;
    WIN32_FIND_DATA     fd;
    TCHAR               *szSubDir;
    TCHAR               *p;
    size_t              cbRoot;
    BOOL                bRet = FALSE;

    if (!szRoot || !lpEnumProc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }   

    cbRoot = lstrlen(szRoot);
    szSubDir = malloc( (cbRoot+MAX_PATH) * sizeof(TCHAR));

    if (!szSubDir)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }
    
    if (FAILED(StringCchCopy(szSubDir, cbRoot+MAX_PATH, szRoot)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }
    
    p = szSubDir + lstrlen(szSubDir);
    
    ConcatenatePaths(szSubDir, TEXT("\\*.*"),cbRoot+MAX_PATH);

    hFile = FindFirstFile(szSubDir, &fd);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        goto Cleanup;
    }

    *p = TEXT('\0');
    EnumBranch(hFile, &fd, szSubDir,szExt, lpEnumProc);

    FindClose(hFile);
    bRet = TRUE;

Cleanup:
    if (szSubDir)
    {
        free(szSubDir);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\dll.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dll.c

Abstract:

    main file for the cross language migration tool

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/


#include "StdAfx.h"
#include "clmt.h"
#include <winbase.h>
#include "clmtmsg.h"


BOOL CheckOS(DWORD);
HRESULT DoRegistryAnalyze();
LONG AddEventSource(VOID);
LONG CLMTReportEvent(WORD, WORD, DWORD, WORD, LPCTSTR*);
void Deinit(BOOL);
HRESULT DoCLMTCureProgramFiles();
HRESULT DoCLMTCleanUpAfterFirstReboot();
HRESULT DoCLMTCleanUpAfterDotNetUpgrade();
HRESULT DeleteUnwantedFilesPerUser(HKEY, LPCTSTR, LPCTSTR, LPTSTR);
HRESULT DeleteUnwantedFiles(HINF, LPCTSTR);
HRESULT AddRunValueToRegistry(LPCTSTR);
INT     DoCLMTDisplayAccountChangeDialog();
BOOL    CALLBACK AccountChangeDlgProc(HWND, UINT, WPARAM, LPARAM);
HRESULT UpdateHardLinkInfoPerUser(HKEY, LPCTSTR, LPCTSTR, LPTSTR);
VOID RemoveFromRunKey(LPCTSTR);



/*++

Routine Description:

    main entry point for the program

Arguments:
    if dwUndo != 0, we are in undo mode, otherwise...

Return Value:

    TRUE - if succeeds
--*/

LONG
DoMig(DWORD dwMode)
{   
    HRESULT hr;
    HINF    hMigrateInf = INVALID_HANDLE_VALUE;
    TCHAR   szInfFile[MAX_PATH],*p;
    UINT    iYesNo;
    DWORD   dwRunStatus;
    DWORD   dwCurrentState;
    DWORD   dwNextState;
    TCHAR   szProfileRoot[MAX_PATH];
    DWORD   cchLen;
    BOOL    bOleInit = FALSE;
    DWORD   dwOrgWinstationsState = 1;
    TCHAR   szBackupDir[2*MAX_PATH];
    TCHAR   szRunOnce[2*MAX_PATH];
    TCHAR   szRun[2 * MAX_PATH];
    HANDLE  hExe = GetModuleHandle(NULL);
    UINT    nRet;
    BOOL    bMsgPopuped = FALSE;
    BOOL    bWinStationChanged = FALSE;
    ULONG   uErrMsgID;
    LONG    err;
    TCHAR   szSecDatabase[MAX_PATH];
    BOOL    bCleanupFailed;
    INT     iRet;
    LCID    lcid;

    DPF(APPmsg, L"DoMig with dwMode = %d", dwMode);

    //
    // Only one instance of CLMT is allowed to run on the system
    //
    if (!IsOneInstance())
    {
        return FALSE;
    }

    //
    // Only users with admin privilege can run the tool
    //
    if (!CheckAdminPrivilege())
    {
        return FALSE;
    }

    //
    // Check if there are other tasks running on the system, quit CLMT
    //
    if (dwMode == CLMT_DOMIG && (!IsDebuggerPresent() && !g_fNoAppChk) && DisplayTaskList())
    {
        return ERROR_SUCCESS;
    }

    //
    // Display Start Up dialog
    //
    if (dwMode == CLMT_DOMIG)
    {
        iRet = ShowStartUpDialog();
        if (iRet == ID_STARTUP_DLG_CANCEL)
        {
            return ERROR_SUCCESS;
        }
    }

    //
    // Check to see if the operation is legal or not
    //
    hr = CheckCLMTStatus(&dwCurrentState, &dwNextState, &uErrMsgID);
    if (SUCCEEDED(hr))
    {
        if (hr == S_OK)
        {
            DPF(dlInfo,
                TEXT("Operation [0x%X] is legal with current machine state [0x%X]"),
                g_dwRunningStatus,
                dwCurrentState);
            
            SetCLMTStatus(g_dwRunningStatus);
        }
        else
        {
            DPF(dlFail,
                TEXT("Operation [0x%X] is illegal with current machine state [0x%X]"),
                g_dwRunningStatus,
                dwCurrentState);

            DoMessageBox(GetConsoleWindow(),
                         uErrMsgID,
                         IDS_MAIN_TITLE,
                         MB_OK | MB_SYSTEMMODAL);

            return FALSE;
        }
    }
    else
    {
        DPF(dlError,
            TEXT("Error occurred when trying to check CLMT and machine status - hr = 0x%X"),
            hr);
        return FALSE;
    }

    //
    // Verify the system if it is eligible to run CLMT
    //
    if (!CheckSystemCriteria())
    {
        DPF(APPerr, TEXT("System Verification Failed!"));
        hr = E_FAIL;
        bMsgPopuped = TRUE;
        goto Exit;
    }

    hr = InitDebugSupport(dwMode);
    if (FAILED(hr))
    {
        DPF (APPerr, L"DLL.C: InitDebugSupport! Error: %d (%#x)", hr, hr);
        goto Exit;
    }

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        DPF (APPerr, L"DLL.C: CoInitialize Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }
    else
    {
        bOleInit = TRUE;
    }

    // Initialize global variables
    if (!InitGlobals(dwMode))
    {
        hr = E_OUTOFMEMORY;
        DPF (APPerr, L"DLL.C: InitGlobal failure, out of memory!");
        goto Exit;
    }

    //we do not care the return value for LogMachineInfo
    LogMachineInfo();

    // Block new TS connections to be made during running CLMT
    hr = DisableWinstations(1, &dwOrgWinstationsState);
    if (SUCCEEDED(hr))
    {
        bWinStationChanged = TRUE;
    }
    else
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: Block new TS session failed: %d (%#x)\n", hr, hr);
        goto Exit;
    }

    if (g_dwRunningStatus == CLMT_REMINDER)
    {  
        BOOL        bIsNTFS;
        hr = IsSysVolNTFS(&bIsNTFS);
        if ( (S_OK == hr) && !bIsNTFS)
        {
            //make sure hr is S_FALSE so that it will not pop up reboot dlg
            hr = S_FALSE;
            DoMessageBox(GetConsoleWindow(), IDS_ASKING_CONVERT_TO_NTFS, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
            goto Exit;
        }
        hr = S_FALSE;
        DoMessageBox(GetConsoleWindow(), IDS_REMIND_HARDLINK, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
        goto Exit;
    }
    else if ( (g_dwRunningStatus == CLMT_CURE_PROGRAM_FILES) 
               || (g_dwRunningStatus == CLMT_CURE_ALL)
               || (g_dwRunningStatus == CLMT_CURE_AND_CLEANUP) )
             
    {
        hr = EnsureDoItemInfFile(g_szToDoINFFileName,ARRAYSIZE(g_szToDoINFFileName));
        if (SUCCEEDED(hr))
        {
            WritePrivateProfileSection(TEXT("Folder.ObjectRename"),NULL,g_szToDoINFFileName);
            WritePrivateProfileSection(TEXT("REG.Update.Sys"),NULL,g_szToDoINFFileName);
            WritePrivateProfileSection(TEXT("UserGrp.ObjectRename"),NULL,g_szToDoINFFileName);
            WritePrivateProfileSection(TEXT("LNK"),NULL,g_szToDoINFFileName);
        }
        LoopUser(UpdateHardLinkInfoPerUser);
        
        hr = DoCLMTCureProgramFiles();
        if (hr == S_OK)
        {
            // We are done with curing Program Files hard link
            CLMTSetMachineState(CLMT_STATE_PROGRAMFILES_CURED);

            // remove "/CURE" rom Run registry key
            RemoveFromRunKey(TEXT("/CURE"));

            // Make sure hr = S_FALSE so that it will not pop up reboot dlg
            hr = S_FALSE;
        }

        if (g_dwRunningStatus == CLMT_CURE_AND_CLEANUP)
        {
            // Do the cleanup also if machine is already upgraded to .NET
            // This scenario will happen only when Win2K FAT --> .NET FAT
            // then run /CURE /FINAL in .NET

            if (IsDotNet())
            {
                CheckCLMTStatus(&dwCurrentState, &dwNextState, &uErrMsgID);

                hr = DoCLMTCleanUpAfterDotNetUpgrade();
                if (hr == S_OK)
                {
                    CLMTSetMachineState(dwNextState);

                    // Remove "/FINAL" from Run registry key
                    RemoveFromRunKey(TEXT("/FINAL"));

                    // Make sure hr = S_FALSE so that it will not pop up reboot dlg
                    hr = S_FALSE;
                }
            }
        }

        goto Exit;
    }
    else if (g_dwRunningStatus == CLMT_CLEANUP_AFTER_UPGRADE)
    {
        hr = DoCLMTCleanUpAfterDotNetUpgrade();
        if (hr == S_OK)
        {
            // If the cleanup finished successfully
            CLMTSetMachineState(dwNextState);

            // Make sure hr = S_FALSE so that it will not pop up reboot dlg
            hr = S_FALSE;
        }

        goto Exit;
    }

    hr = GetInfFilePath(szInfFile, ARRAYSIZE(szInfFile));
    if (FAILED(hr))
    {
        DPF(APPerr,TEXT("[CLMT : get inf file name  failed !"));
        DoMessageBox(GetConsoleWindow(), IDS_CREATE_INF_FAILURE, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
        bMsgPopuped = TRUE;
        goto Exit;
    }

    hr = UpdateINFFileSys(szInfFile);
    if (FAILED(hr))
    {
        DPF(APPerr,TEXT("CLMT :  can not update per system settings in %s!"),szInfFile);        
        switch (hr)
        {
            case E_NOTIMPL:
                DoMessageBox(GetDesktopWindow(), IDS_LANG_NOTSUPPORTED, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
                break;
            default:
                DoMessageBox(GetConsoleWindow(), IDS_GENERAL_WRITE_FAILURE, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
                break;
        }
        bMsgPopuped = TRUE;
        goto Exit;
    }

    hMigrateInf = SetupOpenInfFile(szInfFile,
                                   NULL,
                                   INF_STYLE_WIN4,
                                   NULL);
    if (hMigrateInf != INVALID_HANDLE_VALUE) 
    {
        g_hInf = hMigrateInf;
    }
    else
    {
        DPF(APPerr,TEXT("CLMT :  can not open inf file %s!"),szInfFile);
        DoMessageBox(GetConsoleWindow(), IDS_OPEN_INF_FAILURE, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
        hr = E_FAIL;
        bMsgPopuped = TRUE;
        goto Exit;
    }

    //Copy myself to %windir%\$CLMT_BACKUP$ for future use, eg, runonce
    if (!GetSystemWindowsDirectory(szBackupDir, ARRAYSIZE(szBackupDir)))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF(APPerr, TEXT("Failed to get WINDIR"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    ConcatenatePaths(szBackupDir,CLMT_BACKUP_DIR,ARRAYSIZE(szBackupDir));
    if (S_OK != (hr = CopyMyselfTo(szBackupDir)))
    {
        //If can not copy, we will bail out, since most likely error is disk full 
        DPF(APPerr,TEXT("CLMT :  can not copy clmt.exe to  %s, error code = %d"),szBackupDir,HRESULT_CODE(hr));
        goto Exit;
    }

    //
    // Run Winnt32 /Checkupgrade to check the system compatibility
    //
    if (g_fRunWinnt32)
    {
        if (!IsUserOKWithCheckUpgrade())
        {
            hr = S_FALSE;
            goto Exit;
        }
    }

    hr = EnsureDoItemInfFile(g_szToDoINFFileName,MAX_PATH);
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF(APPerr,TEXT("CLMT :  can not create global Todo list INF file !"));
        goto Exit;
    }

#ifdef NEVER
    err = SDBCleanup(szSecDatabase,ARRAYSIZE(szSecDatabase),&bCleanupFailed);
    if ( (err != ERROR_SUCCESS) || bCleanupFailed )
    {
        TCHAR szErrorMessage[2*MAX_PATH],szErrorTemplate[MAX_PATH],szCaption[MAX_PATH];
        LoadString((HINSTANCE)g_hInstDll, IDS_SDBERROR, szErrorTemplate, ARRAYSIZE(szErrorTemplate)-1);
        hr = StringCchPrintf(szErrorMessage,ARRAYSIZE(szErrorMessage),szErrorTemplate,szSecDatabase);
        LoadString(g_hInstDll, IDS_MAIN_TITLE, szCaption, ARRAYSIZE(szCaption)-1);
        MessageBox(GetConsoleWindow(),szErrorMessage,szCaption, MB_OK|MB_SYSTEMMODAL);
        bMsgPopuped = TRUE;
        hr = E_FAIL;
        goto Exit;        
    }
#endif
#ifdef CONSOLE_UI
    wprintf(TEXT("Analyzing all user shell folders ......\n"));
#endif
    
    hr = DoShellFolderRename(hMigrateInf,NULL,TEXT("System"));
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: DoShellFolderRename Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }    

#ifdef CONSOLE_UI
    wprintf(TEXT("Analyzing per user shell folders ......\n"));
#endif
    if (!LoopUser(MigrateShellPerUser))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: LoopUser with  MigrateShellPerUser Failed");
        hr = E_FAIL;
        goto Exit;
    }
    
#ifdef CONSOLE_UI
    wprintf(TEXT("Analyzing user and group name changes ......\n"));
#endif
    hr = UsrGrpAndDoc_and_SettingsRename(hMigrateInf,TRUE);
     if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: UsrGrpAndDoc_and_SettingsRename Failed! Error: %d (%#x)", hr, hr);
          goto Exit;
    }
    if (!LoopUser(MigrateRegSchemesPerUser))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: LoopUser with  MigrateRegSchemesPerUser Failed");
        goto Exit;
    }

    hr = MigrateRegSchemesPerSystem(hMigrateInf);
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: MigrateRegSchemesPerSystem Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }

#ifdef CONSOLE_UI
    wprintf(TEXT("Analyzing IIS metabase  ......\n"));
#endif

    hr = MigrateMetabaseSettings(hMigrateInf);
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: MigrateMetabaseSettings! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }

    hr = MetabaseAnalyze(NULL, &g_StrReplaceTable, TRUE);
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: MetabaseAnalyze Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }

    // This EnumUserProfile will be enable after RC 1
    //
    //hr = EnumUserProfile(AnalyzeMiscProfilePathPerUser);
    //if (FAILED(hr))
    //{
    //    DPF (APPerr, L"DLL.C: EnumUserProfile with AnalyzeMiscProfilePathPerUser Failed");
    //    goto Exit;
    //}

#ifdef CONSOLE_UI
    wprintf(TEXT("Analyzing the entire registry ......\n"));
#endif
    hr = DoRegistryAnalyze();
    if (FAILED(hr))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF (APPerr, L"DLL.C: DoRegistryAnalyze Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }    

#ifdef CONSOLE_UI
    //wprintf(TEXT("Analyzing lnk files under profile directories ......\n"));
    wprintf(TEXT("Analyzing LNK files under profile directories, please wait as this may\n"));
    wprintf(TEXT("take a few minutes ......\n"));
#endif
    //make sure the link file under profile dirrectory is updated
    cchLen = ARRAYSIZE(szProfileRoot);
    if (GetProfilesDirectory(szProfileRoot,&cchLen))
    {
        if (!MyEnumFiles(szProfileRoot,TEXT("lnk"),LnkFileUpdate))
        {
            //BUGBUG:Xiaoz:Add DLG pop up for failure
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF (APPerr, L"DLL.C: EnumFiles Lnk File  Failed! Error: %d (%#x)\n", hr, hr);
            goto Exit;
        }
    }

    if (GetEnvironmentVariable(L"windir", szProfileRoot, MAX_PATH))
    {
        hr = StringCchCat(szProfileRoot, MAX_PATH, TEXT("\\security\\templates"));
        if (!MyEnumFiles(szProfileRoot,TEXT("inf"),SecTempUpdate))
        {
            //BUGBUG:Xiaoz:Add DLG pop up for failure
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF (APPerr, L"DLL.C: EnumFiles security template File Failed! Error: %d (%#x)\n", hr, hr);
            goto Exit;
        }
    }

    hr = FolderMove(hMigrateInf,TEXT("Generic.Folder.ObjectRename.PerSystem"),TRUE);
    if (FAILED(hr))
    {
        DPF (APPerr, L"DLL.C: FolderMove Failed! Error: %d (%#x)\n", hr, hr);
        goto Exit;
    }

    FRSUpdate();
    Ex2000Update();

    // Analyze the services reconfiguration
    DoServicesAnalyze();

    // Add event log source to registry
    AddEventSource();

    // Log an event into event log
    CLMTReportEvent(EVENTLOG_INFORMATION_TYPE,
                    STATUS_SEVERITY_INFORMATIONAL,
                    MSG_CLMT_STARTED,
                    0,
                    NULL);
    

    // Display the Administrator Account Change dialog
    GetSavedInstallLocale(&lcid);
    if (lcid != 0x411)
    {
        // we ignore displaying this dialog on JPN
        iRet = DoCLMTDisplayAccountChangeDialog();
        
        if (iRet == ID_STARTUP_DLG_CANCEL)
        {
            iRet = DoMessageBox(GetConsoleWindow(),
                                IDS_CONFIRM_OPERATION,
                                IDS_MAIN_TITLE,
                                MB_OKCANCEL);
            if (iRet == IDCANCEL)
            {
                goto Exit;
            }
        }
    }

    //
    // Do the critical system changes here...
    //
    nRet = (UINT) DialogBoxParam(hExe,
                                MAKEINTRESOURCE(IDD_UPDATESYSTEM),
                                GetConsoleWindow(),
                                (DLGPROC) DoCriticalDlgProc,
                                (LPARAM) NULL);
    if (nRet == ID_UPDATE_DONE)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    // Set machine state after operation is done
    if (hr == S_OK)
    {
        // Add cure program files switch to Run key
        AddRunValueToRegistry(TEXT("/CURE /FINAL"));

        // Set machine to next state
        CLMTSetMachineState(dwNextState);    

        // Tool has finished, report to event log
        CLMTReportEvent(EVENTLOG_INFORMATION_TYPE,
                        STATUS_SEVERITY_INFORMATIONAL,
                        MSG_CLMT_FINISHED,
                        0,
                        NULL);
    }

Exit:
    if (bWinStationChanged)
    {
        // Return the WinStations status to original state
        DisableWinstations(dwOrgWinstationsState, NULL);
    }

    if (hMigrateInf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hMigrateInf);
        g_hInf = INVALID_HANDLE_VALUE ;
    }    
    Deinit(bOleInit);
    CloseDebug();
    EnablePrivilege(SE_SHUTDOWN_NAME,FALSE);
    EnablePrivilege(SE_BACKUP_NAME,FALSE);
    EnablePrivilege(SE_RESTORE_NAME,FALSE);
    EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,FALSE); 
    if (hr == S_OK)
    {
        ReStartSystem(EWX_REBOOT);
    }
    else if ( FAILED(hr) && !bMsgPopuped)
    {
        DoMessageBox(GetConsoleWindow(), IDS_FATALERROR, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
    }
    return HRESULT_CODE(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   MigrateShellPerUser
//
//  Synopsis:   Rename shell folders for each user
//
//  Returns:    HRESULT
//
//  History:    03/08/2002 Rerkboos     Add log + code clean up
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT MigrateShellPerUser(
    HKEY    hKeyUser, 
    LPCTSTR UserName, 
    LPCTSTR DomainName,
    LPTSTR  UserSid
)
{
    TCHAR   InfoBuff[1000];
    HINF    hMigrateInf = INVALID_HANDLE_VALUE;
    TCHAR   szInfFile[MAX_PATH];
    HRESULT hr;

    DPF(APPmsg, TEXT("Enter MigrateShellPerUser:"));

    // Get per-user temporary INF file name
    hr = GetInfFilePath(szInfFile, ARRAYSIZE(szInfFile));
    if (SUCCEEDED(hr))
    {
        // Update per-syste data to temp INF file
        hr = UpdateINFFileSys(szInfFile);
        if (SUCCEEDED(hr))
        {
            // Update per-user data to temp INF file
            hr = UpdateINFFilePerUser(szInfFile, UserName, UserSid, FALSE);
            if (SUCCEEDED(hr))
            {
                DPF(APPmsg, TEXT("Per-user INF file was updated successfully"));
            }
            else
            {
                DPF(APPerr, TEXT("Failed to update per-user data in INF"));
            }
        }
        else
        {
            DPF(APPerr, TEXT("Failed to update per-system data in INF"));
        }
    }
    else
    {
        DPF(APPerr, TEXT("Faild to get per-user INF file name"));
    }


#ifdef CONSOLE_UI
    wprintf(TEXT("analyzing settings for user %s \n"), UserName);
#endif

    if (SUCCEEDED(hr))
    {
        // Open per-user INF file
        hMigrateInf = SetupOpenInfFile(szInfFile,
                                       NULL,
                                       INF_STYLE_WIN4,
                                       NULL);
        if (hMigrateInf != INVALID_HANDLE_VALUE)
        {
            // Rename shell folders for the user
            hr = DoShellFolderRename(hMigrateInf, hKeyUser, (LPTSTR) UserName);
            
            SetupCloseInfFile(hMigrateInf);
            DeleteFile(szInfFile);
            if (SUCCEEDED(hr))
            {
                DPF(APPmsg, TEXT("Rename per-user shell folders successfully"));
            }
            else
            {
                DPF(APPerr, TEXT("Rename per-user shell folders Failed"));
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(APPerr, TEXT("Failed to open per-user INF file"));
        }
    }

    DPF(APPmsg, TEXT("Exit MigrateShellPerUser:"));

    return hr;
}

/*++

Routine Description:

    This routine initializes the global variables used in the program

Arguments:
    
Return Value:

    TRUE - if succeeds
--*/
BOOL InitGlobals(DWORD dwRunStatus)
{
    BOOL        bRet = TRUE;
    int         i, n;
    DWORD       dwMachineState;
    HRESULT     hr;

    // Get the module handle to ourself
    g_hInstDll = GetModuleHandle(NULL);

    // Check if the machine has not run CLMT yet
    hr = CLMTGetMachineState(&dwMachineState);
    g_bBeforeMig = (SUCCEEDED(hr) && dwMachineState == CLMT_STATE_ORIGINAL);

    //Init the global string search-replacement table
    if(!InitStrRepaceTable())
    {
        DoMessageBox(GetConsoleWindow(), IDS_OUT_OF_MEMORY, IDS_MAIN_TITLE, MB_OK|MB_SYSTEMMODAL);
        bRet = FALSE;
    }

    return bRet;
}


/*++

Routine Description:

    This routine checks the various OS properties to make sure that the tool cab be run

Arguments:
    
Return Value:

    TRUE - if the clmt tool can be run on the current platform .    
--*/


BOOL CheckOS(DWORD dwMode)
{
    TCHAR   Text[MAX_PATH];
    BOOL    bRet = TRUE;
    LCID    lcid;
    HRESULT hr;
    BOOL    bIsAdmin;
    OSVERSIONINFOEX osviex;

    if (FAILED(StringCchPrintf (Text, ARRAYSIZE(Text), TEXT("Global\\%s"), TEXT("CLMT Is Running"))))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    g_hMutex = CreateMutex(NULL,FALSE,Text);

    if ((g_hMutex == NULL) && (GetLastError() == ERROR_PATH_NOT_FOUND)) 
    {
        g_hMutex = CreateMutex(NULL,FALSE,TEXT("CLMT Is Running"));
        if(g_hMutex == NULL) 
        {
            //
            // An error (like out of memory) has occurred.
            // Bail now.
            //
            DoMessageBox(GetConsoleWindow(), IDS_OUT_OF_MEMORY, IDS_MAIN_TITLE, MB_OK);            
            bRet = FALSE;
            goto Cleanup;
        }     
    }

    //
    // Make sure we are the only process with a handle to our named mutex.
    //
    if ((g_hMutex == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ALREADY_RUNNING, IDS_MAIN_TITLE, MB_OK);            
        bRet = FALSE;
        goto Cleanup;
    }

    if (dwMode == CLMT_DOMIG)
    {
        if (!IsNT5())
        {
            DoMessageBox(GetConsoleWindow(), IDS_NT5, IDS_MAIN_TITLE, MB_OK);
            bRet = FALSE;
            goto Cleanup;
        }

        if (IsDomainController())
        {
            //
            // If this machine is a domain controller, we need W2K SP2
            //
            ZeroMemory(&osviex, sizeof(OSVERSIONINFOEX));
            osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
            GetVersionEx((LPOSVERSIONINFO) &osviex);
            
            bRet = (osviex.wServicePackMajor >= 2 ? TRUE : FALSE);
            if (!bRet)
            {
                DoMessageBox(GetConsoleWindow(), IDS_NT5SP2, IDS_MAIN_TITLE, MB_OK);
                goto Cleanup;
            }

            //
            // Also pop up the message asking admin to take machine
            // off the network if it is in DC replication servers
            //
            DoMessageBox(GetConsoleWindow(),
                         IDS_DC_REPLICA_OFFLINE,
                         IDS_MAIN_TITLE,
                         MB_OK);
        }
    }
    else if (dwMode == CLMT_CLEANUP_AFTER_UPGRADE)
    {
        if (!IsDotNet())
        {
            bRet = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        //for undo code here
        //BUGBUG:XIAOZ Adding code here
    }


    if (IsNEC98())
    {
        DoMessageBox(GetConsoleWindow(), IDS_NEC98, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }

    if (IsIA64())
    {
        DoMessageBox(GetConsoleWindow(), IDS_IA64, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }

    if (IsOnTSClient())
    {
        DoMessageBox(GetConsoleWindow(), IDS_ON_TS_CLIENT, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }

    //if (IsTSServiceRunning() && IsTSConnectionEnabled())
    //{
    //    DoMessageBox(GetConsoleWindow(), IDS_TS_ENABLED, IDS_MAIN_TITLE, MB_OK);
    //    bRet = FALSE;
    //    goto Cleanup;
    //}

    if (IsOtherSessionOnTS())
    {
        DoMessageBox(GetConsoleWindow(), IDS_TS_CLOSE_SESSION, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }

    bIsAdmin = IsAdmin();
    
    if (dwMode == CLMT_DOMIG)
    {
        if (!bIsAdmin)
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
            bRet = FALSE;
            goto Cleanup;
        }    

        if (g_fRunWinnt32)
        {
            if (!IsUserOKWithCheckUpgrade())
            {
                bRet = FALSE;
                goto Cleanup;
            }
        }
        hr = GetSavedInstallLocale(&lcid);
        if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
        {
            hr = SaveInstallLocale();
            if (FAILED(hr))
            {   
                bRet = FALSE;
            }
        }    
    }
    else if ( (dwMode == CLMT_CURE_PROGRAM_FILES)
              || (dwMode == CLMT_CURE_ALL) )
    {
        if (!bIsAdmin)
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
            bRet = FALSE;
            goto Cleanup;
        }    
    }
    else if (dwMode == CLMT_CLEANUP_AFTER_UPGRADE)
    {
        if (!bIsAdmin)
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN_LOGON_DOTNET, IDS_MAIN_TITLE, MB_OK);
            bRet = FALSE;
            goto Cleanup;
        }    
    }

    if(!DoesUserHavePrivilege(SE_SHUTDOWN_NAME)
       || !DoesUserHavePrivilege(SE_BACKUP_NAME)
       || !DoesUserHavePrivilege(SE_RESTORE_NAME)
       || !DoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }
    if(!EnablePrivilege(SE_SHUTDOWN_NAME,TRUE)
        || !EnablePrivilege(SE_BACKUP_NAME,TRUE)
        || !EnablePrivilege(SE_RESTORE_NAME,TRUE)
        || !EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
        bRet = FALSE;
        goto Cleanup;
    }

    //else //This means undo which we do not need user to provide .net CD
    //{
    //    DWORD dwStatusinReg;

    //    hr = CLMTGetMachineState(&dwStatusinReg);
    //    if ( (hr != S_OK) || (CLMT_STATE_MIGRATION_DONE != dwStatusinReg))
    //    {
    //        DPF (APPerr, L"DLL.C: can not get the CLMT status from registry or you have not run the clmt tools!");
    //        //BUGBUG:XIAOZ:ADD a DLG here
    //        bRet = FALSE;
    //        goto Cleanup;
    //    }
    //}
Cleanup:
    return bRet;
}


/*++

Routine Description:

    This routine does system wide  registry search and replace, the string replace table 
    is in global variable g_StrReplaceTable

Arguments:

    hKeyUser - user registry key handle
    UserName - user name that hKeyUser belongs to 
    DomainName  - domain name the UserName belongs to 
Return Value:

    TRUE - if succeeds.    
--*/

HRESULT DoRegistryAnalyze()
{
    LPTSTR  lpUser,lpSearchStr,lpReplaceStr,lpFullPath;
    UINT    i;
    //TCHAR   szExcludeList[] = TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\0\0");
    TCHAR   szExcludeList[] = TEXT("HKLM\\Software\\Microsoft\\Shared Tools\\Stationery\0\0");
    LPTSTR  lpszExcludeList = NULL;
    HRESULT hr ;

        
        
    {
        HKEY    hkey;
        LONG    lRes;
        lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\DRM"),
                            0,KEY_ALL_ACCESS,&hkey);
        if (ERROR_SUCCESS == lRes)
        {
            hr = RegistryAnalyze(hkey,NULL,NULL,&g_StrReplaceTable,lpszExcludeList,REG_SZ,
                                 TEXT("HKLM\\SOFTWARE\\Microsoft\\DRM"),TRUE);
            RegCloseKey(hkey);
        }
    }
    if (!LoopUser(UpdateRegPerUser))
    {
        hr = E_FAIL;
    }
    else
    {
        lpszExcludeList = malloc(MultiSzLen(szExcludeList)*sizeof(TCHAR));
        if (lpszExcludeList)
        {
            memmove((LPBYTE)lpszExcludeList,(LPBYTE)szExcludeList,MultiSzLen(szExcludeList)*sizeof(TCHAR));
            //hr = RegistryAnalyze(HKEY_LOCAL_MACHINE,NULL,NULL,&g_StrReplaceTable,lpszExcludeList,FALSE,NULL);
            hr = RegistryAnalyze(HKEY_LOCAL_MACHINE,NULL,NULL,&g_StrReplaceTable,NULL,FALSE,NULL,TRUE);
            free(lpszExcludeList);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}




//-----------------------------------------------------------------------
//
//  Function:   AddEventSource
//
//  Descrip:    Add EventLog source to registry
//
//  Returns:    Win32 Error Code
//
//  Notes:      
//
//  History:    03/05/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
LONG AddEventSource(VOID)
{
    HKEY  hKey;
    LONG  lRet;
    TCHAR szMessageFile[MAX_PATH+1];

    if (GetModuleFileName(NULL, szMessageFile, ARRAYSIZE(szMessageFile)-1))
    {
        szMessageFile[ARRAYSIZE(szMessageFile)-1] = TEXT('\0');
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\CLMT"),
                              0,
                              NULL,
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegSetValueEx(hKey,
                                 TEXT("EventMessageFile"),
                                 0,
                                 REG_EXPAND_SZ,
                                 (LPBYTE) szMessageFile,
                                 sizeof(szMessageFile));
            if (lRet == ERROR_SUCCESS)
            {
                DWORD dwData = EVENTLOG_ERROR_TYPE |
                               EVENTLOG_WARNING_TYPE |
                               EVENTLOG_INFORMATION_TYPE;

                lRet = RegSetValueEx(hKey,
                                     TEXT("TypesSupported"),
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &dwData,
                                     sizeof(dwData));
            }

            RegCloseKey(hKey);
        }
    }
    else
    {
        lRet = GetLastError();
    }

    return lRet;
}



//-----------------------------------------------------------------------
//
//  Function:   ReportEvent
//
//  Descrip:    Report event to Event Log
//
//  Returns:    Win32 Error Code
//
//  Notes:      
//
//  History:    03/05/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
LONG CLMTReportEvent(
    WORD    wType,              // Event type
    WORD    wCategory,          // Event category
    DWORD   dwEventID,          // Event identifier
    WORD    wNumSubstitute,     // Number of strings to merge
    LPCTSTR *lplpMessage        // Pointer to message string array
)
{
    HANDLE hEventLog;
    LONG   lRet;
    TCHAR  szUserName[UNLEN + 1];
    DWORD  cchUserName = ARRAYSIZE(szUserName);

    hEventLog = RegisterEventSource(NULL, TEXT("CLMT"));
    if (hEventLog)
    {
        // Get the user name who run the tool
        if (GetUserName(szUserName, &cchUserName))
        {
            LPVOID lpSidCurrentUser;
            DWORD  cbSid;
            TCHAR  szDomainName[MAX_PATH];
            DWORD  cbDomainName = ARRAYSIZE(szDomainName) * sizeof(TCHAR);
            SID_NAME_USE sidNameUse;

            // Allocate enough memory for largest possible SID
            cbSid = SECURITY_MAX_SID_SIZE;
            lpSidCurrentUser = MEMALLOC(cbSid);

            if (lpSidCurrentUser)
            {
                if (LookupAccountName(NULL,
                                      szUserName,
                                      (PSID) lpSidCurrentUser,
                                      &cbSid,
                                      szDomainName,
                                      &cbDomainName,
                                      &sidNameUse))
                {
                    if (ReportEvent(hEventLog,
                                    wType,
                                    wCategory,
                                    dwEventID,
                                    (PSID) lpSidCurrentUser,
                                    wNumSubstitute,
                                    0,
                                    lplpMessage,
                                    NULL))
                    {
                        lRet = ERROR_SUCCESS;
                    }
                    else
                    {
                        lRet = GetLastError();
                    }
                }
                else
                {
                    lRet = GetLastError();
                }

                MEMFREE(lpSidCurrentUser);
            }
        }
        else
        {
            if (ReportEvent(hEventLog,
                            wType,
                            wCategory,
                            dwEventID,
                            NULL,
                            wNumSubstitute,
                            0,
                            lplpMessage,
                            NULL))
            {
                lRet = ERROR_SUCCESS;
            }
            else
            {
                lRet = GetLastError();
            }
        }

        DeregisterEventSource(hEventLog);
    }
    else
    {
        lRet = GetLastError();
    }

    return lRet;
}



void Deinit(BOOL bOleInit)
{
    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
    }
    if (INVALID_HANDLE_VALUE != g_hInf)
    {
        SetupCloseInfFile(g_hInf);
    }
    DeInitStrRepaceTable();

    if (bOleInit)
    {
        CoUninitialize();
    }
}



//-----------------------------------------------------------------------
//
//  Function:   DoCLMTCleanUpAfterFirstReboot
//
//  Descrip:    Do the clean up after the machine has been run CLMT and
//              reboot (before upgraded to .NET)
//
//  Returns:    S_OK if cure Program Files successfully
//              S_FALSE if Program Files cannot be cured (no error)
//              Else if error occurred
//
//  History:    07/18/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
HRESULT DoCLMTCureProgramFiles()
{
    HRESULT hr;
    BOOL    bIsNTFS;
    LONG    lRet;
    HKEY    hRunKey;

    hr = IsSysVolNTFS(&bIsNTFS);
    if ((S_OK == hr) && !bIsNTFS)
    {
        hr = S_FALSE;
        DoMessageBox(GetConsoleWindow(),
                     IDS_ASKING_CONVERT_TO_NTFS,
                     IDS_MAIN_TITLE,
                     MB_OK | MB_SYSTEMMODAL);
        goto EXIT;
    }

    hr = INFCreateHardLink(INVALID_HANDLE_VALUE, FOLDER_CREATE_HARDLINK, TRUE);
    if (FAILED(hr))
    {
        DPF(APPerr, L"DLL.C: INFCreateHardLink returned error: %d (%#x)\n", hr, hr);            
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

EXIT:
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   DoCLMTCleanUpAfterFirstReboot
//
//  Descrip:    Do the clean up after the machine has been run CLMT and
//              reboot (before upgraded to .NET)
//
//  Returns:    S_OK if no error occured
//
//  History:    07/18/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
HRESULT DoCLMTCleanUpAfterFirstReboot()
{
    HRESULT hr;
    TCHAR   szInfFile[MAX_PATH];
    HKEY    hRunKey;
    LONG    lRet;

    g_hInf = INVALID_HANDLE_VALUE;

    // Load INF
    hr = GetInfFilePath(szInfFile, ARRAYSIZE(szInfFile));
    if (SUCCEEDED(hr))
    {
        hr = UpdateINFFileSys(szInfFile);
        if (SUCCEEDED(hr))
        {
            g_hInf = SetupOpenInfFile(szInfFile,
                                      NULL,
                                      INF_STYLE_WIN4,
                                      NULL);
            if (g_hInf == INVALID_HANDLE_VALUE) 
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // do the per-system clean up stuffs here...
    //

    // Close the current INF file to update settings in INF
    // Here, each callback function of LoopUser() must call UpdateINFFilePerUser
    // to update per-user settings
    SetupCloseInfFile(g_hInf);
    g_hInf = INVALID_HANDLE_VALUE;

    //
    // do the per-user clean up stuffs here...
    //
    LoopUser(DeleteUnwantedFilesPerUser);

    // Cleanup the variables
    if (g_hInf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(g_hInf);
        g_hInf = INVALID_HANDLE_VALUE;
    }

    // Return S_FALSE because we don't want to reboot the machine
    return S_FALSE;
}



//-----------------------------------------------------------------------
//
//  Function:   DoCLMTCleanUpAfterDotNetUpgrade
//
//  Descrip:    Do the clean up after the machine has been run CLMT and
//              upgraded to .NET
//
//  Returns:    S_OK if no error occured
//
//  History:    07/09/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
HRESULT DoCLMTCleanUpAfterDotNetUpgrade()
{
    HRESULT hr = S_OK;
    TCHAR   szInfFile[MAX_PATH];
    TCHAR   szToDoInfFile[MAX_PATH];
    HKEY    hRunKey;
    LONG    lRet;

    g_hInf = INVALID_HANDLE_VALUE;
    g_hInfDoItem = INVALID_HANDLE_VALUE;

    DPF(APPmsg, TEXT("[Enter CleanupAfterDotNetUpgrade]"));
    //
    // Load Migrate INF
    //
    hr = GetInfFilePath(szInfFile, ARRAYSIZE(szInfFile));
    if (SUCCEEDED(hr))
    {
        hr = UpdateINFFileSys(szInfFile);
        if (SUCCEEDED(hr))
        {
            g_hInf = SetupOpenInfFile(szInfFile,
                                      NULL,
                                      INF_STYLE_WIN4,
                                      NULL);
            if (g_hInf == INVALID_HANDLE_VALUE) 
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    if (g_hInf == INVALID_HANDLE_VALUE)
    {
        return hr;
    }

    //
    // Load ClmtDo.inf
    //
    if (GetSystemWindowsDirectory(szToDoInfFile, ARRAYSIZE(szToDoInfFile)))
    {
        if (ConcatenatePaths(szToDoInfFile, CLMT_BACKUP_DIR, ARRAYSIZE(szToDoInfFile)))
        {
            if (ConcatenatePaths(szToDoInfFile, TEXT("CLMTDO.INF"), ARRAYSIZE(szToDoInfFile)))
            {
                g_hInfDoItem = SetupOpenInfFile(szToDoInfFile,
                                                NULL,
                                                INF_STYLE_WIN4,
                                                NULL);
            }
        }
    }

    if (g_hInfDoItem == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    //
    // Do the CLMT Cleanup (Per System) stuffs here...
    //
    ResetServicesStatus(g_hInfDoItem, TEXT_SERVICE_STATUS_CLEANUP_SECTION);
    ResetServicesStartUp(g_hInfDoItem, TEXT_SERVICE_STARTUP_CLEANUP_SECTION);

    DeleteUnwantedFiles(g_hInf, TEXT("Folders.PerSystem.Cleanup"));

    INFVerifyHardLink(g_hInfDoItem,TEXT("Folder.HardLink"));


    // Close the current INF file to update settings in INF
    // Each Call back function of LoopUser() must call UpdateINFFilePerUser
    // to update per-user settings
    SetupCloseInfFile(g_hInf);
    g_hInf = INVALID_HANDLE_VALUE;

    // Close ClmtDo.inf handle, as we don't need it anymore
    SetupCloseInfFile(g_hInfDoItem);

    //
    // Do the CLMT Cleanup (Per User) stuffs here...
    //
    LoopUser(DeleteUnwantedFilesPerUser);

    // Remove CLMT from registry Run key
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT_RUN_KEY, &hRunKey);
    if (lRet == ERROR_SUCCESS)
    {
        RemoveFromRunKey(TEXT("/FINAL"));
        RegCloseKey(hRunKey);
    }

    //
    // Cleanup the variables
    //
    if (g_hInf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(g_hInf);
    }

    DPF(APPmsg, TEXT("[Exit CleanupAfterDotNetUpgrade]"));

    return S_OK;
}



//-----------------------------------------------------------------------
//
//  Function:   DeleteUnwantedFiles
//
//  Descrip:    Delete unwanted files and directories after the machine
//              has been upgraded to .NET. The list of files/directories
//              are listed in INF.
//              File/directory will be deleted if and only if Loc file name
//              does not match the expected English file name. This prevents
//              deleting English file/directory.
//
//  Returns:    S_OK if no error occured
//
//  History:    07/09/2002 rerkboos     Created
//
//  Notes:      Format in INF:
//                <FileType>, <Loc File to be deleted>, <Expected Eng File>
//
//                FileType:- 0 = Directory
//                           1 = File
//
//-----------------------------------------------------------------------
HRESULT DeleteUnwantedFiles(
    HINF    hInf,
    LPCTSTR lpInfSection
)
{
    HRESULT hr = S_OK;
    BOOL    bRet = TRUE;
    LONG    lLineCount;
    LONG    lLineIndex;
    INT     iFileType;
    TCHAR   szFileName[2 * MAX_PATH];
    TCHAR   szEngFileName[2 * MAX_PATH];
    INFCONTEXT context;

    if (hInf == INVALID_HANDLE_VALUE || lpInfSection == NULL)
    {
        return E_INVALIDARG;
    }

    // Read the list of services to be reset from INF
    lLineCount = SetupGetLineCount(hInf, lpInfSection);
    if (lLineCount >= 0)
    {
        for (lLineIndex = 0 ; lLineIndex < lLineCount && bRet ; lLineIndex++)
        {
            bRet = SetupGetLineByIndex(hInf,
                                       lpInfSection,
                                       (DWORD) lLineIndex,
                                       &context);
            if (bRet)
            {
                bRet = SetupGetIntField(&context, 1, &iFileType)
                       && SetupGetStringField(&context,
                                              2,
                                              szFileName,
                                              ARRAYSIZE(szFileName),
                                              NULL)
                       && SetupGetStringField(&context,
                                              3,
                                              szEngFileName,
                                              ARRAYSIZE(szEngFileName),
                                              NULL);
                if (bRet
                    && MyStrCmpI(szFileName, szEngFileName) != LSTR_EQUAL)
                {
                    switch (iFileType)
                    {
                    case 0:
                        // Directories
                        hr = DeleteDirectory(szFileName);
                        if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)
                        {
                            goto EXIT;
                        }

                        break;

                    case 1:
                        // Files
                        hr = MyDeleteFile(szFileName);
                        if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)
                        {
                            goto EXIT;
                        }

                        break;
                    }
                }
            }
        }
    }

    hr = (bRet ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

EXIT:
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   DeleteUnwantedFilesPerUser
//
//  Descrip:    This is a call back function for LoopUser().
//
//  Returns:    S_OK if no error occured
//
//  History:    07/09/2002 rerkboos     Created
//
//  Notes:      Format in INF:
//                <FileType>, <Loc File to be deleted>, <Expected Eng File>
//
//                FileType:- 0 = Directory
//                           1 = File
//
//-----------------------------------------------------------------------
HRESULT DeleteUnwantedFilesPerUser(
    HKEY    hKeyUser, 
    LPCTSTR UserName, 
    LPCTSTR DomainName,
    LPTSTR  UserSid
)
{
    HRESULT hr = S_OK;

    hr = UpdateINFFilePerUser(g_szInfFile, UserName ,UserSid , FALSE);
    if (SUCCEEDED(hr))
    {
        g_hInf = SetupOpenInfFile(g_szInfFile,
                                  NULL,
                                  INF_STYLE_WIN4,
                                  NULL);
        if (g_hInf != INVALID_HANDLE_VALUE)
        {
            // Delete files/directories here
            hr = DeleteUnwantedFiles(g_hInf, TEXT("Folders.PerUser.Cleanup"));

            // Close Inf file for this user
            SetupCloseInfFile(g_hInf);
            g_hInf = INVALID_HANDLE_VALUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   AddRunValueToRegistry
//
//  Descrip:    This will add "CLMT /switch" to Run key. So CLMT can
//              do the cleanup stuffs after next reboot.
//
//  Returns:    S_OK if no error occured
//
//  History:    07/29/2002 rerkboos     Created
//
//  Notes:      lpCmdSwitch should be supplied in format "/something"
//
//-----------------------------------------------------------------------
HRESULT AddRunValueToRegistry(
    LPCTSTR lpCmdSwitch
)
{
    HRESULT hr = S_FALSE;
    TCHAR   szBackupDir[MAX_PATH];
    TCHAR   szRun[MAX_PATH];

    DPF(dlInfo, TEXT("Add CLMT with switch '%s' to Run key"), lpCmdSwitch);

    if (GetSystemWindowsDirectory(szBackupDir, ARRAYSIZE(szBackupDir)))
    {
        if (ConcatenatePaths(szBackupDir,
                             CLMT_BACKUP_DIR,
                             ARRAYSIZE(szBackupDir)))
        {
            hr = StringCchCopy(szRun, ARRAYSIZE(szRun), szBackupDir);
            if (SUCCEEDED(hr))
            {
                if (ConcatenatePaths(szRun, TEXT("\\CLMT.EXE "), ARRAYSIZE(szRun)))
                {
                    hr = StringCchCat(szRun, ARRAYSIZE(szRun), lpCmdSwitch);
                    if (SUCCEEDED(hr))
                    {
                        SetRunValue(TEXT_CLMT_RUN_VALUE, szRun);
                    }
                }
            }
        }
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   DoCLMTDisplayAccountChangeDialog
//
//  Descrip:    Display the dialog notify user of Administrator account
//              name change.
//
//  Returns:    n/a
//
//  History:    07/29/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
INT DoCLMTDisplayAccountChangeDialog()
{
    return (INT) DialogBoxParam(GetModuleHandle(NULL),
                                MAKEINTRESOURCE(IDD_STARTUP_DLG),
                                GetConsoleWindow(),
                                (DLGPROC) AccountChangeDlgProc,
                                (LPARAM) NULL);
}


//-----------------------------------------------------------------------------
//
//  Function:   AccountChangeDlgProc
//
//  Synopsis:   Dialog box procedure
//
//  Returns:    
//
//  History:    9/02/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL
CALLBACK
AccountChangeDlgProc(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL  bRet;
    DWORD dwErr;
    TCHAR szOldAdminName[64];
    TCHAR szAdminChange[1024];
    LPTSTR lpArgs[1];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Init the dialog
            ShowWindow(hwndDlg, SW_SHOWNORMAL);

            bRet = GetUserNameChangeLog(TEXT("Administrator"),
                                        szOldAdminName,
                                        ARRAYSIZE(szOldAdminName));
            if (bRet)
            {
                lpArgs[0] = szOldAdminName;

                dwErr = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      NULL,
                                      MSG_CLMT_ADMIN_ACCT_CHANGE,
                                      0,
                                      szAdminChange,
                                      ARRAYSIZE(szAdminChange),
                                      (va_list *) lpArgs);
            }
            else
            {
                dwErr = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      NULL,
                                      MSG_CLMT_ACCT_CHANGE,
                                      0,
                                      szAdminChange,
                                      ARRAYSIZE(szAdminChange),
                                      NULL);
            }

            SendMessage(GetDlgItem(hwndDlg, ID_STARTUP_DLG_INFO),
                        WM_SETTEXT,
                        wParam,
                        (LPARAM) szAdminChange);

        case WM_COMMAND:
            // Handle command buttons
            switch (wParam)
            {
                case ID_STARTUP_DLG_NEXT:
                    EndDialog(hwndDlg, ID_STARTUP_DLG_NEXT);
                    break;

                case ID_STARTUP_DLG_CANCEL:
                    EndDialog(hwndDlg, ID_STARTUP_DLG_CANCEL);
                    break;

                case ID_STARTUP_DLG_README:
                    ShowReadMe();
                    break;
            }
            break;

        case WM_CLOSE:
            EndDialog(hwndDlg, ID_STARTUP_DLG_CANCEL);
            break;

        default:
            break;
    }

    return FALSE;
}



HRESULT UpdateHardLinkInfoPerUser(
    HKEY    hKeyUser, 
    LPCTSTR UserName, 
    LPCTSTR DomainName,
    LPTSTR  UserSid)
{
    HRESULT hr;
    HINF    hInf;

    if (!MyStrCmpI(UserSid,TEXT("Default_User_SID")))
    {
        return S_OK;
    }
    hr = EnsureDoItemInfFile(g_szToDoINFFileName,ARRAYSIZE(g_szToDoINFFileName));
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = UpdateINFFilePerUser(g_szToDoINFFileName, UserName , UserSid, FALSE);
    hInf = SetupOpenInfFile(g_szToDoINFFileName, NULL, INF_STYLE_WIN4,NULL);
    if (hInf != INVALID_HANDLE_VALUE)
    {
        INT LineCount,LineNo;
        INFCONTEXT InfContext;

        LineCount = (UINT)SetupGetLineCount(hInf,TEXT("Folder.HardLink.Peruser"));
        if ((LONG)LineCount > 0)
        {   
            for (LineNo = 0; LineNo < LineCount; LineNo++)
            {
                BOOL	b0, b1, b2, b3;
                TCHAR	szKeyName[MAX_PATH], szType[10], 
						szFileName[MAX_PATH+1], szExistingFileName[MAX_PATH+1];

                if (!SetupGetLineByIndex(hInf,TEXT("Folder.HardLink.Peruser"),LineNo,&InfContext))
                {
                    continue;
                }
				b0 = SetupGetStringField(&InfContext,0,szKeyName,ARRAYSIZE(szKeyName),NULL);
                b1 = SetupGetStringField(&InfContext,1,szType,ARRAYSIZE(szType),NULL);
                b2 = SetupGetStringField(&InfContext,2,szFileName,ARRAYSIZE(szFileName),NULL);
                b3 = SetupGetStringField(&InfContext,3,szExistingFileName,ARRAYSIZE(szExistingFileName),NULL);
                if (!b0 || !b1 || !b2 || !b3)
                {
                    continue;
                }

                AddHardLinkEntry(szFileName,szExistingFileName,szType,NULL,NULL,szKeyName);
            }
        }
        SetupCloseInfFile(hInf);
    }
Cleanup :
    return hr;
}



VOID RemoveFromRunKey(
    LPCTSTR lpCLMTOption    // Option to be deleted from Run key
)
{
    HKEY  hRunKey;
    LONG  lRet;
    TCHAR szRunValue[MAX_PATH];
    DWORD cbRunValue;
    DWORD dwType;

    // Remove CLMT from registry Run key
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT_RUN_KEY, &hRunKey);
    if (lRet == ERROR_SUCCESS)
    {
        cbRunValue = sizeof(szRunValue);

        lRet = RegQueryValueEx(hRunKey, 
                               TEXT_CLMT_RUN_VALUE, 
                               NULL,
                               &dwType,
                               (LPBYTE) szRunValue,
                               &cbRunValue);
        if (lRet == ERROR_SUCCESS)
        {
            RemoveSubString(szRunValue, lpCLMTOption);

            // Search if there is another option or not
            // If none, we can safely delete Run key
            if (StrChr(szRunValue, TEXT('/')) == NULL)
            {
                RegDeleteValue(hRunKey, TEXT_CLMT_RUN_VALUE);                
            }
            else
            {
                // Other option exists, save the new Run value to registry
                RegSetValueEx(hRunKey,
                              TEXT_CLMT_RUN_VALUE, 
                              0,
                              REG_SZ, 
                              (CONST BYTE *) szRunValue, 
                              lstrlen(szRunValue) * sizeof(TCHAR));
            }
        }

        RegCloseKey(hRunKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\criteria.c ===
#include "StdAfx.h"
#include <stddef.h>
#include <objidl.h>
#include <objbase.h>
#include <shlobj.h>
#include <wtsapi32.h>
#include <psapi.h>


// Log file created by "winnt32 /checkupgradeonly"
#define TEXT_UPGRADE_LOG                TEXT("%SystemRoot%\\Upgrade.txt")

// Value name in registry to keep track of machine state
#define CLMT_MACHINE_STATE_REG_VALUE    TEXT("MachineState")

// Read me file name
#define TEXT_README_FILE                TEXT("Readme.txt")

// constants used to determine SKU
#define SKU_SRV         1
#define SKU_ADS         2
#define SKU_DTC         3

// Maximum entries for list of applications running on the system
#define MAX_APP_ENTRIES     100

typedef struct _UPGRADE_LOG_PARAM
{
    LPVOID lpText;
    size_t cbText;
    BOOL   fUnicode;
} UPGRADE_LOG_PARAM, *PUPGRADE_LOG_PARAM;

typedef struct _stAppListParam
{
    DWORD  dwNumEntries;
    LPTSTR lpAppName[MAX_APP_ENTRIES];
} APPLIST_PARAM, *PAPPLIST_PARAM;

typedef UINT (WINAPI* PFNGETMODULENAME)(HWND, LPTSTR, UINT);
typedef HMODULE (WINAPI* PFNGETMODULEHANDLE)(LPCTSTR);

typedef struct _GETMODULENAME
{
    PFNGETMODULENAME pfn;
    PFNGETMODULEHANDLE pfnGetModuleHandle;
    TCHAR szfname[MAX_PATH];
    TCHAR szUser32[8];
    HWND hWnd;
    PVOID pvCode;
} GETMODULENAME, *PGETMODULENAME;


BOOL LaunchWinnt32(LPCTSTR);
BOOL AskUserForDotNetCDPath(LPTSTR);
BOOL FindUpgradeLog(VOID);
BOOL IsDotNetWinnt32(LPCTSTR);
INT ShowUpgradeLog(VOID);
BOOL CheckUnsupportComponent(LPVOID, BOOL);
BOOL CALLBACK UpgradeLogDlgProc(HWND, UINT, WPARAM, LPARAM);
HRESULT ReadTextFromFile(LPCTSTR, LPVOID*, size_t*, BOOL*);
BOOL IsOperationOK(DWORD, DWORD, LPDWORD, PUINT);
BOOL CALLBACK EnumWindowProc();
BOOL CALLBACK StartUpDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL StartProcess(LPCTSTR, LPTSTR, LPCTSTR);


LPCTSTR GetWindowModuleFileNameOnly(HWND hWnd, LPTSTR lpszFile, DWORD cchFile);


//-----------------------------------------------------------------------------
//
//  Function:   CheckSystemCriteria
//
//  Synopsis:   
//
//  Returns:    - Ok the continue the tool
//              - Not ok to continue the tools
//              - Unexpected error occured
//
//  History:    09/14/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL CheckSystemCriteria(VOID)
{
    HRESULT hr;
    LCID    lcid;
    OSVERSIONINFOEX osviex;

    if (IsNEC98())
    {
        DoMessageBox(GetConsoleWindow(), IDS_NEC98, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    if (IsIA64())
    {
        DoMessageBox(GetConsoleWindow(), IDS_IA64, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    if (g_dwRunningStatus == CLMT_DOMIG)
    {
        if (!IsNT5())
        {
            DoMessageBox(GetConsoleWindow(), IDS_NT5, IDS_MAIN_TITLE, MB_OK);
            return FALSE;
        }

        if (IsDomainController())
        {
            // If this machine is a domain controller, we need W2K SP2
            ZeroMemory(&osviex, sizeof(OSVERSIONINFOEX));
            osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
            GetVersionEx((LPOSVERSIONINFO) &osviex);

            if (osviex.wServicePackMajor < 2)
            {
                DoMessageBox(GetConsoleWindow(), IDS_NT5SP2, IDS_MAIN_TITLE, MB_OK);
                return FALSE;
            }

            //
            // Also pop up the message asking admin to take machine
            // off the network if it is in DC replication servers
            //
            DoMessageBox(GetConsoleWindow(),
                         IDS_DC_REPLICA_OFFLINE,
                         IDS_MAIN_TITLE,
                         MB_OK);
        }

    }
    else if (g_dwRunningStatus == CLMT_CLEANUP_AFTER_UPGRADE)
    {
        if (!IsDotNet())
        {
            return FALSE;
        }
    }
    else
    {
        // noop
    }

    if (IsOnTSClient())
    {
        DoMessageBox(GetConsoleWindow(), IDS_ON_TS_CLIENT, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    if (IsOtherSessionOnTS())
    {
        DoMessageBox(GetConsoleWindow(), IDS_TS_CLOSE_SESSION, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    hr = GetSavedInstallLocale(&lcid);
    if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
    {
        hr = SaveInstallLocale();
        if (FAILED(hr))
        {   
            return FALSE;
        }
    }    

    return TRUE;
}


BOOL IsOneInstance(VOID)
{
    HRESULT hr;
    TCHAR   szGlobalText[MAX_PATH];

    hr = StringCchPrintf(szGlobalText,
                         ARRAYSIZE(szGlobalText),
                         TEXT("Global\\%s"),
                         TEXT("CLMT Is Running"));
    if (FAILED(hr))
    {
        return FALSE;
    }

    g_hMutex = CreateMutex(NULL, FALSE, szGlobalText);
    if ((g_hMutex == NULL) && (GetLastError() == ERROR_PATH_NOT_FOUND)) 
    {
        g_hMutex = CreateMutex(NULL, FALSE, TEXT("CLMT Is Running"));
        if (g_hMutex == NULL) 
        {
            //
            // An error (like out of memory) has occurred.
            // Bail now.
            //
            DoMessageBox(GetConsoleWindow(), IDS_OUT_OF_MEMORY, IDS_MAIN_TITLE, MB_OK);            

            return FALSE;
        }     
    }

    //
    // Make sure we are the only process with a handle to our named mutex.
    //
    if ((g_hMutex == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ALREADY_RUNNING, IDS_MAIN_TITLE, MB_OK);            

        return FALSE;
    }

    return TRUE;
}



BOOL CheckAdminPrivilege(VOID)
{
    BOOL bIsAdmin;
    BOOL bRet = FALSE;

    if (!IsAdmin())
    {
        if (g_dwRunningStatus == CLMT_DOMIG)
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
        }
        else if ( (g_dwRunningStatus == CLMT_CURE_PROGRAM_FILES) 
                  || (g_dwRunningStatus == CLMT_CURE_ALL) )
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN_RELOGON, IDS_MAIN_TITLE, MB_OK);
        }
        else if (g_dwRunningStatus == CLMT_CLEANUP_AFTER_UPGRADE)
        {
            DoMessageBox(GetConsoleWindow(), IDS_ADMIN_LOGON_DOTNET, IDS_MAIN_TITLE, MB_OK);
        }

        return FALSE;
    }

    if(!DoesUserHavePrivilege(SE_SHUTDOWN_NAME)
       || !DoesUserHavePrivilege(SE_BACKUP_NAME)
       || !DoesUserHavePrivilege(SE_RESTORE_NAME)
       || !DoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    if(!EnablePrivilege(SE_SHUTDOWN_NAME,TRUE)
        || !EnablePrivilege(SE_BACKUP_NAME,TRUE)
        || !EnablePrivilege(SE_RESTORE_NAME,TRUE)
        || !EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) 
    {
        DoMessageBox(GetConsoleWindow(), IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);
        return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
//
//  Function:   CheckCLMTStatus
//
//  Synopsis:   Check the machine status and CLMT running mode.
//
//  Returns:    S_OK - Ok the continue the tool
//              S_FALSE - Not ok to continue the tools
//              Else - Unexpected error occured
//
//  History:    03/12/2002 rerkboos     created
//              07/09/2002 rerkboos     modified
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT CheckCLMTStatus(
    LPDWORD lpdwCurrentState,   // Current machine state before the operation
    LPDWORD lpdwNextState,      // Next state if the operation finish successfully
    PUINT   lpuResourceID       // Resource ID of the error string
)
{
    HRESULT hr;
    BOOL    bIsOK;

    if (lpdwCurrentState == NULL || lpdwNextState == NULL)
    {
        return E_INVALIDARG;
    }

    // Get the current machine state
    hr = CLMTGetMachineState(lpdwCurrentState);
    if (SUCCEEDED(hr))
    {
        bIsOK = IsOperationOK(*lpdwCurrentState,
                              g_dwRunningStatus,
                              lpdwNextState,
                              lpuResourceID);

        hr = (bIsOK == TRUE ? S_OK : S_FALSE);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsOperationOK
//
//  Synopsis:   Verify that the current operation is okay to perform on current
//              state of the system.
//
//  Returns:    TRUE - ok to perform operation
//              FALSE - otherwise
//
//  History:    03/12/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsOperationOK(
    DWORD   dwCurrentState,     // Current state of the system
    DWORD   dwAction,           // Action to perform
    LPDWORD lpdwNextState,      // Next state after performing the action
    LPUINT  lpuResourceID       // Resource ID for the error message
)
{
    BOOL bRet = FALSE;
    int  i;

    struct CLMT_STATE_MACHINE
    {
        DWORD dwCurrentState;
        DWORD dwAction;
        DWORD dwNextState;
    };
    
    const struct CLMT_STATE_MACHINE smCLMT[] =
    {
        CLMT_STATE_ORIGINAL,            CLMT_DOMIG,                 CLMT_STATE_MIGRATION_DONE,

        CLMT_STATE_MIGRATION_DONE,      CLMT_UNDO_PROGRAM_FILES,    CLMT_STATE_PROGRAMFILES_UNDONE,
        CLMT_STATE_MIGRATION_DONE,      CLMT_UNDO_APPLICATION_DATA, CLMT_STATE_APPDATA_UNDONE,
        CLMT_STATE_MIGRATION_DONE,      CLMT_UNDO_ALL,              CLMT_STATE_ORIGINAL,
        CLMT_STATE_MIGRATION_DONE,      CLMT_CLEANUP_AFTER_UPGRADE, CLMT_STATE_FINISH,
        CLMT_STATE_MIGRATION_DONE,      CLMT_CURE_PROGRAM_FILES,    CLMT_STATE_PROGRAMFILES_CURED,
        CLMT_STATE_MIGRATION_DONE,      CLMT_CURE_AND_CLEANUP,      CLMT_STATE_MIGRATION_DONE,

        CLMT_STATE_MIGRATION_DONE,      CLMT_CURE_ALL,              CLMT_STATE_PROGRAMFILES_CURED,
        CLMT_STATE_PROGRAMFILES_CURED,  CLMT_CURE_ALL,              CLMT_STATE_PROGRAMFILES_CURED,

        CLMT_STATE_PROGRAMFILES_CURED,  CLMT_CLEANUP_AFTER_UPGRADE, CLMT_STATE_FINISH,
        CLMT_STATE_PROGRAMFILES_CURED,  CLMT_CURE_AND_CLEANUP,      CLMT_STATE_FINISH,

        CLMT_STATE_PROGRAMFILES_UNDONE, CLMT_UNDO_APPLICATION_DATA, CLMT_STATE_ORIGINAL,
        CLMT_STATE_PROGRAMFILES_UNDONE, CLMT_UNDO_ALL,              CLMT_STATE_ORIGINAL,
        CLMT_STATE_PROGRAMFILES_UNDONE, CLMT_DOMIG,                 CLMT_STATE_MIGRATION_DONE,

        CLMT_STATE_APPDATA_UNDONE,      CLMT_UNDO_PROGRAM_FILES,    CLMT_STATE_ORIGINAL,
        CLMT_STATE_APPDATA_UNDONE,      CLMT_UNDO_ALL,              CLMT_STATE_ORIGINAL,
        CLMT_STATE_APPDATA_UNDONE,      CLMT_DOMIG,                 CLMT_STATE_MIGRATION_DONE,

        CLMT_STATE_PROGRAMFILES_CURED,  CLMT_CURE_PROGRAM_FILES,    CLMT_STATE_PROGRAMFILES_CURED,
        CLMT_STATE_FINISH,              CLMT_CURE_PROGRAM_FILES,    CLMT_STATE_FINISH,

        CLMT_STATE_FINISH,              CLMT_CURE_ALL,              CLMT_STATE_FINISH,

        0xFFFFFFFF,                     0xFFFFFFFF,                 0xFFFFFFFF
    };

    for (i = 0 ; smCLMT[i].dwCurrentState != 0xFFFFFFFF ; i++)
    {
        if (smCLMT[i].dwCurrentState == dwCurrentState)
        {
            if (smCLMT[i].dwAction == dwAction)
            {
                *lpdwNextState = smCLMT[i].dwNextState;
                bRet = TRUE;
            }
        }
    }

    if (!bRet)
    {
        switch (dwCurrentState)
        {
        case CLMT_STATE_ORIGINAL:
            *lpuResourceID = IDS_BAD_OPERATION_ORIGINAL;
            break;

        case CLMT_STATE_MIGRATION_DONE:
        case CLMT_STATE_PROGRAMFILES_CURED:
            *lpuResourceID = IDS_BAD_OPERATION_MIGDONE;
            break;

        case CLMT_STATE_FINISH:
            *lpuResourceID = IDS_BAD_OPERATION_FINISH;
            break;

        default:
            *lpuResourceID = IDS_OPERATION_NOT_LEGAL;
        }
    }

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   CLMTSetMachineState
//
//  Synopsis:   Set the machine state to CLMT registry
//
//  Returns:    S_OK if value is successfully saved in registry
//
//  History:    03/13/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT CLMTSetMachineState(
    DWORD dwMachineState        // Machine state
)
{
    LONG    lStatus;

    lStatus = SetRegistryValue(HKEY_LOCAL_MACHINE,
                               CLMT_REGROOT,
                               CLMT_MACHINE_STATE_REG_VALUE,
                               REG_DWORD,
                               (LPBYTE) &dwMachineState,
                               sizeof(dwMachineState));

    return HRESULT_FROM_WIN32(lStatus);
}



//-----------------------------------------------------------------------------
//
//  Function:   CLMTGetMachineState
//
//  Synopsis:   Get the machine state from CLMT registry key.
//              If the key does not exist, this function will also set the value
//              of reg key to ORIGINAL state.
//
//  Returns:    S_OK if value is successfully retrieved in registry
//
//  History:    03/13/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT CLMTGetMachineState(
    LPDWORD lpdwMachineState
)
{
    HRESULT hr;
    LONG    lStatus;
    DWORD   dwSize;

    if (lpdwMachineState == NULL)
    {
        return E_INVALIDARG;
    }

    dwSize = sizeof(DWORD);
    lStatus = GetRegistryValue(HKEY_LOCAL_MACHINE,
                               CLMT_REGROOT,
                               CLMT_MACHINE_STATE_REG_VALUE,
                               (LPBYTE) lpdwMachineState,
                               &dwSize);
    if (lStatus == ERROR_FILE_NOT_FOUND)
    {
        // First time running the tool, we don't have the value in registry yet.
        // Set the machine state to ORIGINAL
        *lpdwMachineState = CLMT_STATE_ORIGINAL;
        hr = CLMTSetMachineState(CLMT_STATE_ORIGINAL);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsUserOKWithCheckUpgrade
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsUserOKWithCheckUpgrade(VOID)
{
    TCHAR szI386Path[MAX_PATH];
    BOOL  fRet = FALSE;

    DoMessageBox(GetConsoleWindow(), IDS_ASKFORWINNT32, IDS_MAIN_TITLE, MB_OK);

    // Ask user for path to winnt32.exe
    if (AskUserForDotNetCDPath(szI386Path))
    {
        // Launch Winnt32.exe with checkupgrade switch
        if (LaunchWinnt32(szI386Path))
        {
            // Show upgrade.txt to user, ask them to uninstall
            // incompatible components before running CLMT
            if (FindUpgradeLog())
            {
                if (ShowUpgradeLog() == ID_CONTINUE)
                {
                    fRet = TRUE;
                }
                else
                {
                    DoMessageBox(GetConsoleWindow(), IDS_WINNT32_CANCEL, IDS_MAIN_TITLE, MB_OK);
                    DPF(dlError, TEXT("User choose to stop the process"));
                }
            }
            else
            {
                DPF(dlError, TEXT("Upgrade.txt not found"));
            }
        }
        else
        {
            DPF(dlError, TEXT("Unable to launch Winnt32.exe"));
        }
    }
    else
    {
        DPF(dlError, TEXT("User does not supply the path of Winnt32.exe"));
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   FindUpgradeLog
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL FindUpgradeLog(VOID)
{
    const TCHAR szUpgradeLog[] = TEXT("%systemroot%\\Upgrade.txt");
    TCHAR  szExpUpgradeLog[MAX_PATH];
    BOOL   fRet = FALSE;
    SYSTEMTIME stUTC, stNow;
    WIN32_FILE_ATTRIBUTE_DATA attFileAttr;

    if ( ExpandEnvironmentStrings(szUpgradeLog, szExpUpgradeLog, MAX_PATH) )
    {
        if ( GetFileAttributesEx(szExpUpgradeLog, GetFileExInfoStandard, &attFileAttr) )
        {
            // Upgrade.txt exists, check if it's updated today or not
            if ( FileTimeToSystemTime(&attFileAttr.ftLastWriteTime, &stUTC) )
            {
                GetSystemTime(&stNow);

                if (stUTC.wYear  == stNow.wYear  &&
                    stUTC.wMonth == stNow.wMonth &&
                    stUTC.wDay   == stNow.wDay)
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   LaunchWinnt32
//
//  Synopsis:   Launch Winnt32.exe with "checkupgradeonly" switch
//
//  Returns:    TRUE if winnt32.exe is executed successfully
//              FALSE otherwise
//
//  History:    02/07/2002 rerkboos     created
//              05/20/2002 rerkboos     change parameter to receive CD path
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL LaunchWinnt32(
    LPCTSTR lpCDPath      // Path to Server 2003 CD
)
{
    TCHAR   szWinnt32[MAX_PATH];
    TCHAR   szI386Path[MAX_PATH];
    BOOL    bRet = FALSE;
    HRESULT hr;
    STARTUPINFO siWinnt32;
    PROCESS_INFORMATION piWinnt32;

    TCHAR szCmdLine[] = TEXT("Winnt32.exe /#u:anylocale /checkupgradeonly /unattend /dudisable");

    if (lpCDPath == NULL)
    {
        return FALSE;
    }

    // Construct absolute path to Winnt32.exe
    hr = StringCchCopy(szI386Path, ARRAYSIZE(szI386Path), lpCDPath);
    if (SUCCEEDED(hr))
    {
        ConcatenatePaths(szI386Path, TEXT("i386"), ARRAYSIZE(szI386Path));
        hr = StringCchCopy(szWinnt32, ARRAYSIZE(szWinnt32), szI386Path);
        if (SUCCEEDED(hr))
        {
            ConcatenatePaths(szWinnt32, TEXT("winnt32.exe"), ARRAYSIZE(szWinnt32));
        }
    }

    if ( IsDotNetWinnt32(szWinnt32) )
    {
        ZeroMemory(&siWinnt32, sizeof(STARTUPINFO));
        siWinnt32.cb = sizeof(STARTUPINFO);

        // CreateProcess call conforms to security guideline
        bRet = CreateProcess(szWinnt32,
                             szCmdLine,
                             NULL,
                             NULL,
                             FALSE,
                             NORMAL_PRIORITY_CLASS,
                             NULL,
                             szI386Path,
                             &siWinnt32,
                             &piWinnt32);
        if (bRet)
        {
            // Wait until winnt32.exe finished before return back to CLM tool
            WaitForSingleObject(piWinnt32.hProcess, INFINITE);
            CloseHandle(piWinnt32.hProcess);
            CloseHandle(piWinnt32.hThread);
        }
    }

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   AskUserForDotNetCDPath
//
//  Synopsis:   Ask user to supply the path to Server 2003 CD
//
//  Returns:    TRUE if the path is valid
//              FALSE otherwise
//
//  History:    02/07/2002 rerkboos     created
//              05/20/2002 rerkboos     check for Server 2003 SRV/ADS CD
//              06/10/2002 rerkboos     check for Server 2003 DTC cd
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL AskUserForDotNetCDPath(
    LPTSTR lpCDPath        // Buffer to store path to CD
)
{
    HRESULT  hr;
    BOOL     fRet = FALSE;
    BOOL     bDoBrowseDialog;
    LPMALLOC piMalloc;
    INT      iRet;
    DWORD    dwSKU;
    OSVERSIONINFOEX osviex;

    if (lpCDPath == NULL)
    {
        return FALSE;
    }

    //
    // Check the SKU of current system
    //
    osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((LPOSVERSIONINFO) &osviex);
    if (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER
        || osviex.wProductType == VER_NT_SERVER)
    {
        dwSKU = SKU_SRV;
        
        if (osviex.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            dwSKU = SKU_ADS;
        }

        if (osviex.wSuiteMask & VER_SUITE_DATACENTER)
        {
            dwSKU = SKU_DTC;
        }
    }

    hr = SHGetMalloc(&piMalloc);
    if (SUCCEEDED(hr))
    {
        BROWSEINFO biCDPath;
        LPITEMIDLIST lpiList;

        ZeroMemory(&biCDPath, sizeof(BROWSEINFO));

        biCDPath.hwndOwner = NULL;
        biCDPath.lpszTitle = TEXT("Please supply the Windows Server 2003 CD path");
        biCDPath.pszDisplayName = lpCDPath;
        biCDPath.ulFlags = BIF_EDITBOX | 
                           BIF_NONEWFOLDERBUTTON | 
                           BIF_RETURNONLYFSDIRS;

        bDoBrowseDialog = TRUE;
        while (bDoBrowseDialog)
        {
            // Show the Browse dialog
            lpiList = SHBrowseForFolder(&biCDPath);

            if (lpiList == NULL)
            {
                //
                // if lpiList == NULL, user click Cancel in browse dialog
                //
                iRet = MessageBox(GetConsoleWindow(),
                                  TEXT("You did not supply the path to Windows Server 2003 CD.\nDo you want to continue running CLMT?"),
                                  TEXT("CLMT"),
                                  MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2);

                if (iRet != IDYES)
                {
                    // User choose not to run CLMT any further
                    bDoBrowseDialog = FALSE;
                }
            }
            else
            {
                //
                // User supply path in Browse dialog,
                // check whether it is valid Server 2003 SRV/ADS CD or not
                //
                if (SHGetPathFromIDListW(lpiList, lpCDPath))
                {
                    LPTSTR lpFile;
                    DWORD  cchFile;
                    DWORD  dwAttr;

                    cchFile = lstrlen(lpCDPath) + MAX_PATH;
                    lpFile = MEMALLOC(cchFile * sizeof(TCHAR));
                    if (lpFile)
                    {
                        switch (dwSKU)
                        {
                        case SKU_SRV:
                            // Check if it is SRV CD or not
                            hr = StringCchCopy(lpFile, cchFile, lpCDPath);
                            ConcatenatePaths(lpFile, TEXT("win51is"), cchFile);
                            dwAttr = GetFileAttributes(lpFile);
                            if (dwAttr != INVALID_FILE_ATTRIBUTES)
                            {
                                // This is SRV CD
                                fRet = TRUE;
                                bDoBrowseDialog = FALSE;
                            }
                            else
                            {
                                // We also allow W2K SRV -> Server 2003 ADS
                                hr = StringCchCopy(lpFile, cchFile, lpCDPath);
                                ConcatenatePaths(lpFile, TEXT("win51ia"), cchFile);
                                dwAttr = GetFileAttributes(lpFile);
                                if (dwAttr != INVALID_FILE_ATTRIBUTES)
                                {
                                    // This is ADS CD
                                    fRet = TRUE;
                                    bDoBrowseDialog = FALSE;
                                }
                            }
                            break;

                        case SKU_ADS:
                            // Check if it is ADS CD or not
                            hr = StringCchCopy(lpFile, cchFile, lpCDPath);
                            ConcatenatePaths(lpFile, TEXT("win51ia"), cchFile);
                            dwAttr = GetFileAttributes(lpFile);
                            if (dwAttr != INVALID_FILE_ATTRIBUTES)
                            {
                                // This is ADS CD
                                fRet = TRUE;
                                bDoBrowseDialog = FALSE;
                            }
                            break;

                        case SKU_DTC:
                            // Check if it is DTC CD or not
                            hr = StringCchCopy(lpFile, cchFile, lpCDPath);
                            ConcatenatePaths(lpFile, TEXT("win51id"), cchFile);
                            dwAttr = GetFileAttributes(lpFile);
                            if (dwAttr != INVALID_FILE_ATTRIBUTES)
                            {
                                // This is DTC CD
                                fRet = TRUE;
                                bDoBrowseDialog = FALSE;
                            }
                            break;

                        default:
                            fRet = FALSE;
                            bDoBrowseDialog = TRUE;
                        }

                        if (!fRet)
                        {
                            TCHAR szErrorMsg[512];
                            INT   iRead;

                            iRead = LoadString(GetModuleHandle(NULL),
                                               IDS_WRONG_CD,
                                               szErrorMsg,
                                               ARRAYSIZE(szErrorMsg));
                            if (iRead > 0)
                            {
                                MessageBox(GetConsoleWindow(),
                                           szErrorMsg,
                                           TEXT("CLMT"),
                                           MB_OK);
                            }
                        }

                        MEMFREE(lpFile);
                    }
                }
            }
        }

        if (lpiList)
        {
            IMalloc_Free(piMalloc, lpiList);
        }

        IMalloc_Release(piMalloc);
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsDotNetWinnt32
//
//  Synopsis:   Check if the specified path is Server 2003 family CD
//              lpWinnt32 contains absolute path with winnt32.exe
//
//  Returns:    TRUE if it is Server 2003 winnt32,
//              FALSE otherwise
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsDotNetWinnt32(
    LPCTSTR lpWinnt32       // Absolute path to Winnt32.exe
)
{
    BOOL   fRet = FALSE;
    LPVOID lpBuffer;
    DWORD  cbBuffer;
    UINT   cbFileInfo;
    VS_FIXEDFILEINFO* pFileInfo;

    if (lpWinnt32 == NULL)
    {
        return FALSE;
    }

    // Get the size needed to allocate buffer
    cbBuffer = GetFileVersionInfoSize((LPTSTR) lpWinnt32, NULL);
    if (cbBuffer > 0)
    {
        lpBuffer = MEMALLOC(cbBuffer);
        if (lpBuffer)
        {
            // Get the version info of user's specified winnt32.exe
            if (GetFileVersionInfo((LPTSTR) lpWinnt32, 0, cbBuffer, lpBuffer))
            {
                if (VerQueryValue(lpBuffer,
                                  TEXT("\\"),
                                  (LPVOID*) &pFileInfo,
                                  &cbFileInfo))
                {
                    // Server 2003 Family version is 5.2
                    if (pFileInfo->dwFileVersionMS == 0x00050002)
                    {
                        fRet = TRUE;
                    }
                }
            }

            MEMFREE(lpBuffer);
        }
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   ShowUpgradeLog
//
//  Synopsis:   Display the content of %SystemRoot%\Upgrade.txt
//
//  Returns:    User selection to Stop or Continue operation from dialog box
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
INT ShowUpgradeLog(VOID)
{
    HRESULT hr;
    BOOL    fRet;
    HMODULE hExe;
    LPTSTR  lpBuffer;
    size_t  cchBuffer;
    TCHAR   szUpgradeLog[MAX_PATH];
    INT_PTR nRet = 0;
    UPGRADE_LOG_PARAM lParam;

    // Get the absolute path name for upgrade.txt
    if ( !ExpandEnvironmentStrings(TEXT_UPGRADE_LOG, szUpgradeLog, MAX_PATH) )
    {
        return 0;
    }

    // Read content of upgrade.txt
    // Caller needs to free the buffer if function succeeded
    hr = ReadTextFromFile(szUpgradeLog,
                          &lParam.lpText,
                          &lParam.cbText,
                          &lParam.fUnicode);
    if ( SUCCEEDED(hr) )
    {
        hExe = GetModuleHandle(NULL);

        // Display content of Upgrade.txt in modal dialog
        // The dialog will ask user to continue or stop operation
        nRet = DialogBoxParam(hExe,
                              MAKEINTRESOURCE(IDD_UPGRADE_LOG_TEXT),
                              GetConsoleWindow(),
                              (DLGPROC) UpgradeLogDlgProc,
                              (LPARAM) &lParam);

        MEMFREE(lParam.lpText);
    }

    return (INT) nRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   UpgradeLogDlgProc
//
//  Synopsis:   Dialog box procedure
//
//  Returns:    
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL
CALLBACK
UpgradeLogDlgProc(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL  fBlock;
    WCHAR wszWarning[512];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Init the dialog
            ShowWindow(hwndDlg, SW_SHOWNORMAL);

            // Search for unsupport component in the text context from upgrade.txt
            fBlock = CheckUnsupportComponent( 
                            ((PUPGRADE_LOG_PARAM) lParam)->lpText,
                            ((PUPGRADE_LOG_PARAM) lParam)->fUnicode );
            if (fBlock)
            {
                LoadString(g_hInstDll,
                           IDS_BLOCKING_WARNING,
                           wszWarning,
                           ARRAYSIZE(wszWarning));
                SendMessage(GetDlgItem(hwndDlg, ID_CAPTION2),
                            WM_SETTEXT,
                            wParam,
                            (LPARAM) wszWarning);

                // Disable 'Continue' button if found the unsupport component
                EnableWindow(GetDlgItem(hwndDlg, ID_CONTINUE),
                             FALSE);
            }
            else
            {
                LoadString(g_hInstDll,
                           IDS_UNLOCALIZED_WARNING,
                           wszWarning,
                           ARRAYSIZE(wszWarning));
                SendMessage(GetDlgItem(hwndDlg, ID_CAPTION2),
                            WM_SETTEXT,
                            wParam,
                            (LPARAM) wszWarning);
            }

            // Display text using A or W function depending on type of data
            if ( ((PUPGRADE_LOG_PARAM) lParam)->fUnicode )
            {
                SendMessageW(GetDlgItem(hwndDlg, IDC_TEXT),
                             WM_SETTEXT,
                             wParam,
                             (LPARAM) (((PUPGRADE_LOG_PARAM) lParam)->lpText));
            }
            else
            {
                SendMessageA(GetDlgItem(hwndDlg, IDC_TEXT),
                             WM_SETTEXT,
                             wParam,
                             (LPARAM) (((PUPGRADE_LOG_PARAM) lParam)->lpText));
            }

            SetForegroundWindow(hwndDlg);
            break;

        case WM_COMMAND:
            // Handle command buttons
            switch (wParam)
            {
                case ID_CONTINUE:
                    EndDialog(hwndDlg, ID_CONTINUE);
                    break;

                case ID_STOP:
                    EndDialog(hwndDlg, ID_STOP);
                    break;
            }
            break;

        case WM_CLOSE:
            EndDialog(hwndDlg, ID_STOP);
            break;

        default:
            break;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
//
//  Function:   CheckUnsupportComponent
//
//  Synopsis:   Search for unsupport component in upgrade.txt.
//
//  Returns:    TRUE if unsupport component is found,
//              FALSE otherwise
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      We determined unsupport component by searching for word
//              "must uninstall" in buffer.
//
//-----------------------------------------------------------------------------
BOOL CheckUnsupportComponent(
    LPVOID lpBuffer,        // Text buffer
    BOOL   fUnicode         // Flag indicate if text is Unicode or ANSI
)
{
    BOOL   fRet = FALSE;
    LPVOID lpStr;

    if (fUnicode)
    {
        lpStr = (LPWSTR) StrStrW((LPCWSTR) lpBuffer, L"must uninstall");
    }
    else
    {
        lpStr = (LPSTR) StrStrA((LPCSTR) lpBuffer, "must uninstall");
    }

    if (lpStr)
    {
        fRet = TRUE;
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   ReadTextFromFile
//
//  Synopsis:   Read text from file into buffer
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ReadTextFromFile(
    LPCTSTR lpTextFile,     // Text file name
    LPVOID  *lplpText,      // Pointer to a newly allocated buffer
    size_t  *lpcbText,      // Size of allocated buffer in bytes
    BOOL    *lpfUnicode     // Flag indicates if data is unicode or not (optional)
)
{
    HRESULT hr;
    HANDLE  hFile;
    DWORD   cbRead;
    BOOL    fRet = FALSE;

    if (lpTextFile == NULL || lplpText == NULL || lpcbText == NULL)
    {
        return fRet;
    }

    hFile = CreateFile(lpTextFile, 
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // Get the size of memory big enough to store text file,
        // plus a null terminator
        *lpcbText = GetFileSize(hFile, NULL) + sizeof(TCHAR);
        
        *lplpText = MEMALLOC(*lpcbText);
        if (*lplpText != NULL)
        {
            fRet = ReadFile(hFile, *lplpText, *lpcbText, &cbRead, NULL);
            if (fRet)
            {
                // Set the unicode flag if user supplied the pointer
                if (lpfUnicode != NULL)
                {
                    *lpfUnicode = IsTextUnicode(*lplpText, cbRead, NULL);
                }
            }
            else
            {
                // Failed to read text file
                MEMFREE(*lplpText);
                *lplpText = NULL;
                *lpcbText = 0;
            }
        }
        else
        {
            // HeapAlloc failed
            *lpcbText = 0;
        }

        CloseHandle(hFile);
    }

    if (fRet)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   IsNT5
//
//  Descrip:    Check whether current OS is NT5 (Server class)
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001  xiaoz       created
//              02/18/2002  rerkboos    add code to check more criteria
//              06/10/2002  rerkboos    allow DTC to run
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL IsNT5(VOID)
{
    OSVERSIONINFOEX osviex;

    ZeroMemory( &osviex,sizeof(OSVERSIONINFOEX) );
    
    osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO) &osviex) )
    {
        return ( (osviex.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
                 (osviex.dwMajorVersion == 5) &&
                 (osviex.dwMinorVersion == 0) &&
                 ( (osviex.wSuiteMask & VER_SUITE_ENTERPRISE) ||
                   (osviex.wProductType == VER_NT_SERVER) ||
                   (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER) ) &&
                 (osviex.wProductType != VER_NT_WORKSTATION) );
    }

    return FALSE;
}


//-----------------------------------------------------------------------
//
//  Function:   IsDotNet
//
//  Descrip:    Check whether current OS is Windows Server 2003
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    07/09/2002  rerkboos       created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL IsDotNet(VOID)
{
    OSVERSIONINFOEX osviex;

    ZeroMemory( &osviex,sizeof(OSVERSIONINFOEX) );
    
    osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO) &osviex) )
    {
        return ( (osviex.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
                 (osviex.dwMajorVersion == 5) &&
                 (osviex.dwMinorVersion == 2) &&
                 ( (osviex.wSuiteMask & VER_SUITE_ENTERPRISE) ||
                   (osviex.wProductType == VER_NT_SERVER) ||
                   (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER) ) &&
                 (osviex.wProductType != VER_NT_WORKSTATION) );
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsNEC98
//
//  Synopsis:   Check whether this machine is NEC98 platform or not.
//
//  Returns:    TRUE if it is NEC98 machine, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      Code is stolen from Winnt32
//
//-----------------------------------------------------------------------------
BOOL IsNEC98(VOID)
{
    BOOL IsNEC98;

    IsNEC98 = ( (GetKeyboardType(0) == 7) && 
                ((GetKeyboardType(1) & 0xff00) == 0x0d00) );

    return (IsNEC98);
}



//-----------------------------------------------------------------------------
//
//  Function:   IsIA64
//
//  Synopsis:   Check whether the program is running on 64-bit machine or not
//
//  Returns:    TRUE if it is running on 64-bit machine, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      Code is stolen from Winnt32
//
//-----------------------------------------------------------------------------
BOOL IsIA64(VOID)
{
    ULONG_PTR p;
    NTSTATUS status;

    status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessWow64Information,
                                       &p,
                                       sizeof(p),
                                       NULL);

    return (NT_SUCCESS(status) && p);
}



//-----------------------------------------------------------------------------
//
//  Function:   IsDomainController
//
//  Synopsis:   Check whether the machine is a domain controller or not
//
//  Returns:    BOOL
//
//  History:    08/13/2002  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsDomainController(VOID)
{
    HRESULT hr;
    BOOL    bIsDC = FALSE;
    TCHAR   szDCName[MAX_PATH];
    DWORD   cchDCName;

    cchDCName = ARRAYSIZE(szDCName);
    hr = GetDCInfo(&bIsDC, szDCName, &cchDCName);

    return bIsDC;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsOnTSClient
//
//  Synopsis:   Check whether the program is running in terminal session or not
//
//  Returns:    TRUE if it is running in terminal session, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsOnTSClient(VOID)
{
    return GetSystemMetrics(SM_REMOTESESSION);
}      



//-----------------------------------------------------------------------------
//
//  Function:   IsTSInstalled
//
//  Synopsis:   Check whether Terminal Services is installed 
//
//  Returns:    TRUE if TS is installed, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsTSInstalled(VOID)
{
    ULONGLONG ullConditionMask;
    OSVERSIONINFOEX osviex;
    BOOL fRet = FALSE;

    ullConditionMask = 0;
    ullConditionMask = VerSetConditionMask(ullConditionMask,
                                           VER_SUITENAME,
                                           VER_AND);

    ZeroMemory(&osviex, sizeof(osviex));
    osviex.dwOSVersionInfoSize = sizeof(osviex);
    osviex.wSuiteMask = VER_SUITE_TERMINAL;

    fRet = VerifyVersionInfo(&osviex, VER_SUITENAME, ullConditionMask);

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsTSConnectionEnabled
//
//  Synopsis:   Check whether the connection to Terminal Services is enabled
//
//  Returns:    TRUE if it is enabled, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsTSConnectionEnabled(VOID)
{
    HKEY  hKey;
    HKEY  hConnKey;
    TCHAR szKeyName[MAX_PATH];
    DWORD cchKeyName;
    DWORD dwIndex;
    DWORD dwType;
    DWORD dwfEnableWinStation;
    DWORD cbfEnableWinStation;
    LONG  lEnumRet;
    LONG  lRet;
    BOOL  fRet = FALSE;
    FILETIME ft;
    HRESULT  hr;

    cchKeyName = ARRAYSIZE(szKeyName);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT_WINSTATION_KEY,
                        0,
                        KEY_ENUMERATE_SUB_KEYS,
                        &hKey);
    if (ERROR_SUCCESS != lRet)
    {
        return FALSE;
    }

    dwIndex = 0;
    do
    {
        cchKeyName = ARRAYSIZE(szKeyName);

        lEnumRet = RegEnumKeyEx(hKey,
                                dwIndex,
                                szKeyName,
                                &cchKeyName,
                                NULL,
                                NULL,
                                NULL,
                                &ft);
        if (ERROR_SUCCESS == lEnumRet)
        {
            // While there is more key to enumerate
            if (CompareString(LOCALE_ENGLISH,
                              NORM_IGNORECASE,
                              szKeyName,
                              -1,
                              TEXT("Console"),
                              -1)
                != CSTR_EQUAL)
            {
                // Only check for other connection's key, not Console key
                lRet = RegOpenKeyEx(hKey,
                                    szKeyName,
                                    0,
                                    KEY_READ,
                                    &hConnKey);
                if (ERROR_SUCCESS != lRet)
                {
                    fRet = FALSE;
                    break;
                }

                cbfEnableWinStation = sizeof(dwfEnableWinStation);
                lRet = RegQueryValueEx(hConnKey,
                                       TEXT("fEnableWinStation"),
                                       NULL,
                                       &dwType,
                                       (LPBYTE) &dwfEnableWinStation,
                                       &cbfEnableWinStation);

                RegCloseKey(hConnKey);

                if (ERROR_SUCCESS == lRet)
                {
                    // If there is at lease one of connection have WinStation
                    // flag enabled, TS connection can still be made
                    if ( dwfEnableWinStation )
                    {
                        fRet = TRUE;
                        break;
                    }
                }
            }
        }

        dwIndex++;

    } while(ERROR_SUCCESS == lEnumRet);

    RegCloseKey(hKey);

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsTSServiceRunning
//
//  Synopsis:   Check whether the TS service is runnning or not
//
//  Returns:    TRUE if it is running, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//
//  Notes:      Stolen from Termsrv test code
//
//-----------------------------------------------------------------------------
BOOL IsTSServiceRunning(VOID)
{
    BOOL fRet = FALSE;

    SC_HANDLE hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController)
    {
        SC_HANDLE hTermServ = OpenService(hServiceController,
                                          TEXT("TermService"),
                                          SERVICE_QUERY_STATUS);
        if (hTermServ)
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus))
            {
                fRet = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            }
            
            CloseServiceHandle(hTermServ);
        }

        CloseServiceHandle(hServiceController);
    }

    return fRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   IsOtherSessionOnTS
//
//  Synopsis:   Check whether there is other TS sessions are connected.
//
//  Returns:    TRUE if there is remote session connected, FALSE otherwise
//
//  History:    02/18/2001  Rerkboos    Created
//              04/17/2002  Rerkboon    Fix bug 558942
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsOtherSessionOnTS(VOID)
{
    BOOL  fRet;
    DWORD dwSessionCount;
    PWTS_SESSION_INFO pwtsSessionInfo;

    fRet = WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,
                                0,
                                1,
                                &pwtsSessionInfo,
                                &dwSessionCount);
    if (fRet)
    {
        DWORD i;
        DWORD dwClients = 0;

        for (i = 0 ; i < dwSessionCount ; i++)
        {
            // Check to see how many clients connect to TS server
            if (pwtsSessionInfo[i].State != WTSListen
                && pwtsSessionInfo[i].State != WTSIdle
                && pwtsSessionInfo[i].State != WTSReset
                && pwtsSessionInfo[i].State != WTSDown
                && pwtsSessionInfo[i].State != WTSInit)
            {
                dwClients++;
            }
        }

        fRet = (dwClients > 1 ? TRUE : FALSE);

        // BUG 558942: free the memory
        WTSFreeMemory(pwtsSessionInfo);
    }

    return fRet;
}


#define TS_POLICY_SUB_TREE              TEXT("Software\\Policies\\Microsoft\\Windows NT\\Terminal Services")
#define POLICY_DENY_TS_CONNECTIONS      TEXT("fDenyTSConnections")
#define APPLICATION_NAME                TEXT("Winlogon")
#define WINSTATIONS_DISABLED            TEXT("WinStationsDisabled")

HRESULT DisableWinstations(
    DWORD   dwDisabled,
    LPDWORD lpdwPrevStatus
)
{
    HRESULT hr = S_OK;
    LONG    lRet;
    BOOL    bRet;
    BOOL    bPolicyOK;
    DWORD   fDenyTSConnections;
    DWORD   cbfDenyTSConnections;
    TCHAR   szCurrentState[2];
    LPTSTR  lpStopString;

    if (IsTSServiceRunning())
    {
        //
        // Get the current state of WinStations
        //
        if (lpdwPrevStatus)
        {
            GetProfileString(APPLICATION_NAME,
                             WINSTATIONS_DISABLED,
                             TEXT("0"),
                             szCurrentState,
                             ARRAYSIZE(szCurrentState));
            *lpdwPrevStatus = _tcstoul(szCurrentState, &lpStopString, 10);
        }

        //
        // Check if group policy has thrown the big switch, if so, inform and refuse any changes
        //
        fDenyTSConnections = 0;
        cbfDenyTSConnections = sizeof(fDenyTSConnections);

        lRet = GetRegistryValue(HKEY_LOCAL_MACHINE, 
                                TS_POLICY_SUB_TREE,
                                POLICY_DENY_TS_CONNECTIONS,
                                (LPBYTE) &fDenyTSConnections,
                                &cbfDenyTSConnections);
        if (lRet == ERROR_SUCCESS)
        {
            if (fDenyTSConnections)
            {   
                // Machine policy deny TS connection
                bPolicyOK = FALSE;
            }
            else
            {
                // Machine policy allows TS connection
                bPolicyOK = TRUE;
            }
        }
        else if (lRet == ERROR_FILE_NOT_FOUND)
        {
            bPolicyOK = TRUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lRet);
        }

        //
        // If policy allows to change connection status
        //
        if (SUCCEEDED(hr) && bPolicyOK)
        {
            if (dwDisabled)
            {
                bRet = WriteProfileString(APPLICATION_NAME,
                                          WINSTATIONS_DISABLED,
                                          TEXT("1"));
            }
            else
            {
                bRet = WriteProfileString(APPLICATION_NAME,
                                          WINSTATIONS_DISABLED,
                                          TEXT("0"));
            }

            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   DisplayTaskList
//
//  Synopsis:   Display the list of running task on the system
//
//  Returns:    TRUE if there is tasks running
//              FALSE if there is no other tasks running
//
//  History:    07/09/2002  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL DisplayTaskList()
{
    HRESULT hr;
    BOOL    bRet = FALSE;
    DWORD   i;
    DWORD   cchTaskList;
    LPTSTR  lpTaskList = NULL;
    DWORD   cchTask;
    LPTSTR  lpTask = NULL;
    DWORD   dwMaxCchLen;
    TCHAR   szTemp[512];
    TCHAR   szCaption[MAX_PATH];
    TCHAR   szHeader[MAX_PATH];
    APPLIST_PARAM AppListParam;

    // Init the AppList structure
    AppListParam.dwNumEntries = 0;
    for (i = 0 ; i < MAX_APP_ENTRIES ; i++)
    {
        AppListParam.lpAppName[i] = NULL;
    }

    if (LoadString(g_hInstDll, IDS_PRODUCT_NAME, szCaption, ARRAYSIZE(szCaption)) <= 0
        || LoadString(g_hInstDll, IDS_CLOSE_APP_TEXT, szHeader, ARRAYSIZE(szHeader)) <= 0)
    {
        goto CLEANUP;
    }

    bRet = EnumDesktopWindows(NULL, (WNDENUMPROC) &EnumWindowProc, (LPARAM) &AppListParam);
    if (AppListParam.dwNumEntries > 0)
    {
        cchTaskList = lstrlen(szHeader);
        dwMaxCchLen = 0;
        for (i = 0 ; i < AppListParam.dwNumEntries ; i++)
        {
            cchTask = lstrlen(AppListParam.lpAppName[i]) + 4;
            if (cchTask > dwMaxCchLen)
            {
                dwMaxCchLen = cchTask;
            }

            cchTaskList += cchTask;
        }

        // Allocate the string long enough to store a Task name
        lpTask = (LPTSTR) MEMALLOC(dwMaxCchLen * sizeof(TCHAR));
        if (lpTask != NULL)
        {
            // Allocate the string for all the tasks
            lpTaskList = (LPTSTR) MEMALLOC(cchTaskList * sizeof(TCHAR));
            if (lpTaskList != NULL)
            {
                hr = StringCchCopy(lpTaskList, cchTaskList, szHeader);
                for (i = 0 ; i < AppListParam.dwNumEntries ; i++)
                {
                    hr = StringCchPrintf(lpTask,
                                         dwMaxCchLen,
                                         TEXT("- %s\n"),
                                         AppListParam.lpAppName[i]);
                    if (SUCCEEDED(hr))
                    {
                        hr = StringCchCat(lpTaskList,
                                          cchTaskList,
                                          lpTask);
                        if (FAILED(hr))
                        {
                            goto CLEANUP;
                        }
                    }
                }
            }
        }

        MessageBox(GetConsoleWindow(), lpTaskList, szCaption, MB_OK);
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

CLEANUP:

    if (lpTask != NULL)
    {
        MEMFREE(lpTask);
    }

    if (lpTaskList != NULL)
    {
        MEMFREE(lpTaskList);
    }

    for (i = 0 ; i < MAX_APP_ENTRIES ; i++)
    {
        if (AppListParam.lpAppName[i] != NULL)
        {
            MEMFREE(AppListParam.lpAppName[i]);
        }
    }

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   EnumWindowProc
//
//  Synopsis:   A callback function for EnumDesktopWindows() in
//              DisplayTaskList() function.
//
//  Returns:    TRUE if no error occured
//              FALSE if something was wrong
//
//  History:    07/09/2002  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL CALLBACK EnumWindowProc(
    HWND   hwnd,
    LPARAM lParam
)
{
    BOOL    bRet = FALSE;
    HRESULT hr;
    TCHAR   szTitle[MAX_PATH];
    TCHAR   szOwnerFile[MAX_PATH];
    LPCTSTR lpFileName;
    DWORD   dwIndex;
    DWORD   cchLen;
    UINT    ui;
    PFNGETMODULENAME pfnGetWindowModuleFileName;
    
    if (GetWindow(hwnd, GW_OWNER) || !IsWindowVisible(hwnd))
    {
        // Skip child windows or invisible windows
        return TRUE;
    }

    GetWindowText(hwnd, szTitle, MAX_PATH);

    if (szTitle[0] == TEXT('\0'))
    {
        return TRUE;
    }

    if (MyStrCmpI(szTitle, TEXT("Program Manager")) == LSTR_EQUAL)
    {
        return TRUE;
    }

    if (hwnd == GetConsoleWindow())
    {
        // Ignore itself
        return TRUE;
    }

    // Ignore Explorer windows
    lpFileName = GetWindowModuleFileNameOnly(hwnd, szOwnerFile, ARRAYSIZE(szOwnerFile));
    if (StrStrI(szOwnerFile, TEXT("browseui")))
    {
        return TRUE;
    }

    dwIndex = ((PAPPLIST_PARAM) lParam)->dwNumEntries;
    hr = DuplicateString(&(((PAPPLIST_PARAM) lParam)->lpAppName[dwIndex]),
                         &cchLen,
                         szTitle);
    if (SUCCEEDED(hr))
    {
        bRet = TRUE;
        ((PAPPLIST_PARAM) lParam)->dwNumEntries++;
    }

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   ShowStartUpDialog
//
//  Synopsis:   Display startup dialog
//
//  Returns:    none
//
//  History:    08/14/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
INT ShowStartUpDialog()
{
    return (INT) DialogBoxParam(GetModuleHandle(NULL),
                                MAKEINTRESOURCE(IDD_STARTUP_DLG),
                                GetConsoleWindow(),
                                (DLGPROC) StartUpDlgProc,
                                (LPARAM) NULL);
}



//-----------------------------------------------------------------------------
//
//  Function:   StartUpDlgProc
//
//  Synopsis:   Dialog box procedure
//
//  Returns:    
//
//  History:    02/07/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL
CALLBACK
StartUpDlgProc(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    WCHAR wszInfo[1024];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Init the dialog
            ShowWindow(hwndDlg, SW_SHOWNORMAL);

            if (LoadStringW(g_hInstDll,
                            IDS_STARTUP_DLG_INFO,
                            wszInfo,
                            ARRAYSIZE(wszInfo)))
            {
                SendMessage(GetDlgItem(hwndDlg, ID_STARTUP_DLG_INFO),
                            WM_SETTEXT,
                            wParam,
                            (LPARAM) wszInfo);
            }

        case WM_COMMAND:
            // Handle command buttons
            switch (wParam)
            {
                case ID_STARTUP_DLG_NEXT:
                    EndDialog(hwndDlg, ID_STARTUP_DLG_NEXT);
                    break;

                case ID_STARTUP_DLG_CANCEL:
                    EndDialog(hwndDlg, ID_STARTUP_DLG_CANCEL);
                    break;

                case ID_STARTUP_DLG_README:
                    ShowReadMe();
                    break;
            }
            break;

        case WM_CLOSE:
            EndDialog(hwndDlg, ID_STARTUP_DLG_CANCEL);
            break;

        default:
            break;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
//
//  Function:   ShowReadMe
//
//  Synopsis:   Launch notepad to display CLMT readme.txt
//
//  Returns:    none
//
//  History:    08/14/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
VOID ShowReadMe()
{
    HRESULT hr;
    DWORD dwErr;
    DWORD i;
    TCHAR szReadmePath[MAX_PATH];
    TCHAR szNotepad[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];

    dwErr = GetModuleFileName(NULL, szReadmePath, ARRAYSIZE(szReadmePath));
    if (dwErr == 0)
    {
        szReadmePath[0] = TEXT('\0');
    }
    else
    {
        i = lstrlen(szReadmePath);
        while (i > 0 && szReadmePath[i] != TEXT('\\'))
        {
            i--;
        }
        szReadmePath[i + 1] = TEXT('\0');
    }

    hr = StringCchCat(szReadmePath, ARRAYSIZE(szReadmePath), TEXT_README_FILE);

    dwErr = GetFileAttributes(szReadmePath);
    if (dwErr == INVALID_FILE_ATTRIBUTES)
    {
        DoMessageBox(GetConsoleWindow(), IDS_README_NOT_FOUND, IDS_MAIN_TITLE, MB_OK);
    }
    else
    {
        ExpandEnvironmentStrings(TEXT("%systemroot%\\system32\\Notepad.exe"),
                                 szNotepad,
                                 ARRAYSIZE(szNotepad));
        
        hr = StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), szNotepad);
        hr = StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), TEXT(" "));
        hr = StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), szReadmePath);

        StartProcess(szNotepad,
                     szCmdLine,
                     TEXT("."));
    }
}



//-----------------------------------------------------------------------------
//
//  Function:   StartProcess
//
//  Synopsis:   Start a Windows application
//
//  Returns:    TRUE if an application is started
//              FALSE otherwise
//
//  History:    08/14/2002 rerkboos     created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL StartProcess(
    LPCTSTR lpAppName,      // Application name
    LPTSTR  lpCmdLine,      // Application command line
    LPCTSTR lpCurrentDir    // Working directory
)
{
    BOOL bRet = FALSE;
    STARTUPINFO siApp;
    PROCESS_INFORMATION piApp;

    ZeroMemory(&siApp, sizeof(STARTUPINFO));
    siApp.cb = sizeof(STARTUPINFO);

    // CreateProcess call conforms to security guideline
    bRet = CreateProcess(lpAppName,
                         lpCmdLine,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS,
                         NULL,
                         lpCurrentDir,
                         &siApp,
                         &piApp);

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   ThreadProc
//
//  Synopsis:   A procedure that will be run on remote thread
//
//  Returns:    
//
//  History:    08/20/2002 rerkboos     created
//
//  Notes:      Code is copied from Fontspy
//
//-----------------------------------------------------------------------------
DWORD WINAPI ThreadProc(
    PGETMODULENAME pgmn
)
{
    pgmn->szfname[0] = 0;
    if (pgmn->pfnGetModuleHandle(pgmn->szUser32))
    {
        pgmn->pfn(pgmn->hWnd, pgmn->szfname, MAX_PATH);
    }

    return 0;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetWindowModuleFileNameOnly
//
//  Synopsis:   Get the module name that load the current window
//
//  Returns:    
//
//  History:    08/20/2002 rerkboos     created
//
//  Notes:      Code is copied from FontSpy
//
//-----------------------------------------------------------------------------
LPCTSTR GetWindowModuleFileNameOnly(
    HWND   hWnd,
    LPTSTR lpszFile,
    DWORD  cchFile
)
{
    HRESULT hr;
    DWORD   dwProcessID;
    DWORD   dwThreadID;
    HANDLE  hProcess;
    HANDLE  hThread = NULL;
    DWORD   dwXfer;
    PBYTE   pv = NULL;
    LPCTSTR psz;
    UINT    uCodeSize;
    GETMODULENAME gmn;
    
    uCodeSize = (ULONG) GetWindowModuleFileNameOnly - (ULONG) ThreadProc;

    ZeroMemory(&gmn, sizeof(gmn));

    __try
    {
        GetWindowThreadProcessId(hWnd, &dwProcessID);
        hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
        if (!hProcess)
        {
            hr = StringCchCopy(lpszFile, cchFile, TEXT("Access Denied"));
            __leave;
        }

        gmn.hWnd = hWnd;
        
        hr = StringCchCopy(gmn.szUser32, ARRAYSIZE(gmn.szUser32), TEXT("user32"));
        if (FAILED(hr))
        {
            __leave;
        }

        gmn.pfn = (PFNGETMODULENAME) GetProcAddress(
            GetModuleHandle(_T("user32")), 
#ifdef UNICODE
            "GetWindowModuleFileNameW"
#else
            "GetWindowModuleFileNameA"
#endif
            );
        if (!gmn.pfn)
        {
            __leave;
        }

        gmn.pfnGetModuleHandle = (PFNGETMODULEHANDLE)GetProcAddress(
            GetModuleHandle(_T("kernel32")), 
#ifdef UNICODE
            "GetModuleHandleW"
#else
            "GetModuleHandleA"
#endif
            );
        if (!gmn.pfnGetModuleHandle)
        {
            __leave;
        }

        pv = (PBYTE)VirtualAllocEx(
            hProcess, 
            0, 
            uCodeSize + sizeof(gmn), 
            MEM_COMMIT, 
            PAGE_EXECUTE_READWRITE
            );
        if (!pv)
        {
            __leave;
        }

        WriteProcessMemory(
            hProcess, 
            pv, 
            &gmn, 
            sizeof(gmn), 
            &dwXfer
            );

        WriteProcessMemory(
            hProcess, 
            pv+offsetof(GETMODULENAME, pvCode), 
            ThreadProc, 
            uCodeSize, 
            &dwXfer
            );

        hThread = CreateRemoteThread(
            hProcess,
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) (pv + offsetof(GETMODULENAME, pvCode)),
            pv,
            0,
            &dwThreadID
            );

        WaitForSingleObject(hThread, INFINITE);
        ReadProcessMemory(hProcess, pv, &gmn, sizeof(gmn), &dwXfer);
    }
    __finally
    {
        if (pv)
        {
            //VirtualFreeEx(hProcess, pv, uCodeSize+sizeof(gmn), MEM_DECOMMIT);
            VirtualFreeEx(hProcess, pv, 0, MEM_RELEASE);
        }

        if (hProcess != NULL)
        {
            CloseHandle(hProcess);
        }

        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
    }

    hr = StringCchCopy(lpszFile, cchFile, gmn.szfname);
    
    psz = _tcsrchr(lpszFile, _T('\\'))+1;
    if (!psz)
    {
        psz = lpszFile;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\iis.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iis.cpp

Abstract:

    Search IIS metabase and replace the matching value data.

Author:

    Geoffrey Guo (geoffguo) 15-Jan-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#define INITGUID
#define MD_DEFAULT_TIMEOUT 10000    //10 second
#define NOT_USE_SAFE_STRING  
#include "clmt.h"
#include <OLE2.H>
#include <coguid.h>
#include "iiscnfg.h"
#define STRSAFE_LIB
#include <strsafe.h>

#define TEXT_METABASE_SECTION   TEXT("MetabaseSettings")

DWORD       RegType2MetaType(DWORD);
DWORD       MetaType2RegType(DWORD);



/*
*/
HRESULT MigrateMetabaseSettings(HINF hInf)
{
    HRESULT         hr = E_FAIL;
    BOOL            bRet;
    LONG            lComponentCount;
    LONG            lLineIndex;
    INFCONTEXT      context;
    LPCTSTR         lpSectionName;
    TCHAR           szKeyName[MAX_PATH];
    TCHAR           szDataType[16], szUpdateType[16];
    TCHAR           szValueName[MAX_PATH];
    LPTSTR          lpValueData = NULL;
    DWORD           cchReqSize, dwUpdateType;

    const TCHAR szPerSystemSection[] = TEXT_METABASE_SECTION;

    if (hInf == INVALID_HANDLE_VALUE)
    {
        hr =  E_INVALIDARG;
        goto exit;
    }

    DPF(REGmsg, TEXT("Enter MigrateMetabaseSettings:"));

    lpSectionName = szPerSystemSection;

    // Get all components from appropriate section
    lComponentCount = SetupGetLineCount(hInf, lpSectionName);
    if (!lComponentCount)
    {
        hr = S_FALSE;
        goto exit;
    }

    for (lLineIndex = 0 ; lLineIndex < lComponentCount ; lLineIndex++)
    {        
        bRet = SetupGetLineByIndex(hInf, lpSectionName, lLineIndex, &context);
        if (!bRet)
        {
            DPF(REGwar, TEXT("Failed to get line %d, in section %s"),lLineIndex,lpSectionName);
            continue;
        }        
        bRet = SetupGetStringField(&context,
                                   1,
                                   szUpdateType,
                                   ARRAYSIZE(szUpdateType),
                                   &cchReqSize);
        if (!bRet)
        {
            DPF(REGwar, TEXT("Failed to get field 1 in line %d in section %s"),lLineIndex,lpSectionName);
            continue;
        }
        dwUpdateType = _tstoi(szUpdateType);
        switch (dwUpdateType)
        {
            case 0:
                bRet = SetupGetStringField(&context,
                                           2,
                                           szKeyName,
                                           ARRAYSIZE(szKeyName),
                                           &cchReqSize),
                       SetupGetStringField(&context,
                                           3,
                                           szDataType,
                                           ARRAYSIZE(szDataType),
                                           &cchReqSize),
                       SetupGetStringField(&context,
                                            4,
                                            szValueName,
                                            ARRAYSIZE(szValueName),
                                            &cchReqSize);
                if (!bRet)
                {
                    DPF(REGwar, TEXT("Failed to get field 2/3/4 in line %d in section %s"),lLineIndex,lpSectionName);
                    continue;
                }
                bRet = SetupGetStringField(&context, 6, NULL, 0, &cchReqSize);
                if (!bRet)
                {
                    DPF(REGwar, TEXT("Failed to get field 6 size in line %d in section %s"),lLineIndex,lpSectionName);
                    continue;
                }
                lpValueData = (LPTSTR)calloc(cchReqSize, sizeof(TCHAR));
                if (!lpValueData)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                bRet = SetupGetStringField(&context, 6, lpValueData, cchReqSize, &cchReqSize);                                
                if (bRet)
                {
                    //Add metabase value change information to INF file
                    hr = AddRegValueRename(szKeyName, szValueName, NULL, NULL, 
                                          lpValueData, Str2REG(szDataType), 0, 
                                          APPLICATION_DATA_METABASE);
                    if (FAILED(hr))
                    {
                        DPF(REGerr, TEXT("Failed to do meatbase migration"));
                    }
                }
                free(lpValueData);
                break;
            case 1:
                LPTSTR                  lpField[16];
                REG_STRING_REPLACE      myTable;
                HRESULT                 hr1, hr2, hr3;
                for (int i = 0; i <= ARRAYSIZE(lpField); i++)
                {
                    lpField[i] = NULL;
                }
                hr = ReadFieldFromContext(&context, lpField, 2, 4);
                if (hr != S_OK)
                {
                    DPF(REGwar, TEXT("Failed to get field in line %d, in section %s, ReadFieldFromContext returns hr = %d"),lLineIndex,lpSectionName,hr);
                    continue;
                }
                hr1 = Sz2MultiSZ(lpField[3],TEXT(';'));                
                hr2 = Sz2MultiSZ(lpField[4],TEXT(';'));                
                hr3 = ConstructUIReplaceStringTable(lpField[3], lpField[4],&myTable);
                if ( SUCCEEDED(hr1) && SUCCEEDED(hr2) && SUCCEEDED(hr3))
                {
                    hr = MetabaseAnalyze (lpField[2],&myTable,FALSE);
                    if (FAILED(hr))
                    {
                        DPF(REGwar, TEXT("MetabaseAnalyze failed   in line %d, in section %s, hr = %d"),lLineIndex,lpSectionName,hr);
                    }
                }
                else
                {
                    DPF(REGwar, TEXT("Failed to do conversion  in line %d, in section %s, hr1 = %d,hr2 = %d,hr3 = %d"),lLineIndex,lpSectionName,hr1, hr2, hr3);
                }
                for (int i = 0; i <= ARRAYSIZE(lpField); i++)
                {
                    if (lpField[i])
                    {
                        MEMFREE(lpField[i]);
                    }
                }
                break;
        }    
    }

    hr = S_OK;
exit:
    DPF(REGmsg, TEXT("Exit MigrateMetabaseSettings:"));
    return hr;
}


//-----------------------------------------------------------------------//
//
// QueryData()
//
// DESCRIPTION:
// Query and analyze one record metabase data.
//
// pMD_Rec:       Point to a MetaData record
// lpFullKey:     Full key path
// lpValList:     Updated value list
// lpRegStr:      Input parameter structure
//-----------------------------------------------------------------------//
HRESULT QueryData (
    PMETADATA_RECORD        pMD_Rec,
    LPTSTR                  lpFullKey,
    PVALLIST                *lpValList,
    PREG_STRING_REPLACE     lpRegStr,
    BOOL                    bStrChk)
{
    HRESULT hresError = S_OK;
    DWORD   dwType;
    LPTSTR  lpBuff;

    lpBuff = (LPTSTR)pMD_Rec->pbMDData;

    switch (pMD_Rec->dwMDDataType)
    {
        case EXPANDSZ_METADATA:
            dwType = REG_EXPAND_SZ;
            break;

        case MULTISZ_METADATA:
            dwType = REG_MULTI_SZ;
            break;

        case STRING_METADATA:
            dwType = REG_SZ;
            break;

        default:
            goto Exit;
    }

    hresError = ReplaceValueSettings (
                               NULL,
                               lpBuff,
                               pMD_Rec->dwMDDataLen,
                               NULL,
                               dwType,
                               lpRegStr,
                               lpValList,
                               lpFullKey,
                               bStrChk);

Exit:
    return hresError;
}

//-----------------------------------------------------------------------//
//
// SetDataValueChange()
//
// DESCRIPTION:
// Set metabase value based on the value list
//
// lpValList:     Updated value list
// lpFullKey:     Full sub-key path
//-----------------------------------------------------------------------//
HRESULT SetDataValueChange (
IMSAdminBase *pcAdmCom,
METADATA_HANDLE hmdHandle,
PVALLIST *lpValList,
LPTSTR   lpFullKey)
{
    HRESULT  hResult = S_OK;
    PVALLIST lpVal;
    TCHAR    szValueID[16];

    if (*lpValList)
    {
        lpVal = *lpValList;
        
        while (lpVal)
        {
            hResult = StringCchPrintf(szValueID, 15, TEXT("%d"), lpVal->md.dwMDIdentifier);
            if (FAILED(hResult))
            {
                DPF(APPerr,L"IIS:SetDataValueChange:Failed Valud ID %d  is too long", lpVal->md.dwMDIdentifier);
                break;
            }
            //Add metabase value change information to INF file
            hResult = AddRegValueRename(
                                        lpFullKey,
                                        szValueID,
                              